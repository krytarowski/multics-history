ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>lisp_utils_.alm                 
ASSEMBLED ON:	11/05/86  1103.6 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
                                     6  " lisp_utils_.alm
                                     7  
                                     8  " This segment contains the arithmetic functions and
                                     9  " a few other random functions.
                                    10  
                                    11  " translated from PL/I to ALM  28 August 1972 by D.A.Moon
                                    12  " ***** must be bound in with lisp_ and lisp_error_ since
                                    13  " relies on calling through links without the lp loaded.
                                    14  
                                    15  
                                    16  	include	lisp_stack_seg
                                   1-1  " BEGIN INCLUDE FILE lisp_stack_seg.incl.alm
                                   1-2  
                                   1-3  "	lisp stack segment header format
                                   1-4  "	Last modified by Reed 6/21/72
                                   1-5  "
                        000000     1-6  	equ	marked_stack_bottom,0	offset of ptr to bottom of marked stack
                        000002     1-7  	equ	unmkd_stack_bottom,2	offset of ptr to bottom of unmkd_stack
                        000004     1-8  	equ	stack_ptr_ptr,4		offset of ptr to lisp_static_vars_$stack_ptr
                        000006     1-9  	equ	unmkd_ptr_ptr,6		offset of ptr to lisp_static_vars_$unmkd_ptr's offset word
                        000010    1-10  	equ	array_pointer,8		points at cell of array most recently referenced
                        000012    1-11  	equ	nil,10			offset of cell containing pointer to nil...
                        000014    1-12  	equ	true,12			offset of cell containing pointer to t...
                        000016    1-13  	equ	in_pl1_code,14		offset of flag saying whether stack_ptr
                                  1-14  "					& unmkd_ptr or ap and ab|.,x7 are valid...if zero, ap,ab arevalid.
                                  1-15  " table of pointers to operators
                                  1-16  
                        000020    1-17  	equ	bind_op,16
                        000022    1-18  	equ	unbind_op,18
                        000024    1-19  	equ	errset1_op,20
                        000026    1-20  	equ	errset2_op,22
                        000030    1-21  	equ	unerrset_op,24
                        000032    1-22  	equ	call_op,26
                        000034    1-23  	equ	catch1_op,28
                        000036    1-24  	equ	catch2_op,30
                        000040    1-25  	equ	uncatch_op,32
                        000042    1-26  	equ	gensym_data,34	" data for gensym function
                                  1-27  
                        000044    1-28  	equ	system_lp,36		pointer to common linkage section for bound segment.
                        000046    1-29  	equ	iogbind_op,38		operator to help out with compiled iog.
                        000050    1-30  	equ	unseen_go_tag_op,40
                        000052    1-31  	equ	throw1_op,42
                        000054    1-32  	equ	throw2_op,44
                        000056    1-33  	equ	signp_op,46
                        000060    1-34  	equ	type_fields,48
                        000062    1-35  	equ	return_op,50
                        000064    1-36  	equ	err_op,52
                        000066    1-37  	equ	pl1_interface,54
                        000070    1-38  	equ	pl1_lsubr_interface,56
                        000072    1-39  	equ	cons_op,58		operator for compiled cons
                        000074    1-40  	equ	ncons_op,60		opeator for compiled cons with nil
                        000076    1-41  	equ	xcons_op,62		operator for compiled xcons
                        000100    1-42  	equ	begin_list_op,64		operator to begin compiled list code
                        000102    1-43  	equ	append_list_op,66		operator to get new list cell and hook on end
                        000104    1-44  	equ	terminate_list_op,68	operator to finish off list.
                        000106    1-45  	equ	compare_op,70
                        000110    1-46  	equ	link_opr,72
                        000112    1-47  	equ	array_operator,74
                        000114    1-48  	equ	dead_array_operator,76
                        000116    1-49  	equ	store_operator,78
                        000120    1-50  	equ	floating_store_operator,80
                        000122    1-51  	equ	array_info_for_store,82
                        000124    1-52  	equ	array_offset_for_store,84
                        000126    1-53  	equ	array_link_snap_opr,86
                        000130    1-54  	equ	create_string_desc_op,88	string desc for PL/I call
                        000132    1-55  	equ	create_array_desc_op,90	array desc for PL/I call
                        000134    1-56  	equ	pl1_call_op,92		PL/I call operator
                        000136    1-57  	equ	cons_string_op,94		operator to cons up a string
                        000140    1-58  	equ	create_varying_string_op,96
                        000142    1-59  	equ	unwp1_op,98		unwind-protect start
                        000144    1-60  	equ	unwp2_op,100		ditto, for compat.
                        000146    1-61  	equ	ununwp_op,102		End unwind-protect.
                        000150    1-62  	equ	irest_return_op,104 	Interrupt restore return
                        000152    1-63  	equ	pl1_call_nopop_op,106	PL1 call, dont pop PL1 frame
                        000154    1-64  	equ	rcv_char_star_op,108	Receive char * result, pop pl1frame
                                  1-65  	" spare 110
                        000174    1-66  	equ	begin_unmkd_stack,124	beginning of unmkd_stack
                                  1-67  
                                  1-68  " END INCLUDE FILE lisp_stack_seg.incl.alm
                                  1-69  
                                    17  	include	stack_header
                                   2-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   2-2  "
                                   2-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   2-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   2-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   2-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   2-7  
                                   2-8  " HISTORY COMMENTS:
                                   2-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  2-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  2-11  "     added the heap_header_ptr definition
                                  2-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  2-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  2-14  "     Modified to support control point management.  These changes were
                                  2-15  "     actually made in February 1985 by G. Palter.
                                  2-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  2-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  2-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  2-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  2-20  "     some space int the stack header and change the cpd_ptr unal to
                                  2-21  "     cpm_data_ptr (ITS pair).
                                  2-22  "                                                      END HISTORY COMMENTS
                                  2-23  
                        000004    2-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    2-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  2-26  
                        000010    2-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    2-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    2-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    2-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    2-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    2-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    2-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    2-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  2-35  
                        000020    2-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    2-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    2-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    2-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  2-40  
                        000030    2-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    2-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    2-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    2-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  2-45  
                        000040    2-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    2-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    2-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    2-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  2-50  
                        000050    2-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    2-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    2-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    2-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  2-55  
                        000060    2-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    2-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    2-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    2-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    2-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    2-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    2-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    2-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    2-64  	equ	stack_header_end,64			length of stack header
                                  2-65  
                                  2-66  
                                  2-67  
                                  2-68  
                        000000    2-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    2-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  2-71  
                                  2-72  "	The  following constant is an offset within the  pl1  operators table.
                                  2-73  "	It  references a  transfer vector table.
                                  2-74  
                        000551    2-75  	bool	tv_offset,551
                                  2-76  
                                  2-77  
                                  2-78  "	The  following constants are offsets within this transfer vector table.
                                  2-79  
                        001170    2-80  	equ	call_offset,tv_offset+271
                        001171    2-81  	equ	push_offset,tv_offset+272
                        001172    2-82  	equ	return_offset,tv_offset+273
                        001173    2-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    2-84  	equ	entry_offset,tv_offset+275
                                  2-85  
                                  2-86  
                                  2-87  " 	END INCLUDE FILE stack_header.incl.alm
                        000014      18  	equ	t,true
                                    19  	include	lisp_object_types
                                   3-1  
                                   3-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   3-3  "
                                   3-4  " D.A.Moon 14 July 72
                                   3-5  
                                   3-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   3-7  "they should be used with cana instructions in the dl mode.
                                   3-8  "
                                   3-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  3-10  
                                  3-11  
                                  3-12  
                        077700    3-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  3-14  
                        040000    3-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    3-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    3-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    3-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    3-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    3-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    3-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    3-22  	bool	String,004000		"points at a lisp character string
                        002000    3-23  	bool	Subr,002000		"points at subr link
                        000400    3-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    3-25  	bool	Array,000200		"points at an array,
                                  3-26  					" which is a special kind of subr
                        067500    3-27  	bool	Unevalable,067500		"any of these bits means
                                  3-28  					" does not have car and cdr
                        001000    3-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    3-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  3-31  
                                  3-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  3-33  
                        040047    3-34  	bool	fixnum_type,040047
                        020047    3-35  	bool	flonum_type,020047
                                  3-36  
                                  3-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                    20  	include	lisp_error_codes
                                   4-1  
                                   4-2  " BEGIN INCLUDE FILE lisp_error_codes.incl.alm
                                   4-3  
                                   4-4  "This contains codes to be stored on the unmkd pdl before calling
                                   4-5  "lisp_error_.  These codes, at ab|-2,x7, are used by lisp_error_
                                   4-6  "as an index into lisp_error_table_.
                                   4-7  
                        000144     4-8  	equ	undefined_atom,100			- correctable
                        000145     4-9  	equ	undefined_function,101		- correctable
                        000146    4-10  	equ	too_many_args,102			uncorrectable 
                        000147    4-11  	equ	too_few_args,103			..
                        000150    4-12  	equ	file_system_error,104		(obsolete)
                        000151    4-13  	equ	bad_argument,105			uncorrectable arg reject
                        000152    4-14  	equ	undefined_subr,106
                        000153    4-15  	equ	bad_function,107			"bad functional form"
                        000154    4-16  	equ	bad_bv,108			attempt to bind non-variable
                        000155    4-17  	equ	unseen_go_tag,109			correctable -> unevaled new tag
                        000156    4-18  	equ	throw_to_no_catch,110		..
                        000157    4-19  	equ	nonfixedarg,111			correctable
                        000160    4-20  	equ	parenmissing,112			uncorr reader error
                        000161    4-21  	equ	doterror,113			..
                        000162    4-22  	equ	illobj,114			..
                        000163    4-23  	equ	badmacro,115			..
                        000164    4-24  	equ	shortreadlist,116			..
                        000165    4-25  	equ	badreadlist,117			..
                        000166    4-26  	equ	array_bound_error,118		corr -> (array sub1 sub2...)
                        000167    4-27  	equ	car_cdr_error,119			uncorr - car or cdr of number
                        000170    4-28  	equ	bad_arg_correctable,120		correctable arg reject
                        000171    4-29  	equ	bad_prog_op,121			uncorr fail-act: go or return
                        000172    4-30  	equ	no_lexpr,122			uncorr fail-act: args or setarg
                        000173    4-31  	equ	wrong_no_args,123			correctable wna -> new expr value
                        000174    4-32  	equ	bad_ibase,124			corr
                        000175    4-33  	equ	bad_base,125			corr
                        000176    4-34  	equ	bad_input_source,126		corr - retry i/o
                        000177    4-35  	equ	bad_output_dest,127			..
                        000200    4-36  	equ	nihil_ex_nihile,128			uncorr - attempt to setq nil
                        000203    4-37  	equ	not_pdl_ptr,131			corr arg reject - for pdl ptr args
                        000206    4-38  	equ	bad_f_fcn,134			compiled call to fsubr with evaled args
                        000207    4-39  	equ	overflow_err,135			arithmetic overflow.
                        000210    4-40  	equ	mismatch_super_parens,136		uncorr reader error
                        000211    4-41  	equ	no_left_super_paren,137		..
                        000212    4-42  	equ	flonum_too_big,138			..
                        000213    4-43  	equ	quoterror,139			..
                        000214    4-44  	equ	badreadtable,140			..
                        000215    4-45  	equ	badobarray,141			..
                        000216    4-46  	equ	atan_0_0_err,142			(atan 0 0) doesn't work
                        000217    4-47  	equ	unable_to_float,143			corr arg reject - (float x)
                        000220    4-48  	equ	division_by_zero,144		uncorr (should really be corr)
                        000221    4-49  	equ	eof_in_object,145			corr fail-act -> keep reading anyway
                        000222    4-50  	equ	cant_filepos,146			corr fail-act -> new expr value
                        000223    4-51  	equ	filepos_oob,147			..
                        000224    4-52  	equ	file_sys_fun_err,148		corr f.s. err -> new expr value
                        000225    4-53  	equ	stars_left_in_name,149		..
                        000226    4-54  	equ	io_wrong_direction,150		..
                        000227    4-55  	equ	file_is_closed,151			..
                        000230    4-56  	equ	reopen_inconsistent,152		..
                        000231    4-57  	equ	bad_entry_name,153			..
                        000232    4-58  	equ	bad_do_format,154			bad do format in interp.
                        000233    4-59  	equ	not_an_array,155			bad array-type arg
                        000234    4-60  	equ	not_alpha_array,156			bad all-alphabetic array
                        000235    4-61  	equ	include_file_error,157		%include barfed
                        000236    4-62  	equ	stack_loss_error,158		stack overflew
                        000237    4-63  	equ	underflow_fault,159
                        000240    4-64  	equ	zerodivide_fault,160
                        000241    4-65  	equ	bad_array_subscript,161
                        000242    4-66  	equ	store_not_allowed,162
                        000243    4-67  	equ	dead_array_reference,163
                        000244    4-68  	equ	cant_subscript_readtable,164
                        000245    4-69  	equ	not_same_type,165
                        000246    4-70  	equ	special_array_type,166
                        000247    4-71  	equ	array_too_big,167
                        000250    4-72  	equ	argument_must_be_array,168
                        000251    4-73  	equ	store_function_misused,169
                                  4-74  
                                  4-75  " END INCLUDE FILE lisp_error_codes.incl.alm
                                    21  	include	lisp_name_codes
                                   5-1  
                                   5-2  " BEGIN INCLUDE FILE lisp_name_codes.incl.alm
                                   5-3  
                                   5-4  " These are codes for the names of functions which are stored into ab|-1,x7 before
                                   5-5  " calling lisp_error_ for a bad_argument or bad_arg_correctable error. They
                                   5-6  " are used so that the name of the function which is rejecting its argument
                                   5-7  " can be printed.  Please note that all these codes are negative.
                                   5-8  
                 777777 777766     5-9  	equ	fn_do,-10
                 777777 777765    5-10  	equ	fn_arg,-11
                 777777 777764    5-11  	equ	fn_setarg,-12
                 777777 777763    5-12  	equ	fn_status,-13
                 777777 777762    5-13  	equ	fn_sstatus,-14
                 777777 777761    5-14  	equ	fn_errprint,-15
                 777777 777760    5-15  	equ	fn_errframe,-16
                 777777 777757    5-16  	equ	fn_evalframe,-17
                 777777 777756    5-17  	equ	fn_defaultf,-18
                 777777 777752    5-18  	equ	fn_tyo,-22
                 777777 777751    5-19  	equ	fn_ascii,-23
                 777777 777750    5-20  	equ	fn_rplaca,-24
                 777777 777747    5-21  	equ	fn_definedp,-25
                 777777 777746    5-22  	equ	fn_setq,-26
                 777777 777745    5-23  	equ	fn_set,-27
                 777777 777744    5-24  	equ	fn_delete,-28
                 777777 777743    5-25  	equ	fn_delq,-29
                 777777 777742    5-26  	equ	fn_stringlength,-30
                 777777 777741    5-27  	equ	fn_catenate,-31
                 777777 777740    5-28  	equ	fn_array,-32
                 777777 777737    5-29  	equ	fn_substr,-33
                 777777 777736    5-30  	equ	fn_index,-34
                 777777 777735    5-31  	equ	fn_get_pname,-35
                 777777 777734    5-32  	equ	fn_make_atom,-36
                 777777 777733    5-33  	equ	fn_ItoC,-37
                 777777 777732    5-34  	equ	fn_CtoI,-38
                 777777 777731    5-35  	equ	fn_defsubr,-39
                 777777 777730    5-36  	equ	fn_star_array,-40
                 777777 777727    5-37  	equ	fn_args,-41
                 777777 777726    5-38  	equ	fn_sysp,-42
                 777777 777725    5-39  	equ	fn_get,-43
                 777777 777724    5-40  	equ	fn_getl,-44
                 777777 777723    5-41  	equ	fn_putprop,-45
                 777777 777722    5-42  	equ	fn_remprop,-46
                 777777 777721    5-43  	equ	fn_save,-47
                 777777 777720    5-44  	equ	fn_add1,-48
                 777777 777717    5-45  	equ	fn_sub1,-49
                 777777 777716    5-46  	equ	fn_greaterp,-50
                 777777 777715    5-47  	equ	fn_lessp,-51
                 777777 777714    5-48  	equ	fn_minus,-52
                 777777 777713    5-49  	equ	fn_plus,-53
                 777777 777712    5-50  	equ	fn_times,-54
                 777777 777711    5-51  	equ	fn_difference,-55
                 777777 777710    5-52  	equ	fn_quotient,-56
                 777777 777707    5-53  	equ	fn_abs,-57
                 777777 777706    5-54  	equ	fn_expt,-58
                 777777 777705    5-55  	equ	fn_boole,-59
                 777777 777704    5-56  	equ	fn_rot,-60
                 777777 777703    5-57  	equ	fn_lsh,-61
                 777777 777702    5-58  	equ	fn_signp,-62
                 777777 777701    5-59  	equ	fn_fix,-63
                 777777 777700    5-60  	equ	fn_float,-64
                 777777 777677    5-61  	equ	fn_remainder,-65
                 777777 777676    5-62  	equ	fn_max,-66
                 777777 777675    5-63  	equ	fn_min,-67
                 777777 777674    5-64  	equ	fn_add1_fix,-68
                 777777 777673    5-65  	equ	fn_add1_flo,-69
                 777777 777672    5-66  	equ	fn_sub1_fix,-70
                 777777 777671    5-67  	equ	fn_sub1_flo,-71
                 777777 777670    5-68  	equ	fn_plus_fix,-72
                 777777 777667    5-69  	equ	fn_plus_flo,-73
                 777777 777666    5-70  	equ	fn_times_fix,-74
                 777777 777665    5-71  	equ	fn_times_flo,-75
                 777777 777664    5-72  	equ	fn_diff_fix,-76
                 777777 777663    5-73  	equ	fn_diff_flo,-77
                 777777 777662    5-74  	equ	fn_quot_fix,-78
                 777777 777661    5-75  	equ	fn_quot_flo,-79
                 777777 777660    5-76  	equ	fn_eval,-80
                 777777 777657    5-77  	equ	fn_apply,-81
                 777777 777656    5-78  	equ	fn_prog,-82
                 777777 777655    5-79  	equ	fn_errset,-83
                 777777 777654    5-80  	equ	fn_catch,-84
                 777777 777653    5-81  	equ	fn_throw,-85
                 777777 777652    5-82  	equ	fn_store,-86
                 777777 777651    5-83  	equ	fn_defun,-87
                 777777 777650    5-84  	equ	fn_baktrace,-88
                 777777 777647    5-85  	equ	fn_bltarray,-89
                 777777 777646    5-86  	equ	fn_star_rearray,-90
                 777777 777645    5-87  	equ	fn_gensym,-91
                 777777 777644    5-88  	equ	fn_makunbound,-92
                 777777 777643    5-89  	equ	fn_boundp,-93
                 777777 777642    5-90  	equ	fn_star_status,-94
                 777777 777641    5-91  	equ	fn_star_sstatus,-95
                 777777 777640    5-92  	equ	fn_freturn,-96
                 777777 777637    5-93  	equ	fn_cos,-97
                 777777 777636    5-94  	equ	fn_sin,-98
                 777777 777635    5-95  	equ	fn_exp,-99
                 777777 777634    5-96  	equ	fn_log,-100
                 777777 777633    5-97  	equ	fn_sqrt,-101
                 777777 777632    5-98  	equ	fn_isqrt,-102
                 777777 777631    5-99  	equ	fn_atan,-103
                 777777 777630   5-100  	equ	fn_sleep,-104
                 777777 777627   5-101  	equ	fn_oddp,-105
                 777777 777626   5-102  	equ	fn_tyipeek,-106
                 777777 777625   5-103  	equ	fn_alarmclock,-107
                 777777 777624   5-104  	equ	fn_plusp,-108
                 777777 777623   5-105  	equ	fn_minusp,-109
                 777777 777622   5-106  	equ	fn_ls,-110
                 777777 777621   5-107  	equ	fn_eql,-111
                 777777 777620   5-108  	equ	fn_gt,-112
                 777777 777617   5-109  	equ	fn_alphalessp,-113
                 777777 777616   5-110  	equ	fn_samepnamep,-114
                 777777 777615   5-111  	equ	fn_getchar,-115
                 777777 777614   5-112  	equ	fn_opena,-116
                 777777 777613   5-113  	equ	fn_sxhash,-117
                 777777 777612   5-114  	equ	fn_gcd,-118
                 777777 777611   5-115  	equ	fn_allfiles,-119
                 777777 777610   5-116  	equ	fn_chrct,-120
                 777777 777607   5-117  	equ	fn_close,-121
                 777777 777606   5-118  	equ	fn_deletef,-122
                 777777 777605   5-119  	equ	fn_eoffn,-123
                 777777 777604   5-120  	equ	fn_filepos,-124
                 777777 777603   5-121  	equ	fn_inpush,-125
                 777777 777602   5-122  	equ	fn_linel,-126
                 777777 777601   5-123  	equ	fn_mergef,-127
                 777777 777600   5-124  	equ	fn_namelist,-128
                 777777 777577   5-125  	equ	fn_names,-129
                 777777 777576   5-126  	equ	fn_namestring,-130
                 777777 777575   5-127  	equ	fn_openi,-131
                 777777 777574   5-128  	equ	fn_openo,-132
                 777777 777573   5-129  	equ	fn_prin1,-133
                 777777 777572   5-130  	equ	fn_princ,-134
                 777777 777571   5-131  	equ	fn_print,-135
                 777777 777570   5-132  	equ	fn_read,-136
                 777777 777567   5-133  	equ	fn_readch,-137
                 777777 777566   5-134  	equ	fn_readstring,-138
                 777777 777565   5-135  	equ	fn_rename,-139
                 777777 777564   5-136  	equ	fn_shortnamestring,-140
                 777777 777563   5-137  	equ	fn_tyi,-141
                 777777 777562   5-138  	equ	fn_setsyntax,-142
                 777777 777561   5-139  	equ	fn_cursorpos,-143
                 777777 777560   5-140  	equ	fn_force_output,-144
                 777777 777557   5-141  	equ	fn_clear_input,-145
                 777777 777556   5-142  	equ	fn_random,-146
                 777777 777555   5-143  	equ	fn_haulong,-147
                 777777 777554   5-144  	equ	fn_haipart,-148
                 777777 777553   5-145  	equ	fn_cline,-149
                 777777 777552   5-146  	equ	fn_fillarray,-150
                 777777 777551   5-147  	equ	fn_listarray,-151
                 777777 777550   5-148  	equ	fn_sort,-152
                 777777 777547   5-149  	equ	fn_sortcar,-153
                 777777 777546   5-150  	equ	fn_zerop,-154
                 777777 777545   5-151  	equ	fn_listify,-155
                 777777 777544   5-152  	equ	fn_charpos,-156
                 777777 777543   5-153  	equ	fn_pagel,-157
                 777777 777542   5-154  	equ	fn_linenum,-158
                 777777 777541   5-155  	equ	fn_pagenum,-159
                 777777 777540   5-156  	equ	fn_endpagefn,-160
                 777777 777537   5-157  	equ	fn_arraydims,-161
                 777777 777536   5-158  	equ	fn_loadarrays,-162
                 777777 777535   5-159  	equ	fn_dumparrays,-163
                 777777 777534   5-160  	equ	fn_expt_fix,-164
                 777777 777533   5-161  	equ	fn_expt_flo,-165
                 777777 777532   5-162  	equ	fn_nointerrupt,-166
                 777777 777531   5-163  	equ	fn_open,-167
                 777777 777530   5-164  	equ	fn_in,-168
                 777777 777527   5-165  	equ	fn_out,-169
                 777777 777526   5-166  	equ	fn_truename,-170
                 777777 777525   5-167  	equ	fn_ifix,-171
                 777777 777524   5-168  	equ	fn_fsc,-172
                 777777 777523   5-169  	equ	fn_progv,-173
                 777777 777522   5-170  	equ	fn_mapatoms,-174
                 777777 777521   5-171  	equ	fn_unwind_protect,-175
                 777777 777520   5-172  	equ	fn_eval_when,-176
                 777777 777517   5-173  	equ	fn_read_from_string,-177
                 777777 777516   5-174  	equ	fn_displace,-178
                 777777 777515   5-175  	equ	fn_nth,-179
                 777777 777514   5-176  	equ	fn_nthcdr,-180
                 777777 777513   5-177  	equ	fn_includef,-181
                                 5-178  
                                 5-179  " END INCLUDE FILE lisp_name_codes.incl.alm
                                    22  
                                    23  " REGISTER USAGE
                                    24  "
                                    25  " ap	marked pdl pointer
                                    26  " ab	-> lisp stack header
                                    27  " bp	return addr (type 0 subr)
                                    28  " bb
                                    29  " lp,lb,sp,sb     not used
                                    30  "
                                    31  " x0	tsx0 register
                                    32  " x1	-> routine to check arg for arith1, arith2
                                    33  " x2	temp. used by numval.  badarg is called by tsx2
                                    34  " x3	-> instr for xec or xed (quasi impure code)
                                    35  " x4	ap,x4 -> current arg, also x4 is loop counter.
                                    36  " x5	-2*nargs for lsubrs, not changed.
                                    37  " x6	while in function xxx, contains function name code fn_xxx.
                                    38  " x7	unmarked pdl pointer (with ab)
                                    39  
                                    40  " routine to do eax4 -2   ,   tsx0 numval
                                    41  " called by tsx0
                                    42  " used for subrs of one argument so they don't have to
                                    43  " do the eax4 themselves
                                    44  
    000000  aa   777776 6240 00     45  numval1:	eax4	-2			and fall into numval
                                    46  
                                    47  " routine to get the type of a numeric argument
                                    48  " called by tsx0 with ap,x4 pointing at the argument
                                    49  " keeps signalling bad_arg_correctable errors until it gets a number
                                    50  " skip return if fixnum, nonskip return if flonum.
                                    51  " changes only registers 0,2 -- doesn't touch aq.
                                    52  
    000001  aa  0 00000 7221 14     53  numval:	lxl2	ap|0,x4			get type bits without touching aq
    000002  aa   040000 3020 03     54  	canx2	Fixed,du
    000003  aa   000001 6010 10     55  	tnz	1,0			fixnum, skip rtn
    000004  aa   020000 3020 03     56  	canx2	Float,du
    000005  aa   000000 6010 10     57  	tnz	0,0			flonum, nonskip rtn
    000006  aa   777773 6220 04     58  	eax2	numval-*,ic		set error return address and fall into badarg
                                    59  
                                    60  " not a number, signal error
                                    61  " the function name code is in x6
                                    62  " the bad arg is at ap|0,x4
                                    63  " **** KLUDGE: assumes that we are bound in with lisp_error_
                                    64  "      so that we don't have to do a getlp.
                                    65  " called by tsx2, returns to 0,2 with replacement value written over bad arg
                                    66  
    000007  aa   000012 6270 17     67  badarg:	eax7	10,x7			get save area
    000010  aa  1 77766 6501 17     68  	sprilp	ab|-10,x7			save lp of caller, so can get system lp.
    000011  aa  1 77770 7571 17     69  	staq	ab|-8,x7			save aq (e reg saved by sreg)
    000012  aa  1 77772 2521 17     70  	spribp	ab|-6,x7			save bp (return addr)
    000013  aa   000000 6360 16     71  	eaq	0,x6			get fcn name code
    000014  aa   000022 7320 00     72  	qrs	18
    000015  aa   000170 2350 07     73  	lda	bad_arg_correctable,dl
    000016                          74  badarg1:
    000016  aa  1 77776 7571 17     75  	staq	ab|-2,x7			set error codes for lisp_error_
    000017  aa  0 00000 3521 14     76  	eppbp	ap|0,x4			save addr of bad arg
    000020  aa  1 77774 2521 17     77  	spribp	ab|-4,x7
    000021  aa  2 00000 2371 00     78  	ldaq	bp|0			get bad arg
    000022  aa  0 00002 3501 00     79  	eppap	ap|2			put on top of pdl for lisp_error_
    000023  aa  0 77776 7571 00     80  	staq	ap|-2
    000024                          81  fatal_error:				" overflow_err joins here.
    000024  aa  1 00044 3701 20     82  	epplp	ab|system_lp,*		get lp for system modules.
    000025  4a  4 00032 2501 20     83  	spriap	<lisp_static_vars_>|[stack_ptr]	save our stack pointers
    000026  4a  4 00034 7471 20     84  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000027  aa  1 00016 5541 00     85  	stc1	ab|in_pl1_code
    000030  aa   000060 6270 00     86  	push
    000031  aa  7 00040 2721 20
    000032  aa  6 00000 2541 00     87  	call	<lisp_error_>|[lisp_error_]	""" we rely on this call saving xr's and e reg
    000033  0a   001256 3500 00
    000034  4a  4 00010 3521 20
    000035  aa  6 00040 7531 00
    000036  aa  7 00036 6701 20
    000037  aa  6 00000 1731 00
    000040  aa  6 00040 0731 00
    000041  aa  6 00020 6351 20     88  	eaa	sp|16,*			then pop this dummy stack frame
    000042  aa  7 00024 6521 00     89  	sprisp	sb|stack_header.stack_end_ptr
    000043  aa  7 00000 3721 01     90  	eppsp	sb|0,au
    000044  4a  4 00036 3501 20     91  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000045  4a  4 00040 3511 20     92  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000046  4a  4 00034 2271 20     93  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000047  aa  1 00016 4501 00     94  	stz	ab|in_pl1_code
    000050  aa  0 77776 2371 00     95  	ldaq	ap|-2			get replacement value
    000051  aa  0 77776 3501 00     96  	eppap	ap|-2			..
    000052  aa  1 77776 7571 37     97  	staq	ab|-2,x7*			store over bad arg
    000053  aa  1 77772 2371 17     98  	ldaq	ab|-6,x7			restore aq at entry
    000054  aa  1 77774 3521 37     99  	eppbp	ab|-4,x7*			restore bp at entry
    000055  aa  1 77770 3701 37    100  	epplp	ab|-8,x7*			restore to caller's lp.
    000056  aa   777770 6270 17    101  	eax7	-8,x7			pop temps off pdl
    000057  aa   000000 7100 12    102  	tra	0,2			return to caller.
                                   103  
                                   104  	even
    000060  aa   000000 000157     105  	zero	0,nonfixedarg
    000061  aa   000000 000000     106  	oct	0
                                   107  
                                   108  " routines to return in divers ways
                                   109  
                                   110  " return the value at the top of the marked pdl (for 1 arg subr)
                                   111  
    000062  aa  0 77776 2371 00    112  ret_1:	ldaq	ap|-2
                                   113  
                                   114  " return value in aq, popping 1 arg off marked pdl
                                   115  
    000063  aa  0 77776 3501 00    116  lisp_retn_1: eppap	ap|-2
    000064  aa  2 00000 7101 00    117  	tra	bp|0			*** these are type 0 subrs
                                   118  
                                   119  " return t for 1 arg subr
                                   120  
    000065  aa  1 00014 2371 00    121  ret_t:	ldaq	ab|t
    000066  aa  0 77776 3501 00    122  	eppap	ap|-2
    000067  aa  2 00000 7101 00    123  	tra	bp|0
                                   124  
                                   125  " return nil for 1 arg subr
                                   126  
    000070  aa  1 00012 2371 00    127  ret_nil:	ldaq	ab|nil
    000071  aa  0 77776 3501 00    128  	eppap	ap|-2
    000072  aa  2 00000 7101 00    129  	tra	bp|0
                                   130  
                                   131  " return t for lsubr
                                   132  
    000073  aa  1 00014 2371 00    133  l_ret_t:	ldaq	ab|t
    000074  aa  0 00000 3501 15    134  	eppap	ap|0,x5			pop args off pdl
    000075  aa  2 00000 7101 00    135  	tra	bp|0
                                   136  
                                   137  " return nil for lsubr
                                   138  
    000076  aa  1 00012 2371 00    139  l_ret_nil: ldaq	ab|nil
    000077  aa  0 00000 3501 15    140  	eppap	ap|0,x5			pop args off pdl
    000100  aa  2 00000 7101 00    141  	tra	bp|0
                                   142  " return a fixnum from an lsubr
                                   143  
    000101  aa   040047 2350 07    144  retfixnum:lda	fixnum_type,dl			value is in q
    000102  aa  0 00000 3501 15    145  	eppap	ap|0,x5
    000103  aa  2 00000 7101 00    146  	tra	bp|0
                                   147  
                                   148  " return a flonum from an lsubr
                                   149  " value of flonum is in a-q-e
                                   150  
    000104  aa  0 00001 4551 15    151  retflonum:fst	ap|1,x5				**** assumes arg 1 was numeric
    000105  aa  0 00001 2361 15    152  	ldq	ap|1,x5				this moves flonum to q
    000106  aa   020047 2350 07    153  	lda	flonum_type,dl
    000107  aa  0 00000 3501 15    154  	eppap	ap|0,x5
    000110  aa  2 00000 7101 00    155  	tra	bp|0
                                   156  
                                   157  " fixing & floating routines
                                   158  
                                   159  " these are all called by tsx0
                                   160  
                                   161  " routine to float the q, returning result in a-q-e
                                   162  
    000111  aa   000044 7770 00    163  float_q:	llr	36			fx1_to_fx2
    000112  aa   000044 7330 00    164  	lrs	36
    000113  aa   216000 4110 03    165  	lde	=71b25,du			fx2_to_fl2
    000114  aa   400000 4750 03    166  	fad	=0.0,du			normalize
    000115  aa   000000 7100 10    167  	tra	0,0
                                   168  
                                   169  " routine to float the fixnum pointed at by ap,x4 without
                                   170  " changing the a, q, or e.
                                   171  
    000116  aa   000002 6270 17    172  float1:	eax7	2,x7			have to save aqe
    000117  aa  1 77776 4571 17    173  	dfst	ab|-2,x7
    000120  aa  0 00001 2351 14    174  	lda	ap|1,x4			get number to be floated
    000121  aa   000044 7330 00    175  	lrs	36
    000122  aa   216000 4110 03    176  	lde	=71b25,du
    000123  aa   400000 4750 03    177  	fad	=0.0,du
    000124  aa  0 00001 4551 14    178  	fst	ap|1,x4			put it back where it came from
    000125  aa  1 77776 4331 17    179  	dfld	ab|-2,x7			restore a q e
    000126  aa   777776 6270 17    180  	eax7	-2,x7
    000127  aa   000000 7100 10    181  	tra	0,0
                                   182  
                                   183  " routine to fix the flonum in a-q-e, result is in q
                                   184  " check for overflow is made
                                   185  
    000130  aa   400000 4750 03    186  fix_aq:	fad	=0.0,du			normalize and set indicators
    000131  aa   000005 6040 04    187  	tmi	fix_aq_minus-*,ic
    000132  aa   110400 5150 03    188  	fcmp	=o110400,du		2**35
    000133  aa   000011 6050 04    189  	tpl	fix_ovf-*,ic
    000134  aa   216000 4350 03    190  	ufa	=71b25,du
    000135  aa   000000 7100 10    191  	tra	0,0
                                   192  
    000136                         193  fix_aq_minus:
    000136  aa   110400 4250 03    194  	fcmg	=o110400,du		2**35
    000137  aa   000005 6050 04    195  	tpl	fix_ovf-*,ic
    000140  aa   000000 5130 00    196  	fneg	0			magic ufa only works for +
    000141  aa   216000 4350 03    197  	ufa	=71b25,du
    000142  aa   000000 5330 00    198  	negl	0
    000143  aa   000000 7100 10    199  	tra	0,0
                                   200  
    000144  aa  0 00002 3501 00    201  fix_ovf:	eppap	ap|2
    000145  aa   000002 6270 17    202  	eax7	2,x7
    000146  aa  1 77776 4551 17    203  	fst	ab|-2,x7			get flonum format
    000147  aa  1 77776 2361 17    204  	ldq	ab|-2,x7
    000150  aa   020047 2350 07    205  	lda	flonum_type,dl
    000151  aa  0 77776 7571 00    206  	staq	ap|-2
    000152  aa   000207 2350 07    207  	lda	overflow_err,dl
    000153  aa   000000 6360 16    208  	eaq	0,x6
    000154  aa   000022 7320 00    209  	qrs	18
    000155  aa  1 77776 7571 17    210  	staq	ab|-2,x7
    000156  aa   777646 7100 04    211  	tra	fatal_error-*,ic		never returns from lisp_error_
                                   212   
                                   213  " routines for fixnum - only or flonum - only incrementing / decrementing.
                                   214  " x3 -> xed pair to do the work
                                   215  "	for arith2 is xec inst, which can be xed if pair needed.
                                   216  " x1 -> fixval or floval routine
                                   217  " x6 =  function name code.
                                   218  
                                   219  " these 2 support routines are called by tsx0 to get a
                                   220  " floating number or a fixed number.
                                   221  
    000157  0a   000104 7100 00    222  	tra	retflonum			flo exit
    000160  aa  0 00000 7221 14    223  floval:	lxl2	ap|0,x4			get type bits
    000161  aa   020000 3020 03    224  	canx2	Float,du
    000162  aa   000000 6010 10    225  	tnz	0,0			flonum -- win.
    000163  aa   777624 7020 04    226  	tsx2	badarg-*,ic		not flonum, cause error
    000164  aa   777774 7100 04    227  	tra	floval-*,ic
                                   228  
    000165  0a   000101 7100 00    229  	tra	retfixnum			fix exit
    000166  aa  0 00000 7221 14    230  fixval:	lxl2	ap|0,x4			check type bits
    000167  aa   040000 3020 03    231  	canx2	Fixed,du
    000170  aa   000000 6010 10    232  	tnz	0,0			fixnum -- win.
    000171  aa   777616 7020 04    233  	tsx2	badarg-*,ic		not fixnum -- error.
    000172  aa   777774 7100 04    234  	tra	fixval-*,ic
                                   235  
                                   236  " routine to do one - operand arithmetic using
                                   237  " x3, x1 as described above.  Entered with x6 also set up.
                                   238  
                                   239  	odd
    000173  aa   777776 6240 00    240  arith1:	eax4	-2			one arg.
    000174  aa   000000 7000 11    241  	tsx0	0,1			check type of arg
    000175  aa   000000 7170 13    242  	xed	0,x3			perform operation.
    000176  aa   777664 7100 04    243  	tra	ret_1-*,ic		and return the value at top of stack.
                                   244  
                                   245  
                                   246  
                                   247  " using x3, x1 as described above. Entered
                                   248  " with x5, x6 set up.
                                   249  " and initial value in q (fix) or aqe (float).
                                   250  
                                   251  	odd				" must make the xec in odd word to allow xed.
    000177  aa   777776 1050 03    252  prearith2: cmpx5	-2,du			" check for one arg case of -, -$, //, //$
    000200  0a   000204 6010 00    253  	tnz	arith2
    000201  aa   000000 7000 11    254  	tsx0	0,1
    000202  aa   000003 7160 13    255  	xec	3,x3			" do the operation.
    000203  aa   777777 7100 11    256  	tra	-1,x1			" and return the result.
    000204  aa   000000 6240 15    257  arith2:	eax4	0,x5			-> first arg
    000205  aa   777777 6000 11    258  	tze	-1,1			if no args return value in q register.
    000206  aa   000000 7000 11    259  	tsx0	0,1			check type of arg
    000207  aa   000000 7160 13    260  	xec	0,x3			perform operation
    000210  aa   000002 6240 14    261  	eax4	2,x4			next arg.
    000211  aa   777775 6040 04    262  	tmi	-3,ic			and loop.
    000212  aa   777777 7100 11    263  	tra	-1,1			go to appropriate exit routine.
                                   264  
                                   265  " non - mixed mode increment / decrement routines. (Using subroutines
                                   266  " on the preceding page.)
                                   267  
                                   268  " increment fixnum.
                                   269  
                        000213     270  	segdef	add1_fix			subr (1 0 0)
                                   271  
    000213  aa   777674 6260 00    272  add1_fix:	eax6	fn_add1_fix
    000214  aa   777752 6210 04    273  	eax1	fixval-*,ic
    000215  aa   000003 6230 04    274  	eax3	add1_fix_op-*,ic
    000216  aa   777755 7100 04    275  	tra	arith1-*,ic
                                   276  
    000217  aa   000000 0110 03    277  	even
    000220                         278  add1_fix_op:
    000220  aa  0 77777 0541 00    279  	aos	ap|-1
    000221  aa   000000 0110 03    280  	nop	0,du
                                   281  
                                   282  
                                   283  " increment flonum
                                   284  
                        000222     285  	segdef	add1_flo			subr (1 0 0)
                                   286  
    000222  aa   777673 6260 00    287  add1_flo:	eax6	fn_add1_flo
    000223  aa   777735 6210 04    288  	eax1	floval-*,ic
    000224  aa   000002 6230 04    289  	eax3	add1_flo_op-*,ic
    000225  aa   777746 7100 04    290  	tra	arith1-*,ic
                                   291  
                                   292  	even
    000226                         293  add1_flo_op:
    000226  aa  0 77777 4311 00    294  	fld	ap|-1
    000227  0a   000230 7170 00    295  	xed	*+1
    000230  aa   002400 4750 03    296  	fad	=1.0,du
    000231  aa  0 77777 4551 00    297  	fst	ap|-1
                                   298  
                                   299  
                                   300  " decrement fixnum
                                   301  
                        000232     302  	segdef	sub1_fix			subr (1 0 0)
                                   303  
    000232  aa   777672 6260 00    304  sub1_fix:	eax6	fn_sub1_fix
    000233  aa   777733 6210 04    305  	eax1	fixval-*,ic
    000234  aa   000002 6230 04    306  	eax3	sub1_fix_op-*,ic
    000235  aa   777736 7100 04    307  	tra	arith1-*,ic
                                   308  
                                   309  	even
    000236                         310  sub1_fix_op:
    000236  aa   000001 3350 07    311  	lca	1,dl
    000237  aa  0 77777 0551 00    312  	asa	ap|-1
                                   313  
                                   314  
                                   315  " decrement flonum
                                   316  
                        000240     317  	segdef	sub1_flo			subr (1 0 0)
                                   318  
    000240  aa   777671 6260 00    319  sub1_flo:	eax6	fn_sub1_flo
    000241  aa   777717 6210 04    320  	eax1	floval-*,ic
    000242  aa   000002 6230 04    321  	eax3	sub1_flo_op-*,ic
    000243  aa   777730 7100 04    322  	tra	arith1-*,ic
                                   323  
                                   324  	even
    000244                         325  sub1_flo_op:
    000244  aa  0 77777 4311 00    326  	fld	ap|-1
    000245  0a   000246 7170 00    327  	xed	*+1
    000246  aa   002400 5750 03    328  	fsb	=1.0,du
    000247  aa  0 77777 4551 00    329  	fst	ap|-1
                                   330  
                                   331  " plus function for fixnums only.
                                   332  
                        000250     333  	segdef	plus_fix		lsubr (777000 0 0)
                                   334  
    000250  aa   777670 6260 00    335  plus_fix:	eax6	fn_plus_fix
    000251  aa   777715 6210 04    336  	eax1	fixval-*,ic
    000252  aa   000000 2360 07    337  	ldq	0,dl
    000253  aa   777731 7030 04    338  	tsx3	arith2-*,ic
    000254  aa  0 00001 0761 14    339  	adq	ap|1,x4
                                   340  
                                   341  
                                   342  " plus function for flonum's only.
                                   343  
                        000255     344  	segdef	plus_flo			lsubr (777000 0 0)
                                   345  
    000255  aa   777667 6260 00    346  plus_flo:	eax6	fn_plus_flo
    000256  aa   777702 6210 04    347  	eax1	floval-*,ic
    000257  aa   400000 4310 03    348  	fld	=0.0,du
    000260  aa   777724 7030 04    349  	tsx3	arith2-*,ic
    000261  aa  0 00001 4751 14    350  	fad	ap|1,x4
                                   351  
                                   352  " exponentiation function for fixnum to fixnum power
                                   353  
                        000262     354  	segdef	expt_fix
                                   355  
    000262  aa   777534 6260 00    356  expt_fix:	eax6	fn_expt_fix
    000263  aa   777774 6240 00    357  	eax4	-4			get first arg
    000264  aa   777702 7000 04    358  	tsx0	fixval-*,ic
    000265  aa   777776 6240 00    359  	eax4	-2			get second arg
    000266  aa   777700 7000 04    360  	tsx0	fixval-*,ic
                                   361  " OK, got args.  Set up for successive squaring hackery
                                   362  
    000267  aa   000002 6270 17    363  	eax7	2,x7
    000270  aa  0 77775 2361 00    364  	ldq	ap|-3			base in q
    000271  aa  0 77777 2351 00    365  	lda	ap|-1			exponent in a
    000272  aa   000020 6040 04    366  	tmi	ret_fix_0-*,ic
    000273  aa  1 77776 7571 17    367  	staq	ab|-2,x7
    000274  aa   000001 2360 07    368  	ldq	1,dl
    000275  aa  0 77775 7561 00    369  	stq	ap|-3			init result
    000276  aa  1 77776 2371 17    370  expt_fix0:ldaq	ab|-2,x7
    000277  aa   000001 3150 07    371  	cana	1,dl
    000300  aa   000004 6000 04    372  	tze	expt_fix1-*,ic
    000301  aa  0 77775 4021 00    373  	mpy	ap|-3			multiply into result
    000302  aa  0 77775 7561 00    374  	stq	ap|-3
    000303  aa  1 77776 2371 17    375  	ldaq	ab|-2,x7
    000304  aa   000001 7710 00    376  expt_fix1:arl	1
    000305  aa   000006 6000 04    377  	tze	ret_fix_result-*,ic
    000306  aa  1 77776 7551 17    378  	sta	ab|-2,x7
    000307  aa  1 77777 4021 17    379  	mpy	ab|-1,x7			square it
    000310  aa  1 77777 7561 17    380  	stq	ab|-1,x7
    000311  aa   777765 7100 04    381  	tra	expt_fix0-*,ic
                                   382  
    000312  aa  0 77775 4501 00    383  ret_fix_0:stz	ap|-3			neg exponent - zero result
    000313                         384  ret_fix_result:
    000313  aa  0 77774 2371 00    385  	ldaq	ap|-4			pick up result & type
    000314  aa   777776 6270 17    386  	eax7	-2,x7			flush temporaries
    000315  aa  0 77774 3501 00    387  	eppap	ap|-4			..
    000316  aa  2 00000 7101 00    388  	tra	bp|0			and return
                                   389  
                                   390  " flonum to a fixnum power
                                   391  
                        000317     392  	segdef	expt_flo
                                   393  
    000317  aa   777533 6260 00    394  expt_flo:	eax6	fn_expt_flo
    000320  aa   777774 6240 00    395  	eax4	-4			get first arg
    000321  aa   777637 7000 04    396  	tsx0	floval-*,ic
    000322  aa   777776 6240 00    397  	eax4	-2			get second arg
    000323  aa   777643 7000 04    398  	tsx0	fixval-*,ic
    000324  aa   000002 6270 17    399  	eax7	2,x7			get temporaries
    000325  aa   002400 4310 03    400  	fld	=1.0,du			init result
    000326  aa  1 77776 4571 17    401  	dfst	ab|-2,x7
    000327  aa  0 77777 2351 00    402  	lda	ap|-1			check sign of exponent
    000330  aa   000005 6050 04    403  	tpl	expt_fl0-*,ic
    000331  aa   002400 4310 03    404  	fld	=1.0,du			minus - invert base
    000332  aa  0 77775 5651 00    405  	fdv	ap|-3
    000333  aa  0 77775 4551 00    406  	fst	ap|-3
    000334  aa  0 77777 3351 00    407  	lca	ap|-1			change sign of exponent
    000335  aa   000017 6000 04    408  expt_fl0:	tze	return_flo_result-*,ic	all done
    000336  aa   000001 3150 07    409  	cana	1,dl			see if should mpy
    000337  aa   000006 6000 04    410  	tze	expt_fl1-*,ic		no.
    000340  aa  0 77777 7551 00    411  	sta	ap|-1			yes - store a first
    000341  aa  0 77775 4311 00    412  	fld	ap|-3			get current square
    000342  aa  1 77776 4631 17    413  	dfmp	ab|-2,x7			mpy into result
    000343  aa  1 77776 4571 17    414  	dfst	ab|-2,x7
    000344  aa   000002 7100 04    415  	tra	2,ic
    000345  aa  0 77777 7551 00    416  expt_fl1:	sta	ap|-1			save exponent
    000346  aa  0 77775 4311 00    417  	fld	ap|-3			compute next square
    000347  aa  0 77775 4611 00    418  	fmp	ap|-3
    000350  aa  0 77775 4551 00    419  	fst	ap|-3
    000351  aa  0 77777 2351 00    420  	lda	ap|-1
    000352  aa   000001 7710 00    421  	arl	1
    000353  aa   777762 7100 04    422  	tra	expt_fl0-*,ic
                                   423  
    000354                         424  return_flo_result:
    000354  aa  1 77776 4331 17    425  	dfld	ab|-2,x7			round off result
    000355  aa  0 77775 4701 00    426  	fstr	ap|-3
    000356  aa   777735 7100 04    427  	tra	ret_fix_result-*,ic		and return it, popping, etc.
                                   428  
                                   429  " times function for fixnum's only
                                   430  
                        000357     431  	segdef	times_fix			lsubr (777000 0 0)
                                   432  
    000357  aa   777666 6260 00    433  times_fix: eax6	fn_times_fix
    000360  aa   777606 6210 04    434  	eax1	fixval-*,ic
    000361  aa   000001 2360 07    435  	ldq	1,dl
    000362  aa   777622 7030 04    436  	tsx3	arith2-*,ic
    000363  aa  0 00001 4021 14    437  	mpy	ap|1,x4
                                   438  
                                   439  
                                   440  " times function for flonum's only
                                   441  
                        000364     442  	segdef	times_flo			lsubr (777000 0 0)
                                   443  
    000364  aa   777665 6260 00    444  times_flo: eax6	fn_times_flo
    000365  aa   777573 6210 04    445  	eax1	floval-*,ic
    000366  aa   002400 4310 03    446  	fld	=1.0,du
    000367  aa   777615 7030 04    447  	tsx3	arith2-*,ic
    000370  aa  0 00001 4611 14    448  	fmp	ap|1,x4
                                   449  
                                   450  " difference of fixnum's only
                                   451  
                        000371     452  	segdef	diff_fix			lsubr (777000 0 0)
                                   453  
    000371  aa   777664 6260 00    454  diff_fix:	eax6	fn_diff_fix
    000372  aa   777574 6210 04    455  	eax1	fixval-*,ic
    000373  aa   000000 2360 07    456  	ldq	0,dl			make sure there is a result if no args supplied.
    000374  aa   000003 6230 04    457  	eax3	diff_fix_op_1-*,ic		initial op just loads num
    000375  aa   777602 7100 04    458  	tra	prearith2-*,ic
                                   459  
    000376  aa   000000 0110 03    460  	odd
    000377                         461  diff_fix_op_1:
    000377  0a   000400 7170 00    462  	xed	*+1
    000400  aa  0 00001 2361 14    463  	ldq	ap|1,x4			load first arg
    000401  0a   000402 6230 00    464  	eax3	*+1			and switch to the following,
    000402  aa  0 00001 1761 14    465  	sbq	ap|1,x4			which subtracts the remaining args
                                   466  
                                   467  " difference of flonum's only.
                                   468  
                        000403     469  	segdef	diff_flo			lsubr (777000 0 0)
                                   470  
    000403  aa   777663 6260 00    471  diff_flo:	eax6	fn_diff_flo
    000404  aa   777554 6210 04    472  	eax1	floval-*,ic
    000405  aa   400000 4310 03    473  	fld	=0.0,du			initial result.
    000406  aa   000003 6230 04    474  	eax3	diff_flo_op_1-*,ic
    000407  aa   777570 7100 04    475  	tra	prearith2-*,ic
                                   476  
    000410  aa   000000 0110 03    477  	odd
    000411                         478  diff_flo_op_1:
    000411  0a   000412 7170 00    479  	xed	*+1
    000412  aa  0 00001 4311 14    480  	fld	ap|1,x4			load first arg,
    000413  0a   000414 6230 00    481  	eax3	*+1			and set up subtract remaining args
    000414  aa  0 00001 5751 14    482  	fsb	ap|1,x4
                                   483  
                                   484  " quotient of fixnum's only
                                   485  
                        000415     486  	segdef	quot_fix			lsubr (777000 0 0)
                                   487  
    000415  aa   777662 6260 00    488  quot_fix:	eax6	fn_quot_fix
    000416  aa   777550 6210 04    489  	eax1	fixval-*,ic
    000417  aa   000001 2360 07    490  	ldq	1,dl			initialize zero arg case.
    000420  aa   000003 6230 04    491  	eax3	quot_fix_op_1-*,ic		initial operator
    000421  aa   777556 7100 04    492  	tra	prearith2-*,ic
                                   493  
    000422  aa   000000 0110 03    494  	odd
    000423                         495  quot_fix_op_1:
    000423  0a   000424 7170 00    496  	xed	*+1
    000424  aa  0 00001 2361 14    497  	ldq	ap|1,x4			this opr loads first arg,
    000425  0a   000426 6230 00    498  	eax3	*+1			and sets up to divide by rest of args
    000426  aa  0 00001 5061 14    499  	div	ap|1,x4
                                   500  
                                   501  " quotient of flonum's only
                                   502  
                        000427     503  	segdef	quot_flo			lsubr (777000 0 0)
                                   504  
    000427  aa   777661 6260 00    505  quot_flo:	eax6	fn_quot_flo
    000430  aa   777530 6210 04    506  	eax1	floval-*,ic
    000431  aa   002400 4310 03    507  	fld	=1.0,du			initialize zero arg case.
    000432  aa   000003 6230 04    508  	eax3	quot_flo_op_1-*,ic
    000433  aa   777544 7100 04    509  	tra	prearith2-*,ic
                                   510  
    000434  aa   000000 0110 03    511  	odd
    000435                         512  quot_flo_op_1:
    000435  0a   000436 7170 00    513  	xed	*+1
    000436  aa  0 00001 4311 14    514  	fld	ap|1,x4			load first arg
    000437  0a   000440 6230 00    515  	eax3	*+1
    000440  aa  0 00001 5651 14    516  	fdv	ap|1,x4			divide by remaining ones.
                                   517  
                                   518  " lsh function shifts a fixnum left or right a 
                                   519  " specified number of binary places.
                                   520  
                        000441     521  	segdef	lsh			subr (2 0 0)
                                   522  
    000441  aa   777703 6260 00    523  lsh:	eax6	fn_lsh
    000442  aa   777774 6240 00    524  	eax4	-4			arg1 must be fixnum
    000443  aa   777336 7000 04    525  	tsx0	numval-*,ic 		or flonum (treated as fixnum)
    000444  aa   777776 6240 00    526  	eax4	-2			arg2 must be fixnum
    000445  aa   777521 7000 04    527  	tsx0	fixval-*,ic
    000446  aa  0 77775 2361 00    528  	ldq	ap|-3			get number to be shifted
    000447  aa  0 77777 2351 00    529  	lda	ap|-1			get shift count
    000450  aa   000006 6040 04    530  	tmi	lshneg-*,ic		neg = shift right
    000451  aa   000013 6000 04    531  	tze	lshret1-*,ic		zero = don't shift
    000452  aa   000044 1150 07    532  	cmpa	36,dl			shift right out of register?
    000453  aa   000010 6050 04    533  	tpl	lshret0-*,ic		yes, result is zero
    000454  aa   000000 7360 05    534  	qls	0,al			no, shift.
    000455  aa   000007 7100 04    535  	tra	lshret1-*,ic
                                   536  
    000456  aa   000000 5310 00    537  lshneg:	neg	0			get count of right shifts
    000457  aa   000044 1150 07    538  	cmpa	36,dl			shift right out of reg?
    000460  aa   000003 6050 04    539  	tpl	lshret0-*,ic		yes, result is zero
    000461  aa   000000 7720 05    540  	qrl	0,al			no, do the shift
    000462  aa   000002 7100 04    541  	tra	lshret1-*,ic
                                   542  
    000463  aa   000000 2360 07    543  lshret0:	ldq	0,dl
    000464  aa   040047 2350 07    544  lshret1:	lda	fixnum_type,dl
    000465  aa  0 77774 3501 00    545  	eppap	ap|-4
    000466  aa  2 00000 7101 00    546  	tra	bp|0
                                   547  
                                   548  " fsc function, takes a flonum and scales it. (ade instruction).
                                   549  
                        000467     550  	segdef	fsc
    000467  aa   777524 6260 00    551  fsc:	eax6	fn_fsc
    000470  aa   777774 6240 00    552  	eax4	-4		" first arg must be a fixnum or flonum
    000471  0a   000001 7000 00    553  	tsx0	numval
    000472  aa   777776 6240 00    554  	eax4	-2
    000473  0a   000166 7000 00    555  	tsx0	fixval
                                   556  
    000474  aa  0 77777 2351 00    557  	lda	ap|-1		" get scale factor.
    000475  aa   000034 7350 00    558  	als	36-8		" shift to exponent position.
    000476  aa  0 77777 7551 00    559  	sta	ap|-1
    000477  aa  0 77775 4311 00    560  	fld	ap|-3		" load up the floating point number.
    000500  aa   400000 4750 03    561  	fad	=0.0,du		" normalize
    000501  aa  0 77777 4151 00    562  	ade	ap|-1		" scale.
    000502  aa  0 77775 4551 00    563  	fst	ap|-3
    000503  aa  0 77775 2361 00    564  	ldq	ap|-3
    000504  aa   020047 2350 07    565  	lda	flonum_type,dl
                                   566  
    000505  aa  0 77774 3501 00    567  	eppap	ap|-4
    000506  aa  2 00000 7101 00    568  	tra	bp|0
                                   569  
                                   570  " rot function rotates a fixnum left or right a
                                   571  " specified number of binary places
                                   572  
                        000507     573  	segdef	rot			subr (2 0 0)
                                   574  
    000507  aa   777704 6260 00    575  rot:	eax6	fn_rot
    000510  aa   777774 6240 00    576  	eax4	-4			arg1 must be fixnum
    000511  aa   777455 7000 04    577  	tsx0	fixval-*,ic
    000512  aa   777776 6240 00    578  	eax4	-2			arg2 must be fixnum
    000513  aa   777453 7000 04    579  	tsx0	fixval-*,ic
    000514  aa  0 77777 2361 00    580  	ldq	ap|-1			get shift count
    000515  aa   000044 5060 07    581  	div	36,dl			modulo word length
    000516  aa   000000 0750 07    582  	ada	0,dl			set indicators from a (remainder)
    000517  aa   000002 6050 04    583  	tpl	2,ic
    000520  aa   000044 0750 07    584  	ada	36,dl			if right rot is indicated, use
                                   585  					"the equivalent left rot.
    000521  aa   000004 6000 04    586  	tze	rot0-*,ic			if shift count is zero
    000522  aa  0 77775 2361 00    587  	ldq	ap|-3			get number to be rotated
    000523  aa   000000 7760 05    588  	qlr	0,al			do it
    000524  aa   777740 7100 04    589  	tra	lshret1-*,ic		and return it.
                                   590  
    000525  aa  0 77775 2361 00    591  rot0:	ldq	ap|-3			(rot num 0)
    000526  aa   777736 7100 04    592  	tra	lshret1-*,ic		just returns argument 1.
                                   593  
                                   594  " ifix function -- fixes a floating argument, into a fixnum.
                                   595  " if arg is too large, is an error.
                                   596  
                        000527     597  	segdef	ifix
    000527  aa   777525 6260 00    598  ifix:	eax6	fn_ifix
    000530  aa   777776 6240 00    599  	eax4	-2
    000531  0a   000160 7000 00    600  	tsx0	floval
    000532  aa  0 77777 4311 00    601  	fld	ap|-1
    000533  0a   000543 4250 00    602  	fcmg	maxfix
    000534  aa   000003 6040 04    603  	tmi	3,ic
    000535  0a   000007 7020 00    604  	tsx2	badarg
    000536  0a   000527 7100 00    605  	tra	ifix
    000537  aa   216000 4350 03    606  	ufa	=71b25,du
    000540  aa   040047 2350 07    607  	lda	fixnum_type,dl
    000541  aa  0 77776 3501 00    608  	eppap	ap|-2
    000542  aa  2 00000 7101 00    609  	tra	bp|0
    000543  aa   110400 000000     610  maxfix:	vfd	8/36,1/0,1/1	" maximum fixnum in flonum form.
                                   611  
                                   612  " boole function
                                   613  " uses first arg to determine operation to be performed on remaining args
                                   614  
                        000544     615  	segdef	boole			lsubr (777003 0 0)
                                   616  
    000544  aa   777705 6260 00    617  boole:	eax6	fn_boole
    000545  aa   000000 6240 15    618  	eax4	0,x5
    000546  aa   777420 7000 04    619  	tsx0	fixval-*,ic		get first arg which must be fixnum
    000547  aa  0 00001 2351 14    620  	lda	ap|1,x4			get first arg
    000550  aa   000017 3750 07    621  	ana	=o17,dl			low 4 bits only
    000551  aa   000001 7350 00    622  	als	1			times 2
    000552  aa   000000 6230 05    623  	eax3	0,al			put into x3
    000553  aa   000002 6240 14    624  	eax4	2,x4			get 2nd arg
    000554  aa   777412 7000 04    625  	tsx0	fixval-*,ic
    000555  aa  0 00001 2351 14    626  	lda	ap|1,x4			put second arg in result accumulator
    000556                         627  boole_loop:
    000556  aa   000002 6240 14    628  	eax4	2,x4			get next arg
    000557  aa   000004 6050 04    629  	tpl	boole_fin-*,ic		done -- leave.
    000560  aa   777406 7000 04    630  	tsx0	fixval-*,ic
                                   631  
    000561  0a   000570 7170 13    632  	xed	boole_op,x3		do operation
    000562  aa   777774 7100 04    633  	tra	boole_loop-*,ic		and get next arg
                                   634  
    000563  aa   000044 7730 00    635  boole_fin: lrl	36			make fixnum to return
    000564  aa   040047 2350 07    636  	lda	fixnum_type,dl
    000565  aa  0 00000 3501 15    637  	eppap	ap|0,x5
    000566  aa  2 00000 7101 00    638  	tra	bp|0
                                   639  
                                   640  " table of operations for boole
                                   641  " the first operand is in the a
                                   642  " the second operand is in ap|1,x4
                                   643  " the result goes in the a
                                   644  " these operations are called by xed.
                                   645  
    000567  aa   000000 0110 03    646  	even
    000570                         647  boole_op:
    000570  aa   000000 2350 07    648  	lda	0,dl			(0) SETZ
    000571  0a   000556 7100 00    649  	tra	boole_loop
                                   650  
    000572  aa  0 00001 3751 14    651  	ana	ap|1,x4			(1) AND
    000573  0a   000556 7100 00    652  	tra	boole_loop
                                   653  
    000574  0a   000630 6750 00    654  	era	ones			(2) ANDCA
    000575  aa  0 00001 3751 14    655  	ana	ap|1,x4
                                   656  
    000576  aa  0 00001 2351 14    657  	lda	ap|1,x4			(3) SETM
    000577  0a   000556 7100 00    658  	tra	boole_loop
                                   659  
    000600  0a   000630 6750 00    660  	era	ones			(4) ANDCM
    000601  0a   000610 7170 00    661  	xed	andcb
                                   662  
    000602  0a   000556 7100 00    663  	tra	boole_loop		(5) SETA
    000603  aa   000000 0110 03    664  	nop	0,du
                                   665  
    000604  aa  0 00001 6751 14    666  	era	ap|1,x4			(6) XOR
    000605  0a   000556 7100 00    667  	tra	boole_loop
                                   668  
    000606  aa  0 00001 2751 14    669  	ora	ap|1,x4			(7) IOR
    000607  0a   000556 7100 00    670  	tra	boole_loop
                                   671  
    000610  aa  0 00001 2751 14    672  andcb:	ora	ap|1,x4			(10) ANDCB
    000611  0a   000630 6750 00    673  	era	ones
                                   674  
    000612  aa  0 00001 6751 14    675  	era	ap|1,x4			(11) EQV
    000613  0a   000630 6750 00    676  	era	ones
                                   677  
    000614  0a   000630 6750 00    678  	era	ones			(12) SETCA
    000615  0a   000556 7100 00    679  	tra	boole_loop
                                   680  
    000616  0a   000630 6750 00    681  	era	ones			(13) ORCA
    000617  aa  0 00001 2751 14    682  	ora	ap|1,x4
                                   683  
    000620  aa  0 00001 2351 14    684  	lda	ap|1,x4			(14) SETCM
    000621  0a   000630 6750 00    685  	era	ones
                                   686  
    000622  0a   000630 6750 00    687  	era	ones			(15) ORCM
    000623  0a   000624 7170 00    688  	xed	orcb
                                   689  
    000624  aa  0 00001 3751 14    690  orcb:	ana	ap|1,x4			(16) ORCB
    000625  0a   000630 6750 00    691  	era	ones
                                   692  
    000626  0a   000630 2350 00    693  	lda	ones			(17) SETO
    000627  0a   000556 7100 00    694  	tra	boole_loop
                                   695  
                                   696  " constant for complementing - all ones
                                   697  
    000630  aa   777777 777777     698  ones:	oct	777777777777
                                   699  
                                   700  " the single-word comparison operators, <, > and =, must check for error
                                   701  " cases in the interpreter, so they are not identical to greaterp, lessp and eq.
                                   702  
                        000631     703  	segdef	ls_
    000631  aa   777622 6260 00    704  ls_:	eax6	fn_ls
    000632  0a   000646 7030 00    705  	tsx3	compare_words_with_type
    000633  0a   000663 6040 00    706  	tmi	ret_t_2
    000634  0a   000666 7100 00    707  	tra	ret_nil_2
                                   708  
                        000635     709  	segdef	gt_
    000635  aa   777620 6260 00    710  gt_:	eax6	fn_gt
    000636  0a   000646 7030 00    711  	tsx3	compare_words_with_type
    000637  0a   000666 6000 00    712  	tze	ret_nil_2
    000640  0a   000663 6050 00    713  	tpl	ret_t_2
    000641  0a   000666 7100 00    714  	tra	ret_nil_2
                                   715  
                        000642     716  	segdef	eql_
    000642  aa   777621 6260 00    717  eql_:	eax6	fn_eql
    000643  0a   000646 7030 00    718  	tsx3	compare_words_with_type
    000644  0a   000663 6000 00    719  	tze	ret_t_2
    000645  0a   000666 7100 00    720  	tra	ret_nil_2
                                   721  
                                   722  
    000646                         723  compare_words_with_type:
    000646  aa   777774 6240 00    724  	eax4	-4		get first argument.
    000647  0a   000001 7000 00    725  	tsx0	numval		evaluate number...make sure it is one word fix or float
    000650  0a   000656 7100 00    726  	tra	cmp_flt		if float, numval does not skip.
    000651  aa   777776 6240 00    727  	eax4	-2
    000652  0a   000166 7000 00    728  	tsx0	fixval		verify that val is fixed.
    000653  aa  0 77775 2361 00    729  	ldq	ap|-3
    000654  aa  0 77777 1161 00    730  	cmpq	ap|-1
    000655  aa   000000 7100 13    731  	tra	0,x3		x3 must have been preserved.
                                   732  
    000656  aa   777776 6240 00    733  cmp_flt:	eax4	-2
    000657  0a   000160 7000 00    734  	tsx0	floval		verfy second arg is also float.
    000660  aa  0 77775 4311 00    735  	fld	ap|-3
    000661  aa  0 77777 5151 00    736  	fcmp	ap|-1
    000662  aa   000000 7100 13    737  	tra	0,x3		return
                                   738  
    000663  aa  1 00014 2371 00    739  ret_t_2:	ldaq	ab|true		return t.
    000664  aa  0 77774 3501 00    740  	eppap	ap|-4
    000665  aa  2 00000 7101 00    741  	tra	bp|0		and go to caller.
                                   742  
    000666                         743  ret_nil_2:
    000666  aa  1 00012 2371 00    744  	ldaq	ab|nil		load up nil.
    000667  aa  0 77774 3501 00    745  	eppap	ap|-4
    000670  aa  2 00000 7101 00    746  	tra	bp|0		return to caller.
                                   747  
                                   748  " the typep function returns an atomic symbol
                                   749  " whose name designates the type of object given it as argument.
                                   750  " This is a type 1 subr since the return values are constants
                                   751  " in lisp_static_vars_ (We need our lp)
                                   752  
                        000671     753  	segdef	typep			subr (1 1 0)
                                   754  
                                   755  " define constants in lisp_static_vars_
                                   756  
                        000012     757  	link	pname,<lisp_static_vars_>|[pname_atom]
                        000014     758  	link	string,<lisp_static_vars_>|[string_atom]
                        000016     759  	link	fixnum,<lisp_static_vars_>|[fixnum_atom]
                        000020     760  	link	flonum,<lisp_static_vars_>|[flonum_atom]
                        000022     761  	link	random,<lisp_static_vars_>|[random_atom]
                        000024     762  	link	bignum,<lisp_static_vars_>|[bignum_atom]
                        000026     763  	link	list,<lisp_static_vars_>|[list_atom]
                        000030     764  	link	array,<lisp_static_vars_>|[array_atom]
                                   765  
    000671  aa  0 77776 2351 00    766  typep:	lda	ap|-2			get argument
    000672  aa  0 77776 3501 00    767  	eppap	ap|-2			pop pdl
    000673  aa   000040 6000 04    768  	tze	typep_4-*,ic		Undefined = random
    000674  aa   010000 3150 07    769  	cana	Atsym,dl
    000675  aa   000022 6010 04    770  	tnz	typep_1-*,ic
    000676  aa   001000 3150 07    771  	cana	Big_fixed,dl
    000677  aa   000026 6010 04    772  	tnz	typep_big-*,ic
    000700  aa   040000 3150 07    773  	cana	Fixed,dl
    000701  aa   000026 6010 04    774  	tnz	typep_2-*,ic
    000702  aa   020000 3150 07    775  	cana	Float,dl
    000703  aa   000026 6010 04    776  	tnz	typep_3-*,ic
    000704  aa   004000 3150 07    777  	cana	String,dl
    000705  aa   000016 6010 04    778  	tnz	typep_str-*,ic
    000706  aa   000200 3150 07    779  	cana	Array,dl
    000707  aa   000012 6010 04    780  	tnz	typep_array-*,ic
    000710  aa   077700 3150 07    781  	cana	lisp_ptr.type,dl
    000711  aa   000022 6010 04    782  	tnz	typep_4-*,ic
    000712  4a  4 00026 2371 20    783  	ldaq	lp|list,*
    000713                         784  typep_xx:
    000713                         785  retrn_type_1:
    000713  aa  1 77774 3701 37    786  	epplp	ab|-4,x7*			return from type 1 subr
    000714  aa  1 77776 3521 37    787  	eppbp	ab|-2,x7*
    000715  aa   777774 6270 17    788  	eax7	-4,x7
    000716  aa  2 00000 7101 00    789  	tra	bp|0
                                   790  
    000717  4a  4 00012 2371 20    791  typep_1:	ldaq	lp|pname,*
    000720  aa   777773 7100 04    792  	tra	typep_xx-*,ic
                                   793  
    000721                         794  typep_array:
    000721  4a  4 00030 2371 20    795  	ldaq	lp|array,*
    000722  aa   777771 7100 04    796  	tra	typep_xx-*,ic
                                   797  
    000723  4a  4 00014 2371 20    798  typep_str:ldaq	lp|string,*
    000724  aa   777767 7100 04    799  	tra	typep_xx-*,ic
                                   800  
    000725  4a  4 00024 2371 20    801  typep_big:ldaq	lp|bignum,*
    000726  aa   777765 7100 04    802  	tra	typep_xx-*,ic
                                   803  
    000727  4a  4 00016 2371 20    804  typep_2:	ldaq	lp|fixnum,*
    000730  aa   777763 7100 04    805  	tra	typep_xx-*,ic
                                   806  
    000731  4a  4 00020 2371 20    807  typep_3:	ldaq	lp|flonum,*
    000732  aa   777761 7100 04    808  	tra	typep_xx-*,ic
                                   809  
    000733  4a  4 00022 2371 20    810  typep_4:	ldaq	lp|random,*
    000734  aa   777757 7100 04    811  	tra	typep_xx-*,ic
                                   812  
                        000735     813  	entry	pl1_sxhash
    000735                         814  pl1_sxhash:
    000735  4a  4 00040 3511 20    815  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000736  4a  4 00036 3501 20    816  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000737  4a  4 00034 2271 20    817  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000740  aa  1 00016 4501 00    818  	stz	ab|in_pl1_code
    000741  aa   000004 6270 17    819  	eax7	4,x7
    000742  aa  1 77774 6501 17    820  	sprilp	ab|-4,x7		" save lp and return address.
    000743  aa  1 77776 3571 17    821  	stcd	ab|-2,x7
    000744  0a   000753 7100 00    822  	tra	sxhash		" and call the lisp routine.
    000745  aa  0 00002 3501 00    823  	eppap	ap|2		" now put result back on stack.
    000746  aa  0 77776 7571 00    824  	staq	ap|-2
    000747  4a  4 00032 2501 20    825  	spriap	<lisp_static_vars_>|[stack_ptr]
    000750  4a  4 00034 7471 20    826  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000751  aa  1 00016 5541 00    827  	stc1	ab|in_pl1_code
    000752  aa  7 00044 7101 20    828  	short_return
                                   829  
                        000753     830  	segdef	sxhash		" s-expression hash routine.
    000753  aa   000000 6250 17    831  sxhash:	eax5	0,x7		" x5 points to two numeric temps.
    000754  aa   000002 6270 17    832  	eax7	2,x7		" x7 keeps top of stack, as usual.
    000755  aa  1 00000 4501 15    833  	stz	ab|0,x5		" make sure result starts at zero.
    000756  aa  0 77776 2371 00    834  	ldaq	ap|-2		" load argument.
    000757  0a   000765 7060 00    835  	tsx6	hash_fcn	" call hasher.
    000760  aa  1 00000 2361 15    836  	ldq	ab|0,x5		" load result
    000761  aa   777776 6270 17    837  	eax7	-2,x7
    000762  aa  0 77776 3501 00    838  	eppap	ap|-2		" pop arg off stack
    000763  aa   040047 2350 07    839  	lda	fixnum_type,dl	" make it a fixnum to return
    000764  0a   000713 7100 00    840  	tra	retrn_type_1	" and return.
                                   841  
    000765  aa   040047 1150 07    842  hash_fcn:	cmpa	fixnum_type,dl	" check type and go to appropriate routine
    000766  0a   001022 6000 00    843  	tze	hash_fix
    000767  aa   020047 1150 07    844  	cmpa	flonum_type,dl
    000770  0a   001025 6000 00    845  	tze	hash_float
    000771  aa   010000 3150 07    846  	cana	Atsym,dl
    000772  0a   001037 6010 00    847  	tnz	hash_sym
    000773  aa   001000 3150 07    848  	cana	Big_fixed,dl
    000774  0a   001057 6010 00    849  	tnz	hash_big
    000775  aa   004000 3150 07    850  	cana	String,dl
    000776  0a   001055 6010 00    851  	tnz	hash_str
    000777  aa   077700 3150 07    852  	cana	Atomic,dl
    001000  aa   000000 6010 16    853  	tnz	0,x6		" return if unknown type.
                                   854  
    001001  aa  0 77776 3521 20    855  	eppbp	ap|-2,*
    001002  aa  0 00002 3501 00    856  	eppap	ap|2		" must get car and cdr of list.
    001003  aa  2 00002 2371 00    857  	ldaq	bp|2
    001004  aa  0 77774 7571 00    858  	staq	ap|-4		" store cdr for later use
    001005  aa  2 00000 2371 00    859  	ldaq	bp|0
    001006  aa  0 77776 7571 00    860  	staq	ap|-2		" and make car the arg.
    001007  aa   000002 6270 17    861  	eax7	2,x7		" get room to save return address
    001010  aa  1 77776 7461 17    862  	stx6	ab|-2,x7		" store return address.
    001011  0a   000765 7060 00    863  	tsx6	hash_fcn
    001012  aa  1 00000 2361 15    864  	ldq	ab|0,x5		" now rotate hash result right.
    001013  aa   000043 7760 00    865  	qlr	35		" rotate right 1
    001014  aa  1 00000 7561 15    866  	stq	ab|0,x5
    001015  aa  1 77776 2261 17    867  	ldx6	ab|-2,x7		" get back return address.
    001016  aa   777776 6270 17    868  	eax7	-2,x7
    001017  aa  0 77776 3501 00    869  	eppap	ap|-2		" pop off stacks
    001020  aa  0 77776 2371 00    870  	ldaq	ap|-2		" get cdr of list
    001021  0a   000765 7100 00    871  	tra	hash_fcn	" and go back and try again.
                                   872  
    001022  aa  1 00000 0361 15    873  hash_fix:	adlq	ab|0,x5
    001023  aa  1 00000 7561 15    874  	stq	ab|0,x5		" store new hash result.
    001024  aa   000000 7100 16    875  	tra	0,x6
                                   876  
    001025                         877  hash_float:
    001025  aa  0 77777 4311 00    878  	fld	ap|-1		" fix up float number for compatibility with PDP10
    001026  aa   000003 6050 04    879  	tpl	3,ic
    001027  aa   000000 5130 07    880  	fneg	0,dl
    001030  aa  0 77777 4551 00    881  	fst	ap|-1		" store abs val back
    001031  aa  0 77777 2361 00    882  	ldq	ap|-1		" now get word of float number
    001032  aa   000011 7370 00    883  	lls	9
    001033  aa   000777 3750 07    884  	ana	=o777,dl
    001034  aa   000001 7310 00    885  	ars	1
    001035  aa   000011 7730 00    886  	lrl	9		" move back to q
    001036  0a   001022 7100 00    887  	tra	hash_fix
                                   888  
    001037  aa  0 77776 3521 20    889  hash_sym:	eppbp	ap|-2,*		" get pointer to atsym
    001040  aa  2 00004 3521 00    890  	eppbp	bp|4		" make pointer point to string.
    001041                         891  hash_chrs:
    001041  aa  2 00000 2361 00    892  	ldq	bp|0		" load length
    001042  aa   000000 6000 16    893  	tze	0,x6		" if zero, don't bother with rest
    001043  aa   000003 0760 07    894  	adq	3,dl
    001044  aa   000002 7320 00    895  	qrs	2		" divide by 4
    001045  aa   000000 6240 06    896  hash_com:	eax4	0,ql		" and move length to x4
    001046  aa  1 00001 4501 15    897  	stz	ab|1,x5		" zero temporary.
    001047  aa  2 00000 2361 14    898  	ldq	bp|0,x4		" load the last word so far of the string
    001050  aa  1 00001 6561 15    899  	ersq	ab|1,x5		" and xor into result
    001051  aa   777777 6240 14    900  	eax4	-1,x4		" move back
    001052  aa   777775 6010 04    901  	tnz	-3,ic		" and loop
    001053  aa  1 00001 2361 15    902  	ldq	ab|1,x5		" load up the hash result
    001054  0a   001022 7100 00    903  	tra	hash_fix		" and put it into result
                                   904  
    001055  aa  0 77776 3521 20    905  hash_str:	eppbp	ap|-2,*
    001056  0a   001041 7100 00    906  	tra	hash_chrs
                                   907  
    001057  aa  0 77776 3521 20    908  hash_big:	eppbp	ap|-2,*		" get pointer to bignum
    001060  aa  2 00000 2361 00    909  	ldq	bp|0		" get number of words
    001061  aa   777777 3760 07    910  	anq	-1,dl		" and mask word length out
    001062  0a   001045 7100 00    911  	tra	hash_com
                                   912  
                                   913  " the signp function, which tests whether the sign
                                   914  " of the second argument (evaluated) matches the sign of the
                                   915  " designation in the first argument (unevaluated), which can
                                   916  " be l,le,e,n,ge,g,a
                                   917  " this is a type 1 subr since it needs to call eval.
                                   918  
                        001063     919  	segdef	signp			fsubr (0 1 0)
                                   920  
    001063  aa  0 00002 3501 00    921  signp:	eppap	ap|2			room for temp
    001064  aa   000002 6220 00    922  	eax2	2
    001065  aa  0 77774 3521 72    923  	eppbp	ap|-4,*2			bp = cdr of arg list
    001066  aa  2 00000 3521 20    924  	eppbp	bp|0,*
    001067  aa  2 00000 2371 00    925  	ldaq	bp|0			get cadr of arg list, = 2nd arg
    001070  aa  0 77776 7571 00    926  	staq	ap|-2			save for evaluation
    001071  aa  0 77774 2371 20    927  	ldaq	ap|-4,*			get car of arg list
    001072  aa  0 77774 7571 00    928  	staq	ap|-4			save it.
    001073  aa   000004 6270 17    929  	eax7	4,x7			call eval to do 2nd arg
    001074  aa  1 77774 6501 17    930  	sprilp	ab|-4,x7
    001075  aa   777776 6250 00    931  	eax5	-2
    001076  aa  1 77776 3571 17    932  	stcd	ab|-2,x7			**** Must be bound in with lisp_
    001077  4a  4 00042 7101 20    933  	tra	<lisp_>|[eval_]
    001100  aa  0 00002 3501 00    934  	eppap	ap|2			put result back in pdl
    001101  aa  0 77776 7571 00    935  	staq	ap|-2
    001102  aa   020047 1150 07    936  	cmpa	flonum_type,dl
    001103  aa   000014 6000 04    937  	tze	signp_flt-*,ic
    001104  aa   001000 3150 07    938  	cana	Big_fixed,dl
    001105  aa   000007 6010 04    939  	tnz	signp_big-*,ic
    001106  aa   040047 1150 07    940  	cmpa	fixnum_type,dl
    001107  aa   000076 6010 04    941  	tnz	signp_nil-*,ic		not a number, just return nil.
    001110  aa  0 77777 2341 00    942  	szn	ap|-1
    001111  aa   000012 6040 04    943  	tmi	signp_neg-*,ic
    001112  aa   000013 6000 04    944  	tze	signp_zero-*,ic
    001113  aa   000014 6050 04    945  	tpl	signp_plus-*,ic
                                   946  
    001114  aa  0 77776 2341 20    947  signp_big:szn	ap|-2,*		points at first word of bignum, upper bit = sign.
    001115  aa   000006 6040 04    948  	tmi	signp_neg-*,ic
    001116  aa   000011 7100 04    949  	tra	signp_plus-*,ic	can't be zero if a bignum.
    001117  aa  0 77777 4301 00    950  signp_flt:fszn	ap|-1
    001120  aa   000003 6040 04    951  	tmi	signp_neg-*,ic
    001121  aa   000004 6000 04    952  	tze	signp_zero-*,ic
    001122  aa   000005 6050 04    953  	tpl	signp_plus-*,ic
                                   954  
                                   955  
    001123  aa   777777 6250 00    956  signp_neg:eax5	-1
    001124  aa   000004 7100 04    957  	tra	signp_com-*,ic
                                   958  
    001125                         959  signp_zero:
    001125  aa   000000 6250 00    960  	eax5	0
    001126  aa   000002 7100 04    961  	tra	signp_com-*,ic
                                   962  
    001127                         963  signp_plus:
    001127  aa   000001 6250 00    964  	eax5	+1
                                   965  	"tra	signp_com-*,ic
                                   966  
    001130                         967  signp_com:
                                   968  	" decode first argument
                                   969  
    001130  aa  0 77774 2351 00    970  	lda	ap|-4			must be atomic symbol
    001131  aa   010000 3150 07    971  	cana	Atsym,dl
    001132  aa   000056 6000 04    972  	tze	bad_signp-*,ic
    001133  aa  0 77774 3521 20    973  	eppbp	ap|-4,*			-> atomic symbol
    001134  aa  2 00004 2351 00    974  	lda	bp|4			get pnamel
    001135  aa   000001 1150 07    975  	cmpa	1,dl
    001136  aa   000030 6010 04    976  	tnz	signp_2-*,ic
                                   977  					" must be l,g,a,e,n
    001137  aa  2 00005 2351 00    978  	lda	bp|5			get the 1 char pname
    001140  aa   154000 1150 03    979  	cmpa	=o154000,du		l ?
    001141  aa   000004 6010 04    980  	tnz	xx01-*,ic
    001142  aa   777777 1050 03    981  	  cmpx5	 -1,du			yes, neg?
    001143  aa   000040 6000 04    982  	  tze	 signp_t-*,ic		yes, return t.
    001144  aa   000041 7100 04    983  	  tra	 signp_nil-*,ic		no, return nil
    001145  aa   147000 1150 03    984  xx01:	cmpa	=o147000,du		g ?
    001146  aa   000004 6010 04    985  	tnz	xx02-*,ic
    001147  aa   000001 1050 03    986  	 cmpx5	 +1,du			yes, pos?
    001150  aa   000033 6000 04    987  	 tze	 signp_t-*,ic		yes, return t.
    001151  aa   000034 7100 04    988  	 tra	 signp_nil-*,ic		no, return nil.
    001152  aa   141000 1150 03    989  xx02:	cmpa	=o141000,du		a ?
    001153  aa   000030 6000 04    990  	tze	signp_t-*,ic		yes, always t.
    001154  aa   145000 1150 03    991  	cmpa	=o145000,du		e ?
    001155  aa   000004 6010 04    992  	tnz	xx03-*,ic
    001156  aa   000000 1050 03    993  	 cmpx5	 0,du			yes, zero?
    001157  aa   000024 6000 04    994  	 tze	 signp_t-*,ic		yes, return t.
    001160  aa   000025 7100 04    995  	 tra	 signp_nil-*,ic		no, return nil.
    001161  aa   156000 1150 03    996  xx03:	cmpa	=o156000,du		n ?
    001162  aa   000026 6010 04    997  	tnz	bad_signp-*,ic		no, illegal.
    001163  aa   000000 1050 03    998  	 cmpx5	 0,du			yes, nonzero?
    001164  aa   000017 6010 04    999  	 tnz	 signp_t-*,ic		yes, return t.
    001165  aa   000020 7100 04   1000  	 tra	 signp_nil-*,ic		no, return nil.
                                  1001  
                                  1002  " signp with 1st arg of length 2. Must be le or ge
                                  1003  
    001166  aa   000002 1150 07   1004  signp_2:	cmpa	2,dl			really length 2?
    001167  aa   000021 6010 04   1005  	tnz	bad_signp-*,ic		no, error.
    001170  aa  2 00005 2351 00   1006  	lda	bp|5			yes, get the pname
    001171  aa   147145 1150 03   1007  	cmpa	=o147145,du		ge ?
    001172  aa   000004 6010 04   1008  	tnz	xx04-*,ic
    001173  aa   000000 1050 03   1009  	 cmpx5	 0,du			yes, pos or 0?
    001174  aa   000007 6050 04   1010  	 tpl	 signp_t-*,ic		yes, return t.
    001175  aa   000010 7100 04   1011  	 tra	 signp_nil-*,ic		no, return nil.
    001176  aa   154145 1150 03   1012  xx04:	cmpa	=o154145,du		le ?
    001177  aa   000011 6010 04   1013  	tnz	bad_signp-*,ic		no, error.
    001200  aa   000001 1050 03   1014  	 cmpx5	 1,du			is it neg or zero?
    001201  aa   000002 6010 04   1015  	 tnz	 signp_t-*,ic		yes, return t.
    001202  aa   000003 7100 04   1016  	 tra	 signp_nil-*,ic		no, return nil.
                                  1017  
                                  1018  " routines to return t or nil for signp
                                  1019  
    001203  aa  1 00014 2371 00   1020  signp_t:	ldaq	ab|t
    001204  aa   000002 7100 04   1021  	tra	2,ic
                                  1022  
    001205  aa  1 00012 2371 00   1023  signp_nil:ldaq	ab|nil
    001206                        1024  subr_1_2_exit:
    001206  aa  0 77774 3501 00   1025  	eppap	ap|-4
    001207  aa   777504 7100 04   1026  	tra	typep_xx-*,ic		exit from type 1 subr
                                  1027  
                                  1028  " come here when first arg to signp is bad.
                                  1029  
    001210  aa   777774 6240 00   1030  bad_signp:eax4	-4
    001211  aa   777702 6260 00   1031  	eax6	fn_signp
    001212  aa   777716 6220 04   1032  	eax2	signp_com-*,ic
    001213  aa   776574 7100 04   1033  	tra	badarg-*,ic		returns to signp_com
                                  1034  
                        001214    1035  	segdef	fixgcd	" lisp \\ subr.
    001214  aa   777612 6260 00   1036  fixgcd:	eax6	fn_gcd
    001215  aa   777774 6240 00   1037  	eax4	-4
    001216  0a   000166 7000 00   1038  	tsx0	fixval
    001217  aa   777776 6240 00   1039  	eax4	-2
    001220  0a   000166 7000 00   1040  	tsx0	fixval
    001221  aa  0 77775 2351 00   1041  	lda	ap|-3	" load first arg
    001222  0a   001226 6054 00   1042  	tpnz	pos1st
    001223  0a   000463 6000 00   1043  	tze	lshret0
    001224  aa   000000 5310 00   1044  	neg	0
    001225  aa  0 77775 7551 00   1045  	sta	ap|-3
    001226  aa  0 77777 2351 00   1046  pos1st:	lda	ap|-1
    001227  0a   001233 6054 00   1047  	tpnz	pos2nd
    001230  0a   000463 6000 00   1048  	tze	lshret0
    001231  aa   000000 5310 00   1049  	neg	0
    001232  aa  0 77777 7551 00   1050  	sta	ap|-1
    001233  aa  0 77775 1151 00   1051  pos2nd:	cmpa	ap|-3
    001234  0a   001240 6040 00   1052  	tmi	noexch
    001235  aa  0 77775 2361 00   1053  	ldq	ap|-3
    001236  aa  0 77777 7561 00   1054  	stq	ap|-1
    001237  aa  0 77775 7551 00   1055  	sta	ap|-3
    001240  aa  0 77775 2361 00   1056  noexch:	ldq	ap|-3
    001241  aa  0 77777 5061 00   1057  	div	ap|-1
    001242  aa   000000 1150 07   1058  	cmpa	0,dl
    001243  0a   001247 6000 00   1059  	tze	retgcd
    001244  aa  0 77777 2361 00   1060  	ldq	ap|-1
    001245  aa  0 77777 7551 00   1061  	sta	ap|-1
    001246  aa   777773 7100 04   1062  	tra	-5,ic
    001247  aa  0 77776 2371 00   1063  retgcd:	ldaq	ap|-2
    001250  aa  0 77774 3501 00   1064  	eppap	ap|-4
    001251  aa  2 00000 7101 00   1065  	tra	bp|0
                                  1066  
                                  1067  	end
ENTRY SEQUENCES
     
    001252  5a   000030 0000 00
    001253  aa  7 00046 2721 20
    001254  0a   000735 7100 00
LITERALS
     
    001256  aa   000000 000000 
    001257  aa   000000 000000 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001260  5a   000003 000000 
    001261  5a   000241 600000 
    001262  aa   000000 000000 
    001263  55   000011 000002 
    001264  5a   000002 400003 
    001265  55   000006 000011 
    001266  aa  013 154 151 163
    001267  aa  160 137 165 164
    001270  aa  151 154 163 137
    001271  55   000016 000003 
    001272  0a   001214 400000 
    001273  55   000014 000003 
    001274  aa  006 146 151 170         fixgcd
    001275  aa  147 143 144 000
    001276  55   000023 000011 
    001277  0a   001063 400000 
    001300  55   000021 000003 
    001301  aa  005 163 151 147         signp
    001302  aa  156 160 000 000
    001303  55   000030 000016 
    001304  0a   000753 400000 
    001305  55   000026 000003 
    001306  aa  006 163 170 150         sxhash
    001307  aa  141 163 150 000
    001310  55   000036 000023 
    001311  0a   001253 500000 
    001312  55   000033 000003 
    001313  aa  012 160 154 061         pl1_sxhash
    001314  aa  137 163 170 150
    001315  aa  141 163 150 000
    001316  55   000043 000030 
    001317  0a   000671 400000 
    001320  55   000041 000003 
    001321  aa  005 164 171 160         typep
    001322  aa  145 160 000 000
    001323  55   000050 000036 
    001324  0a   000642 400000 
    001325  55   000046 000003 
    001326  aa  004 145 161 154         eql_
    001327  aa  137 000 000 000
    001330  55   000054 000043 
    001331  0a   000635 400000 
    001332  55   000053 000003 
    001333  aa  003 147 164 137         gt_
    001334  55   000060 000050 
    001335  0a   000631 400000 
    001336  55   000057 000003 
    001337  aa  003 154 163 137         ls_
    001340  55   000065 000054 
    001341  0a   000544 400000 
    001342  55   000063 000003 
    001343  aa  005 142 157 157         boole
    001344  aa  154 145 000 000
    001345  55   000072 000060 
    001346  0a   000527 400000 
    001347  55   000070 000003 
    001350  aa  004 151 146 151         ifix
    001351  aa  170 000 000 000
    001352  55   000076 000065 
    001353  0a   000507 400000 
    001354  55   000075 000003 
    001355  aa  003 162 157 164         rot
    001356  55   000102 000072 
    001357  0a   000467 400000 
    001360  55   000101 000003 
    001361  aa  003 146 163 143         fsc
    001362  55   000106 000076 
    001363  0a   000441 400000 
    001364  55   000105 000003 
    001365  aa  003 154 163 150         lsh
    001366  55   000114 000102 
    001367  0a   000427 400000 
    001370  55   000111 000003 
    001371  aa  010 161 165 157         quot_flo
    001372  aa  164 137 146 154
    001373  aa  157 000 000 000
    001374  55   000122 000106 
    001375  0a   000415 400000 
    001376  55   000117 000003 
    001377  aa  010 161 165 157         quot_fix
    001400  aa  164 137 146 151
    001401  aa  170 000 000 000
    001402  55   000130 000114 
    001403  0a   000403 400000 
    001404  55   000125 000003 
    001405  aa  010 144 151 146         diff_flo
    001406  aa  146 137 146 154
    001407  aa  157 000 000 000
    001410  55   000136 000122 
    001411  0a   000371 400000 
    001412  55   000133 000003 
    001413  aa  010 144 151 146         diff_fix
    001414  aa  146 137 146 151
    001415  aa  170 000 000 000
    001416  55   000144 000130 
    001417  0a   000364 400000 
    001420  55   000141 000003 
    001421  aa  011 164 151 155         times_flo
    001422  aa  145 163 137 146
    001423  aa  154 157 000 000
    001424  55   000152 000136 
    001425  0a   000357 400000 
    001426  55   000147 000003 
    001427  aa  011 164 151 155         times_fix
    001430  aa  145 163 137 146
    001431  aa  151 170 000 000
    001432  55   000160 000144 
    001433  0a   000317 400000 
    001434  55   000155 000003 
    001435  aa  010 145 170 160         expt_flo
    001436  aa  164 137 146 154
    001437  aa  157 000 000 000
    001440  55   000166 000152 
    001441  0a   000262 400000 
    001442  55   000163 000003 
    001443  aa  010 145 170 160         expt_fix
    001444  aa  164 137 146 151
    001445  aa  170 000 000 000
    001446  55   000174 000160 
    001447  0a   000255 400000 
    001450  55   000171 000003 
    001451  aa  010 160 154 165         plus_flo
    001452  aa  163 137 146 154
    001453  aa  157 000 000 000
    001454  55   000202 000166 
    001455  0a   000250 400000 
    001456  55   000177 000003 
    001457  aa  010 160 154 165         plus_fix
    001460  aa  163 137 146 151
    001461  aa  170 000 000 000
    001462  55   000210 000174 
    001463  0a   000240 400000 
    001464  55   000205 000003 
    001465  aa  010 163 165 142         sub1_flo
    001466  aa  061 137 146 154
    001467  aa  157 000 000 000
    001470  55   000216 000202 
    001471  0a   000232 400000 
    001472  55   000213 000003 
    001473  aa  010 163 165 142         sub1_fix
    001474  aa  061 137 146 151
    001475  aa  170 000 000 000
    001476  55   000224 000210 
    001477  0a   000222 400000 
    001500  55   000221 000003 
    001501  aa  010 141 144 144         add1_flo
    001502  aa  061 137 146 154
    001503  aa  157 000 000 000
    001504  55   000232 000216 
    001505  0a   000213 400000 
    001506  55   000227 000003 
    001507  aa  010 141 144 144         add1_fix
    001510  aa  061 137 146 151
    001511  aa  170 000 000 000
    001512  55   000002 000224 
    001513  6a   000000 400002 
    001514  55   000235 000003 
    001515  aa  014 163 171 155         symbol_table
    001516  aa  142 157 154 137
    001517  aa  164 141 142 154
    001520  aa  145 000 000 000

DEFINITIONS HASH TABLE

    001521  aa   000000 000065 
    001522  5a   000023 000000 
    001523  5a   000102 000000 
    001524  5a   000174 000000 
    001525  5a   000210 000000 
    001526  5a   000065 000000 
    001527  aa   000000 000000 
    001530  5a   000016 000000 
    001531  aa   000000 000000 
    001532  aa   000000 000000 
    001533  aa   000000 000000 
    001534  5a   000136 000000 
    001535  5a   000144 000000 
    001536  aa   000000 000000 
    001537  5a   000076 000000 
    001540  aa   000000 000000 
    001541  5a   000072 000000 
    001542  5a   000060 000000 
    001543  5a   000122 000000 
    001544  5a   000130 000000 
    001545  aa   000000 000000 
    001546  aa   000000 000000 
    001547  aa   000000 000000 
    001550  aa   000000 000000 
    001551  aa   000000 000000 
    001552  aa   000000 000000 
    001553  aa   000000 000000 
    001554  5a   000152 000000 
    001555  5a   000160 000000 
    001556  5a   000232 000000 
    001557  5a   000030 000000 
    001560  aa   000000 000000 
    001561  aa   000000 000000 
    001562  5a   000216 000000 
    001563  5a   000224 000000 
    001564  aa   000000 000000 
    001565  aa   000000 000000 
    001566  aa   000000 000000 
    001567  aa   000000 000000 
    001570  aa   000000 000000 
    001571  aa   000000 000000 
    001572  aa   000000 000000 
    001573  aa   000000 000000 
    001574  aa   000000 000000 
    001575  aa   000000 000000 
    001576  5a   000202 000000 
    001577  5a   000054 000000 
    001600  5a   000106 000000 
    001601  5a   000114 000000 
    001602  5a   000166 000000 
    001603  5a   000011 000000 
    001604  5a   000043 000000 
    001605  5a   000036 000000 
    001606  5a   000050 000000 

EXTERNAL NAMES

    001607  aa  005 145 166 141         eval_
    001610  aa  154 137 000 000
    001611  aa  005 154 151 163         lisp_
    001612  aa  160 137 000 000
    001613  aa  011 165 156 155         unmkd_ptr
    001614  aa  153 144 137 160
    001615  aa  164 162 000 000
    001616  aa  011 163 164 141         stack_ptr
    001617  aa  143 153 137 160
    001620  aa  164 162 000 000
    001621  aa  012 141 162 162         array_atom
    001622  aa  141 171 137 141
    001623  aa  164 157 155 000
    001624  aa  011 154 151 163         list_atom
    001625  aa  164 137 141 164
    001626  aa  157 155 000 000
    001627  aa  013 142 151 147         bignum_atom
    001630  aa  156 165 155 137
    001631  aa  141 164 157 155
    001632  aa  013 162 141 156         random_atom
    001633  aa  144 157 155 137
    001634  aa  141 164 157 155
    001635  aa  013 146 154 157         flonum_atom
    001636  aa  156 165 155 137
    001637  aa  141 164 157 155
    001640  aa  013 146 151 170         fixnum_atom
    001641  aa  156 165 155 137
    001642  aa  141 164 157 155
    001643  aa  013 163 164 162         string_atom
    001644  aa  151 156 147 137
    001645  aa  141 164 157 155
    001646  aa  012 160 156 141         pname_atom
    001647  aa  155 145 137 141
    001650  aa  164 157 155 000
    001651  aa  021 154 151 163         lisp_static_vars_
    001652  aa  160 137 163 164
    001653  aa  141 164 151 143
    001654  aa  137 166 141 162
    001655  aa  163 137 000 000
    001656  aa  013 154 151 163         lisp_error_
    001657  aa  160 137 145 162
    001660  aa  162 157 162 137

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    001661  aa   000004 000000 
    001662  55   000331 000327 
    001663  aa   000004 000000 
    001664  55   000371 000333 
    001665  aa   000004 000000 
    001666  55   000371 000336 
    001667  aa   000004 000000 
    001670  55   000371 000341 
    001671  aa   000004 000000 
    001672  55   000371 000344 
    001673  aa   000004 000000 
    001674  55   000371 000347 
    001675  aa   000004 000000 
    001676  55   000371 000352 
    001677  aa   000004 000000 
    001700  55   000371 000355 
    001701  aa   000004 000000 
    001702  55   000371 000360 
    001703  aa   000004 000000 
    001704  55   000371 000363 
    001705  aa   000004 000000 
    001706  55   000371 000366 
    001707  aa   000004 000000 
    001710  55   000376 000376 
    001711  aa   000001 000000 
    001712  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    001713  5a   000401 000000 
    001714  5a   000403 000000 
    001715  5a   000403 000001 
    001716  5a   000405 000000 
    001717  5a   000407 000000 
    001720  5a   000411 000000 
    001721  5a   000413 000000 
    001722  5a   000415 000000 
    001723  5a   000417 000000 
    001724  5a   000421 000000 
    001725  5a   000423 000000 
    001726  5a   000425 000000 
    001727  5a   000427 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001260 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000044 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         lisp_error_|lisp_error_
    000011  5a   000447 0000 00
    000012  9a   777766 0000 46         lisp_static_vars_|pname_atom
    000013  5a   000446 0000 00
    000014  9a   777764 0000 46         lisp_static_vars_|string_atom
    000015  5a   000445 0000 00
    000016  9a   777762 0000 46         lisp_static_vars_|fixnum_atom
    000017  5a   000444 0000 00
    000020  9a   777760 0000 46         lisp_static_vars_|flonum_atom
    000021  5a   000443 0000 00
    000022  9a   777756 0000 46         lisp_static_vars_|random_atom
    000023  5a   000442 0000 00
    000024  9a   777754 0000 46         lisp_static_vars_|bignum_atom
    000025  5a   000441 0000 00
    000026  9a   777752 0000 46         lisp_static_vars_|list_atom
    000027  5a   000440 0000 00
    000030  9a   777750 0000 46         lisp_static_vars_|array_atom
    000031  5a   000437 0000 00
    000032  9a   777746 0000 46         lisp_static_vars_|stack_ptr
    000033  5a   000436 0000 00
    000034  9a   777744 0000 46         lisp_static_vars_|unmkd_ptr
    000035  5a   000435 0000 00
    000036  9a   777742 0000 46         lisp_static_vars_|stack_ptr
    000037  5a   000436 0000 20
    000040  9a   777740 0000 46         lisp_static_vars_|unmkd_ptr
    000041  5a   000434 0000 20
    000042  9a   777736 0000 46         lisp_|eval_
    000043  5a   000433 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   677776 300022 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000325 
    000020  aa   000000 000217 
    000021  aa   000000 000303 
    000022  aa   000313 000217 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000006 
    000066  aa   000116 000060 
    000067  aa   147740 446356 
    000070  aa   000000 114774 
    000071  aa   461267 000000 
    000072  aa   000132 000044 
    000073  aa   120017 346605 
    000074  aa   000000 112002 
    000075  aa   404115 200000 
    000076  aa   000143 000066 
    000077  aa   147714 750316 
    000100  aa   000000 114774 
    000101  aa   453561 000000 
    000102  aa   000161 000047 
    000103  aa   106701 741731 
    000104  aa   000000 110670 
    000105  aa   211444 000000 
    000106  aa   000173 000046 
    000107  aa   106701 741746 
    000110  aa   000000 110670 
    000111  aa   211450 600000 
    000112  aa   000205 000045 
    000113  aa   120017 346602 
    000114  aa   000000 112002 
    000115  aa   404115 000000 
    000116  aa   076163 160145          >special_ldd>install>MR12.0-1206>lisp_utils_.alm
    000117  aa   143151 141154 
    000120  aa   137154 144144 
    000121  aa   076151 156163 
    000122  aa   164141 154154 
    000123  aa   076115 122061 
    000124  aa   062056 060055 
    000125  aa   061062 060066 
    000126  aa   076154 151163 
    000127  aa   160137 165164 
    000130  aa   151154 163137 
    000131  aa   056141 154155 
    000132  aa   076154 144144          >ldd>include>lisp_stack_seg.incl.alm
    000133  aa   076151 156143 
    000134  aa   154165 144145 
    000135  aa   076154 151163 
    000136  aa   160137 163164 
    000137  aa   141143 153137 
    000140  aa   163145 147056 
    000141  aa   151156 143154 
    000142  aa   056141 154155 
    000143  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000144  aa   143151 141154 
    000145  aa   137154 144144 
    000146  aa   076151 156163 
    000147  aa   164141 154154 
    000150  aa   076115 122061 
    000151  aa   062056 060055 
    000152  aa   061062 060066 
    000153  aa   076163 164141 
    000154  aa   143153 137150 
    000155  aa   145141 144145 
    000156  aa   162056 151156 
    000157  aa   143154 056141 
    000160  aa   154155 040040 
    000161  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000162  aa   076151 156143 
    000163  aa   154165 144145 
    000164  aa   076154 151163 
    000165  aa   160137 157142 
    000166  aa   152145 143164 
    000167  aa   137164 171160 
    000170  aa   145163 056151 
    000171  aa   156143 154056 
    000172  aa   141154 155040 
    000173  aa   076154 144144          >ldd>include>lisp_error_codes.incl.alm
    000174  aa   076151 156143 
    000175  aa   154165 144145 
    000176  aa   076154 151163 
    000177  aa   160137 145162 
    000200  aa   162157 162137 
    000201  aa   143157 144145 
    000202  aa   163056 151156 
    000203  aa   143154 056141 
    000204  aa   154155 040040 
    000205  aa   076154 144144          >ldd>include>lisp_name_codes.incl.alm
    000206  aa   076151 156143 
    000207  aa   154165 144145 
    000210  aa   076154 151163 
    000211  aa   160137 156141 
    000212  aa   155145 137143 
    000213  aa   157144 145163 
    000214  aa   056151 156143 
    000215  aa   154056 141154 
    000216  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         213    add1_fix                 lisp_utils_:  270,  272.
         220    add1_fix_op              lisp_utils_:  274,  278.
         222    add1_flo                 lisp_utils_:  285,  287.
         226    add1_flo_op              lisp_utils_:  289,  293.
         610    andcb                    lisp_utils_:  661,  672.
         102    append_list_op           lisp_stack_seg:      43.
         250    argument_must_be_array   lisp_error_codes:    72.
         173    arith1                   lisp_utils_:  240,  275,  290,  307,  322.
         204    arith2                   lisp_utils_:  253,  257,  338,  349,  436,  447.
         200    Array                    lisp_utils_:  779,
                                         lisp_object_types:   25.
          30    array                    lisp_utils_:  764,  795.
                array_atom               lisp_utils_:  764.
         166    array_bound_error        lisp_error_codes:    26.
         122    array_info_for_store     lisp_stack_seg:      51.
         126    array_link_snap_opr      lisp_stack_seg:      53.
         124    array_offset_for_store   lisp_stack_seg:      52.
         112    array_operator           lisp_stack_seg:      47.
          10    array_pointer            lisp_stack_seg:      10.
         247    array_too_big            lisp_error_codes:    71.
         216    atan_0_0_err             lisp_error_codes:    46.
       77700    Atomic                   lisp_utils_:  852,
                                         lisp_object_types:   19.
       10000    Atsym                    lisp_utils_:  769,  846,  971,
                                         lisp_object_types:   18.
           7    badarg                   lisp_utils_:   67,  226,  233,  604, 1033.
          16    badarg1                  lisp_utils_:   74.
         163    badmacro                 lisp_error_codes:    23.
         215    badobarray               lisp_error_codes:    45.
         165    badreadlist              lisp_error_codes:    25.
         214    badreadtable             lisp_error_codes:    44.
         151    bad_argument             lisp_error_codes:    13.
         170    bad_arg_correctable      lisp_utils_:   73,
                                         lisp_error_codes:    28.
         241    bad_array_subscript      lisp_error_codes:    65.
         175    bad_base                 lisp_error_codes:    33.
         154    bad_bv                   lisp_error_codes:    16.
         232    bad_do_format            lisp_error_codes:    58.
         231    bad_entry_name           lisp_error_codes:    57.
         153    bad_function             lisp_error_codes:    15.
         206    bad_f_fcn                lisp_error_codes:    38.
         174    bad_ibase                lisp_error_codes:    32.
         176    bad_input_source         lisp_error_codes:    34.
         177    bad_output_dest          lisp_error_codes:    35.
         171    bad_prog_op              lisp_error_codes:    29.
        1210    bad_signp                lisp_utils_:  972,  997, 1005, 1013, 1030.
         100    begin_list_op            lisp_stack_seg:      42.
         174    begin_unmkd_stack        lisp_stack_seg:      66.
        1000    Bignum                   lisp_object_types:   20.
          24    bignum                   lisp_utils_:  762,  801.
                bignum_atom              lisp_utils_:  762.
        1000    Big_fixed                lisp_utils_:  771,  848,  938,
                                         lisp_object_types:   29.
          20    bind_op                  lisp_stack_seg:      17.
         544    boole                    lisp_utils_:  615,  617.
         563    boole_fin                lisp_utils_:  629,  635.
         556    boole_loop               lisp_utils_:  627,  633,  649,  652,  658,  663,  667,  670,  679,  694.
         570    boole_op                 lisp_utils_:  632,  647.
        1170    call_offset              stack_header:        80.
          32    call_op                  lisp_stack_seg:      22.
         222    cant_filepos             lisp_error_codes:    50.
         244    cant_subscript_readtable       lisp_error_codes:    68.
         167    car_cdr_error            lisp_error_codes:    27.
          34    catch1_op                lisp_stack_seg:      23.
          36    catch2_op                lisp_stack_seg:      24.
         656    cmp_flt                  lisp_utils_:  726,  733.
         106    compare_op               lisp_stack_seg:      45.
         646    compare_words_with_type  lisp_utils_:  705,  711,  718,  723.
          72    cons_op                  lisp_stack_seg:      39.
         136    cons_string_op           lisp_stack_seg:      57.
         132    create_array_desc_op     lisp_stack_seg:      55.
         130    create_string_desc_op    lisp_stack_seg:      54.
         140    create_varying_string_op       lisp_stack_seg:      58.
         114    dead_array_operator      lisp_stack_seg:      48.
         243    dead_array_reference     lisp_error_codes:    67.
         371    diff_fix                 lisp_utils_:  452,  454.
         377    diff_fix_op_1            lisp_utils_:  457,  461.
         403    diff_flo                 lisp_utils_:  469,  471.
         411    diff_flo_op_1            lisp_utils_:  474,  478.
         220    division_by_zero         lisp_error_codes:    48.
         161    doterror                 lisp_error_codes:    21.
        1174    entry_offset             stack_header:        84.
         221    eof_in_object            lisp_error_codes:    49.
         642    eql_                     lisp_utils_:  716,  717.
          24    errset1_op               lisp_stack_seg:      19.
          26    errset2_op               lisp_stack_seg:      20.
          64    err_op                   lisp_stack_seg:      36.
                eval_                    lisp_utils_:  933.
         262    expt_fix                 lisp_utils_:  354,  356.
         276    expt_fix0                lisp_utils_:  370,  381.
         304    expt_fix1                lisp_utils_:  372,  376.
         335    expt_fl0                 lisp_utils_:  403,  408,  422.
         345    expt_fl1                 lisp_utils_:  410,  416.
         317    expt_flo                 lisp_utils_:  392,  394.
          24    fatal_error              lisp_utils_:   81,  211.
         100    File                     lisp_object_types:   30.
         223    filepos_oob              lisp_error_codes:    51.
         227    file_is_closed           lisp_error_codes:    55.
         150    file_system_error        lisp_error_codes:    12.
         224    file_sys_fun_err         lisp_error_codes:    52.
       40000    Fixed                    lisp_utils_:   54,  231,  773,
                                         lisp_object_types:   15.
        1214    fixgcd                   lisp_utils_: 1035, 1036.
          16    fixnum                   lisp_utils_:  759,  804.
                fixnum_atom              lisp_utils_:  759.
       40047    fixnum_type              lisp_utils_:  144,  544,  607,  636,  839,  842,  940,
                                         lisp_object_types:   34.
         166    fixval                   lisp_utils_:  230,  234,  273,  305,  336,  358,  360,  398,  434,  455,  489,  527,
                                                       555,  577,  579,  619,  625,  630,  728, 1038, 1040.
         130    fix_aq                   lisp_utils_:  186.
         136    fix_aq_minus             lisp_utils_:  187,  193.
         144    fix_ovf                  lisp_utils_:  189,  195,  201.
       20000    Float                    lisp_utils_:   56,  224,  775,
                                         lisp_object_types:   16.
         116    float1                   lisp_utils_:  172.
         120    floating_store_operator  lisp_stack_seg:      50.
         111    float_q                  lisp_utils_:  163.
          20    flonum                   lisp_utils_:  760,  807.
                flonum_atom              lisp_utils_:  760.
         212    flonum_too_big           lisp_error_codes:    42.
       20047    flonum_type              lisp_utils_:  153,  205,  565,  844,  936,
                                         lisp_object_types:   35.
         160    floval                   lisp_utils_:  223,  227,  288,  320,  347,  396,  445,  472,  506,  600,  734.
      777707    fn_abs                   lisp_name_codes:     53.
      777720    fn_add1                  lisp_name_codes:     44.
      777674    fn_add1_fix              lisp_utils_:  272,
                                         lisp_name_codes:     64.
      777673    fn_add1_flo              lisp_utils_:  287,
                                         lisp_name_codes:     65.
      777625    fn_alarmclock            lisp_name_codes:    103.
      777611    fn_allfiles              lisp_name_codes:    115.
      777617    fn_alphalessp            lisp_name_codes:    109.
      777657    fn_apply                 lisp_name_codes:     77.
      777765    fn_arg                   lisp_name_codes:     10.
      777727    fn_args                  lisp_name_codes:     37.
      777740    fn_array                 lisp_name_codes:     28.
      777537    fn_arraydims             lisp_name_codes:    157.
      777751    fn_ascii                 lisp_name_codes:     19.
      777631    fn_atan                  lisp_name_codes:     99.
      777650    fn_baktrace              lisp_name_codes:     84.
      777647    fn_bltarray              lisp_name_codes:     85.
      777705    fn_boole                 lisp_utils_:  617,
                                         lisp_name_codes:     55.
      777643    fn_boundp                lisp_name_codes:     89.
      777654    fn_catch                 lisp_name_codes:     80.
      777741    fn_catenate              lisp_name_codes:     27.
      777544    fn_charpos               lisp_name_codes:    152.
      777610    fn_chrct                 lisp_name_codes:    116.
      777557    fn_clear_input           lisp_name_codes:    141.
      777553    fn_cline                 lisp_name_codes:    145.
      777607    fn_close                 lisp_name_codes:    117.
      777637    fn_cos                   lisp_name_codes:     93.
      777732    fn_CtoI                  lisp_name_codes:     34.
      777561    fn_cursorpos             lisp_name_codes:    139.
      777756    fn_defaultf              lisp_name_codes:     17.
      777747    fn_definedp              lisp_name_codes:     21.
      777731    fn_defsubr               lisp_name_codes:     35.
      777651    fn_defun                 lisp_name_codes:     83.
      777744    fn_delete                lisp_name_codes:     24.
      777606    fn_deletef               lisp_name_codes:    118.
      777743    fn_delq                  lisp_name_codes:     25.
      777711    fn_difference            lisp_name_codes:     51.
      777664    fn_diff_fix              lisp_utils_:  454,
                                         lisp_name_codes:     72.
      777663    fn_diff_flo              lisp_utils_:  471,
                                         lisp_name_codes:     73.
      777516    fn_displace              lisp_name_codes:    174.
      777766    fn_do                    lisp_name_codes:      9.
      777535    fn_dumparrays            lisp_name_codes:    159.
      777540    fn_endpagefn             lisp_name_codes:    156.
      777605    fn_eoffn                 lisp_name_codes:    119.
      777621    fn_eql                   lisp_utils_:  717,
                                         lisp_name_codes:    107.
      777760    fn_errframe              lisp_name_codes:     15.
      777761    fn_errprint              lisp_name_codes:     14.
      777655    fn_errset                lisp_name_codes:     79.
      777660    fn_eval                  lisp_name_codes:     76.
      777757    fn_evalframe             lisp_name_codes:     16.
      777520    fn_eval_when             lisp_name_codes:    172.
      777635    fn_exp                   lisp_name_codes:     95.
      777706    fn_expt                  lisp_name_codes:     54.
      777534    fn_expt_fix              lisp_utils_:  356,
                                         lisp_name_codes:    160.
      777533    fn_expt_flo              lisp_utils_:  394,
                                         lisp_name_codes:    161.
      777604    fn_filepos               lisp_name_codes:    120.
      777552    fn_fillarray             lisp_name_codes:    146.
      777701    fn_fix                   lisp_name_codes:     59.
      777700    fn_float                 lisp_name_codes:     60.
      777560    fn_force_output          lisp_name_codes:    140.
      777640    fn_freturn               lisp_name_codes:     92.
      777524    fn_fsc                   lisp_utils_:  551,
                                         lisp_name_codes:    168.
      777612    fn_gcd                   lisp_utils_: 1036,
                                         lisp_name_codes:    114.
      777645    fn_gensym                lisp_name_codes:     87.
      777725    fn_get                   lisp_name_codes:     39.
      777615    fn_getchar               lisp_name_codes:    111.
      777724    fn_getl                  lisp_name_codes:     40.
      777735    fn_get_pname             lisp_name_codes:     31.
      777716    fn_greaterp              lisp_name_codes:     46.
      777620    fn_gt                    lisp_utils_:  710,
                                         lisp_name_codes:    108.
      777554    fn_haipart               lisp_name_codes:    144.
      777555    fn_haulong               lisp_name_codes:    143.
      777525    fn_ifix                  lisp_utils_:  598,
                                         lisp_name_codes:    167.
      777530    fn_in                    lisp_name_codes:    164.
      777513    fn_includef              lisp_name_codes:    177.
      777736    fn_index                 lisp_name_codes:     30.
      777603    fn_inpush                lisp_name_codes:    121.
      777632    fn_isqrt                 lisp_name_codes:     98.
      777733    fn_ItoC                  lisp_name_codes:     33.
      777715    fn_lessp                 lisp_name_codes:     47.
      777602    fn_linel                 lisp_name_codes:    122.
      777542    fn_linenum               lisp_name_codes:    154.
      777551    fn_listarray             lisp_name_codes:    147.
      777545    fn_listify               lisp_name_codes:    151.
      777536    fn_loadarrays            lisp_name_codes:    158.
      777634    fn_log                   lisp_name_codes:     96.
      777622    fn_ls                    lisp_utils_:  704,
                                         lisp_name_codes:    106.
      777703    fn_lsh                   lisp_utils_:  523,
                                         lisp_name_codes:     57.
      777734    fn_make_atom             lisp_name_codes:     32.
      777644    fn_makunbound            lisp_name_codes:     88.
      777522    fn_mapatoms              lisp_name_codes:    170.
      777676    fn_max                   lisp_name_codes:     62.
      777601    fn_mergef                lisp_name_codes:    123.
      777675    fn_min                   lisp_name_codes:     63.
      777714    fn_minus                 lisp_name_codes:     48.
      777623    fn_minusp                lisp_name_codes:    105.
      777600    fn_namelist              lisp_name_codes:    124.
      777577    fn_names                 lisp_name_codes:    125.
      777576    fn_namestring            lisp_name_codes:    126.
      777532    fn_nointerrupt           lisp_name_codes:    162.
      777515    fn_nth                   lisp_name_codes:    175.
      777514    fn_nthcdr                lisp_name_codes:    176.
      777627    fn_oddp                  lisp_name_codes:    101.
      777531    fn_open                  lisp_name_codes:    163.
      777614    fn_opena                 lisp_name_codes:    112.
      777575    fn_openi                 lisp_name_codes:    127.
      777574    fn_openo                 lisp_name_codes:    128.
      777527    fn_out                   lisp_name_codes:    165.
      777543    fn_pagel                 lisp_name_codes:    153.
      777541    fn_pagenum               lisp_name_codes:    155.
      777713    fn_plus                  lisp_name_codes:     49.
      777624    fn_plusp                 lisp_name_codes:    104.
      777670    fn_plus_fix              lisp_utils_:  335,
                                         lisp_name_codes:     68.
      777667    fn_plus_flo              lisp_utils_:  346,
                                         lisp_name_codes:     69.
      777573    fn_prin1                 lisp_name_codes:    129.
      777572    fn_princ                 lisp_name_codes:    130.
      777571    fn_print                 lisp_name_codes:    131.
      777656    fn_prog                  lisp_name_codes:     78.
      777523    fn_progv                 lisp_name_codes:    169.
      777723    fn_putprop               lisp_name_codes:     41.
      777710    fn_quotient              lisp_name_codes:     52.
      777662    fn_quot_fix              lisp_utils_:  488,
                                         lisp_name_codes:     74.
      777661    fn_quot_flo              lisp_utils_:  505,
                                         lisp_name_codes:     75.
      777556    fn_random                lisp_name_codes:    142.
      777570    fn_read                  lisp_name_codes:    132.
      777567    fn_readch                lisp_name_codes:    133.
      777566    fn_readstring            lisp_name_codes:    134.
      777517    fn_read_from_string      lisp_name_codes:    173.
      777677    fn_remainder             lisp_name_codes:     61.
      777722    fn_remprop               lisp_name_codes:     42.
      777565    fn_rename                lisp_name_codes:    135.
      777704    fn_rot                   lisp_utils_:  575,
                                         lisp_name_codes:     56.
      777750    fn_rplaca                lisp_name_codes:     20.
      777616    fn_samepnamep            lisp_name_codes:    110.
      777721    fn_save                  lisp_name_codes:     43.
      777745    fn_set                   lisp_name_codes:     23.
      777764    fn_setarg                lisp_name_codes:     11.
      777746    fn_setq                  lisp_name_codes:     22.
      777562    fn_setsyntax             lisp_name_codes:    138.
      777564    fn_shortnamestring       lisp_name_codes:    136.
      777702    fn_signp                 lisp_utils_: 1031,
                                         lisp_name_codes:     58.
      777636    fn_sin                   lisp_name_codes:     94.
      777630    fn_sleep                 lisp_name_codes:    100.
      777550    fn_sort                  lisp_name_codes:    148.
      777547    fn_sortcar               lisp_name_codes:    149.
      777633    fn_sqrt                  lisp_name_codes:     97.
      777762    fn_sstatus               lisp_name_codes:     13.
      777730    fn_star_array            lisp_name_codes:     36.
      777646    fn_star_rearray          lisp_name_codes:     86.
      777641    fn_star_sstatus          lisp_name_codes:     91.
      777642    fn_star_status           lisp_name_codes:     90.
      777763    fn_status                lisp_name_codes:     12.
      777652    fn_store                 lisp_name_codes:     82.
      777742    fn_stringlength          lisp_name_codes:     26.
      777717    fn_sub1                  lisp_name_codes:     45.
      777672    fn_sub1_fix              lisp_utils_:  304,
                                         lisp_name_codes:     66.
      777671    fn_sub1_flo              lisp_utils_:  319,
                                         lisp_name_codes:     67.
      777737    fn_substr                lisp_name_codes:     29.
      777613    fn_sxhash                lisp_name_codes:    113.
      777726    fn_sysp                  lisp_name_codes:     38.
      777653    fn_throw                 lisp_name_codes:     81.
      777712    fn_times                 lisp_name_codes:     50.
      777666    fn_times_fix             lisp_utils_:  433,
                                         lisp_name_codes:     70.
      777665    fn_times_flo             lisp_utils_:  444,
                                         lisp_name_codes:     71.
      777526    fn_truename              lisp_name_codes:    166.
      777563    fn_tyi                   lisp_name_codes:    137.
      777626    fn_tyipeek               lisp_name_codes:    102.
      777752    fn_tyo                   lisp_name_codes:     18.
      777521    fn_unwind_protect        lisp_name_codes:    171.
      777546    fn_zerop                 lisp_name_codes:    150.
         467    fsc                      lisp_utils_:  550,  551.
          42    gensym_data              lisp_stack_seg:      26.
         635    gt_                      lisp_utils_:  709,  710.
        1057    hash_big                 lisp_utils_:  849,  908.
        1041    hash_chrs                lisp_utils_:  891,  906.
        1045    hash_com                 lisp_utils_:  896,  911.
         765    hash_fcn                 lisp_utils_:  835,  842,  863,  871.
        1022    hash_fix                 lisp_utils_:  843,  873,  887,  903.
        1025    hash_float               lisp_utils_:  845,  877.
        1055    hash_str                 lisp_utils_:  851,  905.
        1037    hash_sym                 lisp_utils_:  847,  889.
         527    ifix                     lisp_utils_:  597,  598,  605.
         162    illobj                   lisp_error_codes:    22.
         235    include_file_error       lisp_error_codes:    61.
          16    in_pl1_code              lisp_utils_:   85,   94,  818,  827,
                                         lisp_stack_seg:      13.
          46    iogbind_op               lisp_stack_seg:      29.
         226    io_wrong_direction       lisp_error_codes:    54.
         150    irest_return_op          lisp_stack_seg:      62.
         110    link_opr                 lisp_stack_seg:      46.
                lisp_                    lisp_utils_:  933.
                lisp_error_              lisp_utils_:   87.
       77700    lisp_ptr.type            lisp_utils_:  781,
                                         lisp_object_types:   13.
          63    lisp_retn_1              lisp_utils_:  116.
                lisp_static_vars_        lisp_utils_:   83,   84,   91,   92,   93,  757,  758,  759,  760,  761,  762,  763,
                                                       764,  815,  816,  817,  825,  826.
          26    list                     lisp_utils_:  763,  783.
                list_atom                lisp_utils_:  763.
         441    lsh                      lisp_utils_:  521,  523.
         456    lshneg                   lisp_utils_:  530,  537.
         463    lshret0                  lisp_utils_:  533,  539,  543, 1043, 1048.
         464    lshret1                  lisp_utils_:  531,  535,  541,  544,  589,  592.
         631    ls_                      lisp_utils_:  703,  704.
          76    l_ret_nil                lisp_utils_:  139.
          73    l_ret_t                  lisp_utils_:  133.
           0    marked_stack_bottom      lisp_stack_seg:       6.
         543    maxfix                   lisp_utils_:  602,  610.
         210    mismatch_super_parens    lisp_error_codes:    40.
          74    ncons_op                 lisp_stack_seg:      40.
         200    nihil_ex_nihile          lisp_error_codes:    36.
          12    nil                      lisp_utils_:  127,  139,  744, 1023,
                                         lisp_stack_seg:      11.
        1240    noexch                   lisp_utils_: 1052, 1056.
         157    nonfixedarg              lisp_utils_:  105,
                                         lisp_error_codes:    19.
         234    not_alpha_array          lisp_error_codes:    60.
         233    not_an_array             lisp_error_codes:    59.
         203    not_pdl_ptr              lisp_error_codes:    37.
         245    not_same_type            lisp_error_codes:    69.
         211    no_left_super_paren      lisp_error_codes:    41.
         172    no_lexpr                 lisp_error_codes:    30.
       61400    Numeric                  lisp_object_types:   17.
           1    numval                   lisp_utils_:   53,   58,  525,  553,  725.
           0    numval1                  lisp_utils_:   45.
         630    ones                     lisp_utils_:  654,  660,  673,  676,  678,  681,  685,  687,  691,  693,  698.
         624    orcb                     lisp_utils_:  688,  690.
         207    overflow_err             lisp_utils_:  207,
                                         lisp_error_codes:    39.
         160    parenmissing             lisp_error_codes:    20.
         152    pl1_call_nopop_op        lisp_stack_seg:      63.
         134    pl1_call_op              lisp_stack_seg:      56.
          66    pl1_interface            lisp_stack_seg:      37.
          70    pl1_lsubr_interface      lisp_stack_seg:      38.
         735    pl1_sxhash               lisp_utils_:  813,  814.
         250    plus_fix                 lisp_utils_:  333,  335.
         255    plus_flo                 lisp_utils_:  344,  346.
          12    pname                    lisp_utils_:  757,  791.
                pname_atom               lisp_utils_:  757.
        1226    pos1st                   lisp_utils_: 1042, 1046.
        1233    pos2nd                   lisp_utils_: 1047, 1051.
         177    prearith2                lisp_utils_:  252,  458,  475,  492,  509.
        1171    push_offset              stack_header:        81.
         213    quoterror                lisp_error_codes:    43.
         415    quot_fix                 lisp_utils_:  486,  488.
         423    quot_fix_op_1            lisp_utils_:  491,  495.
         427    quot_flo                 lisp_utils_:  503,  505.
         435    quot_flo_op_1            lisp_utils_:  508,  512.
          22    random                   lisp_utils_:  761,  810.
                random_atom              lisp_utils_:  761.
         154    rcv_char_star_op         lisp_stack_seg:      64.
         230    reopen_inconsistent      lisp_error_codes:    56.
         101    retfixnum                lisp_utils_:  144,  229.
         104    retflonum                lisp_utils_:  151,  222.
        1247    retgcd                   lisp_utils_: 1059, 1063.
         713    retrn_type_1             lisp_utils_:  785,  840.
         354    return_flo_result        lisp_utils_:  408,  424.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          62    return_op                lisp_stack_seg:      35.
          62    ret_1                    lisp_utils_:  112,  243.
         312    ret_fix_0                lisp_utils_:  366,  383.
         313    ret_fix_result           lisp_utils_:  377,  384,  427.
          70    ret_nil                  lisp_utils_:  127.
         666    ret_nil_2                lisp_utils_:  707,  712,  714,  720,  743.
          65    ret_t                    lisp_utils_:  121.
         663    ret_t_2                  lisp_utils_:  706,  713,  719,  739.
         507    rot                      lisp_utils_:  573,  575.
         525    rot0                     lisp_utils_:  586,  591.
         164    shortreadlist            lisp_error_codes:    24.
        1063    signp                    lisp_utils_:  919,  921.
        1166    signp_2                  lisp_utils_:  976, 1004.
        1114    signp_big                lisp_utils_:  939,  947.
        1130    signp_com                lisp_utils_:  957,  961,  967, 1032.
        1117    signp_flt                lisp_utils_:  937,  950.
        1123    signp_neg                lisp_utils_:  943,  948,  951,  956.
        1205    signp_nil                lisp_utils_:  941,  983,  988,  995, 1000, 1011, 1016, 1023.
          56    signp_op                 lisp_stack_seg:      33.
        1127    signp_plus               lisp_utils_:  945,  949,  953,  963.
        1203    signp_t                  lisp_utils_:  982,  987,  990,  994,  999, 1010, 1015, 1020.
        1125    signp_zero               lisp_utils_:  944,  952,  959.
         246    special_array_type       lisp_error_codes:    70.
          73    stach_header.trace_top_ptr     stack_header:        62.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     lisp_utils_:   89,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         236    stack_loss_error         lisp_error_codes:    62.
                stack_ptr                lisp_utils_:   83,   91,  816,  825.
           4    stack_ptr_ptr            lisp_stack_seg:       8.
         225    stars_left_in_name       lisp_error_codes:    53.
         251    store_function_misused   lisp_error_codes:    73.
         242    store_not_allowed        lisp_error_codes:    66.
         116    store_operator           lisp_stack_seg:      49.
        4000    String                   lisp_utils_:  777,  850,
                                         lisp_object_types:   22.
          14    string                   lisp_utils_:  758,  798.
                string_atom              lisp_utils_:  758.
         232    sub1_fix                 lisp_utils_:  302,  304.
         236    sub1_fix_op              lisp_utils_:  306,  310.
         240    sub1_flo                 lisp_utils_:  317,  319.
         244    sub1_flo_op              lisp_utils_:  321,  325.
        2000    Subr                     lisp_object_types:   23.
        1206    subr_1_2_exit            lisp_utils_: 1024.
         753    sxhash                   lisp_utils_:  822,  830,  831.
          44    system_lp                lisp_utils_:   82,
                                         lisp_stack_seg:      28.
         400    System_Subr              lisp_object_types:   24.
          14    t                        lisp_utils_:   18,  121,  133, 1020.
         104    terminate_list_op        lisp_stack_seg:      44.
          52    throw1_op                lisp_stack_seg:      31.
          54    throw2_op                lisp_stack_seg:      32.
         156    throw_to_no_catch        lisp_error_codes:    18.
         357    times_fix                lisp_utils_:  431,  433.
         364    times_flo                lisp_utils_:  442,  444.
         147    too_few_args             lisp_error_codes:    11.
         146    too_many_args            lisp_error_codes:    10.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
          14    true                     lisp_utils_:   18,  739,
                                         lisp_stack_seg:      12.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
         671    typep                    lisp_utils_:  753,  766.
         717    typep_1                  lisp_utils_:  770,  791.
         727    typep_2                  lisp_utils_:  774,  804.
         731    typep_3                  lisp_utils_:  776,  807.
         733    typep_4                  lisp_utils_:  768,  782,  810.
         721    typep_array              lisp_utils_:  780,  794.
         725    typep_big                lisp_utils_:  772,  801.
         723    typep_str                lisp_utils_:  778,  798.
         713    typep_xx                 lisp_utils_:  784,  792,  796,  799,  802,  805,  808,  811, 1026.
          60    type_fields              lisp_stack_seg:      34.
         217    unable_to_float          lisp_error_codes:    47.
          22    unbind_op                lisp_stack_seg:      18.
          40    uncatch_op               lisp_stack_seg:      25.
       60000    Uncollectable            lisp_object_types:   21.
         144    undefined_atom           lisp_error_codes:     8.
         145    undefined_function       lisp_error_codes:     9.
         152    undefined_subr           lisp_error_codes:    14.
         237    underflow_fault          lisp_error_codes:    63.
          30    unerrset_op              lisp_stack_seg:      21.
       67500    Unevalable               lisp_object_types:   27.
                unmkd_ptr                lisp_utils_:   84,   92,   93,  815,  817,  826.
           6    unmkd_ptr_ptr            lisp_stack_seg:       9.
           2    unmkd_stack_bottom       lisp_stack_seg:       7.
         155    unseen_go_tag            lisp_error_codes:    17.
          50    unseen_go_tag_op         lisp_stack_seg:      30.
         146    ununwp_op                lisp_stack_seg:      61.
         142    unwp1_op                 lisp_stack_seg:      59.
         144    unwp2_op                 lisp_stack_seg:      60.
         173    wrong_no_args            lisp_error_codes:    31.
          76    xcons_op                 lisp_stack_seg:      41.
        1145    xx01                     lisp_utils_:  980,  984.
        1152    xx02                     lisp_utils_:  985,  989.
        1161    xx03                     lisp_utils_:  992,  996.
        1176    xx04                     lisp_utils_: 1008, 1012.
         240    zerodivide_fault         lisp_error_codes:    64.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
