	COMPILATION LISTING OF SEGMENT apl_create_save_frame_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1559.4 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* Program to push a "save" frame on the APL stack. Used by programs which must operate in the
       11*   global environment.
       12*
       13*   Richard S. Lamson, 1973.
       14*   Modified by PG on 740315 to fix a bug which caused the save frame to overwrite the last word of the previous frame.
       15*   Modified by PG on 740514 to check for running off the parse stack, and fix a serious reference count bug.
       16*   Modified by G. Gordon Benedict in July, 1974 to add correct apl names to entry points
       17*   Modified 761011 by PG for new parse_frame declaration.
       18*   Modified 770204 by PG to get update entry to restore local meanings (apparently hasn't done
       19*	so since 740514 change was made).
       20*   Modified 790815 by PG to fix 413 (local meanings don't get restored by )LOAD...looks like this
       21*	was broken by 770204 change...looks like there are 3 cases, not 2 as I had thought).
       22**/
       23 
       24 apl_create_save_frame_:
       25      procedure;
       26 
       27 /* Push a save frame after the suspended frame that is on the top of the stack now.  */
       28 
       29 	parse_frame_ptr = ws_info.current_parse_frame_ptr;
       30 	number_of_ptrs = 1 + divide (addr (parse_frame.old_meaning_ptrs (1)) -> source_length + 3, 4, 21, 0);
       31 	save_frame_pointer = addrel (parse_frame_ptr, size (parse_frame));
       32 
       33 	if fixed (rel (save_frame_pointer), 18) > max_parse_stack_depth
       34 	then call apl_system_error_ (apl_error_table_$cant_push_save_frame);
       35 
       36 	total_symbols = 0;
       37 
       38 /* Save a pointer to each symbol bead, a pointer to each meaning,
       39*   and set g-m-p-p to null to indicate that the current meaning is assumed
       40*   to be the global meaning. */
       41 
       42 	do bucket_number = 1 to symbol_table.table_size;
       43 	     do symbol_pointer = symbol_table.hash_bucket_ptr (bucket_number)
       44 		repeat (symbol_pointer -> symbol_bead.hash_link_pointer) while (symbol_pointer ^= null);
       45 
       46 		total_symbols = total_symbols + 1;
       47 
       48 		save_frame.symbol_pointer (total_symbols) = symbol_pointer;
       49 		call increment_reference_count (symbol_pointer);
       50 
       51 		save_frame.saved_meaning_pointer (total_symbols) = symbol_pointer -> symbol_bead.meaning_pointer;
       52 		call increment_reference_count (symbol_pointer -> symbol_bead.meaning_pointer);
       53 
       54 		save_frame.global_meaning_pointer_pointer (total_symbols) = null;
       55 	     end;
       56 	end;
       57 
       58 /* Now walk the stack and find the "globalest" meaning for each symbol.
       59*   If the symbol was never localized, the current values are ok.
       60*   If the symbol was only localized once, that localization has the correct old global meaning.
       61*   Otherwise each additional localization replaces the current one, since we walk the stack backwards. */
       62 
       63 	do parse_frame_ptr = ws_info.current_parse_frame_ptr
       64 	     repeat (parse_frame_ptr -> parse_frame.last_parse_frame_ptr) while (parse_frame_ptr ^= null);
       65 
       66 	     if parse_frame_ptr -> parse_frame.parse_frame_type = function_frame_type
       67 	     then do;
       68 		     lexed_function_bead_pointer = parse_frame_ptr -> parse_frame.lexed_function_bead_ptr;
       69 		     do local = 1 to lexed_function_bead_pointer -> lexed_function_bead.number_of_localized_symbols;
       70 
       71 			symbol_pointer = lexed_function_bead_pointer -> lexed_function_bead.localized_symbols (local);
       72 
       73 			if symbol_pointer ^= null
       74 			then if symbol_pointer -> general_bead.symbol
       75 						/* filter localized system variables */
       76 			     then do global = 1 to total_symbols;
       77 				     if symbol_pointer = save_frame.symbol_pointer (global)
       78 				     then do;
       79 					     call process_symbol;
       80 					     go to found_symbol;
       81 					end;
       82 				end;
       83 						/* if it falls thru the do-loop, its an error; a localized symbol which
       84*						   has no correspondence in the symbol table, but who cares? */
       85 found_symbol:
       86 		     end;
       87 		end;
       88 	     else if parse_frame_ptr -> parse_frame.parse_frame_type = save_frame_type
       89 	     then call apl_system_error_ (apl_error_table_$random_system_error);
       90 	end;
       91 
       92 	save_frame.last_frame_pointer = ws_info.current_parse_frame_ptr;
       93 	save_frame.saved_symbol_count = total_symbols;
       94 	save_frame.frame_type = save_frame_type;
       95 	ws_info.current_parse_frame_ptr = save_frame_pointer;
       96 
       97 	return;
       98 
       99 process_symbol:
      100      procedure;
      101 
      102 /* Since the current meaning (symbol_bead.meaning_pointer) can point
      103*   to the same bead as the old meaning ptr, we must be careful with
      104*   the reference counts. We will increment the reference count first,
      105*   then decrement it.
      106*
      107*   Make the current meaning be the more global meaning. */
      108 
      109 	call increment_reference_count (parse_frame_ptr -> parse_frame.old_meaning_ptrs (local));
      110 	call decrement_reference_count (save_frame.symbol_pointer (global) -> symbol_bead.meaning_pointer);
      111 
      112 	save_frame.symbol_pointer (global) -> symbol_bead.meaning_pointer =
      113 	     parse_frame_ptr -> parse_frame.old_meaning_ptrs (local);
      114 
      115 /* Remember where we got this pointer to the global meaning, so we can change it
      116*   if destroy_save_frame_update_ is called. */
      117 
      118 	save_frame.global_meaning_pointer_pointer (global) = addr (parse_frame_ptr -> parse_frame.old_meaning_ptrs (local));
      119 
      120      end process_symbol;
      121 
      122 /* Entry to restore meanings to old localized meanings. */
      123 
      124 apl_destroy_save_frame_:
      125      entry;
      126 
      127 	modification = "0"b;
      128 	go to destroy;
      129 
      130 /* Entry to replace global meaning with present meaning, and then revert to old local meanings. */
      131 
      132 apl_destroy_save_frame_update_:
      133      entry;
      134 
      135 	modification = "1"b;
      136 
      137 destroy:
      138 	save_frame_pointer = ws_info.current_parse_frame_ptr;
      139 
      140 	if save_frame.frame_type ^= save_frame_type
      141 	then return;
      142 
      143 	do global = 1 to save_frame.saved_symbol_count;
      144 	     sp = save_frame.symbol_pointer (global);
      145 	     mp = save_frame.saved_meaning_pointer (global);
      146 	     gmpp = save_frame.global_meaning_pointer_pointer (global);
      147 
      148 /* If requested, make global meaning be present meaning.  There are two ways to do this,
      149*   depending on whether the symbol was localized or not. */
      150 
      151 	     if modification & gmpp = null
      152 	     then do;
      153 
      154 /* Case 1: Set global meaning from present meaning. Symbol was never localized. Therefore present meaning
      155*   is correct, and all we have to do is flush the saved old "local" meaning. There is purposefully no code
      156*   in this then-clause; the cases seem clearer that way. */
      157 
      158 		end;
      159 	     else do;
      160 
      161 /* Present meaning is not correct */
      162 
      163 		     if modification & gmpp ^= null
      164 		     then do;
      165 
      166 /* Case 2: Set global meaning from present meaning. Symbol was localized. Therefore we have to set the
      167*   oldest parse_frame.old_meaning_ptr (point to by gmpp), and relocalize the symbol. */
      168 
      169 			     tp = sp -> symbol_bead.meaning_pointer;
      170 			     call increment_reference_count (tp);
      171 			     call decrement_reference_count (gmpp -> based_meaning_pointer);
      172 			     gmpp -> based_meaning_pointer = tp;
      173 			end;
      174 
      175 /* Case 2 (rest) and Case 3: Global meaning OK now. Restore local meaning as shown by save_frame. */
      176 
      177 		     call increment_reference_count (mp);
      178 		     call decrement_reference_count (sp -> symbol_bead.meaning_pointer);
      179 		     sp -> symbol_bead.meaning_pointer = mp;
      180 		end;
      181 
      182 /* Now throw away pointers in save frame */
      183 
      184 	     call decrement_reference_count (mp);
      185 	     call decrement_reference_count (sp);
      186 	end;
      187 
      188 	ws_info.current_parse_frame_ptr = save_frame.last_frame_pointer;
      189 	return;
      190 
      191 increment_reference_count:
      192      procedure (pointer);
      193 
      194 declare	pointer		pointer unaligned parameter;
      195 
      196 	if pointer = null
      197 	then return;
      198 
      199 	pointer -> general_bead.reference_count = pointer -> general_bead.reference_count + 1;
      200 
      201      end increment_reference_count;
      202 
      203 
      204 
      205 
      206 decrement_reference_count:
      207      procedure (pointer);
      208 
      209 declare	pointer		pointer unaligned parameter;
      210 
      211 	if pointer = null
      212 	then return;
      213 
      214 	pointer -> general_bead.reference_count = pointer -> general_bead.reference_count - 1;
      215 	if pointer -> general_bead.reference_count <= 0
      216 	then call apl_free_bead_ (pointer);
      217 
      218      end decrement_reference_count;
      219 
      220 /* automatic */
      221 
      222 declare	(parse_frame_ptr, lexed_function_bead_pointer, symbol_pointer, mp, sp, gmpp, tp)
      223 			pointer unaligned;
      224 
      225 declare	(
      226 	bucket_number,
      227 	local,
      228 	global,
      229 	total_symbols,
      230 	pointers,
      231 	source_length	based
      232 	)		fixed binary (24) aligned;
      233 
      234 declare	modification	bit (1) aligned;
      235 
      236 /* based */
      237 
      238 declare	based_meaning_pointer
      239 			pointer unaligned based;
      240 
      241 /* builtins */
      242 
      243 declare	(addr, divide, fixed, null, rel, size)
      244 			builtin;
      245 
      246 /* external static */
      247 
      248 declare	(apl_error_table_$cant_push_save_frame, apl_error_table_$random_system_error)
      249 			fixed binary (35) aligned external static;
      250 
      251 /* entries */
      252 
      253 declare	apl_system_error_	entry (fixed binary (35));
      254 declare	apl_free_bead_	entry (pointer unaligned);
      255 
      256 /* include files */
      257 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_number_data.incl.pl1 ================================== */
  1     2 
  1     3 /*
  1     4*   This include file contains information about the machine representation of numbers.
  1     5*   In all programs numbers should simply be declared 'float'.
  1     6*   All default statements should be in this include file.
  1     7*
  1     8*   This is the binary version.  The manifest constant Binary should be used by programs
  1     9*   that need to know whether we are using binary or decimal.
  1    10* */
  1    11 
  1    12 /* format: style3,initlm0,idind30 */
  1    13 
  1    14 default (float & ^decimal & ^binary & ^precision & ^constant) float binary (63);
  1    15 
  1    16 declare	(
  1    17 	TheBiggestNumberWeveGot	float initial (0.1701411834604692317e+39),
  1    18 	TheSmallestNumberWeveGot	float initial (.1469367938527859385e-38),
  1    19 	Binary			bit (1) aligned initial ("1"b)
  1    20 	)			internal static options (constant);
  1    21 
  1    22 /* Number of characters in a number datum entry; used for copying float number arrays as strings.
  1    23*   (Obsolete! use array copies!) */
  1    24 
  1    25 declare	NumberSize		fixed binary precision (4) internal static initial (8);
  1    26 
  1    27 /* ------ END INCLUDE SEGMENT		apl_number_data.incl.pl1 ---------------------------------- */
      258 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_ws_info.incl.pl1 ====================================== */
  2     2 
  2     3 /* This structure contains all of the global data (or pointers to it) for the APL subsystem */
  2     4 
  2     5 /* automatic */
  2     6 
  2     7 declare	ws_info_ptr ptr initial (apl_static_$ws_info_ptr.static_ws_info_ptr);
  2     8 
  2     9 /* external static */
  2    10 
  2    11 declare	1 apl_static_$ws_info_ptr	external static aligned structure,
  2    12 	  2 static_ws_info_ptr	unaligned pointer;
  2    13 
  2    14 /* based */
  2    15 
  2    16 declare	1 ws_info			aligned based (ws_info_ptr),
  2    17 	  2 version_number		fixed bin,	/* version of this structure (3) */
  2    18 	  2 switches		unaligned,	/* mainly ws parameters */
  2    19 	    3 long_error_mode	bit,		/* if 1, long Multics format, else APL/360 format */
  2    20 	    3 debug_mode		bit,		/* if 1, system error causes escape to command level */
  2    21 	    3 canonicalize_mode	bit,		/* if 1, the editor canonicalizes user input */
  2    22 	    3 restrict_exec_command	bit,		/* if 1, the )EXEC command may not be used */
  2    23 	    3 restrict_debug_command	bit,		/* if 1, the )DEBUG command may not be used */
  2    24 	    3 restrict_external_functions
  2    25 				bit,		/* if 1, the )ZFN, )MFN, and )DFN commands may not be used */
  2    26 	    3 restrict_load		bit,		/* if 1, the )LOAD and )COPY commands may not be used */
  2    27 	    3 restrict_load_directory	bit,		/* if 1, no directory allowed in )LOAD or )COPY pathnames */
  2    28 	    3 restrict_save		bit,		/* if 1, the )SAVE command may not be used */
  2    29 	    3 restrict_save_directory	bit,		/* if 1, no directory allowed in )SAVE pathnames */
  2    30 	    3 off_hold		bit,		/* if 1, )OFF HOLD was typed, else just )OFF */
  2    31 	    3 transparent_to_signals	bit,		/* if 1, any conditions slip right past APL */
  2    32 	    3 meter_mode		bit,		/* if 1, metering may be done, else speed is all-important */
  2    33 	    3 restrict_msg_command	bit,		/* if 1, the )MSG command may not be used. */
  2    34 	    3 compatibility_check_mode
  2    35 				bit,		/* if 1, check for incompatible operators */
  2    36 	    3 no_quit_handler	bit,		/* if 1, do not trap QUITs. */
  2    37 						/* remaining 20 bits not presently used */
  2    38 
  2    39 	  2 values,				/* attributes of the workspace */
  2    40 	    3 digits		fixed bin,	/* number of digits of precision printed on output */
  2    41 	    3 width		fixed bin,	/* line length for formatted output */
  2    42 	    3 index_origin		fixed bin,	/* the index origin (0 or 1) */
  2    43 	    3 random_link		fixed bin(35),	/* seed for random number generator */
  2    44 	    3 fuzz		float,		/* comparison tolerance (relative fuzz) */
  2    45 	    3 float_index_origin	float,		/* the index origin	in floating point */
  2    46 	    3 number_of_symbols	fixed bin,	/* the number of symbol_beads currently in existence */
  2    47 	    3 maximum_value_stack_size
  2    48 				fixed bin (18),	/* maximum number of words in one segment of value stack */
  2    49 
  2    50 	  2 pointers,				/* pointers to various internal tables */
  2    51 	    3 symbol_table_ptr	unaligned pointer,	/* -> symbol_table (apl_symbol_table.incl.pl1) */
  2    52 	    3 current_parse_frame_ptr	unaligned pointer,	/* -> topmost parse frame */
  2    53 	    3 value_stack_ptr	unaligned pointer,	/* -> next free location on value stack */
  2    54 	    3 alloc_free_info_ptr	unaligned pointer,	/* -> apl_storage_mngr_ data (apl_storage_system_data.incl.pl1) */
  2    55 
  2    56 	  2 time_invoked		fixed bin(71),	/* clock time that APL was entered */
  2    57 	  2 integer_fuzz		float,		/* the absolute fuzz used in checking for integers */
  2    58 	  2 user_number		fixed bin(35),	/* number under which the user is signed on */
  2    59 	  2 latent_expression	unaligned pointer,	/* -> value_bead for QuadLX */
  2    60 	  2 lock			char(32),		/* the lock currently set on this workspace (password) */
  2    61 	  2 wsid			char(100),	/* the workspace identification: name, number name, or clear ws */
  2    62 	  2 last_error_code		fixed bin(35),	/* last code passed to apl_error_ */
  2    63 	  2 signoff_lock		character (32),
  2    64 
  2    65 	  2 interrupt_info		aligned,		/* bits used by apl_interpreter_ to tell when to abort */
  2    66 	    3 dont_interrupt_parse	bit,		/* if 1, don't do a dirty stop because the parser is running */
  2    67 	    3 dont_interrupt_operator	bit,		/* if 1, don't do a dirty stop because an operator is running */
  2    68 	    3 dont_interrupt_storage_manager		/* if 1, don't stop because apl_storage_mngr_ is */
  2    69 				bit,		/*       munging his tables */
  2    70 	    3 unused_interrupt_bit	bit,		/* not presently used */
  2    71 	    3 dont_interrupt_command	bit,
  2    72 	    3 can_be_interrupted	bit,		/* if 1, OK to do a clean stop (we are between lines, reading) */
  2    73 	    3 clean_interrupt_pending	bit,		/* interrupt occured, break cleanly (between lines) */
  2    74 	    3 dirty_interrupt_pending	bit,		/* interrupt occured, break as soon as not inhibited */
  2    75 
  2    76 	  2 user_name		char (32),	/* process group id of user */
  2    77 	  2 immediate_input_prompt	char (32) varying,	/* normal input */
  2    78 	  2 evaluated_input_prompt	char (32) varying,	/* quad input */
  2    79 	  2 character_input_prompt	char (32) varying,	/* quad-quote input */
  2    80 	  2 vcpu_time		aligned,
  2    81 	    3 total		fixed bin (71),
  2    82 	    3 setup		fixed bin (71),
  2    83 	    3 parse		fixed bin (71),
  2    84 	    3 lex			fixed bin (71),
  2    85 	    3 operator		fixed bin (71),
  2    86 	    3 storage_manager	fixed bin (71),
  2    87 	  2 output_info		aligned,		/* data pertaining to output buffer */
  2    88 	    3 output_buffer_ptr	unal ptr,		/* ptr to output buffer */
  2    89 	    3 output_buffer_len	fixed bin (21),	/* length (bytes) of output buffer */
  2    90 	    3 output_buffer_pos	fixed bin (21),	/* index of next byte to write in */
  2    91 	    3 output_buffer_ll	fixed bin (21),	/* print positions used up so far */
  2    92 	  2 tab_width		fixed bin (21);	/* number of columns a tabs moves cursor */
  2    93 
  2    94 declare	output_buffer char (ws_info.output_buffer_len) based (ws_info.output_buffer_ptr);
  2    95 
  2    96 /* internal static */
  2    97 
  2    98 declare	max_parse_stack_depth fixed bin int static init(64536);
  2    99 
  2   100 /* ------ END INCLUDE SEGMENT		apl_ws_info.incl.pl1 -------------------------------------- */
      259 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_bead_format.incl.pl1 ================================== */
  3     2 
  3     3 declare 1 general_bead  		aligned based,	/* The Venerable Bead		*/
  3     4 	2 type 			unaligned,
  3     5 	  3 bead_type		unaligned,
  3     6 	    4 operator		bit (1),		/* ON if operator bead		*/
  3     7 	    4 symbol		bit (1),		/* ON if symbol bead		*/
  3     8 	    4 value		bit (1),		/* ON if value bead			*/
  3     9 	    4 function		bit (1),		/* ON if function bead		*/
  3    10 	    4 group		bit (1),		/* ON if group bead			*/
  3    11 	    4 label		bit (1),		/* ON if label bead			*/
  3    12 	    4 shared_variable	bit (1),		/* ON if shared variable bead 	*/
  3    13 	    4 lexed_function	bit (1),		/* ON if lexed function bead  	*/
  3    14 	  3 data_type		unaligned,
  3    15 	    4 list_value		bit (1),		/* ON if a list value bead		*/
  3    16 	    4 character_value	bit (1),		/* ON if a character value bead	*/
  3    17 	    4 numeric_value		bit (1),		/* ON if a numeric value bead		*/
  3    18 	    4 integral_value	bit (1),		/* ON if an integral value bead	*/
  3    19 	    4 zero_or_one_value	bit (1),		/* ON if a boolean value bead		*/
  3    20 	    4 complex_value		bit (1),		/* ON if a complex, numeric value bead   */
  3    21 	  3 unused_bits		bit (4) unaligned,	/* pad to 18 bits (for future use)	*/
  3    22 	2 size			bit (18) unaligned,	/* Number of words this bead occupies
  3    23*						   (used by bead storage manager)	*/
  3    24 	2 reference_count 		fixed binary (29);	/* Number of pointers which point
  3    25*						   to this bead (used by bead manager)	*/
  3    26 
  3    27 
  3    28 /* constant strings for initing type field in various beads */
  3    29 
  3    30 declare (
  3    31 	operator_type		init("100000000000000000"b),
  3    32 	symbol_type		init("010000000000000000"b),
  3    33     	value_type		init("001000000000000000"b),
  3    34 	function_type		init("000100000000000000"b),
  3    35 	group_type		init("000010000000000000"b),
  3    36 	label_type		init("001001000011000000"b),
  3    37 	shared_variable_type	init("001000100000000000"b),
  3    38 	lexed_function_type		init("000000010000000000"b),
  3    39 
  3    40 	list_value_type		init("000000001000000000"b),
  3    41 	character_value_type 	init("001000000100000000"b),
  3    42 	numeric_value_type		init("001000000010000000"b),
  3    43 	integral_value_type		init("001000000011000000"b),
  3    44 	zero_or_one_value_type	init("001000000011100000"b),
  3    45 	complex_value_type		init("001000000000010000"b),
  3    46 
  3    47 	not_integer_mask		init("111111111110011111"b),		/* to clear integral, zero_or_one bits */
  3    48 	not_zero_or_one_mask	init("111111111111011111"b)		/* to clear zero_or_one bit */
  3    49         ) bit(18) internal static;
  3    50 
  3    51 /* ------ END INCLUDE SEGMENT		apl_bead_format.incl.pl1 ---------------------------------- */
      260 
  4     1 /* ====== BEGIN INCLUDE SEGMENT	apl_symbol_bead.incl.pl1 ================================== */
  4     2 
  4     3 /* Explanation of fields:
  4     4*   symbol_bead.hash_link_pointer	points to next symbol in same hash bucket in the symbol table.
  4     5*   symbol_bead.meaning_pointer	points to current "value" of this name:
  4     6*				   =  null	  => unused (e.g. undefined variable)
  4     7*				   -> group bead      => group name
  4     8*				   -> value bead      => variable with a value
  4     9*				   -> function bead   => function name
  4    10*				   -> label bead      => localized label value
  4    11*				   -> shared var bead => shared variable	*/
  4    12 
  4    13 declare 1 symbol_bead 		aligned based,
  4    14 	2 header	 		aligned like general_bead,
  4    15 	2 hash_link_pointer		pointer unaligned,
  4    16 	2 meaning_pointer		pointer unaligned,
  4    17 	2 name_length 		fixed binary,
  4    18 	2 name			character (0 refer (symbol_bead.name_length)) unaligned;
  4    19 
  4    20 /* ------ END INCLUDE SEGMENT		apl_symbol_bead.incl.pl1 ---------------------------------- */
      261 
  5     1 /* ====== BEGIN INCLUDE SEGMENT	apl_lexed_function_bead.incl.pl1 ========================== */
  5     2 
  5     3 /* this is the format of a user-defined function after it has been run
  5     4*   through apl_lex_, the first (left to right) parsing phase. */
  5     5 
  5     6 dcl 1 lexed_function_bead based aligned,
  5     7     2 header like general_bead,			/* type bits, etc. */
  5     8 
  5     9     2 name pointer unaligned,				/* -> symbol bead which names the function */
  5    10     2 bits_for_parse unaligned like operator_bead.bits_for_parse,	/* so can treat like system function */
  5    11     2 number_of_statements fixed bin,
  5    12     2 number_of_localized_symbols fixed bin,		/* including labels and parameter variables, return var */
  5    13 						/* even if they aren't there, thus >_ 3 */
  5    14     2 number_of_labels fixed bin,
  5    15     2 label_values_ptr pointer unaligned,			/* -> label_values below */
  5    16     2 statement_map_ptr pointer unaligned,			/* -> statement_map below */
  5    17     2 lexeme_array_ptr pointer unaligned,			/* -> lexeme_array below */
  5    18 
  5    19 	/* the first 3 localized symbols are always reserved for ReturnSymbol, LeftArgSymbol, RighArgSymbol respectively.
  5    20*	   If some of these symbols are not present (e.g. monadic or value-less function), null pointers are used.
  5    21*	   So beware!, there can be null ptrs in the localized_symbols array. */
  5    22 
  5    23     2 localized_symbols(  (0) refer (lexed_function_bead.number_of_localized_symbols)) pointer unaligned,
  5    24 						/* first localized vars from header line, then labels */
  5    25     2 label_values ( (0) refer (lexed_function_bead.number_of_labels)) pointer unaligned,
  5    26 						/* ptrs to label-value beads for labels */
  5    27     2 statement_map ( (0) refer (lexed_function_bead.number_of_statements)) fixed bin(18),
  5    28 						/* index in lexeme_array of rightmost lexeme of each stmt */
  5    29     2 lexeme_array ( (0) refer (lexed_function_bead.number_of_labels)	/* not really, but fake out compiler */ ) pointer unaligned;
  5    30 			/* the actual lexemes.  Length of array is
  5    31*							statement_map(number_of_statements)   */
  5    32 
  5    33 
  5    34 /* manifest constants for first 3 localized symbols */
  5    35 
  5    36 dcl (ReturnSymbol	init(1),
  5    37      LeftArgSymbol	init(2),
  5    38      RightArgSymbol	init(3)
  5    39     ) fixed binary static;
  5    40 
  5    41 
  5    42 	/* the last three parts of this bead are referenced separately, though ptrs earlier in the bead.
  5    43*	   Here are declarations for them as level-1 structures */
  5    44 
  5    45 dcl 1 lexed_function_label_values_structure based aligned,
  5    46      2 lexed_function_label_values ( 500 /* or so */ ) pointer unaligned,
  5    47 
  5    48     statement_count fixed bin,
  5    49     lexed_function_statement_map (statement_count) fixed bin(18) aligned based,
  5    50 
  5    51     1 lexed_function_lexemes_structure based aligned,
  5    52      2 lexed_function_lexeme_array ( 500 /* or so */ ) pointer unaligned;
  5    53 
  5    54 /* ------ END INCLUDE SEGMENT		apl_lexed_function_bead.incl.pl1 -------------------------- */
      262 
  6     1 /* ====== BEGIN INCLUDE SEGMENT	apl_parse_frame.incl.pl1 ================================== */
  6     2 
  6     3 declare	1 parse_frame		aligned based (parse_frame_ptr),
  6     4 	  2 last_parse_frame_ptr	ptr unaligned,	/* pointer to last parse frame, or null */
  6     5 	  2 parse_frame_type	fixed bin,	/* suspended, function, eval input, etc. */
  6     6 	  2 function_bead_ptr	ptr unaligned,	/* ptr to function bead */
  6     7 	  2 lexed_function_bead_ptr	ptr unaligned,	/* ptr to lexed function bead */
  6     8 	  2 reduction_stack_ptr	ptr unaligned,	/* ptr to reduction stack for this frame */
  6     9 	  2 current_parseme		fixed bin,	/* element of reduction stack that is top of stack */
  6    10 	  2 current_lexeme		fixed bin,	/* element number of current lexeme */
  6    11 	  2 current_line_number	fixed bin,	/* line number being executed */
  6    12 	  2 return_point		fixed bin,	/* where to join the reductions on return */
  6    13 	  2 put_result		fixed bin,	/* where to put the value when returning to this frame */
  6    14 	  2 print_final_value	bit(1) aligned,	/* if true, print final value on line */
  6    15 	  2 initial_value_stack_ptr	ptr unaligned,	/* for cleaning up the value stack */
  6    16 	  2 number_of_ptrs		fixed bin,	/* number of old meaning ptrs */
  6    17 	  2 old_meaning_ptrs	dim (number_of_ptrs refer (parse_frame.number_of_ptrs)) ptr unaligned;
  6    18 						/* old meanings for local variables. */
  6    19 
  6    20 declare	number_of_ptrs fixed bin;
  6    21 
  6    22 declare	(suspended_frame_type init (1),		/* for comparison with parse frame type */
  6    23 	function_frame_type init (2),
  6    24 	evaluated_frame_type init (3),
  6    25 	execute_frame_type init (4),
  6    26 	save_frame_type init (5)
  6    27 	) fixed bin internal static options (constant);
  6    28 
  6    29 declare	reductions_pointer pointer;
  6    30 
  6    31 declare
  6    32 	1 reduction_stack		aligned dim (1000) based (reductions_pointer),
  6    33 	  2 type			fixed bin,	/* type of parseme */
  6    34 	  2 bits			unaligned like operator_bead.bits_for_parse,
  6    35 	  2 semantics		ptr unaligned,
  6    36 	  2 lexeme		fixed bin,
  6    37 
  6    38 	1 reduction_stack_for_op	aligned dim (1000) based (reductions_pointer),
  6    39 	  2 type			fixed bin,
  6    40 	  2 bits			unaligned like operator_bead.bits_for_parse,
  6    41 	  2 semantics		fixed bin,
  6    42 	  2 lexeme		fixed bin,
  6    43 
  6    44 	(eol_type init(0),					/* parseme types - end of line */
  6    45 	bol_type init(1),					/* begining of line */
  6    46 	val_type init(2),					/* value */
  6    47 	op_type init(3),					/* op */
  6    48 	open_paren_type init(4),
  6    49 	close_paren_type init(5),
  6    50 	open_bracket_type init(6),
  6    51 	close_subscript_type init(7),
  6    52 	close_rank_type init(8),
  6    53 	semi_colon_type init(9),
  6    54 	diamond_type init (10),
  6    55 	subscript_type init (11)) fixed bin internal static options (constant);
  6    56 
  6    57 /* ------ END INCLUDE SEGMENT		apl_parse_frame.incl.pl1 ---------------------------------- */
      263 
  7     1 /* ====== BEGIN INCLUDE FILE		apl_save_frame.incl.pl1 =================================== */
  7     2 
  7     3 declare	save_frame_pointer pointer unaligned;
  7     4 
  7     5 declare 1 save_frame 		aligned based (save_frame_pointer),
  7     6 	2 last_frame_pointer 	ptr unal,		/* pointer to last parse frame		*/
  7     7 	2 frame_type 		fixed bin,	/* = save_frame_type			*/
  7     8 	2 saved_symbol_count	fixed bin (29),	/* number of symbols in saved frame		*/
  7     9 	2 symbol_list		aligned dimension (total_symbols refer (save_frame.saved_symbol_count)),
  7    10 	  3 symbol_pointer		ptr unal,		/* pointer to each symbol bead (never null)	*/
  7    11 	  3 saved_meaning_pointer	ptr unal,		/* ptr to local meaning at time save_frame is created */
  7    12 						/* (if null, local meaning is null)		*/
  7    13 	  3 global_meaning_pointer_pointer		/* pointer to the meaning pointer which 	*/
  7    14 				ptr unal;		/* represents the global meaning of this symbol	*/
  7    15 						/* (if null, either symbol was never localized,	*/
  7    16 						/* or save_frame was created by apl_load_command_,*/
  7    17 						/* and saved_meaning_ptr determines whether it    */
  7    18 						/* was localized)				*/
  7    19 
  7    20 /* ------ END INCLUDE FILE		apl_save_frame.incl.pl1 ----------------------------------- */
      264 
  8     1 /* BEGIN INCLUDE FILE apl_symbol_table.incl.pl1
  8     2*
  8     3*   initially written 20 June 1973 by Dan Bricklin */
  8     4 
  8     5 declare
  8     6 	initial_size fixed bin int static init(17),	/* initial size of hash table */
  8     7 
  8     8 	1 symbol_table aligned based(ws_info.symbol_table_ptr),
  8     9 	   2 table_size fixed bin,			/* how many buckets */
  8    10 	   2 hash_bucket_ptr(initial_size refer(table_size)) ptr unaligned; /* the buckets */
  8    11 
  8    12 /* END INCLUDE FILE apl_symbol_table.incl.pl1 */
      265 
  9     1 /* ====== BEGIN INCLUDE SEGMENT	apl_operator_bead.incl.pl1 ================================ */
  9     2 
  9     3 declare
  9     4 	1 operator_bead		aligned based,
  9     5 
  9     6 	  2 type			unaligned like general_bead.type,
  9     7 
  9     8 	  2 bits_for_lex		unaligned,
  9     9 	    3 allow_brackets	bit(1),		/* operator may have dimension info in brackets */
  9    10 	    3 allow_product		bit(1),		/* operator may be used in inner and outer product */
  9    11 	    3 allow_reduction	bit(1),		/* operator may be used in reduction and scan */
  9    12 	    3 special_assignment	bit(1),		/* doesn't use standard assignment operator */
  9    13 	    3 ignores_assignment	bit(1),		/* assignment has no effect */
  9    14 	    3 allow_subscripted_assignment
  9    15 				bit(1),		/* system variable that can be subscripted assigned */
  9    16 	    3 pad			bit(12),
  9    17 
  9    18 	  2 bits_for_parse		unaligned,
  9    19 	    3 stop_trace_control	bit(1),		/* next lexeme is function being stopped/traced
  9    20*						   (op1 tells which) */
  9    21 	    3 quad		bit(1),		/* this is a quad type */
  9    22 	    3 system_variable	bit(1),		/* this is a system variable, not an op */
  9    23 	    3 dyadic		bit(1),		/* operator may be dyadic */
  9    24 	    3 monadic		bit(1),		/* operator may be monadic */
  9    25 	    3 function		bit(1),		/* operator is a user defined function */
  9    26 	    3 semantics_valid	bit(1),		/* if semantics has been set */
  9    27 	    3 has_list		bit(1),		/* semantics is a list */
  9    28 	    3 inner_product		bit(1),		/* op2 is valid */
  9    29 	    3 semantics_on_stack	bit(1),		/* semantics points to value stack */
  9    30 	    3 is_external_function	bit(1),		/* semantics points to function bead for ext function */
  9    31 	    3 pad			bit(7),
  9    32 	    3 op2			fixed bin(8) unaligned,	/* secondary operator code */
  9    33 	    3 op1			fixed bin(8) unaligned,	/* primary operator code */
  9    34 	  2 type_code		fixed bin;	/* for parse */
  9    35 
  9    36 /* ------ END INCLUDE SEGMENT		apl_operator_bead.incl.pl1 -------------------------------- */
      266 
      267      end /* apl_create_save_frame_ */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1346.2  apl_create_save_frame_.pl1        >special_ldd>on>apl.1129>apl_create_save_frame_.pl1
258          1    03/27/82  0429.8  apl_number_data.incl.pl1          >ldd>include>apl_number_data.incl.pl1
259          2    03/27/82  0439.2  apl_ws_info.incl.pl1              >ldd>include>apl_ws_info.incl.pl1
260          3    03/27/82  0438.5  apl_bead_format.incl.pl1          >ldd>include>apl_bead_format.incl.pl1
261          4    03/27/82  0439.2  apl_symbol_bead.incl.pl1          >ldd>include>apl_symbol_bead.incl.pl1
262          5    03/27/82  0438.7  apl_lexed_function_bead.incl.pl1  >ldd>include>apl_lexed_function_bead.incl.pl1
263          6    03/27/82  0439.0  apl_parse_frame.incl.pl1          >ldd>include>apl_parse_frame.incl.pl1
264          7    03/27/82  0439.1  apl_save_frame.incl.pl1           >ldd>include>apl_save_frame.incl.pl1
265          8    03/27/82  0439.2  apl_symbol_table.incl.pl1         >ldd>include>apl_symbol_table.incl.pl1
266          9    03/27/82  0439.0  apl_operator_bead.incl.pl1        >ldd>include>apl_operator_bead.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 243 ref 30 118
apl_error_table_$cant_push_save_frame
                                000010 external static fixed bin(35,0)          dcl 248 set ref 33*
apl_error_table_$random_system_error
                                000012 external static fixed bin(35,0)          dcl 248 set ref 88*
apl_free_bead_                  000016 constant        entry                    external dcl 254 ref 215
apl_static_$ws_info_ptr         000020 external static structure                level 1 dcl 2-11
apl_system_error_               000014 constant        entry                    external dcl 253 ref 33 88
based_meaning_pointer                  based           pointer                  unaligned dcl 238 set ref 171* 172*
bead_type                              based           structure                level 3 packed unaligned dcl 3-3
bits_for_parse            1            based           structure                level 2 packed unaligned dcl 9-3
bucket_number                   000107 automatic       fixed bin(24,0)          dcl 225 set ref 42* 43*
current_parse_frame_ptr
                         15            based           pointer                  level 3 packed unaligned dcl 2-16 set ref 29 63 92
                                                                                  95* 137 188*
divide                                                 builtin function         dcl 243 ref 30
fixed                                                  builtin function         dcl 243 ref 33
frame_type                1            based           fixed bin(17,0)          level 2 dcl 7-5 set ref 94* 140
function_frame_type                    constant        fixed bin(17,0)          initial dcl 6-22 ref 66
general_bead                           based           structure                level 1 dcl 3-3
global                          000111 automatic       fixed bin(24,0)          dcl 225 set ref 73* 77* 110 112 118 143* 144 145
                                                                                  146*
global_meaning_pointer_pointer
                          5            based           pointer                  array level 3 packed unaligned dcl 7-5 set ref 54*
                                                                                  118* 146
gmpp                            000105 automatic       pointer                  unaligned dcl 222 set ref 146* 151 163 171 172
hash_bucket_ptr           1            based           pointer                  array level 2 packed unaligned dcl 8-5 ref 43
hash_link_pointer         2            based           pointer                  level 2 packed unaligned dcl 4-13 ref 55
last_frame_pointer                     based           pointer                  level 2 packed unaligned dcl 7-5 set ref 92* 188
last_parse_frame_ptr                   based           pointer                  level 2 packed unaligned dcl 6-3 ref 90
lexed_function_bead                    based           structure                level 1 dcl 5-6
lexed_function_bead_pointer     000101 automatic       pointer                  unaligned dcl 222 set ref 68* 69 71
lexed_function_bead_ptr
                          3            based           pointer                  level 2 packed unaligned dcl 6-3 ref 68
local                           000110 automatic       fixed bin(24,0)          dcl 225 set ref 69* 71* 109 112 118
localized_symbols        12            based           pointer                  array level 2 packed unaligned dcl 5-6 ref 71
max_parse_stack_depth                  constant        fixed bin(17,0)          initial dcl 2-98 ref 33
meaning_pointer           3            based           pointer                  level 2 packed unaligned dcl 4-13 set ref 51 52*
                                                                                  110* 112* 169 178* 179*
modification                    000113 automatic       bit(1)                   dcl 234 set ref 127* 135* 151 163
mp                              000103 automatic       pointer                  unaligned dcl 222 set ref 145* 177* 179 184*
null                                                   builtin function         dcl 243 ref 43 54 63 73 151 163 196 211
number_of_localized_symbols
                          5            based           fixed bin(17,0)          level 2 dcl 5-6 ref 69
number_of_ptrs                  000116 automatic       fixed bin(17,0)          dcl 6-20 set ref 30* 31
old_meaning_ptrs         15            based           pointer                  array level 2 packed unaligned dcl 6-3 set ref 30
                                                                                  109* 112 118
operator_bead                          based           structure                level 1 dcl 9-3
parse_frame                            based           structure                level 1 dcl 6-3 set ref 31
parse_frame_ptr                 000100 automatic       pointer                  unaligned dcl 222 set ref 29* 30 31 31 63* 63* 66 68
                                                                                  88* 90 109 112 118
parse_frame_type          1            based           fixed bin(17,0)          level 2 dcl 6-3 ref 66 88
pointer                                parameter       pointer                  unaligned dcl 209 in procedure
                                                                                  "decrement_reference_count" set ref 206 211 214
                                                                                  214 215 215*
pointer                                parameter       pointer                  unaligned dcl 194 in procedure
                                                                                  "increment_reference_count" ref 191 196 199 199
pointers                 14            based           structure                level 2 dcl 2-16
reference_count           1            based           fixed bin(29,0)          level 2 dcl 3-3 set ref 199* 199 214* 214 215
rel                                                    builtin function         dcl 243 ref 33
save_frame                             based           structure                level 1 dcl 7-5
save_frame_pointer              000117 automatic       pointer                  unaligned dcl 7-3 set ref 31* 33 48 51 54 77 92 93
                                                                                  94 95 110 112 118 137* 140 143 144 145 146 188
save_frame_type                        constant        fixed bin(17,0)          initial dcl 6-22 ref 88 94 140
saved_meaning_pointer
                          4            based           pointer                  array level 3 packed unaligned dcl 7-5 set ref 51*
                                                                                  145
saved_symbol_count        2            based           fixed bin(29,0)          level 2 dcl 7-5 set ref 93* 143
size                                                   builtin function         dcl 243 ref 31
source_length                          based           fixed bin(24,0)          dcl 225 ref 30
sp                              000104 automatic       pointer                  unaligned dcl 222 set ref 144* 169 178 179 185*
static_ws_info_ptr              000020 external static pointer                  level 2 packed unaligned dcl 2-11 ref 2-7
symbol                    0(01)        based           bit(1)                   level 4 packed unaligned dcl 3-3 ref 73
symbol_bead                            based           structure                level 1 dcl 4-13
symbol_list               3            based           structure                array level 2 dcl 7-5
symbol_pointer            3            based           pointer                  array level 3 in structure "save_frame" packed
                                                                                  unaligned dcl 7-5 in procedure
                                                                                  "apl_create_save_frame_" set ref 48* 77 110 112
                                                                                  144
symbol_pointer                  000102 automatic       pointer                  unaligned dcl 222 in procedure
                                                                                  "apl_create_save_frame_" set ref 43* 43* 48 49* 51
                                                                                  52* 55 71* 73 73 77
symbol_table                           based           structure                level 1 dcl 8-5
symbol_table_ptr         14            based           pointer                  level 3 packed unaligned dcl 2-16 ref 42 43
table_size                             based           fixed bin(17,0)          level 2 dcl 8-5 ref 42
total_symbols                   000112 automatic       fixed bin(24,0)          dcl 225 set ref 36* 46* 46 48 51 54 73 93
tp                              000106 automatic       pointer                  unaligned dcl 222 set ref 169* 170* 172
type                                   based           structure                level 3 in structure "symbol_bead" packed unaligned
                                                                                  dcl 4-13 in procedure "apl_create_save_frame_"
type                                   based           structure                level 3 in structure "lexed_function_bead" packed
                                                                                  unaligned dcl 5-6 in procedure
                                                                                  "apl_create_save_frame_"
type                                   based           structure                level 2 in structure "general_bead" packed unaligned
                                                                                  dcl 3-3 in procedure "apl_create_save_frame_"
ws_info                                based           structure                level 1 dcl 2-16
ws_info_ptr                     000114 automatic       pointer                  initial dcl 2-7 set ref 29 42 43 63 92 95 137 188
                                                                                  2-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Binary                                 internal static bit(1)                   initial dcl 1-16
LeftArgSymbol                          internal static fixed bin(17,0)          initial dcl 5-36
NumberSize                             internal static fixed bin(4,0)           initial dcl 1-25
ReturnSymbol                           internal static fixed bin(17,0)          initial dcl 5-36
RightArgSymbol                         internal static fixed bin(17,0)          initial dcl 5-36
TheBiggestNumberWeveGot                internal static float bin(63)            initial dcl 1-16
TheSmallestNumberWeveGot               internal static float bin(63)            initial dcl 1-16
bol_type                               internal static fixed bin(17,0)          initial dcl 6-31
character_value_type                   internal static bit(18)                  initial unaligned dcl 3-30
close_paren_type                       internal static fixed bin(17,0)          initial dcl 6-31
close_rank_type                        internal static fixed bin(17,0)          initial dcl 6-31
close_subscript_type                   internal static fixed bin(17,0)          initial dcl 6-31
complex_value_type                     internal static bit(18)                  initial unaligned dcl 3-30
diamond_type                           internal static fixed bin(17,0)          initial dcl 6-31
eol_type                               internal static fixed bin(17,0)          initial dcl 6-31
evaluated_frame_type                   internal static fixed bin(17,0)          initial dcl 6-22
execute_frame_type                     internal static fixed bin(17,0)          initial dcl 6-22
function_type                          internal static bit(18)                  initial unaligned dcl 3-30
group_type                             internal static bit(18)                  initial unaligned dcl 3-30
initial_size                           internal static fixed bin(17,0)          initial dcl 8-5
integral_value_type                    internal static bit(18)                  initial unaligned dcl 3-30
label_type                             internal static bit(18)                  initial unaligned dcl 3-30
lexed_function_label_values_structure  based           structure                level 1 dcl 5-45
lexed_function_lexemes_structure       based           structure                level 1 dcl 5-45
lexed_function_statement_map           based           fixed bin(18,0)          array dcl 5-45
lexed_function_type                    internal static bit(18)                  initial unaligned dcl 3-30
list_value_type                        internal static bit(18)                  initial unaligned dcl 3-30
not_integer_mask                       internal static bit(18)                  initial unaligned dcl 3-30
not_zero_or_one_mask                   internal static bit(18)                  initial unaligned dcl 3-30
numeric_value_type                     internal static bit(18)                  initial unaligned dcl 3-30
op_type                                internal static fixed bin(17,0)          initial dcl 6-31
open_bracket_type                      internal static fixed bin(17,0)          initial dcl 6-31
open_paren_type                        internal static fixed bin(17,0)          initial dcl 6-31
operator_type                          internal static bit(18)                  initial unaligned dcl 3-30
output_buffer                          based           char                     unaligned dcl 2-94
pointers                               automatic       fixed bin(24,0)          dcl 225
reduction_stack                        based           structure                array level 1 dcl 6-31
reduction_stack_for_op                 based           structure                array level 1 dcl 6-31
reductions_pointer                     automatic       pointer                  dcl 6-29
semi_colon_type                        internal static fixed bin(17,0)          initial dcl 6-31
shared_variable_type                   internal static bit(18)                  initial unaligned dcl 3-30
statement_count                        automatic       fixed bin(17,0)          dcl 5-45
subscript_type                         internal static fixed bin(17,0)          initial dcl 6-31
suspended_frame_type                   internal static fixed bin(17,0)          initial dcl 6-22
symbol_type                            internal static bit(18)                  initial unaligned dcl 3-30
val_type                               internal static fixed bin(17,0)          initial dcl 6-31
value_type                             internal static bit(18)                  initial unaligned dcl 3-30
zero_or_one_value_type                 internal static bit(18)                  initial unaligned dcl 3-30

NAMES DECLARED BY EXPLICIT CONTEXT.
apl_create_save_frame_          000013 constant        entry                    external dcl 24
apl_destroy_save_frame_         000253 constant        entry                    external dcl 124
apl_destroy_save_frame_update_  000264 constant        entry                    external dcl 132
decrement_reference_count       000462 constant        entry                    internal dcl 206 ref 110 171 178 184 185
destroy                         000274 constant        label                    dcl 137 ref 128
found_symbol                    000217 constant        label                    dcl 85 ref 80
increment_reference_count       000445 constant        entry                    internal dcl 191 ref 49 52 109 170 177
process_symbol                  000406 constant        entry                    internal dcl 99 ref 79

NAME DECLARED BY CONTEXT OR IMPLICATION.
addrel                                                 builtin function         ref 31

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       664         706     533         674
Length      1266     533        22         344     131           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_create_save_frame_              134 external procedure  is an external procedure.  
process_symbol                          internal procedure  shares stack frame of external procedure apl_create_save_frame_.  
increment_reference_count               internal procedure  shares stack frame of external procedure apl_create_save_frame_.  
decrement_reference_count               internal procedure  shares stack frame of external procedure apl_create_save_frame_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_create_save_frame_   000100 parse_frame_ptr             apl_create_save_frame_
                         000101 lexed_function_bead_pointer apl_create_save_frame_
                         000102 symbol_pointer              apl_create_save_frame_
                         000103 mp                          apl_create_save_frame_
                         000104 sp                          apl_create_save_frame_
                         000105 gmpp                        apl_create_save_frame_
                         000106 tp                          apl_create_save_frame_
                         000107 bucket_number               apl_create_save_frame_
                         000110 local                       apl_create_save_frame_
                         000111 global                      apl_create_save_frame_
                         000112 total_symbols               apl_create_save_frame_
                         000113 modification                apl_create_save_frame_
                         000114 ws_info_ptr                 apl_create_save_frame_
                         000116 number_of_ptrs              apl_create_save_frame_
                         000117 save_frame_pointer          apl_create_save_frame_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
apl_free_bead_                apl_system_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
apl_error_table_$cant_push_save_frame                       apl_error_table_$random_system_error
apl_static_$ws_info_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2    7 000005        24 000012        29 000021        30 000024        31 000032        33 000036        36 000053
     42 000054        43 000065        46 000075        48 000076        49 000104        51 000106        52 000115
     54 000123        55 000131        56 000135        63 000137        66 000145        68 000152        69 000154
     71 000165        73 000170        77 000205        79 000213        80 000214        82 000215        85 000217
     87 000221        88 000222        90 000233        92 000237        93 000243        94 000245        95 000247
     97 000251       124 000252       127 000261       128 000262       132 000263       135 000272       137 000274
    140 000277       143 000303       144 000313       145 000320       146 000322       151 000324       158 000330
    163 000331       169 000335       170 000340       171 000342       172 000351       177 000357       178 000361
    179 000370       184 000373       185 000375       186 000377       188 000401       189 000405        99 000406
    109 000407       110 000417       112 000431       118 000442       120 000444       191 000445       196 000447
    199 000457       201 000461       206 000462       211 000464       214 000474       215 000477       218 000510


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
