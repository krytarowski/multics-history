	COMPILATION LISTING OF SEGMENT apl_dyadic_iota_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1602.4 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* This program implements the dyadic, mixed operators iota and epsilon.
       11*   Written by R.S.Lamson, Summer, 1973.
       12*   Modified by PG on 740909 for new value bead declaration, positioning error marker, and proper handling
       13*	of the value stack and fuzz.
       14*   Modified 780209 by PG to use apl_push_stack_ (bug 278).
       15**/
       16 
       17 apl_dyadic_iota_:
       18 	procedure (operators_argument);
       19 
       20 	from_vb = operators_argument.operands (2).value;
       21 	into_vb = operators_argument.operands (1).value;
       22 	data_elements = from_vb -> value_bead.total_data_elements;
       23 
       24 	if into_vb -> value_bead.rhorho ^= 1
       25 	then go to left_argument_not_vector;
       26 
       27 	if operators_argument.operands (2).on_stack & from_vb -> value_bead.numeric_value
       28 	then result_vb = from_vb;
       29 	else call allocate_result;
       30 
       31 	internal_op_code = internal_iota_code;
       32 	match_site = iota_match_site;
       33 	non_match_site = iota_non_match_site;
       34 	go to joined_code;
       35 
       36 apl_dyadic_epsilon_:
       37 	entry (operators_argument);
       38 
       39 	from_vb = operators_argument.operands (1).value;
       40 	into_vb = operators_argument.operands (2).value;
       41 	data_elements = from_vb -> value_bead.total_data_elements;
       42 
       43 	if operators_argument.operands (1).on_stack & from_vb -> value_bead.numeric_value
       44 	then result_vb = from_vb;
       45 	else call allocate_result;
       46 
       47 	internal_op_code = internal_epsilon_code;
       48 	match_site = epsilon_match_site;
       49 	non_match_site = epsilon_non_match_site;
       50 
       51 joined_code:
       52 	from = from_vb -> value_bead.data_pointer;
       53 	into = into_vb -> value_bead.data_pointer;
       54 	result = result_vb -> value_bead.data_pointer;
       55 
       56 	if into_vb -> value_bead.total_data_elements = 0
       57 	then go to never_match;
       58 
       59 	if from_vb -> value_bead.character_value
       60 	then if into_vb -> value_bead.character_value
       61 	     then comparison_site = character_comparison_site;
       62 	     else go to never_match;
       63 	else if from_vb -> value_bead.numeric_value
       64 	     then if into_vb -> value_bead.numeric_value
       65 		then comparison_site = numeric_comparison_site;
       66 		else go to never_match;
       67 	     else go to no_type_bits;
       68 
       69 	do from_subscript = 0 by 1 while (from_subscript < from_vb -> value_bead.total_data_elements);
       70 	     do into_subscript = 0 by 1 while (into_subscript < into_vb -> value_bead.total_data_elements);
       71 		go to comparison_site;
       72 
       73 character_comparison_site:
       74 		if from -> character_datum (from_subscript) =
       75 		   into -> character_datum (into_subscript)
       76 		then go to match_site;
       77 		else go to next_comparison;
       78 
       79 numeric_comparison_site:
       80 		if from -> numeric_datum (from_subscript) = into -> numeric_datum (into_subscript)
       81 		then go to match_site;
       82 		else if abs (from -> numeric_datum (from_subscript) - into -> numeric_datum (into_subscript)) <
       83 			abs (ws_info.fuzz * (from -> numeric_datum (from_subscript) + into -> numeric_datum (into_subscript)))
       84 		     then go to match_site;
       85 next_comparison:
       86 	     end;
       87 
       88 	     go to non_match_site;
       89 
       90 iota_match_site:		/* iota match	*/
       91 iota_non_match_site:	/* iota mismatch.  happens to work because subscript is right coming out of loop
       92*			   and is more efficient than using value_bead.rho				*/
       93 
       94 	     result -> numeric_datum (from_subscript) = float (into_subscript + ws_info.index_origin);
       95 	     go to next_element;
       96 
       97 epsilon_match_site:		/* epsilon match	*/
       98 	     result -> numeric_datum (from_subscript) = 1.0e0;
       99 	     go to next_element;
      100 
      101 epsilon_non_match_site:		/* epsilon mismatch	*/
      102 	     result -> numeric_datum (from_subscript) = 0.0e0;
      103 
      104 next_element:
      105 	end;
      106 
      107 	go to return_point;
      108 
      109 never_match:
      110 	if internal_op_code = internal_iota_code
      111 	then value = float (into_vb -> value_bead.total_data_elements + ws_info.index_origin);
      112 	else value = 0.0e0;
      113 
      114 	do from_subscript = 0 by 1 while (from_subscript < data_elements);
      115 	     result -> numeric_datum (from_subscript) = value;
      116 	end;
      117 
      118 return_point:
      119 	if internal_op_code = internal_iota_code
      120 	then string (result_vb -> value_bead.type) = integral_value_type;
      121 	else string (result_vb -> value_bead.type) = zero_or_one_value_type;
      122 	operators_argument.result = result_vb;
      123 	return;
      124 
      125 left_argument_not_vector:
      126 	operators_argument.error_code = apl_error_table_$iota_argument_not_vector;
      127 	operators_argument.where_error = operators_argument.where_error + 1;
      128 	return;
      129 
      130 no_type_bits:
      131 	operators_argument.error_code = apl_error_table_$no_type_bits;
      132 	return;
      133 
      134 allocate_result:
      135 	procedure();
      136 
      137 	number_of_dimensions = from_vb -> value_bead.rhorho;
      138 	n_words = size (value_bead) + size (numeric_datum) + 1;
      139 	result_vb = apl_push_stack_ (n_words);
      140 	result_vb -> value_bead.total_data_elements = from_vb -> value_bead.total_data_elements;
      141 	result_vb -> value_bead.rhorho = from_vb -> value_bead.rhorho;
      142 
      143 	do from_subscript = 1 to from_vb -> value_bead.rhorho;
      144 	     result_vb -> value_bead.rho (from_subscript) = from_vb -> value_bead.rho (from_subscript);
      145 	end;
      146 
      147 	result_vb -> value_bead.data_pointer = addr (result_vb -> value_bead.rho (number_of_dimensions + 1));
      148 
      149 	if substr (rel (result_vb -> value_bead.data_pointer), 18, 1)
      150 	then result_vb -> value_bead.data_pointer = addrel (result_vb -> value_bead.data_pointer, 1);
      151 
      152 end allocate_result;
      153 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_push_stack_fcn.incl.pl1 =============================== */
  1     2 
  1     3 /* format: style3 */
  1     4 apl_push_stack_:
  1     5      procedure (P_n_words) returns (ptr);
  1     6 
  1     7 /* Function to (1) double-word align ws_info.value_stack_ptr, and
  1     8*   (2) make sure allocation request will fit on current value stack.
  1     9*
  1    10*   Written 770413 by PG
  1    11*   Modified 780210 by PG to round allocations up to an even number of words.
  1    12**/
  1    13 
  1    14 /* parameters */
  1    15 
  1    16 declare	P_n_words		fixed bin (19) parameter;
  1    17 
  1    18 /* automatic */
  1    19 
  1    20 declare	block_ptr		ptr,
  1    21 	num_words		fixed bin (19);
  1    22 
  1    23 /* builtins */
  1    24 
  1    25 declare	(addrel, binary, rel, substr, unspec)
  1    26 			builtin;
  1    27 
  1    28 /* entries */
  1    29 
  1    30 declare	apl_get_value_stack_
  1    31 			entry (fixed bin (19));
  1    32 
  1    33 /* program */
  1    34 
  1    35 	num_words = P_n_words;
  1    36 
  1    37 	if substr (unspec (num_words), 36, 1) = "1"b	/* num_words odd */
  1    38 	then num_words = num_words + 1;
  1    39 
  1    40 	if binary (rel (ws_info.value_stack_ptr), 18) + num_words > ws_info.maximum_value_stack_size
  1    41 	then call apl_get_value_stack_ (num_words);
  1    42 
  1    43 	block_ptr = ws_info.value_stack_ptr;
  1    44 	ws_info.value_stack_ptr = addrel (ws_info.value_stack_ptr, num_words);
  1    45 	return (block_ptr);
  1    46 
  1    47      end apl_push_stack_;
  1    48 
  1    49 /* ------ END INCLUDE SEGMENT		apl_push_stack_fcn.incl.pl1 ------------------------------- */
      154 
      155 
      156 /* external static */
      157 
      158 declare (apl_error_table_$iota_argument_not_vector, apl_error_table_$no_type_bits
      159 	) fixed binary (35) external static;
      160 
      161 /* automatic */
      162 
      163 declare  value float;
      164 declare (from_vb, into_vb, result_vb, from, into, result) pointer;
      165 
      166 declare  (internal_op_code, data_elements, from_subscript, into_subscript) fixed binary (21);
      167 declare	n_words fixed bin (19);
      168 
      169 declare (internal_iota_code initial (1), internal_epsilon_code initial (2)) fixed binary (21) internal static;
      170 declare (match_site, non_match_site, comparison_site) label local;
      171 
      172 /* builtin */
      173 
      174 declare	(abs, addr, addrel, fixed, float, mod, rel, size, string, substr) builtin;
      175 
      176 /* include files */
      177 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_number_data.incl.pl1 ================================== */
  2     2 
  2     3 /*
  2     4*   This include file contains information about the machine representation of numbers.
  2     5*   In all programs numbers should simply be declared 'float'.
  2     6*   All default statements should be in this include file.
  2     7*
  2     8*   This is the binary version.  The manifest constant Binary should be used by programs
  2     9*   that need to know whether we are using binary or decimal.
  2    10* */
  2    11 
  2    12 /* format: style3,initlm0,idind30 */
  2    13 
  2    14 default (float & ^decimal & ^binary & ^precision & ^constant) float binary (63);
  2    15 
  2    16 declare	(
  2    17 	TheBiggestNumberWeveGot	float initial (0.1701411834604692317e+39),
  2    18 	TheSmallestNumberWeveGot	float initial (.1469367938527859385e-38),
  2    19 	Binary			bit (1) aligned initial ("1"b)
  2    20 	)			internal static options (constant);
  2    21 
  2    22 /* Number of characters in a number datum entry; used for copying float number arrays as strings.
  2    23*   (Obsolete! use array copies!) */
  2    24 
  2    25 declare	NumberSize		fixed binary precision (4) internal static initial (8);
  2    26 
  2    27 /* ------ END INCLUDE SEGMENT		apl_number_data.incl.pl1 ---------------------------------- */
      178 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_bead_format.incl.pl1 ================================== */
  3     2 
  3     3 declare 1 general_bead  		aligned based,	/* The Venerable Bead		*/
  3     4 	2 type 			unaligned,
  3     5 	  3 bead_type		unaligned,
  3     6 	    4 operator		bit (1),		/* ON if operator bead		*/
  3     7 	    4 symbol		bit (1),		/* ON if symbol bead		*/
  3     8 	    4 value		bit (1),		/* ON if value bead			*/
  3     9 	    4 function		bit (1),		/* ON if function bead		*/
  3    10 	    4 group		bit (1),		/* ON if group bead			*/
  3    11 	    4 label		bit (1),		/* ON if label bead			*/
  3    12 	    4 shared_variable	bit (1),		/* ON if shared variable bead 	*/
  3    13 	    4 lexed_function	bit (1),		/* ON if lexed function bead  	*/
  3    14 	  3 data_type		unaligned,
  3    15 	    4 list_value		bit (1),		/* ON if a list value bead		*/
  3    16 	    4 character_value	bit (1),		/* ON if a character value bead	*/
  3    17 	    4 numeric_value		bit (1),		/* ON if a numeric value bead		*/
  3    18 	    4 integral_value	bit (1),		/* ON if an integral value bead	*/
  3    19 	    4 zero_or_one_value	bit (1),		/* ON if a boolean value bead		*/
  3    20 	    4 complex_value		bit (1),		/* ON if a complex, numeric value bead   */
  3    21 	  3 unused_bits		bit (4) unaligned,	/* pad to 18 bits (for future use)	*/
  3    22 	2 size			bit (18) unaligned,	/* Number of words this bead occupies
  3    23*						   (used by bead storage manager)	*/
  3    24 	2 reference_count 		fixed binary (29);	/* Number of pointers which point
  3    25*						   to this bead (used by bead manager)	*/
  3    26 
  3    27 
  3    28 /* constant strings for initing type field in various beads */
  3    29 
  3    30 declare (
  3    31 	operator_type		init("100000000000000000"b),
  3    32 	symbol_type		init("010000000000000000"b),
  3    33     	value_type		init("001000000000000000"b),
  3    34 	function_type		init("000100000000000000"b),
  3    35 	group_type		init("000010000000000000"b),
  3    36 	label_type		init("001001000011000000"b),
  3    37 	shared_variable_type	init("001000100000000000"b),
  3    38 	lexed_function_type		init("000000010000000000"b),
  3    39 
  3    40 	list_value_type		init("000000001000000000"b),
  3    41 	character_value_type 	init("001000000100000000"b),
  3    42 	numeric_value_type		init("001000000010000000"b),
  3    43 	integral_value_type		init("001000000011000000"b),
  3    44 	zero_or_one_value_type	init("001000000011100000"b),
  3    45 	complex_value_type		init("001000000000010000"b),
  3    46 
  3    47 	not_integer_mask		init("111111111110011111"b),		/* to clear integral, zero_or_one bits */
  3    48 	not_zero_or_one_mask	init("111111111111011111"b)		/* to clear zero_or_one bit */
  3    49         ) bit(18) internal static;
  3    50 
  3    51 /* ------ END INCLUDE SEGMENT		apl_bead_format.incl.pl1 ---------------------------------- */
      179 
  4     1 /* ====== BEGIN INCLUDE SEGMENT	apl_value_bead.incl.pl1 =================================== */
  4     2 
  4     3 declare
  4     4 	number_of_dimensions fixed bin,
  4     5 
  4     6 	1 value_bead		aligned based,
  4     7 	2 header			aligned like general_bead,
  4     8 	2 total_data_elements	fixed binary (21),	/* length of ,[value] in APL		*/
  4     9 	2 rhorho			fixed binary,	/* number of dimensions of value	*/
  4    10 	2 data_pointer		pointer unaligned,	/* packed pointer to the data in value	*/
  4    11 	2 rho			fixed binary (21) dimension (number_of_dimensions refer (value_bead.rhorho));
  4    12 						/* dimensions of value (zero-origin)	*/
  4    13 
  4    14 
  4    15 declare 1 character_data_structure	aligned based,	/* alignment trick for PL/I compiler	*/
  4    16 	2 character_datum		character (1) unaligned dimension (0:data_elements - 1);
  4    17 						/* actual elements of character array	*/
  4    18 
  4    19 declare   character_string_overlay	character (data_elements) aligned based;
  4    20 						/* to overlay on above structure	 */
  4    21 
  4    22 
  4    23 declare   numeric_datum		float aligned dimension (0:data_elements - 1) based;
  4    24 						/* actual elements of numeric array	*/
  4    25 
  4    26 declare	complex_datum		complex float aligned dimension (0:data_elements -1) based;
  4    27 
  4    28 declare	MAX_VALUE_BEAD_SIZE		fixed bin (19) init (261120) int static options (constant);
  4    29 
  4    30 /* ------ END INCLUDE SEGMENT		apl_value_bead.incl.pl1 ----------------------------------- */
      180 
  5     1 /* ====== BEGIN INCLUDE SEGMENT	apl_ws_info.incl.pl1 ====================================== */
  5     2 
  5     3 /* This structure contains all of the global data (or pointers to it) for the APL subsystem */
  5     4 
  5     5 /* automatic */
  5     6 
  5     7 declare	ws_info_ptr ptr initial (apl_static_$ws_info_ptr.static_ws_info_ptr);
  5     8 
  5     9 /* external static */
  5    10 
  5    11 declare	1 apl_static_$ws_info_ptr	external static aligned structure,
  5    12 	  2 static_ws_info_ptr	unaligned pointer;
  5    13 
  5    14 /* based */
  5    15 
  5    16 declare	1 ws_info			aligned based (ws_info_ptr),
  5    17 	  2 version_number		fixed bin,	/* version of this structure (3) */
  5    18 	  2 switches		unaligned,	/* mainly ws parameters */
  5    19 	    3 long_error_mode	bit,		/* if 1, long Multics format, else APL/360 format */
  5    20 	    3 debug_mode		bit,		/* if 1, system error causes escape to command level */
  5    21 	    3 canonicalize_mode	bit,		/* if 1, the editor canonicalizes user input */
  5    22 	    3 restrict_exec_command	bit,		/* if 1, the )EXEC command may not be used */
  5    23 	    3 restrict_debug_command	bit,		/* if 1, the )DEBUG command may not be used */
  5    24 	    3 restrict_external_functions
  5    25 				bit,		/* if 1, the )ZFN, )MFN, and )DFN commands may not be used */
  5    26 	    3 restrict_load		bit,		/* if 1, the )LOAD and )COPY commands may not be used */
  5    27 	    3 restrict_load_directory	bit,		/* if 1, no directory allowed in )LOAD or )COPY pathnames */
  5    28 	    3 restrict_save		bit,		/* if 1, the )SAVE command may not be used */
  5    29 	    3 restrict_save_directory	bit,		/* if 1, no directory allowed in )SAVE pathnames */
  5    30 	    3 off_hold		bit,		/* if 1, )OFF HOLD was typed, else just )OFF */
  5    31 	    3 transparent_to_signals	bit,		/* if 1, any conditions slip right past APL */
  5    32 	    3 meter_mode		bit,		/* if 1, metering may be done, else speed is all-important */
  5    33 	    3 restrict_msg_command	bit,		/* if 1, the )MSG command may not be used. */
  5    34 	    3 compatibility_check_mode
  5    35 				bit,		/* if 1, check for incompatible operators */
  5    36 	    3 no_quit_handler	bit,		/* if 1, do not trap QUITs. */
  5    37 						/* remaining 20 bits not presently used */
  5    38 
  5    39 	  2 values,				/* attributes of the workspace */
  5    40 	    3 digits		fixed bin,	/* number of digits of precision printed on output */
  5    41 	    3 width		fixed bin,	/* line length for formatted output */
  5    42 	    3 index_origin		fixed bin,	/* the index origin (0 or 1) */
  5    43 	    3 random_link		fixed bin(35),	/* seed for random number generator */
  5    44 	    3 fuzz		float,		/* comparison tolerance (relative fuzz) */
  5    45 	    3 float_index_origin	float,		/* the index origin	in floating point */
  5    46 	    3 number_of_symbols	fixed bin,	/* the number of symbol_beads currently in existence */
  5    47 	    3 maximum_value_stack_size
  5    48 				fixed bin (18),	/* maximum number of words in one segment of value stack */
  5    49 
  5    50 	  2 pointers,				/* pointers to various internal tables */
  5    51 	    3 symbol_table_ptr	unaligned pointer,	/* -> symbol_table (apl_symbol_table.incl.pl1) */
  5    52 	    3 current_parse_frame_ptr	unaligned pointer,	/* -> topmost parse frame */
  5    53 	    3 value_stack_ptr	unaligned pointer,	/* -> next free location on value stack */
  5    54 	    3 alloc_free_info_ptr	unaligned pointer,	/* -> apl_storage_mngr_ data (apl_storage_system_data.incl.pl1) */
  5    55 
  5    56 	  2 time_invoked		fixed bin(71),	/* clock time that APL was entered */
  5    57 	  2 integer_fuzz		float,		/* the absolute fuzz used in checking for integers */
  5    58 	  2 user_number		fixed bin(35),	/* number under which the user is signed on */
  5    59 	  2 latent_expression	unaligned pointer,	/* -> value_bead for QuadLX */
  5    60 	  2 lock			char(32),		/* the lock currently set on this workspace (password) */
  5    61 	  2 wsid			char(100),	/* the workspace identification: name, number name, or clear ws */
  5    62 	  2 last_error_code		fixed bin(35),	/* last code passed to apl_error_ */
  5    63 	  2 signoff_lock		character (32),
  5    64 
  5    65 	  2 interrupt_info		aligned,		/* bits used by apl_interpreter_ to tell when to abort */
  5    66 	    3 dont_interrupt_parse	bit,		/* if 1, don't do a dirty stop because the parser is running */
  5    67 	    3 dont_interrupt_operator	bit,		/* if 1, don't do a dirty stop because an operator is running */
  5    68 	    3 dont_interrupt_storage_manager		/* if 1, don't stop because apl_storage_mngr_ is */
  5    69 				bit,		/*       munging his tables */
  5    70 	    3 unused_interrupt_bit	bit,		/* not presently used */
  5    71 	    3 dont_interrupt_command	bit,
  5    72 	    3 can_be_interrupted	bit,		/* if 1, OK to do a clean stop (we are between lines, reading) */
  5    73 	    3 clean_interrupt_pending	bit,		/* interrupt occured, break cleanly (between lines) */
  5    74 	    3 dirty_interrupt_pending	bit,		/* interrupt occured, break as soon as not inhibited */
  5    75 
  5    76 	  2 user_name		char (32),	/* process group id of user */
  5    77 	  2 immediate_input_prompt	char (32) varying,	/* normal input */
  5    78 	  2 evaluated_input_prompt	char (32) varying,	/* quad input */
  5    79 	  2 character_input_prompt	char (32) varying,	/* quad-quote input */
  5    80 	  2 vcpu_time		aligned,
  5    81 	    3 total		fixed bin (71),
  5    82 	    3 setup		fixed bin (71),
  5    83 	    3 parse		fixed bin (71),
  5    84 	    3 lex			fixed bin (71),
  5    85 	    3 operator		fixed bin (71),
  5    86 	    3 storage_manager	fixed bin (71),
  5    87 	  2 output_info		aligned,		/* data pertaining to output buffer */
  5    88 	    3 output_buffer_ptr	unal ptr,		/* ptr to output buffer */
  5    89 	    3 output_buffer_len	fixed bin (21),	/* length (bytes) of output buffer */
  5    90 	    3 output_buffer_pos	fixed bin (21),	/* index of next byte to write in */
  5    91 	    3 output_buffer_ll	fixed bin (21),	/* print positions used up so far */
  5    92 	  2 tab_width		fixed bin (21);	/* number of columns a tabs moves cursor */
  5    93 
  5    94 declare	output_buffer char (ws_info.output_buffer_len) based (ws_info.output_buffer_ptr);
  5    95 
  5    96 /* internal static */
  5    97 
  5    98 declare	max_parse_stack_depth fixed bin int static init(64536);
  5    99 
  5   100 /* ------ END INCLUDE SEGMENT		apl_ws_info.incl.pl1 -------------------------------------- */
      181 
  6     1 /* ====== BEGIN INCLUDE SEGEMENT	apl_operators_argument.incl.pl1 =========================== */
  6     2 
  6     3 declare	1 operators_argument	aligned,
  6     4 	  2 operands (2)		aligned,		/* these are the operands to the operator to be executed.
  6     5*						   if operand (1).value is null, operator is monadic */
  6     6 	    3 value		pointer unaligned,	/* a pointer to the value bead for this operand */
  6     7 	    3 on_stack		bit (1) aligned,	/* ON if this value resides on the value stack */
  6     8 	  2 operator		aligned,		/* information about the operator to be executed */
  6     9 	    3 dimension		fixed bin,	/* (optional) dimension along which to operate */
  6    10 	    3 padding		bit (18) unaligned,	/* unused part of operator bead */
  6    11 	    3 op2			fixed bin (8) unal,	/* a modifier for op1, or a 2nd operator if inner product */
  6    12 	    3 op1			fixed bin (8) unal,	/* code for the actual operator to be executed */
  6    13 	  2 result		pointer unal,	/* (output) set by operator to point to result bead in stack */
  6    14 	  2 error_code		fixed bin (35),	/* (output) set before signaling apl_operator_error_ */
  6    15 	  2 where_error		fixed bin;	/* parseme index of where error was - parse sets to operator */
  6    16 
  6    17 /* ------ END INCLUDE SEGMENT		apl_operators_argument.incl.pl1 --------------------------- */
      182 
      183 end apl_dyadic_iota_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1346.3  apl_dyadic_iota_.pl1              >special_ldd>on>apl.1129>apl_dyadic_iota_.pl1
154          1    03/27/82  0429.8  apl_push_stack_fcn.incl.pl1       >ldd>include>apl_push_stack_fcn.incl.pl1
178          2    03/27/82  0429.8  apl_number_data.incl.pl1          >ldd>include>apl_number_data.incl.pl1
179          3    03/27/82  0438.5  apl_bead_format.incl.pl1          >ldd>include>apl_bead_format.incl.pl1
180          4    03/27/82  0439.2  apl_value_bead.incl.pl1           >ldd>include>apl_value_bead.incl.pl1
181          5    03/27/82  0439.2  apl_ws_info.incl.pl1              >ldd>include>apl_ws_info.incl.pl1
182          6    03/27/82  0439.0  apl_operators_argument.incl.pl1   >ldd>include>apl_operators_argument.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_n_words                              parameter       fixed bin(19,0)          dcl 1-16 ref 1-4 1-35
abs                                                    builtin function         dcl 174 ref 82 82
addr                                                   builtin function         dcl 174 ref 147
addrel                                                 builtin function         dcl 174 in procedure "apl_dyadic_iota_" ref 149
addrel                                                 builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-44
apl_error_table_$iota_argument_not_vector
                                000010 external static fixed bin(35,0)          dcl 158 ref 125
apl_error_table_$no_type_bits   000012 external static fixed bin(35,0)          dcl 158 ref 130
apl_get_value_stack_            000016 constant        entry                    external dcl 1-30 ref 1-40
apl_static_$ws_info_ptr         000014 external static structure                level 1 dcl 5-11
binary                                                 builtin function         dcl 1-25 ref 1-40
block_ptr                       000162 automatic       pointer                  dcl 1-20 set ref 1-43* 1-45
character_data_structure               based           structure                level 1 dcl 4-15
character_datum                        based           char(1)                  array level 2 packed unaligned dcl 4-15 ref 73 73
character_value           0(09)        based           bit(1)                   level 5 packed unaligned dcl 4-3 set ref 59 59
comparison_site                 000134 automatic       label variable           local dcl 170 set ref 59* 63* 71
data_elements                   000117 automatic       fixed bin(21,0)          dcl 166 set ref 22* 41* 114 138
data_pointer              4            based           pointer                  level 2 packed unaligned dcl 4-3 set ref 51 53 54
                                                                                  147* 149 149* 149
data_type                 0(08)        based           structure                level 4 packed unaligned dcl 4-3
error_code                7            parameter       fixed bin(35,0)          level 2 dcl 6-3 set ref 125* 130*
float                                                  builtin function         dcl 174 ref 90 109
from                            000110 automatic       pointer                  dcl 164 set ref 51* 73 79 82 82
from_subscript                  000120 automatic       fixed bin(21,0)          dcl 166 set ref 69* 69* 73 79 82 82 90 97 101* 114*
                                                                                  114* 115* 143* 144 144*
from_vb                         000102 automatic       pointer                  dcl 164 set ref 20* 22 27 27 39* 41 43 43 51 59 63
                                                                                  69 137 140 141 143 144
fuzz                      6            based           float bin(63)            level 3 dcl 5-16 ref 82
general_bead                           based           structure                level 1 dcl 3-3
header                                 based           structure                level 2 dcl 4-3
index_origin              4            based           fixed bin(17,0)          level 3 dcl 5-16 ref 90 109
integral_value_type                    constant        bit(18)                  initial unaligned dcl 3-30 ref 118
internal_epsilon_code                  constant        fixed bin(21,0)          initial dcl 169 ref 47
internal_iota_code                     constant        fixed bin(21,0)          initial dcl 169 ref 31 109 118
internal_op_code                000116 automatic       fixed bin(21,0)          dcl 166 set ref 31* 47* 109 118
into                            000112 automatic       pointer                  dcl 164 set ref 53* 73 79 82 82
into_subscript                  000121 automatic       fixed bin(21,0)          dcl 166 set ref 70* 70* 73 79 82 82* 90
into_vb                         000104 automatic       pointer                  dcl 164 set ref 21* 24 40* 53 56 59 63 70 109
match_site                      000124 automatic       label variable           local dcl 170 set ref 32* 48* 73 79 82
maximum_value_stack_size
                         13            based           fixed bin(18,0)          level 3 dcl 5-16 ref 1-40
n_words                         000122 automatic       fixed bin(19,0)          dcl 167 set ref 138* 139*
non_match_site                  000130 automatic       label variable           local dcl 170 set ref 33* 49* 88
num_words                       000164 automatic       fixed bin(19,0)          dcl 1-20 set ref 1-35* 1-37 1-37* 1-37 1-40 1-40*
                                                                                  1-44
number_of_dimensions            000140 automatic       fixed bin(17,0)          dcl 4-3 set ref 137* 138 147
numeric_datum                          based           float bin(63)            array dcl 4-23 set ref 79 79 82 82 82 82 90* 97*
                                                                                  101* 115* 138
numeric_value             0(10)        based           bit(1)                   level 5 packed unaligned dcl 4-3 set ref 27 43 63 63
on_stack                  1            parameter       bit(1)                   array level 3 dcl 6-3 ref 27 43
operands                               parameter       structure                array level 2 dcl 6-3
operators_argument                     parameter       structure                level 1 dcl 6-3 set ref 17 36
pointers                 14            based           structure                level 2 dcl 5-16
rel                                                    builtin function         dcl 174 in procedure "apl_dyadic_iota_" ref 149
rel                                                    builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-40
result                    6            parameter       pointer                  level 2 in structure "operators_argument" packed
                                                                                  unaligned dcl 6-3 in procedure "apl_dyadic_iota_"
                                                                                  set ref 122*
result                          000114 automatic       pointer                  dcl 164 in procedure "apl_dyadic_iota_" set ref 54*
                                                                                  90 97 101 115
result_vb                       000106 automatic       pointer                  dcl 164 set ref 27* 43* 54 118 121 122 139* 140 141
                                                                                  144 147 147 149 149 149
rho                       5            based           fixed bin(21,0)          array level 2 dcl 4-3 set ref 144* 144 147
rhorho                    3            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 24 137 141* 141 143
size                                                   builtin function         dcl 174 ref 138 138
static_ws_info_ptr              000014 external static pointer                  level 2 packed unaligned dcl 5-11 ref 5-7
string                                                 builtin function         dcl 174 set ref 118* 121*
substr                                                 builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-37
substr                                                 builtin function         dcl 174 in procedure "apl_dyadic_iota_" ref 149
total_data_elements       2            based           fixed bin(21,0)          level 2 dcl 4-3 set ref 22 41 56 69 70 109 140* 140
type                                   based           structure                level 3 packed unaligned dcl 4-3 set ref 118* 121*
unspec                                                 builtin function         dcl 1-25 ref 1-37
value                           000100 automatic       float bin(63)            dcl 163 in procedure "apl_dyadic_iota_" set ref 109*
                                                                                  112* 115
value                                  parameter       pointer                  array level 3 in structure "operators_argument"
                                                                                  packed unaligned dcl 6-3 in procedure
                                                                                  "apl_dyadic_iota_" ref 20 21 39 40
value_bead                             based           structure                level 1 dcl 4-3 set ref 138
value_stack_ptr          16            based           pointer                  level 3 packed unaligned dcl 5-16 set ref 1-40 1-43
                                                                                  1-44* 1-44
values                    2            based           structure                level 2 dcl 5-16
where_error              10            parameter       fixed bin(17,0)          level 2 dcl 6-3 set ref 127* 127
ws_info                                based           structure                level 1 dcl 5-16
ws_info_ptr                     000142 automatic       pointer                  initial dcl 5-7 set ref 82 90 109 5-7* 1-40 1-40
                                                                                  1-43 1-44 1-44
zero_or_one_value_type                 constant        bit(18)                  initial unaligned dcl 3-30 ref 121

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Binary                                 internal static bit(1)                   initial dcl 2-16
MAX_VALUE_BEAD_SIZE                    internal static fixed bin(19,0)          initial dcl 4-28
NumberSize                             internal static fixed bin(4,0)           initial dcl 2-25
TheBiggestNumberWeveGot                internal static float bin(63)            initial dcl 2-16
TheSmallestNumberWeveGot               internal static float bin(63)            initial dcl 2-16
character_string_overlay               based           char                     dcl 4-19
character_value_type                   internal static bit(18)                  initial unaligned dcl 3-30
complex_datum                          based           complex float bin(63)    array dcl 4-26
complex_value_type                     internal static bit(18)                  initial unaligned dcl 3-30
fixed                                                  builtin function         dcl 174
function_type                          internal static bit(18)                  initial unaligned dcl 3-30
group_type                             internal static bit(18)                  initial unaligned dcl 3-30
label_type                             internal static bit(18)                  initial unaligned dcl 3-30
lexed_function_type                    internal static bit(18)                  initial unaligned dcl 3-30
list_value_type                        internal static bit(18)                  initial unaligned dcl 3-30
max_parse_stack_depth                  internal static fixed bin(17,0)          initial dcl 5-98
mod                                                    builtin function         dcl 174
not_integer_mask                       internal static bit(18)                  initial unaligned dcl 3-30
not_zero_or_one_mask                   internal static bit(18)                  initial unaligned dcl 3-30
numeric_value_type                     internal static bit(18)                  initial unaligned dcl 3-30
operator_type                          internal static bit(18)                  initial unaligned dcl 3-30
output_buffer                          based           char                     unaligned dcl 5-94
shared_variable_type                   internal static bit(18)                  initial unaligned dcl 3-30
symbol_type                            internal static bit(18)                  initial unaligned dcl 3-30
value_type                             internal static bit(18)                  initial unaligned dcl 3-30

NAMES DECLARED BY EXPLICIT CONTEXT.
allocate_result                 000403 constant        entry                    internal dcl 134 ref 29 45
apl_dyadic_epsilon_             000111 constant        entry                    external dcl 36
apl_dyadic_iota_                000044 constant        entry                    external dcl 17
apl_push_stack_                 000470 constant        entry                    internal dcl 1-4 ref 139
character_comparison_site       000223 constant        label                    dcl 73 ref 59
epsilon_match_site              000305 constant        label                    dcl 97 ref 48
epsilon_non_match_site          000313 constant        label                    dcl 101 ref 49
iota_match_site                 000274 constant        label                    dcl 90 set ref 32
iota_non_match_site             000274 constant        label                    dcl 90 ref 33
joined_code                     000150 constant        label                    dcl 51 ref 34
left_argument_not_vector        000370 constant        label                    dcl 125 set ref 24
never_match                     000323 constant        label                    dcl 109 ref 56 59 63
next_comparison                 000271 constant        label                    dcl 85 ref 77
next_element                    000320 constant        label                    dcl 104 ref 95 99
no_type_bits                    000375 constant        label                    dcl 130 ref 63
numeric_comparison_site         000235 constant        label                    dcl 79 ref 63
return_point                    000351 constant        label                    dcl 118 ref 107

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       650         670     542         660
Length      1166     542        20         262     106           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_dyadic_iota_                    136 external procedure  is an external procedure.  
allocate_result                         internal procedure  shares stack frame of external procedure apl_dyadic_iota_.  
apl_push_stack_                         internal procedure  shares stack frame of external procedure apl_dyadic_iota_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_dyadic_iota_         000100 value                       apl_dyadic_iota_
                         000102 from_vb                     apl_dyadic_iota_
                         000104 into_vb                     apl_dyadic_iota_
                         000106 result_vb                   apl_dyadic_iota_
                         000110 from                        apl_dyadic_iota_
                         000112 into                        apl_dyadic_iota_
                         000114 result                      apl_dyadic_iota_
                         000116 internal_op_code            apl_dyadic_iota_
                         000117 data_elements               apl_dyadic_iota_
                         000120 from_subscript              apl_dyadic_iota_
                         000121 into_subscript              apl_dyadic_iota_
                         000122 n_words                     apl_dyadic_iota_
                         000124 match_site                  apl_dyadic_iota_
                         000130 non_match_site              apl_dyadic_iota_
                         000134 comparison_site             apl_dyadic_iota_
                         000140 number_of_dimensions        apl_dyadic_iota_
                         000142 ws_info_ptr                 apl_dyadic_iota_
                         000162 block_ptr                   apl_push_stack_
                         000164 num_words                   apl_push_stack_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
apl_get_value_stack_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
apl_error_table_$iota_argument_not_vector                   apl_error_table_$no_type_bits apl_static_$ws_info_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5    7 000034        17 000041        20 000052        21 000056        22 000060        24 000062        27 000065
     29 000075        31 000076        32 000100        33 000103        34 000106        36 000107        39 000117
     40 000122        41 000125        43 000127        45 000137        47 000140        48 000142        49 000145
     51 000150        53 000153        54 000156        56 000161        59 000164        63 000176        69 000207
     70 000214        71 000222        73 000223        77 000234        79 000235        82 000251        85 000271
     88 000273        90 000274        95 000304        97 000305        99 000312       101 000313       104 000320
    107 000322       109 000323       112 000334       114 000336       115 000343       116 000347       118 000351
    121 000360       122 000363       123 000367       125 000370       127 000373       128 000374       130 000375
    132 000402       134 000403       137 000404       138 000407       139 000417       140 000421       141 000425
    143 000427       144 000437       145 000444       147 000446       149 000453       152 000467    1    4 000470
 1   35 000472    1   37 000474    1   40 000501    1   43 000516    1   44 000521    1   45 000530


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
