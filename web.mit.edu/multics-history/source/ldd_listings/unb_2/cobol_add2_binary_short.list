	COMPILATION LISTING OF SEGMENT cobol_add2_binary_short
	Compiled by: Multics PL/I Compiler, Release 31b, of April 24, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 05/24/89  1030.7 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
       17*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
       18*     MCR8060 cobol_add2_binary_short.pl1 Added Trace statements.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 /* Modified on 10/19/84 by FCH, [5.3-1], BUG563, new cobol_addr_tokens.incl.pl1 */
       23 /* Modified on 08/31/83 by FCH, [5.2...],  trace added */
       24 /* Modified on 01/17/77 by ORN to call cobol_make_reg_token instead of cobol_make_register_token */
       25 /* Modified since Version 2.0 */
       26 
       27 /*{*/
       28 /* format: style3 */
       29 cobol_add2_binary_short:
       30      proc (lop_token_ptr, rop_token_ptr, result_token_ptr, operation_code);
       31 
       32 	/***.....	if Trace_Bit then call cobol_gen_driver_$Tr_Beg(MY_NAME);/**/
       33 
       34 /*
       35*This procedure generates code to add or subtract two short
       36*binary operands using index register instructions.  The operands
       37*can be short binary data items or constants.
       38**/
       39 
       40 /*  DECLARATION OF THE PARAMETERS  */
       41 
       42 dcl	lop_token_ptr	ptr;
       43 dcl	rop_token_ptr	ptr;
       44 dcl	result_token_ptr	ptr;
       45 dcl	operation_code	fixed bin;
       46 
       47 /*  DESCRIPTION OF THE PARAMETERS  */
       48 
       49 /*
       50*PARAMETER		DESCRIPTION
       51*
       52*lop_token_ptr	Pointer to the token that describes the left
       53*		operand (augend or minuend) of the
       54*		operation to be performed.  (input)
       55*rop_token_ptr 	Pointer to the token that describes the
       56*		right operand (addend or subtrahend) of the
       57*		operation to be performed.  (input)
       58*result_token_ptr 	Pointer to a register token (type 100)
       59*		that describes the regisetr that contains
       60*		the result (sum or difference) of the
       61*		operation.  If this pointer is null() on entry,
       62*		then a buffer in which this token is creaded
       63*		is supplied by this procedure.  Otherwise
       64*		it must point to a work buffer in which
       65*		the token is to be built.
       66*operation_code	a code that indicates the type of arithmetic
       67*		operation to be performed.  (input)  The
       68*		code is defined in the following table:
       69*
       70*		   operation_code	|   meaning
       71*		===================================
       72*		      1		|      addition
       73*		      2		|   subtraction
       74*
       75**/
       76 
       77 /*  DECLARATION OF EXTERNAL ENTRIES  */
       78 
       79 dcl	cobol_register$load ext entry (ptr);
       80 dcl	cobol_register$release
       81 			ext entry (ptr);
       82 dcl	cobol_make_reg_token
       83 			ext entry (ptr, bit (4));
       84 dcl	cobol_alloc$stack	ext entry (fixed bin, fixed bin, fixed bin (24));
       85 dcl	cobol_make_type9$short_bin
       86 			ext entry (ptr, fixed bin, fixed bin (24));
       87 dcl	cobol_addr	ext entry (ptr, ptr, ptr);
       88 dcl	cobol_emit	ext entry (ptr, ptr, fixed bin);
       89 dcl	cobol_make_bin_const
       90 			ext entry (ptr, ptr, fixed bin);
       91 dcl	cobol_store_binary	ext entry (ptr, ptr, bit (1));
       92 
       93 /*  DECLARATION OF INTERNAL STATIC VARIABLES  */
       94 
       95 dcl	LXL		bit (10) int static init ("1110100000"b);
       96 						/*  720(0)  */
       97 dcl	LDX		bit (10) int static init ("0100100000"b);
       98 						/*  220(0)  */
       99 dcl	STX		bit (10) int static init ("1111000000"b);
      100 						/*  740(0)  */
      101 dcl	ADX		bit (10) int static init ("0001100000"b);
      102 						/*  060(0)  */
      103 dcl	SBX		bit (10) int static init ("0011100000"b);
      104 						/*  160(0)  */
      105 
      106 
      107 /*  DECLARATION OF INTERNAL VARIABLES  */
      108 
      109 dcl	1 input_buff	aligned,
      110 	  2 buff		(1:10) ptr;
      111 
      112 dcl	1 inst_buff	aligned,
      113 	  2 buff		(1:2) fixed bin;
      114 
      115 dcl	1 reloc_buff	aligned,
      116 	  2 buff		(1:10) bit (5) aligned;
      117 
      118 dcl	temp_lop_token_ptr	ptr;
      119 dcl	temp_rop_token_ptr	ptr;
      120 dcl	ret_offset	fixed bin (24);
      121 dcl	temp_op		bit (10);
      122 dcl	temp_ptr		ptr;
      123 dcl	call_again	bit (1);
      124 
      125 dcl	dn_ptr		ptr;
      126 
      127 
      128 dcl	1 register_struc,
      129 	  2 what_reg	fixed bin,
      130 	  2 reg_no	bit (4),
      131 	  2 lock		fixed bin,
      132 	  2 already_there	fixed bin,
      133 	  2 contains	fixed bin,
      134 	  2 tok_ptr	ptr,
      135 	  2 literal	bit (36);
      136 
      137 
      138 
      139 /**************************************************/
      140 start:						/*  Get an index register to be used in the computation, and lock it.  */
      141 	register_struc.what_reg = 5;			/*  any index register  */
      142 	register_struc.lock = 1;
      143 	register_struc.contains = 0;
      144 	call cobol_register$load (addr (register_struc));
      145 
      146 /*  Set up to call the addressability utility  */
      147 	input_ptr = addr (input_buff);
      148 	inst_ptr = addr (inst_buff);
      149 	reloc_ptr = addr (reloc_buff);
      150 
      151 	input_struc.type = 2;
      152 	input_struc.operand_no = 1;
      153 	input_struc.lock = 0;
      154 	input_struc.operand.size_sw (1) = 0;
      155 
      156 
      157 /*  Check to see if either operand is a constant token (type 2), and
      158*	if so, convert to an immediate constant token.  */
      159 
      160 	if lop_token_ptr -> data_name.type = rtc_numlit
      161 	then do;					/*  Left operand is numeric literal.  */
      162 		temp_ptr = null ();
      163 		call cobol_make_bin_const (lop_token_ptr, temp_ptr, 1);
      164 		lop_token_ptr = temp_ptr;
      165 	     end;					/*  Left operand is a numeric literal  */
      166 
      167 	if rop_token_ptr -> data_name.type = rtc_numlit
      168 	then do;					/*  Right operand is a numeric literal.  */
      169 		temp_ptr = null ();
      170 		call cobol_make_bin_const (rop_token_ptr, temp_ptr, 1);
      171 		rop_token_ptr = temp_ptr;
      172 	     end;					/*  Right operand is a numeric literal  */
      173 
      174 	if (operation_code = 2 /*  subtract  */ & rop_token_ptr -> data_name.type = rtc_dataname)
      175 	then do;					/*  Subtraction, and subtrahend is a data name  */
      176 
      177 		if mod (rop_token_ptr -> data_name.offset, 4) = 0
      178 		then do;				/*  Subtrahend is word aligned  */
      179 			temp_lop_token_ptr = lop_token_ptr;
      180 			temp_rop_token_ptr = rop_token_ptr;
      181 		     end;				/*  Subtrahend is word aligned  */
      182 
      183 		else do;				/*  Subtrahend is half-word aligned.  */
      184 						/*  Word align the subtrahend  */
      185 			temp_rop_token_ptr = null ();
      186 			call word_align_short (rop_token_ptr, temp_rop_token_ptr);
      187 			temp_lop_token_ptr = lop_token_ptr;
      188 		     end;				/*  Subtrahend is half-word aligned  */
      189 	     end;					/*  Subtraction, and subtrahend is a data name.  */
      190 
      191 
      192 	else if (operation_code = 2 /*  Subtract  */ & rop_token_ptr -> data_name.type = rtc_register)
      193 	     /*  Subtract, subtrahend is in a register  */
      194 	     | (lop_token_ptr -> data_name.type = rtc_register & rop_token_ptr -> data_name.type = rtc_register)
      195 						/*  Both operands are in registers  */
      196 	then do;					/*  Store the right operand into a short binary te porary.  */
      197 						/*  Allocate space on the stack, and build a data name token for it.  */
      198 		call cobol_alloc$stack (2, 0, ret_offset);
      199 		temp_rop_token_ptr = null ();
      200 		call cobol_make_type9$short_bin (temp_rop_token_ptr, 1000 /*stack*/, ret_offset);
      201 						/*  Generate code to store the register into the temporary.  */
      202 		call cobol_store_binary (rop_token_ptr, temp_rop_token_ptr, call_again);
      203 		temp_lop_token_ptr = lop_token_ptr;
      204 	     end;					/*  Store the right operand into a short binary temporary.  */
      205 
      206 
      207 	else if (rop_token_ptr -> data_name.type = rtc_register | lop_token_ptr -> data_name.type = rtc_register)
      208 	then do;					/*  Only one operand is in a register.  */
      209 						/*  Make the  left operand the register token.  */
      210 		if lop_token_ptr -> data_name.type = rtc_register
      211 		then do;				/*  Left operand pointer already points to the register token.  */
      212 			temp_lop_token_ptr = lop_token_ptr;
      213 			temp_rop_token_ptr = rop_token_ptr;
      214 		     end;				/*  Left operand pointer already points to the register token.  */
      215 
      216 		else do;				/*  Must switch the operand pointers.  */
      217 			temp_lop_token_ptr = rop_token_ptr;
      218 			temp_rop_token_ptr = lop_token_ptr;
      219 		     end;				/*  Must switch the operand pointers.  */
      220 
      221 
      222 
      223 		if temp_rop_token_ptr -> data_name.type = rtc_dataname
      224 		then if mod (temp_rop_token_ptr -> data_name.offset, 4) ^= 0
      225 		     then do;			/*  Right operand not word aligned.  */
      226 						/*  Generate code to word align the right operand.  */
      227 			     temp_ptr = temp_rop_token_ptr;
      228 			     temp_rop_token_ptr = null ();
      229 			     call word_align_short (temp_ptr, temp_rop_token_ptr);
      230 			end;			/*  Right operand not word aligned.  */
      231 
      232 	     end;					/*  Only one operand is in a register.  */
      233 
      234 	else if (lop_token_ptr -> data_name.type = rtc_immed_const /*  Left operand a constant  */
      235 	     | (lop_token_ptr -> data_name.type = rtc_dataname & mod (lop_token_ptr -> data_name.offset, 4) = 0))
      236 	     /*  Left a word aligned data name  */
      237 	     & (rop_token_ptr -> data_name.type = rtc_dataname & mod (rop_token_ptr -> data_name.offset, 4) ^= 0)
      238 						/*  Right is half-word aligned  */
      239 	then do;					/*  Left operand constant or word aligned, right operand half-word aligned.  */
      240 						/*  Switch the operands, so that half-word aligned will be loaded into the index register  */
      241 
      242 		temp_lop_token_ptr = rop_token_ptr;
      243 		temp_rop_token_ptr = lop_token_ptr;
      244 
      245 	     end;					/*  Left operand constant or word aligned, right operand half-word aligned.  */
      246 
      247 	else if (lop_token_ptr -> data_name.type = rtc_dataname & mod (lop_token_ptr -> data_name.offset, 4) ^= 0)
      248 	     & (rop_token_ptr -> data_name.type = rtc_dataname & mod (rop_token_ptr -> data_name.offset, 4) ^= 0)
      249 	then do;					/*  Both operands are data names, and both are half-word aligned.  */
      250 						/*  Word align the right operand  */
      251 		temp_rop_token_ptr = null ();
      252 		call word_align_short (rop_token_ptr, temp_rop_token_ptr);
      253 		temp_lop_token_ptr = lop_token_ptr;
      254 	     end;					/*  Both operands are data names, and both are half-word aligned.  */
      255 
      256 	else do;					/*  None of the above special cases  */
      257 		temp_lop_token_ptr = lop_token_ptr;
      258 		temp_rop_token_ptr = rop_token_ptr;
      259 	     end;					/*  None of the above special cases.  */
      260 
      261 
      262 /*  Generate code to load the index, and add or subtract to it.  */
      263 
      264 
      265 
      266 	if temp_lop_token_ptr -> data_name.type = rtc_register
      267 	then do;					/*  Left operand is already in a register.  */
      268 						/*  Release the register obtained earlier .  */
      269 		call cobol_register$release (addr (register_struc));
      270 						/*  Set the register number of the left operand into the register structure.  */
      271 		register_struc.reg_no = temp_lop_token_ptr -> cobol_type100.register;
      272 	     end;					/*  Left operand is already in a register.  */
      273 
      274 	else call load_index (temp_lop_token_ptr, register_struc.reg_no);
      275 	call op_to_index (temp_rop_token_ptr, register_struc.reg_no, operation_code);
      276 
      277 /*  Make a register token for the register containing the result of the computation  */
      278 	call cobol_make_reg_token (result_token_ptr, register_struc.reg_no);
      279 
      280 	/***..... if Trace_Bit then call cobol_gen_driver_$Tr_End(MY_NAME);/**/
      281 
      282 /*************************************/
      283 word_align_short:
      284      proc (unaligned_tok_ptr, aligned_tok_ptr);
      285 
      286 /*
      287*This procedure generates code to word align a short binary cobol
      288*data item.
      289**/
      290 
      291 /*  DECLARATION OF THE PARAMETERS  */
      292 
      293 dcl	unaligned_tok_ptr	ptr;
      294 dcl	aligned_tok_ptr	ptr;
      295 
      296 /*  DESCRIPTION OF THE PARAMETERS  */
      297 /*
      298*PARAMETER		DESCRIPTION
      299*
      300*unaligned_tok_ptr	Pointer to the data name token for the
      301*		half-word aligned short binary data item.
      302*		(input)
      303*aligned_tok_ptr	Pointer to a data name token that describes
      304*		the word aligned fixed binary data item.
      305*		If this pointer is null() on entry, then a
      306*		token will be created in compiler space,
      307*		otherwise, it must point to some work space
      308*		in which the token is to be built.
      309*
      310**/
      311 
      312 
      313 /*  Allocate space on the stack to receive the word aligned short binary.  */
      314 	call cobol_alloc$stack (2, 0, ret_offset);
      315 
      316 /*  Make a data name token for the temporary space.  */
      317 	call cobol_make_type9$short_bin (aligned_tok_ptr, 1000, ret_offset);
      318 
      319 /*  Establish addressability to the original operand.  */
      320 	input_struc.operand.token_ptr (1) = unaligned_tok_ptr;
      321 	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      322 
      323 	temp_op = LXL;
      324 	substr (temp_op, 7, 3) = substr (register_struc.reg_no, 2, 3);
      325 
      326 /*  Emit the code to load the subtrahend into the index register.  */
      327 	inst_struc_basic.fill1_op = temp_op;
      328 	call cobol_emit (inst_ptr, reloc_ptr, 1);
      329 
      330 /*  Establish addressability to the temporary  */
      331 	input_struc.operand.token_ptr (1) = aligned_tok_ptr;
      332 	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      333 
      334 	temp_op = STX;
      335 	substr (temp_op, 7, 3) = substr (register_struc.reg_no, 2, 3);
      336 
      337 /*  Emit code to store the half-word aligned into the word aligned temporary.  */
      338 	inst_struc_basic.fill1_op = temp_op;
      339 	call cobol_emit (inst_ptr, reloc_ptr, 1);
      340      end word_align_short;
      341 
      342 
      343 /*************************************/
      344 load_index:
      345      proc (op_token_ptr, index_reg_no);
      346 
      347 /*
      348*This procedure generates code to load an index register with
      349*a value to be used in a computation using the register.  The value
      350*loaded into the index may be either a short binary data item, or
      351*a constant.
      352**/
      353 
      354 /*  DECLARATION OF THE PARAMETERS  */
      355 
      356 dcl	op_token_ptr	ptr;
      357 dcl	index_reg_no	bit (4);
      358 
      359 
      360 /*
      361*PARAMETER		DESCRIPTION
      362*
      363*op_token_ptr	Pointer to a token that describes the value
      364*		to be loaded into the index  register.  This
      365*		may be either a data name (type 9) token
      366*		or an immediate constant (type 102) token
      367*		(input)
      368*index_reg_no	A code that indicates the index register
      369*		to be loaded. (input)  The format of this
      370*		code is:
      371*		     "1nnn"b
      372*		where nnn is the index register number (1-7)
      373*
      374**/
      375 
      376 /*  DECLARATION OF INTERNAL STATIC DATA  */
      377 
      378 dcl	ldx_du_inst	bit (36) int static init ("000000000000000000010010000000000011"b);
      379 						/*  LDXn 0,du  */
      380 
      381 
      382 /*  DECLARATION OF INTERNAL DATA  */
      383 
      384 dcl	work_opcode	bit (10);
      385 
      386 	if op_token_ptr -> data_name.type = rtc_dataname
      387 	then do;					/*  Data name is to be loaded into the index register  */
      388 
      389 		if mod (op_token_ptr -> data_name.offset, 4) ^= 0
      390 		then work_opcode = LXL;		/*  Data name is half-word aligned.  */
      391 		else work_opcode = LDX;		/*  Data name is word aligned.  */
      392 						/*  Establish addressability to the operand  */
      393 		input_struc.operand.token_ptr (1) = op_token_ptr;
      394 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      395 
      396 		substr (work_opcode, 7, 3) = substr (index_reg_no, 2, 3);
      397 		inst_struc_basic.fill1_op = work_opcode;
      398 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      399 	     end;					/*  Data name is  to be loaded into the index register  */
      400 
      401 	else do;					/*  Constant is to be loaded into the index register  */
      402 		substr (ldx_du_inst, 25, 3) = substr (index_reg_no, 2, 3);
      403 		substr (ldx_du_inst, 1, 18) = substr (unspec (op_token_ptr -> immed_const.const_value), 19, 18);
      404 		call cobol_emit (addr (ldx_du_inst), null (), 1);
      405 
      406 	     end;					/*  Constant is to be loaded into the index register  */
      407 
      408      end load_index;
      409 
      410 
      411 /*************************************/
      412 op_to_index:
      413      proc (op_token_ptr, index_reg_no, operation_code);
      414 
      415 /*
      416*This procedure generates code to add a value to or subtract a
      417*value from an index  register.
      418**/
      419 
      420 /*  DECLARATION OF THE PARAMETERS  */
      421 
      422 dcl	op_token_ptr	ptr;
      423 dcl	index_reg_no	bit (4);
      424 dcl	operation_code	fixed bin;
      425 
      426 /*  DESCRIPTION OF THE PARAMETERS  */
      427 
      428 /*
      429*PARAMETER		DESCRIPTION
      430*
      431*op_token_ptr	Pointer to the token that describes the
      432*		value to be added to or subtracted
      433*		from the index register.  This token can
      434*		describe either a word aligned short binary
      435*		or an immediate constant.  (input)
      436*index_reg_no	A code that indicates the index register to
      437*		which the operation is to be performed.
      438*		(input)  The format of this code is:
      439*		      "1nnn"b
      440*		where nnn is the index register number. (1-7)
      441*operation_code	A code that specifies the operation to be
      442*		performed (input)  This code is:
      443*		   value		|   operation
      444*		==========================================
      445*		     1		|   addition
      446*		     2		|   subtraction
      447*		=========================================
      448*
      449**/
      450 
      451 
      452 /*  DECLARATION OF INTERNAL STATIC DATA  */
      453 
      454 dcl	op_du_inst	bit (36) int static init ("000000000000000000000000000000000011"b);
      455 						/*  zero,du  */
      456 
      457 
      458 	if op_token_ptr -> data_name.type = rtc_dataname
      459 	then do;					/*  Operand is a data name.  */
      460 		input_struc.operand.token_ptr (1) = op_token_ptr;
      461 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      462 
      463 		if operation_code = 1
      464 		then inst_ptr -> inst_struc_basic.fill1_op = ADX;
      465 		else inst_ptr -> inst_struc_basic.fill1_op = SBX;
      466 		substr (inst_ptr -> inst_struc_basic.fill1_op, 7, 3) = substr (index_reg_no, 2, 3);
      467 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      468 	     end;					/*  Operand is a data name  */
      469 
      470 	else do;					/*  Operand is an immediate constant  */
      471 		substr (op_du_inst, 25, 3) = substr (index_reg_no, 2, 3);
      472 		substr (op_du_inst, 1, 18) = substr (unspec (op_token_ptr -> immed_const.const_value), 19, 18);
      473 		if operation_code = 1
      474 		then substr (op_du_inst, 19, 6) = ADX;
      475 		else substr (op_du_inst, 19, 6) = SBX;
      476 		call cobol_emit (addr (op_du_inst), null (), 1);
      477 	     end;					/*  Operand is an immediate constant.  */
      478 
      479      end op_to_index;
      480 
      481 
      482 	/***.....	dcl cobol_gen_driver_$Tr_Beg entry(char(*));/**/
      483 	/***.....	dcl cobol_gen_driver_$Tr_End entry(char(*));/**/
      484 
      485 	/***.....	dcl Trace_Bit bit(1) static external;/**/
      486 	/***.....	dcl Trace_Lev fixed bin static external;/**/
      487 	/***.....	dcl Trace_Line char(36) static external;/**/
      488 	/***.....	dcl ioa_ entry options(variable); /**/
      489 	/***..... dcl MY_NAME char (23) int static init ("COBOL_ADD2_BINARY_SHORT");/**/
      490 
      491 /*  INCLUDE FILES USED IN THIS PROCEDURE  */
      492 
      493 
      494 /*****	Declaration for builtin function	*****/
      495 
      496 dcl	(substr, mod, binary, fixed, addr, addrel, rel, length, string, unspec, null, index)
      497 			builtin;
      498 
      499 /*****	End of declaration for builtin function	*****/
      500 
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... cobol_type9.incl.pl1 */
  1     3 /* Last modified on 11/19/76 by ORN */
  1     4 
  1     5 /*
  1     6*A type 9 data name token is entered into the name table by the data
  1     7*division syntax phase for each data name described in the data division.
  1     8*The replacement phase subsequently replaces type 8 user word references
  1     9*to data names in the procedure division minpral file with the corresponding
  1    10*type 9 tokens from the name table.
  1    11**/
  1    12 
  1    13 /* dcl dn_ptr ptr; */
  1    14 
  1    15 /* BEGIN DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    16 dcl 1 data_name based (dn_ptr),
  2     1 
  2     2 /* begin include file ... cobol_TYPE9.incl.pl1 */
  2     3 /* Last modified on 06/19/77 by ORN */
  2     4 /* Last modified on 12/28/76 by FCH */
  2     5 
  2     6 		/* header */
  2     7 		2 size fixed bin,
  2     8 		2 line fixed bin,
  2     9 		2 column fixed bin,
  2    10 		2 type fixed bin,
  2    11 		/* body */
  2    12 		2 string_ptr ptr,
  2    13 		2 prev_rec ptr,
  2    14 		2 searched bit (1),
  2    15 		2 duplicate bit (1),
  2    16 		2 saved bit (1),
  2    17 		2 debug_ind bit (1),
  2    18 		2 filler2 bit (3),
  2    19 		2 used_as_sub bit (1),
  2    20 		2 def_line fixed bin,
  2    21 		2 level fixed bin,
  2    22 		2 linkage fixed bin,
  2    23 		2 file_num fixed bin,
  2    24 		2 size_rtn fixed bin,
  2    25 		2 item_length fixed bin(24),
  2    26 		2 places_left fixed bin,
  2    27 		2 places_right fixed bin,
  2    28 		/* description */
  2    29 		2 file_section bit (1),
  2    30 		2 working_storage bit (1),
  2    31 		2 constant_section bit (1),
  2    32 		2 linkage_section bit (1),
  2    33 		2 communication_section bit (1),
  2    34 		2 report_section bit (1),
  2    35 		2 level_77 bit (1),
  2    36 		2 level_01 bit (1),
  2    37 		2 non_elementary bit (1),
  2    38 		2 elementary bit (1),
  2    39 		2 filler_item bit (1),
  2    40 		2 s_of_rdf bit (1),
  2    41 		2 o_of_rdf bit (1),
  2    42 		2 bin_18 bit (1),
  2    43 		2 bin_36 bit (1),
  2    44 		2 pic_has_l bit (1),
  2    45 		2 pic_is_do bit (1),
  2    46 		2 numeric bit (1),
  2    47 		2 numeric_edited bit (1),
  2    48 		2 alphanum bit (1),
  2    49 		2 alphanum_edited bit (1),
  2    50 		2 alphabetic bit (1),
  2    51 		2 alphabetic_edited bit (1),
  2    52 		2 pic_has_p bit (1),
  2    53 		2 pic_has_ast bit (1),
  2    54 		2 item_signed bit(1),
  2    55 		2 sign_separate bit (1),
  2    56 		2 display bit (1),
  2    57 		2 comp bit (1),
  2    58 		2 ascii_packed_dec_h bit (1),	/* as of 8/16/76  this field used for comp8. */
  2    59 		2 ascii_packed_dec bit (1),
  2    60 		2 ebcdic_packed_dec bit (1),
  2    61 		2 bin_16 bit (1),
  2    62 		2 bin_32 bit (1),
  2    63 		2 usage_index bit (1),
  2    64 		2 just_right bit (1),
  2    65 		2 compare_argument bit (1),
  2    66 		2 sync bit (1),
  2    67 		2 temporary bit (1),
  2    68 		2 bwz bit (1),
  2    69 		2 variable_length bit (1),
  2    70 		2 subscripted bit (1),
  2    71 		2 occurs_do bit (1),
  2    72 		2 key_a bit (1),
  2    73 		2 key_d bit (1),
  2    74 		2 indexed_by bit (1),
  2    75 		2 value_numeric bit (1),
  2    76 		2 value_non_numeric bit (1),
  2    77 		2 value_signed bit (1),
  2    78 		2 sign_type bit (3),
  2    79 		2 pic_integer bit (1),
  2    80 		2 ast_when_zero bit (1),
  2    81 		2 label_record bit (1),
  2    82 		2 sign_clause_occurred bit (1),
  2    83 		2 okey_dn bit (1),
  2    84 		2 subject_of_keyis bit (1),
  2    85 		2 exp_redefining bit (1),
  2    86 		2 sync_in_rec bit (1),
  2    87 		2 rounded bit (1),
  2    88 		2 ad_bit bit (1),
  2    89 		2 debug_all bit (1),
  2    90 		2 overlap bit (1),
  2    91 		2 sum_counter bit (1),
  2    92 		2 exp_occurs bit (1),
  2    93 		2 linage_counter bit (1),
  2    94 		2 rnm_01 bit (1),
  2    95 		2 aligned bit (1),
  2    96 		2 not_user_writable bit (1),
  2    97 		2 database_key bit (1),
  2    98 		2 database_data_item bit (1),
  2    99 		2 seg_num fixed bin,
  2   100 		2 offset fixed bin(24),
  2   101 		2 initial_ptr fixed bin,
  2   102 		2 edit_ptr fixed bin,
  2   103 		2 occurs_ptr fixed bin,
  2   104 		2 do_rec char(5),
  2   105 		2 bitt bit (1),
  2   106 		2 byte bit (1),
  2   107 		2 half_word bit (1),
  2   108 		2 word bit (1),
  2   109 		2 double_word bit (1),
  2   110 		2 half_byte bit (1),
  2   111 		2 filler5 bit (1),
  2   112 		2 bit_offset bit (4),
  2   113 		2 son_cnt bit (16),
  2   114 		2 max_red_size fixed bin(24),
  2   115 		2 name_size fixed bin,
  2   116 		2 name char(0 refer(data_name.name_size));	
  2   117 
  2   118 
  2   119 
  2   120 /* end include file ... cobol_TYPE9.incl.pl1 */
  2   121 
  1    17 
  1    18 /* END DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    19 
  1    20 /* END INCLUDE FILE ... cobol_type9.incl.pl1 */
  1    21 
      501 
  3     1   
  3     2 /* BEGIN INCLUDE FILE... cobol_type102.incl.pl1 */
  3     3 /* Last modified on 1/19/76 by ORN */
  3     4 
  3     5 /*
  3     6*An immediate constant token is created during the
  3     7*generation of code that performs arithmetic in the hardware
  3     8*registers, for any numeric literal token whose value is within
  3     9*the range:  (-131072,131071).
  3    10**/
  3    11 
  3    12 dcl immed_const_ptr ptr;
  3    13 
  3    14 /* BEGIN DECLARATION OF TYPE102 (IMMEDIATE CONSTANT) TOKEN */
  3    15 dcl 1 immed_const based(immed_const_ptr),
  3    16 	/* header */
  3    17 	2 size fixed bin (15),
  3    18 	2 line fixed bin (15),
  3    19 	2 column fixed bin (15),
  3    20 	2 type fixed bin (15),
  3    21 	/* body */
  3    22 	2 const_value fixed bin (35);
  3    23 /* END DECLARATION OF TYPE102 (IMMEDIATE CONSTANT) TOKEN */
  3    24 
  3    25 /*
  3    26*FIELD		CONTENTS
  3    27*
  3    28*size		The total size in bytes of this immediate
  3    29*		constant token.
  3    30*line		not used
  3    31*column		not used
  3    32*type		102
  3    33*const_value	The fixed binary value of the immediate constant.
  3    34**/
  3    35 
  3    36 /* END INCLUDE FILE... cobol_type102.incl.pl1 */
  3    37 
      502 
  4     1 
  4     2 /* BEGIN INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8058),
  4     7*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
  4     8*     MCR8058 cobol_addr_tokens.incl.pl1 Change array extents to refer to
  4     9*     constants rather than variables.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Last modified on 10/1/74 by tg */
  4    14 
  4    15 
  4    16 /* parameter list */
  4    17 
  4    18      dcl	   (input_ptr, inst_ptr, reloc_ptr) ptr;
  4    19 
  4    20 
  4    21 /* input_struc_basic is used for type 1 addressing */
  4    22 
  4    23      dcl	   1 input_struc_basic    based (input_ptr),
  4    24 	     2 type	      fixed bin,
  4    25 	     2 operand_no	      fixed bin,
  4    26 	     2 lock	      fixed bin,
  4    27 	     2 segno	      fixed bin,
  4    28 	     2 char_offset	      fixed bin (24),
  4    29 	     2 send_receive	      fixed bin;
  4    30 
  4    31 
  4    32      dcl	   1 input_struc	      based (input_ptr),
  4    33 	     2 type	      fixed bin,
  4    34 	     2 operand_no	      fixed bin,
  4    35 	     2 lock	      fixed bin,
  4    36 	     2 operand	      (0 refer (input_struc.operand_no)),
  4    37 	       3 token_ptr	      ptr,
  4    38 	       3 send_receive     fixed bin,
  4    39 	       3 ic_mod	      fixed bin,
  4    40 	       3 size_sw	      fixed bin;
  4    41 
  4    42 /* reloc_struc is used for all types of addressing * all types */
  4    43 
  4    44      dcl	   1 reloc_struc	      (input_struc.operand_no + 1) based (reloc_ptr),
  4    45 	     2 left_wd	      bit (5) aligned,
  4    46 	     2 right_wd	      bit (5) aligned;
  4    47 
  4    48 /* Instruction format for 1 word instruction */
  4    49 
  4    50 
  4    51      dcl	   1 inst_struc_basic     based (inst_ptr) aligned,
  4    52 	     2 y		      unaligned,
  4    53 	       3 pr	      bit (3) unaligned,
  4    54 	       3 wd_offset	      bit (15) unaligned,
  4    55 	     2 fill1_op	      bit (10) unaligned,
  4    56 	     2 zero1	      bit (1) unaligned,
  4    57 	     2 pr_spec	      bit (1) unaligned,
  4    58 	     2 tm		      bit (2) unaligned,
  4    59 	     2 td		      bit (4) unaligned;
  4    60 
  4    61 
  4    62 /* The detailed definitions of the fields in this structure
  4    63*   can be found in the GMAP manual section 8 */
  4    64 /* EIS instruction format for 2_4 word instructions */
  4    65 
  4    66      dcl	   1 inst_struc	      based (inst_ptr) aligned,
  4    67 	     2 inst	      unaligned,
  4    68 	       3 zero1	      bit (2) unaligned,
  4    69 	       3 mf3	      unaligned,
  4    70 	         4 pr_spec	      bit (1) unaligned,
  4    71 	         4 reg_or_length  bit (1) unaligned,
  4    72 	         4 zero2	      bit (1) unaligned,
  4    73 	         4 reg_mod	      bit (4) unaligned,
  4    74 	       3 zero3	      bit (2) unaligned,
  4    75 	       3 mf2	      unaligned,
  4    76 	         4 pr_spec	      bit (1) unaligned,
  4    77 	         4 reg_or_length  bit (1) unaligned,
  4    78 	         4 zero4	      bit (1) unaligned,
  4    79 	         4 reg_mod	      bit (4) unaligned,
  4    80 	       3 fill1_op	      bit (10) unaligned,
  4    81 	       3 zero5	      bit (1) unaligned,
  4    82 	       3 mf1	      unaligned,
  4    83 	         4 pr_spec	      bit (1) unaligned,
  4    84 	         4 reg_or_length  bit (1) unaligned,
  4    85 	         4 zero6	      bit (1) unaligned,
  4    86 	         4 reg_mod	      bit (4) unaligned,
  4    87 	     2 desc_ext	      unaligned,
  4    88 	       3 desc	      (512) unaligned,
  4    89 	         4 desc_od	      bit (36) unaligned;
  4    90 
  4    91 /* The detailed definitions of the fields in this structure
  4    92*   can be found in the GMAP manual section 8.
  4    93*   The desc_ext is the descriptor extension of this eis
  4    94*   instruction. The number of descriptors associated with
  4    95*   this instruction is equavalent to the operand number.
  4    96*   Depending on operand data type, the descriptor
  4    97*   can be alphanumeric or numeric.  The structures of the
  4    98*   alphanumeric and the numeric descriptors are defined
  4    99*   below. */
  4   100 
  4   101 /* alphanumeric descriptor format */
  4   102 
  4   103      dcl	   1 desc_an	      based (desc_an_ptr) unaligned,
  4   104 	     2 desc_f	      (512) unaligned,
  4   105 	       3 y	      unaligned,
  4   106 	         4 pr	      bit (3) unaligned,
  4   107 	         4 wd_offset      bit (15) unaligned,
  4   108 	       3 char_n	      bit (3) unaligned,
  4   109 	       3 zero1	      bit (1) unaligned,
  4   110 	       3 ta	      bit (2),
  4   111 	       3 n	      bit (12) unaligned;
  4   112 
  4   113 
  4   114 /* The detailed definitions of the fields in this structure can
  4   115*   be found in the GMAP manual section 8. */
  4   116 /* numeric descriptor format */
  4   117 
  4   118      dcl	   desc_nn_ptr	      ptr;
  4   119      dcl	   desc_an_ptr	      ptr;
  4   120 
  4   121 
  4   122      dcl	   1 desc_nn	      based (desc_nn_ptr) unaligned,
  4   123 	     2 desc_f	      (512) unaligned,
  4   124 	       3 y	      unaligned,
  4   125 	         4 pr	      bit (3) unaligned,
  4   126 	         4 wd_offset      bit (15) unaligned,
  4   127 	       3 digit_n	      bit (3) unaligned,
  4   128 	       3 tn	      bit (1) unaligned,
  4   129 	       3 sign_type	      bit (2) unaligned,
  4   130 	       3 scal	      bit (6) unaligned,
  4   131 	       3 n	      bit (6) unaligned;
  4   132 
  4   133 
  4   134 /* The detailed definitions of fields in this structure can
  4   135*   be found in the GMAP manual section 8. */
  4   136 /* END INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  4   137 
      503 
  5     1 
  5     2 /* BEGIN INCLUDE FILE ...   cobol_record_types.incl.pl1 */
  5     3 /*   <<<   LAST MODIFIED ON 09-09-75 by tlf   >>>   */
  5     4 
  5     5 dcl rtc_resword fixed bin (15) int static		init(1);
  5     6 dcl rtc_numlit fixed bin (15) int static		init(2);
  5     7 dcl rtc_alphalit fixed bin (15) int static		init(3);
  5     8 dcl rtc_picstring fixed bin (15) int static		init(4);
  5     9 dcl rtc_diag fixed bin (15) int static			init(5);
  5    10 dcl rtc_source fixed bin (15) int static		init(6);
  5    11 dcl rtc_procdef fixed bin (15) int static		init(7);
  5    12 dcl rtc_userwd fixed bin (15) int static		init(8);
  5    13 dcl rtc_dataname fixed bin (15) int static		init(9);
  5    14 dcl rtc_indexname fixed bin (15) int static		init(10);
  5    15 dcl rtc_condname fixed bin (15) int static 		init(11);
  5    16 dcl rtc_filedef fixed bin (15) int static 		init(12);
  5    17 dcl rtc_commdesc fixed bin (15) int static		init(13);
  5    18 dcl rtc_debugitems fixed bin (15) int static		init(14);
  5    19 dcl rtc_savedarea fixed bin (15) int static		init(15);
  5    20 dcl rtc_sortmerge fixed bin (15) int static		init(16);
  5    21 dcl rtc_mnemonic fixed bin (15) int static		init(17);
  5    22 dcl rtc_pararef fixed bin (15) int static		init(18);
  5    23 dcl rtc_eos fixed bin (15) int static 			init(19);
  5    24 dcl rtc_reportname fixed bin (15) int static		init(20);
  5    25 dcl rtc_groupname fixed bin (15) int static		init(21);
  5    26 dcl rtc_reportentry fixed bin (15) int static		init(22);
  5    27 dcl rtc_unknown1 fixed bin (15) int static		init(23);
  5    28 dcl rtc_debugenable fixed bin (15) int static		init(24);
  5    29 dcl rtc_unknown2 fixed bin (15) int static		init(25);
  5    30 dcl rtc_unknown3 fixed bin (15) int static		init(26);
  5    31 dcl rtc_unknown4 fixed bin (15) int static		init(27);
  5    32 dcl rtc_unknown5 fixed bin (15) int static		init(28);
  5    33 dcl rtc_unknown6 fixed bin (15) int static		init(29);
  5    34 dcl rtc_internal_tag fixed bin (15) int static		init(30);
  5    35 dcl rtc_equate_tag fixed bin (15) int static		init(31);
  5    36 dcl rtc_register fixed bin (15) int static		init(100);
  5    37 dcl rtc_fdec_temp fixed bin (15) int static		init(101);
  5    38 dcl rtc_immed_const fixed bin (15) int static		init(102);
  5    39 
  5    40 /* END INCLUDE FILE ...   cobol_record_types.incl.pl1 */
  5    41 
      504 
  6     1 
  6     2 /* BEGIN INCLUDE FILE ... cobol_type100.incl.pl1 */
  6     3 /* Last modified on 11/19/76 by ORN */
  6     4 
  6     5 /*
  6     6*The internal register token is used only during the code generation phase.
  6     7**/
  6     8 
  6     9 dcl cobol_type100_ptr ptr;
  6    10 
  6    11 /* BEGIN DECLARATION OF TYPE100 (INTERNAL REGISTER) TOKEN */
  6    12 dcl 1 cobol_type100 based (cobol_type100_ptr) aligned,
  6    13 	/* header */
  6    14 	 2 size fixed bin (15),
  6    15 	 2 line fixed bin (15),
  6    16 	 2 column fixed bin (7),
  6    17 	 2 type fixed bin (7),
  6    18 	/* body */
  6    19 	 2 register bit (4) unaligned;
  6    20 /* END DECLARATION OF TYPE100 (INTERNAL REGISTER) TOKEN */
  6    21 
  6    22  /*
  6    23*FIELD		CONTENTS
  6    24*
  6    25*size		The total size in bytes of this token.
  6    26*line		Generated sequence number of source line.
  6    27*		Always 0.
  6    28*column		The column number on the source image.
  6    29*		Always 0.
  6    30*type		100
  6    31*register		The register number in the following form.
  6    32*			"0001"b - A register.
  6    33*			"0010"b - Q register.
  6    34*			"0011"b - A and Q registers.
  6    35*			"1nnn"b - index register nnn.
  6    36**/
  6    37 
  6    38 /* END INCLUDE FILE ... cobol_type100.incl.pl1 */
  6    39 
      505 
      506 
      507      end cobol_add2_binary_short;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/24/89  0834.9  cobol_add2_binary_short.pl1       >spec>install>MR12.3-1048>cobol_add2_binary_short.pl1
501          1    03/27/82  0439.9  cobol_type9.incl.pl1              >ldd>include>cobol_type9.incl.pl1
1-17         2    11/11/82  1712.7  cobol_TYPE9.incl.pl1              >ldd>include>cobol_TYPE9.incl.pl1
502          3    03/27/82  0439.8  cobol_type102.incl.pl1            >ldd>include>cobol_type102.incl.pl1
503          4    05/24/89  0811.7  cobol_addr_tokens.incl.pl1        >spec>install>MR12.3-1048>cobol_addr_tokens.incl.pl1
504          5    03/27/82  0439.8  cobol_record_types.incl.pl1       >ldd>include>cobol_record_types.incl.pl1
505          6    03/27/82  0439.8  cobol_type100.incl.pl1            >ldd>include>cobol_type100.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADX                                    constant        bit(10)                  initial packed unaligned dcl 101 ref 463 473
LDX                                    constant        bit(10)                  initial packed unaligned dcl 97 ref 391
LXL                                    constant        bit(10)                  initial packed unaligned dcl 95 ref 323 389
SBX                                    constant        bit(10)                  initial packed unaligned dcl 103 ref 465 475
STX                                    constant        bit(10)                  initial packed unaligned dcl 99 ref 334
addr                                                   builtin function         dcl 496 ref 144 144 147 148 149 269 269 404 404 476
                                                                                  476
aligned_tok_ptr                        parameter       pointer                  dcl 294 set ref 283 317* 331
call_again                      000150 automatic       bit(1)                   packed unaligned dcl 123 set ref 202*
cobol_addr                      000024 constant        entry                    external dcl 87 ref 321 332 394 461
cobol_alloc$stack               000020 constant        entry                    external dcl 84 ref 198 314
cobol_emit                      000026 constant        entry                    external dcl 88 ref 328 339 398 404 467 476
cobol_make_bin_const            000030 constant        entry                    external dcl 89 ref 163 170
cobol_make_reg_token            000016 constant        entry                    external dcl 82 ref 278
cobol_make_type9$short_bin      000022 constant        entry                    external dcl 85 ref 200 317
cobol_register$load             000012 constant        entry                    external dcl 79 ref 144
cobol_register$release          000014 constant        entry                    external dcl 80 ref 269
cobol_store_binary              000032 constant        entry                    external dcl 91 ref 202
cobol_type100                          based           structure                level 1 dcl 6-12
const_value               4            based           fixed bin(35,0)          level 2 dcl 3-15 ref 403 472
contains                  4     000152 automatic       fixed bin(17,0)          level 2 dcl 128 set ref 143*
data_name                              based           structure                level 1 unaligned dcl 1-16
fill1_op                  0(18)        based           bit(10)                  level 2 packed packed unaligned dcl 4-51 set ref
                                                                                  327* 338* 397* 463* 465* 466*
immed_const                            based           structure                level 1 unaligned dcl 3-15
index_reg_no                           parameter       bit(4)                   packed unaligned dcl 357 in procedure "load_index"
                                                                                  ref 344 396 402
index_reg_no                           parameter       bit(4)                   packed unaligned dcl 423 in procedure "op_to_index"
                                                                                  ref 412 466 471
input_buff                      000100 automatic       structure                level 1 dcl 109 set ref 147
input_ptr                       000164 automatic       pointer                  dcl 4-18 set ref 147* 151 152 153 154 320 321* 331
                                                                                  332* 393 394* 460 461*
input_struc                            based           structure                level 1 unaligned dcl 4-32
inst_buff                       000124 automatic       structure                level 1 dcl 112 set ref 148
inst_ptr                        000166 automatic       pointer                  dcl 4-18 set ref 148* 321* 327 328* 332* 338 339*
                                                                                  394* 397 398* 461* 463 465 466 467*
inst_struc_basic                       based           structure                level 1 dcl 4-51
ldx_du_inst                     000010 internal static bit(36)                  initial packed unaligned dcl 378 set ref 402* 403*
                                                                                  404 404
lock                      2            based           fixed bin(17,0)          level 2 in structure "input_struc" dcl 4-32
                                                                                  in procedure "cobol_add2_binary_short" set ref
                                                                                  153*
lock                      2     000152 automatic       fixed bin(17,0)          level 2 in structure "register_struc" dcl 128
                                                                                  in procedure "cobol_add2_binary_short" set ref
                                                                                  142*
lop_token_ptr                          parameter       pointer                  dcl 42 set ref 29 160 163* 164* 179 187 192 203 207
                                                                                  210 212 218 234 234 234 243 247 247 253 257
mod                                                    builtin function         dcl 496 ref 177 223 234 234 247 247 389
null                                                   builtin function         dcl 496 ref 162 169 185 199 228 251 404 404 476 476
offset                   24            based           fixed bin(24,0)          level 2 dcl 1-16 ref 177 223 234 234 247 247 389
op_du_inst                      000011 internal static bit(36)                  initial packed unaligned dcl 454 set ref 471* 472*
                                                                                  473* 475* 476 476
op_token_ptr                           parameter       pointer                  dcl 422 in procedure "op_to_index" ref 412 458 460
                                                                                  472
op_token_ptr                           parameter       pointer                  dcl 356 in procedure "load_index" ref 344 386 389
                                                                                  393 403
operand                   4            based           structure                array level 2 unaligned dcl 4-32
operand_no                1            based           fixed bin(17,0)          level 2 dcl 4-32 set ref 152*
operation_code                         parameter       fixed bin(17,0)          dcl 424 in procedure "op_to_index" ref 412 463 473
operation_code                         parameter       fixed bin(17,0)          dcl 45 in procedure "cobol_add2_binary_short" set
                                                                                  ref 29 174 192 275*
reg_no                    1     000152 automatic       bit(4)                   level 2 packed packed unaligned dcl 128 set ref 271*
                                                                                  274* 275* 278* 324 335
register                  4            based           bit(4)                   level 2 packed packed unaligned dcl 6-12 ref 271
register_struc                  000152 automatic       structure                level 1 unaligned dcl 128 set ref 144 144 269 269
reloc_buff                      000126 automatic       structure                level 1 dcl 115 set ref 149
reloc_ptr                       000170 automatic       pointer                  dcl 4-18 set ref 149* 321* 328* 332* 339* 394* 398*
                                                                                  461* 467*
result_token_ptr                       parameter       pointer                  dcl 44 set ref 29 278*
ret_offset                      000144 automatic       fixed bin(24,0)          dcl 120 set ref 198* 200* 314* 317*
rop_token_ptr                          parameter       pointer                  dcl 43 set ref 29 167 170* 171* 174 177 180 186* 192
                                                                                  192 202* 207 213 217 234 234 242 247 247 252* 258
rtc_dataname                           constant        fixed bin(15,0)          initial dcl 5-13 ref 174 223 234 234 247 247 386 458
rtc_immed_const                        constant        fixed bin(15,0)          initial dcl 5-38 ref 234
rtc_numlit                             constant        fixed bin(15,0)          initial dcl 5-6 ref 160 167
rtc_register                           constant        fixed bin(15,0)          initial dcl 5-36 ref 192 192 192 207 207 210 266
size_sw                  10            based           fixed bin(17,0)          array level 3 dcl 4-32 set ref 154*
substr                                                 builtin function         dcl 496 set ref 324* 324 335* 335 396* 396 402* 402
                                                                                  403* 403 466* 466 471* 471 472* 472 473* 475*
temp_lop_token_ptr              000140 automatic       pointer                  dcl 118 set ref 179* 187* 203* 212* 217* 242* 253*
                                                                                  257* 266 271 274*
temp_op                         000145 automatic       bit(10)                  packed unaligned dcl 121 set ref 323* 324* 327 334*
                                                                                  335* 338
temp_ptr                        000146 automatic       pointer                  dcl 122 set ref 162* 163* 164 169* 170* 171 227*
                                                                                  229*
temp_rop_token_ptr              000142 automatic       pointer                  dcl 119 set ref 180* 185* 186* 199* 200* 202* 213*
                                                                                  218* 223 223 227 228* 229* 243* 251* 252* 258*
                                                                                  275*
token_ptr                 4            based           pointer                  array level 3 dcl 4-32 set ref 320* 331* 393* 460*
type                      3            based           fixed bin(17,0)          level 2 in structure "data_name" dcl 1-16
                                                                                  in procedure "cobol_add2_binary_short" ref 160 167
                                                                                  174 192 192 192 207 207 210 223 234 234 234 247
                                                                                  247 266 386 458
type                                   based           fixed bin(17,0)          level 2 in structure "input_struc" dcl 4-32
                                                                                  in procedure "cobol_add2_binary_short" set ref
                                                                                  151*
unaligned_tok_ptr                      parameter       pointer                  dcl 293 ref 283 320
unspec                                                 builtin function         dcl 496 ref 403 472
what_reg                        000152 automatic       fixed bin(17,0)          level 2 dcl 128 set ref 140*
work_opcode                     000206 automatic       bit(10)                  packed unaligned dcl 384 set ref 389* 391* 396* 397

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addrel                                                 builtin function         dcl 496
binary                                                 builtin function         dcl 496
cobol_type100_ptr                      automatic       pointer                  dcl 6-9
desc_an                                based           structure                level 1 packed packed unaligned dcl 4-103
desc_an_ptr                            automatic       pointer                  dcl 4-119
desc_nn                                based           structure                level 1 packed packed unaligned dcl 4-122
desc_nn_ptr                            automatic       pointer                  dcl 4-118
dn_ptr                                 automatic       pointer                  dcl 125
fixed                                                  builtin function         dcl 496
immed_const_ptr                        automatic       pointer                  dcl 3-12
index                                                  builtin function         dcl 496
input_struc_basic                      based           structure                level 1 unaligned dcl 4-23
inst_struc                             based           structure                level 1 dcl 4-66
length                                                 builtin function         dcl 496
rel                                                    builtin function         dcl 496
reloc_struc                            based           structure                array level 1 unaligned dcl 4-44
rtc_alphalit                           internal static fixed bin(15,0)          initial dcl 5-7
rtc_commdesc                           internal static fixed bin(15,0)          initial dcl 5-17
rtc_condname                           internal static fixed bin(15,0)          initial dcl 5-15
rtc_debugenable                        internal static fixed bin(15,0)          initial dcl 5-28
rtc_debugitems                         internal static fixed bin(15,0)          initial dcl 5-18
rtc_diag                               internal static fixed bin(15,0)          initial dcl 5-9
rtc_eos                                internal static fixed bin(15,0)          initial dcl 5-23
rtc_equate_tag                         internal static fixed bin(15,0)          initial dcl 5-35
rtc_fdec_temp                          internal static fixed bin(15,0)          initial dcl 5-37
rtc_filedef                            internal static fixed bin(15,0)          initial dcl 5-16
rtc_groupname                          internal static fixed bin(15,0)          initial dcl 5-25
rtc_indexname                          internal static fixed bin(15,0)          initial dcl 5-14
rtc_internal_tag                       internal static fixed bin(15,0)          initial dcl 5-34
rtc_mnemonic                           internal static fixed bin(15,0)          initial dcl 5-21
rtc_pararef                            internal static fixed bin(15,0)          initial dcl 5-22
rtc_picstring                          internal static fixed bin(15,0)          initial dcl 5-8
rtc_procdef                            internal static fixed bin(15,0)          initial dcl 5-11
rtc_reportentry                        internal static fixed bin(15,0)          initial dcl 5-26
rtc_reportname                         internal static fixed bin(15,0)          initial dcl 5-24
rtc_resword                            internal static fixed bin(15,0)          initial dcl 5-5
rtc_savedarea                          internal static fixed bin(15,0)          initial dcl 5-19
rtc_sortmerge                          internal static fixed bin(15,0)          initial dcl 5-20
rtc_source                             internal static fixed bin(15,0)          initial dcl 5-10
rtc_unknown1                           internal static fixed bin(15,0)          initial dcl 5-27
rtc_unknown2                           internal static fixed bin(15,0)          initial dcl 5-29
rtc_unknown3                           internal static fixed bin(15,0)          initial dcl 5-30
rtc_unknown4                           internal static fixed bin(15,0)          initial dcl 5-31
rtc_unknown5                           internal static fixed bin(15,0)          initial dcl 5-32
rtc_unknown6                           internal static fixed bin(15,0)          initial dcl 5-33
rtc_userwd                             internal static fixed bin(15,0)          initial dcl 5-12
string                                                 builtin function         dcl 496

NAMES DECLARED BY EXPLICIT CONTEXT.
cobol_add2_binary_short         000013 constant        entry                    external dcl 29
load_index                      000644 constant        entry                    internal dcl 344 ref 274
op_to_index                     000764 constant        entry                    internal dcl 412 ref 275
start                           000020 constant        label                    dcl 140
word_align_short                000461 constant        entry                    internal dcl 283 ref 186 229 252

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1266        1322    1127        1276
Length      1644    1127        34         306     136           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cobol_add2_binary_short             210 external procedure  is an external procedure.  
word_align_short                        internal procedure  shares stack frame of external procedure cobol_add2_binary_short.  
load_index                              internal procedure  shares stack frame of external procedure cobol_add2_binary_short.  
op_to_index                             internal procedure  shares stack frame of external procedure cobol_add2_binary_short.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ldx_du_inst                 load_index
000011 op_du_inst                  op_to_index

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cobol_add2_binary_short  000100 input_buff                  cobol_add2_binary_short
                         000124 inst_buff                   cobol_add2_binary_short
                         000126 reloc_buff                  cobol_add2_binary_short
                         000140 temp_lop_token_ptr          cobol_add2_binary_short
                         000142 temp_rop_token_ptr          cobol_add2_binary_short
                         000144 ret_offset                  cobol_add2_binary_short
                         000145 temp_op                     cobol_add2_binary_short
                         000146 temp_ptr                    cobol_add2_binary_short
                         000150 call_again                  cobol_add2_binary_short
                         000152 register_struc              cobol_add2_binary_short
                         000164 input_ptr                   cobol_add2_binary_short
                         000166 inst_ptr                    cobol_add2_binary_short
                         000170 reloc_ptr                   cobol_add2_binary_short
                         000206 work_opcode                 load_index

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cobol_addr                    cobol_alloc$stack             cobol_emit                    cobol_make_bin_const
cobol_make_reg_token          cobol_make_type9$short_bin    cobol_register$load           cobol_register$release
cobol_store_binary

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 000006       140 000020       142 000022       143 000024       144 000025       147 000035       148 000037
    149 000041       151 000043       152 000045       153 000047       154 000050       160 000051       162 000057
    163 000061       164 000076       167 000101       169 000107       170 000111       171 000126       174 000131
    177 000147       179 000153       180 000156       181 000157       185 000160       186 000162       187 000172
    189 000176       192 000177       198 000221       199 000237       200 000241       202 000256       203 000272
    204 000276       207 000277       210 000303       212 000305       213 000306       214 000307       217 000310
    218 000311       223 000312       227 000322       228 000323       229 000325       232 000327       234 000330
    242 000355       243 000356       245 000357       247 000360       251 000366       252 000370       253 000400
    254 000404       257 000405       258 000406       266 000407       269 000413       271 000424       272 000430
    274 000431       275 000433       278 000446       507 000460       283 000461       314 000463       317 000501
    320 000517       321 000524       323 000537       324 000541       327 000546       328 000553       331 000570
    332 000575       334 000610       335 000614       338 000621       339 000626       340 000643       344 000644
    386 000646       389 000653       391 000662       393 000666       394 000670       396 000703       397 000710
    398 000715       399 000732       402 000733       403 000740       404 000743       408 000763       412 000764
    458 000766       460 000773       461 000775       463 001010       465 001021       466 001025       467 001032
    468 001047       471 001050       472 001055       473 001060       475 001066       476 001070       479 001110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
