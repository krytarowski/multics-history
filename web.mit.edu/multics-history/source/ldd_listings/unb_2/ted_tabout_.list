	COMPILATION LISTING OF SEGMENT ted_tabout_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/23/82  1458.5 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
        8 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
        9 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       10 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       11 
       12 ted_gtabout_:			/* process out pseudo-tabs globally  */
       13       proc (ted_support_p, msg, code);
       14       mode = "g";
       15       goto global;
       16 
       17 dcl (msg		char (168) var,
       18      code		fixed bin (35)) parm;
       19 
       20 ted_vtabout_:			/* process out pseudo-tabs globally  */
       21       entry (ted_support_p, msg, code);
       22       mode = "v";
       23 global:
       24       if (ted_support.version ^= ted_support_version_2)
       25       then do;
       26          code = error_table_$unimplemented_version;
       27          return;
       28       end;
       29       call proc_expr (ted_support_p, msg, code);
       30       if (code ^= 0)
       31       then return;
       32       goto common;
       33 
       34 ted_tabout_:			/* process out pseudo-tabs	       */
       35       entry (ted_support_p, msg, code);
       36       mode = " ";
       37 
       38       if (ted_support.version ^= ted_support_version_2)
       39          & (ted_support.version ^= 1)
       40       then do;
       41          code = error_table_$unimplemented_version;
       42          return;
       43       end;
       44 
       45 common:
       46       delim = rchr (req.cc);
       47       req.cc = req.cc + 1;		/* process the tab specs	       */
       48       substr (tabmarks, 1, 1) = delim;
       49       tab = " ";
       50       last_tab = 0;
       51       tabchar = rchr (req.cc);
       52       j = req.cc + 1;
       53       if (rchr (j) = delim)		/* if none specified,	       */
       54       then do;			/*  use system settings	       */
       55 gb2b:
       56          do j = 11 to length (tab) by 10;
       57 	  substr (tab, j, 1) = "L";
       58 	  last_tab = j;
       59          end;
       60          req.cc = req.cc + 1;
       61          goto gb2a;
       62       end;
       63       num = 0;
       64       do req.cc = j to req.de;	/* walk across request line	       */
       65          tc = rchr (req.cc);
       66          nd = index (tabmarks, tc);
       67          if (nd ^= 0)
       68          then do;
       69 	  if (num = 0)
       70 	  then goto skipit;
       71 	  if (num > length (tab) - 4)
       72 	  then do;
       73 	     msg = "Sts) Tabstob >";
       74 	     pic3 = length (tab) - 4;
       75 	     msg = msg || pic3;
       76 	     code = tederror_table_$Error_Msg;
       77 	     return;
       78 	  end;
       79 	  last_tab = max (num, last_tab);   /* remember rightmost stop     */
       80 	  if (nd > 5)
       81 	  then nd = nd - 3;		/* account for upper case	       */
       82 	  if (nd < 3)
       83 	  then nd = 3;
       84 				/* plug in the stop		       */
       85 	  substr (tab, num, 1) = substr (tabmarks, nd, 1);
       86 	  num = 0;
       87 	  if (rchr (req.cc + 1) = ",")
       88 	  then req.cc = req.cc + 1;
       89 	  if (rchr (req.cc + 1) = delim)
       90 	  then do;
       91 	     req.cc = req.cc + 1;
       92 	     goto gb2a;
       93 	  end;
       94 	  if (tc = delim)
       95 	  then goto gb2a;
       96          end;
       97          else do;
       98 	  nd = index ("0123456789", tc);
       99 	  if (nd = 0)
      100 	  then do;
      101 	     msg = "Sbd) Bad decimal digit.";
      102 	     code = tederror_table_$Error_Msg;
      103 	     return;
      104 	  end;
      105 	  num = num * 10 + nd - 1;
      106          end;
      107 skipit:
      108       end;
      109       if (mode = " ")
      110       then code = tederror_table_$No_Delim2;
      111       else code = tederror_table_$No_Delim3;
      112       return;
      113 gb2a:
      114       code = 0;
      115       req.nc = req.cc + 1;
      116       last_tab = last_tab - 1;
      117       if (mode = " ")
      118       then call worker;
      119       else call do_global (worker, mode, ted_support_p, msg, code);
      120       if (code = 0)
      121       then do;
      122          current = out.de;		/* tell ted where "." now is	       */
      123          code = tederror_table_$Copy_Set;  /* tell ted to finish up	       */
      124       end;
      125       return;
      126 worker: proc;
      127       
      128          visi, viso = 0;
      129          save_de = out.de;
      130          tabdone = "0"b;
      131          do ic = inp.sb to inp.se;
      132 	  ch = ichr (ic);
      133 	  if (viso >= last_tab)	/* if we're beyond last stop	       */
      134 	  then if (ch = tabchar)	/* ..and its a tab		       */
      135 	  then do;		/* ..just place a SP in its place    */
      136 	     ch = " ";
      137 	     tabdone = "1"b;	/* this switch is necessary because  */
      138 	  end;			/* ..tabchar may be \040	       */
      139 	  if (ichr (ic + 1) = BSP)
      140 	  then do;		/* grab all parts of an overstrike   */
      141 	     ochr (out.de + 1) = ch;
      142 	     out.de = out.de + 1;
      143 	     do while (ichr (ic + 1) = BSP);
      144 	        substr (ostr, out.de + 1, 2) = substr (istr, ic + 1, 2);
      145 	        out.de = out.de + 2;
      146 	        ic = ic + 2;
      147 	     end;
      148 	     visi = visi + 1;	/* input visual		       */
      149 	     viso = viso + 1;	/* ..and output visual go up	       */
      150 	  end;
      151 	  else if (ch = tabchar) & ^tabdone
      152 	  then do;		/* HEY! found a tab		       */
      153 	     SPct = 1;
      154 	     do j = viso to length (tab) - 3   /* look for the next stop   */
      155 	        while (substr (tab, j + 2, 1) = " ");
      156 	        SPct = SPct + 1;
      157 	     end;
      158 	     if (substr (tab, j + 2, 1) = "L") /* if it is a left-set      */
      159 	     then do;		/* ..add the needed space on right   */
      160 	        substr (ostr, out.de + 1, SPct) = " ";
      161 	        out.de = out.de + SPct;
      162 	     end;
      163 	     else do;
      164 	        if (substr (tab, j + 2, 1) = "C") /* if centering,	       */
      165 	        then L = divide (SPct, 2, 24, 0); /* ..use half the space  */
      166 	        else L = SPct;	/* ..otherwise use it all	       */
      167 	        R = SPct - L;	/* then what is left over?	       */
      168 	        hold_leng = out.de - save_de;  /* pull out tabb'ed data    */
      169 	        hold = substr (ostr, save_de + 1, hold_leng);
      170 	        hold_leng = hold_leng + R;  /* reset output length	       */
      171 	        out.de = save_de;
      172 	        substr (ostr, out.de + 1, L) = " ";  /* put in left SPs    */
      173 	        out.de = out.de + L;
      174 	        substr (ostr, out.de + 1, hold_leng) = hold;  /* then put  */
      175 	        out.de = out.de + hold_leng;   /* ..back the data	       */
      176 	     end;
      177 	     if (ch = HT)		/* don't let an HT mess up the       */
      178 	     then visi = visi + (10 - mod (visi, 10));  /* ..visual pos    */
      179 	     else visi = visi + 1;
      180 	     viso = viso + SPct;
      181 	  end;
      182 	  else if (ch = HT)		/* we check for this because the tab */
      183 	  then do;		/* ..may not be an HT, but HT's      */
      184 	     visi = visi + 1;	/* ..cause visual things which are   */
      185 	     viso = viso + 1;	/* ..maintained		       */
      186 	     if (mod (visi, 10) ^= 0)
      187 	     then ic = ic - 1;
      188 	     ochr (out.de + 1) = " ";
      189 	     out.de = out.de + 1;
      190 	  end;
      191 	  else do;		/* just an ordinary character	       */
      192 	     ochr (out.de + 1) = ch;
      193 	     out.de = out.de + 1;
      194 	     visi = visi + 1;
      195 	     viso = viso + 1;
      196 	     if (ch = NL)		/* This "ordinary" character happens */
      197 	     then do;		/* ..to finish up a line	       */
      198 	        visi, viso = 0;
      199 	        tabdone = "0"b;
      200 	        save_de = out.de;
      201 	     end;
      202 	  end;
      203 	  if (substr (tab, viso + 1, 1) ^= " ")	  /* when we pass over     */
      204 	  then save_de = out.de;	/* ..a stop, remember where we are   */
      205          end;
      206 
      207       end worker;
      208 dcl last_tab	fixed bin (24);
      209 dcl tab		char (204);
  1     1 /* BEGIN INCLUDE FILE ..... ted_support.incl.pl1 ..... 03/16/81	       */
  1     2 
  1     3 /* more information may be found in ted_support.gi.info		       */
  1     4 
  1     5 dcl  ted_support_p ptr;
  1     6 dcl ted_support_version_2 fixed bin int static init(2);
  1     7 dcl 1 ted_support based(ted_support_p),
  1     8     2 version fixed bin,	/* 1				       */
  1     9     2 addr_ct fixed bin,	/* number of addresses given: 0,1,2 	  (IN) */
  1    10     2 checkpoint entry (	/* routine to update "safe" status        (IN) */
  1    11 	fixed bin(21),	/* amount of input used up		       */
  1    12 	fixed bin(21)),	/* amount of output used up		       */
  1    13 
  1    14     2 inp,		/***** input string parameters	       */
  1    15 			/* The input data may NOT be modified.	       */
  1    16       3 pt ptr,		/* pointer to base of data string         (IN) */
  1    17       3 sb fixed bin(21),	/* index of addressed string begin        (IN) */
  1    18       3 lno fixed bin(21),	/* linenumber in data string of sb        (IN) */
  1    19       3 se fixed bin(21),	/* index of addressed string end      (IN/OUT) */
  1    20       3 de fixed bin(21),	/* index of data end		  (IN) */
  1    21 
  1    22     2 out,		/***** output string parameters	       */
  1    23       3 pt ptr,		/* pointer to base of output string       (IN) */
  1    24       3 de fixed bin(21),	/* index of data end (already copied) (IN/OUT) */
  1    25       3 ml fixed bin(21),	/* max length of output string	  (IN) */
  1    26 
  1    27     2 req,		/***** request string parameters	       */
  1    28       3 pt ptr,		/* pointer to base of request string	  (IN) */
  1    29       3 cc fixed bin(21),	/* index of current character		  (IN) */
  1    30       3 nc fixed bin(21),	/* index of next character	        (IN/OUT) */
  1    31       3 de fixed bin(21),	/* index of data end	        (IN/OUT) */
  1    32       3 ml fixed bin(21),	/* max length of requsest buffer 	  (IN) */
  1    33 
  1    34 /* req.nc is initialized to req.de, i.e.  request line used-up.  A routine   */
  1    35 /* can set req.nc to 1, put some data into req and set req.de	       */
  1    36 /* appropriately.  The data will be the next ted requests executed after     */
  1    37 /* the routine returns.					       */
  1    38 			
  1    39 /* Or if req.nc is set equal to req.cc then the rest of the request line     */
  1    40 /* will be executed after return.				       */
  1    41 
  1    42     2 string_mode bit(1),	/* 0- line mode, 1- string mode 	  (IN) */
  1    43     2 current fixed bin(21),	/* current location		        (IN/OUT) */
  1    44 			/* current is initialized to "undefined"       */
  1    45     2 get_req entry (),	/* fill the request string with the next line  */
  1    46 			/*  from ted's input stream. req.de will be    */
  1    47 			/*  updated to reflect the new length.	       */
  1    48 			/* req.cc and req.nc are not changed.	       */
  1    49     2 proc_expr entry	/* process the expression for global execution */
  1    50 	(ptr,		/* -> ted_support structure		  [IN] */
  1    51 	char (168) var,	/* message text			 [OUT] */
  1    52 	fixed bin (35)),	/* completion code			 [OUT] */
  1    53     2 do_global entry	/* globally execute some action	       */
  1    54 	(entry (),	/* worker procedure			  [IN] */
  1    55 	char (1),		/* which action, "g" or "v"		  [IN] */
  1    56 	ptr,		/* -> ted_support structure		  [IN] */
  1    57 	char (168) var,	/* message text			 [OUT] */
  1    58 	fixed bin (35)),	/* completion code			 [OUT] */
  1    59     2 reg_exp_p ptr,	/* -> the remembered regular expression area   */
  1    60     2 bcb_p ptr;		/* -> buffer control block		       */
  1    61 /* _________________________________________________________________________ */
  1    62 /*			 ENTRY CONDITIONS			       */
  1    63 /* _________________________________________________________________________ */
  1    64 /* Upon entering, three substructures describe the environment in which the  */
  1    65 /* request is to operate. (Refer to the INPUT diagram) Note that the	       */
  1    66 /* "normal" operational steps are:				       */
  1    67 /* 1) ted copies the string from 1:inp.sb-1 to the output string	       */
  1    68 /* 2) ted_xyz_ takes care of the data from inp.sb:inp.se		       */
  1    69 /* 3) ted copies the string from inp.se+1:inp.de to the output string	       */
  1    70 /* The following 3 diagrams represent conditions upon entering ted_xyz_:     */
  1    71 /* _________________________________________________________________________ */
  1    72 /*	       inp.pt		(\ represents NL)		       */
  1    73 /*		|					       */
  1    74 /* [INPUT]	now is\the time\for all\good men\to come.\.....	       */
  1    75 /*		       |               |                 |	       */
  1    76 /*		    inp.sb          inp.se            inp.de	       */
  1    77 /* _________________________________________________________________________ */
  1    78 /*	       out.pt		(\ represents NL)		       */
  1    79 /*    		|					       */
  1    80 /* [OUTPUT]  ?	now is\........................................	       */
  1    81 /*	   |	      |                                       |	       */
  1    82 /*	current	   out.de				   out.ml	       */
  1    83 /* _________________________________________________________________________ */
  1    84 /*	       req.pt		(\ represents NL)		       */
  1    85 /*    		|					       */
  1    86 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  1    87 /*		          |            |                      |	       */
  1    88 /*		       req.cc       req.de		   req.ml	       */
  1    89 /*				req.nc			       */
  1    90 
  1    91 /* _________________________________________________________________________ */
  1    92 /*			 EXIT CONDITIONS			       */
  1    93 /* _________________________________________________________________________ */
  1    94 /* Assume a request replaces the addressed lines with the string following   */
  1    95 /* it, (in this case "farfle") and leaves "." at the beginning of the range. */
  1    96 /*	       out.pt		(\ represents NL)		       */
  1    97 /*    		|					       */
  1    98 /* [OUTPUT]	now is\farfle\farfle\..........................	       */
  1    99 /*		       |            |                         |	       */
  1   100 /*		   current       out.de		   out.ml	       */
  1   101 /* _________________________________________________________________________ */
  1   102 /* 1) If the data after the string are to be treated as more ted requests,   */
  1   103 /*  the request data would be left like this.			       */
  1   104 /*	       req.pt		(\ represents NL)		       */
  1   105 /*    		|					       */
  1   106 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  1   107 /*		                   |   |                      |	       */
  1   108 /*			    req.nc   req.de		   req.ml	       */
  1   109 /* _________________________________________________________________________ */
  1   110 /* 2) If the request is going to return a string to be executed, the request */
  1   111 /*  data (and buffer) would be left like this:			       */
  1   112 /*	       req.pt		(\ represents NL)		       */
  1   113 /*    		|        					       */
  1   114 /* [REQUEST]	-1,.1p w\ /farfle/ 1,$P\.......................	       */
  1   115 /*		|       |                                     |	       */
  1   116 /*	       req.nc  req.de			   req.ml	       */
  1   117 
  1   118 /* These return codes are expected				       */
  1   119 dcl (tederror_table_$Copy_Set,/* copy rest of input to output,	       */
  1   120 			/*   and set "." from current		       */
  1   121 			/* "rest of input" is the string which begins  */
  1   122 			/*  at char inp.se+1 and extends to inp.de.    */
  1   123 			/*  If the input has all been processed, then  */
  1   124 			/*  inp.se should be set to inp.de+1.	       */
  1   125      tederror_table_$NoChange,/* dont copy, dont set current	       */
  1   126      tederror_table_$Set,	/* dont copy, just set current	       */
  1   127 			/*   (in input buffer)		       */
  1   128      tederror_table_$Error_Msg,/* msg is being returned.		       */
  1   129 			/*  no copy or set is done		       */
  1   130      tederror_table_$No_Delim1,/* missing 1st delimiter		       */
  1   131      tederror_table_$No_Delim2,/* missing 2nd delimiter		       */
  1   132      tederror_table_$No_Delim3)/* missing 3nd delimiter		       */
  1   133 		fixed bin(35)ext static;
  1   134 dcl  error_table_$unimplemented_version fixed bin(35) ext static;
  1   135 
  1   136 dcl  istr char(inp.de) based(inp.pt);	/* the input string		       */
  1   137 dcl  ichr(inp.de) char(1) based(inp.pt);
  1   138 dcl  ostr char(out.ml) based(out.pt);	/* the output string	       */
  1   139 dcl  ochr(out.ml) char(1) based(out.pt);
  1   140 dcl  rstr char(req.ml) based(req.pt);	/* the request string	       */
  1   141 dcl  rchr(req.ml) char(1) based(req.pt);
  1   142 
  1   143 /* These declarations are used if the expression search is needed by the     */
  1   144 /* request. There are 2 parts to getting an expression search done:	       */
  1   145 /* 	1) compiling	2) searching			       */
  1   146 /* If a function uses the remembered expression, it does this:	       */
  1   147 /*	call tedsrch_$search (ted_support.reg_exp_p,		       */
  1   148 /*	  ted_support.bcbp, string_begin, string_end, match_begin,	       */
  1   149 /*	  match_end, search_end, msg, code);			       */
  1   150 
  1   151 /* If a function utilizes an expression the user supplies, it must first be  */
  1   152 /* compiled:
  1   153*/*	if (expression_length > 0)				       */
  1   154 /*	then call tedsrch_$compile (addr (ichr (expression_begin)),	       */
  1   155 /*	  expression_length, ted_support.reg_exp_p,		       */
  1   156 /*	  ted_support.string_mode, ""b, msg, code);		       */
  1   157 /* This results in the remembered expression being changed to the one just   */
  1   158 /* compiled.						       */
  1   159 
  1   160 /* If a function wishes to utilize a function without it being remembered    */
  1   161 /* by ted, it may declare an area of its own and compile into it. It first   */
  1   162 /* must be initialized:					       */
  1   163 /*	dcl expr_area (200) bit (36);				       */
  1   164 /*	call tedsrch_$init_exp (addr (expr_area), size (expr_area));       */
  2     1 /* BEGIN INCLUDE FILE ..... tedsrch_.incl.pl1 ..... 10/21/82 J Falksen */
  2     2 
  2     3 dcl tedsrch_$init_exp entry (		/* initialize an expression area     */
  2     4 		ptr,		/* -> compiled expression area  [IN] */
  2     5 		fixed bin (21));	/*   length of area in words	       */
  2     6 
  2     7 dcl tedsrch_$compile entry (		/* compile a regular expression      */
  2     8 		ptr,		/* -> regular expression to search   */
  2     9 		fixed bin (21),	/*   length thereof 	       */
  2    10 		ptr,		/* -> compiled expression area  [IN] */
  2    11 		bit (1)aligned,	/* 0- line mode	1- string mode   */
  2    12 		bit (1)aligned,	/* 0- reg expr	1- literal expr  */
  2    13 		char (168) var,	/* error message		 [OUT] */
  2    14 		fixed bin (35)	/* error status code	 [OUT] */
  2    15 		);
  2    16 
  2    17 dcl tedsrch_$search entry (		/* search for expression	       */
  2    18 		ptr,		/* -> compiled expression	       */
  2    19 		ptr,		/* -> buffer ctl block for file      */
  2    20 		fixed bin (21),	/* beginning of string to search     */
  2    21 		fixed bin (21),	/* end of string to search	       */
  2    22 		fixed bin (21),	/* beginning of match	       */
  2    23 		fixed bin (21),	/* end of match		       */
  2    24 		fixed bin (21),	/* end of string used for match      */
  2    25 		char (168)var,	/* error message return	 [OUT] */
  2    26 		fixed bin (35)	/* error status code	 [OUT] */
  2    27 		);
  2    28 
  2    29 
  2    30 /* END INCLUDE FILE ..... tedsrch_.incl.pl1 ..... */
  1   165 
  1   166 
  1   167 /* END INCLUDE FILE ..... ted_support.incl.pl1 .....		       */
      210 
      211 
      212 dcl L		fixed bin (24);
      213 dcl R		fixed bin (24);
      214 dcl SPct		fixed bin (24);
      215 dcl ch		char (1);
      216 dcl delim		char (1);
      217 dcl hold		char (200);
      218 dcl hold_leng	fixed bin (24);
      219 dcl ic		fixed bin (24);
      220 dcl j		fixed bin (24);
      221 dcl mode		char (1);
      222 dcl nd		fixed bin (24);
      223 dcl num		fixed bin;
      224 dcl pic3		pic "zz9";
      225 dcl save_de	fixed bin (24);
      226 dcl tabchar	char (1);
      227 dcl tabdone	bit (1);
      228 dcl tabmarks	char (8) int static init ("/,LCRlcr");
      229 dcl tc		char (1);
      230 dcl visi		fixed bin (24);
      231 dcl viso		fixed bin (24);
      232 dcl BSP		char (1) int static init ("");
      233 dcl HT		char (1) int static init ("	");
      234 dcl NL		char (1) int static init ("
      235 ");
      236 
      237    end ted_gtabout_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/23/82  1458.5  ted_tabout_.pl1                   >spec>on>ted_fix>ted_tabout_.pl1
210          1    11/23/82  1324.6  ted_support.incl.pl1              >ldd>include>ted_support.incl.pl1
1-165        2    11/23/82  1324.7  tedsrch_.incl.pl1                 >ldd>include>tedsrch_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BSP                             001015 constant        char(1)                  initial unaligned dcl 232 ref 139 143
HT                                     constant        char(1)                  initial unaligned dcl 233 ref 177 182
L                               000164 automatic       fixed bin(24,0)          dcl 212 set ref 164* 166* 167 172 173
NL                                     constant        char(1)                  initial unaligned dcl 234 ref 196
R                               000165 automatic       fixed bin(24,0)          dcl 213 set ref 167* 170
SPct                            000166 automatic       fixed bin(24,0)          dcl 214 set ref 153* 156* 156 160 161 164 166 167
                                                                                  180
cc                       22            based           fixed bin(21,0)          level 3 dcl 1-7 set ref 45 47* 47 51 52 60* 60 64*
                                                                                  65 87 87* 87 89 91* 91* 115
ch                              000167 automatic       char(1)                  unaligned dcl 215 set ref 132* 133 136* 141 151 177
                                                                                  182 192 196
code                                   parameter       fixed bin(35,0)          dcl 17 set ref 12 20 26* 29* 30 34 41* 76* 102* 109*
                                                                                  111* 113* 119* 120 123*
current                  27            based           fixed bin(21,0)          level 2 dcl 1-7 set ref 122*
de                       13            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" ref 144
de                       16            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" set ref 122 129 141
                                                                                  142* 142 144 145* 145 160 161* 161 168 171* 172
                                                                                  173* 173 174 175* 175 188 189* 189 192 193* 193
                                                                                  200 203
de                       24            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" ref 64
delim                           000170 automatic       char(1)                  unaligned dcl 216 set ref 45* 48 53 89 94
do_global                40            based           entry variable           level 2 dcl 1-7 ref 119
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 1-134 ref 26 41
hold                            000171 automatic       char(200)                unaligned dcl 217 set ref 169* 174
hold_leng                       000253 automatic       fixed bin(24,0)          dcl 218 set ref 168* 169 170* 170 174 175
ic                              000254 automatic       fixed bin(24,0)          dcl 219 set ref 131* 132 139 143 144 146* 146 186*
                                                                                  186*
ichr                                   based           char(1)                  array unaligned dcl 1-137 ref 132 139 143
inp                       6            based           structure                level 2 unaligned dcl 1-7
istr                                   based           char                     unaligned dcl 1-136 ref 144
j                               000255 automatic       fixed bin(24,0)          dcl 220 set ref 52* 53 55* 57 58* 64 154* 154* 158
                                                                                  164
last_tab                        000100 automatic       fixed bin(24,0)          dcl 208 set ref 50* 58* 79* 79 116* 116 133
ml                       17            based           fixed bin(21,0)          level 3 dcl 1-7 ref 144 160 169 172 174
mode                            000256 automatic       char(1)                  unaligned dcl 221 set ref 14* 22* 36* 109 117 119*
msg                                    parameter       varying char(168)        dcl 17 set ref 12 20 29* 34 73* 75* 75 101* 119*
nc                       23            based           fixed bin(21,0)          level 3 dcl 1-7 set ref 115*
nd                              000257 automatic       fixed bin(24,0)          dcl 222 set ref 66* 67 80 80* 80 82 82* 85 98* 99
                                                                                  105
num                             000260 automatic       fixed bin(17,0)          dcl 223 set ref 63* 69 71 79 85 86* 105* 105
ochr                                   based           char(1)                  array unaligned dcl 1-139 set ref 141* 188* 192*
ostr                                   based           char                     unaligned dcl 1-138 set ref 144* 160* 169 172* 174*
out                      14            based           structure                level 2 unaligned dcl 1-7
pic3                            000261 automatic       picture(3)               unaligned dcl 224 set ref 74* 75
proc_expr                34            based           entry variable           level 2 dcl 1-7 ref 29
pt                       14            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" ref 141 144 160 169
                                                                                  172 174 188 192
pt                       20            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" ref 45 51 53 65 87 89
pt                        6            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_gtabout_" ref 132 139 143 144
rchr                                   based           char(1)                  array unaligned dcl 1-141 ref 45 51 53 65 87 89
req                      20            based           structure                level 2 unaligned dcl 1-7
save_de                         000262 automatic       fixed bin(24,0)          dcl 225 set ref 129* 168 169 171 200* 203*
sb                       10            based           fixed bin(21,0)          level 3 dcl 1-7 ref 131
se                       12            based           fixed bin(21,0)          level 3 dcl 1-7 ref 131
tab                             000101 automatic       char(204)                unaligned dcl 209 set ref 49* 55 57* 71 74 85* 154
                                                                                  154 158 164 203
tabchar                         000263 automatic       char(1)                  unaligned dcl 226 set ref 51* 133 151
tabdone                         000264 automatic       bit(1)                   unaligned dcl 227 set ref 130* 137* 151 199*
tabmarks                        000010 internal static char(8)                  initial unaligned dcl 228 set ref 48* 66 85
tc                              000265 automatic       char(1)                  unaligned dcl 229 set ref 65* 66 94 98
ted_support                            based           structure                level 1 unaligned dcl 1-7
ted_support_p                          parameter       pointer                  dcl 1-5 set ref 12 20 23 29 29* 34 38 38 45 45 47 47
                                                                                  51 51 52 53 60 60 64 64 65 65 87 87 87 87 89 89 91
                                                                                  91 115 115 119 119* 122 122 129 131 131 132 139
                                                                                  141 141 142 142 143 144 144 144 144 144 145 145
                                                                                  160 160 160 161 161 168 169 169 171 172 172 172
                                                                                  173 173 174 174 174 175 175 188 188 189 189 192
                                                                                  192 193 193 200 203
ted_support_version_2                  constant        fixed bin(17,0)          initial dcl 1-6 ref 23 38
tederror_table_$Copy_Set        000012 external static fixed bin(35,0)          dcl 1-119 ref 123
tederror_table_$Error_Msg       000014 external static fixed bin(35,0)          dcl 1-119 ref 76 102
tederror_table_$No_Delim2       000016 external static fixed bin(35,0)          dcl 1-119 ref 109
tederror_table_$No_Delim3       000020 external static fixed bin(35,0)          dcl 1-119 ref 111
version                                based           fixed bin(17,0)          level 2 dcl 1-7 ref 23 38 38
visi                            000266 automatic       fixed bin(24,0)          dcl 230 set ref 128* 148* 148 177* 177 177 179* 179
                                                                                  184* 184 186 194* 194 198*
viso                            000267 automatic       fixed bin(24,0)          dcl 231 set ref 128* 133 149* 149 154 180* 180 185*
                                                                                  185 195* 195 198* 203

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
rstr                                   based           char                     unaligned dcl 1-140
tederror_table_$NoChange               external static fixed bin(35,0)          dcl 1-119
tederror_table_$No_Delim1              external static fixed bin(35,0)          dcl 1-119
tederror_table_$Set                    external static fixed bin(35,0)          dcl 1-119
tedsrch_$compile                000000 constant        entry                    external dcl 2-7
tedsrch_$init_exp               000000 constant        entry                    external dcl 2-3
tedsrch_$search                 000000 constant        entry                    external dcl 2-17

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000121 constant        label                    dcl 45 ref 32
gb2a                            000411 constant        label                    dcl 113 set ref 61 92 94
gb2b                            000154 constant        label                    dcl 55
global                          000045 constant        label                    dcl 23 ref 15
skipit                          000371 constant        label                    dcl 107 ref 69
ted_gtabout_                    000024 constant        entry                    external dcl 12
ted_tabout_                     000077 constant        entry                    external dcl 34
ted_vtabout_                    000036 constant        entry                    external dcl 20
worker                          000470 constant        entry                    internal dcl 126 ref 117 119 119

NAMES DECLARED BY CONTEXT OR IMPLICATION.
divide                                                 builtin function         ref 164
index                                                  builtin function         ref 66 98
length                                                 builtin function         ref 55 71 74 154
max                                                    builtin function         ref 79
mod                                                    builtin function         ref 177 186
substr                                                 builtin function         set ref 48 57* 85* 85 144* 144 154 158 160* 164 169
                                                                                  172* 174* 203

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1142        1166    1021        1152
Length      1376    1021        24         173     120           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ted_gtabout_                        214 external procedure  is an external procedure.  
worker                               67 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 tabmarks                    ted_gtabout_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ted_gtabout_             000100 last_tab                    ted_gtabout_
                         000101 tab                         ted_gtabout_
                         000164 L                           ted_gtabout_
                         000165 R                           ted_gtabout_
                         000166 SPct                        ted_gtabout_
                         000167 ch                          ted_gtabout_
                         000170 delim                       ted_gtabout_
                         000171 hold                        ted_gtabout_
                         000253 hold_leng                   ted_gtabout_
                         000254 ic                          ted_gtabout_
                         000255 j                           ted_gtabout_
                         000256 mode                        ted_gtabout_
                         000257 nd                          ted_gtabout_
                         000260 num                         ted_gtabout_
                         000261 pic3                        ted_gtabout_
                         000262 save_de                     ted_gtabout_
                         000263 tabchar                     ted_gtabout_
                         000264 tabdone                     ted_gtabout_
                         000265 tc                          ted_gtabout_
                         000266 visi                        ted_gtabout_
                         000267 viso                        ted_gtabout_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_var            call_int_this       return              mod_fx1             ext_entry           int_entry

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          tederror_table_$Copy_Set      tederror_table_$Error_Msg
tederror_table_$No_Delim2     tederror_table_$No_Delim3




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000020        14 000031        15 000033        20 000034        22 000043        23 000045        26 000052
     27 000055        29 000056        30 000071        32 000074        34 000075        36 000104        38 000106
     41 000115        42 000120        45 000121        47 000131        48 000132        49 000135        50 000140
     51 000141        52 000146        53 000150        55 000154        57 000161        58 000164        59 000165
     60 000170        61 000174        63 000175        64 000176        65 000210        66 000221        67 000233
     69 000234        71 000236        73 000242        74 000250        75 000260        76 000272        77 000274
     79 000275        80 000302        82 000307        85 000314        86 000320        87 000321        89 000326
     91 000333        92 000334        94 000335        96 000340        98 000341        99 000352       101 000353
    102 000361       103 000363       105 000364       107 000371       109 000373       111 000404       112 000410
    113 000411       115 000413       116 000420       117 000422       119 000433       120 000454       122 000457
    123 000463       125 000466       126 000467       128 000475       129 000500       130 000505       131 000506
    132 000516       133 000526       136 000534       137 000536       139 000540       141 000545       142 000552
    143 000553       144 000565       145 000572       146 000574       147 000576       148 000577       149 000600
    150 000601       151 000602       153 000607       154 000611       156 000625       157 000626       158 000630
    160 000636       161 000647       162 000651       164 000652       166 000660       167 000662       168 000665
    169 000673       170 000700       171 000702       172 000704       173 000710       174 000712       175 000717
    177 000720       179 000733       180 000734       181 000736       182 000737       184 000742       185 000743
    186 000744       188 000752       189 000757       190 000760       192 000761       193 000766       194 000767
    195 000770       196 000771       198 000773       199 000775       200 000776       203 001000       205 001011
    207 001013


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
