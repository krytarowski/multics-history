	COMPILATION LISTING OF SEGMENT gcos_write_
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 09/09/83  1147.3 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 gcos_write_: proc (filecode, record, reportcode);
        7 
        8 /*
        9*   *  This  procedure  is  called  to write a record on a gcos file.
       10*   *
       11*   *  The main entry point expects an ASCII string, which will be converted to BCD,
       12*   *  and put into a GCOS standard system format record. Certain  special  ascii
       13*   *  characters are recognized and are converted to printer control information.
       14*   *  Newline characters are converted to  octal  7701  (skip  one  line).  If  n
       15*   *  contiguous  newlines  are  encountered,  then  a control sequence of 77n is
       16*   *  produced (skip n lines). Page characters (octal 014) are converted  to  7720
       17*   *  (skip  to  head of form).   Note that gcos_write_ does not actually do this
       18*   *  conversion, but instead, it is done by a subroutine  (gcos_cv_printline_gebcd_).
       19*   *
       20*   *  A search of the filecode table is made to match the filecode to an existing  fib.  If
       21*   *  no  match  is  found,  a file is opened and a fib is built. This is done by
       22*   *  gcos_open_file_, and gcos_attach_file_. This is only done for those
       23*   *  entry points that use the filecode to specify the file.
       24*   *
       25*   *  Since records are written in GCOS standard format, multiple records are
       26*   *  packed  into  320  word  blocks.  These blocks are written to the specified
       27*   *  files using ios_.
       28*   *
       29*   *  If  the  length  of
       30*   *  the record to be written is 0, an end of file record will be written.  This
       31*   *  is a record with length 0 and the end of file code (170000)  in  the  lower
       32*   *  half  of the record header word (the upper half containing the length).
       33*   *  The buffer is then written out.
       34*   *
       35*   *
       36*   *  ADDITIONAL ENTRY POINTS:
       37*   *
       38*   *  $ptr	-same as main entry, except that the file is specified by a
       39*   *		 fib pointer.
       40*   *
       41*   *  $force	-forces a partially-filled buffer for the specified filecode
       42*   *		 to be written out to the file. An empty buffer is not written out.
       43*   *
       44*   *  $force_ptr	-same as $force, except that the file is specified by a
       45*   *   		 fib pointer.
       46*   *
       47*   *  $bcd	-writes a BCD string onto the given stream, in a GCOS record.
       48*   *
       49*   *  $bcd_ptr	-same as $bcd above, except that the file is specified by
       50*   *		 a fib pointer.
       51*   *
       52*   *  $ascii_ptr	-writes a GCOS record, containing the ASCII characters from the
       53*   *		 input string. Turns on bit 27 (counting from zero) of the rcw,
       54*   *		 if bits 28 and 29 are not both zero, and bit 26 if they are zero,
       55*   *		 thus allowing media codes 5, 6, 7, and 8 to be specified.
       56*   *		 Pads last word with ASCII pad characters (octal 177).
       57*   *		 The file is specified by a pointer to the fib.
       58*   *
       59*   *
       60*   *  The above entries all construct a rcw and place it before the data in the record.
       61*   *
       62*   *
       63*   *
       64*   *  The following entries assume the record already starts with a rcw (or bcw, for $block).
       65*   *
       66*   *  $record	-writes gcos record, complete with rcw, without changing
       67*   *		 anything in it. reportcode is ignored, but must be supplied
       68*   *		 in the call (and should be (8)"0"b).
       69*   *		 record should be char(*), with * being 4 times
       70*   *		 the word length of the record, including the rcw.
       71*   *
       72*   *		 Since the contents of the record and the rcw are not
       73*   *		 examined or changed, but merely copied into the output buffer,
       74*   *		 this entry can be used to write more than one record per call,
       75*   *		 by overlaying the records with a char(*) argument of the
       76*   *		 correct length. This is done by gcos_mme_syot_.
       77*   *
       78*   *
       79*   *  $record_ptr	-same as $record, except that the file is specified
       80*   *		 by a fib pointer.
       81*   *
       82*   *  $print_bcd_card -writes gcos record, supplied as above, but modifies it as follows:
       83*   *		 it assumes it is a bcd card (14 data words in record) and it
       84*   *		 puts octal 7701 (bcd newline) into last word, in "columns" 81-82.
       85*   *		 It puts reportcode into the rcw that it is passed. reportcode
       86*   *		 should begin with "11"b (media code for bcd printlines).
       87*   *		 BCD ! (77) and ? (17) are escaped by preceeding them with 7777.
       88*   *		 All modifications are made to the copy in the write buffer,
       89*   *		 so the copy passed by the caller is preserved.
       90*   *
       91*   *  $print_bcd_ptr -same as $print_bcd_card except that file is specified
       92*   *		 by a pointer to the fib.
       93*   *
       94*   *  $block	-writes a full block (up to 320 words). If there are any records in
       95*   *		 the buffer for the given filecode, that buffer is written out first. The
       96*   *		 length and serial number are put into the bcw, in the caller's copy of the
       97*   *		 block. The block must be passed as a char(*) variable, with * being exactly
       98*   *		 4 times the word length of the block, including the bcw.
       99*   *
      100*   *  $block_ptr	-same as $block, except that the file is specified
      101*   *		 by a fib pointer.
      102*   *
      103*   *	INPUT PARAMETERS:
      104*   *	either:	filecode--filecode of file to be written on.
      105*   *	or:	fib_ptr--pointer to fib of file to be written on
      106*   *		record--record to be written.
      107*   *		reportcode--8 bits used as: media code (2 bits) and report code (6 bits).
      108*   *			(thus the 4 bit ascii media codes are not presently supported -
      109*   *			EXCEPT for the $ascii_ptr, $record and $record_ptr entries.)
      110*   *
      111*   */
      112 
      113 /*
      114*   Author: DICK SNYDER AUGUST 10,1970
      115*   Change: T. CASEY JUNE 1973, NOVEMBER 1973, FEBRUARY 1974, APRIL 1974,  AUGUST 1974
      116*   Change: D. KAYDEN  APRIL 1974, JULY 1974, DECEMBER 1974
      117*   Change: M. R. Jordan, October 1977
      118*   Change: Dave Ward	08/14/81 reorganized. Arrayed form of fibs.
      119**/
      120 
      121 dcl  fib_ptr                  ptr parm;
      122 dcl  filecode                 char(*) parm	/* file code of file to be written */;
      123 dcl  record                   char(*) parm	/* record to be written */;
      124 dcl  reportcode               bit(8) parm	/* record type and report code */;
      125 
      126 /* Come here from all entry points that take filecode (except $force)
      127*   to look up the fib by filecode, and open the file if the fib is not found */
      128 
      129 main: ;
      130 
      131 
      132 /* 	Look for fib to match file code 			 */
      133 
      134 	if look_up_filecode () then return;		/* internal procedure */
      135 
      136 /* Come here from all entries that take a fib pointer (except $force_ptr),
      137*   to provide a buffer if necessary, and write a record on the file, but bypassing
      138*   the the opening of the file if the fib is not found; when a fib pointer is
      139*   specified, the file must be open.		*/
      140 
      141 setbuf: ;
      142 	call setup;
      143 
      144 	if length (record) = 0 then do;
      145 
      146 /*
      147*   Come here if length of record to be written is 0. Write a
      148*   filemark record (000000170000 octal) in the block if the
      149*   device is disk or drum. If tape, write an eof followed by
      150*   a trailer and another eof.
      151**/
      152 	     if ^fib.tape then do;			/* if not a tape */
      153 		buf (fib.rec_len) = "000000170000"b3;	/* put eof mark */
      154 						/* in record header (bits 18-23). */
      155 						/* Rest of header = 0's  */
      156 		fib.rec_len = fib.rec_len + 1;	/* and increment length of record */
      157 	     end;
      158 
      159 	     call write_fib_block;			/* go write the block */
      160 
      161 	     if fib.tape then do;			/* writing on tape? */
      162 
      163 		call ios_$order ((fib.stream), "eof", null, status); /* write eof */
      164 		if code ^= 0 then			/* all errors fatal */
      165 wr_err:		     ;
      166 		call gcos_error_ (code, "^a^/stream=^a", fib.pathnm, fib.stream);
      167 
      168 		trailer.blk_count = block.num -1;	/* put no blocks written in trailer */
      169 		call ios_$write ((fib.stream), addr (trailer), 0, 14, i, status); /* write eof trailer */
      170 		if code ^= 0 then goto wr_err;	/* all errors fatal */
      171 
      172 		call ios_$order ((fib.stream), "eof", null, status); /* write another eof */
      173 		if code ^= 0 then goto wr_err;	/* all errors fatal */
      174 	     end;
      175 
      176 	     return;
      177 	end;
      178 
      179 	lenrec = divide (length (record)+3, 4, 17, 0);
      180 
      181 
      182 /* 	set up for translation of ASCII data to BCD. Subroutine gcos_cv_printline_gebcd_ */
      183 /* 	will translate the message and move it to the buffer. It will also */
      184 /* 	transform newlines and newpages into proper BCD escape codes  */
      185 
      186 	inp = addr (record);			/* get address of input record */
      187 
      188 	if ^acisw then				/* if we don't want an ASCII record */
      189 	     if ^bcdsw then do;			/* and we don't have a BCD record */
      190 
      191 /* if any of the above, copy the input record directly into the buffer,
      192*   omitting the ASCII to BCD translation */
      193 
      194 
      195 /* Since we are here, none of the above was true, so translate to BCD */
      196 
      197 		call gcos_cv_printline_gebcd_ (inp, length (record), addr (temp_buf), i);
      198 		lenrec = divide (i+5, 6, 17, 0);
      199 		inp = addr (temp_buf);		/* get pointer to the BCD string */
      200 	     end;
      201 
      202 print_join: ;
      203 
      204 	if lenrec >= 319 then do;			/* test for long record */
      205 	     code = gcos_et_$record_too_long;
      206 	     goto wr_err;
      207 	end;
      208 
      209 	if fib.rec_len + lenrec >= 319 then call write_fib_block; /* write current block if new rec won't fit */
      210 
      211 	rcwp, outp = addr (buf (fib.rec_len));		/* addr of slot in buffer for this record */
      212 
      213 	if ^gcossw then outp = addrel (outp, 1);	/* leave room for rcw, unless its there already */
      214 
      215 	outstring = instring;			/* copy record into buffer */
      216 
      217 	if gcossw then do;				/* if we have a gcos record, with rcw already in it */
      218 
      219 	     lenrec = lenrec - 1;			/* don't count the rcw in the length */
      220 
      221 /* INCODE PROCESSING:
      222*
      223*   All BCD card images (which may have been originally created by reading cards punched
      224*   in other than GEBCD card codes) are written onto files by calls to gcos_write_$record.
      225*
      226*   That entry turns on gcossw. Therefore, if gcossw is on
      227*   and the media code is "10" (BCD card) and gcos_ext_stat_$incode is nonzero,
      228*   we want to go through the record we just put into the buffer, looking for any of the
      229*   six characters that can be different, and translate them into the proper GEBCD codes. */
      230 
      231 	     if gcos_ext_stat_$incode ^= 0 then		/* If incode translation is in effect */
      232 		if rcw.media_code = "0010"b then	/* and we have a BCD card */
      233 		     call gcos_incode_ (addrel (inp, 1), lenrec * 6, addrel (outp, 1));
      234 
      235 	end;
      236 
      237 	else do;
      238 
      239 /* Create record header (rcw) consisting of length and record type and reportcode */
      240 
      241 	     rcwp -> word = "0"b;			/* clear out the rcw */
      242 	     rcw.length = lenrec;			/* fill in record length */
      243 
      244 	     substr (rcwp -> word, 29, 8) = reportcode;	/* fill in media and report codes */
      245 
      246 	     if acisw then do;			/* if $ascii entry, fix up several parts of the record */
      247 
      248 		if rcw.media_code = "0"b then		/* if we want ascii media code 8 */
      249 		     substr (rcw.media_code, 1, 1) = "1"b; /* make it 8 ("1000"b) */
      250 		else substr (rcw.media_code, 2, 1) = "1"b; /* else make it 5, 6, or 7 ("01xx"b) */
      251 
      252 		acipad = mod (length (record), 4);	/* see if they partially fill the last word */
      253 
      254 		if acipad > 0 then			/* if last word is only partially filled */
      255 		     substr (outp -> acistring, length (record)+1, 4-acipad) = substr (pads, 1, 4-acipad);
      256 						/* fill rest of it with pad (177) chars */
      257 	     end;
      258 	end;
      259 
      260 	fib.rec_len = fib.rec_len+lenrec+1;		/* compute new length of block */
      261 	return;
      262 
      263 print_bcd_card: entry (filecode, record, reportcode);
      264 
      265 /* print bcd card image. 7701 is appended to card, and rcw is modified using reportcode argument */
      266 
      267 	goto print_common;
      268 
      269 print_bcd_ptr: entry (fib_ptr, record, reportcode);
      270 
      271 /* print bcd card image, but with fib pointer argument */
      272 
      273 	fibptr = fib_ptr;
      274 print_common: ;
      275 	call setup;
      276 
      277 /* EDITP PROCESSING
      278*
      279*   The following code searches the record just written for the BCD characters
      280*   ! (77) and ? (17), which have special meaning for printed output. In order
      281*   to be taken literally and just printed, they must be preceeded by the BCD
      282*   escape sequence, which is two !'s (7777). Since this procedure is called to
      283*   write all sorts of records on gcos files, some of which will later be printed,
      284*   and some of which will be read by gcos slave programs, and the escapes are
      285*   only proper in print files, this code is only entered when the $print_bcd_card
      286*   entry was used.
      287*
      288*   */
      289 
      290 	inp = addrel (addr (record), 1);
      291 	outp = addr (temp_buf);
      292 	j = 0;
      293 	do i = 1 to 80;
      294 
      295 	     if bcd.char = "17"b3 |			/* 17 = "?" */
      296 	     bcd.char = "77"b3 then do;		/* 77 = "!" */
      297 		bcd2.chars = "7777"b3 ;		/* 7777 = "!!" */
      298 		outp = addr (bcd2.next);
      299 		j = j + 2;
      300 	     end;
      301 	     outp -> bcd.char = bcd.char;
      302 	     inp = addr (bcd.next);
      303 	     outp = addr (outp -> bcd.next);
      304 	     j = j + 1;
      305 	end;
      306 	bcd2.chars = "7701"b3 ;			/* 7701 = "!1" (bcd newline) */
      307 
      308 	inp = addr (temp_buf);
      309 	lenrec = divide (j+7, 6, 17, 0);
      310 	goto print_join;
      311 
      312 record_ptr: entry (fib_ptr, record, reportcode);
      313 
      314 /* write gcos record (as for $record entry) but with fib pointer arg */
      315 
      316 	gcossw = "1"b;				/* full gcos record, rcw included */
      317 						/* fall thru to turn on bcdsw */
      318 
      319 /* 	Enter here to write a string which is already in bcd and which	 */
      320 /* 	already has newlines and newpages translated to their bcd equivalents */
      321 
      322 
      323 bcd_ptr:	entry (fib_ptr, record, reportcode);
      324 
      325 	bcdsw = "1"b;				/* indicate that input is in BCD */
      326 
      327 ptr:	entry (fib_ptr, record, reportcode);
      328 
      329 /* do the same as the primary entry, given a fib pointer */
      330 
      331 /* Come here from $ascii_ptr entry */
      332 ptr_common: ;
      333 	fibptr = fib_ptr;
      334 
      335 	goto setbuf;
      336 
      337 ascii_ptr: entry (fib_ptr, record, reportcode);
      338 
      339 /* write a record containing the ascii input string, untranslated */
      340 
      341 	acisw = "1"b;				/* remember we entered here */
      342 
      343 	goto ptr_common;				/* go set fib pointer */
      344 
      345 record:	entry (filecode, record, reportcode);
      346 
      347 /* write gcos record with no alteration at all. rcw is included in length of char(*) argument */
      348 
      349 	gcossw = "1"b;				/* we have a full gcos record, rcw included */
      350 
      351 bcd:	entry (filecode, record, reportcode);
      352 
      353 /* write block of bcd words, and build rcw, but look up fib by filecode */
      354 
      355 	bcdsw = "1"b;				/* input is bcd characters */
      356 
      357 	goto main;				/* go look up filecoe and join main body of program */
      358 
      359 block:	entry (filecode, record);
      360 
      361 /* write complete 320 word block */
      362 
      363 	if look_up_filecode () then return;
      364 
      365 writing_block: ;
      366 	call setup;
      367 	if fib.rec_len > 0 then			/* if there is anything in the buffer */
      368 	     call write_fib_block;			/* go write it out first */
      369 
      370 	blockptr = addr (record);
      371 	blockptr -> block.num = block.num;		/* copy current bsn into bcw of block to be written */
      372 
      373 /* Compute word length of block and put it where write_block expects to find it. */
      374 
      375 	fib.rec_len = blockptr -> block.length;
      376 
      377 	call write_block;				/* go write the block */
      378 
      379 	return;					/* that's all */
      380 
      381 block_ptr: entry (fib_ptr, record);
      382 
      383 /* write complete 320 word block, but with fib pointer arg
      384**/
      385 
      386 	fibptr = fib_ptr;
      387 	goto writing_block;
      388 
      389 
      390 /* 	Enter here to force out buffer for file specified in filecode.	 */
      391 /* 	Do not force if buffer is null or rec_len = 0 which		 */
      392 /* 	indicates that buffer was just written out.		 */
      393 
      394 force:	entry (filecode);
      395 
      396 	if look_up_filecode () then return;
      397 
      398 
      399 	goto force_common;
      400 
      401 force_ptr: entry (fib_ptr);
      402 
      403 /* 	Enter here to force out buffer for file associated with the	 */
      404 /* fib pointed to by fibptr. */
      405 
      406 	fibptr = fib_ptr;
      407 
      408 force_common: ;
      409 	if fib.buffer ^= null then			/* and there is a buffer */
      410 	     if fib.rec_len ^= 0 then			/* and it is not empty */
      411 		call write_fib_block;		/* write it out */
      412 
      413 	return;
      414 
      415 look_up_filecode: proc () returns (bit (1));
      416 
      417 /* look up a fib by filecode
      418*   Return "1"b if file not to be written.
      419**/
      420 
      421 	     do i = 1 to hbound (save_data.fibs, 1);
      422 		if fct.filecode (i) = filecode then do;
      423 		     if fct.sysout (i) then return ("1"b);
      424 		     fibptr = fct.fibptr (i);		/* get pointer to fib */
      425 		     if ^fib.gein then return ("1"b);	/* protect user files from simulator */
      426 		     return ("0"b);
      427 		end;
      428 	     end;
      429 
      430 /* 	No fib found. Create one and a file to match 	 */
      431 	     call gcos_open_file_ (filecode, "", fibptr, sw); /* initialize a fib for the specified filecode */
      432 	     fib.gein = "1"b;			/* file for slave use - a gein file */
      433 	     return ("0"b);
      434 	end look_up_filecode;
      435 
      436 setup:	proc;
      437 
      438 /* allocate a working buffer if necessary */
      439 	     if fib.buffer = null then do;		/* buffer provided yet? */
      440 		k = index (string (fib_buffers.buffer_in_use), "0"b);
      441 		if k = 0 then do;
      442 		     call gcos_error_ (		/* No buffers available. */
      443 			0
      444 			, "Exceeded ^i file buffers provided."
      445 			, hbound (fib_buffers.buffer_in_use, 1)
      446 			);
      447 		     return;
      448 		end;
      449 		fib_buffers.buffer_in_use (k) = "1"b;	/* Mark buffer in use. */
      450 		fib.buffer_indx = k;
      451 		fib.buffer = addr (fib_buffers.buffer (k));
      452 
      453 		fib.rec_len = 0;			/* block length */
      454 		block.num = divide (fib.current, 320, 17, 0) + 1; /* set block serial number */
      455 		if ^fib.attached then call gcos_attach_file_ (fibptr);
      456 
      457 	     end;
      458 	     return;
      459 	end setup;
      460 
      461 write_fib_block: proc;
      462 
      463 /* write a block onto the file */
      464 	     blockptr = fib.buffer;			/* pointer to the block to be written */
      465 	     blockptr -> block.length = fib.rec_len;	/* put length into bcw */
      466 
      467 write_block:   entry;
      468 
      469 /* entry with blockptr already set. */
      470 
      471 	     if fib.tape then write_count = fib.rec_len + 1; /* write only used words in block on tape */
      472 	     else write_count = 320;			/* write max words per block to disk */
      473 	     fib.rec_len = 0;			/* reset block length */
      474 
      475 	     call ios_$write ((fib.stream), blockptr, 0, write_count, i, status); /* write record */
      476 
      477 	     if code ^= 0 then goto wr_err;		/* fatal write error */
      478 
      479 /* 	Bump serial number in buffer header (bits 1-17) by one	 */
      480 
      481 	     block.num = block.num + 1;
      482 
      483 	     fib.current = fib.current + write_count;	/* bump curr rec no */
      484 	     if fib.current > fib.size then		/* grow file size if necessary */
      485 		fib.size = fib.size + 3840;		/* grow file one link */
      486 
      487 	     return;				/* return from internal procedure */
      488 
      489 	end write_fib_block;
      490 
      491 /*   Variables for gcos_write_:		 */
      492 /*   IDENTIFIER		ATTRIBUTES	 */
      493 dcl  acipad                   fixed bin(24)	/* number of pad chars needed to finish ascii rec */;
      494 dcl  acistring                char(1044480) based;
      495 dcl  acisw                    bit(1)init("0"b)	/* => $ascii entry. */;
      496 dcl  addr                     builtin;
      497 dcl  addrel                   builtin;
      498 dcl  bcdsw                    bit(1)init("0"b)	/* => $bcd entry. */;
      499 dcl  blockptr                 ptr;
      500 dcl  divide                   builtin;
      501 dcl  gcossw                   bit(1)init("0"b)	/* => $record entry. */;
      502 dcl  gcos_attach_file_        ext entry (pointer);
      503 dcl  gcos_cv_printline_gebcd_ ext entry (ptr, fixed bin(21), ptr, fixed bin(21));
      504 dcl  gcos_error_              ext entry options (variable);
      505 dcl  gcos_et_$record_too_long fixed bin(35) ext;
      506 dcl  gcos_incode_             ext entry (ptr, fixed bin(24), ptr);
      507 dcl  gcos_open_file_          ext entry (char(*), char(*), pointer, bit(1));
      508 dcl  i                        fixed bin(21);
      509 dcl  index                    builtin;
      510 dcl  inp                      ptr;
      511 dcl  instring                 (lenrec) fixed bin(24)based (inp)	/* input string */;
      512 dcl  j                        fixed bin(24);
      513 dcl  k                        fixed bin;
      514 dcl  length                   builtin;
      515 dcl  lenrec                   fixed bin(17)	/* length in words of record  */;
      516 dcl  mod                      builtin;
      517 dcl  null                     builtin;
      518 dcl  outp                     ptr;
      519 dcl  outstring                (lenrec) fixed bin(24)based (outp)	/* output string */;
      520 dcl  pads                     char(4) int static init("")	/* four ASCII pad (177) chars */;
      521 dcl  putp                     ptr;
      522 dcl  rcwp                     ptr;
      523 dcl  substr                   builtin;
      524 dcl  sw                       bit(1)	/* switch used in open call */;
      525 dcl  temp_buf                 (350) fixed bin(24);
      526 dcl  word                     bit(36) aligned based;
      527 dcl  write_count              fixed bin(21)	/* no of words to write */;	;
      528 
      529 dcl 1 block	aligned based (fib.buffer),		/* overlay for buffer */
      530       2 num	fixed bin(18)unsigned unaligned,	/* block number */
      531       2 length	fixed bin(18)unsigned unaligned,	/* block length */
      532       2 buf	(0:318) bit(36)			/* remainder of block */
      533 ;
      534 
      535 dcl 1 trailer	int static			/* model of eof trailer */
      536 ,     2 eoftrailer	bit(36) init( "202546262020"b3 )	/* bEOFbb */
      537 ,     2 blk_count	fixed bin(24) init(0)		/* block count for file */
      538 ,     2 junk	(12)bit(36) init((12)(1)"0"b)		/* remainder of label record. */
      539 ;
      540 
      541 dcl 1 rcw		aligned based (rcwp),
      542       2 length	fixed bin(18)unsigned unaligned,			/* record length */
      543       2 eof	bit(6) unaligned,
      544       2 zeros	bit(2) unaligned,
      545       2 media_code	bit(4) unaligned,
      546       2 report_code	bit(6) unaligned;
      547 
      548 dcl 1 bcd		unaligned based (inp),
      549       2 char	bit(6) unaligned,
      550       2 next	bit(6) unaligned;
      551 
      552 dcl 1 bcd2	unaligned based (outp),
      553       2 chars	bit(12) unaligned,
      554       2 next	bit(6) unaligned;
      555 
  1     1 /* BEGIN INCLUDE FILE gcos_fibs.incl.pl1   (Wardd Multics)  09/13/81 1739.2 mst Sun */
  1     2 dcl 1 fibs_control		aligned based(gcos_ext_stat_$temp_seg_ptr)
  1     3 
  1     4 /* Structure to save released fibs in.
  1     5**/
  1     6 ,     2 released_fibs
  1     7 ,       3 nrf		fixed bin		/* Number of released fibs. */
  1     8 ,       3 released_fib	(500) like fib	/* Copy of released fib. */
  1     9 
  1    10 /* Buffers. */
  1    11 ,     2 fib_buffers
  1    12 ,       3 buffer_in_use	(500)bit(1)unal	/* "1"b => in use. */
  1    13 ,       3 buffer		(500)bit(320*36)	/* Space for buffer. */
  1    14 ;
  1    15 
  1    16 /*   END INCLUDE FILE gcos_fibs.incl.pl1 */
      556 
      557 
  2     1 /* BEGIN INCLUDE FILE gcos_ext_stat_.incl.pl1  */
  2     2 /*
  2     3*  Changes to gcos_ext_stat_ must be made here AND gcos_ext_stat_.cds
  2     4**/
  2     5 /* July 77 (MRJ) Mike Jordan. */
  2     6 /* Change: Mel Wilson Oct 1979 for gtss compatibility (Bell Canada). */
  2     7 /* Change: A. N. Kepner, March, 1978 to allow courtesy call i/o  within cc routines. */
  2     8 /* Change: Dave Ward 06/01/81 Reorganized to eliminate alm object (using cds). Use of like structures. */
  2     9 /* Change: Scott C. Akers 01/26/82 Add tape_buffer_size for GEINOS processing. */
  2    10 /* Change: Ron Barstad  83-08-02  Added activity_card_num for execution report */
  2    11 /*                                Increased size of statistics for 4js3 MMEs  */
  2    12 
  2    13 dcl  gcos_ext_stat_$abort_reason char(128) varying 	/* abort reason from gcos pgm */  ext;
  2    14 dcl  gcos_ext_stat_$abort_return label	/* abort return point */  ext;
  2    15 dcl  gcos_ext_stat_$activity_card_num pic "9999" ext;	/* card number defining current activity */
  2    16 dcl  gcos_ext_stat_$activity_name char(8) 	/* name of activity to be run */  ext;
  2    17 dcl  gcos_ext_stat_$activity_start_time fixed bin(71) 	/* TOD start of activity */  ext;
  2    18 dcl  gcos_ext_stat_$card_num  pic "9999"	/* ordinal number of card in input stream */  ext;
  2    19 dcl  gcos_ext_stat_$dbs       (36)bit(1)	/* Debugging switch. */  ext;
  2    20 dcl  gcos_ext_stat_$default_nondollar char(2) 	/* filecode where nondollar cards go by default */  ext;
  2    21 dcl  gcos_ext_stat_$dir_rings (3) fixed bin(3)	/* ring brackets for created catalogs */  ext;
  2    22 dcl  gcos_ext_stat_$dpno      char(100) varying 	/* arguments for call to dpunch */  ext;
  2    23 dcl  gcos_ext_stat_$dpo       char(100) varying 	/* arguments for call to dprint */  ext;
  2    24 dcl  gcos_ext_stat_$endfc     char(2) 	/* endfc value for endcopy processing */  ext;
  2    25 dcl  gcos_ext_stat_$er        ptr	/* fib pointer for *er */  ext;
  2    26 dcl  gcos_ext_stat_$etc_filecode char(2) 	/* filecode where $ ETC cards should be written */  ext;
  2    27 dcl  gcos_ext_stat_$gcos_slave_area_seg ptr	/* pointer to gcos slave area segment */  ext;
  2    28 dcl  gcos_ext_stat_$gf        fixed bin(24)/* sw used by getfield rtn */  ext;
  2    29 dcl  gcos_ext_stat_$incode    fixed bin(24)	/* switches to control incode processing */  ext;
  2    30 dcl  gcos_ext_stat_$increment_hold fixed bin(24)	/* Holds increment for courtesy call returns. */  ext;
  2    31 dcl  gcos_ext_stat_$initial_cpu_time fixed bin(71) 	/* vcu time at activity start */  ext;
  2    32 dcl  gcos_ext_stat_$input_segment_path char(168) varying 	/* pathname of input segment */  ext;
  2    33 dcl  gcos_ext_stat_$jcl_warnings fixed bin(24)	/* number warnings issued processing control cards */  ext;
  2    34 dcl  gcos_ext_stat_$job_cpu_time fixed bin(71)	/* cpu usage at job start */  ext;
  2    35 dcl  gcos_ext_stat_$job_id    char(18) varying 	/* unique job id for file naming */  ext;
  2    36 dcl  gcos_ext_stat_$job_real_time fixed bin(71)	/* job start time in microseconds */  ext;
  2    37 dcl  gcos_ext_stat_$last_mme  fixed bin(24)/* number of last mme executed */  ext;
  2    38 dcl  gcos_ext_stat_$ldrss     fixed bin(24)	/* loader shared stg. */  ext;
  2    39 dcl  gcos_ext_stat_$max_activities fixed bin(24)/* max activities in a job */  ext;
  2    40 dcl  gcos_ext_stat_$max_mem   fixed bin(19) 	/* maximum memory available to an activity */  ext;
  2    41 dcl  gcos_ext_stat_$mme_rtrn  label	/* where to return at activity end */  ext;
  2    42 dcl  gcos_ext_stat_$nondollar char(2)	/* non-dollar card file code */  ext;
  2    43 dcl  gcos_ext_stat_$nongcos   char(2) 	/* filecode where nongcos dollar cards go */  ext;
  2    44 dcl  gcos_ext_stat_$normal_return label	/* nonlocal goto for normal termination */  ext;
  2    45 dcl  gcos_ext_stat_$patchfile_ptr ptr	/* pointer to patchfile */  ext;
  2    46 dcl  gcos_ext_stat_$pathname_prefix char(168)var ext;
  2    47 dcl  gcos_ext_stat_$pch       ptr	/* pointer to fib for syspunch collector file */  ext;
  2    48 dcl  gcos_ext_stat_$pdir      char(168) varying 	/* pathname of process directory */  ext;
  2    49 dcl  gcos_ext_stat_$prt       ptr	/* pointer to fib for sysprint collector file */  ext;
  2    50 dcl  gcos_ext_stat_$rs        ptr	/* pointer to fib for geload r* collector file */  ext;
  2    51 dcl  gcos_ext_stat_$saveseg_ptr ptr 	/* pointer to save segment used by save/restart */  ext;
  2    52 dcl  gcos_ext_stat_$save_dir  char(168) varying 	/* pathname of temp save directory */  ext;
  2    53 dcl  gcos_ext_stat_$seg_rings (3) fixed bin(3)	/* ring brackets for created files */  ext;
  2    54 dcl  gcos_ext_stat_$sig_ptr   ptr	/* saved pointer to signal_ */  ext;
  2    55 dcl  gcos_ext_stat_$skip_umc  bit(1)  ext;
  2    56 dcl  gcos_ext_stat_$snumb     bit (30) aligned 	/* snumb of the current job */  ext;
  2    57 dcl  gcos_ext_stat_$sought_label char(8) 	/* Label from GOTO, IF, or WHEN card */  ext;
  2    58 dcl  gcos_ext_stat_$statistics (3*44) fixed bin(24)	/* mme usage statistics- 3 per mme */  ext;
  2    59 dcl  gcos_ext_stat_$stop_code fixed bin(24)	/* debugging, print results and stop. */  ext;
  2    60 dcl  gcos_ext_stat_$storage_limit fixed bin(19) 	/* activity storage limit */  ext;
  2    61 dcl  gcos_ext_stat_$sysout_limit fixed bin(35) 	/* sysout line limit */  ext;
  2    62 dcl  gcos_ext_stat_$sysout_lines fixed bin(35)	/* sysout lines used */  ext;
  2    63 dcl  gcos_ext_stat_$system_free_pointer ptr 	/* pointer to area for allocating in  ext; set by gcos */  ext;
  2    64 dcl  gcos_ext_stat_$tape_buffer_size fixed bin(35) external static;	/* tape buffer size for GEINOS. */
  2    65 dcl  gcos_ext_stat_$temp_dir  char(168) varying 	/* pathname of directory to hold temp files */  ext;
  2    66 dcl  gcos_ext_stat_$temp_seg_ptr ptr ext;
  2    67 dcl  gcos_ext_stat_$termination_code bit (18) 	/* termination code from gcos_mme_bort_ */  ext;
  2    68 dcl  gcos_ext_stat_$time_limit fixed bin(71) 	/* activity time limit */  ext;
  2    69 dcl  gcos_ext_stat_$userid    char(12) 	/* the USERID */  ext;
  2    70 dcl  gcos_ext_stat_$validation_level fixed bin(3)	/* current ring of execution */  ext;
  2    71 
  2    72 /*	Courtesy Call Queue
  2    73*   A queue for courtesy call addresses which must be saved during
  2    74*   execution of courtesy call routines. A courtesy call address is
  2    75*   saved each time a MME GEROUT or MME GEINOS, which specifies a
  2    76*   courtesy call, is executed within a courtesy call routine. Each
  2    77*   time a MME GEENDC is executed a courtesy call address will be
  2    78*   removed from this FIFO queue and the corresponding courtesy call
  2    79*   routine executed until the queue is empty. The FIFO "queue" is
  2    80*   implemented in a circular fashion. "next_avail" points to the
  2    81*   next empty location in the queue. "next_out" points to the
  2    82*   entry in the queue which has been in the queue longest. When
  2    83*   entering or removing entries from the queue the appropriate index
  2    84*   is incremented modulo the length of the queue. By convention the
  2    85*   queue is empty when "next_avail" equals "next_out". A
  2    86*   second convention is that the queue is considered to overflow
  2    87*   during an attempt to add an entry to the queue which would force
  2    88*   "next_avail" to "catch up" with "next_out". This means that
  2    89*   the last empty position in the queue will never be used.
  2    90**/
  2    91 
  2    92 dcl 1 gcos_ext_stat_$courtesy_call_control aligned ext
  2    93 ,     3 courtesy_call
  2    94 ,       4 hold             like save_machine_conditions	/* Mach. conds. restored on courtesy call returns. */
  2    95 ,       4 next_avail       fixed bin(24)		/* next available empty location in cc_queue. */
  2    96 ,       4 next_out         fixed bin(24)		/* next entry to remove from cc_queue. */
  2    97 ,       4 queue            (6) fixed bin(24)
  2    98 ;
  2    99 
  3     1 /* BEGIN INCLUDE FILE gcos_save_mc.incl.pl1   (Wardd Multics)  09/12/81 0905.9 mst Sat */
  3     2 
  3     3 /* Structure to isolate the definition of the size of the
  3     4*space needed to store he machine conditions structure (mc).
  3     5**/
  3     6 dcl 1 save_machine_conditions based
  3     7 ,     3 save_space		bit(1728)
  3     8 ;
  3     9 
  3    10 /*   END INCLUDE FILE gcos_save_mc.incl.pl1 */
  2   100 
  2   101 
  2   102 dcl 1 gcos_ext_stat_$fct	aligned ext,
  2   103       3 fct		(40) like fct_entry;
  4     1 /* BEGIN INCLUDE FILE gcos_fct_entry.incl.pl1   (Wardd Multics)  05/30/81 1758.6 mst Sat */
  4     2 
  4     3 dcl 1 fct_entry	aligned based,
  4     4       2 filecode	char(2) aligned,			/* file code (or blank) */
  4     5 						/* flags */
  4     6       2 sysout	bit(1) unaligned,			/* 1=file is sysout or dac */
  4     7       2 dac	bit(1) unaligned,			/* 1=file is dac,0=file is sysout */
  4     8       2 pad	bit(34) unaligned,			/* unused */
  4     9       2 fibptr	ptr aligned			/*	ptr to fib for this file */
  4    10 ;
  4    11 
  4    12 /*   END INCLUDE FILE gcos_fct_entry.incl.pl1 */
  2   104 
  2   105 
  2   106 dcl 1 gcos_ext_stat_$save_data aligned ext,
  2   107       3 save_data like save_data_entry;
  5     1 /* BEGIN INCLUDE FILE gcos_save_data_entry.incl.pl1   (Wardd Multics)  07/01/81 1339.9 mst Wed */
  5     2 /* Change: Dave Ward	07/01/81 include gcos_flags_. */
  5     3 /* Change: Dave Ward	09/10/81 fib changed to fibs & likened to fib. */
  5     4 
  5     5 dcl 1 save_data_entry  aligned based
  5     6 ,3 flgs                like flags	/* system wide flgs */
  5     7 ,3 actid               char(8)	/* activity no. and accnt i.d. */
  5     8 ,3 short_actid         bit(36) aligned	/* short form of activity id */
  5     9 ,3 ident               char(60)	/* holds ident info from snumb card */
  5    10 ,3 psw                 bit(36) aligned	/* program switch word */
  5    11 ,3 last_execute_act_no fixed bin(24)/* activity number of last $ EXECUTE card in job */
  5    12 ,3 activity_no         fixed bin(24)/* activity number */
  5    13 ,3 job_time_limit      fixed bin(71)	/* job time limit */
  5    14 ,3 job_sysout_limit    fixed bin(24)/* job sysout line limit */
  5    15 ,3 sysout_queue        (10) char(32)	/* sysout queue */
  5    16 ,3 sysout_queue_media  (10) fixed bin(24)/* medium (print,punch) of each file on queue */
  5    17 ,3 sqindex             fixed bin(24)/* curr offset in sysout queue */
  5    18 ,3 pathname_prefix     char(168)varying 	/* prefix for gcos cfdescs */
  5    19 ,3 skip_umc            aligned bit(1) 	/* flag to tell if we should skip umc names */
  5    20 ,3 job_deck            pointer	/* pointer to seg holding canonicalized job deck */
  5    21 ,3 jd_size             fixed bin(24)/* size in words of job deck */
  5    22 ,3 jd_position         fixed bin(24)	/* position of current block of job deck */
  5    23 ,3 jd_rem_block_len    fixed bin(24)/* words remaining in current block of job deck */
  5    24 ,3 syot_dir            char(168)varying	/* pathname of directory to hold sysout files */
  5    25 ,3 fibs		   (40) like fib
  5    26 ,3 param               (32) char(57)varying	/* parameters */
  5    27 ;
  5    28 
  6     1 /* BEGIN INCLUDE FILE gcos_flags.incl.pl1   (Wardd Multics)  07/01/81 1344.7 mst Wed */
  6     2 /* Change: Mel Wilson	03/01/79 to add gtssflag & identflag */
  6     3 /* Change: Dave Ward	07/01/81 revised, mad apart of gcos_ext_stat_. */
  6     4 
  6     5 
  6     6 /* 	Declaration of Simulator Wide Flags	 */
  6     7 
  6     8 dcl 1 flags aligned based,
  6     9       2 (
  6    10 	pad1,	/* no longer used */
  6    11 	copy,	/* 1=copy option on|0=off */
  6    12 	snumb,	/* 1=snumb card read|0=not */
  6    13 	ident,	/* 1=ident card read|0=not */
  6    14 	activ,	/* 1=activity being defined|0=not */
  6    15 	cc,	/* 1=courtesy call active|0=not */
  6    16 	pad2,	/* no longer used */
  6    17 	cksum,	/* 1=don't check checksums|0=do */
  6    18 	pad3,	/* no longer used */
  6    19 	wrapup,	/* 1=processing wrapup after abort */
  6    20 
  6    21 /* FOLLOWING ADDED AFTER MARCH 73 */
  6    22 
  6    23 	nosave,	/* 1=disable save/restart function,0=not */
  6    24 	pad4,	/* no longer used */
  6    25 	gcos,	/* 1=job deck segment in gcos file format */
  6    26 	raw,	/* 1=sysout punch files to be converted to raw bit strings */
  6    27 	list,	/* 1=sysout print files to be converted to ascii */
  6    28 	brief,	/* 1=print nothing but fatal error messages on terminal */
  6    29 	debug,	/* 1=give option to call debug before aborting */
  6    30 	no_canonicalize,	/* 1=do NOT canonicalize job deck */
  6    31 
  6    32 /* 18 bits into first word */
  6    33 
  6    34 	pad5,	/* no longer used */
  6    35 	dpunch,	/* 1=dpunch sysout punch files;0=don't */
  6    36 	dprint,	/* 1=dprint sysout print files,0=don't */
  6    37 	userid,	/* 1=userid card read,0=not */
  6    38 	userlib,	/* 1= -userlib ctl arg given, see gcos_gein_ */
  6    39 	dstar,	/* 1=current activity card written on d* */
  6    40 	write_etc,	/* 1 tells get_cc_field to write $ ETC cards on etc_filecode */
  6    41 	prev_act_abort,	/* turned on by abort and off by $ BREAK */
  6    42 	this_act_abort,	/* turned on by abort to select abort disp codes */
  6    43 	abort_subact,	/* 1=processing abort subactivity */
  6    44 	dump,	/* 1=dump option given on activity card */
  6    45 	nondollar,	/* 1=reading nondollar card deck in gein */
  6    46 	endjob,	/* 1=cc_endjob already called once in this job */
  6    47 	abort_card,	/* 1=the terminator for this activity was a $ ABORT card */
  6    48 	truncate,	/* 1=truncate option given:truncate long ascii input lines */
  6    49 	continue,	/* 1=continue option given:continue after nonfatal errors */
  6    50 	rout,	/* 1=gcos_mme_rout_ was called in this activity */
  6    51 	seeking,	/* 1=gein is looking for a label and/or terminator */
  6    52 
  6    53 /* end of first word */
  6    54 
  6    55 	seeking_terminator,	/* 1=gein is looking for a terminator */
  6    56 	lower_case,	/* 1=lower case print conversion wanted */
  6    57 	no_bar,	/* 1=do not run slave program in BAR mode */
  6    58 	long,	/* 1=print some lines from execution reort on terminal */
  6    59 	endfc,	/* 1=process endfc option on endcopy card */
  6    60 	gtssflag,	/* 1=update gtss_user_state_ during execution */
  6    61 	identflag,	/* 1= use $ident banner info for print & punch */
  6    62 	spawnflag,	/* 1= entry due to tss spawn */
  6    63 	taskflag	/* 1= entry due to tss drl task */
  6    64 		) bit(1) unal,
  6    65       2	pad6	  bit(27)unal
  6    66 ;
  6    67 
  6    68 /*   END INCLUDE FILE gcos_flags.incl.pl1 */
  5    29 
  5    30 
  5    31 /*   END INCLUDE FILE gcos_save_data_entry.incl.pl1 */
  2   108 
  2   109 
  7     1 /*     BEGIN INCLUDE FILE gcos_file_info_block_.incl.pl1   DAK - APRIL 74    */
  7     2 
  7     3 /* 	Declaration of File Information Block (fib)
  7     4*
  7     5*   Change: Mel Wilson	11/01/79 for gtss compatibility
  7     6*   Change: Dave Ward	05/20/81 *_file constants.
  7     7*   Change: Dave Ward	05/29/81 separated fct structures.
  7     8*   Change: Dave Ward	09/02/81 provision for tape density 6250, dens_hist 2 bits (not 3).
  7     9**/
  7    10 dcl 1 fib aligned based (fibptr)			/* fib structure */
  7    11 
  7    12 ,     2 buffer	ptr aligned			/* pointer to current buffer (gcos_write_) */
  7    13 ,     2 buffer_indx	fixed bin			/* Index to buffer in use. */
  7    14 ,     2 stream	char(8)unal			/* stream name for attaching this file */
  7    15 ,     2 pathnm	char(168)unal			/* pathname (for disk, print or punch files) */
  7    16 ,     2 unique_file_id bit(36)				/* multics unique segment id for file */
  7    17 ,     2 indicators					/* five words of flags */
  7    18 
  7    19 ,       3 indicators_word_1
  7    20 ,         4 used	bit(1) unal			/* 1=fib used, 0=fib used */
  7    21 ,         4 attached	bit(1) unal			/* 1=stream is attached */
  7    22 ,         4 type	bit(1) unal			/* 1=random, 0=linked */
  7    23 ,         4 perm	bit(1) unal			/* 1=permanent file, 0=not */
  7    24 ,         4 print	bit(1) unal			/* 1=file type is printer */
  7    25 ,         4 punch	bit(1) unal			/* 1=file type is punch */
  7    26 ,         4 reader	bit(1) unal			/* 1=file type is card reader */
  7    27 ,         4 tape	bit(1) unal			/* 1=file type is tape */
  7    28 ,         4 console	bit(1) unal			/* 1=file type is console typewriter */
  7    29 ,         4 read	bit(1) unal			/* 1=read access permitted */
  7    30 ,         4 write	bit(1) unal			/* 1=write access permitted */
  7    31 ,         4 null	bit(1) unal			/* 1=file is null */
  7    32 ,         4 purge	bit(1) unal			/* 1=purge file at time on release */
  7    33 ,         4 gein	bit(1) unal			/* 1 = this file contains data cards from the job deck */
  7    34 ,         4 disp	bit(2) unal			/* disposition code:
  7    35*						   00 = dismount
  7    36*						   01 = release
  7    37*						   10 = save
  7    38*						   11 = continue	 */
  7    39 ,         4 adisp	bit(2) unal			/* abort disp - same codes as disp */
  7    40 ,         4 order	bit(1) unal			/* 1 = write, 0 = read or other */
  7    41 ,         4 mode	bit(2) unal			/* tape i/o mode 
  7    42*						   00 = binary
  7    43*						   01 = decimal
  7    44*						   10 = nine	*/
  7    45 ,         4 tracks	bit(2) unal			/* tape request code:
  7    46*						   00 = installation default
  7    47*						   01 = 7 track
  7    48*						   10 = 9 track	*/
  7    49 ,         4 density	bit(4) unal			/* tape density from $ TAPE card
  7    50*						   0000 = site standard high
  7    51*						   0001 = 200 bpi
  7    52*						   0010 = 556 bpi
  7    53*						   0100 = 800 bpi
  7    54*						   1001 = 1600 bpi
  7    55*						   1100 = 6250 bpi
  7    56*						   1111 = handler capable of any appropriate denisty */
  7    57 ,         4 dens_hist	bit(2) unal			/* density history for MME GEFADD */
  7    58 ,         4 forced_acl_flag bit(1) unal 			/* 1 => acl forced for gtss file (2.4) */
  7    59 ,         4 fill	bit(6) unal			/* reserved for future use */
  7    60 ,       3 indicators_word_2
  7    61 ,         4 plud	bit(18) unal			/* primary log unit designator */
  7    62 						/* bcd channel and channel number */
  7    63 
  7    64 ,         4 slud	bit(18) unal			/* secondary log. unit designator */
  7    65 						/* bcd channel and channel number */
  7    66 ,       3 indicators_word_3
  7    67 ,         4 serial_no	bit(30) unal			/* tape serial number */
  7    68 ,         4 pad	bit( 6) unal			/* unused */
  7    69 ,       3 indicators_word_4
  7    70 ,         4 tape_name	bit(72) unal			/* tape name */
  7    71 
  7    72 ,     2 current	fixed bin(21)			/* current file position */
  7    73 ,     2 last	fixed bin(21)			/* eof for sequential disk files */
  7    74 ,     2 size	fixed bin(24)			/* offset of end of file in words */
  7    75 ,     2 init_size	fixed bin(24)			/* file size at start of activity */
  7    76 ,     2 init_posit	fixed bin(24)			/* file position at start of activity */
  7    77 ,     2 iocount	fixed bin(35)			/* total no. of i/o operations */
  7    78 ,     2 rec_len	fixed bin(24)			/* length of current record (gcos_write_) */
  7    79 ,     2 command_count	fixed bin(17) unal		/* size of command table for device (gcos_mme_inos_) */
  7    80 ,     2 command_index	fixed bin(17) unal		/* pointer to command table entry (gcos_mme_inos_) */
  7    81 ,     2 error_retry	fixed bin(17) unal		/* error retry counter */
  7    82 ,     2 seq_no	fixed bin(17) unal		/* tape reel sequence no */
  7    83 ;
  7    84 dcl  fibptr                   ptr			/* pointer to current fib in gcos_ext_stat_ */;
  7    85 
  7    86 /* File usage classification constants: */
  7    87 dcl  linked_file              bit(1)static int options(constant)init("0"b);
  7    88 dcl  random_file              bit(1)static int options(constant)init("1"b);
  7    89 dcl  read_file                bit(1)static int options(constant)init("0"b);
  7    90 dcl  write_file               bit(1)static int options(constant)init("1"b);
  7    91 
  7    92 /*     END INCLUDE FILE gcos_file_info_block_.incl.pl1     */
  2   110 
  2   111 
  2   112 dcl 1 gcos_ext_stat_$mc like mc	/* machine condition from abort or fault */  ext;
  8     1 /*  */
  8     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  8     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  8     4 /* Modified 07/07/76 by Morris for fault register data */
  8     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  8     6 /* Modified '82 to make values constant */
  8     7 
  8     8 /* words 0-15 pointer registers */
  8     9 
  8    10 dcl  mcp ptr;
  8    11 
  8    12 dcl 1 mc based (mcp) aligned,
  8    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  8    14    (2 regs,					/* registers */
  8    15       3 x (0:7) bit (18),				/* index registers */
  8    16       3 a bit (36),					/* accumulator */
  8    17       3 q bit (36),					/* q-register */
  8    18       3 e bit (8),					/* exponent */
  8    19       3 pad1 bit (28),
  8    20       3 t bit (27),					/* timer register */
  8    21       3 pad2 bit (6),
  8    22       3 ralr bit (3),				/* ring alarm register */
  8    23 
  8    24     2 scu (0:7) bit (36),
  8    25 
  8    26     2 mask bit (72),				/* mem controller mask at time of fault */
  8    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  8    28     2 errcode fixed bin (35),				/* fault handler's error code */
  8    29     2 fim_temp,
  8    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  8    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  8    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  8    33     2 fault_reg bit (36),				/* fault register */
  8    34     2 pad2 bit (1),
  8    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  8    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  8    37     2 fault_time bit (54),				/* time of fault */
  8    38 
  8    39     2 eis_info (0:7) bit (36)) unaligned;
  8    40 
  8    41 
  8    42 dcl (apx fixed bin init (0),
  8    43      abx fixed bin init (1),
  8    44      bpx fixed bin init (2),
  8    45      bbx fixed bin init (3),
  8    46      lpx fixed bin init (4),
  8    47      lbx fixed bin init (5),
  8    48      spx fixed bin init (6),
  8    49      sbx fixed bin init (7)) internal static options (constant);
  8    50 
  8    51 
  8    52 
  8    53 
  8    54 dcl  scup ptr;
  8    55 
  8    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  8    57 
  8    58 
  8    59 /*	WORD (0)		*/
  8    60 
  8    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  8    62       3 prr bit (3),				/* procedure ring register */
  8    63       3 psr bit (15),				/* procedure segment register */
  8    64       3 p bit (1),					/* procedure privileged bit */
  8    65 
  8    66     2 apu,					/* APPENDING UNIT STATUS */
  8    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  8    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  8    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  8    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  8    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  8    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  8    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  8    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  8    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  8    76       3 ptw bit (1),				/* Fetch of PTW */
  8    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  8    78       3 fap bit (1),				/* Fetch of final address paged */
  8    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  8    80       3 fabs bit (1),				/* Fetch of final address absolute */
  8    81 
  8    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  8    83 
  8    84 
  8    85 /*	WORD (1)		*/
  8    86 
  8    87     2 fd,						/* FAULT  DATA */
  8    88       3 iro bit (1),				/* illegal ring order */
  8    89       3 oeb bit (1),				/* out of execute bracket */
  8    90       3 e_off bit (1),				/* no execute */
  8    91       3 orb bit (1),				/* out of read bracket */
  8    92       3 r_off bit (1),				/* no read */
  8    93       3 owb bit (1),				/* out of write bracket */
  8    94       3 w_off bit (1),				/* no write */
  8    95       3 no_ga bit (1),				/* not a gate */
  8    96       3 ocb bit (1),				/* out of call bracket */
  8    97       3 ocall bit (1),				/* outward call */
  8    98       3 boc bit (1),				/* bad outward call */
  8    99       3 inret bit (1),				/* inward return */
  8   100       3 crt bit (1),				/* cross ring transfer */
  8   101       3 ralr bit (1),				/* ring alarm register */
  8   102       3 am_er bit (1),				/* associative memory fault */
  8   103       3 oosb bit (1),				/* out of segment bounds */
  8   104       3 paru bit (1),				/* processor parity upper */
  8   105       3 parl bit (1),				/* processor parity lower */
  8   106       3 onc_1 bit (1),				/* op not complete type 1 */
  8   107       3 onc_2 bit (1),				/* op not complete type 2 */
  8   108 
  8   109     2 port_stat,					/* PORT  STATUS */
  8   110       3 ial bit (4),				/* illegal action lines */
  8   111       3 iac bit (3),				/* illegal action channel */
  8   112       3 con_chan bit (3),				/* connect channel */
  8   113 
  8   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  8   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  8   116 
  8   117 
  8   118 /*	WORD (2)		*/
  8   119 
  8   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  8   121       3 trr bit (3),				/* temporary ring register */
  8   122       3 tsr bit (15),				/* temporary segment register */
  8   123 
  8   124     2 pad2 bit (9),
  8   125 
  8   126     2 cpu_no bit (3),				/* CPU number */
  8   127 
  8   128     2 delta bit (6),				/* tally modification DELTA */
  8   129 
  8   130 
  8   131 /*	WORD (3)		*/
  8   132 
  8   133     2 word3 bit (18),
  8   134 
  8   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  8   136       3 tsna,					/* Word 1 status */
  8   137         4 prn bit (3),				/* Word 1  PR  number */
  8   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  8   139       3 tsnb,					/* Word 2  status */
  8   140         4 prn bit (3),				/* Word 2  PR  number */
  8   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  8   142       3 tsnc,					/* Word 3  status */
  8   143         4 prn bit (3),				/* Word 3  PR  number */
  8   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  8   145 
  8   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  8   147 
  8   148 
  8   149 /* 	WORD (4)		*/
  8   150 
  8   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  8   152 
  8   153     2 ir,						/* INDICATOR  REGISTERS */
  8   154       3 zero bit (1),				/* zero indicator */
  8   155       3 neg bit (1),				/* negative indicator */
  8   156       3 carry bit (1),				/* carryry indicator */
  8   157       3 ovfl bit (1),				/* overflow indicator */
  8   158       3 eovf bit (1),				/* eponent overflow */
  8   159       3 eufl bit (1),				/* exponent underflow */
  8   160       3 oflm bit (1),				/* overflow mask */
  8   161       3 tro bit (1),				/* tally runout */
  8   162       3 par bit (1),				/* parity error */
  8   163       3 parm bit (1),				/* parity mask */
  8   164       3 bm bit (1),					/* ^bar mode */
  8   165       3 tru bit (1),				/* truncation mode */
  8   166       3 mif bit (1),				/* multi-word instruction mode */
  8   167       3 abs bit (1),				/* absolute mode */
  8   168       3 pad bit (4),
  8   169 
  8   170 
  8   171 /*	WORD (5)		*/
  8   172 
  8   173     2 ca bit (18),					/* COMPUTED  ADDRESS */
  8   174 
  8   175     2 cu,						/* CONTROL UNIT STATUS */
  8   176       3 rf bit (1),					/* on first cycle of repeat instr */
  8   177       3 rpt bit (1),				/* repeat instruction */
  8   178       3 rd bit (1),					/* repeat double instruction */
  8   179       3 rl bit (1),					/* repeat link instruciton */
  8   180       3 pot bit (1),				/* IT  modification */
  8   181       3 pon bit (1),				/* return type instruction */
  8   182       3 xde bit (1),				/* XDE from Even location */
  8   183       3 xdo bit (1),				/* XDE from Odd  location */
  8   184       3 poa bit (1),				/* operation preparation */
  8   185       3 rfi bit (1),				/* tells CPU to refetch instruction */
  8   186       3 its bit (1),				/* ITS modification */
  8   187       3 if bit (1),					/* fault occured during instruction fetch */
  8   188 
  8   189     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  8   190 
  8   191 
  8   192 /*	WORDS (6,7)	*/
  8   193 
  8   194     2 even_inst bit (36),				/* even instruction of faulting pair */
  8   195 
  8   196     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  8   197 
  8   198 
  8   199 
  8   200 
  8   201 
  8   202 
  8   203 /*	ALTERNATE   SCU  DECLARATION		*/
  8   204 
  8   205 
  8   206 dcl 1 scux based (scup) aligned,
  8   207 
  8   208    (2 pad0 bit (36),
  8   209 
  8   210     2 fd,						/* GROUP II  FAULT DATA */
  8   211       3 isn bit (1),				/* illegal segment number */
  8   212       3 ioc bit (1),				/* illegal op  code  */
  8   213       3 ia_am bit (1),				/* illegal address - modifier */
  8   214       3 isp bit (1),				/* illegal slave  procedure */
  8   215       3 ipr bit (1),				/* illegal procedure */
  8   216       3 nea bit (1),				/* non existent address */
  8   217       3 oobb bit (1),				/* out of bounds */
  8   218       3 pad bit (29),
  8   219 
  8   220     2 pad2 bit (36),
  8   221 
  8   222     2 pad3a bit (18),
  8   223 
  8   224     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  8   225       3 prn bit (3),				/* PR  number */
  8   226       3 prv bit (1),				/* PR  valid bit */
  8   227 
  8   228     2 pad3b bit (6)) unaligned,
  8   229 
  8   230     2 pad45 (0:1) bit (36),
  8   231 
  8   232     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  8   233 
  8   234 
  8   235 
  8   236 /*  END INCLUDE FILE   mc.incl.pl1 */
  2   113 
  2   114 
  2   115 dcl 1 gcos_ext_stat_$gcos_gtss	ext
  2   116 ,     3 gcos_gtss_ext
  2   117 ,       4 u_state_ptr ptr
  2   118 ,       4 snumb_index fixed bin(24)
  2   119 ,       4 home_path char(168)
  2   120 ;
  2   121 
  2   122 /*   END INCLUDE FILE gcos_ext_stat_.incl.pl1 */
      558 
      559 
  9     1 /* BEGIN INCLUDE FILE gcos_dcl_ios_.incl.pl1   (Wardd Multics)  06/16/81 1040.9 mst Tue */
  9     2 
  9     3 dcl  ios_$attach		entry (
  9     4 			char(*)
  9     5 ,			char(*)
  9     6 ,			char(*)
  9     7 ,			char(*)
  9     8 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9     9 				);
  9    10 
  9    11 dcl  ios_$detach		entry (
  9    12 			char(*)
  9    13 ,			char(*)
  9    14 ,			char(*)
  9    15 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    16 				);
  9    17 
  9    18 dcl  ios_$order               entry (
  9    19 			char(*)
  9    20 ,			char(*)
  9    21 ,			ptr
  9    22 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    23 				);
  9    24 
  9    25 dcl  ios_$read                entry (
  9    26 			char(*)
  9    27 ,			ptr
  9    28 ,			fixed bin(21)
  9    29 ,			fixed bin(21)
  9    30 ,			fixed bin(21)
  9    31 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    32 				);
  9    33 
  9    34 dcl  ios_$read_ptr            entry (
  9    35 			ptr
  9    36 ,			fixed bin(21)
  9    37 ,			fixed bin(21)
  9    38 				);
  9    39 dcl  ios_$setsize		entry (
  9    40 			char(*)
  9    41 ,			fixed bin(21)
  9    42 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    43 				);
  9    44 
  9    45 dcl  ios_$seek                entry (
  9    46 			char(*)
  9    47 ,			char(*)
  9    48 ,			char(*)
  9    49 ,			fixed bin(21)
  9    50 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    51 				);
  9    52 
  9    53 dcl  ios_$tell		entry (
  9    54 			char(*)
  9    55 ,			char(*)
  9    56 ,			char(*)
  9    57 ,			fixed bin(21)
  9    58 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    59 				);
  9    60 
  9    61 dcl  ios_$write               entry (
  9    62 			char(*)
  9    63 ,			ptr
  9    64 ,			fixed bin(21)
  9    65 ,			fixed bin(21)
  9    66 ,			fixed bin(21)
  9    67 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
  9    68 				);
  9    69 
  9    70 dcl  ios_$write_ptr           entry (
  9    71 			ptr
  9    72 ,			fixed bin(21)
  9    73 ,			fixed bin(21)
  9    74 				);
  9    75 
  9    76 dcl 1 status			/* Return status code. */
  9    77 ,     2 code	fixed bin(35)aligned
  9    78 ,     2 word2	bit(36)aligned
  9    79 ;
  9    80 
  9    81 /*   END INCLUDE FILE gcos_dcl_ios_.incl.pl1 */
      560 
      561      end gcos_write_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/09/83  1007.2  gcos_write_.pl1                   >spec>on>09/07/83-gcos>gcos_write_.pl1
556          1    03/31/82  1614.5  gcos_fibs.incl.pl1                >ldd>include>gcos_fibs.incl.pl1
558          2    09/08/83  1229.3  gcos_ext_stat_.incl.pl1           >spec>on>09/07/83-gcos>gcos_ext_stat_.incl.pl1
2-100        3    03/27/82  0424.8  gcos_save_mc.incl.pl1             >ldd>include>gcos_save_mc.incl.pl1
2-104        4    03/27/82  0424.8  gcos_fct_entry.incl.pl1           >ldd>include>gcos_fct_entry.incl.pl1
2-108        5    03/27/82  0424.8  gcos_save_data_entry.incl.pl1     >ldd>include>gcos_save_data_entry.incl.pl1
5-29         6    09/08/83  1230.3  gcos_flags.incl.pl1               >spec>on>09/07/83-gcos>gcos_flags.incl.pl1
2-110        7    03/27/82  0424.8  gcos_file_info_block_.incl.pl1    >ldd>include>gcos_file_info_block_.incl.pl1
2-113        8    08/17/83  1135.7  mc.incl.pl1                       >ldd>include>mc.incl.pl1
560          9    03/27/82  0424.8  gcos_dcl_ios_.incl.pl1            >ldd>include>gcos_dcl_ios_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acipad                          000100 automatic       fixed bin(24,0)          dcl 493 set ref 252* 254 254 254
acistring                              based           char(1044480)            unaligned dcl 494 set ref 254*
acisw                           000101 automatic       bit(1)                   initial unaligned dcl 495 set ref 188 246 341* 495*
addr                                                   builtin function         dcl 496 ref 169 169 186 197 197 199 211 290 291 298
                                                                                  302 303 308 370 451
addrel                                                 builtin function         dcl 497 ref 213 231 231 231 231 290
attached                 60(01)        based           bit(1)                   level 4 packed unaligned dcl 7-10 ref 455
bcd                                    based           structure                level 1 packed unaligned dcl 548
bcd2                                   based           structure                level 1 packed unaligned dcl 552
bcdsw                           000102 automatic       bit(1)                   initial unaligned dcl 498 set ref 188 325* 355* 498*
blk_count                 1     000010 internal static fixed bin(24,0)          initial level 2 dcl 535 set ref 168*
block                                  based           structure                level 1 dcl 529
blockptr                        000104 automatic       pointer                  dcl 499 set ref 370* 371 375 464* 465 475*
buf                       1            based           bit(36)                  array level 2 dcl 529 set ref 153* 211
buffer                                 based           pointer                  level 2 in structure "fib" dcl 7-10 in procedure
                                                                                  "gcos_write_" set ref 153 168 211 371 409 439 451*
                                                                                  454 464 481 481
buffer                74450            based           bit(11520)               array level 3 in structure "fibs_control" dcl 1-2
                                                                                  in procedure "gcos_write_" set ref 451
buffer_in_use         74432            based           bit(1)                   array level 3 packed unaligned dcl 1-2 set ref 440
                                                                                  442 442 449*
buffer_indx               2            based           fixed bin(17,0)          level 2 dcl 7-10 set ref 450*
char                                   based           bit(6)                   level 2 packed unaligned dcl 548 set ref 295 295
                                                                                  301* 301
chars                                  based           bit(12)                  level 2 packed unaligned dcl 552 set ref 297* 306*
code                            000664 automatic       fixed bin(35,0)          level 2 dcl 9-76 set ref 164 166* 170 173 205* 477
current                  65            based           fixed bin(21,0)          level 2 dcl 7-10 set ref 454 483* 483 484
divide                                                 builtin function         dcl 500 ref 179 198 309 454
fct                             000046 external static structure                array level 2 dcl 2-102
fct_entry                              based           structure                level 1 dcl 4-3
fib                                    based           structure                level 1 dcl 7-10
fib_buffers           74432            based           structure                level 2 dcl 1-2
fib_ptr                                parameter       pointer                  dcl 121 ref 269 273 312 323 327 333 337 381 386 401
                                                                                  406
fibptr                          000662 automatic       pointer                  dcl 7-84 in procedure "gcos_write_" set ref 152 153
                                                                                  153 156 156 161 163 166 166 168 169 172 209 211
                                                                                  211 260 260 273* 333* 367 371 375 386* 406* 409
                                                                                  409 424* 425 431* 432 439 450 451 453 454 454 455
                                                                                  455* 464 465 471 471 473 475 481 481 483 483 484
                                                                                  484 484 484
fibptr                    2     000046 external static pointer                  array level 3 in structure "gcos_ext_stat_$fct"
                                                                                  dcl 2-102 in procedure "gcos_write_" ref 424
fibs                    322     000050 external static structure                array level 3 dcl 2-106 ref 421
fibs_control                           based           structure                level 1 dcl 1-2
filecode                               parameter       char                     unaligned dcl 122 in procedure "gcos_write_" set ref
                                                                                  6 263 345 351 359 394 422 431*
filecode                        000046 external static char(2)                  array level 3 in structure "gcos_ext_stat_$fct"
                                                                                  dcl 2-102 in procedure "gcos_write_" ref 422
flags                                  based           structure                level 1 dcl 6-8
gcos_attach_file_               000026 constant        entry                    external dcl 502 ref 455
gcos_cv_printline_gebcd_        000030 constant        entry                    external dcl 503 ref 197
gcos_error_                     000032 constant        entry                    external dcl 504 ref 166 442
gcos_et_$record_too_long        000034 external static fixed bin(35,0)          dcl 505 ref 205
gcos_ext_stat_$fct              000046 external static structure                level 1 dcl 2-102
gcos_ext_stat_$incode           000042 external static fixed bin(24,0)          dcl 2-29 ref 231
gcos_ext_stat_$save_data        000050 external static structure                level 1 dcl 2-106
gcos_ext_stat_$temp_seg_ptr     000044 external static pointer                  dcl 2-66 ref 440 442 442 449 451
gcos_incode_                    000036 constant        entry                    external dcl 506 ref 231
gcos_open_file_                 000040 constant        entry                    external dcl 507 ref 431
gcossw                          000106 automatic       bit(1)                   initial unaligned dcl 501 set ref 213 217 316* 349*
                                                                                  501*
gein                     60(13)        based           bit(1)                   level 4 packed unaligned dcl 7-10 set ref 425 432*
i                               000107 automatic       fixed bin(21,0)          dcl 508 set ref 169* 197* 198 293* 421* 422 423 424*
                                                                                  475*
index                                                  builtin function         dcl 509 ref 440
indicators               60            based           structure                level 2 dcl 7-10
indicators_word_1        60            based           structure                level 3 dcl 7-10
inp                             000110 automatic       pointer                  dcl 510 set ref 186* 197* 199* 215 231 231 290* 295
                                                                                  295 301 302* 302 308*
instring                               based           fixed bin(24,0)          array dcl 511 ref 215
ios_$order                      000052 constant        entry                    external dcl 9-18 ref 163 172
ios_$write                      000054 constant        entry                    external dcl 9-61 ref 169 475
j                               000112 automatic       fixed bin(24,0)          dcl 512 set ref 292* 299* 299 304* 304 309
k                               000113 automatic       fixed bin(17,0)          dcl 513 set ref 440* 441 449 450 451
length                    0(18)        based           fixed bin(18,0)          level 2 in structure "block" packed unsigned
                                                                                  unaligned dcl 529 in procedure "gcos_write_" set
                                                                                  ref 375 465*
length                                 based           fixed bin(18,0)          level 2 in structure "rcw" packed unsigned unaligned
                                                                                  dcl 541 in procedure "gcos_write_" set ref 242*
length                                                 builtin function         dcl 514 in procedure "gcos_write_" ref 144 179 197
                                                                                  197 252 254
lenrec                          000114 automatic       fixed bin(17,0)          dcl 515 set ref 179* 198* 204 209 215 219* 219 231
                                                                                  242 260 309*
mc                                     based           structure                level 1 dcl 8-12
media_code                0(26)        based           bit(4)                   level 2 packed unaligned dcl 541 set ref 231 248
                                                                                  248* 250*
mod                                                    builtin function         dcl 516 ref 252
next                      0(12)        based           bit(6)                   level 2 in structure "bcd2" packed unaligned dcl 552
                                                                                  in procedure "gcos_write_" set ref 298
next                      0(06)        based           bit(6)                   level 2 in structure "bcd" packed unaligned dcl 548
                                                                                  in procedure "gcos_write_" set ref 302 303
null                                                   builtin function         dcl 517 ref 163 163 172 172 409 439
num                                    based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 529 set ref
                                                                                  168 371* 371 454* 481* 481
outp                            000116 automatic       pointer                  dcl 518 set ref 211* 213* 213 215 231 231 254 291*
                                                                                  297 298* 298 301 303* 303 306
outstring                              based           fixed bin(24,0)          array dcl 519 set ref 215*
pads                            000000 constant        char(4)                  initial unaligned dcl 520 ref 254
pathnm                    5            based           char(168)                level 2 packed unaligned dcl 7-10 set ref 166*
rcw                                    based           structure                level 1 dcl 541
rcwp                            000120 automatic       pointer                  dcl 522 set ref 211* 231 241 242 244 248 248 250
rec_len                  73            based           fixed bin(24,0)          level 2 dcl 7-10 set ref 153 156* 156 209 211 260*
                                                                                  260 367 375* 409 453* 465 471 473*
record                                 parameter       char                     unaligned dcl 123 set ref 6 144 179 186 197 197 252
                                                                                  254 263 269 290 312 323 327 337 345 351 359 370
                                                                                  381
reportcode                             parameter       bit(8)                   unaligned dcl 124 ref 6 244 263 269 312 323 327 337
                                                                                  345 351
save_data                       000050 external static structure                level 2 dcl 2-106
save_data_entry                        based           structure                level 1 dcl 5-5
save_machine_conditions                based           structure                level 1 packed unaligned dcl 3-6
size                     67            based           fixed bin(24,0)          level 2 dcl 7-10 set ref 484 484* 484
status                          000664 automatic       structure                level 1 unaligned dcl 9-76 set ref 163* 169* 172*
                                                                                  475*
stream                    3            based           char(8)                  level 2 packed unaligned dcl 7-10 set ref 163 166*
                                                                                  169 172 475
substr                                                 builtin function         dcl 523 set ref 244* 248* 250* 254* 254
sw                              000122 automatic       bit(1)                   unaligned dcl 524 set ref 431*
sysout                    1     000046 external static bit(1)                   array level 3 packed unaligned dcl 2-102 ref 423
tape                     60(07)        based           bit(1)                   level 4 packed unaligned dcl 7-10 ref 152 161 471
temp_buf                        000123 automatic       fixed bin(24,0)          array dcl 525 set ref 197 197 199 291 308
trailer                         000010 internal static structure                level 1 unaligned dcl 535 set ref 169 169
word                                   based           bit(36)                  dcl 526 set ref 241* 244*
write_count                     000661 automatic       fixed bin(21,0)          dcl 527 set ref 471* 472* 475* 483

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 8-42
apx                                    internal static fixed bin(17,0)          initial dcl 8-42
bbx                                    internal static fixed bin(17,0)          initial dcl 8-42
bpx                                    internal static fixed bin(17,0)          initial dcl 8-42
gcos_ext_stat_$abort_reason            external static varying char(128)        dcl 2-13
gcos_ext_stat_$abort_return            external static label variable           dcl 2-14
gcos_ext_stat_$activity_card_num       external static picture(4)               unaligned dcl 2-15
gcos_ext_stat_$activity_name           external static char(8)                  unaligned dcl 2-16
gcos_ext_stat_$activity_start_time     external static fixed bin(71,0)          dcl 2-17
gcos_ext_stat_$card_num                external static picture(4)               unaligned dcl 2-18
gcos_ext_stat_$courtesy_call_control   external static structure                level 1 dcl 2-92
gcos_ext_stat_$dbs                     external static bit(1)                   array unaligned dcl 2-19
gcos_ext_stat_$default_nondollar       external static char(2)                  unaligned dcl 2-20
gcos_ext_stat_$dir_rings               external static fixed bin(3,0)           array dcl 2-21
gcos_ext_stat_$dpno                    external static varying char(100)        dcl 2-22
gcos_ext_stat_$dpo                     external static varying char(100)        dcl 2-23
gcos_ext_stat_$endfc                   external static char(2)                  unaligned dcl 2-24
gcos_ext_stat_$er                      external static pointer                  dcl 2-25
gcos_ext_stat_$etc_filecode            external static char(2)                  unaligned dcl 2-26
gcos_ext_stat_$gcos_gtss               external static structure                level 1 unaligned dcl 2-115
gcos_ext_stat_$gcos_slave_area_seg     external static pointer                  dcl 2-27
gcos_ext_stat_$gf                      external static fixed bin(24,0)          dcl 2-28
gcos_ext_stat_$increment_hold          external static fixed bin(24,0)          dcl 2-30
gcos_ext_stat_$initial_cpu_time        external static fixed bin(71,0)          dcl 2-31
gcos_ext_stat_$input_segment_path      external static varying char(168)        dcl 2-32
gcos_ext_stat_$jcl_warnings            external static fixed bin(24,0)          dcl 2-33
gcos_ext_stat_$job_cpu_time            external static fixed bin(71,0)          dcl 2-34
gcos_ext_stat_$job_id                  external static varying char(18)         dcl 2-35
gcos_ext_stat_$job_real_time           external static fixed bin(71,0)          dcl 2-36
gcos_ext_stat_$last_mme                external static fixed bin(24,0)          dcl 2-37
gcos_ext_stat_$ldrss                   external static fixed bin(24,0)          dcl 2-38
gcos_ext_stat_$max_activities          external static fixed bin(24,0)          dcl 2-39
gcos_ext_stat_$max_mem                 external static fixed bin(19,0)          dcl 2-40
gcos_ext_stat_$mc                      external static structure                level 1 unaligned dcl 2-112
gcos_ext_stat_$mme_rtrn                external static label variable           dcl 2-41
gcos_ext_stat_$nondollar               external static char(2)                  unaligned dcl 2-42
gcos_ext_stat_$nongcos                 external static char(2)                  unaligned dcl 2-43
gcos_ext_stat_$normal_return           external static label variable           dcl 2-44
gcos_ext_stat_$patchfile_ptr           external static pointer                  dcl 2-45
gcos_ext_stat_$pathname_prefix         external static varying char(168)        dcl 2-46
gcos_ext_stat_$pch                     external static pointer                  dcl 2-47
gcos_ext_stat_$pdir                    external static varying char(168)        dcl 2-48
gcos_ext_stat_$prt                     external static pointer                  dcl 2-49
gcos_ext_stat_$rs                      external static pointer                  dcl 2-50
gcos_ext_stat_$save_dir                external static varying char(168)        dcl 2-52
gcos_ext_stat_$saveseg_ptr             external static pointer                  dcl 2-51
gcos_ext_stat_$seg_rings               external static fixed bin(3,0)           array dcl 2-53
gcos_ext_stat_$sig_ptr                 external static pointer                  dcl 2-54
gcos_ext_stat_$skip_umc                external static bit(1)                   unaligned dcl 2-55
gcos_ext_stat_$snumb                   external static bit(30)                  dcl 2-56
gcos_ext_stat_$sought_label            external static char(8)                  unaligned dcl 2-57
gcos_ext_stat_$statistics              external static fixed bin(24,0)          array dcl 2-58
gcos_ext_stat_$stop_code               external static fixed bin(24,0)          dcl 2-59
gcos_ext_stat_$storage_limit           external static fixed bin(19,0)          dcl 2-60
gcos_ext_stat_$sysout_limit            external static fixed bin(35,0)          dcl 2-61
gcos_ext_stat_$sysout_lines            external static fixed bin(35,0)          dcl 2-62
gcos_ext_stat_$system_free_pointer     external static pointer                  dcl 2-63
gcos_ext_stat_$tape_buffer_size        external static fixed bin(35,0)          dcl 2-64
gcos_ext_stat_$temp_dir                external static varying char(168)        dcl 2-65
gcos_ext_stat_$termination_code        external static bit(18)                  unaligned dcl 2-67
gcos_ext_stat_$time_limit              external static fixed bin(71,0)          dcl 2-68
gcos_ext_stat_$userid                  external static char(12)                 unaligned dcl 2-69
gcos_ext_stat_$validation_level        external static fixed bin(3,0)           dcl 2-70
ios_$attach                     000000 constant        entry                    external dcl 9-3
ios_$detach                     000000 constant        entry                    external dcl 9-11
ios_$read                       000000 constant        entry                    external dcl 9-25
ios_$read_ptr                   000000 constant        entry                    external dcl 9-34
ios_$seek                       000000 constant        entry                    external dcl 9-45
ios_$setsize                    000000 constant        entry                    external dcl 9-39
ios_$tell                       000000 constant        entry                    external dcl 9-53
ios_$write_ptr                  000000 constant        entry                    external dcl 9-70
lbx                                    internal static fixed bin(17,0)          initial dcl 8-42
linked_file                            internal static bit(1)                   initial unaligned dcl 7-87
lpx                                    internal static fixed bin(17,0)          initial dcl 8-42
mcp                                    automatic       pointer                  dcl 8-10
putp                                   automatic       pointer                  dcl 521
random_file                            internal static bit(1)                   initial unaligned dcl 7-88
read_file                              internal static bit(1)                   initial unaligned dcl 7-89
sbx                                    internal static fixed bin(17,0)          initial dcl 8-42
scu                                    based           structure                level 1 dcl 8-56
scup                                   automatic       pointer                  dcl 8-54
scux                                   based           structure                level 1 dcl 8-206
spx                                    internal static fixed bin(17,0)          initial dcl 8-42
write_file                             internal static bit(1)                   initial unaligned dcl 7-90

NAMES DECLARED BY EXPLICIT CONTEXT.
ascii_ptr                       001004 constant        entry                    external dcl 337
bcd                             001053 constant        entry                    external dcl 351
bcd_ptr                         000737 constant        entry                    external dcl 323
block                           001103 constant        entry                    external dcl 359
block_ptr                       001157 constant        entry                    external dcl 381
force                           001203 constant        entry                    external dcl 394
force_common                    001242 constant        label                    dcl 408 ref 399
force_ptr                       001230 constant        entry                    external dcl 401
gcos_write_                     000056 constant        entry                    external dcl 6
look_up_filecode                001254 constant        entry                    internal dcl 415 ref 134 363 396
main                            000077 constant        label                    dcl 129 ref 357
print_bcd_card                  000551 constant        entry                    external dcl 263
print_bcd_ptr                   000577 constant        entry                    external dcl 269
print_common                    000617 constant        label                    dcl 274 ref 267
print_join                      000376 constant        label                    dcl 202 ref 310
ptr                             000760 constant        entry                    external dcl 327
ptr_common                      000774 constant        label                    dcl 332 ref 343
record                          001025 constant        entry                    external dcl 345
record_ptr                      000716 constant        entry                    external dcl 312
setbuf                          000105 constant        label                    dcl 141 set ref 335
setup                           001374 constant        entry                    internal dcl 436 ref 142 275 366
wr_err                          000165 constant        label                    dcl 164 ref 170 173 206 477
write_block                     001506 constant        entry                    internal dcl 467 ref 377
write_fib_block                 001476 constant        entry                    internal dcl 461 ref 159 209 367 409
writing_block                   001131 constant        label                    dcl 365 ref 387

NAMES DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 421 442 442
string                                                 builtin function         ref 440

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2072        2150    1616        2102
Length      2554    1616        56         370     254          16

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gcos_write_                         604 external procedure  is an external procedure.  
look_up_filecode                        internal procedure  shares stack frame of external procedure gcos_write_.  
setup                                   internal procedure  shares stack frame of external procedure gcos_write_.  
write_fib_block                         internal procedure  shares stack frame of external procedure gcos_write_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 trailer                     gcos_write_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
gcos_write_              000100 acipad                      gcos_write_
                         000101 acisw                       gcos_write_
                         000102 bcdsw                       gcos_write_
                         000104 blockptr                    gcos_write_
                         000106 gcossw                      gcos_write_
                         000107 i                           gcos_write_
                         000110 inp                         gcos_write_
                         000112 j                           gcos_write_
                         000113 k                           gcos_write_
                         000114 lenrec                      gcos_write_
                         000116 outp                        gcos_write_
                         000120 rcwp                        gcos_write_
                         000122 sw                          gcos_write_
                         000123 temp_buf                    gcos_write_
                         000661 write_count                 gcos_write_
                         000662 fibptr                      gcos_write_
                         000664 status                      gcos_write_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mod_fx1             ext_entry           ext_entry_desc
index_bs_1_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
gcos_attach_file_             gcos_cv_printline_gebcd_      gcos_error_                   gcos_incode_
gcos_open_file_               ios_$order                    ios_$write

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
gcos_et_$record_too_long      gcos_ext_stat_$fct            gcos_ext_stat_$incode         gcos_ext_stat_$save_data
gcos_ext_stat_$temp_seg_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    495 000045       498 000046       501 000047         6 000052       129 000077       134 000100       141 000105
    142 000106       144 000107       152 000111       153 000115       156 000121       159 000122       161 000123
    163 000127       164 000163       166 000166       168 000222       169 000230       170 000273       172 000275
    173 000332       176 000334       179 000335       186 000340       188 000343       197 000347       198 000370
    199 000374       202 000376       204 000377       205 000402       206 000405       209 000406       211 000413
    213 000422       215 000426       217 000434       219 000436       231 000440       235 000472       241 000473
    242 000474       244 000500       246 000506       248 000510       250 000516       252 000520       254 000524
    260 000541       261 000546       263 000547       267 000572       269 000573       273 000613       274 000617
    275 000620       290 000621       291 000626       292 000630       293 000631       295 000640       297 000651
    298 000655       299 000661       301 000663       302 000667       303 000673       304 000676       305 000677
    306 000701       308 000705       309 000707       310 000713       312 000714       316 000732       323 000734
    325 000753       327 000755       332 000774       333 000775       335 001001       337 001002       341 001020
    343 001022       345 001023       349 001046       351 001050       355 001074       357 001076       359 001077
    363 001124       365 001131       366 001132       367 001133       370 001137       371 001142       375 001145
    377 001151       379 001152       381 001153       386 001173       387 001177       394 001200       396 001217
    399 001224       401 001225       406 001236       408 001242       409 001243       413 001253       415 001254
    421 001256       422 001263       423 001277       424 001311       425 001313       426 001324       428 001332
    431 001334       432 001363       433 001366       436 001374       439 001375       440 001401       441 001412
    442 001413       447 001441       449 001442       450 001446       451 001451       453 001455       454 001457
    455 001464       458 001475       461 001476       464 001477       465 001502       467 001505       471 001507
    472 001517       473 001521       475 001522       477 001561       481 001563       483 001572       484 001575
    487 001602


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
