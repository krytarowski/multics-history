	COMPILATION LISTING OF SEGMENT apl_get_list_nums_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1620.0 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* APL External Function to read a segment full of numbers that are in
       11*   character form suitable for list-directed input. The numbers are converted
       12*   to float bin (63) and returned as a vector.
       13*
       14*   Written 790318 by PG (from apl_pickup_float_bin_2_).
       15*   Modified 790622 by PG to fix 406 (did not check for reading > 130560 elements)
       16*	Future enhancements: (1) when the lineno builtin is changed
       17*	to work for stream input files, have the error messages from
       18*	this program include the line number of the input file, (2) get
       19*	a maximum-sized vector from APL at the beginning (get a whole
       20*	value stack, in other words), rather than using a temp seg.
       21*	This will use 255K less in the pdir, in the limiting case.
       22**/
       23 
       24 apl_get_list_nums_:
       25      procedure (operators_argument);
       26 
       27 /* automatic */
       28 
       29 declare	code		fixed bin (35),		/* Multics status code */
       30 	dname		char (168),		/* directory name for segment */
       31 	ename		char (32),		/* entry name of segment */
       32 	file_title	char (200) varying,		/* title of input file */
       33 	n_words		fixed bin (19),		/* number of words to allocate on value stack */
       34 	n_values		fixed bin,		/* number of values read */
       35 	result		ptr,			/* pointer to result data array */
       36 	result_vb		ptr,			/* pointer to result value bead */
       37 	right		ptr,			/* pointer to right data array */
       38 	right_vb		ptr,			/* pointer to right value bead */
       39 	seg_ptr		ptr,			/* ptr to temp segment */
       40 	temp_numeric_datum	float;			/* temporary apl value */
       41 
       42 /* based */
       43 
       44 declare	right_arg_string	char (data_elements) based (right);
       45 
       46 /* builtins */
       47 
       48 declare	(addrel, divide, null, onsource, rtrim, size, string, substr, rel)
       49 			builtin;
       50 
       51 /* conditins */
       52 
       53 declare	(cleanup, conversion, endfile, transmit, undefinedfile)
       54 			condition;
       55 
       56 /* entries */
       57 
       58 declare	expand_pathname_	entry (char (*), char (*), char (*), fixed bin (35)),
       59 	get_temp_segment_	entry (char (*), ptr, fixed bin (35)),
       60 	ioa_		entry options (variable),
       61 	pl1_io_$error_code	entry (file) returns (fixed bin (35)),
       62 	release_temp_segment_
       63 			entry (char (*), ptr, fixed bin (35));
       64 
       65 /* files */
       66 
       67 declare	apl_get_list_nums	file;
       68 
       69 /* include files */
       70 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_external_function.incl.pl1 ============================ */
  1     2 
  1     3 /* This include segment contains all of the Version 2 apl declarations necessary for an external apl
  1     4*   function to interface to apl. */
  1     5 
  1     6 /* automatic */
  1     7 
  1     8 declare	data_elements fixed binary (21);	/* number of elements for arrays */
  1     9 
  1    10 /* entries */
  1    11 
  1    12 declare	apl_allocate_words_ entry (fixed binary (19), unaligned pointer);
  1    13 		/* param 1	(input)	number of words to allocate */
  1    14 		/* param 2	(output)	word-aligned packed pointer to allocated bead,
  1    15*					with general_bead.size and general_bead.reference_count set. */
  1    16 
  1    17 declare	apl_free_words_ entry (fixed binary (19), unaligned pointer);
  1    18 		/* param 1	(input)	number of words to free */
  1    19 		/* param 2	(input)	word-aligned packed pointer to bead to be freed. */
  1    20 
  1    21 declare	apl_free_bead_ entry (unaligned pointer);
  1    22 		/* param 1	(input)	word-aligned packed pointer to bead to be freed. */
  1    23 		/*			if reference count is non-zero, a system error will result. */
  1    24 
  1    25 declare	apl_get_value_stack_ entry (fixed binary (19));
  1    26 		/* param 1	(input)	number of words needed in a value stack. */
  1    27 		/* (implicit)	(output)	sets ws_info.value_stack_ptr to point to new value stack. */
  1    28 
  1    29 declare	apl_subsystem_ entry (fixed bin (35), bit (*) aligned, char (*), char (*), char (*), char (*),
  1    30 		fixed bin (35));
  1    31 		/* param 1	(input)	user number */
  1    32 		/* param 2	(input)	control switches (1 like ws_info.switches) */
  1    33 		/* param 3	(input)	initial ws pathname */
  1    34 		/* param 4	(input)	terminal conversion table to use */
  1    35 		/* param 5	(output)	user-specified signoff lock ("*" = no lock) */
  1    36 		/* param 6	(output)	0 = normal termination,
  1    37*					apl_error_table_$off_hold = )OFF HOLD,
  1    38*					apl_error_table_$cant_load_ws = could not load initial ws */
  1    39 
  1    40 declare	apl_system_error_ entry (fixed bin (35));
  1    41 		/* param 1	(input)	status code of error to be printed. */
  1    42 		/*			system errors will not return to caller. */
  1    43 
  1    44 /* external static */
  1    45 
  1    46 declare	(apl_error_table_$cant_load_ws,	/* status code returned by apl_subsystem_ if ws not found */
  1    47 	apl_error_table_$domain,		/* status code for DOMAIN ERROR */
  1    48 	apl_error_table_$function,		/* status code for FUNCTION ERROR - IN EXTERNAL FUNCTION */
  1    49 	apl_error_table_$index,		/* status code for INDEX ERROR */
  1    50 	apl_error_table_$length,		/* status code for LENGTH ERROR */
  1    51 	apl_error_table_$no_type_bits,	/* status code for SYSTEM ERROR - VALUE HAS NO TYPE BITS */
  1    52 	apl_error_table_$rank,		/* status code for RANK ERROR */
  1    53 	apl_error_table_$result_size,		/* status code for RESULT SIZE ERROR - OBJECT WOULD BE LARGER THAN A SEGMENT */
  1    54 	apl_error_table_$system_error,	/* status code for SYSTEM ERROR */
  1    55 	apl_error_table_$off_hold)		/* status code returned by apl_subsystem_ after )OFF HOLD */
  1    56 	fixed binary (35) external static;
  1    57 
  1    58 /* include files */
  1    59 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_number_data.incl.pl1 ================================== */
  2     2 
  2     3 /*
  2     4*   This include file contains information about the machine representation of numbers.
  2     5*   In all programs numbers should simply be declared 'float'.
  2     6*   All default statements should be in this include file.
  2     7*
  2     8*   This is the binary version.  The manifest constant Binary should be used by programs
  2     9*   that need to know whether we are using binary or decimal.
  2    10* */
  2    11 
  2    12 /* format: style3,initlm0,idind30 */
  2    13 
  2    14 default (float & ^decimal & ^binary & ^precision & ^constant) float binary (63);
  2    15 
  2    16 declare	(
  2    17 	TheBiggestNumberWeveGot	float initial (0.1701411834604692317e+39),
  2    18 	TheSmallestNumberWeveGot	float initial (.1469367938527859385e-38),
  2    19 	Binary			bit (1) aligned initial ("1"b)
  2    20 	)			internal static options (constant);
  2    21 
  2    22 /* Number of characters in a number datum entry; used for copying float number arrays as strings.
  2    23*   (Obsolete! use array copies!) */
  2    24 
  2    25 declare	NumberSize		fixed binary precision (4) internal static initial (8);
  2    26 
  2    27 /* ------ END INCLUDE SEGMENT		apl_number_data.incl.pl1 ---------------------------------- */
  1    60 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_ws_info.incl.pl1 ====================================== */
  3     2 
  3     3 /* This structure contains all of the global data (or pointers to it) for the APL subsystem */
  3     4 
  3     5 /* automatic */
  3     6 
  3     7 declare	ws_info_ptr ptr initial (apl_static_$ws_info_ptr.static_ws_info_ptr);
  3     8 
  3     9 /* external static */
  3    10 
  3    11 declare	1 apl_static_$ws_info_ptr	external static aligned structure,
  3    12 	  2 static_ws_info_ptr	unaligned pointer;
  3    13 
  3    14 /* based */
  3    15 
  3    16 declare	1 ws_info			aligned based (ws_info_ptr),
  3    17 	  2 version_number		fixed bin,	/* version of this structure (3) */
  3    18 	  2 switches		unaligned,	/* mainly ws parameters */
  3    19 	    3 long_error_mode	bit,		/* if 1, long Multics format, else APL/360 format */
  3    20 	    3 debug_mode		bit,		/* if 1, system error causes escape to command level */
  3    21 	    3 canonicalize_mode	bit,		/* if 1, the editor canonicalizes user input */
  3    22 	    3 restrict_exec_command	bit,		/* if 1, the )EXEC command may not be used */
  3    23 	    3 restrict_debug_command	bit,		/* if 1, the )DEBUG command may not be used */
  3    24 	    3 restrict_external_functions
  3    25 				bit,		/* if 1, the )ZFN, )MFN, and )DFN commands may not be used */
  3    26 	    3 restrict_load		bit,		/* if 1, the )LOAD and )COPY commands may not be used */
  3    27 	    3 restrict_load_directory	bit,		/* if 1, no directory allowed in )LOAD or )COPY pathnames */
  3    28 	    3 restrict_save		bit,		/* if 1, the )SAVE command may not be used */
  3    29 	    3 restrict_save_directory	bit,		/* if 1, no directory allowed in )SAVE pathnames */
  3    30 	    3 off_hold		bit,		/* if 1, )OFF HOLD was typed, else just )OFF */
  3    31 	    3 transparent_to_signals	bit,		/* if 1, any conditions slip right past APL */
  3    32 	    3 meter_mode		bit,		/* if 1, metering may be done, else speed is all-important */
  3    33 	    3 restrict_msg_command	bit,		/* if 1, the )MSG command may not be used. */
  3    34 	    3 compatibility_check_mode
  3    35 				bit,		/* if 1, check for incompatible operators */
  3    36 	    3 no_quit_handler	bit,		/* if 1, do not trap QUITs. */
  3    37 						/* remaining 20 bits not presently used */
  3    38 
  3    39 	  2 values,				/* attributes of the workspace */
  3    40 	    3 digits		fixed bin,	/* number of digits of precision printed on output */
  3    41 	    3 width		fixed bin,	/* line length for formatted output */
  3    42 	    3 index_origin		fixed bin,	/* the index origin (0 or 1) */
  3    43 	    3 random_link		fixed bin(35),	/* seed for random number generator */
  3    44 	    3 fuzz		float,		/* comparison tolerance (relative fuzz) */
  3    45 	    3 float_index_origin	float,		/* the index origin	in floating point */
  3    46 	    3 number_of_symbols	fixed bin,	/* the number of symbol_beads currently in existence */
  3    47 	    3 maximum_value_stack_size
  3    48 				fixed bin (18),	/* maximum number of words in one segment of value stack */
  3    49 
  3    50 	  2 pointers,				/* pointers to various internal tables */
  3    51 	    3 symbol_table_ptr	unaligned pointer,	/* -> symbol_table (apl_symbol_table.incl.pl1) */
  3    52 	    3 current_parse_frame_ptr	unaligned pointer,	/* -> topmost parse frame */
  3    53 	    3 value_stack_ptr	unaligned pointer,	/* -> next free location on value stack */
  3    54 	    3 alloc_free_info_ptr	unaligned pointer,	/* -> apl_storage_mngr_ data (apl_storage_system_data.incl.pl1) */
  3    55 
  3    56 	  2 time_invoked		fixed bin(71),	/* clock time that APL was entered */
  3    57 	  2 integer_fuzz		float,		/* the absolute fuzz used in checking for integers */
  3    58 	  2 user_number		fixed bin(35),	/* number under which the user is signed on */
  3    59 	  2 latent_expression	unaligned pointer,	/* -> value_bead for QuadLX */
  3    60 	  2 lock			char(32),		/* the lock currently set on this workspace (password) */
  3    61 	  2 wsid			char(100),	/* the workspace identification: name, number name, or clear ws */
  3    62 	  2 last_error_code		fixed bin(35),	/* last code passed to apl_error_ */
  3    63 	  2 signoff_lock		character (32),
  3    64 
  3    65 	  2 interrupt_info		aligned,		/* bits used by apl_interpreter_ to tell when to abort */
  3    66 	    3 dont_interrupt_parse	bit,		/* if 1, don't do a dirty stop because the parser is running */
  3    67 	    3 dont_interrupt_operator	bit,		/* if 1, don't do a dirty stop because an operator is running */
  3    68 	    3 dont_interrupt_storage_manager		/* if 1, don't stop because apl_storage_mngr_ is */
  3    69 				bit,		/*       munging his tables */
  3    70 	    3 unused_interrupt_bit	bit,		/* not presently used */
  3    71 	    3 dont_interrupt_command	bit,
  3    72 	    3 can_be_interrupted	bit,		/* if 1, OK to do a clean stop (we are between lines, reading) */
  3    73 	    3 clean_interrupt_pending	bit,		/* interrupt occured, break cleanly (between lines) */
  3    74 	    3 dirty_interrupt_pending	bit,		/* interrupt occured, break as soon as not inhibited */
  3    75 
  3    76 	  2 user_name		char (32),	/* process group id of user */
  3    77 	  2 immediate_input_prompt	char (32) varying,	/* normal input */
  3    78 	  2 evaluated_input_prompt	char (32) varying,	/* quad input */
  3    79 	  2 character_input_prompt	char (32) varying,	/* quad-quote input */
  3    80 	  2 vcpu_time		aligned,
  3    81 	    3 total		fixed bin (71),
  3    82 	    3 setup		fixed bin (71),
  3    83 	    3 parse		fixed bin (71),
  3    84 	    3 lex			fixed bin (71),
  3    85 	    3 operator		fixed bin (71),
  3    86 	    3 storage_manager	fixed bin (71),
  3    87 	  2 output_info		aligned,		/* data pertaining to output buffer */
  3    88 	    3 output_buffer_ptr	unal ptr,		/* ptr to output buffer */
  3    89 	    3 output_buffer_len	fixed bin (21),	/* length (bytes) of output buffer */
  3    90 	    3 output_buffer_pos	fixed bin (21),	/* index of next byte to write in */
  3    91 	    3 output_buffer_ll	fixed bin (21),	/* print positions used up so far */
  3    92 	  2 tab_width		fixed bin (21);	/* number of columns a tabs moves cursor */
  3    93 
  3    94 declare	output_buffer char (ws_info.output_buffer_len) based (ws_info.output_buffer_ptr);
  3    95 
  3    96 /* internal static */
  3    97 
  3    98 declare	max_parse_stack_depth fixed bin int static init(64536);
  3    99 
  3   100 /* ------ END INCLUDE SEGMENT		apl_ws_info.incl.pl1 -------------------------------------- */
  1    61 
  4     1 /* ====== BEGIN INCLUDE SEGMENT	apl_bead_format.incl.pl1 ================================== */
  4     2 
  4     3 declare 1 general_bead  		aligned based,	/* The Venerable Bead		*/
  4     4 	2 type 			unaligned,
  4     5 	  3 bead_type		unaligned,
  4     6 	    4 operator		bit (1),		/* ON if operator bead		*/
  4     7 	    4 symbol		bit (1),		/* ON if symbol bead		*/
  4     8 	    4 value		bit (1),		/* ON if value bead			*/
  4     9 	    4 function		bit (1),		/* ON if function bead		*/
  4    10 	    4 group		bit (1),		/* ON if group bead			*/
  4    11 	    4 label		bit (1),		/* ON if label bead			*/
  4    12 	    4 shared_variable	bit (1),		/* ON if shared variable bead 	*/
  4    13 	    4 lexed_function	bit (1),		/* ON if lexed function bead  	*/
  4    14 	  3 data_type		unaligned,
  4    15 	    4 list_value		bit (1),		/* ON if a list value bead		*/
  4    16 	    4 character_value	bit (1),		/* ON if a character value bead	*/
  4    17 	    4 numeric_value		bit (1),		/* ON if a numeric value bead		*/
  4    18 	    4 integral_value	bit (1),		/* ON if an integral value bead	*/
  4    19 	    4 zero_or_one_value	bit (1),		/* ON if a boolean value bead		*/
  4    20 	    4 complex_value		bit (1),		/* ON if a complex, numeric value bead   */
  4    21 	  3 unused_bits		bit (4) unaligned,	/* pad to 18 bits (for future use)	*/
  4    22 	2 size			bit (18) unaligned,	/* Number of words this bead occupies
  4    23*						   (used by bead storage manager)	*/
  4    24 	2 reference_count 		fixed binary (29);	/* Number of pointers which point
  4    25*						   to this bead (used by bead manager)	*/
  4    26 
  4    27 
  4    28 /* constant strings for initing type field in various beads */
  4    29 
  4    30 declare (
  4    31 	operator_type		init("100000000000000000"b),
  4    32 	symbol_type		init("010000000000000000"b),
  4    33     	value_type		init("001000000000000000"b),
  4    34 	function_type		init("000100000000000000"b),
  4    35 	group_type		init("000010000000000000"b),
  4    36 	label_type		init("001001000011000000"b),
  4    37 	shared_variable_type	init("001000100000000000"b),
  4    38 	lexed_function_type		init("000000010000000000"b),
  4    39 
  4    40 	list_value_type		init("000000001000000000"b),
  4    41 	character_value_type 	init("001000000100000000"b),
  4    42 	numeric_value_type		init("001000000010000000"b),
  4    43 	integral_value_type		init("001000000011000000"b),
  4    44 	zero_or_one_value_type	init("001000000011100000"b),
  4    45 	complex_value_type		init("001000000000010000"b),
  4    46 
  4    47 	not_integer_mask		init("111111111110011111"b),		/* to clear integral, zero_or_one bits */
  4    48 	not_zero_or_one_mask	init("111111111111011111"b)		/* to clear zero_or_one bit */
  4    49         ) bit(18) internal static;
  4    50 
  4    51 /* ------ END INCLUDE SEGMENT		apl_bead_format.incl.pl1 ---------------------------------- */
  1    62 
  5     1 /* ====== BEGIN INCLUDE SEGMENT	apl_value_bead.incl.pl1 =================================== */
  5     2 
  5     3 declare
  5     4 	number_of_dimensions fixed bin,
  5     5 
  5     6 	1 value_bead		aligned based,
  5     7 	2 header			aligned like general_bead,
  5     8 	2 total_data_elements	fixed binary (21),	/* length of ,[value] in APL		*/
  5     9 	2 rhorho			fixed binary,	/* number of dimensions of value	*/
  5    10 	2 data_pointer		pointer unaligned,	/* packed pointer to the data in value	*/
  5    11 	2 rho			fixed binary (21) dimension (number_of_dimensions refer (value_bead.rhorho));
  5    12 						/* dimensions of value (zero-origin)	*/
  5    13 
  5    14 
  5    15 declare 1 character_data_structure	aligned based,	/* alignment trick for PL/I compiler	*/
  5    16 	2 character_datum		character (1) unaligned dimension (0:data_elements - 1);
  5    17 						/* actual elements of character array	*/
  5    18 
  5    19 declare   character_string_overlay	character (data_elements) aligned based;
  5    20 						/* to overlay on above structure	 */
  5    21 
  5    22 
  5    23 declare   numeric_datum		float aligned dimension (0:data_elements - 1) based;
  5    24 						/* actual elements of numeric array	*/
  5    25 
  5    26 declare	complex_datum		complex float aligned dimension (0:data_elements -1) based;
  5    27 
  5    28 declare	MAX_VALUE_BEAD_SIZE		fixed bin (19) init (261120) int static options (constant);
  5    29 
  5    30 /* ------ END INCLUDE SEGMENT		apl_value_bead.incl.pl1 ----------------------------------- */
  1    63 
  6     1 /* ====== BEGIN INCLUDE SEGEMENT	apl_operators_argument.incl.pl1 =========================== */
  6     2 
  6     3 declare	1 operators_argument	aligned,
  6     4 	  2 operands (2)		aligned,		/* these are the operands to the operator to be executed.
  6     5*						   if operand (1).value is null, operator is monadic */
  6     6 	    3 value		pointer unaligned,	/* a pointer to the value bead for this operand */
  6     7 	    3 on_stack		bit (1) aligned,	/* ON if this value resides on the value stack */
  6     8 	  2 operator		aligned,		/* information about the operator to be executed */
  6     9 	    3 dimension		fixed bin,	/* (optional) dimension along which to operate */
  6    10 	    3 padding		bit (18) unaligned,	/* unused part of operator bead */
  6    11 	    3 op2			fixed bin (8) unal,	/* a modifier for op1, or a 2nd operator if inner product */
  6    12 	    3 op1			fixed bin (8) unal,	/* code for the actual operator to be executed */
  6    13 	  2 result		pointer unal,	/* (output) set by operator to point to result bead in stack */
  6    14 	  2 error_code		fixed bin (35),	/* (output) set before signaling apl_operator_error_ */
  6    15 	  2 where_error		fixed bin;	/* parseme index of where error was - parse sets to operator */
  6    16 
  6    17 /* ------ END INCLUDE SEGMENT		apl_operators_argument.incl.pl1 --------------------------- */
  1    64 
  1    65 
  1    66 /* ------ END INCLUDE SEGMENT		apl_external_function.incl.pl1 ---------------------------- */
       71 
       72 
       73 /* program */
       74 
       75 /* Usage in APL:
       76*		)MFN GET_LIST_NUMS APL_GET_LIST_NUMS_
       77*		R -< GET_LIST_NUMS 'PATH'		*/
       78 
       79 	right_vb = operators_argument.operands (2).value; /* Get ptr to right argument */
       80 	if ^right_vb -> value_bead.value		/* Make sure argument is a value bead */
       81 	then go to domain_error_right;
       82 
       83 	if ^right_vb -> value_bead.character_value	/* Make sure argument is character */
       84 	then go to domain_error_right;
       85 
       86 	right = right_vb -> value_bead.data_pointer;	/* Point to data array */
       87 	data_elements = right_vb -> value_bead.total_data_elements;
       88 
       89 /* Pop right arg off value stack, if necessary. */
       90 
       91 	if operators_argument.operands (2).on_stack
       92 	then ws_info.value_stack_ptr = right_vb;
       93 
       94 	call expand_pathname_ (right_arg_string, dname, ename, code);
       95 	if code ^= 0
       96 	then go to set_code;
       97 
       98 /* Get a temp segment to hold the numbers in until we know how many there are. */
       99 
      100 	seg_ptr = null;
      101 	on cleanup
      102 	     call clean_up;
      103 
      104 	call get_temp_segment_ ("apl_get_list_nums_", seg_ptr, code);
      105 	if code ^= 0
      106 	then go to set_code;
      107 
      108 /* Open the file and setup handlers for various errors that can happen. */
      109 
      110 	file_title = "vfile_ " || rtrim (dname) || ">" || rtrim (ename) || " -extend";
      111 
      112 	on undefinedfile (apl_get_list_nums)
      113 	     go to cant_open;
      114 	open file (apl_get_list_nums) title (file_title) stream input;
      115 
      116 	on endfile (apl_get_list_nums)
      117 	     go to end_of_file;
      118 	on transmit (apl_get_list_nums)
      119 	     go to transmit_trouble;
      120 	on conversion
      121 	     begin;
      122 		call ioa_ ("apl_get_list_nums_: value ^d (^a) non-numeric. 0 assumed.", n_values, onsource ());
      123 		onsource = "0";
      124 	     end;
      125 
      126 /* Everything is set up. Read data until eof. */
      127 
      128 	get file (apl_get_list_nums) list ((seg_ptr -> numeric_datum (n_values - 1) do n_values = 1 to 130560 by 1));
      129 
      130 /* If we get here, we have read as many values as will fit in one segment.
      131*   It is just possible that this coincides with the end-of-file on
      132*   the input file. If so, there is no error. */
      133 
      134 	get file (apl_get_list_nums) list (temp_numeric_datum);
      135 
      136 /* No end-of-file. Tell user it is just too big. */
      137 
      138 	code = apl_error_table_$result_size;
      139 	go to set_code;
      140 
      141 /* put result on value stack */
      142 /* Calculate size of result bead. Note that result data array */
      143 /* must be double-word aligned. */
      144 
      145 end_of_file:
      146 	number_of_dimensions = 1;			/* We will return a vector */
      147 	data_elements = n_values - 1;
      148 	n_words = size (value_bead) + size (numeric_datum) + 1;
      149 
      150 	result_vb = apl_push_stack_ (n_words);
      151 
      152 /* Set pointer to data array.  Double-word align it. */
      153 
      154 	result = addrel (result_vb, size (value_bead));
      155 
      156 	if substr (rel (result), 18, 1)
      157 	then result = addrel (result, 1);
      158 
      159 /* Initialize new value bead. */
      160 
      161 	result_vb -> value_bead.total_data_elements = data_elements;
      162 	result_vb -> value_bead.rhorho = number_of_dimensions;
      163 	result_vb -> value_bead.rho (1) = data_elements;
      164 	result_vb -> value_bead.data_pointer = result;
      165 
      166 /* Give result bead the correct type */
      167 
      168 	string (result_vb -> value_bead.type) = numeric_value_type;
      169 
      170 /* The result value bead is all set up.  Copy the data into the apl workspace */
      171 
      172 	result -> numeric_datum (*) = seg_ptr -> numeric_datum (*);
      173 
      174 	call clean_up;
      175 
      176 	operators_argument.result = result_vb;
      177 	return;
      178 
      179 domain_error_right:
      180 	operators_argument.where_error = operators_argument.where_error - 1;
      181 						/* Mark right operand */
      182 	operators_argument.error_code = apl_error_table_$domain;
      183 	return;
      184 
      185 set_code:
      186 	operators_argument.error_code = code;
      187 	return;
      188 
      189 cant_open:
      190 transmit_trouble:
      191 	operators_argument.error_code = pl1_io_$error_code (apl_get_list_nums);
      192 	call clean_up;
      193 	return;
      194 
      195 /* Internal procedures */
      196 
      197 clean_up:
      198      procedure;
      199 
      200 	close file (apl_get_list_nums);
      201 	call release_temp_segment_ ("apl_get_list_nums_", seg_ptr, code);
      202 
      203      end clean_up;
      204 
  7     1 /* ====== BEGIN INCLUDE SEGMENT	apl_push_stack_fcn.incl.pl1 =============================== */
  7     2 
  7     3 /* format: style3 */
  7     4 apl_push_stack_:
  7     5      procedure (P_n_words) returns (ptr);
  7     6 
  7     7 /* Function to (1) double-word align ws_info.value_stack_ptr, and
  7     8*   (2) make sure allocation request will fit on current value stack.
  7     9*
  7    10*   Written 770413 by PG
  7    11*   Modified 780210 by PG to round allocations up to an even number of words.
  7    12**/
  7    13 
  7    14 /* parameters */
  7    15 
  7    16 declare	P_n_words		fixed bin (19) parameter;
  7    17 
  7    18 /* automatic */
  7    19 
  7    20 declare	block_ptr		ptr,
  7    21 	num_words		fixed bin (19);
  7    22 
  7    23 /* builtins */
  7    24 
  7    25 declare	(addrel, binary, rel, substr, unspec)
  7    26 			builtin;
  7    27 
  7    28 /* entries */
  7    29 
  7    30 declare	apl_get_value_stack_
  7    31 			entry (fixed bin (19));
  7    32 
  7    33 /* program */
  7    34 
  7    35 	num_words = P_n_words;
  7    36 
  7    37 	if substr (unspec (num_words), 36, 1) = "1"b	/* num_words odd */
  7    38 	then num_words = num_words + 1;
  7    39 
  7    40 	if binary (rel (ws_info.value_stack_ptr), 18) + num_words > ws_info.maximum_value_stack_size
  7    41 	then call apl_get_value_stack_ (num_words);
  7    42 
  7    43 	block_ptr = ws_info.value_stack_ptr;
  7    44 	ws_info.value_stack_ptr = addrel (ws_info.value_stack_ptr, num_words);
  7    45 	return (block_ptr);
  7    46 
  7    47      end apl_push_stack_;
  7    48 
  7    49 /* ------ END INCLUDE SEGMENT		apl_push_stack_fcn.incl.pl1 ------------------------------- */
      205 
      206      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1549.4  apl_get_list_nums_.pl1            >special_ldd>on>apl.1129>apl_get_list_nums_.pl1
71           1    03/27/82  0438.7  apl_external_function.incl.pl1    >ldd>include>apl_external_function.incl.pl1
1-60         2    03/27/82  0429.8  apl_number_data.incl.pl1          >ldd>include>apl_number_data.incl.pl1
1-61         3    03/27/82  0439.2  apl_ws_info.incl.pl1              >ldd>include>apl_ws_info.incl.pl1
1-62         4    03/27/82  0438.5  apl_bead_format.incl.pl1          >ldd>include>apl_bead_format.incl.pl1
1-63         5    03/27/82  0439.2  apl_value_bead.incl.pl1           >ldd>include>apl_value_bead.incl.pl1
1-64         6    03/27/82  0439.0  apl_operators_argument.incl.pl1   >ldd>include>apl_operators_argument.incl.pl1
205          7    03/27/82  0429.8  apl_push_stack_fcn.incl.pl1       >ldd>include>apl_push_stack_fcn.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_n_words                              parameter       fixed bin(19,0)          dcl 7-16 ref 7-4 7-35
addrel                                                 builtin function         dcl 48 in procedure "apl_get_list_nums_" ref 154 156
addrel                                                 builtin function         dcl 7-25 in procedure "apl_push_stack_" ref 7-44
apl_error_table_$domain         000032 external static fixed bin(35,0)          dcl 1-46 ref 182
apl_error_table_$result_size    000034 external static fixed bin(35,0)          dcl 1-46 ref 138
apl_get_list_nums               000030 constant        file                     dcl 67 set ref 112 114 116 118 128 134 189 189* 200
apl_get_value_stack_            000042 constant        entry                    external dcl 7-30 ref 7-40
apl_static_$ws_info_ptr         000036 external static structure                level 1 dcl 3-11
bead_type                              based           structure                level 4 packed unaligned dcl 5-3
binary                                                 builtin function         dcl 7-25 ref 7-40
block_ptr                       000514 automatic       pointer                  dcl 7-20 set ref 7-43* 7-45
character_value           0(09)        based           bit(1)                   level 5 packed unaligned dcl 5-3 set ref 83
cleanup                         000264 stack reference condition                dcl 53 ref 101
code                            000100 automatic       fixed bin(35,0)          dcl 29 set ref 94* 95 104* 105 138* 185 201*
conversion                      000272 stack reference condition                dcl 53 ref 120
data_elements                   000330 automatic       fixed bin(21,0)          dcl 1-8 set ref 87* 94 94 147* 148 161 163 172
data_pointer              4            based           pointer                  level 2 packed unaligned dcl 5-3 set ref 86 164*
data_type                 0(08)        based           structure                level 4 packed unaligned dcl 5-3
dname                           000101 automatic       char(168)                unaligned dcl 29 set ref 94* 110
ename                           000153 automatic       char(32)                 unaligned dcl 29 set ref 94* 110
endfile                         000300 stack reference condition                dcl 53 ref 116
error_code                7            parameter       fixed bin(35,0)          level 2 dcl 6-3 set ref 182* 185* 189*
expand_pathname_                000016 constant        entry                    external dcl 58 ref 94
file_title                      000163 automatic       varying char(200)        dcl 29 set ref 110* 114
general_bead                           based           structure                level 1 dcl 4-3
get_temp_segment_               000020 constant        entry                    external dcl 58 ref 104
header                                 based           structure                level 2 dcl 5-3
ioa_                            000022 constant        entry                    external dcl 58 ref 122
maximum_value_stack_size
                         13            based           fixed bin(18,0)          level 3 dcl 3-16 ref 7-40
n_values                        000247 automatic       fixed bin(17,0)          dcl 29 set ref 122* 128* 128* 147
n_words                         000246 automatic       fixed bin(19,0)          dcl 29 set ref 148* 150*
null                                                   builtin function         dcl 48 ref 100
num_words                       000516 automatic       fixed bin(19,0)          dcl 7-20 set ref 7-35* 7-37 7-37* 7-37 7-40 7-40*
                                                                                  7-44
number_of_dimensions            000334 automatic       fixed bin(17,0)          dcl 5-3 set ref 145* 148 154 162
numeric_datum                          based           float bin(63)            array dcl 5-23 set ref 128* 148 172* 172
numeric_value_type                     constant        bit(18)                  initial unaligned dcl 4-30 ref 168
on_stack                  1            parameter       bit(1)                   array level 3 dcl 6-3 ref 91
onsource                                               builtin function         dcl 48 set ref 122 123*
operands                               parameter       structure                array level 2 dcl 6-3
operators_argument                     parameter       structure                level 1 dcl 6-3 set ref 24
pl1_io_$error_code              000024 constant        entry                    external dcl 58 ref 189
pointers                 14            based           structure                level 2 dcl 3-16
rel                                                    builtin function         dcl 48 in procedure "apl_get_list_nums_" ref 156
rel                                                    builtin function         dcl 7-25 in procedure "apl_push_stack_" ref 7-40
release_temp_segment_           000026 constant        entry                    external dcl 58 ref 201
result                    6            parameter       pointer                  level 2 in structure "operators_argument" packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "apl_get_list_nums_" set ref 176*
result                          000250 automatic       pointer                  dcl 29 in procedure "apl_get_list_nums_" set ref
                                                                                  154* 156 156* 156 164 172
result_vb                       000252 automatic       pointer                  dcl 29 set ref 150* 154 161 162 163 164 168 176
rho                       5            based           fixed bin(21,0)          array level 2 dcl 5-3 set ref 163*
rhorho                    3            based           fixed bin(17,0)          level 2 dcl 5-3 set ref 162*
right                           000254 automatic       pointer                  dcl 29 set ref 86* 94
right_arg_string                       based           char                     unaligned dcl 44 set ref 94*
right_vb                        000256 automatic       pointer                  dcl 29 set ref 79* 80 83 86 87 91
rtrim                                                  builtin function         dcl 48 ref 110 110
seg_ptr                         000260 automatic       pointer                  dcl 29 set ref 100* 104* 128 172 201*
size                                                   builtin function         dcl 48 ref 148 148 154
static_ws_info_ptr              000036 external static pointer                  level 2 packed unaligned dcl 3-11 ref 3-7
string                                                 builtin function         dcl 48 set ref 168*
substr                                                 builtin function         dcl 48 in procedure "apl_get_list_nums_" ref 156
substr                                                 builtin function         dcl 7-25 in procedure "apl_push_stack_" ref 7-37
temp_numeric_datum              000262 automatic       float bin(63)            dcl 29 set ref 134*
total_data_elements       2            based           fixed bin(21,0)          level 2 dcl 5-3 set ref 87 161*
transmit                        000310 stack reference condition                dcl 53 ref 118
type                                   based           structure                level 3 packed unaligned dcl 5-3 set ref 168*
undefinedfile                   000320 stack reference condition                dcl 53 ref 112
unspec                                                 builtin function         dcl 7-25 ref 7-37
value                                  parameter       pointer                  array level 3 in structure "operators_argument"
                                                                                  packed unaligned dcl 6-3 in procedure
                                                                                  "apl_get_list_nums_" ref 79
value                     0(02)        based           bit(1)                   level 5 in structure "value_bead" packed unaligned
                                                                                  dcl 5-3 in procedure "apl_get_list_nums_" set ref
                                                                                  80
value_bead                             based           structure                level 1 dcl 5-3 set ref 148 154
value_stack_ptr          16            based           pointer                  level 3 packed unaligned dcl 3-16 set ref 91* 7-40
                                                                                  7-43 7-44* 7-44
values                    2            based           structure                level 2 dcl 3-16
where_error              10            parameter       fixed bin(17,0)          level 2 dcl 6-3 set ref 179* 179
ws_info                                based           structure                level 1 dcl 3-16
ws_info_ptr                     000332 automatic       pointer                  initial dcl 3-7 set ref 91 3-7* 7-40 7-40 7-43 7-44
                                                                                  7-44

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Binary                                 internal static bit(1)                   initial dcl 2-16
MAX_VALUE_BEAD_SIZE                    internal static fixed bin(19,0)          initial dcl 5-28
NumberSize                             internal static fixed bin(4,0)           initial dcl 2-25
TheBiggestNumberWeveGot                internal static float bin(63)            initial dcl 2-16
TheSmallestNumberWeveGot               internal static float bin(63)            initial dcl 2-16
apl_allocate_words_             000000 constant        entry                    external dcl 1-12
apl_error_table_$cant_load_ws          external static fixed bin(35,0)          dcl 1-46
apl_error_table_$function              external static fixed bin(35,0)          dcl 1-46
apl_error_table_$index                 external static fixed bin(35,0)          dcl 1-46
apl_error_table_$length                external static fixed bin(35,0)          dcl 1-46
apl_error_table_$no_type_bits          external static fixed bin(35,0)          dcl 1-46
apl_error_table_$off_hold              external static fixed bin(35,0)          dcl 1-46
apl_error_table_$rank                  external static fixed bin(35,0)          dcl 1-46
apl_error_table_$system_error          external static fixed bin(35,0)          dcl 1-46
apl_free_bead_                  000000 constant        entry                    external dcl 1-21
apl_free_words_                 000000 constant        entry                    external dcl 1-17
apl_get_value_stack_            000000 constant        entry                    external dcl 1-25
apl_subsystem_                  000000 constant        entry                    external dcl 1-29
apl_system_error_               000000 constant        entry                    external dcl 1-40
character_data_structure               based           structure                level 1 dcl 5-15
character_string_overlay               based           char                     dcl 5-19
character_value_type                   internal static bit(18)                  initial unaligned dcl 4-30
complex_datum                          based           complex float bin(63)    array dcl 5-26
complex_value_type                     internal static bit(18)                  initial unaligned dcl 4-30
divide                                                 builtin function         dcl 48
function_type                          internal static bit(18)                  initial unaligned dcl 4-30
group_type                             internal static bit(18)                  initial unaligned dcl 4-30
integral_value_type                    internal static bit(18)                  initial unaligned dcl 4-30
label_type                             internal static bit(18)                  initial unaligned dcl 4-30
lexed_function_type                    internal static bit(18)                  initial unaligned dcl 4-30
list_value_type                        internal static bit(18)                  initial unaligned dcl 4-30
max_parse_stack_depth                  internal static fixed bin(17,0)          initial dcl 3-98
not_integer_mask                       internal static bit(18)                  initial unaligned dcl 4-30
not_zero_or_one_mask                   internal static bit(18)                  initial unaligned dcl 4-30
operator_type                          internal static bit(18)                  initial unaligned dcl 4-30
output_buffer                          based           char                     unaligned dcl 3-94
shared_variable_type                   internal static bit(18)                  initial unaligned dcl 4-30
symbol_type                            internal static bit(18)                  initial unaligned dcl 4-30
value_type                             internal static bit(18)                  initial unaligned dcl 4-30
zero_or_one_value_type                 internal static bit(18)                  initial unaligned dcl 4-30

NAMES DECLARED BY EXPLICIT CONTEXT.
apl_get_list_nums_              000147 constant        entry                    external dcl 24
apl_push_stack_                 001070 constant        entry                    internal dcl 7-4 ref 150
cant_open                       001000 constant        label                    dcl 189 ref 112
clean_up                        001026 constant        entry                    internal dcl 197 ref 101 174 192
domain_error_right              000767 constant        label                    dcl 179 ref 80 83
end_of_file                     000706 constant        label                    dcl 145 ref 116
set_code                        000774 constant        label                    dcl 185 ref 95 105 139
transmit_trouble                001000 constant        label                    dcl 189 ref 118

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1414        1460    1144        1424
Length      2030    1144        44         334     250           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_get_list_nums_                  388 external procedure  is an external procedure.  
on unit on line 101                  64 on unit               
on unit on line 112                  64 on unit               
on unit on line 116                  64 on unit               
on unit on line 118                  64 on unit               
on unit on line 120                 104 on unit               
clean_up                            134 internal procedure  uses I/O statements.  
apl_push_stack_                         internal procedure  shares stack frame of external procedure apl_get_list_nums_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_get_list_nums_       000100 code                        apl_get_list_nums_
                         000101 dname                       apl_get_list_nums_
                         000153 ename                       apl_get_list_nums_
                         000163 file_title                  apl_get_list_nums_
                         000246 n_words                     apl_get_list_nums_
                         000247 n_values                    apl_get_list_nums_
                         000250 result                      apl_get_list_nums_
                         000252 result_vb                   apl_get_list_nums_
                         000254 right                       apl_get_list_nums_
                         000256 right_vb                    apl_get_list_nums_
                         000260 seg_ptr                     apl_get_list_nums_
                         000262 temp_numeric_datum          apl_get_list_nums_
                         000330 data_elements               apl_get_list_nums_
                         000332 ws_info_ptr                 apl_get_list_nums_
                         000334 number_of_dimensions        apl_get_list_nums_
                         000514 block_ptr                   apl_push_stack_
                         000516 num_words                   apl_push_stack_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
get_end             stream_io           open                close               enable_file         get_list_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
apl_get_value_stack_          expand_pathname_              get_temp_segment_             ioa_
on_data_$getonsource          on_data_$setonsource          pl1_io_$error_code            release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
apl_error_table_$domain       apl_error_table_$result_size  apl_get_list_nums             apl_get_list_nums.fsb
apl_static_$ws_info_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000144        67 000157    3    7 000173        79 000175        80 000201        83 000204        86 000207
     87 000211        91 000213        94 000220        95 000246       100 000250       101 000252       104 000274
    105 000320       110 000322       112 000420       114 000441       116 000467       118 000507       120 000527
    122 000543       123 000600       124 000636       128 000640       134 000667       138 000702       139 000705
    145 000706       147 000710       148 000713       150 000722       154 000724       156 000731       161 000737
    162 000742       163 000744       164 000746       168 000747       172 000751       174 000756       176 000762
    177 000766       179 000767       182 000771       183 000773       185 000774       187 000777       189 001000
    192 001020       193 001024       197 001025       200 001036       201 001042       203 001067    7    4 001070
 7   35 001072    7   37 001074    7   40 001101    7   43 001116    7   44 001121    7   45 001130


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
