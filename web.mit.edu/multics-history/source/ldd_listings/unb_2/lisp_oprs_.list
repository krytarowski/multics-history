ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>lisp_oprs_.alm                  
ASSEMBLED ON:	11/05/86  1101.8 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
                                     6  "		LISP Operators
                                     7  
                                     8  " these operators provide run time support for compiled lisp functions
                                     9  " they are called by tspbp through pointers in the lisp stack header
                                    10  
                                    11  " Written by D A Moon 21 Aug 72
                                    12  " modified 15 Oct 72 by DAM for some evidently secret reason
                                    13  " modified 74.05.17 by DAM for "new" arrays and to speed up some oprs by using more pointer regs
                                    14  " modified 74.12.06 by DAM for external arrays
                                    15  
                                    16  
                                    17  
                                    18  	macro	enter_pl1_code
                              1     19  	epplp	ab|system_lp,*
                              2     20  	stx7	lisp_static_vars_$unmkd_ptr+1
                              3     21  	spriap	lisp_static_vars_$stack_ptr
                              4     22  	stc1	ab|in_pl1_code
                              5     23  	ife	&1,push
                              6     24  	push	&2
                              7     25  	eppbp	lisp_subr_tv_$..lisp..
                              8     26  	spribp	sp|stack_frame.entry_ptr
                              9     27  	ifend
                             10     28  	&end
                                    29  
                                    30  	macro	exit_pl1_code
                              1     31  	ife	&1,pop
                              2     32  	eppbp	sp|0
                              3     33  	inhibit	on
                              4     34  	spribp	sb|stack_header.stack_end_ptr
                              5     35  	eppsp	sp|stack_frame.prev_sp,*
                              6     36  	inhibit	off
                              7     37  	ifend
                              8     38  	epbpab	lisp_static_vars_$unmkd_ptr,*
                              9     39  	eppap	lisp_static_vars_$stack_ptr,*
                             10     40  	ldx7	lisp_static_vars_$unmkd_ptr+1
                             11     41  	stz	ab|in_pl1_code
                             12     42  	&end
                                    43  
                 777777 777774      44  	equ	his_lp,-4			where on unmkd pdl caller's lp kept
                 777777 777776      45  	equ	his_bp,-2			where on unmkd pdl caller's
                                    46  					" bp (= return addr) is kept
                 777777 777770      47  	equ	form,-8			dcl from lisp_
                 777777 777772      48  	equ	fcn,-6
                 777777 777774      49  	equ	argl,-4
                 777777 777776      50  	equ	plist,-2
                                    51  	include	lisp_unmkd_pdl
                                   1-1  
                                   1-2  " BEGIN INCLUDE FILE: lisp_unmkd_pdl.incl.alm
                                   1-3  "
                                   1-4  " D.A.Moon 14 July 72
                                   1-5  
                                   1-6  "offsets within the frame structure used to put control info on the unmarked pdl
                                   1-7  
                        000000     1-8  	equ	frame.prev_frame,0	left half		rel ptr to previous frame same type
                        000000     1-9  	equ	frame.stack_ptr,0	right half	rel(stack_ptr) when frame created
                        000001    1-10  	equ	frame.dat1,1	left half
                        000001    1-11  	equ	frame.dat2,1	right half
                        000002    1-12  	equ	frame.ret,2	4-word pl1 label variable, where to return to on event.
                                  1-13  
                                  1-14  " END INCLUDE FILE lisp_unmkd_pdl.incl.alm
                                    52  	include	lisp_stack_seg
                                   2-1  " BEGIN INCLUDE FILE lisp_stack_seg.incl.alm
                                   2-2  
                                   2-3  "	lisp stack segment header format
                                   2-4  "	Last modified by Reed 6/21/72
                                   2-5  "
                        000000     2-6  	equ	marked_stack_bottom,0	offset of ptr to bottom of marked stack
                        000002     2-7  	equ	unmkd_stack_bottom,2	offset of ptr to bottom of unmkd_stack
                        000004     2-8  	equ	stack_ptr_ptr,4		offset of ptr to lisp_static_vars_$stack_ptr
                        000006     2-9  	equ	unmkd_ptr_ptr,6		offset of ptr to lisp_static_vars_$unmkd_ptr's offset word
                        000010    2-10  	equ	array_pointer,8		points at cell of array most recently referenced
                        000012    2-11  	equ	nil,10			offset of cell containing pointer to nil...
                        000014    2-12  	equ	true,12			offset of cell containing pointer to t...
                        000016    2-13  	equ	in_pl1_code,14		offset of flag saying whether stack_ptr
                                  2-14  "					& unmkd_ptr or ap and ab|.,x7 are valid...if zero, ap,ab arevalid.
                                  2-15  " table of pointers to operators
                                  2-16  
                        000020    2-17  	equ	bind_op,16
                        000022    2-18  	equ	unbind_op,18
                        000024    2-19  	equ	errset1_op,20
                        000026    2-20  	equ	errset2_op,22
                        000030    2-21  	equ	unerrset_op,24
                        000032    2-22  	equ	call_op,26
                        000034    2-23  	equ	catch1_op,28
                        000036    2-24  	equ	catch2_op,30
                        000040    2-25  	equ	uncatch_op,32
                        000042    2-26  	equ	gensym_data,34	" data for gensym function
                                  2-27  
                        000044    2-28  	equ	system_lp,36		pointer to common linkage section for bound segment.
                        000046    2-29  	equ	iogbind_op,38		operator to help out with compiled iog.
                        000050    2-30  	equ	unseen_go_tag_op,40
                        000052    2-31  	equ	throw1_op,42
                        000054    2-32  	equ	throw2_op,44
                        000056    2-33  	equ	signp_op,46
                        000060    2-34  	equ	type_fields,48
                        000062    2-35  	equ	return_op,50
                        000064    2-36  	equ	err_op,52
                        000066    2-37  	equ	pl1_interface,54
                        000070    2-38  	equ	pl1_lsubr_interface,56
                        000072    2-39  	equ	cons_op,58		operator for compiled cons
                        000074    2-40  	equ	ncons_op,60		opeator for compiled cons with nil
                        000076    2-41  	equ	xcons_op,62		operator for compiled xcons
                        000100    2-42  	equ	begin_list_op,64		operator to begin compiled list code
                        000102    2-43  	equ	append_list_op,66		operator to get new list cell and hook on end
                        000104    2-44  	equ	terminate_list_op,68	operator to finish off list.
                        000106    2-45  	equ	compare_op,70
                        000110    2-46  	equ	link_opr,72
                        000112    2-47  	equ	array_operator,74
                        000114    2-48  	equ	dead_array_operator,76
                        000116    2-49  	equ	store_operator,78
                        000120    2-50  	equ	floating_store_operator,80
                        000122    2-51  	equ	array_info_for_store,82
                        000124    2-52  	equ	array_offset_for_store,84
                        000126    2-53  	equ	array_link_snap_opr,86
                        000130    2-54  	equ	create_string_desc_op,88	string desc for PL/I call
                        000132    2-55  	equ	create_array_desc_op,90	array desc for PL/I call
                        000134    2-56  	equ	pl1_call_op,92		PL/I call operator
                        000136    2-57  	equ	cons_string_op,94		operator to cons up a string
                        000140    2-58  	equ	create_varying_string_op,96
                        000142    2-59  	equ	unwp1_op,98		unwind-protect start
                        000144    2-60  	equ	unwp2_op,100		ditto, for compat.
                        000146    2-61  	equ	ununwp_op,102		End unwind-protect.
                        000150    2-62  	equ	irest_return_op,104 	Interrupt restore return
                        000152    2-63  	equ	pl1_call_nopop_op,106	PL1 call, dont pop PL1 frame
                        000154    2-64  	equ	rcv_char_star_op,108	Receive char * result, pop pl1frame
                                  2-65  	" spare 110
                        000174    2-66  	equ	begin_unmkd_stack,124	beginning of unmkd_stack
                                  2-67  
                                  2-68  " END INCLUDE FILE lisp_stack_seg.incl.alm
                                  2-69  
                                    53  	include	lisp_array_fmt
                                   3-1  """ BEGIN INCLUDE FILE lisp_array_fmt.incl.alm
                                   3-2  
                                   3-3  " This include file describes the format of the "new" LISP arrays.
                                   3-4  " Written 74.05.13 by DAM
                                   3-5  
                        000000     3-6  	equ	array_info.ndims,0		left half
                        000000     3-7  	equ	array_info.gc_mark,0	right half
                        000001     3-8  	equ	call_array_operator,1	tspbp ab|array_opr,*
                        000002     3-9  	equ	array_data_ptr,2		-> dope vector||data in Lists space
                        000004    3-10  	equ	array_load_sequence,4	lda, ldq, tra bp|0
                        000007    3-11  	equ	array_info.type,7		left half - codes dcl below
                        000007    3-12  	equ	array_info.2ndims,7		right half - minus 2 times ndims
                                  3-13  
                        000000    3-14  	equ	S_expr_array,0		values for array_info.type
                        000001    3-15  	equ	Un_gc_array,1
                        000002    3-16  	equ	Fixnum_array,2
                        000003    3-17  	equ	Flonum_array,3
                        000004    3-18  	equ	Readtable_array,4
                        000005    3-19  	equ	Obarray_array,5
                        000006    3-20  	equ	Dead_array,6
                                  3-21  
                                  3-22  """ END INCLUDE FILE lisp_array_fmt.incl.alm
                                    54  	include	lisp_name_codes
                                   4-1  
                                   4-2  " BEGIN INCLUDE FILE lisp_name_codes.incl.alm
                                   4-3  
                                   4-4  " These are codes for the names of functions which are stored into ab|-1,x7 before
                                   4-5  " calling lisp_error_ for a bad_argument or bad_arg_correctable error. They
                                   4-6  " are used so that the name of the function which is rejecting its argument
                                   4-7  " can be printed.  Please note that all these codes are negative.
                                   4-8  
                 777777 777766     4-9  	equ	fn_do,-10
                 777777 777765    4-10  	equ	fn_arg,-11
                 777777 777764    4-11  	equ	fn_setarg,-12
                 777777 777763    4-12  	equ	fn_status,-13
                 777777 777762    4-13  	equ	fn_sstatus,-14
                 777777 777761    4-14  	equ	fn_errprint,-15
                 777777 777760    4-15  	equ	fn_errframe,-16
                 777777 777757    4-16  	equ	fn_evalframe,-17
                 777777 777756    4-17  	equ	fn_defaultf,-18
                 777777 777752    4-18  	equ	fn_tyo,-22
                 777777 777751    4-19  	equ	fn_ascii,-23
                 777777 777750    4-20  	equ	fn_rplaca,-24
                 777777 777747    4-21  	equ	fn_definedp,-25
                 777777 777746    4-22  	equ	fn_setq,-26
                 777777 777745    4-23  	equ	fn_set,-27
                 777777 777744    4-24  	equ	fn_delete,-28
                 777777 777743    4-25  	equ	fn_delq,-29
                 777777 777742    4-26  	equ	fn_stringlength,-30
                 777777 777741    4-27  	equ	fn_catenate,-31
                 777777 777740    4-28  	equ	fn_array,-32
                 777777 777737    4-29  	equ	fn_substr,-33
                 777777 777736    4-30  	equ	fn_index,-34
                 777777 777735    4-31  	equ	fn_get_pname,-35
                 777777 777734    4-32  	equ	fn_make_atom,-36
                 777777 777733    4-33  	equ	fn_ItoC,-37
                 777777 777732    4-34  	equ	fn_CtoI,-38
                 777777 777731    4-35  	equ	fn_defsubr,-39
                 777777 777730    4-36  	equ	fn_star_array,-40
                 777777 777727    4-37  	equ	fn_args,-41
                 777777 777726    4-38  	equ	fn_sysp,-42
                 777777 777725    4-39  	equ	fn_get,-43
                 777777 777724    4-40  	equ	fn_getl,-44
                 777777 777723    4-41  	equ	fn_putprop,-45
                 777777 777722    4-42  	equ	fn_remprop,-46
                 777777 777721    4-43  	equ	fn_save,-47
                 777777 777720    4-44  	equ	fn_add1,-48
                 777777 777717    4-45  	equ	fn_sub1,-49
                 777777 777716    4-46  	equ	fn_greaterp,-50
                 777777 777715    4-47  	equ	fn_lessp,-51
                 777777 777714    4-48  	equ	fn_minus,-52
                 777777 777713    4-49  	equ	fn_plus,-53
                 777777 777712    4-50  	equ	fn_times,-54
                 777777 777711    4-51  	equ	fn_difference,-55
                 777777 777710    4-52  	equ	fn_quotient,-56
                 777777 777707    4-53  	equ	fn_abs,-57
                 777777 777706    4-54  	equ	fn_expt,-58
                 777777 777705    4-55  	equ	fn_boole,-59
                 777777 777704    4-56  	equ	fn_rot,-60
                 777777 777703    4-57  	equ	fn_lsh,-61
                 777777 777702    4-58  	equ	fn_signp,-62
                 777777 777701    4-59  	equ	fn_fix,-63
                 777777 777700    4-60  	equ	fn_float,-64
                 777777 777677    4-61  	equ	fn_remainder,-65
                 777777 777676    4-62  	equ	fn_max,-66
                 777777 777675    4-63  	equ	fn_min,-67
                 777777 777674    4-64  	equ	fn_add1_fix,-68
                 777777 777673    4-65  	equ	fn_add1_flo,-69
                 777777 777672    4-66  	equ	fn_sub1_fix,-70
                 777777 777671    4-67  	equ	fn_sub1_flo,-71
                 777777 777670    4-68  	equ	fn_plus_fix,-72
                 777777 777667    4-69  	equ	fn_plus_flo,-73
                 777777 777666    4-70  	equ	fn_times_fix,-74
                 777777 777665    4-71  	equ	fn_times_flo,-75
                 777777 777664    4-72  	equ	fn_diff_fix,-76
                 777777 777663    4-73  	equ	fn_diff_flo,-77
                 777777 777662    4-74  	equ	fn_quot_fix,-78
                 777777 777661    4-75  	equ	fn_quot_flo,-79
                 777777 777660    4-76  	equ	fn_eval,-80
                 777777 777657    4-77  	equ	fn_apply,-81
                 777777 777656    4-78  	equ	fn_prog,-82
                 777777 777655    4-79  	equ	fn_errset,-83
                 777777 777654    4-80  	equ	fn_catch,-84
                 777777 777653    4-81  	equ	fn_throw,-85
                 777777 777652    4-82  	equ	fn_store,-86
                 777777 777651    4-83  	equ	fn_defun,-87
                 777777 777650    4-84  	equ	fn_baktrace,-88
                 777777 777647    4-85  	equ	fn_bltarray,-89
                 777777 777646    4-86  	equ	fn_star_rearray,-90
                 777777 777645    4-87  	equ	fn_gensym,-91
                 777777 777644    4-88  	equ	fn_makunbound,-92
                 777777 777643    4-89  	equ	fn_boundp,-93
                 777777 777642    4-90  	equ	fn_star_status,-94
                 777777 777641    4-91  	equ	fn_star_sstatus,-95
                 777777 777640    4-92  	equ	fn_freturn,-96
                 777777 777637    4-93  	equ	fn_cos,-97
                 777777 777636    4-94  	equ	fn_sin,-98
                 777777 777635    4-95  	equ	fn_exp,-99
                 777777 777634    4-96  	equ	fn_log,-100
                 777777 777633    4-97  	equ	fn_sqrt,-101
                 777777 777632    4-98  	equ	fn_isqrt,-102
                 777777 777631    4-99  	equ	fn_atan,-103
                 777777 777630   4-100  	equ	fn_sleep,-104
                 777777 777627   4-101  	equ	fn_oddp,-105
                 777777 777626   4-102  	equ	fn_tyipeek,-106
                 777777 777625   4-103  	equ	fn_alarmclock,-107
                 777777 777624   4-104  	equ	fn_plusp,-108
                 777777 777623   4-105  	equ	fn_minusp,-109
                 777777 777622   4-106  	equ	fn_ls,-110
                 777777 777621   4-107  	equ	fn_eql,-111
                 777777 777620   4-108  	equ	fn_gt,-112
                 777777 777617   4-109  	equ	fn_alphalessp,-113
                 777777 777616   4-110  	equ	fn_samepnamep,-114
                 777777 777615   4-111  	equ	fn_getchar,-115
                 777777 777614   4-112  	equ	fn_opena,-116
                 777777 777613   4-113  	equ	fn_sxhash,-117
                 777777 777612   4-114  	equ	fn_gcd,-118
                 777777 777611   4-115  	equ	fn_allfiles,-119
                 777777 777610   4-116  	equ	fn_chrct,-120
                 777777 777607   4-117  	equ	fn_close,-121
                 777777 777606   4-118  	equ	fn_deletef,-122
                 777777 777605   4-119  	equ	fn_eoffn,-123
                 777777 777604   4-120  	equ	fn_filepos,-124
                 777777 777603   4-121  	equ	fn_inpush,-125
                 777777 777602   4-122  	equ	fn_linel,-126
                 777777 777601   4-123  	equ	fn_mergef,-127
                 777777 777600   4-124  	equ	fn_namelist,-128
                 777777 777577   4-125  	equ	fn_names,-129
                 777777 777576   4-126  	equ	fn_namestring,-130
                 777777 777575   4-127  	equ	fn_openi,-131
                 777777 777574   4-128  	equ	fn_openo,-132
                 777777 777573   4-129  	equ	fn_prin1,-133
                 777777 777572   4-130  	equ	fn_princ,-134
                 777777 777571   4-131  	equ	fn_print,-135
                 777777 777570   4-132  	equ	fn_read,-136
                 777777 777567   4-133  	equ	fn_readch,-137
                 777777 777566   4-134  	equ	fn_readstring,-138
                 777777 777565   4-135  	equ	fn_rename,-139
                 777777 777564   4-136  	equ	fn_shortnamestring,-140
                 777777 777563   4-137  	equ	fn_tyi,-141
                 777777 777562   4-138  	equ	fn_setsyntax,-142
                 777777 777561   4-139  	equ	fn_cursorpos,-143
                 777777 777560   4-140  	equ	fn_force_output,-144
                 777777 777557   4-141  	equ	fn_clear_input,-145
                 777777 777556   4-142  	equ	fn_random,-146
                 777777 777555   4-143  	equ	fn_haulong,-147
                 777777 777554   4-144  	equ	fn_haipart,-148
                 777777 777553   4-145  	equ	fn_cline,-149
                 777777 777552   4-146  	equ	fn_fillarray,-150
                 777777 777551   4-147  	equ	fn_listarray,-151
                 777777 777550   4-148  	equ	fn_sort,-152
                 777777 777547   4-149  	equ	fn_sortcar,-153
                 777777 777546   4-150  	equ	fn_zerop,-154
                 777777 777545   4-151  	equ	fn_listify,-155
                 777777 777544   4-152  	equ	fn_charpos,-156
                 777777 777543   4-153  	equ	fn_pagel,-157
                 777777 777542   4-154  	equ	fn_linenum,-158
                 777777 777541   4-155  	equ	fn_pagenum,-159
                 777777 777540   4-156  	equ	fn_endpagefn,-160
                 777777 777537   4-157  	equ	fn_arraydims,-161
                 777777 777536   4-158  	equ	fn_loadarrays,-162
                 777777 777535   4-159  	equ	fn_dumparrays,-163
                 777777 777534   4-160  	equ	fn_expt_fix,-164
                 777777 777533   4-161  	equ	fn_expt_flo,-165
                 777777 777532   4-162  	equ	fn_nointerrupt,-166
                 777777 777531   4-163  	equ	fn_open,-167
                 777777 777530   4-164  	equ	fn_in,-168
                 777777 777527   4-165  	equ	fn_out,-169
                 777777 777526   4-166  	equ	fn_truename,-170
                 777777 777525   4-167  	equ	fn_ifix,-171
                 777777 777524   4-168  	equ	fn_fsc,-172
                 777777 777523   4-169  	equ	fn_progv,-173
                 777777 777522   4-170  	equ	fn_mapatoms,-174
                 777777 777521   4-171  	equ	fn_unwind_protect,-175
                 777777 777520   4-172  	equ	fn_eval_when,-176
                 777777 777517   4-173  	equ	fn_read_from_string,-177
                 777777 777516   4-174  	equ	fn_displace,-178
                 777777 777515   4-175  	equ	fn_nth,-179
                 777777 777514   4-176  	equ	fn_nthcdr,-180
                 777777 777513   4-177  	equ	fn_includef,-181
                                 4-178  
                                 4-179  " END INCLUDE FILE lisp_name_codes.incl.alm
                                    55  	include	lisp_object_types
                                   5-1  
                                   5-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   5-3  "
                                   5-4  " D.A.Moon 14 July 72
                                   5-5  
                                   5-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   5-7  "they should be used with cana instructions in the dl mode.
                                   5-8  "
                                   5-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  5-10  
                                  5-11  
                                  5-12  
                        077700    5-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  5-14  
                        040000    5-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    5-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    5-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    5-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    5-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    5-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    5-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    5-22  	bool	String,004000		"points at a lisp character string
                        002000    5-23  	bool	Subr,002000		"points at subr link
                        000400    5-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    5-25  	bool	Array,000200		"points at an array,
                                  5-26  					" which is a special kind of subr
                        067500    5-27  	bool	Unevalable,067500		"any of these bits means
                                  5-28  					" does not have car and cdr
                        001000    5-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    5-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  5-31  
                                  5-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  5-33  
                        040047    5-34  	bool	fixnum_type,040047
                        020047    5-35  	bool	flonum_type,020047
                                  5-36  
                                  5-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                    56  	include	stack_header
                                   6-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   6-2  "
                                   6-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   6-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   6-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   6-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   6-7  
                                   6-8  " HISTORY COMMENTS:
                                   6-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  6-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  6-11  "     added the heap_header_ptr definition
                                  6-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  6-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  6-14  "     Modified to support control point management.  These changes were
                                  6-15  "     actually made in February 1985 by G. Palter.
                                  6-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  6-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  6-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  6-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  6-20  "     some space int the stack header and change the cpd_ptr unal to
                                  6-21  "     cpm_data_ptr (ITS pair).
                                  6-22  "                                                      END HISTORY COMMENTS
                                  6-23  
                        000004    6-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    6-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  6-26  
                        000010    6-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    6-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    6-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    6-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    6-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    6-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    6-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    6-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  6-35  
                        000020    6-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    6-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    6-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    6-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  6-40  
                        000030    6-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    6-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    6-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    6-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  6-45  
                        000040    6-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    6-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    6-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    6-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  6-50  
                        000050    6-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    6-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    6-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    6-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  6-55  
                        000060    6-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    6-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    6-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    6-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    6-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    6-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    6-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    6-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    6-64  	equ	stack_header_end,64			length of stack header
                                  6-65  
                                  6-66  
                                  6-67  
                                  6-68  
                        000000    6-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    6-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  6-71  
                                  6-72  "	The  following constant is an offset within the  pl1  operators table.
                                  6-73  "	It  references a  transfer vector table.
                                  6-74  
                        000551    6-75  	bool	tv_offset,551
                                  6-76  
                                  6-77  
                                  6-78  "	The  following constants are offsets within this transfer vector table.
                                  6-79  
                        001170    6-80  	equ	call_offset,tv_offset+271
                        001171    6-81  	equ	push_offset,tv_offset+272
                        001172    6-82  	equ	return_offset,tv_offset+273
                        001173    6-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    6-84  	equ	entry_offset,tv_offset+275
                                  6-85  
                                  6-86  
                                  6-87  " 	END INCLUDE FILE stack_header.incl.alm
                                    57  	include	stack_frame
                                   7-1  "
                                   7-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   7-3  "
                                   7-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   7-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   7-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   7-7  "
                        000020     7-8  	equ	stack_frame.prev_sp,16
                        000020     7-9  	equ	stack_frame.condition_word,16
                        000022    7-10  	equ	stack_frame.next_sp,18
                        000022    7-11  	equ	stack_frame.signaller_word,18
                        000024    7-12  	equ	stack_frame.return_ptr,20
                        000026    7-13  	equ	stack_frame.entry_ptr,22
                        000030    7-14  	equ	stack_frame.operator_ptr,24
                        000030    7-15  	equ	stack_frame.lp_ptr,24
                        000032    7-16  	equ	stack_frame.arg_ptr,26
                        000034    7-17  	equ	stack_frame.static_ptr,28
                        000035    7-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    7-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    7-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    7-21  	equ	stack_frame.translator_id,31
                        000040    7-22  	equ	stack_frame.regs,32
                        000060    7-23  	equ	stack_frame.min_length,48
                        000020    7-24  	equ	stack_frame.flag_word,16
                        020000    7-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    7-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    7-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    7-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    7-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    7-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    7-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    7-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  7-33  
                                  7-34  "
                                  7-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  7-36  "
                                    58  
                                    59  
                                    60  " routine to set up operator pointers in the stack header
                                    61  " called during initialization of the lisp environment,
                                    62  " every time the 'lisp' command is issued.
                                    63  
                        000000      64  	entry	init
                                    65  
    000000  aa  7 00046 2721 20     66  init:	getlp
    000001  4a  4 00026 3511 20     67  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*	-> stack header
    000002  aa   000140 2370 04     68  	ldaq	gensym_init-*,ic
    000003  aa  1 00042 7571 00     69  	staq	ab|gensym_data		" initialize data for gensym function.
    000004  aa   000140 2370 04     70  	ldaq	fault_tag_3_number_1-*,ic	kill old array store pointer
    000005  aa  1 00010 7571 00     71  	staq	ab|array_pointer
    000006  aa   000142 3520 04     72  	eppbp	array_reference_op-*,ic
    000007  aa  1 00112 2521 00     73  	spribp	ab|array_operator
    000010  aa   000234 3520 04     74  	eppbp	dead_array_reference_op-*,ic
    000011  aa  1 00114 2521 00     75  	spribp	ab|dead_array_operator
    000012  aa   000314 3520 04     76  	eppbp	array_link_snap_op-*,ic
    000013  aa  1 00126 2521 00     77  	spribp	ab|array_link_snap_opr
    000014  aa   000244 3520 04     78  	eppbp	store_op-*,ic
    000015  aa  1 00116 2521 00     79  	spribp	ab|store_operator
    000016  aa   000256 3520 04     80  	eppbp	floating_store_op-*,ic
    000017  aa  1 00120 2521 00     81  	spribp	ab|floating_store_operator
    000020  aa   000126 2370 04     82  	ldaq	fault_tag_3_number_2-*,ic
    000021  aa  1 00122 7571 00     83  	staq	ab|array_info_for_store
    000022  aa   000607 3520 04     84  	eppbp	bind-*,ic
    000023  aa  1 00020 2521 00     85  	spribp	ab|bind_op
    000024  aa   000705 3520 04     86  	eppbp	unbind-*,ic
    000025  aa  1 00022 2521 00     87  	spribp	ab|unbind_op
    000026  aa   000727 3520 04     88  	eppbp	errset1-*,ic
    000027  aa  1 00024 2521 00     89  	spribp	ab|errset1_op
    000030  aa   000730 3520 04     90  	eppbp	errset2-*,ic
    000031  aa  1 00026 2521 00     91  	spribp	ab|errset2_op
    000032  aa   001030 3520 04     92  	eppbp	unerrset-*,ic
    000033  aa  1 00030 2521 00     93  	spribp	ab|unerrset_op
    000034  aa   001034 3520 04     94  	eppbp	call-*,ic
    000035  aa  1 00032 2521 00     95  	spribp	ab|call_op
    000036  aa   001076 3520 04     96  	eppbp	catch1-*,ic
    000037  aa  1 00034 2521 00     97  	spribp	ab|catch1_op
    000040  aa   001077 3520 04     98  	eppbp	catch2-*,ic
    000041  aa  1 00036 2521 00     99  	spribp	ab|catch2_op
    000042  aa   001161 3520 04    100  	eppbp	uncatch-*,ic
    000043  aa  1 00040 2521 00    101  	spribp	ab|uncatch_op
    000044  aa   001165 3520 04    102  	eppbp	iogbind-*,ic
    000045  aa  1 00046 2521 00    103  	spribp	ab|iogbind_op
    000046  aa   001224 3520 04    104  	eppbp	obscene_go_tag-*,ic
    000047  aa  1 00050 2521 00    105  	spribp	ab|unseen_go_tag_op
    000050  aa   001315 3520 04    106  	eppbp	throw1-*,ic
    000051  aa  1 00052 2521 00    107  	spribp	ab|throw1_op
    000052  aa   001316 3520 04    108  	eppbp	throw2-*,ic
    000053  aa  1 00054 2521 00    109  	spribp	ab|throw2_op
    000054  aa   001241 3520 04    110  	eppbp	signp-*,ic
    000055  aa  1 00056 2521 00    111  	spribp	ab|signp_op
    000056  aa   001233 3520 04    112  	eppbp	return-*,ic
    000057  aa  1 00062 2521 00    113  	spribp	ab|return_op
    000060  aa   001276 3520 04    114  	eppbp	err-*,ic
    000061  aa  1 00064 2521 00    115  	spribp	ab|err_op
    000062  aa  1 00044 6501 00    116  	sprilp	ab|system_lp		set up for later use.
    000063  aa   000437 3520 04    117  	eppbp	pl1_interfacer-*,ic
    000064  aa  1 00066 2521 00    118  	spribp	ab|pl1_interface
    000065  aa   000430 3520 04    119  	eppbp	pl1_lsubr_interfacer-*,ic
    000066  aa  1 00070 2521 00    120  	spribp	ab|pl1_lsubr_interface
    000067  4a  4 00030 3521 20    121  	eppbp	<lisp_alloc_>|[cons_opr]
    000070  aa  1 00072 2521 00    122  	spribp	ab|cons_op
    000071  4a  4 00032 3521 20    123  	eppbp	<lisp_alloc_>|[ncons_opr]
    000072  aa  1 00074 2521 00    124  	spribp	ab|ncons_op
    000073  4a  4 00034 3521 20    125  	eppbp	<lisp_alloc_>|[xcons_opr]
    000074  aa  1 00076 2521 00    126  	spribp	ab|xcons_op
    000075  4a  4 00036 3521 20    127  	eppbp	<lisp_alloc_>|[begin_list_opr]
    000076  aa  1 00100 2521 00    128  	spribp	ab|begin_list_op
    000077  4a  4 00040 3521 20    129  	eppbp	<lisp_alloc_>|[append_list_opr]
    000100  aa  1 00102 2521 00    130  	spribp	ab|append_list_op
    000101  4a  4 00042 3521 20    131  	eppbp	<lisp_alloc_>|[terminate_list_opr]
    000102  aa  1 00104 2521 00    132  	spribp	ab|terminate_list_op
    000103  0a   001335 3520 00    133  	eppbp	compare
    000104  aa  1 00106 2521 00    134  	spribp	ab|compare_op
    000105  0a   000562 3520 00    135  	eppbp	link_operator
    000106  aa  1 00110 2521 00    136  	spribp	ab|link_opr
    000107  aa   040047 2350 07    137  	lda	fixnum_type,dl
    000110  aa   020047 2360 07    138  	ldq	flonum_type,dl
    000111  aa  1 00060 7571 00    139  	staq	ab|type_fields
    000112  4a  4 00044 3521 20    140  	eppbp	<lisp_alloc_>|[cons_string]
    000113  aa  1 00136 2521 00    141  	spribp	ab|cons_string_op
    000114  0a   001603 3520 00    142  	eppbp	pl1_call_operator
    000115  aa  1 00134 2521 00    143  	spribp	ab|pl1_call_op
    000116  0a   001444 3520 00    144  	eppbp	create_string_descriptor
    000117  aa  1 00130 2521 00    145  	spribp	ab|create_string_desc_op
    000120  0a   001462 3520 00    146  	eppbp	create_varying_string
    000121  aa  1 00140 2521 00    147  	spribp	ab|create_varying_string_op
    000122  0a   001521 3520 00    148  	eppbp	create_array_descriptor
    000123  aa  1 00132 2521 00    149  	spribp	ab|create_array_desc_op
    000124  aa   001546 3520 04    150  	eppbp	unwind_protect-*,ic
    000125  aa  1 00142 2521 00    151  	spribp	ab|unwp1_op
    000126  aa  1 00144 2521 00    152  	spribp	ab|unwp2_op
    000127  0a   001707 3520 00    153  	eppbp	unwind_protect_end
    000130  aa  1 00146 2521 00    154  	spribp	ab|ununwp_op
    000131  0a   001726 3520 00    155  	eppbp	irest_return
    000132  aa  1 00150 2521 00    156  	spribp	ab|irest_return_op
    000133  0a   001621 3520 00    157  	eppbp	pl1_call_nopop
    000134  aa  1 00152 2521 00    158  	spribp	ab|pl1_call_nopop_op
    000135  0a   001631 3520 00    159  	eppbp	rcv_char_star
    000136  aa  1 00154 2521 00    160  	spribp	ab|rcv_char_star_op
    000137  aa  7 00044 7101 20    161  	short_return
    000140                         162  patch_instruction:
    000140  aa  1 00032 7101 20    163  	tra	ab|call_op,*
    000141  aa   000000 0110 03    164  	even
    000142                         165  gensym_init:
    000142  aa  147 000 000 000    166  	aci	"g"
    000143  aa   000000 000000     167  	dec	0
                                   168  
                                   169  """ Operators having to do with arrays.
                                   170  
                                   171  	even
    000144                         172  fault_tag_3_number_1:
    000144  aa   000001 0000 47    173  	arg	1,f3
    000145  aa   000000 0000 00    174  	arg	0
    000146                         175  fault_tag_3_number_2:
    000146  aa   000002 0000 47    176  	arg	2,f3
    000147  aa   000000 0000 00    177  	arg	0
                                   178  
    000150                         179  array_reference_op:
    000150  aa  1 00044 3715 20    180  	epplb	ab|system_lp,*			check for *rset t mode
                        000010     181  	link	star_rset,<lisp_static_vars_>|[star_rset],*
    000151  4a  5 00010 2371 20    182  	ldaq	lb|star_rset,*
    000152  aa  3 00000 3715 20    183  	epplb	bb|array_data_ptr-2,*		-> array_data block (dope vector)
    000153  aa  3 00005 7241 00    184  	lxl4	bb|array_info.2ndims-2		number of subscripts * -2
    000154  aa   000026 6000 04    185  	tze	external_array_reference-*,ic		tra if ext array flag set
    000155  aa  1 00012 1171 00    186  	cmpaq	ab|nil
    000156  aa   000013 6010 04    187  	tnz	array_ref_with_full_checking-*,ic
                                   188  
    000157                         189  array_ref_without_checking:
    000157  aa   000000 6360 00    190  	eaq	0				compute offset in q
                                   191  
    000160  aa  0 00001 0761 14    192  	adq	ap|1,x4				add in a subscript
    000161  aa  5 00001 4021 14    193  	mpy	lb|1,x4				multiply by multiplier
    000162  aa   000002 6240 14    194  	eax4	2,x4
    000163  aa   777775 6010 04    195  	tnz	-3,ic
                                   196  
    000164  aa  3 00005 7241 00    197  	lxl4	bb|array_info.2ndims-2		pop subscripts off stack
    000165  aa  0 00000 3501 14    198  	eppap	ap|0,x4				..
                                   199  
    000166  aa  1 00122 2535 00    200  	spribb	ab|array_info_for_store		save data for store
    000167  aa  1 00124 7561 00    201  	stq	ab|array_offset_for_store
    000170  aa  3 00002 7101 00    202  	tra	bb|array_load_sequence-2		use code in array to load and return
                                   203  
    000171                         204  array_ref_with_full_checking:
                                   205  
    000171                         206  array_checking_loop:
    000171  aa  0 00000 2371 14    207  	ldaq	ap|0,x4				get a subscript
    000172  aa   040047 1150 07    208  	cmpa	fixnum_type,dl			fixnum?
    000173  aa   000024 6010 04    209  	tnz	bad_subscript-*,ic			no, barf
    000174  aa  5 00000 1161 14    210  	cmpq	lb|0,x4				compare against bounds
    000175  aa   000022 6030 04    211  	trc	bad_subscript-*,ic			out of bounds or negative
    000176  aa   000002 6240 14    212  	eax4	2,x4
    000177  aa   777772 6010 04    213  	tnz	array_checking_loop-*,ic
    000200  aa  3 00005 7241 00    214  	lxl4	bb|array_info.2ndims-2		number of subscripts * -2
    000201  aa   777756 7100 04    215  	tra	array_ref_without_checking-*,ic	reference is OK, proceed.
                                   216  
    000202                         217  external_array_reference:
    000202  aa  1 00012 1171 00    218  	cmpaq	ab|nil
    000203  aa   000006 6000 04    219  	tze	ext_array_ref_no_check-*,ic
    000204  aa  0 77776 2371 00    220  	ldaq	ap|-2			check bound
    000205  aa   040047 1150 07    221  	cmpa	fixnum_type,dl
    000206  aa   000011 6010 04    222  	tnz	bad_subscript-*,ic
    000207  aa  3 00002 1161 00    223  	cmpq	bb|array_load_sequence-2	which is stored in kludgey way
    000210  aa   000007 6030 04    224  	trc	bad_subscript-*,ic		out of bounds or negative
    000211                         225  ext_array_ref_no_check:
    000211  aa  0 77777 2361 00    226  	ldq	ap|-1			get subscript
    000212  aa  0 77776 3501 00    227  	eppap	ap|-2			pop subscript
    000213  aa  1 00122 2535 00    228  	spribb	ab|array_info_for_store	save data for store
    000214  aa  1 00124 7561 00    229  	stq	ab|array_offset_for_store
    000215  aa   040047 2350 07    230  	lda	fixnum_type,dl		ext arrays are always fixnum
    000216  aa  3 00003 7101 00    231  	tra	bb|array_load_sequence-2+1	use code in array to load and return
                                   232  
    000217                         233  bad_subscript:
    000217  4a  4 00046 7211 20    234  	lxl1	<lisp_error_table_>|[bad_array_subscript]	better not need lp
    000220                         235  array_reference_err:
    000220  aa  0 00004 3501 00    236  	eppap	ap|4		get set to push args to lisp_error_
    000221  aa  0 77776 7571 00    237  	staq	ap|-2		the bad subscript
    000222  aa  3 77776 3535 00    238  	eppbb	bb|-2		the array pointer
    000223  aa  7 00024 2535 20    239  	spribb	sb|stack_header.stack_end_ptr,*
    000224  aa  7 00024 2371 20    240  	ldaq	sb|stack_header.stack_end_ptr,*
    000225  aa   000243 2750 07    241  	ora	Array+35,dl	turn on array type bit and its tag
    000226  aa  0 77774 7571 00    242  	staq	ap|-4
    000227  aa  0 77776 2371 00    243  	ldaq	ap|-2		make list of array pointer and subscript
    000230  aa  1 00074 2721 20    244  	tspbp	ab|ncons_op,*
    000231  aa  0 77776 2535 00    245  	spribb	ap|-2
    000232  aa  0 77774 2371 00    246  	ldaq	ap|-4
    000233  aa  1 00072 2721 20    247  	tspbp	ab|cons_op,*
    000234  aa  0 77776 2371 00    248  	ldaq	ap|-2
    000235  aa  3 00002 7571 00    249  	staq	bb|2
    000236  aa  0 77776 3501 00    250  	eppap	ap|-2
    000237  aa  0 77776 2535 00    251  	spribb	ap|-2
    000240  aa   000000 6350 11    252  	eaa	0,x1		get error code.
    000241  aa   000022 7710 00    253  	arl	18
    000242  aa   000126 3360 07    254  	lcq	-fn_store,dl	if fn code requuired, was store
    000243  aa   000211 7000 04    255  	tsx0	Lisp_Error-*,ic	go signal uncorrectable error.
                                   256  
    000244                         257  dead_array_reference_op:
    000244  aa  0 00002 3501 00    258  	eppap	ap|2		will pass array pointer to lisp_error_
    000245  aa  3 77776 3535 00    259  	eppbb	bb|-2		the array pointer
    000246  aa  7 00024 2535 20    260  	spribb	sb|stack_header.stack_end_ptr,*
    000247  aa  7 00024 2371 20    261  	ldaq	sb|stack_header.stack_end_ptr,*
    000250  aa   000243 2750 07    262  	ora	Array+35,dl
    000251  aa  0 77776 7571 00    263  	staq	ap|-2
    000252  4a  4 00050 2351 20    264  	lda	<lisp_error_table_>|[dead_array_reference]	better not need lp
    000253  aa  3 00005 2211 00    265  	ldx1	bb|array_info.type-2	perhaps is really a readtable
    000254  aa   000004 1010 03    266  	cmpx1	Readtable_array,du
    000255  aa   000002 6010 04    267  	tnz	2,ic
    000256  4a  4 00052 2351 20    268  	 lda	 <lisp_error_table_>|[cant_subscript_readtable]	better not need lp
    000257  aa   000175 7000 04    269  	tsx0	Lisp_Error-*,ic	go signal uncorrectable error.
                                   270  
                                   271  
                                   272  """ compiled store comes here.  locations in stack header have been set up
                                   273  """ by a previous array reference.  value to store is in aq. (or just q if
                                   274  """ compiler knows it to be a fixnum or flonum array)
                                   275  
    000260  aa  1 00122 3535 20    276  store_op:	eppbb	ab|array_info_for_store,*	-> array_info, fault if bad.
    000261  aa  1 00124 7211 00    277  	lxl1	ab|array_offset_for_store	get index value
    000262  aa  3 00005 2201 00    278  	ldx0	bb|array_info.type-2	get array type
    000263  0a   000265 7160 10    279  	xec	store_table,x0		do store seq. depending on type
    000264  aa  2 00000 7101 00    280  	tra	bp|0			and return.  aq is unchanged.
                                   281  
    000265                         282  store_table:
    000265  aa  3 00000 7571 71    283  	staq	bb|array_data_ptr-2,*x1	S-expr array
    000266  aa  3 00000 7571 71    284  	staq	bb|array_data_ptr-2,*x1	Un-gc array
    000267  aa  3 00000 7561 71    285  	stq	bb|array_data_ptr-2,*x1	fixnum array
    000270  aa  3 00000 7561 71    286  	stq	bb|array_data_ptr-2,*x1	flonum array
    000271  0a   000324 7100 00    287  	tra	not_allowed_to_store	readtable
    000272  0a   000324 7100 00    288  	tra	not_allowed_to_store	obarray
    000273  0a   000324 7100 00    289  	tra	store_into_dead_array	dead.
                                   290  
                                   291  " operator similar to store_op but value to be stored is in EAQ.
                                   292  " type checking is performed.
                                   293  
    000274                         294  floating_store_op:
    000274  aa  1 00122 3535 20    295  	eppbb	ab|array_info_for_store,*
    000275  aa  1 00124 7211 00    296  	lxl1	ab|array_offset_for_store
    000276  aa  3 00005 2201 00    297  	ldx0	bb|array_info.type-2
    000277  0a   000301 7160 10    298  	xec	floating_store_table,x0
    000300  aa  2 00000 7101 00    299  	tra	bp|0
                                   300  
    000301                         301  floating_store_table:
    000301  0a   000315 7100 00    302  	tra	move_EAQ_to_Q_then_store
    000302  0a   000315 7100 00    303  	tra	move_EAQ_to_Q_then_store
    000303  0a   000310 7100 00    304  	tra	not_allowed_to_store_f		flonum -> fixnum array
    000304  aa  3 00000 4701 71    305  	fstr	bb|array_data_ptr-2,*x1		flonum -> flonum array
    000305  0a   000310 7100 00    306  	tra	not_allowed_to_store_f
    000306  0a   000310 7100 00    307  	tra	not_allowed_to_store_f
    000307  0a   000310 7100 00    308  	tra	not_allowed_to_store_f
                                   309  
    000310                         310  not_allowed_to_store_f:
    000310  aa   000002 6270 17    311  	eax7	2,x7
    000311  aa  1 77777 4701 17    312  	fstr	ab|-1,x7
    000312  aa  1 77777 2361 17    313  	ldq	ab|-1,x7
    000313  aa   020047 2350 07    314  	lda	flonum_type,dl
    000314  aa   000010 7100 04    315  	tra	not_allowed_to_store-*,ic
                                   316  
    000315                         317  move_EAQ_to_Q_then_store:
    000315  aa   000002 6270 17    318  	eax7	2,x7
    000316  aa  1 77777 4701 17    319  	fstr	ab|-1,x7
    000317  aa  1 77777 2361 17    320  	ldq	ab|-1,x7
    000320  aa   020047 2350 07    321  	lda	flonum_type,dl
    000321  aa   777776 6270 17    322  	eax7	-2,x7
    000322  aa  3 00000 7571 71    323  	staq	bb|array_data_ptr-2,*x1
    000323  aa  2 00000 7101 00    324  	tra	bp|0
                                   325  
    000324                         326  not_allowed_to_store:  store_into_dead_array:
    000324  4a  4 00054 7211 20    327  	lxl1	<lisp_error_table_>|[store_not_allowed]		better not need lp
    000325  aa   777673 7100 04    328  	tra	array_reference_err-*,ic
                                   329  
                                   330  
                                   331  """ This operator is used by compiled code to get an array pointer
                                   332  """ from an atomic symbol which is alleged to be the name of an array
                                   333  """ It is called by xec'ing a 4-word block in the comp_subr_block,
                                   334  """ which contains a tspbp to this operator
                                   335  """ and a word in the form  vfd 9/type,9/ndims,18/constant
                                   336  """ constant is the offset relative to lp (in the constants area)
                                   337  """ of the atomic symbol which names the array.
                                   338  """ The first word in the block is changed to eppbb *+2,*
                                   339  """ and the last words are changed to point to the array_info block.
                                   340  
                                   341  """ Registers:
                                   342  """	lp = caller's lp
                                   343  """	bp -> calling xec instruction + 1
                                   344  """	lb = system lp
                                   345  """	bb = clobberable, set on return to -> array_info
                                   346  """	aq and x5 are unchanged.
                                   347  
                        000012     348  	link	array_atom,<lisp_static_vars_>|[array_atom]
                        000014     349  	link	no_snapped_links_flag,<lisp_static_vars_>|[no_snapped_links]
                                   350  
    000326                         351  array_link_snap_op:
    000326  aa  1 00044 3715 20    352  	epplb	ab|system_lp,*
    000327  aa  0 00002 3501 00    353  	eppap	ap|2		save aq
    000330  aa  0 77776 7571 00    354  	staq	ap|-2
    000331  aa  2 77777 2211 00    355  	ldx1	bp|-1		-> array_link block (relative to lp)
    000332  aa   077777 3610 03    356  	anx1	=o077777,du
    000333  aa  4 00001 7201 11    357  	lxl0	lp|1,x1		offset from lp to symbol naming array
    000334  aa  4 00000 3535 30    358  	eppbb	lp|0,x0*		-> symbol
    000335                         359  continue_array_search:
    000335  aa  3 00002 2371 00    360  	ldaq	bb|2
    000336  aa   077700 3150 07    361  	cana	lisp_ptr.type,dl	end?
    000337  aa   000037 6010 04    362  	tnz	couldnt_snap_array_link-*,ic
    000340  aa  3 00002 3535 20    363  	eppbb	bb|2,*		next piece of property list
    000341  aa  3 00000 2371 00    364  	ldaq	bb|0
    000342  4a  5 00012 1171 20    365  	cmpaq	lb|array_atom,*
    000343  aa   777772 6010 04    366  	tnz	continue_array_search-*,ic
    000344  aa  3 00002 3535 20    367  	eppbb	bb|2,*
    000345  aa  3 00000 3535 20    368  	eppbb	bb|0,*		array pointer
    000346  aa  4 00001 2201 11    369  	ldx0	lp|1,x1		ndims
    000347  aa   000777 3600 03    370  	anx0	=o000777,du
    000350  aa  3 00000 1001 00    371  	cmpx0	bb|array_info.ndims
    000351  aa   000025 6010 04    372  	tnz	couldnt_snap_array_link-*,ic
    000352  aa  4 00001 2351 11    373  	lda	lp|1,x1		get required type
    000353  aa   000033 7710 00    374  	arl	27
    000354  aa   000017 6000 04    375  	tze	check_for_Sexpr_array-*,ic
    000355  aa   000000 6200 05    376  	eax0	0,al
    000356  aa  3 00007 1001 00    377  	cmpx0	bb|array_info.type	check against actual type
    000357  aa   000017 6010 04    378  	tnz	couldnt_snap_array_link-*,ic
    000360                         379  could_snap_array_link:
    000360  aa  4 00002 2535 11    380  	spribb	lp|2,x1		snap the link
    000361  4a  5 00014 4501 00    381  	stz	lb|no_snapped_links_flag
    000362  aa   777777 6350 00    382  	eaa	-1
    000363  aa  4 77772 3551 00    383  	ansa	lp|-6		turn off flags for unlinker
    000364  aa   000002 6350 11    384  	eaa	2,x1
    000365  aa   000005 2750 04    385  	ora	link_snap_instruction-*,ic
    000366  aa  4 00000 7551 11    386  	sta	lp|0,x1		put in eppbb instruction
    000367  aa  0 77776 2371 00    387  	ldaq	ap|-2		restore aq
    000370  aa  0 77776 3501 00    388  	eppap	ap|-2
    000371  aa  2 00000 7101 00    389  	tra	bp|0		exit.  bb has been set.
                                   390  
    000372  aa  4 00000 3535 20    391  link_snap_instruction:  eppbb lp|0,*
                                   392  
    000373                         393  check_for_Sexpr_array:
    000373  aa  3 00007 2201 00    394  	ldx0	bb|array_info.type
    000374  0a   000405 2340 10    395  	szn	ok_to_link_table,x0
    000375  aa   777763 6010 04    396  	tnz	could_snap_array_link-*,ic
    000376                         397  couldnt_snap_array_link:
    000376  aa  4 00001 7201 11    398  	lxl0	lp|1,x1
    000377  aa  4 00000 2371 10    399  	ldaq	lp|0,x0		name of array
    000400  aa  0 00002 3501 00    400  	eppap	ap|2
    000401  aa  0 77776 7571 00    401  	staq	ap|-2
    000402  4a  4 00056 2351 20    402  	lda	<lisp_error_table_>|[not_an_array]		better not need lp
    000403  aa   000000 6360 00    403  	eaq	0		"function ? wanted an array, not foo"
    000404  aa   000050 7100 04    404  	tra	Lisp_Error-*,ic
                                   405  
                                   406  
    000405                         407  ok_to_link_table:
    000405  aa   000000 000001     408  	vfd	36/1,36/1,36/0,36/0,36/0,36/1,36/0
    000406  aa   000000 000001 
    000407  aa   000000 000000 
    000410  aa   000000 000000 
    000411  aa   000000 000000 
    000412  aa   000000 000001 
    000413  aa   000000 000000 
                                   409  
                                   410  """ Interpreted store function.  similar to store operator
                                   411  """	but makes more checks.
                                   412  
                        000414     413  	segdef	store
                                   414  
    000414  aa  0 00004 3501 00    415  store:	eppap	ap|4		extract args from arglist (fsubr)
    000415  aa  0 77772 3535 20    416  	eppbb	ap|-6,*		-> arglist
    000416  aa  3 00002 2371 20    417  	ldaq	bb|2,*		cadr is 2nd arg
    000417  aa  0 77776 7571 00    418  	staq	ap|-2
    000420  aa  3 00000 2371 00    419  	ldaq	bb|0		car is 1st arg
    000421  aa  0 77774 7571 00    420  	staq	ap|-4
    000422  aa   000010 6270 17    421  	eax7	8,x7		going to make two calls to eval
    000423  aa  1 77774 6501 17    422  	sprilp	ab|his_lp,x7
    000424  aa   777776 6250 00    423  	eax5	-2
    000425  aa  1 77776 3571 17    424  	stcd	ab|his_bp,x7
    000426  4a  4 00060 7101 20    425  	tra	<lisp_>|[eval_]	evaluate 2nd arg
    000427  aa  0 77774 7571 00    426  	staq	ap|-4		save the value to be stored
    000430  aa  1 77774 6501 17    427  	sprilp	ab|his_lp,x7
    000431  aa   777776 6250 00    428  	eax5	-2
    000432  aa  1 77776 3571 17    429  	stcd	ab|his_bp,x7
    000433  4a  4 00060 7101 20    430  	tra	<lisp_>|[eval_]	evaluate first arg (array reference)
                                   431  
    000434  aa  0 77776 2371 00    432  	ldaq	ap|-2		pick up value to be stored
    000435  aa  0 77776 3501 00    433  	eppap	ap|-2		clear the stack
    000436  aa  1 00122 3535 20    434  	eppbb	ab|array_info_for_store,*	get ptr to array_info block
    000437  aa  1 00124 7211 00    435  	lxl1	ab|array_offset_for_store	get subscript
    000440  aa  3 00005 2201 00    436  	ldx0	bb|array_info.type-2	check type of array and of value to store
    000441  0a   000445 7160 10    437  	xec	store_test,x0
    000442  aa   777662 6010 04    438  	tnz	not_allowed_to_store-*,ic	type mismatch
    000443  0a   000265 7160 10    439  	xec	store_table,x0	OK to store, do so.
    000444  aa   000645 7100 04    440  	tra	return-*,ic
                                   441  
    000445                         442  store_test:
    000445  aa   000000 6220 00    443  	eax2	0		S-expr - can always store
    000446  aa   000000 6220 00    444  	eax2	0		Un-gc - can always store
    000447  aa   040047 1150 07    445  	cmpa	fixnum_type,dl	Fixnum
    000450  aa   020047 1150 07    446  	cmpa	flonum_type,dl	Flonum
    000451  0a   000324 7100 00    447  	tra	not_allowed_to_store  Readtable
    000452  0a   000324 7100 00    448  	tra	not_allowed_to_store  Obarray
    000453  0a   000324 7100 00    449  	tra	store_into_dead_array Dead
                                   450  
                                   451  """ Routine to signal a LISP error
                                   452  
    000454                         453  Lisp_Error:
    000454  aa   000010 6270 17    454  	eax7	8,x7		save bp, lp, bb, lb, x0, and room to push error code.
    000455  aa  1 77770 5421 17    455  	sprpbp	ab|-8,x7
    000456  aa  1 77771 5441 17    456  	sprplp	ab|-7,x7
    000457  aa  1 77772 5431 17    457  	sprpbb	ab|-6,x7
    000460  aa  1 77773 5451 17    458  	sprplb	ab|-5,x7
    000461  aa  1 77774 7401 17    459  	stx0	ab|-4,x7
                                   460  
    000462  aa  1 77776 7571 17    461  	staq	ab|-2,x7		error code, fn code
                                   462  
                                   463  " prepare to call pl1 program
                                   464  
                                   465  	enter_pl1_code	push
    000463  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    000464  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    000465  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    000466  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    000467  aa   000060 6270 00         	push	
    000470  aa  7 00040 2721 20
    000471  4a  4 00066 3521 20         	eppbp	lisp_subr_tv_$..lisp..
    000472  aa  6 00026 2521 00         	spribp	sp|stack_frame.entry_ptr
    000473  aa   000065 3500 04    466  	eppap	null_argl-*,ic		pass no args to pl1 error routine.
    000474  4a  4 00070 3521 20    467  	short_call lisp_error_$lisp_error_
    000475  aa  7 00036 6701 20
    000476  aa  6 00030 3701 20
                                   468  	exit_pl1_code	pop
    000477  aa  6 00000 3521 00         	eppbp	sp|0
    000500                              	inhibit	on
    000500  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    000501  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    000502                              	inhibit	off
    000502  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    000503  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    000504  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    000505  aa  1 00016 4501 00         	stz	ab|in_pl1_code
                                   469  
    000506  aa  1 77776 2201 17    470  	ldx0	ab|-2,x7		restore saved registers
    000507  aa  1 77775 7651 17    471  	lprplb	ab|-3,x7
    000510  aa  1 77774 7631 17    472  	lprpbb	ab|-4,x7
    000511  aa  1 77773 7641 17    473  	lprplp	ab|-5,x7
    000512  aa  1 77772 7621 17    474  	lprpbp	ab|-6,x7
    000513  aa   777772 6270 17    475  	eax7	-6,x7
                                   476  
    000514  aa   000000 7100 10    477  	tra	0,x0		return from call to Lisp_Error
                                   478  
                                   479  " two routines which are the operators for pl1 compiled subrs.
                                   480  " These routines generate a standard Multics call, and keep track
                                   481  " of the lisp stacks so that interrupts can be handled correctly.
                                   482  " The calling sequence, which appears in the subr block in the lisp
                                   483  " static storage segment, is:
                                   484  "
                                   485  "	eax7	2,x7
                                   486  "	spribp	ab|-2,x7
                                   487  "	tspbp	ab|pl1_interface_op,*	for the appropiate interface....
                                   488  "	its	<routine>			link to routine....
                                   489  "
    000515                         490  pl1_lsubr_interfacer:
    000515  aa  0 00002 3501 00    491  	eppap	ap|2			get room for saving x5.
    000516  aa   000000 6360 15    492  	eaq	0,x5
    000517  aa   000022 7320 00    493  	qrs	18
    000520  aa   040047 2350 07    494  	lda	fixnum_type,dl
    000521  aa  0 77776 7571 00    495  	staq	ap|-2
    000522                         496  pl1_interfacer:
    000522  aa   000004 6270 17    497  	eax7	4,x7			get room to save lp
    000523  aa  1 77774 6501 17    498  	sprilp	ab|-4,x7			save callers lp
    000524  aa  2 00000 3701 20    499  	epplp	bp|0,*			get pointer to pl1 entry to call.
    000525  aa  1 77776 6501 17    500  	sprilp	ab|-2,x7			and save through the save sequence.
                                   501  	enter_pl1_code	push
    000526  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    000527  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    000530  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    000531  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    000532  aa   000060 6270 00         	push	
    000533  aa  7 00040 2721 20
    000534  4a  4 00066 3521 20         	eppbp	lisp_subr_tv_$..lisp..
    000535  aa  6 00026 2521 00         	spribp	sp|stack_frame.entry_ptr
    000536  4a  4 00026 3521 20    502  	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
    000537  aa   000021 3500 04    503  	eppap	null_argl-*,ic			must set up arg list.
    000540  aa  2 77776 3521 20    504  	short_call bp|-2,*			call the target fo the call.
    000541  aa  7 00036 6701 20
    000542  aa  6 00030 3701 20
                                   505  	exit_pl1_code	pop
    000543  aa  6 00000 3521 00         	eppbp	sp|0
    000544                              	inhibit	on
    000544  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    000545  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    000546                              	inhibit	off
    000546  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    000547  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    000550  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    000551  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    000552  aa  1 77774 3701 37    506  	epplp	ab|-4,x7*
    000553  aa  1 77772 3521 37    507  	eppbp	ab|-6,x7*
    000554  aa   777772 6270 17    508  	eax7	-6,x7
    000555  aa  0 77776 2371 00    509  	ldaq	ap|-2
    000556  aa  0 77776 3501 00    510  	eppap	ap|-2
    000557  aa  2 00000 7101 00    511  	tra	bp|0
                                   512  	even
    000560  aa   000000 000004     513  null_argl:oct	4,0
    000561  aa   000000 000000 
                                   514  
                                   515  
                                   516  
                                   517  " link opertor for compiled code
                                   518  
    000562                         519  link_operator:
    000562  aa   000010 6270 17    520  	eax7	8,x7
    000563  aa  1 77770 5441 17    521  	sprplp	ab|-8,x7
    000564  aa  1 77771 7401 17    522  	stx0	ab|-7,x7
    000565  aa  1 77771 4451 17    523  	sxl5 	ab|-7,x7
    000566  aa  4 77777 3521 00    524  	eppbp	lp|-1
    000567  aa  2 00000 0521 00    525  	adwpbp	bp|0		" get pointer to itp.
    000570  aa  1 77772 2521 17    526  	spribp	ab|-6,x7
    000571  aa  1 77772 3521 17    527  	eppbp	ab|-6,x7
    000572  aa  1 77776 2521 17    528  	spribp	ab|-2,x7
    000573  0a   000627 2370 00    529  	ldaq	one_arg
    000574  aa  1 77774 7571 17    530  	staq	ab|-4,x7
                                   531  	enter_pl1_code	push
    000575  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    000576  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    000577  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    000600  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    000601  aa   000060 6270 00         	push	
    000602  aa  7 00040 2721 20
    000603  4a  4 00066 3521 20         	eppbp	lisp_subr_tv_$..lisp..
    000604  aa  6 00026 2521 00         	spribp	sp|stack_frame.entry_ptr
    000605  4a  4 00026 3501 20    532  	eppap	lisp_static_vars_$unmkd_ptr,*
    000606  aa  0 77774 3501 00    533  	eppap	ap|-4
    000607  4a  4 00074 3521 20    534  	short_call lisp_linker_$lisp_linker_
    000610  aa  7 00036 6701 20
    000611  aa  6 00030 3701 20
                                   535  	exit_pl1_code	pop
    000612  aa  6 00000 3521 00         	eppbp	sp|0
    000613                              	inhibit	on
    000613  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    000614  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    000615                              	inhibit	off
    000615  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    000616  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    000617  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    000620  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    000621  aa  1 77770 7641 17    536  	lprplp	ab|-8,x7
    000622  aa  1 77771 2201 17    537  	ldx0	ab|-7,x7
    000623  aa  1 77771 7251 17    538  	lxl5	ab|-7,x7
    000624  aa  1 77772 3521 37    539  	eppbp	ab|-6,x7*
    000625  aa   777770 6270 17    540  	eax7	-8,x7
    000626  aa  2 00000 7101 20    541  	tra	bp|0,*
                                   542  
    000627  aa   000002 000004     543  one_arg:	zero	2,4
    000630  aa   000000 000000     544  	zero	0,0
                                   545  
                                   546  " bind operator.
                                   547  " the calling tspbp is followed by a word with 4*number bindings in
                                   548  " left half
                                   549  " Following this is one word for each binding, in the form:
                                   550  "	vfd	3/flags, 15/atom_loc, 18/value_loc
                                   551  " where atom_loc is offset from lp of ptr to atom, value_loc is
                                   552  " offset of new value to be given it, flags tells where value_loc
                                   553  " is offset from: 0=ab, 1=ap, 2=lp, 3=addr of this word (bp)
                                   554  "    If flags is >3, means one of these special cases:
                                   555  "	4  bind the argatom according to x5 (for compiled lexpr's)
                                   556  "			(atom_loc better be 0!!!)
                                   557  "	5  obtain value from x5 (for compiled lexpr's)
                                   558  "	6  same as 1 except take the car of the value
                                   559  "	7  same as 2 except take the car of the value
                                   560  "
                                   561  "   NB: offset from ap is from ap after 4*number_bindings
                                   562  "       has been added to it.
                                   563  " The marked pdl portion of the binding block is allocated
                                   564  " by this operator, and the unmarked pdl portion
                                   565  " must be allocated here.
                                   566  " this operator destroys the contents of aq and all the index registers
                                   567  "
                                   568  " Usage of index registers in this operator:
                                   569  "
                                   570  " x0   not used
                                   571  " x1   temp.
                                   572  " x2   saves value of ap when operator was called
                                   573  " x3   counts number of bindings to be done
                                   574  " x4   points at current 4-word slot in binding block
                                   575  " x5   not changed, for flags = 4 or 5, should be -2*#args to lsubr
                                   576  " x6   temp
                                   577  " x7   unmarked pdl ptr, as usual
                                   578  "
                                   579  " Pointer Registers
                                   580  "
                                   581  " bp -> control words in caller
                                   582  " lp    left as caller's lp
                                   583  " lb    system lp
                                   584  " bb    temporary
                                   585  
                                   586  
                        000016     587  	link	binding_top_plus_1,<lisp_static_vars_>|[binding_top]+1
                        000020     588  	link	argatom,<lisp_static_vars_>|[argatom]
                                   589  
    000631                         590  bind:
    000631  aa   000002 6270 17    591  	eax7	2,x7			room for binding block
    000632  aa  1 00044 3715 20    592  	epplb	ab|system_lp,*
    000633  aa  2 00000 2231 00    593  	ldx3	bp|0			4*number_bindings
    000634  aa  2 00000 3241 00    594  	lcx4	bp|0			offset of first binding from top of stack
    000635  aa  0 00000 6221 00    595  	eax2	ap|0			save ap in case of flags=4
    000636  aa  0 00000 3501 13    596  	eppap	ap|0,x3			make room for binding block.
    000637  4a  5 00016 2361 20    597  	ldq	lb|binding_top_plus_1,*	make binding block
    000640  aa  1 77777 7561 17    598  	stq	ab|-1,x7			binding_block.back_ptr (clear rev_ptr)
    000641  aa  1 77776 7421 17    599  	stx2	ab|-2,x7			set binding_block.top_block
    000642  aa  1 77776 4421 17    600  	sxl2	ab|-2,x7			set binding_block.bot_block
    000643  aa  1 77776 6211 17    601  	eax1	ab|-2,x7			and thread onto list of binding blocks
    000644  4a  5 00016 7411 20    602  	stx1	lb|binding_top_plus_1,*
                                   603  
    000645                         604  bind_loop:
    000645  aa  2 00001 3521 00    605  	eppbp	bp|1			-> next binding descrip word
    000646  aa  2 00000 2211 00    606  	ldx1	bp|0			get atom to be bound
    000647  aa   077777 3610 03    607  	anx1	=o077777,du
    000650  aa   000035 6000 04    608  	tze	flags4-*,ic		not an atom (for flags=4)
    000651  aa  4 00000 2371 11    609  	ldaq	lp|0,x1
    000652  aa  0 00002 7571 14    610  	staq	ap|2,x4
    000653  aa  0 00002 2371 34    611  	ldaq	ap|2,x4*
    000654  aa  0 00000 7571 14    612  	staq	ap|0,x4			save old value
    000655  aa   000004 6240 14    613  	eax4	4,x4			-> next slot in binding block
    000656  aa  0 00000 6211 14    614  	eax1	ap|0,x4			update binding_block.top_block
    000657  aa  1 77776 7411 17    615  	stx1	ab|-2,x7
    000660  aa  2 00000 7211 00    616  	lxl1	bp|0			get new value to give to atom
    000661  aa  2 00000 2351 00    617  	lda	bp|0			use 'flags' as xec vector index
    000662  aa   000017 7710 00    618  	arl	15
    000663  0a   000670 7160 01    619  	xec	bind_vec,au		get new value in aq
    000664                         620  xec_ret:
    000664  aa  0 77776 7571 34    621  	staq	ap|2-4,x4*
    000665  aa   777774 6230 13    622  	eax3	-4,x3			count bindings
    000666  aa   777757 6010 04    623  	tnz	bind_loop-*,ic
    000667  aa  2 00001 7101 00    624  	tra	bp|1			all done
                                   625  
    000670                         626  bind_vec:
    000670  aa  1 00000 2371 11    627  	ldaq	ab|0,x1
    000671  aa  0 00000 2371 11    628  	ldaq	ap|0,x1
    000672  aa  4 00000 2371 11    629  	ldaq	lp|0,x1
    000673  aa  2 00000 2371 11    630  	ldaq	bp|0,x1
    000674  0a   000705 7100 00    631  	tra	flags4			4  - special case
    000675  0a   000700 7100 00    632  	tra	flags5			5  - get value from x5 reg.
    000676  aa  0 00000 2371 31    633  	ldaq	ap|0,x1*
    000677  aa  4 00000 2371 31    634  	ldaq	lp|0,x1*
                                   635  
                                   636  
    000700  aa   000000 6350 15    637  flags5:	eaa	0,x5			get -2*nargs
    000701  aa   000000 5310 00    638  	neg	0
    000702  aa   000067 7330 00    639  	lrs	19+36			c(q) = nargs
    000703  aa   040047 2350 07    640  	lda	fixnum_type,dl
    000704  aa   777760 7100 04    641  	tra	xec_ret-*,ic
                                   642  
    000705  aa   000004 6240 14    643  flags4:	eax4	4,x4			adjust x4 for next binding
    000706  4a  5 00020 2131 20    644  	epaq	lb|argatom,*		-> argatom
    000707  aa   000000 6350 01    645  	eaa	0,au			clear ring number
    000710  aa   060043 2750 07    646  	ora	Uncollectable+35,dl		type bit and its tag
    000711  aa  0 77776 7571 14    647  	staq	ap|2-4,x4			put in binding block
    000712  aa  0 77776 2371 34    648  	ldaq	ap|2-4,x4*		save old value
    000713  aa  0 77774 7571 14    649  	staq	ap|0-4,x4
    000714  aa  0 00000 6261 14    650  	eax6	ap|0,x4			update binding_block.top_block
    000715  aa  1 77776 7461 17    651  	stx6	ab|-2,x7
    000716  aa   000000 6350 15    652  	eaa	0,x5			-2 * nargs
    000717  aa   000000 5310 00    653  	neg	0
    000720  aa   000001 7310 00    654  	ars	1			nargs to au
    000721  aa   060000 2750 07    655  	ora	Uncollectable,dl		special kludge thing argatom is bound to
    000722  aa  0 77776 3535 34    656  	eppbb	ap|2-4,x4*		-> value cell of argatom
    000723  aa  3 00000 7551 00    657  	sta	bb|0			store first word
    000724  aa  2 00000 7211 00    658  	lxl1	bp|0			stack offset due to compiled code
    000725  aa  3 00001 7411 00    659  	stx1	bb|1			build up second word.
    000726  aa  3 00001 0421 00    660  	asx2	bb|1			stack pointer when operator called
    000727  aa  3 00001 0451 00    661  	asx5	bb|1			stack offset to get to arguments
    000730  aa   777735 7100 04    662  	tra	xec_ret+1-*,ic		and return to normal sequence
                                   663  
                                   664  
                                   665  " unbind operator.
                                   666  " unbinds the binding block which must be located at top of unmkd pdl
                                   667  "preserves aq but
                                   668  " changes index registers, decrements x7 by 2, 
                                   669  " de-allocates the binding block allocated by bind operator, hence changes ap
                                   670  
                                   671  
    000731  aa   000004 6270 17    672  unbind:	eax7	4,x7		save aq + temp.
    000732  aa  1 77774 7571 17    673  	staq	ab|-4,x7
    000733  aa  1 00044 3715 20    674  	epplb	ab|system_lp,*
    000734  aa  1 77772 7211 17    675  	lxl1	ab|-6,x7			binding_block.bot_block
    000735  aa  1 77777 7411 17    676  	stx1	ab|-1,x7			save for cmpx1
    000736  aa   000000 6260 11    677  	eax6	0,x1			save base of binding block for eppap below.
    000737  aa  0 00000 3531 00    678  	epbpbb	ap|0			baseptr of marked pdl
    000740  aa  1 77772 2211 17    679  	ldx1	ab|-6,x7			binding_block.top_block
                                   680  
                                   681  " now proceed to unbind top down
                                   682  
    000741                         683  unbind_loop:
    000741  aa  1 77777 1011 17    684  	cmpx1	ab|-1,x7			reached bottom?
    000742  aa   000005 6000 04    685  	tze	unbind_end-*,ic		 yes.
    000743  aa   777774 6210 11    686  	eax1	-4,x1			 no, do next.
    000744  aa  3 00000 2371 11    687  	ldaq	bb|0,x1			get old value
    000745  aa  3 00002 7571 31    688  	staq	bb|2,x1*			put back on atom
    000746  aa   777773 7100 04    689  	tra	unbind_loop-*,ic		and keep it up.
                                   690  
    000747                         691  unbind_end:
    000747  aa  1 77773 2211 17    692  	ldx1	ab|-5,x7			unthread this binding block
    000750  4a  5 00016 7411 20    693  	stx1	lb|binding_top_plus_1,*
    000751  aa  3 00000 3501 16    694  	eppap	bb|0,x6			pop binding block storage off of marked pdl
    000752  aa  1 77774 2371 17    695  	ldaq	ab|-4,x7			restore aq
    000753  aa   777772 6270 17    696  	eax7	-6,x7			clear save area and binding_block from pdl
    000754  aa  2 00000 7101 00    697  	tra	bp|0			& return
                                   698  
                                   699  " errset1 operator.
                                   700  " sets up an errset with no suppression of error messages
                                   701  " destroys contents of x0-x6 and aq. x7 is bumped by 12,
                                   702  " ap is bumped by 2.
                                   703  " *** 22 SEP 72 - DAM -- no longer makes a stack frame,
                                   704  " just saves the rtcd loc in the stack frame, which is destroyed
                                   705  " by the Multics non local go to mechanism.
                                   706  
                                   707  " call is:
                                   708  "	tspbp	ab|errset1,*
                                   709  "	tra	eob			return here if error occurs
                                   710  "					"with nil or value of err in aq
                                   711  "	- compiled first arg to errset -
                                   712  " eob:	tspbp	ab|unerrset,*
                                   713  
                                   714  
    000755  aa  0 00002 3501 00    715  errset1:	eppap	ap|2			temp for use if error occurs
    000756  aa   000000 6220 00    716  	eax2	0			this is not errset with nil 2nd arg
    000757  aa   000005 7100 04    717  	tra	errset_com-*,ic
                                   718  
                                   719  
                                   720  " errset2 operator.
                                   721  " sets up an errset with 2nd arg to errset determining
                                   722  " suppression of error messages. destroys contents of aq
                                   723  " and x0-x6, x7 is bumped by 12, ap is unchanged. Call is
                                   724  " same as errset1 except that top of marked pdl
                                   725  " contains evaluated second arg to errset.
                                   726  
                                   727  
    000760  aa  0 77776 2371 00    728  errset2:	ldaq	ap|-2			get 2nd arg to errset
    000761  aa  1 00012 1171 00    729  	cmpaq	ab|nil			if nil, suppress error msgs
    000762  aa   777774 6010 04    730  	tnz	errset1+1-*,ic		not nil, allow msgs
    000763  aa   400000 2220 03    731  	ldx2	=o400000,du		nil, set x2 to "1"b
                                   732  
    000764                         733  errset_com:
    000764  aa   000014 6270 17    734  	eax7	12,x7			size(frame)+save lp,bp,sp|20
    000765  aa  1 77774 6501 17    735  	sprilp	ab|his_lp,x7
    000766  aa  1 77776 2521 17    736  	spribp	ab|his_bp,x7		save caller's stuff for return
    000767  aa  1 00044 3701 20    737  	epplp	ab|system_lp,*
    000770  aa  6 00024 2371 00    738  	ldaq	sp|20			save ret addr in stack frame we are sharing
    000771  aa  1 77772 7571 17    739  	staq	ab|-6,x7
                                   740  
                                   741  " set up errset frame on unmarked pdl
                                   742  " above errset frame our caller's lp, bp will be
                                   743  " saved so that error routine can return to him.
                                   744  
    000772  aa  0 00000 6211 00    745  	eax1	ap|0
    000773  aa  1 77764 4411 17    746  	sxl1	ab|frame.stack_ptr-12,x7
    000774  4a  4 00022 2211 20    747  	ldx1	<lisp_static_vars_>|[err_frame]+1
    000775  aa  1 77764 7411 17    748  	stx1	ab|frame.prev_frame-12,x7
    000776  aa  1 77765 4501 17    749  	stz	ab|frame.dat2-12,x7		set to "1"b by err if eval needed
    000777  aa  1 77765 7421 17    750  	stx2	ab|frame.dat1-12,x7		set suppress-msgs flag
    001000  aa   000010 3520 04    751  	eppbp	err_return-*,ic
    001001  aa  1 77766 2521 17    752  	spribp	ab|frame.ret-12,x7
    001002  aa  1 77770 6521 17    753  	sprisp	ab|frame.ret+2-12,x7
    001003  aa  1 77764 6211 17    754  	eax1	ab|-12,x7
    001004  4a  4 00022 7411 20    755  	stx1	<lisp_static_vars_>|[err_frame]+1
                                   756  
                                   757  " return to compiled first arg to errset
                                   758  
    001005  aa  1 77774 3701 37    759  	epplp	ab|his_lp,x7*
    001006  aa  1 77776 3521 37    760  	eppbp	ab|his_bp,x7*
    001007  aa  2 00001 7101 00    761  	tra	bp|1
                                   762  
                                   763  " come here if error occurs, value to return is on top of
                                   764  " marked pdl, frame.dat2 is "1"b if it hasn't been evaled yet (from fcn 'err')
                                   765  
    001010                         766  err_return:
    001010  aa  7 00046 2721 20    767  	getlp			" in pl1 code mode, must get lp from lot.
    001011  aa   000060 6270 00    768  	push				"stack frame to call out with
    001012  aa  7 00040 2721 20
    001013  4a  4 00026 3521 20    769  	eppbp	<lisp_static_vars_>|[unmkd_ptr],*    push onto unmkd pdl...
    001014  aa  2 00002 3521 00    770  	eppbp	bp|2
    001015  4a  4 00076 2521 20    771  	spribp	<lisp_static_vars_>|[unmkd_ptr]
    001016  4a  4 00100 3501 20    772  	eppap	<lisp_static_vars_>|[err_frame],*
    001017  aa  0 00014 3501 00    773  	eppap	ap|12			... the addr to unwind to
    001020  aa  2 77776 2501 00    774  	spriap	bp|-2			which is just above our errset frame
    001021  4a  4 00072 3521 20    775  	eppbp	<lisp_static_vars_>|[stack_ptr],*    copy value to be returned down
    001022  aa  0 77764 7211 00    776  	lxl1	ap|frame.stack_ptr-12
    001023  aa  2 77776 2371 00    777  	ldaq	bp|-2
    001024  aa  2 00000 3531 00    778  	epbpbb	bp|0
    001025  aa  3 77776 7571 11    779  	staq	bb|-2,x1
    001026  aa   777532 3500 04    780  	eppap	null_argl-*,ic		get null arg list for call.
    001027  4a  4 00102 3521 20    781  	short_call  <lisp_prog_fns_>|[lisp_unwinder]
    001030  aa  7 00036 6701 20
    001031  aa  6 00030 3701 20
    001032  4a  4 00100 3521 20    782  	eppbp	<lisp_static_vars_>|[err_frame],*  should we eval the returned value?
    001033  aa  2 00000 7211 00    783  	lxl1	bp|frame.stack_ptr
    001034  4a  4 00072 3511 20    784  	epbpab	<lisp_static_vars_>|[stack_ptr],*
    001035  aa  1 00000 3501 11    785  	eppap	ab|0,x1
    001036  4a  4 00064 2501 20    786  	spriap	<lisp_static_vars_>|[stack_ptr]
    001037  aa  2 00001 7201 00    787  	lxl0	bp|frame.dat2
    001040  aa   000005 6000 04    788  	tze	err_ret_0-*,ic
    001041  aa   777517 3500 04    789  	eppap	null_argl-*,ic		get null arg list for call to pl1 entry in eval.
    001042  4a  4 00104 3521 20    790  	short_call  <lisp_>|[eval]
    001043  aa  7 00036 6701 20
    001044  aa  6 00030 3701 20
    001045                         791  err_ret_0:
                                   792  
                                   793  " now go from pl1_code mode to lisp_code mode, and
                                   794  " return to error return loc in errset caller, with errset frame still around
                                   795  
                                   796  	exit_pl1_code	pop
    001045  aa  6 00000 3521 00         	eppbp	sp|0
    001046                              	inhibit	on
    001046  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    001047  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    001050                              	inhibit	off
    001050  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001051  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001052  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001053  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001054  aa  1 77772 2371 17    797  	ldaq	ab|-6,x7			restore ret addr in stack frame
    001055  aa  6 00024 7571 00    798  	staq	sp|20
    001056  aa  1 77774 3701 37    799  	epplp	ab|his_lp,x7*
    001057  aa  1 77776 3521 37    800  	eppbp	ab|his_bp,x7*
    001060  aa  0 77776 2371 00    801  	ldaq	ap|-2			value of the errset
    001061  aa  2 00000 7101 00    802  	tra	bp|0			return to caller, who will do an unerrset.
                                   803   
                                   804  " unerrset operator.
                                   805  " this operator removes the errset frame which must be at the top of
                                   806  " the unmarked pdl.  It does not disturb the aq or the ap, it
                                   807  " decrements x7 by 12, and the other index registers are destroyed.
                                   808  " doesn't have to restore sp|20 since that is only
                                   809  " destroyed by a non-local goto and our non-local-goto reciever has
                                   810  " already fixed it.
                                   811  
                        000022     812  	link	err_frame_plus_1,<lisp_static_vars_>|[err_frame]+1
                                   813  
    001062                         814  unerrset:
    001062  aa  1 00044 3715 20    815  	epplb	ab|system_lp,*		get lp for this program.
    001063  aa  1 77764 2211 17    816  	ldx1	ab|frame.prev_frame-12,x7	remove err frame from pdl
    001064  4a  5 00022 7411 20    817  	stx1	lb|err_frame_plus_1,*
    001065  aa   777764 6270 17    818  	eax7	-12,x7
    001066  aa  0 77776 3501 00    819  	eppap	ap|-2		get rid of value pushed on by caller.
    001067  aa  2 00000 7101 00    820  	tra	bp|0
                                   821  
                                   822  
                                   823  " call operator.
                                   824  " this operator is used to provide call_outs from lisp-compiled
                                   825  " code to external functions.  It is called by tspbp lp|link,*
                                   826  " where the doubleword link in the linkage section is:
                                   827  
                                   828  " link:	vfd  3/ab, 15/fcn_offset, 1/snap, 1/constant, 1/fsubr, 9/nargs, 6/itb
                                   829  "	vfd  18/call_oper, 12/0, 6/20
                                   830  " where fcn_offset is offset from ap (constant = 0)
                                   831  "  or from lp (constant = 1)
                                   832  " snap is 1 if the link is to be changed to point directly
                                   833  "  at the function if possible
                                   834  " fsubr is 1 if the top of the pdl contains the unevaluated
                                   835  "  list of args, 0 if top of pdl contains spread, evaluated args
                                   836  " nargs is o777 if arg count times -2 is in x5, otherwise is arg count
                                   837  " the remaining fields look like  itb  ab,call_oper,*
                                   838  " so that the tspbp has the effect of tspbp ab|call_oper,*
                                   839  " this operator destroys all the index registers, it returns
                                   840  " with x7 unchanged, result of function in aq, and the
                                   841  " args or arglist popped off the marked pdl.
                                   842  
                                   843  
    001070  aa   000006 6270 17    844  call:	eax7	6,x7		push lp, bp, addr of link
    001071  aa  1 77774 6501 17    845  	sprilp	ab|his_lp,x7
    001072  aa  1 77776 2521 17    846  	spribp	ab|his_bp,x7
    001073  aa  2 77777 2201 00    847  	ldx0	bp|-1		get addr of link
    001074  aa   077777 3600 03    848  	anx0	=o077777,du
    001075  aa  4 00000 3521 10    849  	eppbp	lp|0,x0
    001076  aa  1 77772 2521 17    850  	spribp	ab|-6,x7
    001077  aa  2 00000 2351 00    851  	lda	bp|0		get the function into aq
    001100  aa   000003 7350 00    852  	als	3		spread sign bit (3) into (0-2)
    001101  aa   000003 7310 00    853  	ars	3
    001102  aa   200000 3150 07    854  	cana	=o200000,dl	test constant bit
    001103  aa   000003 6010 04    855  	tnz	3,ic
    001104  aa  0 00000 2371 01    856  	ldaq	ap|0,au		not constant, get from stack
    001105  aa   000002 7100 04    857  	tra	2,ic
    001106  aa  4 00000 2371 01    858  	ldaq	lp|0,au		constant, get from linkage section
    001107  aa  0 00010 3501 00    859  	eppap	ap|-form
    001110  aa  0 77770 7571 00    860  	staq	ap|form
    001111  aa  2 00000 2351 00    861  	lda	bp|0			check for f_type function
    001112  aa   100000 3150 07    862  	cana	=o100000,dl
    001113  aa   000012 6010 04    863  	tnz	call_2_f-*,ic
    001114  aa  1 00044 3701 20    864  	epplp	ab|system_lp,*
                                   865  
                                   866  
                                   867  " set x5 to number of args if not already so set
                                   868  
    001115  aa  1 77772 2351 37    869  	lda	ab|-6,x7*
    001116  aa   077700 3750 07    870  	ana	=o77700,dl
    001117  aa   077700 1150 07    871  	cmpa	=o77700,dl
    001120  aa   000004 6000 04    872  	tze	already_got_x5-*,ic
    001121  aa   000005 7310 00    873  	  ars	  5
    001122  aa   000000 5310 00    874  	  neg	  0
    001123  aa   000000 6250 05    875  	  eax5	  0,al
    001124                         876  already_got_x5:
                                   877  
                                   878  " go to routine in lisp_ to do rest of work
                                   879  
    001124  4a  4 00106 7101 20    880  	tra	<lisp_>|[call1]
                                   881  
                                   882  " call with unevaled arg list
                                   883  
    001125                         884  call_2_f:
    001125  aa  0 77766 2371 00    885  	ldaq	ap|form-2			arg list
    001126  aa  0 77776 3501 00    886  	eppap	ap|-2
    001127  aa  0 77774 7571 00    887  	staq	ap|argl
    001130  aa  0 77772 2371 00    888  	ldaq	ap|fcn
    001131  aa  0 77770 7571 00    889  	staq	ap|form
    001132  aa  1 00044 3701 20    890  	epplp	ab|system_lp,*
    001133  4a  4 00110 7101 20    891  	tra	<lisp_>|[callf]
                                   892  
                                   893  
                                   894  " catch1 operator.
                                   895  " is the compiled form of a catch with one argument
                                   896  " destroys contents of aq and x0-x6, x7 is bumped by 12,
                                   897  " ap is bumped by 2.
                                   898  " call is:
                                   899  "	tspbp	ab|catch1,*
                                   900  "	tra	eoc			return here if throw occurs
                                   901  "					with the value thrown in aq
                                   902  "	- compiled first arg to catch -
                                   903  " eoc:	tspbp	ab|uncatch,*
                                   904  "	"result of catch is now in aq
                                   905  "
                                   906  " also saves sp|20 and restores it if it gets destroyed
                                   907  " by unwinder_
                                   908  
                                   909  
                                   910  
    001134  aa  0 00002 3501 00    911  catch1:	eppap	ap|2			make fake catch tag
    001135  aa   000305 2370 04    912  	ldaq	nultag-*,ic
    001136  aa  0 77776 7571 00    913  	staq	ap|-2
                                   914  					" fall into catch2
                                   915  
                                   916  
                                   917  
                                   918  " catch2 operator.
                                   919  " is compiled form of catch with a second arg, which is the catch tag.
                                   920  " call is same as catch1 except ap is not bumped and top of marked pdl
                                   921  " contains the unevaluated second arg to catch.
                                   922  
                                   923  
    001137                         924  catch2:
    001137  aa   000014 6270 17    925  	eax7	12,x7
    001140  aa  1 77774 6501 17    926  	sprilp	ab|his_lp,x7
    001141  aa  1 77776 2521 17    927  	spribp	ab|his_bp,x7
    001142  aa  1 00044 3701 20    928  	epplp	ab|system_lp,*
    001143  aa  6 00024 2371 00    929  	ldaq	sp|20			save ret addr in stack frame we are sharing
    001144  aa  1 77772 7571 17    930  	staq	ab|-6,x7
                                   931  
                                   932  " set up catch frame on unmarked pdl.  Above the
                                   933  " catch frame our caller's lp, bp will be saved
                                   934  " so that we can return to him if a throw occurs.
                                   935  
    001145  aa  0 00000 6211 00    936  	eax1	ap|0			-> just above catch label (for throw)
    001146  aa  1 77764 4411 17    937  	sxl1	ab|frame.stack_ptr-12,x7
    001147  4a  4 00024 2211 20    938  	ldx1	<lisp_static_vars_>|[catch_frame]+1
    001150  aa  1 77764 7411 17    939  	stx1	ab|frame.prev_frame-12,x7
    001151  aa   000010 3520 04    940  	eppbp	throw_ret-*,ic
    001152  aa  1 77766 2521 17    941  	spribp	ab|frame.ret-12,x7
    001153  aa  1 77770 6521 17    942  	sprisp	ab|frame.ret+2-12,x7
    001154  aa  1 77764 6211 17    943  	eax1	ab|-12,x7
    001155  4a  4 00024 7411 20    944  	stx1	<lisp_static_vars_>|[catch_frame]+1
                                   945  
                                   946  " go elaborate the compiled first arg to catch
                                   947  
    001156  aa  1 77774 3701 37    948  	epplp	ab|his_lp,x7*
    001157  aa  1 77776 3521 37    949  	eppbp	ab|his_bp,x7*
    001160  aa  2 00001 7101 00    950  	tra	bp|1
                                   951  
                                   952  
                                   953  " come here (in pl1_code mode) if a throw occurs.  The value
                                   954  " thrown is at top of marked pdl.  The unmarked pdl has not
                                   955  " yet been unwound.
                                   956  " We move the thrown value down, unwind the unmarked pdl to
                                   957  " just above our catch_frame, put the thrown value
                                   958  " in aq, and return to the location after
                                   959  " the call to catch1 or catch2.  The caller will do an uncatch.
                                   960  
    001161                         961  throw_ret:
    001161  aa  7 00046 2721 20    962  	getlp				" get lp from lot, as we are in pl1 code mode here.
    001162  aa   000060 6270 00    963  	push
    001163  aa  7 00040 2721 20
    001164  4a  4 00026 3521 20    964  	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
    001165  aa  2 00002 3521 00    965  	eppbp	bp|2			push onto unmarked pdl...
    001166  4a  4 00076 2521 20    966  	spribp	<lisp_static_vars_>|[unmkd_ptr]
    001167  4a  4 00112 3501 20    967  	eppap	<lisp_static_vars_>|[catch_frame],*
    001170  aa  0 00014 3501 00    968  	eppap	ap|12			...the addr to unwind to...
    001171  aa  2 77776 2501 00    969  	spriap	bp|-2			...which is just above our catch frame
    001172  4a  4 00072 3521 20    970  	eppbp	<lisp_static_vars_>|[stack_ptr],*
    001173  aa  2 77776 2371 00    971  	ldaq	bp|-2			get the thrown value
    001174  aa  0 77764 7211 00    972  	lxl1	ap|frame.stack_ptr-12
    001175  aa  2 00000 3531 00    973  	epbpbb	bp|0
    001176  aa  3 77776 7571 11    974  	staq	bb|-2,x1			and put it into our part of marked pdl
    001177  aa   777361 3500 04    975  	eppap	null_argl-*,ic		call the unwinder with no pl1 arguments.
    001200  4a  4 00102 3521 20    976  	short_call  <lisp_prog_fns_>|[lisp_unwinder]
    001201  aa  7 00036 6701 20
    001202  aa  6 00030 3701 20
                                   977  
                                   978  " switch to lisp_code mode (ptrs in ap, x7)
                                   979  
                                   980  	exit_pl1_code	pop
    001203  aa  6 00000 3521 00         	eppbp	sp|0
    001204                              	inhibit	on
    001204  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    001205  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    001206                              	inhibit	off
    001206  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001207  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001210  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001211  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001212  aa  0 00000 3531 00    981  	epbpbb	ap|0			adjust stack_ptr to value when catch wsa done
    001213  aa  1 77764 7211 17    982  	lxl1	ab|frame.stack_ptr-12,x7
    001214  aa  3 00000 3501 11    983  	eppap	bb|0,x1
    001215  aa  1 77772 2371 17    984  	ldaq	ab|-6,x7			restore sp|20
    001216  aa  6 00024 7571 00    985  	staq	sp|20
    001217  aa  0 77776 2371 00    986  	ldaq	ap|-2			return thrown value in aq
    001220  aa  1 77774 3701 37    987  	epplp	ab|his_lp,x7*
    001221  aa  1 77776 3521 37    988  	eppbp	ab|his_bp,x7*
    001222  aa  2 00000 7101 00    989  	tra	bp|0			return to caller who will do an uncatch
                                   990  
                                   991  
                                   992  
                                   993  " uncatch operator.
                                   994  " this operator removes the catch frame which must be at the top
                                   995  " of the unmarked pdl.  It does not disturb the aq or the ap,
                                   996  " it decrements x7 by 12, and the other index registers are
                                   997  " destroyed.
                                   998  
                        000024     999  	link	catch_frame_plus_1,<lisp_static_vars_>|[catch_frame]+1
                                  1000  
    001223  aa  1 00044 3715 20   1001  uncatch:	epplb	ab|system_lp,*
    001224  aa  1 77764 2211 17   1002  	ldx1	ab|frame.prev_frame-12,x7	unthread this catch_frame
    001225  4a  5 00024 7411 20   1003  	stx1	lb|catch_frame_plus_1,*
    001226  aa   777764 6270 17   1004  	eax7	-12,x7
    001227  aa  0 77776 3501 00   1005  	eppap	ap|-2		get rid of value pushed by caller.
    001230  aa  2 00000 7101 00   1006  	tra	bp|0
                                  1007  
                                  1008   
                                  1009  " operator to bind for iog.  Allows iog to be compiled as
                                  1010  "	tspbp	ab|iogbind_op,*
                                  1011  "	<call>	<function ioc>
                                  1012  "	<eval>	2nd arg to iog
                                  1013  "	tspbp	ab|unbind_op,*
                                  1014  "
                                  1015  " binds ^q, ^r, ^w to nil.
                                  1016  " destroys the contents of aq and all the index registers, bumps x7 by 2
                                  1017  " bumps ap by 16, but only 12 of those words are currently used.
                                  1018  
                                  1019  	
    001231  aa   000006 6270 17   1020  iogbind:	eax7	6,x7			room for binding block, save lp,bp
    001232  aa  1 77774 6501 17   1021  	sprilp	ab|his_lp,x7
    001233  aa  1 77776 2521 17   1022  	spribp	ab|his_bp,x7
    001234  aa  1 00044 3701 20   1023  	epplp	ab|system_lp,*
    001235  aa  0 00020 3501 00   1024  	eppap	ap|16			make room for binding block
    001236  aa  1 00014 2371 00   1025  	ldaq	ab|true			" KLUDGE to take up space...rebind t to t.
    001237  aa  0 77762 7571 00   1026  	staq	ap|-14
    001240  aa  0 77760 7571 00   1027  	staq	ap|-16			" END KLUDGE
    001241  4a  4 00114 2371 20   1028  	ldaq	<lisp_static_vars_>|[ctrlQ]	put ^q in binding block
    001242  aa  0 77766 7571 00   1029  	staq	ap|-10
    001243  4a  4 00116 2371 20   1030  	ldaq	<lisp_static_vars_>|[ctrlR]	put ^r in binding block
    001244  aa  0 77772 7571 00   1031  	staq	ap|-6
    001245  4a  4 00120 2371 20   1032  	ldaq	<lisp_static_vars_>|[ctrlW]	put ^w in binding block
    001246  aa  0 77776 7571 00   1033  	staq	ap|-2
    001247  aa  0 77766 2371 20   1034  	ldaq	ap|-10,*			now save old values.
    001250  aa  0 77764 7571 00   1035  	staq	ap|-12
    001251  aa  0 77772 2371 20   1036  	ldaq	ap|-6,*
    001252  aa  0 77770 7571 00   1037  	staq	ap|-8
    001253  aa  0 77776 2371 20   1038  	ldaq	ap|-2,*
    001254  aa  0 77774 7571 00   1039  	staq	ap|-4
    001255  4a  4 00016 2361 20   1040  	ldq	<lisp_static_vars_>|[binding_top]+1
    001256  aa  1 77773 7561 17   1041  	stq	ab|-5,x7			make binding_block in unmkd pdl
    001257  aa  0 77760 6211 00   1042  	eax1	ap|-16
    001260  aa  1 77772 4411 17   1043  	sxl1	ab|-6,x7			binding_block.bot_block
    001261  aa  0 00000 6211 00   1044  	eax1	ap|0
    001262  aa  1 77772 7411 17   1045  	stx1	ab|-6,x7			binding_block.top_block
    001263  aa  1 77772 6211 17   1046  	eax1	ab|-6,x7			and thread onto list of b.b.'s
    001264  4a  4 00016 7411 20   1047  	stx1	<lisp_static_vars_>|[binding_top]+1
                                  1048  
                                  1049  
    001265  aa  1 00012 2371 00   1050  	ldaq	ab|nil			now reset ^q, ^r, ^w to nil
    001266  4a  4 00122 7571 20   1051  	staq	<lisp_static_vars_>|[ctrlQ],*
    001267  4a  4 00124 7571 20   1052  	staq	<lisp_static_vars_>|[ctrlR],*
    001270  4a  4 00126 7571 20   1053  	staq	<lisp_static_vars_>|[ctrlW],*
                                  1054  
    001271  aa   000020 7100 04   1055  	tra	return-*,ic
                                  1056  
                                  1057  
                                  1058  
                                  1059  " unseen_go_tag operator
                                  1060  " this operator is called by the compiled form of the go function
                                  1061  " when the argument is non-atomic and, having been evaled, is not
                                  1062  " found in the table of known tags.
                                  1063  " Called by tspbp with the losing tag in the aq.  Returns with
                                  1064  " ap, x7 unchanged, better tag in the aq, index regs destroyed.
                                  1065  "
                                  1066  " If the aq contains an atom, it is really a losing tag
                                  1067  " and a call to lisp_error_ is constructed.
                                  1068  " If the aq contains a list, then it is evaluated and returned
                                  1069  " to caller, just like the interpreted go function.
                                  1070  
    001272                        1071  obscene_go_tag:
    001272  aa   000004 6270 17   1072  	eax7	4,x7			save caller's lp,bp
    001273  aa  1 77776 2521 17   1073  	spribp	ab|his_bp,x7
    001274  aa  1 77774 6501 17   1074  	sprilp	ab|his_lp,x7
    001275  aa  0 00002 3501 00   1075  	eppap	ap|2			save tag on pdl for lisp_error_ or eval
    001276  aa  0 77776 7571 00   1076  	staq	ap|-2
    001277  aa   077700 3150 07   1077  	cana	lisp_ptr.type,dl		atomic tag?
    001300  aa   000006 6000 04   1078  	tze	re_eval_tag-*,ic		no, eval it again.
    001301  4a  4 00130 2351 20   1079  	lda	<lisp_error_table_>|[unseen_go_tag]
    001302  aa   777152 7000 04   1080  	tsx0	Lisp_Error-*,ic
    001303  aa  0 77776 2371 00   1081  	ldaq	ap|-2			get replacement tag
    001304  aa  0 77776 3501 00   1082  	eppap	ap|-2
    001305  aa   000004 7100 04   1083  	tra	return-*,ic
                                  1084  
                                  1085  " come here to eval the tag again
                                  1086  
    001306                        1087  re_eval_tag:
    001306  aa   777776 6250 00   1088  	eax5	-2			calling eval with 1 arg
    001307  aa  1 00044 3701 20   1089  	epplp	ab|system_lp,*		get right lp for eval
    001310  4a  4 00060 7101 20   1090  	tra	<lisp_>|[eval_]		eval the tag and return to our caller. (clever)
                                  1091  
                                  1092  
                                  1093  " return operator.
                                  1094  " called by tra ab|return_op,*
                                  1095  " This operator is used to return from a type 1 subr
                                  1096  " after the unmkd pdl has been cleared, and the args, temps,
                                  1097  " and local variables have been removed from the marked pdl.
                                  1098  " the value to be returned should be in the aq.
                                  1099  
    001311  aa  1 77774 3701 37   1100  return:	epplp	ab|his_lp,x7*
    001312  aa  1 77776 3521 37   1101  	eppbp	ab|his_bp,x7*
    001313  aa   777774 6270 17   1102  	eax7	-4,x7
    001314  aa  2 00000 7101 00   1103  	tra	bp|0
                                  1104  
                                  1105  
                                  1106  
                                  1107  
                                  1108  
                                  1109  " signp operator.
                                  1110  " called by tspbp ab|signp_op,*
                                  1111  " This operator sets the indicators from the number in the aq.
                                  1112  " If C(aq) is not a number, indicators are set randomly.
                                  1113  " Changes no registers except aq.
                                  1114  
    001315  aa   020000 3150 07   1115  signp:	cana	Float,dl			flonum?
    001316  aa   000005 6010 04   1116  	tnz	signp_fl-*,ic		yes.
    001317  aa   001000 3150 07   1117  	cana	Big_fixed,dl		bignum?
    001320  aa   000011 6010 04   1118  	tnz	signp_big-*,ic
                                  1119  
                                  1120  " fixnum - set indicators from q<0:35>
                                  1121  
    001321  aa   000000 1160 03   1122  	cmpq	0,du			set indicators for fixnum in q.
    001322  aa  2 00000 7101 00   1123  	tra	bp|0
                                  1124  
                                  1125  " flonum - set indicators from fraction, q<8:35>
                                  1126  
    001323  aa   001000 3160 03   1127  signp_fl:	canq	=o1000,du			set zero indicator from sign bit of float.
    001324  aa   000003 6010 04   1128  	tnz	set_minus_indicator-*,ic	and if negative float, set negative indicator.
    001325  aa   400000 1160 03   1129  	cmpq	=0.0,du			otherwise, compare with floating point zero (= least fixed number)
    001326  aa  2 00000 7101 00   1130  	tra	bp|0
    001327                        1131  set_minus_indicator:
    001327  aa   777777 2340 03   1132  	szn	=o777777,du		turn on minus indicator.
    001330  aa  2 00000 7101 00   1133  	tra	bp|0			return.
                                  1134  
    001331  aa   000000 3124 01   1135  signp_big: easpbb	0,au			move pointer from AQ to BB
    001332  aa   000000 3134 02   1136  	eawpbb	0,qu			..
    001333  aa  3 00000 2341 00   1137  	szn	bb|0			get sign from bignum.  works because
                                  1138  	"				no bignum is zero, and RH of header is nonzero
    001334  aa  2 00000 7101 00   1139  	tra	bp|0
                                  1140  
                                  1141  " compare operator.
                                  1142  " takes arg in AQ, bb points at thing to be compared with.
                                  1143  " sets indicators, returns.
                                  1144  
    001335  aa   040047 1150 07   1145  compare:	cmpa	fixnum_type,dl
    001336  0a   001341 6010 00   1146  	tnz	floatcomp
    001337  aa  3 00001 1161 00   1147  	cmpq	bb|1
    001340  aa  2 00000 7101 00   1148  	tra	bp|0		return
                                  1149  
    001341  aa  0 00002 3501 00   1150  floatcomp:eppap	ap|2
    001342  aa  0 77776 7571 00   1151  	staq	ap|-2
    001343  aa  0 77777 4311 00   1152  	fld	ap|-1
    001344  aa   000001 6200 00   1153  	eax0	1
    001345  aa  3 00001 5151 00   1154  	fcmp	bb|1
    001346  aa   000004 6054 04   1155  	tpnz	4,ic
    001347  aa   000002 6000 04   1156  	tze	2,ic
    001350  aa   777777 6200 10   1157  	eax0	-1,x0
    001351  aa   777777 6200 10   1158  	eax0	-1,x0
    001352  aa  0 77776 2371 00   1159  	ldaq	ap|-2		" reload the aq.
    001353  aa  0 77776 3501 00   1160  	eppap	ap|-2
    001354  aa   000000 1000 03   1161  	cmpx0	0,du
    001355  aa  2 00000 7101 00   1162  	tra	bp|0
                                  1163  
                                  1164  " err operator.
                                  1165  
                                  1166  " (err x) compiles into:
                                  1167  "	ldaq	(eval x)
                                  1168  "	tra	ab|err_op,*
                                  1169  "	-- never returns --
                                  1170  "
                                  1171  " err with no args is the same as (err nil)
                                  1172  " err with 2 args cannot be compiled!!
                                  1173  
    001356  aa  0 00002 3501 00   1174  err:	eppap	ap|2			push value of err onto pdl
    001357  aa  0 77776 7571 00   1175  	staq	ap|-2			for use of lisp_error_$err_op
                                  1176  	enter_pl1_code
    001360  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    001361  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    001362  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    001363  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    001364  4a  4 00132 7101 20   1177  	tra	lisp_error_$err_op		go join interpreter's err fcn.
                                  1178  
                                  1179  " throw operators.
                                  1180  " these operators execute those cases of the compiled throw
                                  1181  " function that cannot be done in-line.
                                  1182  
                                  1183  " throw1 operator.
                                  1184  " takes value to be thrown in aq.  There is no tag.
                                  1185  " called by tra ab|throw1_op,*
                                  1186  
    001365  aa  0 00004 3501 00   1187  throw1:	eppap	ap|4			get room to store value being thrown
    001366  aa  0 77776 7571 00   1188  	staq	ap|-2
    001367  aa   000053 2370 04   1189  	ldaq	nultag-*,ic		get null tag and fall into throw2 operator
                                  1190  
                                  1191  
                                  1192  
                                  1193  
                                  1194  
                                  1195  " throw2 operator.
                                  1196  " takes value to be thrown on top of marked pdl,
                                  1197  "  with an empty slot beneath it, tag in aq.
                                  1198  " Called by tra ab|throw2_op,*
                                  1199  " the unmarked pdl is searched for catches using the same
                                  1200  " algorithm as the throw function in the interpreter.  When the catch
                                  1201  " to be thrown to is found, control is transferred to it.  The catch
                                  1202  " has the responsiblity of unwinding the pdl's and resuming execution
                                  1203  " at the point where catch was called.
                                  1204  
                                  1205  
    001370                        1206  throw2:
    001370  aa  1 00044 3701 20   1207  	epplp	ab|system_lp,*
    001371  4a  4 00024 2211 20   1208  	ldx1	<lisp_static_vars_>|[catch_frame]+1
    001372                        1209  catch_search:
    001372  aa   000041 6000 04   1210  	tze	bad_throw-*,ic	tra if no more catch frames
    001373  aa  0 00000 3711 00   1211  	epbplb	ap|0			get pointer to base of marked stack
    001374  aa  1 00000 7261 11   1212  	lxl6	ab|frame.stack_ptr,x1	get pdl area of catch
    001375  aa  5 77776 1171 16   1213  	cmpaq	lb|-2,x6			is our tag = tag of catch?
    001376  aa   000010 6000 04   1214  	tze	throw_1-*,ic		yes, win.
    001377  aa   000043 1170 04   1215  	cmpaq	nultag-*,ic		if null tag in throw, any catch will do.
    001400  aa   000006 6000 04   1216  	tze	throw_1-*,ic		so go there.
    001401  aa  5 77776 7221 16   1217  	lxl2	lb|-2,x6			no, check for nultag
    001402  aa   061400 1020 03   1218  	cmpx2	nulfu,du
    001403  aa   000003 6000 04   1219  	tze	throw_1-*,ic		this is unlabeled catch, it catches us.
    001404  aa  1 00000 2211 11   1220  	ldx1	ab|frame.prev_frame,x1	not our catch, keep looking.
    001405  aa   777765 7100 04   1221  	tra	catch_search-*,ic
                                  1222  
                                  1223  " come here with x1 pointing at catch frame of catch that catches us.
                                  1224  
    001406  4a  4 00024 7411 20   1225  throw_1:	stx1	lisp_static_vars_$catch_frame+1   discard any intervening catches
                                  1226  	enter_pl1_code
    001407  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    001410  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    001411  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    001412  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    001413  aa  6 00000 6221 00   1227  	eax2	sp|0			which is the catch.
    001414  aa  1 00005 1021 11   1228  	cmpx2	ab|frame.ret+3,x1
    001415  aa   000013 6000 04   1229  	tze	throw_to_same_sp-*,ic
                                  1230  "
                                  1231  "	Build arglist to call the Multics unwinder
                                  1232  "	(Started using Multics unwinder 12/6/78 -BSG)
                                  1233  "
    001416  aa  1 00002 3521 11   1234  	eppbp	ab|frame.ret,x1		Point at label var
    001417  aa  6 00002 2521 00   1235  	spribp	sp|2
    001420  0a   001426 2370 00   1236  	ldaq	argl_h_of_1
    001421  aa  6 00000 7571 00   1237  	staq	sp|0
    001422  aa  6 00000 3501 00   1238  	eppap	sp|0
    001423  4a  4 00134 3521 20   1239  	short_call unwinder_$unwinder_
    001424  aa  7 00036 6701 20
    001425  aa  6 00030 3701 20
                                  1240  
                                  1241  	even
    001426                        1242  argl_h_of_1:
    001426  aa   000002 000000    1243  	zero	2,0
    001427  aa   000000 000004    1244  	zero	0,04
    001430                        1245  throw_to_same_sp:
                                  1246  
    001430  aa  1 00002 3521 31   1247  	eppbp	ab|frame.ret,x1*
    001431  aa  6 00024 2521 00   1248  	spribp	sp|20
    001432  aa  7 00044 7101 20   1249  	short_return
                                  1250  
                                  1251  " come here when an unseen throw tag condition occurrs.
                                  1252  
    001433                        1253  bad_throw:
    001433  aa  0 00002 3501 00   1254  	eppap	ap|2			place to store bad tag
    001434  aa  0 77776 7571 00   1255  	staq	ap|-2
    001435  4a  4 00136 2351 20   1256  	lda	<lisp_error_table_>|[throw_to_no_catch]
    001436  aa   777016 7000 04   1257  	tsx0	Lisp_Error-*,ic
    001437  aa  0 77776 2371 00   1258  	ldaq	ap|-2			get replacement tag
    001440  aa  0 77776 3501 00   1259  	eppap	ap|-2
    001441  aa   777730 7100 04   1260  	tra	throw2+1-*,ic		and go try again
                                  1261  
                        061400    1262  	equ	nulfu,Numeric		= type field of nultag
                                  1263  
                                  1264  	even
    001442  aa   000000 061400    1265  nultag:	zero	0,nulfu		tag used by catch/throw with no tag.
    001443  aa   000000 000000    1266  	dec	0			tag is two words....
                                  1267  
                                  1268  " Operator to create a string descriptor for PL/I calls
                                  1269  " bb -> place to put descriptor
                                  1270  " aq has the string (or atomic symbol)
                                  1271  " returns with lb the appropriate argument ptr to store
                                  1272  " clobbers regs
                                  1273  
    001444                        1274  create_string_descriptor:
    001444  aa   000000 3304 01   1275  	easplb	0,au		move aq to lb and
    001445  aa   000001 3314 02   1276  	eawplb	1,qu		make it point at first char
    001446  aa   004000 3150 07   1277  	cana	String,dl		check type
    001447  aa   000004 6010 04   1278  	tnz	csd00-*,ic
    001450  aa   010000 3150 07   1279  	cana	Atsym,dl
    001451  aa   000006 6000 04   1280  	tze	csd_barf-*,ic	bad type
    001452  aa  5 00004 3715 00   1281  	epplb	lb|4		symbol - skip header
    001453  aa  5 77777 2351 00   1282  csd00:	lda	lb|-1		pick up length
    001454  aa   524000 2750 03   1283  	ora	=o524000,du	set type in desc
    001455  aa  3 00000 7551 00   1284  	sta	bb|0		store descriptor
    001456  aa  2 00000 7101 00   1285  	tra	bp|0		return
                                  1286  
    001457  aa  1 00044 3701 20   1287  csd_barf:	epplp	ab|system_lp,*
    001460  4a  4 00140 2351 20   1288  	lda	<lisp_error_table_>|[csd_op_barf]
    001461  aa   776773 7100 04   1289  	tra	Lisp_Error-*,ic
                                  1290  
                                  1291  
                                  1292  "
    001462                        1293  create_varying_string:
                                  1294  
                                  1295  " aq contains the symbol or string to initialize it with
                                  1296  " bb -> where to put the descriptor
                                  1297  " word after call contains the declared length of the string
                                  1298  " return with aq containing the new string as a lisp object, and
                                  1299  " return with lb -> the data portion of the string.  due to
                                  1300  " a pl1 crock this points at the chars rather than the length
                                  1301  
    001462  aa  0 00004 3501 00   1302  	eppap	ap|4			save stuff so can cons string
    001463  aa  0 77776 7571 00   1303  	staq	ap|-2
    001464  aa   000002 6270 17   1304  	eax7	2,x7
    001465  aa  2 00000 2361 00   1305  	ldq	bp|0			pick up length
    001466  aa  2 00001 3521 00   1306  	eppbp	bp|1
    001467  aa  1 77776 2521 17   1307  	spribp	ab|-2,x7
    001470  aa   530000 2760 03   1308  	orq	=o530000,du		make varying string descrip
    001471  aa  3 00000 7561 00   1309  	stq	bb|0			put in user's descriptor
    001472  aa   777777 3760 07   1310  	anq	-1,dl			clear qu again
    001473  aa  1 00136 2721 20   1311  	tspbp	ab|cons_string_op,*
    001474  aa  3 00001 3715 00   1312  	epplb	bb|1		set up return addr of string
    001475  aa  1 77776 3521 37   1313  	eppbp	ab|-2,x7*
    001476  aa   777776 6270 17   1314  	eax7	-2,x7
    001477  aa  0 77774 7571 00   1315  	staq	ap|-4			save value we want to return in aq
    001500  aa  0 77776 2371 00   1316  	ldaq	ap|-2
    001501  aa   000000 3124 01   1317  	easpbb	0,au		copy au to bb
    001502  aa   000001 3134 02   1318  	eawpbb	1,qu
    001503  aa   010000 3150 07   1319  	cana	Atsym,dl
    001504  aa   000003 6000 04   1320  	tze	cvs00-*,ic
    001505  aa  3 00004 3535 00   1321  	eppbb	bb|4
    001506  aa   000003 7100 04   1322  	tra	cvs01-*,ic
                                  1323  
    001507  aa   004000 3150 07   1324  cvs00:	cana	String,dl
    001510  aa   777747 6000 04   1325  	tze	csd_barf-*,ic
    001511  aa  3 77777 7221 00   1326  cvs01:	lxl2	bb|-1
    001512  aa  5 77777 4421 00   1327  	sxl2	lb|-1		set current length of varying string
    001513  aa  0 00140 1005 40   1328  	mlr	(pr,rl),(pr,rl)
    001514  aa   300000 000012    1329  	desc9a	bb|0,x2
    001515  aa   500000 000012    1330  	desc9a	lb|0,x2
    001516  aa  0 77774 2371 00   1331  	ldaq	ap|-4			pick up the string into aq
    001517  aa  0 77774 3501 00   1332  	eppap	ap|-4			for benefit of caller
    001520  aa  2 00000 7101 00   1333  	tra	bp|0			done
                                  1334  
                                  1335  
                                  1336  "
                                  1337  " create an array descriptor for a PL/I call
                                  1338  " bb -> the place to put it.  Sufficient words must have been allocated
                                  1339  " aq contains the array (as an array-ptr or a symbol)
                                  1340  " word following the call has type in left half, ndims in right half
                                  1341  " returns with lb -> the data
                                  1342  " clobbers regs
                                  1343  
    001521                        1344  create_array_descriptor:
    001521  aa   000000 3304 01   1345  	easplb	0,au		move aq into lb
    001522  aa   000000 3314 02   1346  	eawplb	0,qu
    001523  aa   000200 3150 07   1347  	cana	Array,dl		got array-ptr?
    001524  aa   000030 6000 04   1348  	tze	cadget-*,ic	no, go get one
    001525  aa  2 00000 7201 00   1349  cad00:	lxl0	bp|0		get number of dimensions
    001526  aa  5 00000 1001 00   1350  	cmpx0	lb|array_info.ndims	check it
    001527  aa   000045 6010 04   1351  	tnz	cad_barf-*,ic
    001530  aa  5 00007 2211 00   1352  	ldx1	lb|array_info.type	check type of array
    001531  aa  2 00000 1011 00   1353  	cmpx1	bp|0
    001532  aa   000042 6010 04   1354  	tnz	cad_barf-*,ic
    001533  aa   000000 6350 10   1355  	eaa	0,x0		put ndims in descriptor
    001534  aa   000006 7350 00   1356  	als	6
    001535  0a   001577 2750 11   1357  	ora	type_table,x1	and type bits
    001536  aa  3 00000 7551 00   1358  	sta	bb|0		stor first descriptor word
                                  1359  
    001537  aa   000000 6210 00   1360  	eax1	0		the array descriptor is stored backwards!
    001540  aa  5 00002 3715 20   1361  	epplb	lb|array_data_ptr,*
    001541  aa   777776 6210 11   1362  cad01:	eax1	-2,x1		scan lisp dope vector backwards
    001542  aa  3 00001 4501 00   1363  	stz	bb|1		lower bound
    001543  aa  5 00000 2361 11   1364  	ldq	lb|0,x1		upper bound
    001544  aa   000001 1760 07   1365  	sbq	1,dl
    001545  aa  3 00002 7561 00   1366  	stq	bb|2
    001546  aa  5 00001 2361 11   1367  	ldq	lb|1,x1		multiplier
    001547  aa  3 00003 7561 00   1368  	stq	bb|3
    001550  aa  3 00003 3535 00   1369  	eppbb	bb|3		advance to next dimension
    001551  aa   777777 6200 10   1370  	eax0	-1,x0		count dimensions
    001552  aa   777767 6010 04   1371  	tnz	cad01-*,ic
    001553  aa  2 00001 7101 00   1372  	tra	bp|1		done, return
                                  1373  
                                  1374  " do a get
                                  1375  
    001554  aa   010000 3150 07   1376  cadget:	cana	Atsym,dl		better be a symbol
    001555  aa   000017 6000 04   1377  	tze	cad_barf-*,ic
    001556  aa  1 00044 3735 20   1378  	eppsb	ab|system_lp,*
                        000012    1379  	link	array_atom,<lisp_static_vars_>|[array_atom]
    001557  4a  7 00012 2371 20   1380  	ldaq	sb|array_atom,*
    001560  aa  6 00000 3731 00   1381  	epbpsb	sp|0
    001561  aa  5 00002 7201 00   1382  cadget0:	lxl0	lb|2		check for end
    001562  aa   077700 3000 03   1383  	canx0	lisp_ptr.type,du
    001563  aa   000011 6010 04   1384  	tnz	cad_barf-*,ic	reached end - no array property
    001564  aa  5 00002 3715 20   1385  	epplb	lb|2,*		-> next plist cell
    001565  aa  5 00000 1171 00   1386  	cmpaq	lb|0		array property?
    001566  aa   000003 6000 04   1387  	tze	cadget1-*,ic	yes -use it
    001567  aa  5 00002 3715 20   1388  	epplb	lb|2,*		no - take next property
    001570  aa   777771 7100 04   1389  	tra	cadget0-*,ic
                                  1390  
    001571  aa  5 00002 3715 20   1391  cadget1:	epplb	lb|2,*		-> plist value
    001572  aa  5 00000 3715 20   1392  	epplb	lb|0,*		get the array pointer
    001573  aa   777732 7100 04   1393  	tra	cad00-*,ic	and resume normal operation
                                  1394  
    001574  aa  1 00044 3701 20   1395  cad_barf:	epplp	ab|system_lp,*
    001575  4a  4 00142 2351 20   1396  	lda	<lisp_error_table_>|[cad_op_barf]
    001576  aa   776656 7100 04   1397  	tra	Lisp_Error-*,ic
                                  1398  
    001577                        1399  type_table:
    001577  aa   410000 000107    1400  	oct	410000000107	Sexpr
    001600  aa   410000 000107    1401  	oct	410000000107	Sexpr
    001601  aa   404000 000043    1402  	oct	404000000043	fixnum
    001602  aa   414000 000033    1403  	oct	414000000033	flonum
                                  1404  
                                  1405  
                                  1406  "
                                  1407  " PL/I call operator
                                  1408  " bb -> arg list
                                  1409  " a contains argcount*2 in left half
                                  1410  " bp is return address
                                  1411  " instruction following tspbp is callsp indirect through link.
                                  1412  " At first I had this an epplb that was xec'ed,
                                  1413  " but the crufty hardware then goes to the wrong segment if it is bound
                                  1414  
    001603                        1415  pl1_call_operator:
    001603  aa   000004 6270 17   1416  	eax7	4,x7		save caller's lp and address
    001604  aa  1 77774 3571 17   1417  	stcd	ab|-4,x7		save ingenious internal return pt
    001605  0a   001643 7100 00   1418  	tra	pl1_call_common
                                  1419  	exit_pl1_code	pop
    001606  aa  6 00000 3521 00         	eppbp	sp|0
    001607                              	inhibit	on
    001607  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    001610  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    001611                              	inhibit	off
    001611  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001612  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001613  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001614  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001615                        1420  pl1_call_ret_common:
    001615  aa  1 77777 7621 17   1421  	lprpbp	ab|-1,x7
    001616  aa  1 77776 7641 17   1422  	lprplp	ab|-2,x7
    001617  aa   777774 6270 17   1423  	eax7	-4,x7
    001620  aa  2 00001 7101 00   1424  	tra	bp|1		return skipping callsp inst
                                  1425  
    001621                        1426  pl1_call_nopop:
    001621  aa   000004 6270 17   1427  	eax7	4,x7
    001622  aa  1 77774 3571 17   1428  	stcd	ab|-4,x7
    001623  0a   001643 7100 00   1429  	tra	pl1_call_common
                                  1430  	exit_pl1_code "nopop
    001624  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001625  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001626  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001627  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001630  0a   001615 7100 00   1431  	tra	pl1_call_ret_common
                                  1432  
    001631                        1433  rcv_char_star:
    001631  aa  3 00000 2361 00   1434  	ldq	bb|0		get length from lisp string
    001632  aa  0 00140 1005 40   1435  	mlr	(pr,rl),(pr,rl)	move from bp to bb
    001633  aa   500000 000006    1436  	desc9a	lb|0,ql
    001634  aa   300001 000006    1437  	desc9a	bb|1,ql		body of lisp code
                                  1438  	"			Now pop PL/I stack
    001635  aa  6 00000 3731 00   1439  	epbpsb	sp|0
    001636  aa  6 00000 3715 00   1440  	epplb	sp|0
    001637  aa   000000 0110 03   1441  	even
    001640                        1442  	inhibit	on
    001640  aa  6 00020 3723 20   1443  	eppsp	sp|stack_frame.prev_sp,*
    001641  aa  7 00024 6517 00   1444  	sprilb	sb|stack_header.stack_end_ptr
    001642                        1445  	inhibit	off
    001642  aa  2 00000 7101 00   1446  	tra	bp|0
                                  1447  
    001643                        1448  pl1_call_common:
    001643  aa   000000 6360 01   1449  	eaq	0,au		set descriptor counter
    001644  aa   000004 2750 07   1450  	ora	4,dl		and arglist type
    001645  aa  3 00000 7571 00   1451  	staq	bb|0		and finish arg list
    001646  aa  1 77776 5441 17   1452  	sprplp	ab|-2,x7
    001647  aa  1 77777 5421 17   1453  	sprpbp	ab|-1,x7
                                  1454  
                                  1455  	enter_pl1_code	push,64 "for pl1 vars
    001650  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    001651  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    001652  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    001653  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    001654  aa   000100 6270 00         	push	64
    001655  aa  7 00040 2721 20
    001656  4a  4 00066 3521 20         	eppbp	lisp_subr_tv_$..lisp..
    001657  aa  6 00026 2521 00         	spribp	sp|stack_frame.entry_ptr
    001660  aa  3 00000 3501 00   1456  	eppap	bb|0		make the call
                                  1457  
    001661  4a  4 00026 3521 20   1458  	eppbp	lisp_static_vars_$unmkd_ptr,*	get back return address
    001662  aa  2 77777 7621 00   1459  	lprpbp	bp|-1
    001663  aa  2 00000 2131 00   1460  	epaq	bp|0		get caller's linkage
    001664  aa  7 00026 7641 61   1461  	lprplp	sb|stack_header.lot_ptr,*au
    001665  aa  6 00024 3571 00   1462  	stcd	sp|stack_frame.return_ptr
    001666  aa  2 00000 7131 00   1463  	callsp	bp|0		call to caller's callsp
                                  1464  				" can't use short_call, clobbers pr4
    001667  aa  6 00030 3701 20   1465  	epplp	sp|stack_frame.lp_ptr,*
    001670  4a  4 00026 3521 20   1466  	eppbp	lisp_static_vars_$unmkd_ptr,*
    001671  aa  2 77774 6101 00   1467  	rtcd	bp|-4
                                  1468  
                                  1469  "
                                  1470  "
                                  1471  "	Unwind Protect Feature
                                  1472  "	Greenberg, 9/10/78
                                  1473  "
                                  1474  
                                  1475  "Called as follows:
                                  1476  "	tspbp	ab|unwp1,*
                                  1477  "	 tra	cleanup_handler
                                  1478  "	code......
                                  1479  
                                  1480  
    001672                        1481  unwind_protect:
    001672  aa   000006 6270 17   1482  	eax7	6,7		Push unmarked frame
    001673  aa   777772 6210 17   1483  	eax1	-6,7		Get pointer to it.
    001674  aa  1 00004 6501 11   1484  	sprilp	ab|frame.ret+2,1	Save LP for both us and handler.
    001675  aa  1 00044 3701 20   1485  	epplp	ab|system_lp,*
    001676  4a  4 00144 2261 20   1486  	ldx6	lisp_static_vars_$unwp_frame+1 Get thread.
    001677  aa  1 00000 7461 11   1487  	stx6	ab|frame.prev_frame,1
    001700  aa  0 00000 6261 00   1488  	eax6	ap|0		Save marked pdl.
    001701  aa  1 00000 4461 11   1489  	sxl6	ab|frame.stack_ptr,1
    001702  aa  1 00001 5541 11   1490  	stc1	ab|frame.dat1,1	Let interpreter know we are compiled.
    001703  aa  1 00002 2521 11   1491  	spribp	ab|frame.ret,1	Fake lisp PL/I environment closure.
    001704  4a  4 00144 7411 20   1492  	stx1	lisp_static_vars_$unwp_frame+1 Now we're official.
    001705  aa  1 00004 3701 31   1493  	epplp	ab|frame.ret+2,1*	Restore his Lisp LP.
    001706  aa  2 00001 7101 00   1494  	tra	bp|1		Execute protected code.
                                  1495  
                                  1496  "Un-unwind-protect operator.  Assumes top unwp frame is the right one.
                                  1497  "Called as:
                                  1498  "	tspbp	ab|ununwp,*
                                  1499  
                                  1500  
    001707                        1501  unwind_protect_end:
    001707  aa  4 00000 3715 00   1502  	epplb	lp|0		Save his Lisp LP
    001710  aa  1 00044 3701 20   1503  	epplp	ab|system_lp,*
    001711  4a  4 00144 2211 20   1504  	ldx1	lisp_static_vars_$unwp_frame+1
    001712  aa  1 00000 2261 11   1505  	ldx6	ab|frame.prev_frame,1 Get last frame, this MUST be unm top.
    001713  4a  4 00144 7461 20   1506  	stx6	lisp_static_vars_$unwp_frame+1
    001714  4a  4 00146 2361 20   1507  	ldq	lisp_static_vars_$masked Save interrupt state
    001715  aa   000001 3350 07   1508  	lca	1,dl		Mask all interrupts
    001716  4a  4 00146 7551 20   1509  	sta	lisp_static_vars_$masked
    001717  aa  1 00004 3701 31   1510  	epplp	ab|frame.ret+2,1*	Get Handler's Lisp LP.
    001720  aa  1 00002 3535 31   1511  	eppbb	ab|frame.ret,1*	BB = handler address
    001721  aa   000006 6270 11   1512  	eax7	6,1		Pop unwp frame, set ret block, intsav
    001722  aa  1 77774 2521 17   1513  	spribp	ab|his_bp-2,7	Save return address.
    001723  aa  1 77772 6515 17   1514  	sprilb	ab|his_lp-2,7	Save his LP, too.
    001724  aa  1 77776 7561 17   1515  	stq	ab|-2,7		Store the interrupt system state.
    001725  aa  3 00000 7101 00   1516  	tra	bb|0		Go execute the handler.
                                  1517  
                                  1518  
                                  1519  "This next guy is called by the end of interrupt-inhibited handlers.
                                  1520  " As:
                                  1521  "	tspbp	ab|irest_return_op,*
                                  1522  
    001726                        1523  irest_return:
    001726  aa  1 00044 3701 20   1524  	epplp	ab|system_lp,*	Restore linkage
    001727  aa  1 77776 2361 17   1525  	ldq	ab|-2,7		Get old interrupt state
    001730  aa   777776 6270 17   1526  	eax7	-2,7		Get PDL back.
    001731  4a  4 00146 7561 20   1527  	stq	lisp_static_vars_$masked
    001732  4a  4 00150 2341 20   1528  	szn	lisp_static_vars_$deferred_interrupt Any?
    001733  0a   001311 6000 00   1529  	tze	return		Finish normal return
                                  1530  
                                  1531  	enter_pl1_code	push
    001734  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    001735  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    001736  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    001737  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    001740  aa   000060 6270 00         	push	
    001741  aa  7 00040 2721 20
    001742  4a  4 00066 3521 20         	eppbp	lisp_subr_tv_$..lisp..
    001743  aa  6 00026 2521 00         	spribp	sp|stack_frame.entry_ptr
    001744  0a   000560 3500 00   1532  	eppap	null_argl
    001745  4a  4 00152 3521 20   1533  	short_call lisp_fault_handler_$interrupt_poll
    001746  aa  7 00036 6701 20
    001747  aa  6 00030 3701 20
                                  1534  	exit_pl1_code	pop
    001750  aa  6 00000 3521 00         	eppbp	sp|0
    001751                              	inhibit	on
    001751  aa  7 00024 2523 00         	spribp	sb|stack_header.stack_end_ptr
    001752  aa  6 00020 3723 20         	eppsp	sp|stack_frame.prev_sp,*
    001753                              	inhibit	off
    001753  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001754  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001755  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001756  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001757  0a   001311 7100 00   1535  	tra	return
                                  1536  
                                  1537  
                                  1538  "This next character is called by lisp_prog_fns_, to accomplish quite
                                  1539  "the same when the interpreter unwinds an unwp frame.  We are coming
                                  1540  "from the PL/I environment, and we must pop the unm frame as well.
                                  1541  
                        001760    1542  	segdef	xec_unwprot_compiled_handler
    001760                        1543  xec_unwprot_compiled_handler:
    001760  aa  7 00046 2721 20   1544  	getlp
                                  1545  	exit_pl1_code
    001761  4a  4 00026 3511 20         	epbpab	lisp_static_vars_$unmkd_ptr,*
    001762  4a  4 00072 3501 20         	eppap	lisp_static_vars_$stack_ptr,*
    001763  4a  4 00062 2271 20         	ldx7	lisp_static_vars_$unmkd_ptr+1
    001764  aa  1 00016 4501 00         	stz	ab|in_pl1_code
    001765  0a   001707 2720 00   1546  	tspbp	unwind_protect_end	Hah, hah hah.
                                  1547  	enter_pl1_code
    001766  aa  1 00044 3701 20         	epplp	ab|system_lp,*
    001767  4a  4 00062 7471 20         	stx7	lisp_static_vars_$unmkd_ptr+1
    001770  4a  4 00064 2501 20         	spriap	lisp_static_vars_$stack_ptr
    001771  aa  1 00016 5541 00         	stc1	ab|in_pl1_code
    001772  aa  7 00044 7101 20   1548  	short_return
                                  1549  
                                  1550  	end
ENTRY SEQUENCES
     
    001773  5a   000031 0000 00
    001774  aa  7 00046 2721 20
    001775  0a   000000 7100 00

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001776  5a   000003 000000 
    001777  5a   000045 600000 
    002000  aa   000000 000000 
    002001  55   000011 000002 
    002002  5a   000002 400003 
    002003  55   000006 000011 
    002004  aa  012 154 151 163
    002005  aa  160 137 157 160
    002006  aa  162 163 137 000
    002007  55   000024 000003 
    002010  0a   001760 400000 
    002011  55   000014 000003 
    002012  aa  034 170 145 143         xec_unwprot_compiled_handler
    002013  aa  137 165 156 167
    002014  aa  160 162 157 164
    002015  aa  137 143 157 155
    002016  aa  160 151 154 145
    002017  aa  144 137 150 141
    002020  aa  156 144 154 145
    002021  aa  162 000 000 000
    002022  55   000031 000011 
    002023  0a   000414 400000 
    002024  55   000027 000003 
    002025  aa  005 163 164 157         store
    002026  aa  162 145 000 000
    002027  55   000036 000024 
    002030  0a   001774 500000 
    002031  55   000034 000003 
    002032  aa  004 151 156 151         init
    002033  aa  164 000 000 000
    002034  55   000002 000031 
    002035  6a   000000 400002 
    002036  55   000041 000003 
    002037  aa  014 163 171 155         symbol_table
    002040  aa  142 157 154 137
    002041  aa  164 141 142 154
    002042  aa  145 000 000 000

DEFINITIONS HASH TABLE

    002043  aa   000000 000015 
    002044  aa   000000 000000 
    002045  aa   000000 000000 
    002046  aa   000000 000000 
    002047  aa   000000 000000 
    002050  aa   000000 000000 
    002051  5a   000024 000000 
    002052  5a   000011 000000 
    002053  5a   000036 000000 
    002054  aa   000000 000000 
    002055  aa   000000 000000 
    002056  5a   000031 000000 
    002057  aa   000000 000000 
    002060  aa   000000 000000 

EXTERNAL NAMES

    002061  aa  016 151 156 164         interrupt_poll
    002062  aa  145 162 162 165
    002063  aa  160 164 137 160
    002064  aa  157 154 154 000
    002065  aa  023 154 151 163         lisp_fault_handler_
    002066  aa  160 137 146 141
    002067  aa  165 154 164 137
    002070  aa  150 141 156 144
    002071  aa  154 145 162 137
    002072  aa  022 144 145 146         deferred_interrupt
    002073  aa  145 162 162 145
    002074  aa  144 137 151 156
    002075  aa  164 145 162 162
    002076  aa  165 160 164 000
    002077  aa  006 155 141 163         masked
    002100  aa  153 145 144 000
    002101  aa  012 165 156 167         unwp_frame
    002102  aa  160 137 146 162
    002103  aa  141 155 145 000
    002104  aa  013 143 141 144         cad_op_barf
    002105  aa  137 157 160 137
    002106  aa  142 141 162 146
    002107  aa  013 143 163 144         csd_op_barf
    002110  aa  137 157 160 137
    002111  aa  142 141 162 146
    002112  aa  021 164 150 162         throw_to_no_catch
    002113  aa  157 167 137 164
    002114  aa  157 137 156 157
    002115  aa  137 143 141 164
    002116  aa  143 150 000 000
    002117  aa  011 165 156 167         unwinder_
    002120  aa  151 156 144 145
    002121  aa  162 137 000 000
    002122  aa  006 145 162 162         err_op
    002123  aa  137 157 160 000
    002124  aa  015 165 156 163         unseen_go_tag
    002125  aa  145 145 156 137
    002126  aa  147 157 137 164
    002127  aa  141 147 000 000
    002130  aa  005 143 164 162         ctrlW
    002131  aa  154 127 000 000
    002132  aa  005 143 164 162         ctrlR
    002133  aa  154 122 000 000
    002134  aa  005 143 164 162         ctrlQ
    002135  aa  154 121 000 000
    002136  aa  005 143 141 154         callf
    002137  aa  154 146 000 000
    002140  aa  005 143 141 154         call1
    002141  aa  154 061 000 000
    002142  aa  004 145 166 141         eval
    002143  aa  154 000 000 000
    002144  aa  015 154 151 163         lisp_unwinder
    002145  aa  160 137 165 156
    002146  aa  167 151 156 144
    002147  aa  145 162 000 000
    002150  aa  016 154 151 163         lisp_prog_fns_
    002151  aa  160 137 160 162
    002152  aa  157 147 137 146
    002153  aa  156 163 137 000
    002154  aa  014 154 151 163         lisp_linker_
    002155  aa  160 137 154 151
    002156  aa  156 153 145 162
    002157  aa  137 000 000 000
    002160  aa  013 154 151 163         lisp_error_
    002161  aa  160 137 145 162
    002162  aa  162 157 162 137
    002163  aa  010 056 056 154         ..lisp..
    002164  aa  151 163 160 056
    002165  aa  056 000 000 000
    002166  aa  015 154 151 163         lisp_subr_tv_
    002167  aa  160 137 163 165
    002170  aa  142 162 137 164
    002171  aa  166 137 000 000
    002172  aa  011 163 164 141         stack_ptr
    002173  aa  143 153 137 160
    002174  aa  164 162 000 000
    002175  aa  005 145 166 141         eval_
    002176  aa  154 137 000 000
    002177  aa  005 154 151 163         lisp_
    002200  aa  160 137 000 000
    002201  aa  014 156 157 164         not_an_array
    002202  aa  137 141 156 137
    002203  aa  141 162 162 141
    002204  aa  171 000 000 000
    002205  aa  021 163 164 157         store_not_allowed
    002206  aa  162 145 137 156
    002207  aa  157 164 137 141
    002210  aa  154 154 157 167
    002211  aa  145 144 000 000
    002212  aa  030 143 141 156         cant_subscript_readtable
    002213  aa  164 137 163 165
    002214  aa  142 163 143 162
    002215  aa  151 160 164 137
    002216  aa  162 145 141 144
    002217  aa  164 141 142 154
    002220  aa  145 000 000 000
    002221  aa  024 144 145 141         dead_array_reference
    002222  aa  144 137 141 162
    002223  aa  162 141 171 137
    002224  aa  162 145 146 145
    002225  aa  162 145 156 143
    002226  aa  145 000 000 000
    002227  aa  023 142 141 144         bad_array_subscript
    002230  aa  137 141 162 162
    002231  aa  141 171 137 163
    002232  aa  165 142 163 143
    002233  aa  162 151 160 164
    002234  aa  021 154 151 163         lisp_error_table_
    002235  aa  160 137 145 162
    002236  aa  162 157 162 137
    002237  aa  164 141 142 154
    002240  aa  145 137 000 000
    002241  aa  013 143 157 156         cons_string
    002242  aa  163 137 163 164
    002243  aa  162 151 156 147
    002244  aa  022 164 145 162         terminate_list_opr
    002245  aa  155 151 156 141
    002246  aa  164 145 137 154
    002247  aa  151 163 164 137
    002250  aa  157 160 162 000
    002251  aa  017 141 160 160         append_list_opr
    002252  aa  145 156 144 137
    002253  aa  154 151 163 164
    002254  aa  137 157 160 162
    002255  aa  016 142 145 147         begin_list_opr
    002256  aa  151 156 137 154
    002257  aa  151 163 164 137
    002260  aa  157 160 162 000
    002261  aa  011 170 143 157         xcons_opr
    002262  aa  156 163 137 157
    002263  aa  160 162 000 000
    002264  aa  011 156 143 157         ncons_opr
    002265  aa  156 163 137 157
    002266  aa  160 162 000 000
    002267  aa  010 143 157 156         cons_opr
    002270  aa  163 137 157 160
    002271  aa  162 000 000 000
    002272  aa  013 154 151 163         lisp_alloc_
    002273  aa  160 137 141 154
    002274  aa  154 157 143 137
    002275  aa  011 165 156 155         unmkd_ptr
    002276  aa  153 144 137 160
    002277  aa  164 162 000 000
    002300  aa  013 143 141 164         catch_frame
    002301  aa  143 150 137 146
    002302  aa  162 141 155 145
    002303  aa  011 145 162 162         err_frame
    002304  aa  137 146 162 141
    002305  aa  155 145 000 000
    002306  aa  007 141 162 147         argatom
    002307  aa  141 164 157 155
    002310  aa  013 142 151 156         binding_top
    002311  aa  144 151 156 147
    002312  aa  137 164 157 160
    002313  aa  020 156 157 137         no_snapped_links
    002314  aa  163 156 141 160
    002315  aa  160 145 144 137
    002316  aa  154 151 156 153
    002317  aa  163 000 000 000
    002320  aa  012 141 162 162         array_atom
    002321  aa  141 171 137 141
    002322  aa  164 157 155 000
    002323  aa  011 163 164 141         star_rset
    002324  aa  162 137 162 163
    002325  aa  145 164 000 000
    002326  aa  021 154 151 163         lisp_static_vars_
    002327  aa  160 137 163 164
    002330  aa  141 164 151 143
    002331  aa  137 166 141 162
    002332  aa  163 137 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    002333  aa   000004 000000 
    002334  55   000067 000063 
    002335  aa   000004 000000 
    002336  55   000330 000074 
    002337  aa   000004 000000 
    002340  55   000330 000101 
    002341  aa   000004 000000 
    002342  55   000330 000103 
    002343  aa   000004 000000 
    002344  55   000236 000106 
    002345  aa   000004 000000 
    002346  55   000236 000111 
    002347  aa   000004 000000 
    002350  55   000236 000114 
    002351  aa   000004 000000 
    002352  55   000121 000121 
    002353  aa   000004 000000 
    002354  55   000162 000124 
    002355  aa   000004 000000 
    002356  55   000236 000126 
    002357  aa   000004 000000 
    002360  55   000330 000132 
    002361  aa   000004 000000 
    002362  55   000330 000134 
    002363  aa   000004 000000 
    002364  55   000330 000136 
    002365  aa   000004 000000 
    002366  55   000201 000140 
    002367  aa   000004 000000 
    002370  55   000201 000142 
    002371  aa   000004 000000 
    002372  55   000201 000144 
    002373  aa   000004 000000 
    002374  55   000152 000146 
    002375  aa   000004 000000 
    002376  55   000156 000156 
    002377  aa   000004 000000 
    002400  55   000162 000162 
    002401  aa   000004 000000 
    002402  55   000170 000165 
    002403  aa   000004 000000 
    002404  55   000330 000174 
    002405  aa   000004 000000 
    002406  55   000201 000177 
    002407  aa   000004 000000 
    002410  55   000236 000203 
    002411  aa   000004 000000 
    002412  55   000236 000207 
    002413  aa   000004 000000 
    002414  55   000236 000214 
    002415  aa   000004 000000 
    002416  55   000236 000223 
    002417  aa   000004 000000 
    002420  55   000236 000231 
    002421  aa   000004 000000 
    002422  55   000274 000243 
    002423  aa   000004 000000 
    002424  55   000274 000246 
    002425  aa   000004 000000 
    002426  55   000274 000253 
    002427  aa   000004 000000 
    002430  55   000274 000257 
    002431  aa   000004 000000 
    002432  55   000274 000263 
    002433  aa   000004 000000 
    002434  55   000274 000266 
    002435  aa   000004 000000 
    002436  55   000274 000271 
    002437  aa   000004 000000 
    002440  55   000330 000277 
    002441  aa   000004 000000 
    002442  55   000330 000302 
    002443  aa   000004 000000 
    002444  55   000330 000305 
    002445  aa   000004 000000 
    002446  55   000330 000310 
    002447  aa   000004 000000 
    002450  55   000330 000312 
    002451  aa   000004 000000 
    002452  55   000330 000315 
    002453  aa   000004 000000 
    002454  55   000330 000322 
    002455  aa   000004 000000 
    002456  55   000330 000325 
    002457  aa   000001 000000 
    002460  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    002461  5a   000335 000000 
    002462  5a   000337 000000 
    002463  5a   000341 000000 
    002464  5a   000343 000001 
    002465  5a   000345 000000 
    002466  5a   000347 000000 
    002467  5a   000351 000000 
    002470  5a   000353 000000 
    002471  5a   000355 000000 
    002472  5a   000357 000000 
    002473  5a   000361 000000 
    002474  5a   000363 000000 
    002475  5a   000365 000000 
    002476  5a   000443 000000 
    002477  5a   000367 000000 
    002500  5a   000371 000000 
    002501  5a   000373 000000 
    002502  5a   000375 000000 
    002503  5a   000445 000000 
    002504  5a   000377 000000 
    002505  5a   000401 000000 
    002506  5a   000403 000000 
    002507  5a   000405 000000 
    002510  5a   000441 000001 
    002511  5a   000407 000000 
    002512  5a   000411 000000 
    002513  5a   000413 000000 
    002514  5a   000415 000000 
    002515  5a   000417 000000 
    002516  5a   000421 000000 
    002517  5a   000423 000000 
    002520  5a   000425 000000 
    002521  5a   000427 000000 
    002522  5a   000431 000000 
    002523  5a   000433 000000 
    002524  5a   000435 000000 
    002525  5a   000437 000000 
    002526  5a   000441 000000 
    002527  5a   000443 000001 
    002530  5a   000445 000001 
    002531  5a   000447 000000 
    002532  5a   000451 000001 
    002533  5a   000453 000000 
    002534  5a   000455 000000 
    002535  5a   000457 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001776 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000154 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         lisp_static_vars_|star_rset
    000011  5a   000537 0000 20
    000012  9a   777766 0000 46         lisp_static_vars_|array_atom
    000013  5a   000536 0000 00
    000014  9a   777764 0000 46         lisp_static_vars_|no_snapped_links
    000015  5a   000535 0000 00
    000016  9a   777762 0000 46         lisp_static_vars_|binding_top
    000017  5a   000534 0000 00
    000020  9a   777760 0000 46         lisp_static_vars_|argatom
    000021  5a   000533 0000 00
    000022  9a   777756 0000 46         lisp_static_vars_|err_frame
    000023  5a   000532 0000 00
    000024  9a   777754 0000 46         lisp_static_vars_|catch_frame
    000025  5a   000531 0000 00
    000026  9a   777752 0000 46         lisp_static_vars_|unmkd_ptr
    000027  5a   000530 0000 20
    000030  9a   777750 0000 46         lisp_alloc_|cons_opr
    000031  5a   000527 0000 00
    000032  9a   777746 0000 46         lisp_alloc_|ncons_opr
    000033  5a   000526 0000 00
    000034  9a   777744 0000 46         lisp_alloc_|xcons_opr
    000035  5a   000525 0000 00
    000036  9a   777742 0000 46         lisp_alloc_|begin_list_opr
    000037  5a   000524 0000 00
    000040  9a   777740 0000 46         lisp_alloc_|append_list_opr
    000041  5a   000523 0000 00
    000042  9a   777736 0000 46         lisp_alloc_|terminate_list_opr
    000043  5a   000522 0000 00
    000044  9a   777734 0000 46         lisp_alloc_|cons_string
    000045  5a   000521 0000 00
    000046  9a   777732 0000 46         lisp_error_table_|bad_array_subscript
    000047  5a   000520 0000 00
    000050  9a   777730 0000 46         lisp_error_table_|dead_array_reference
    000051  5a   000517 0000 00
    000052  9a   777726 0000 46         lisp_error_table_|cant_subscript_readtable
    000053  5a   000516 0000 00
    000054  9a   777724 0000 46         lisp_error_table_|store_not_allowed
    000055  5a   000515 0000 00
    000056  9a   777722 0000 46         lisp_error_table_|not_an_array
    000057  5a   000514 0000 00
    000060  9a   777720 0000 46         lisp_|eval_
    000061  5a   000513 0000 00
    000062  9a   777716 0000 46         lisp_static_vars_|unmkd_ptr
    000063  5a   000512 0000 00
    000064  9a   777714 0000 46         lisp_static_vars_|stack_ptr
    000065  5a   000511 0000 00
    000066  9a   777712 0000 46         lisp_subr_tv_|..lisp..
    000067  5a   000510 0000 00
    000070  9a   777710 0000 46         lisp_error_|lisp_error_
    000071  5a   000507 0000 00
    000072  9a   777706 0000 46         lisp_static_vars_|stack_ptr
    000073  5a   000511 0000 20
    000074  9a   777704 0000 46         lisp_linker_|lisp_linker_
    000075  5a   000506 0000 00
    000076  9a   777702 0000 46         lisp_static_vars_|unmkd_ptr
    000077  5a   000530 0000 00
    000100  9a   777700 0000 46         lisp_static_vars_|err_frame
    000101  5a   000505 0000 20
    000102  9a   777676 0000 46         lisp_prog_fns_|lisp_unwinder
    000103  5a   000504 0000 00
    000104  9a   777674 0000 46         lisp_|eval
    000105  5a   000503 0000 00
    000106  9a   777672 0000 46         lisp_|call1
    000107  5a   000502 0000 00
    000110  9a   777670 0000 46         lisp_|callf
    000111  5a   000501 0000 00
    000112  9a   777666 0000 46         lisp_static_vars_|catch_frame
    000113  5a   000500 0000 20
    000114  9a   777664 0000 46         lisp_static_vars_|ctrlQ
    000115  5a   000477 0000 00
    000116  9a   777662 0000 46         lisp_static_vars_|ctrlR
    000117  5a   000476 0000 00
    000120  9a   777660 0000 46         lisp_static_vars_|ctrlW
    000121  5a   000475 0000 00
    000122  9a   777656 0000 46         lisp_static_vars_|ctrlQ
    000123  5a   000477 0000 20
    000124  9a   777654 0000 46         lisp_static_vars_|ctrlR
    000125  5a   000476 0000 20
    000126  9a   777652 0000 46         lisp_static_vars_|ctrlW
    000127  5a   000475 0000 20
    000130  9a   777650 0000 46         lisp_error_table_|unseen_go_tag
    000131  5a   000474 0000 00
    000132  9a   777646 0000 46         lisp_error_|err_op
    000133  5a   000473 0000 00
    000134  9a   777644 0000 46         unwinder_|unwinder_
    000135  5a   000472 0000 00
    000136  9a   777642 0000 46         lisp_error_table_|throw_to_no_catch
    000137  5a   000471 0000 00
    000140  9a   777640 0000 46         lisp_error_table_|csd_op_barf
    000141  5a   000470 0000 00
    000142  9a   777636 0000 46         lisp_error_table_|cad_op_barf
    000143  5a   000467 0000 00
    000144  9a   777634 0000 46         lisp_static_vars_|unwp_frame
    000145  5a   000466 0000 00
    000146  9a   777632 0000 46         lisp_static_vars_|masked
    000147  5a   000465 0000 00
    000150  9a   777630 0000 46         lisp_static_vars_|deferred_interrupt
    000151  5a   000464 0000 00
    000152  9a   777626 0000 46         lisp_fault_handler_|interrupt_poll
    000153  5a   000463 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   677133 115500 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000426 
    000020  aa   000000 000250 
    000021  aa   000000 000366 
    000022  aa   000412 000250 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000010 
    000066  aa   000126 000057 
    000067  aa   147740 446273 
    000070  aa   000000 114774 
    000071  aa   461243 400000 
    000072  aa   000142 000044 
    000073  aa   106701 741715 
    000074  aa   000000 110670 
    000075  aa   211413 600000 
    000076  aa   000153 000044 
    000077  aa   120017 346605 
    000100  aa   000000 112002 
    000101  aa   404115 200000 
    000102  aa   000164 000044 
    000103  aa   106701 741760 
    000104  aa   000000 110670 
    000105  aa   211451 600000 
    000106  aa   000175 000045 
    000107  aa   120017 346602 
    000110  aa   000000 112002 
    000111  aa   404115 000000 
    000112  aa   000207 000047 
    000113  aa   106701 741731 
    000114  aa   000000 110670 
    000115  aa   211444 000000 
    000116  aa   000221 000066 
    000117  aa   147714 750316 
    000120  aa   000000 114774 
    000121  aa   453561 000000 
    000122  aa   000237 000041 
    000123  aa   052721 247134 
    000124  aa   000000 105272 
    000125  aa   317215 400000 
    000126  aa   076163 160145          >special_ldd>install>MR12.0-1206>lisp_oprs_.alm
    000127  aa   143151 141154 
    000130  aa   137154 144144 
    000131  aa   076151 156163 
    000132  aa   164141 154154 
    000133  aa   076115 122061 
    000134  aa   062056 060055 
    000135  aa   061062 060066 
    000136  aa   076154 151163 
    000137  aa   160137 157160 
    000140  aa   162163 137056 
    000141  aa   141154 155040 
    000142  aa   076154 144144          >ldd>include>lisp_unmkd_pdl.incl.alm
    000143  aa   076151 156143 
    000144  aa   154165 144145 
    000145  aa   076154 151163 
    000146  aa   160137 165156 
    000147  aa   155153 144137 
    000150  aa   160144 154056 
    000151  aa   151156 143154 
    000152  aa   056141 154155 
    000153  aa   076154 144144          >ldd>include>lisp_stack_seg.incl.alm
    000154  aa   076151 156143 
    000155  aa   154165 144145 
    000156  aa   076154 151163 
    000157  aa   160137 163164 
    000160  aa   141143 153137 
    000161  aa   163145 147056 
    000162  aa   151156 143154 
    000163  aa   056141 154155 
    000164  aa   076154 144144          >ldd>include>lisp_array_fmt.incl.alm
    000165  aa   076151 156143 
    000166  aa   154165 144145 
    000167  aa   076154 151163 
    000170  aa   160137 141162 
    000171  aa   162141 171137 
    000172  aa   146155 164056 
    000173  aa   151156 143154 
    000174  aa   056141 154155 
    000175  aa   076154 144144          >ldd>include>lisp_name_codes.incl.alm
    000176  aa   076151 156143 
    000177  aa   154165 144145 
    000200  aa   076154 151163 
    000201  aa   160137 156141 
    000202  aa   155145 137143 
    000203  aa   157144 145163 
    000204  aa   056151 156143 
    000205  aa   154056 141154 
    000206  aa   155040 040040 
    000207  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000210  aa   076151 156143 
    000211  aa   154165 144145 
    000212  aa   076154 151163 
    000213  aa   160137 157142 
    000214  aa   152145 143164 
    000215  aa   137164 171160 
    000216  aa   145163 056151 
    000217  aa   156143 154056 
    000220  aa   141154 155040 
    000221  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000222  aa   143151 141154 
    000223  aa   137154 144144 
    000224  aa   076151 156163 
    000225  aa   164141 154154 
    000226  aa   076115 122061 
    000227  aa   062056 060055 
    000230  aa   061062 060066 
    000231  aa   076163 164141 
    000232  aa   143153 137150 
    000233  aa   145141 144145 
    000234  aa   162056 151156 
    000235  aa   143154 056141 
    000236  aa   154155 040040 
    000237  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000240  aa   076151 156143 
    000241  aa   154165 144145 
    000242  aa   076163 164141 
    000243  aa   143153 137146 
    000244  aa   162141 155145 
    000245  aa   056151 156143 
    000246  aa   154056 141154 
    000247  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

                ..lisp..                 lisp_oprs_:   465,  501,  531, 1455, 1531.
        1124    already_got_x5           lisp_oprs_:   872,  876.
         102    append_list_op           lisp_oprs_:   130,
                                         lisp_stack_seg:      43.
                append_list_opr          lisp_oprs_:   129.
          20    argatom                  lisp_oprs_:   588,  644.
      777774    argl                     lisp_oprs_:    49,  887.
        1426    argl_h_of_1              lisp_oprs_:  1236, 1242.
         200    Array                    lisp_oprs_:   241,  262, 1347,
                                         lisp_object_types:   25.
          12    array_atom               lisp_oprs_:   348,  365, 1379, 1380.
         171    array_checking_loop      lisp_oprs_:   206,  213.
           2    array_data_ptr           lisp_oprs_:   183,  283,  284,  285,  286,  305,  323, 1361,
                                         lisp_array_fmt:       9.
           7    array_info.2ndims        lisp_oprs_:   184,  197,  214,
                                         lisp_array_fmt:      12.
           0    array_info.gc_mark       lisp_array_fmt:       7.
           0    array_info.ndims         lisp_oprs_:   371, 1350,
                                         lisp_array_fmt:       6.
           7    array_info.type          lisp_oprs_:   265,  278,  297,  377,  394,  436, 1352,
                                         lisp_array_fmt:      11.
         122    array_info_for_store     lisp_oprs_:    83,  200,  228,  276,  295,  434,
                                         lisp_stack_seg:      51.
         326    array_link_snap_op       lisp_oprs_:    76,  351.
         126    array_link_snap_opr      lisp_oprs_:    77,
                                         lisp_stack_seg:      53.
           4    array_load_sequence      lisp_oprs_:   202,  223,  231,
                                         lisp_array_fmt:      10.
         124    array_offset_for_store   lisp_oprs_:   201,  229,  277,  296,  435,
                                         lisp_stack_seg:      52.
         112    array_operator           lisp_oprs_:    73,
                                         lisp_stack_seg:      47.
          10    array_pointer            lisp_oprs_:    71,
                                         lisp_stack_seg:      10.
         220    array_reference_err      lisp_oprs_:   235,  328.
         150    array_reference_op       lisp_oprs_:    72,  179.
         157    array_ref_without_checking     lisp_oprs_:   189,  215.
         171    array_ref_with_full_checking   lisp_oprs_:   187,  204.
       77700    Atomic                   lisp_object_types:   19.
       10000    Atsym                    lisp_oprs_:  1279, 1319, 1376,
                                         lisp_object_types:   18.
                bad_array_subscript      lisp_oprs_:   234.
         217    bad_subscript            lisp_oprs_:   209,  211,  222,  224,  233.
        1433    bad_throw                lisp_oprs_:  1210, 1253.
         100    begin_list_op            lisp_oprs_:   128,
                                         lisp_stack_seg:      42.
                begin_list_opr           lisp_oprs_:   127.
         174    begin_unmkd_stack        lisp_stack_seg:      66.
        1000    Bignum                   lisp_object_types:   20.
        1000    Big_fixed                lisp_oprs_:  1117,
                                         lisp_object_types:   29.
         631    bind                     lisp_oprs_:    84,  590.
                binding_top              lisp_oprs_:   587, 1040, 1047.
          16    binding_top_plus_1       lisp_oprs_:   587,  597,  602,  693.
         645    bind_loop                lisp_oprs_:   604,  623.
          20    bind_op                  lisp_oprs_:    85,
                                         lisp_stack_seg:      17.
         670    bind_vec                 lisp_oprs_:   619,  626.
        1525    cad00                    lisp_oprs_:  1349, 1393.
        1541    cad01                    lisp_oprs_:  1362, 1371.
        1554    cadget                   lisp_oprs_:  1348, 1376.
        1561    cadget0                  lisp_oprs_:  1382, 1389.
        1571    cadget1                  lisp_oprs_:  1387, 1391.
        1574    cad_barf                 lisp_oprs_:  1351, 1354, 1377, 1384, 1395.
                cad_op_barf              lisp_oprs_:  1396.
        1070    call                     lisp_oprs_:    94,  844.
                call1                    lisp_oprs_:   880.
                callf                    lisp_oprs_:   891.
        1125    call_2_f                 lisp_oprs_:   863,  884.
           1    call_array_operator      lisp_array_fmt:       8.
        1170    call_offset              stack_header:        80.
          32    call_op                  lisp_oprs_:    95,  163,
                                         lisp_stack_seg:      22.
                cant_subscript_readtable       lisp_oprs_:   268.
        1134    catch1                   lisp_oprs_:    96,  911.
          34    catch1_op                lisp_oprs_:    97,
                                         lisp_stack_seg:      23.
        1137    catch2                   lisp_oprs_:    98,  924.
          36    catch2_op                lisp_oprs_:    99,
                                         lisp_stack_seg:      24.
                catch_frame              lisp_oprs_:   938,  944,  967,  999, 1208, 1225.
          24    catch_frame_plus_1       lisp_oprs_:   999, 1003.
        1372    catch_search             lisp_oprs_:  1209, 1221.
         373    check_for_Sexpr_array    lisp_oprs_:   375,  393.
        1335    compare                  lisp_oprs_:   133, 1145.
         106    compare_op               lisp_oprs_:   134,
                                         lisp_stack_seg:      45.
          72    cons_op                  lisp_oprs_:   122,  247,
                                         lisp_stack_seg:      39.
                cons_opr                 lisp_oprs_:   121.
                cons_string              lisp_oprs_:   140.
         136    cons_string_op           lisp_oprs_:   141, 1311,
                                         lisp_stack_seg:      57.
         335    continue_array_search    lisp_oprs_:   359,  366.
         376    couldnt_snap_array_link  lisp_oprs_:   362,  372,  378,  397.
         360    could_snap_array_link    lisp_oprs_:   379,  396.
        1521    create_array_descriptor  lisp_oprs_:   148, 1344.
         132    create_array_desc_op     lisp_oprs_:   149,
                                         lisp_stack_seg:      55.
        1444    create_string_descriptor       lisp_oprs_:   144, 1274.
         130    create_string_desc_op    lisp_oprs_:   145,
                                         lisp_stack_seg:      54.
        1462    create_varying_string    lisp_oprs_:   146, 1293.
         140    create_varying_string_op       lisp_oprs_:   147,
                                               lisp_stack_seg:      58.
        1453    csd00                    lisp_oprs_:  1278, 1282.
        1457    csd_barf                 lisp_oprs_:  1280, 1287, 1325.
                csd_op_barf              lisp_oprs_:  1288.
                ctrlQ                    lisp_oprs_:  1028, 1051.
                ctrlR                    lisp_oprs_:  1030, 1052.
                ctrlW                    lisp_oprs_:  1032, 1053.
        1507    cvs00                    lisp_oprs_:  1320, 1324.
        1511    cvs01                    lisp_oprs_:  1322, 1326.
           6    Dead_array               lisp_array_fmt:      20.
         114    dead_array_operator      lisp_oprs_:    75,
                                         lisp_stack_seg:      48.
                dead_array_reference     lisp_oprs_:   264.
         244    dead_array_reference_op  lisp_oprs_:    74,  257.
                deferred_interrupt       lisp_oprs_:  1528.
        1174    entry_offset             stack_header:        84.
        1356    err                      lisp_oprs_:   114, 1174.
         755    errset1                  lisp_oprs_:    88,  715,  730.
          24    errset1_op               lisp_oprs_:    89,
                                         lisp_stack_seg:      19.
         760    errset2                  lisp_oprs_:    90,  728.
          26    errset2_op               lisp_oprs_:    91,
                                         lisp_stack_seg:      20.
         764    errset_com               lisp_oprs_:   717,  733.
                err_frame                lisp_oprs_:   747,  755,  772,  782,  812.
          22    err_frame_plus_1         lisp_oprs_:   812,  817.
          64    err_op                   lisp_oprs_:   115, 1177,
                                         lisp_stack_seg:      36.
        1010    err_return               lisp_oprs_:   751,  766.
        1045    err_ret_0                lisp_oprs_:   788,  791.
                eval                     lisp_oprs_:   790.
                eval_                    lisp_oprs_:   425,  430, 1090.
         202    external_array_reference       lisp_oprs_:   185,  217.
         211    ext_array_ref_no_check   lisp_oprs_:   219,  225.
         144    fault_tag_3_number_1     lisp_oprs_:    70,  172.
         146    fault_tag_3_number_2     lisp_oprs_:    82,  175.
      777772    fcn                      lisp_oprs_:    48,  888.
         100    File                     lisp_object_types:   30.
       40000    Fixed                    lisp_object_types:   15.
           2    Fixnum_array             lisp_array_fmt:      16.
       40047    fixnum_type              lisp_oprs_:   137,  208,  221,  230,  445,  494,  640, 1145,
                                         lisp_object_types:   34.
         705    flags4                   lisp_oprs_:   608,  631,  643.
         700    flags5                   lisp_oprs_:   632,  637.
       20000    Float                    lisp_oprs_:  1115,
                                         lisp_object_types:   16.
        1341    floatcomp                lisp_oprs_:  1146, 1150.
         274    floating_store_op        lisp_oprs_:    80,  294.
         120    floating_store_operator  lisp_oprs_:    81,
                                         lisp_stack_seg:      50.
         301    floating_store_table     lisp_oprs_:   298,  301.
           3    Flonum_array             lisp_array_fmt:      17.
       20047    flonum_type              lisp_oprs_:   138,  314,  321,  446,
                                         lisp_object_types:   35.
      777707    fn_abs                   lisp_name_codes:     53.
      777720    fn_add1                  lisp_name_codes:     44.
      777674    fn_add1_fix              lisp_name_codes:     64.
      777673    fn_add1_flo              lisp_name_codes:     65.
      777625    fn_alarmclock            lisp_name_codes:    103.
      777611    fn_allfiles              lisp_name_codes:    115.
      777617    fn_alphalessp            lisp_name_codes:    109.
      777657    fn_apply                 lisp_name_codes:     77.
      777765    fn_arg                   lisp_name_codes:     10.
      777727    fn_args                  lisp_name_codes:     37.
      777740    fn_array                 lisp_name_codes:     28.
      777537    fn_arraydims             lisp_name_codes:    157.
      777751    fn_ascii                 lisp_name_codes:     19.
      777631    fn_atan                  lisp_name_codes:     99.
      777650    fn_baktrace              lisp_name_codes:     84.
      777647    fn_bltarray              lisp_name_codes:     85.
      777705    fn_boole                 lisp_name_codes:     55.
      777643    fn_boundp                lisp_name_codes:     89.
      777654    fn_catch                 lisp_name_codes:     80.
      777741    fn_catenate              lisp_name_codes:     27.
      777544    fn_charpos               lisp_name_codes:    152.
      777610    fn_chrct                 lisp_name_codes:    116.
      777557    fn_clear_input           lisp_name_codes:    141.
      777553    fn_cline                 lisp_name_codes:    145.
      777607    fn_close                 lisp_name_codes:    117.
      777637    fn_cos                   lisp_name_codes:     93.
      777732    fn_CtoI                  lisp_name_codes:     34.
      777561    fn_cursorpos             lisp_name_codes:    139.
      777756    fn_defaultf              lisp_name_codes:     17.
      777747    fn_definedp              lisp_name_codes:     21.
      777731    fn_defsubr               lisp_name_codes:     35.
      777651    fn_defun                 lisp_name_codes:     83.
      777744    fn_delete                lisp_name_codes:     24.
      777606    fn_deletef               lisp_name_codes:    118.
      777743    fn_delq                  lisp_name_codes:     25.
      777711    fn_difference            lisp_name_codes:     51.
      777664    fn_diff_fix              lisp_name_codes:     72.
      777663    fn_diff_flo              lisp_name_codes:     73.
      777516    fn_displace              lisp_name_codes:    174.
      777766    fn_do                    lisp_name_codes:      9.
      777535    fn_dumparrays            lisp_name_codes:    159.
      777540    fn_endpagefn             lisp_name_codes:    156.
      777605    fn_eoffn                 lisp_name_codes:    119.
      777621    fn_eql                   lisp_name_codes:    107.
      777760    fn_errframe              lisp_name_codes:     15.
      777761    fn_errprint              lisp_name_codes:     14.
      777655    fn_errset                lisp_name_codes:     79.
      777660    fn_eval                  lisp_name_codes:     76.
      777757    fn_evalframe             lisp_name_codes:     16.
      777520    fn_eval_when             lisp_name_codes:    172.
      777635    fn_exp                   lisp_name_codes:     95.
      777706    fn_expt                  lisp_name_codes:     54.
      777534    fn_expt_fix              lisp_name_codes:    160.
      777533    fn_expt_flo              lisp_name_codes:    161.
      777604    fn_filepos               lisp_name_codes:    120.
      777552    fn_fillarray             lisp_name_codes:    146.
      777701    fn_fix                   lisp_name_codes:     59.
      777700    fn_float                 lisp_name_codes:     60.
      777560    fn_force_output          lisp_name_codes:    140.
      777640    fn_freturn               lisp_name_codes:     92.
      777524    fn_fsc                   lisp_name_codes:    168.
      777612    fn_gcd                   lisp_name_codes:    114.
      777645    fn_gensym                lisp_name_codes:     87.
      777725    fn_get                   lisp_name_codes:     39.
      777615    fn_getchar               lisp_name_codes:    111.
      777724    fn_getl                  lisp_name_codes:     40.
      777735    fn_get_pname             lisp_name_codes:     31.
      777716    fn_greaterp              lisp_name_codes:     46.
      777620    fn_gt                    lisp_name_codes:    108.
      777554    fn_haipart               lisp_name_codes:    144.
      777555    fn_haulong               lisp_name_codes:    143.
      777525    fn_ifix                  lisp_name_codes:    167.
      777530    fn_in                    lisp_name_codes:    164.
      777513    fn_includef              lisp_name_codes:    177.
      777736    fn_index                 lisp_name_codes:     30.
      777603    fn_inpush                lisp_name_codes:    121.
      777632    fn_isqrt                 lisp_name_codes:     98.
      777733    fn_ItoC                  lisp_name_codes:     33.
      777715    fn_lessp                 lisp_name_codes:     47.
      777602    fn_linel                 lisp_name_codes:    122.
      777542    fn_linenum               lisp_name_codes:    154.
      777551    fn_listarray             lisp_name_codes:    147.
      777545    fn_listify               lisp_name_codes:    151.
      777536    fn_loadarrays            lisp_name_codes:    158.
      777634    fn_log                   lisp_name_codes:     96.
      777622    fn_ls                    lisp_name_codes:    106.
      777703    fn_lsh                   lisp_name_codes:     57.
      777734    fn_make_atom             lisp_name_codes:     32.
      777644    fn_makunbound            lisp_name_codes:     88.
      777522    fn_mapatoms              lisp_name_codes:    170.
      777676    fn_max                   lisp_name_codes:     62.
      777601    fn_mergef                lisp_name_codes:    123.
      777675    fn_min                   lisp_name_codes:     63.
      777714    fn_minus                 lisp_name_codes:     48.
      777623    fn_minusp                lisp_name_codes:    105.
      777600    fn_namelist              lisp_name_codes:    124.
      777577    fn_names                 lisp_name_codes:    125.
      777576    fn_namestring            lisp_name_codes:    126.
      777532    fn_nointerrupt           lisp_name_codes:    162.
      777515    fn_nth                   lisp_name_codes:    175.
      777514    fn_nthcdr                lisp_name_codes:    176.
      777627    fn_oddp                  lisp_name_codes:    101.
      777531    fn_open                  lisp_name_codes:    163.
      777614    fn_opena                 lisp_name_codes:    112.
      777575    fn_openi                 lisp_name_codes:    127.
      777574    fn_openo                 lisp_name_codes:    128.
      777527    fn_out                   lisp_name_codes:    165.
      777543    fn_pagel                 lisp_name_codes:    153.
      777541    fn_pagenum               lisp_name_codes:    155.
      777713    fn_plus                  lisp_name_codes:     49.
      777624    fn_plusp                 lisp_name_codes:    104.
      777670    fn_plus_fix              lisp_name_codes:     68.
      777667    fn_plus_flo              lisp_name_codes:     69.
      777573    fn_prin1                 lisp_name_codes:    129.
      777572    fn_princ                 lisp_name_codes:    130.
      777571    fn_print                 lisp_name_codes:    131.
      777656    fn_prog                  lisp_name_codes:     78.
      777523    fn_progv                 lisp_name_codes:    169.
      777723    fn_putprop               lisp_name_codes:     41.
      777710    fn_quotient              lisp_name_codes:     52.
      777662    fn_quot_fix              lisp_name_codes:     74.
      777661    fn_quot_flo              lisp_name_codes:     75.
      777556    fn_random                lisp_name_codes:    142.
      777570    fn_read                  lisp_name_codes:    132.
      777567    fn_readch                lisp_name_codes:    133.
      777566    fn_readstring            lisp_name_codes:    134.
      777517    fn_read_from_string      lisp_name_codes:    173.
      777677    fn_remainder             lisp_name_codes:     61.
      777722    fn_remprop               lisp_name_codes:     42.
      777565    fn_rename                lisp_name_codes:    135.
      777704    fn_rot                   lisp_name_codes:     56.
      777750    fn_rplaca                lisp_name_codes:     20.
      777616    fn_samepnamep            lisp_name_codes:    110.
      777721    fn_save                  lisp_name_codes:     43.
      777745    fn_set                   lisp_name_codes:     23.
      777764    fn_setarg                lisp_name_codes:     11.
      777746    fn_setq                  lisp_name_codes:     22.
      777562    fn_setsyntax             lisp_name_codes:    138.
      777564    fn_shortnamestring       lisp_name_codes:    136.
      777702    fn_signp                 lisp_name_codes:     58.
      777636    fn_sin                   lisp_name_codes:     94.
      777630    fn_sleep                 lisp_name_codes:    100.
      777550    fn_sort                  lisp_name_codes:    148.
      777547    fn_sortcar               lisp_name_codes:    149.
      777633    fn_sqrt                  lisp_name_codes:     97.
      777762    fn_sstatus               lisp_name_codes:     13.
      777730    fn_star_array            lisp_name_codes:     36.
      777646    fn_star_rearray          lisp_name_codes:     86.
      777641    fn_star_sstatus          lisp_name_codes:     91.
      777642    fn_star_status           lisp_name_codes:     90.
      777763    fn_status                lisp_name_codes:     12.
      777652    fn_store                 lisp_oprs_:   254,
                                         lisp_name_codes:     82.
      777742    fn_stringlength          lisp_name_codes:     26.
      777717    fn_sub1                  lisp_name_codes:     45.
      777672    fn_sub1_fix              lisp_name_codes:     66.
      777671    fn_sub1_flo              lisp_name_codes:     67.
      777737    fn_substr                lisp_name_codes:     29.
      777613    fn_sxhash                lisp_name_codes:    113.
      777726    fn_sysp                  lisp_name_codes:     38.
      777653    fn_throw                 lisp_name_codes:     81.
      777712    fn_times                 lisp_name_codes:     50.
      777666    fn_times_fix             lisp_name_codes:     70.
      777665    fn_times_flo             lisp_name_codes:     71.
      777526    fn_truename              lisp_name_codes:    166.
      777563    fn_tyi                   lisp_name_codes:    137.
      777626    fn_tyipeek               lisp_name_codes:    102.
      777752    fn_tyo                   lisp_name_codes:     18.
      777521    fn_unwind_protect        lisp_name_codes:    171.
      777546    fn_zerop                 lisp_name_codes:    150.
      777770    form                     lisp_oprs_:    47,  859,  860,  885,  889.
           1    frame.dat1               lisp_oprs_:   750, 1490,
                                         lisp_unmkd_pdl:      10.
           1    frame.dat2               lisp_oprs_:   749,  787,
                                         lisp_unmkd_pdl:      11.
           0    frame.prev_frame         lisp_oprs_:   748,  816,  939, 1002, 1220, 1487, 1505,
                                         lisp_unmkd_pdl:       8.
           2    frame.ret                lisp_oprs_:   752,  753,  941,  942, 1228, 1234, 1247, 1484, 1491, 1493, 1510, 1511,
                                         lisp_unmkd_pdl:      12.
           0    frame.stack_ptr          lisp_oprs_:   746,  776,  783,  937,  972,  982, 1212, 1489,
                                         lisp_unmkd_pdl:       9.
          42    gensym_data              lisp_oprs_:    69,
                                         lisp_stack_seg:      26.
         142    gensym_init              lisp_oprs_:    68,  165.
      777776    his_bp                   lisp_oprs_:    45,  424,  429,  736,  760,  800,  846,  927,  949,  988, 1022, 1073,
                                                      1101, 1513.
      777774    his_lp                   lisp_oprs_:    44,  422,  427,  735,  759,  799,  845,  926,  948,  987, 1021, 1074,
                                                      1100, 1514.
           0    init                     lisp_oprs_:    64,   66.
                interrupt_poll           lisp_oprs_:  1533.
          16    in_pl1_code              lisp_oprs_:   465,  468,  501,  505,  531,  535,  796,  980, 1176, 1226, 1419, 1430,
                                                      1455, 1531, 1534, 1545, 1547,
                                         lisp_stack_seg:      13.
        1231    iogbind                  lisp_oprs_:   102, 1020.
          46    iogbind_op               lisp_oprs_:   103,
                                         lisp_stack_seg:      29.
        1726    irest_return             lisp_oprs_:   155, 1523.
         150    irest_return_op          lisp_oprs_:   156,
                                         lisp_stack_seg:      62.
         562    link_operator            lisp_oprs_:   135,  519.
         110    link_opr                 lisp_oprs_:   136,
                                         lisp_stack_seg:      46.
         372    link_snap_instruction    lisp_oprs_:   385,  391.
                lisp_                    lisp_oprs_:   425,  430,  790,  880,  891, 1090.
                lisp_alloc_              lisp_oprs_:   121,  123,  125,  127,  129,  131,  140.
         454    Lisp_Error               lisp_oprs_:   255,  269,  404,  453, 1080, 1257, 1289, 1397.
                lisp_error_              lisp_oprs_:   467, 1177.
                lisp_error_table_        lisp_oprs_:   234,  264,  268,  327,  402, 1079, 1256, 1288, 1396.
                lisp_fault_handler_      lisp_oprs_:  1533.
                lisp_linker_             lisp_oprs_:   534.
                lisp_prog_fns_           lisp_oprs_:   781,  976.
       77700    lisp_ptr.type            lisp_oprs_:   361, 1077, 1383,
                                         lisp_object_types:   13.
                lisp_static_vars_        lisp_oprs_:    67,  181,  348,  349,  465,  468,  501,  502,  505,  531,  532,  535,
                                                       587,  588,  747,  755,  769,  771,  772,  775,  782,  784,  786,  796,
                                                       812,  938,  944,  964,  966,  967,  970,  980,  999, 1028, 1030, 1032,
                                                      1040, 1047, 1051, 1052, 1053, 1176, 1208, 1225, 1226, 1379, 1419, 1430,
                                                      1455, 1458, 1466, 1486, 1492, 1504, 1506, 1507, 1509, 1527, 1528, 1531,
                                                      1534, 1545, 1547.
                lisp_subr_tv_            lisp_oprs_:   465,  501,  531, 1455, 1531.
                lisp_unwinder            lisp_oprs_:   781,  976.
           0    marked_stack_bottom      lisp_stack_seg:       6.
                masked                   lisp_oprs_:  1507, 1509, 1527.
         315    move_EAQ_to_Q_then_store       lisp_oprs_:   302,  303,  317.
          74    ncons_op                 lisp_oprs_:   124,  244,
                                         lisp_stack_seg:      40.
                ncons_opr                lisp_oprs_:   123.
          12    nil                      lisp_oprs_:   186,  218,  729, 1050,
                                         lisp_stack_seg:      11.
         324    not_allowed_to_store     lisp_oprs_:   287,  288,  315,  326,  438,  447,  448.
         310    not_allowed_to_store_f   lisp_oprs_:   304,  306,  307,  308,  310.
                not_an_array             lisp_oprs_:   402.
                no_snapped_links         lisp_oprs_:   349.
          14    no_snapped_links_flag    lisp_oprs_:   349,  381.
       61400    nulfu                    lisp_oprs_:  1218, 1262, 1265.
         560    null_argl                lisp_oprs_:   466,  503,  513,  780,  789,  975, 1532.
        1442    nultag                   lisp_oprs_:   912, 1189, 1215, 1265.
       61400    Numeric                  lisp_oprs_:  1262,
                                         lisp_object_types:   17.
           5    Obarray_array            lisp_array_fmt:      19.
        1272    obscene_go_tag           lisp_oprs_:   104, 1071.
         405    ok_to_link_table         lisp_oprs_:   395,  407.
         627    one_arg                  lisp_oprs_:   529,  543.
         140    patch_instruction        lisp_oprs_:   162.
        1643    pl1_call_common          lisp_oprs_:  1418, 1429, 1448.
        1621    pl1_call_nopop           lisp_oprs_:   157, 1426.
         152    pl1_call_nopop_op        lisp_oprs_:   158,
                                         lisp_stack_seg:      63.
         134    pl1_call_op              lisp_oprs_:   143,
                                         lisp_stack_seg:      56.
        1603    pl1_call_operator        lisp_oprs_:   142, 1415.
        1615    pl1_call_ret_common      lisp_oprs_:  1420, 1431.
          66    pl1_interface            lisp_oprs_:   118,
                                         lisp_stack_seg:      37.
         522    pl1_interfacer           lisp_oprs_:   117,  496.
          70    pl1_lsubr_interface      lisp_oprs_:   120,
                                         lisp_stack_seg:      38.
         515    pl1_lsubr_interfacer     lisp_oprs_:   119,  490.
      777776    plist                    lisp_oprs_:    50.
        1171    push_offset              stack_header:        81.
        1631    rcv_char_star            lisp_oprs_:   159, 1433.
         154    rcv_char_star_op         lisp_oprs_:   160,
                                         lisp_stack_seg:      64.
           4    Readtable_array          lisp_oprs_:   266,
                                         lisp_array_fmt:      18.
        1311    return                   lisp_oprs_:   112,  440, 1055, 1083, 1100, 1529, 1535.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          62    return_op                lisp_oprs_:   113,
                                         lisp_stack_seg:      35.
        1306    re_eval_tag              lisp_oprs_:  1078, 1087.
        1327    set_minus_indicator      lisp_oprs_:  1128, 1131.
        1315    signp                    lisp_oprs_:   110, 1115.
        1331    signp_big                lisp_oprs_:  1118, 1135.
        1323    signp_fl                 lisp_oprs_:  1116, 1127.
          56    signp_op                 lisp_oprs_:   111,
                                         lisp_stack_seg:      33.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    lisp_oprs_:   465,  501,  531, 1455, 1531,
                                         stack_frame:   13.
          20    stack_frame.flag_word    stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       lisp_oprs_:  1465,
                                         stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      lisp_oprs_:   468,  505,  535,  796,  980, 1419, 1443, 1534,
                                         stack_frame:    8.
          40    stack_frame.regs         stack_frame:   22.
          24    stack_frame.return_ptr   lisp_oprs_:  1462,
                                         stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     lisp_oprs_:  1461,
                                         stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     lisp_oprs_:   239,  240,  260,  261,  468,  505,  535,  796,  980, 1419, 1444,
                                                            1534,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
                stack_ptr                lisp_oprs_:   465,  468,  501,  505,  531,  535,  775,  784,  786,  796,  970,  980,
                                                      1176, 1226, 1419, 1430, 1455, 1531, 1534, 1545, 1547.
           4    stack_ptr_ptr            lisp_stack_seg:       8.
          10    star_rset                lisp_oprs_:   181,  182.
         414    store                    lisp_oprs_:   413,  415.
         324    store_into_dead_array    lisp_oprs_:   289,  326,  449.
                store_not_allowed        lisp_oprs_:   327.
         260    store_op                 lisp_oprs_:    78,  276.
         116    store_operator           lisp_oprs_:    79,
                                         lisp_stack_seg:      49.
         265    store_table              lisp_oprs_:   279,  282,  439.
         445    store_test               lisp_oprs_:   437,  442.
        4000    String                   lisp_oprs_:  1277, 1324,
                                         lisp_object_types:   22.
        2000    Subr                     lisp_object_types:   23.
          44    system_lp                lisp_oprs_:   116,  180,  352,  465,  501,  531,  592,  674,  737,  815,  864,  890,
                                                       928, 1001, 1023, 1089, 1176, 1207, 1226, 1287, 1378, 1395, 1455, 1485,
                                                      1503, 1524, 1531, 1547,
                                         lisp_stack_seg:      28.
         400    System_Subr              lisp_object_types:   24.
           0    S_expr_array             lisp_array_fmt:      14.
         104    terminate_list_op        lisp_oprs_:   132,
                                         lisp_stack_seg:      44.
                terminate_list_opr       lisp_oprs_:   131.
        1365    throw1                   lisp_oprs_:   106, 1187.
          52    throw1_op                lisp_oprs_:   107,
                                         lisp_stack_seg:      31.
        1370    throw2                   lisp_oprs_:   108, 1206, 1260.
          54    throw2_op                lisp_oprs_:   109,
                                         lisp_stack_seg:      32.
        1406    throw_1                  lisp_oprs_:  1214, 1216, 1219, 1225.
        1161    throw_ret                lisp_oprs_:   940,  961.
                throw_to_no_catch        lisp_oprs_:  1256.
        1430    throw_to_same_sp         lisp_oprs_:  1229, 1245.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
          14    true                     lisp_oprs_:  1025,
                                         lisp_stack_seg:      12.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
          60    type_fields              lisp_oprs_:   139,
                                         lisp_stack_seg:      34.
        1577    type_table               lisp_oprs_:  1357, 1399.
         731    unbind                   lisp_oprs_:    86,  672.
         747    unbind_end               lisp_oprs_:   685,  691.
         741    unbind_loop              lisp_oprs_:   683,  689.
          22    unbind_op                lisp_oprs_:    87,
                                         lisp_stack_seg:      18.
        1223    uncatch                  lisp_oprs_:   100, 1001.
          40    uncatch_op               lisp_oprs_:   101,
                                         lisp_stack_seg:      25.
       60000    Uncollectable            lisp_oprs_:   646,  655,
                                         lisp_object_types:   21.
        1062    unerrset                 lisp_oprs_:    92,  814.
          30    unerrset_op              lisp_oprs_:    93,
                                         lisp_stack_seg:      21.
       67500    Unevalable               lisp_object_types:   27.
                unmkd_ptr                lisp_oprs_:    67,  465,  468,  501,  502,  505,  531,  532,  535,  769,  771,  796,
                                                       964,  966,  980, 1176, 1226, 1419, 1430, 1455, 1458, 1466, 1531, 1534,
                                                      1545, 1547.
           6    unmkd_ptr_ptr            lisp_stack_seg:       9.
           2    unmkd_stack_bottom       lisp_stack_seg:       7.
                unseen_go_tag            lisp_oprs_:  1079.
          50    unseen_go_tag_op         lisp_oprs_:   105,
                                         lisp_stack_seg:      30.
         146    ununwp_op                lisp_oprs_:   154,
                                         lisp_stack_seg:      61.
                unwinder_                lisp_oprs_:  1239.
        1672    unwind_protect           lisp_oprs_:   150, 1481.
        1707    unwind_protect_end       lisp_oprs_:   153, 1501, 1546.
         142    unwp1_op                 lisp_oprs_:   151,
                                         lisp_stack_seg:      59.
         144    unwp2_op                 lisp_oprs_:   152,
                                         lisp_stack_seg:      60.
                unwp_frame               lisp_oprs_:  1486, 1492, 1504, 1506.
           1    Un_gc_array              lisp_array_fmt:      15.
          76    xcons_op                 lisp_oprs_:   126,
                                         lisp_stack_seg:      41.
                xcons_opr                lisp_oprs_:   125.
         664    xec_ret                  lisp_oprs_:   620,  641,  662.
        1760    xec_unwprot_compiled_handler   lisp_oprs_:  1542, 1543.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
