	COMPILATION LISTING OF SEGMENT tedaddr_
	Compiled by: Multics PL/I Compiler, Release 31b, of April 24, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 05/02/89  1052.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-08-03,RWaters), approve(88-08-03,MCR7950), audit(88-09-29,Huen),
       18*     install(88-10-07,MR12.2-1146):
       19*     Bug fixes for MR12.2.
       20*  2) change(89-03-29,Huen), approve(89-03-29,MCR8062), audit(89-04-25,JRGray),
       21*     install(89-05-02,MR12.3-1037):
       22*     Fix bug 205: Modify ted not to complain that "." is undefined unless there
       23*     is an attempt to reference it.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
       28 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
       29 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       30 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       31 
       32 /*							       */
       33 /*   _|_              |             |      |			       */
       34 /*    |      _      _ |   ___     _ |    _ |    _			       */
       35 /*    |     / \    / \|   ___\   / \|   / \|  |/ \		       */
       36 /*    |    (__/   (   |  /   |  (   |  (   |  |			       */
       37 /*    \_    \_/    \_/|  \__/|   \_/|   \_/|  |			       */
       38 /*                                                   -----		       */
       39 /*							       */
       40 
       41 /* tedaddr_ .......... subroutine to find address portion of ted request    */
       42 /*  and locate addressed line in buffer				       */
       43 
       44 /**** <<<<----- dcl_tedaddr_.incl.pl1 tedaddr_			       */
       45 tedaddr_:				/* process request addresses	       */
       46    proc (adb_p, ain_p, ain_l, abp, msg, acode);
       47 dcl (
       48     adb_p		ptr,		/* -> database		       */
       49     ain_p		ptr,		/* -> string containing address      */
       50     ain_l		fixed bin (21),	/*   length of it		  [IN] */
       51 				/* If <0 then recursive call	       */
       52 				/*   how much was used up	 [OUT] */
       53     abp		ptr,		/* -> buffer control block  [IN/OUT] */
       54     msg		char (168) var,	/* place to hold err message if any  */
       55     acode		fixed bin (35)	/* status code		       */
       56 				/*   0- null address	       */
       57 				/*   1- address found	       */
       58 				/*   8- error, msg tells what	       */
       59     )		parm;		/* ----->>>>		       */
       60 
       61 /*    req_addr			     request address format	       */
       62 /*             ::= {@bufname,}{address}	     optional buffer spec	       */
       63 /*							       */
       64 /*    address			     basic address format	       */
       65 /* 	     ::= {prefix}...addr				       */
       66 /*							       */
       67 /*    prefix			     conditional address process     */
       68 /* 	     ::= ? gadr ,		       see NOTE 1		       */
       69 /*               | ? gadr ;		       see NOTE 2		       */
       70 /*							       */
       71 /*    addr						       */
       72 /* 	     ::= gadr		     single address		       */
       73 /*               | gadr , gadr	     range, see NOTE 1	       */
       74 /*               | gadr ; gadr	     range, see NOTE 2	       */
       75 /*               | adr ( adr , adr )	     byte range, see NOTE 1	       */
       76 /*               | adr ( adr ; adr )	     byte range, see NOTE 2	       */
       77 /*               |   0 ( adr , adr )	     buffer range, see NOTE 1	       */
       78 /*               |   0 ( adr ; adr )	     buffer range, see NOTE 2	       */
       79 /*							       */
       80 /*    gadr						       */
       81 /* 	     ::= adr		     line address		       */
       82 /*               | adr ( adr )	     line/byte address	       */
       83 /*               |   0 ( adr )	     buffer address		       */
       84 /*							       */
       85 /*    adr							       */
       86 /* 	     ::= num		     absolute line number	       */
       87 /*               | num adrr		       with additional parts	       */
       88 /*               |     adrr		     (just additional parts)	       */
       89 /*							       */
       90 /*    adrr			     additional parts	       */
       91 /* 	     ::= rel		     relative line number	       */
       92 /*               | num		     non-initial number is +rel      */
       93 /*               | fwd		     forward regexp search	       */
       94 /*               | bwd		     backward regexp search	       */
       95 /*               | .		     curline		       */
       96 /*               | $		     last line		       */
       97 /*               | \l		     enter line mode	       */
       98 /*               | \s		     enter string mode	       */
       99 /*							       */
      100 /*    rel							       */
      101 /* 	     ::= + num		     forward relative	       */
      102 /*               | . num		       (same)		       */
      103 /*               | - num		     backward relative	       */
      104 /*							       */
      105 /*    fwd				     forward search		       */
      106 /* 	     ::= / regexp /		       wrap-around, next line to     */
      107 /*				       end of buffer, then beginning */
      108 /* 			                 of buffer to curline	       */
      109 /*               | [ address ] / regexp /      restricted range, beginning   */
      110 /* 				       to end of addressed area      */
      111 /*							       */
      112 /*    bwd				     backward search	       */
      113 /* 	     ::= </ regexp /	     curloc to begin buffer	       */
      114 /*               | [ address ] </ regexp /   end to begin of addressed area  */
      115 /*							       */
      116 /* NOTE 1: when 2 address syllables are separated by a comma, this means     */
      117 /*  that the second address uses the same initial location as the first one. */
      118 /*							       */
      119 /* NOTE 2: when 2 address syllables are separated by a semicolon, this       */
      120 /*  means that the second address uses the result of the first as its	       */
      121 /*  beginning location.					       */
      122 
      123 /* UPDATE HISTORY (finally)					       */
      124 /* EL#   date	TR	comments				       */
      125 /* 138 84-10-08 phx16962 pass failure of tedsrch_$compile back	       */
      126 /* 144 84-10-09 phx17335 "Addr- after buffer" in byte mode in mid-buffer     */
      127 /* 195 88-08-07 phx19783,19787 Motion relative to '.' illegal if '.' is      */
      128 /*	undefined                                                          */
      129 /* 205 89-01-20 phx21225 ted should not complain that "." is undefined       */
      130 /*        unless there is an attempt to reference it.      		       */
      131 
      132 dcl 1 ca_		based (ca__p) like b.a_; /* current address	       */
      133 
      134 dcl next_in	fixed bin;	/* where at in address data	       */
      135 dcl in_p		ptr;		/* -> address data		       */
      136 dcl in_l		fixed bin;	/*   length of it		       */
      137 dcl in_s		char (in_l) based (in_p); /* data as a string	       */
      138 dcl in_c		(in_l) char (1) based (in_p); /* data as an array      */
      139 
      140 /**** data refering to the string being searched			       */
      141 dcl file_str	char (last_file_char) based (b.cur.sp);
      142 dcl first_file_char fixed bin (21);
      143 dcl next_file_char	fixed bin (21);
      144 dcl last_file_char	fixed bin (21);
      145 dcl in_part_2	bit (1);		/* which part of file are we in      */
      146 
      147 dcl adr_num	fixed bin;
      148 dcl all_buffer	bit (1);
      149 dcl bkp_sw	bit (1);
      150 dcl ca__p		ptr;
      151 dcl ch		char (1);
      152 dcl code		fixed bin (35);
      153 dcl concealsw	bit (1);
      154 dcl delim		char (1);
      155 dcl dot_sw	bit (1);
      156 dcl end_sw	bit (1);
      157 dcl expr_l	fixed bin (21);
      158 dcl i		fixed bin (21);
      159 dcl line_sw	bit (1);
      160 dcl negsw		bit (1);
      161 dcl num		fixed bin (21);
      162 dcl possw		bit (1);
      163 dcl q_sw		bit (1);
      164 dcl recurring	bit (1);
      165 dcl reg_sw	bit (1);
      166 dcl relsw		bit (1);
      167 dcl srb1		fixed bin (21);
      168 dcl srb2		fixed bin (21);
      169 dcl sre1		fixed bin (21);
      170 dcl sre2		fixed bin (21);
      171 dcl start_scan	fixed bin (21);
      172 dcl string_sw	bit (1) defined (b.present (0));
      173 dcl tbp		ptr;
      174 dcl used		fixed bin (21);
      175 
      176 dcl NL		char (1) int static init ("
      177 ");
      178 
      179 dcl ioa_		entry options (variable);
      180 dcl ioa_$ioa_switch entry () options (variable);
      181 dcl ioa_$ioa_switch_nnl entry () options (variable);
      182 
      183 
      184 dcl (
      185     addr, fixed, index, null, reverse, substr, verify
      186     )		builtin; 
      187       dbase_p = adb_p;
      188       bp = abp;			/* "current" buffer		       */
      189       in_part_2 = ""b;
      190       in_p = ain_p;
      191       if (ain_l < 0)
      192       then do;
      193          ain_l = -ain_l;
      194          recurring = "1"b;
      195       end;
      196       else recurring = ""b;
      197       in_l = ain_l;
      198       next_in = 1; 


      199       if db_addr
      200       then call ioa_$ioa_switch (db_output,
      201 	      "addr: in=^p,^i ""^a"" b(^a)", /* ^/^-pfnl=part|first,next,last",   */
      202 	      ain_p, ain_l, substr (in_s, 1, in_l - 1), b.name);
      203       if (in_c (next_in) = "@")	/* explicit buffer specification?    */
      204       then do;
      205          next_in = next_in + 1;
      206          used = in_l - next_in + 1;
      207          call tedget_buffer_ (adb_p, addr (in_c (next_in)),
      208 	    used, tbp, msg);
      209          next_in = next_in + used;
      210          if (tbp = null ())		/* did not find that buffer	       */
      211          then do;
      212 	  acode = 8;
      213 	  return;
      214          end;
      215          bp = tbp;			/* change reference to that buffer   */
      216          next_in = next_in		/* skip SPs		       */
      217 	    + verify (substr (in_s, next_in), " ") - 1;
      218          if (in_c (next_in) ^= ",")	/* no address following?	       */
      219          then do;			/*   just point to specified buffer  */
      220 	  q_sw = "1"b;
      221 	  b.present (1), b.present (2) = ""b;
      222 	  acode = 0;
      223 	  goto finished;
      224          end;
      225          next_in = next_in + 1;	/* skip over the comma	       */
      226       end; 



      227       adr_num = 1;			/* prepare for 1st address	       */
      228       b.a_.r.ln (1), b.a_.r.ln (2) = -1;
      229       ca__p = addr (b.a_ (1));
      230 q_comma:				/* begin at "."		       */
      231       b.a_ (1) = b.a_ (0);
      232 q_semi:
      233       b.present (1), b.present (2) = ""b;
      234       acode = 0;			/* indicate null addr	       */
      235 
      236 line2:				/* continue on 2nd line address      */
      237       line_sw = "1"b;		/* in line addr		       */
      238       all_buffer = "0"b;		/* not addressing whole buffer       */
      239       reg_sw = "0"b;		/* no byte regexp just finished      */
      240 byte2:				/* continue on 2nd byte address      */
      241       start_scan = 0;		/* scan is not started	       */
      242       end_sw = "0"b;		/* address is not finished	       */
      243       q_sw = "0"b;			/* prefix not in effect	       */
      244       relsw = "0"b;			/* absolute numerics	       */
      245       negsw = "0"b;			/* not "-"		       */
      246       possw = "0"b;			/* not "+"		       */
      247       dot_sw = "0"b;		/* not "."		       */
      248       goto scan2;			/* begin (or resume) scan of input   */
      249 
      250 a_line:
      251       ca_.l.re = ca_.l.le;
      252       ca_.r.le = ca_.r.re;		/* set string to full line	       */
      253 scan:				/* actually found some address       */
      254       acode = 1;			/* resume scan		       */
      255       b.present (adr_num) = "1"b;	/* current address (1|2) is present  */
      256       relsw = "1"b;			/* any more numbers are relative     */
      257 scan0:				/* begin prefix or byte addr	       */
      258       if (start_scan = 0)		/* keep where this scan started      */
      259       then start_scan = next_in;
      260 scan1:
      261       next_in = next_in + 1;		/* bump source char index	       */
      262 scan2:
      263       if db_addr
      264       then call ioa_$ioa_switch_nnl (db_output,
      265 	      """^1a""(^i)", in_c (next_in), next_in);
      266 
      267       if (next_in > in_l)		/* check for end of line	       */
      268       then do;			/* OPPS, went too far	       */
      269          next_in = in_l;		/* bring it back in line	       */
      270 err_Amn:
      271          msg = "Amn) No NL.";
      272 add_err_8:
      273          acode = 8;			/* error found		       */
      274 add_err_text:
      275          if recurring
      276          then goto fail;
      277          if (start_scan = 0)		/* didnt capture start point,        */
      278          then start_scan = next_in;	/* so force it in		       */
      279          msg = msg || " """;
      280          msg = msg || substr (in_s, start_scan, next_in - start_scan + 1);
      281          msg = msg || """";
      282          goto fail;
      283       end;
      284       ch = in_c (next_in);		/* pick up next char from input line */
      285       if db_addr
      286       then call ioa_$ioa_switch (db_output,
      287 	      "^-a^d:^[,rel^]^[,pos^]^[,neg^]", adr_num, relsw, possw, negsw);
      288 
      289       if (ch = " ") then goto scan1;	/* ignore blanks at this level       */
      290       if ^end_sw
      291       then do;
      292          if (ch = "/") then goto reg;	/* start of regular expression       */
      293 /**** A special case exists so that (/abc/////) will find the 3rd occrrance  */
      294 /****  but will also be able to find the abc beginning in col 1.	       */
      295 /**** A TR complained about (/,/;//) giving a single character result,       */
      296 /****  so we make this special case carry over the ";".		       */
      297          if (ch ^= ";")
      298          then reg_sw = "0"b;		/*   not regexp		       */
      299          if (ch = "$") then goto last;	/* "$" goto end of input file	       */
      300          if (ch = "-") then goto neg;	/* "-" note minus sign seen	       */
      301          if (ch = "+") then goto pos;	/* "+" note plus sign seen	       */
      302          if (ch >= "0") & (ch <= "9") then goto get_num;
      303          if (ch = "[") then goto limit; /* search limiting		       */
      304          if (ch = "?")		/* prefix			       */
      305          then do;
      306 	  if b.present (1)		/* already been an address	       */
      307 	  then goto err_Ad1;	/*   so this is an error	       */
      308 	  q_sw = "1"b;
      309 	  goto scan0;		/* go get the prefix	       */
      310          end;
      311          if ^line_sw		/* in byte addr		       */
      312          then do;
      313 	  if (ch = ".")
      314 	  then do;
      315 	     if relsw
      316 	     then do;
      317 err_Ad1:
      318 	        msg = "Ad1) . $ ? Can only appear first.";
      319 	        goto add_err_8;
      320 	     end;
      321 	     dot_sw = "1"b;
      322 	     goto scan;
      323 	  end;
      324 	  if (ch = ")")		/* end byte address		       */
      325 	  then do;
      326 	     if negsw | possw	/* ### number missing	       */
      327 	     then goto err_Anm;
      328 	     line_sw = "1"b;	/* back in line address	       */
      329 	     end_sw = "1"b;		/* however, this one finished	       */
      330 	     goto scan1;
      331 	  end;
      332 	  if (ch = ",") | (ch = ";")	/* byte address separator	       */
      333 	  then do;
      334 	     if q_sw		/* cant use this form in byte addr   */
      335 	     then goto err_Aqe;
      336 	     if negsw | possw	/* ### number missing	       */
      337 	     then goto err_Anm;
      338 	     if (adr_num = 2)	/* ### already done 2nd?	       */
      339 	     then goto only_2;
      340 	     if ^b.present (1)	/* ### left out 1st one?	       */
      341 	     then goto err_Aa1;
      342 	     next_in = next_in + 1;	/* skip the separator	       */
      343 	     adr_num = 2;		/* start 2nd address	       */
      344 	     ca__p = addr (b.a_.l (2)); /* begin 2nd where 1st left off */
      345 	     b.a_ (2) = b.a_ (1);
      346 	     if (ch = ",")		/* except if comma then go back to   */
      347 	     then do;		/*   beginning of line	       */
      348 	        b.a_.l.re (2) = b.a_.l.le (2);
      349 	        b.a_.r.le (2) = b.a_.r.re (2);
      350 	     end;
      351 	     b.present (2) = "0"b;	/* no address found		       */
      352 	     goto byte2;
      353 	  end;
      354 	  msg = "Abc) Bad char in byte addr.";
      355 	  goto add_err_8;
      356          end;
      357          else do;			/* in line address		       */
      358 	  if negsw | possw		/* ### number missing	       */
      359 	  then goto err_Anm;
      360 	  if (ch = ".")		/* current line ref		       */
      361 	  then do;
      362 	     if q_sw & (ca_.r.le = 0) /* prefix and undefined "."	       */
      363 	     then goto q_fail;	/* then let him know by failing      */
      364 	     if relsw
      365 	     then goto err_Ad1;	/* dot only allowed first	       */
      366 	     dot_sw = "1"b;
      367 	     goto a_line;
      368 	  end;
      369 	  if (ch = "(")		/* begin byte | buffer addr?	       */
      370 	  then do;
      371 	     relsw, dot_sw, line_sw = "0"b;
      372 	     goto scan0;
      373 	  end;
      374 	  if (ch = "<")		/* backup search		       */
      375 	  then goto backup;
      376          end;
      377       end;
      378       if negsw | possw		/* ### number missing	       */
      379       then goto err_Anm;
      380       if (ch = ",") | (ch = ";")	/* line address separator	       */
      381       then do;
      382          if (adr_num = 2)		/* already done 2 of em?	       */
      383          then do;
      384 only_2:
      385 	  msg = "Ao2) Only 2 addr allowed.";
      386 	  goto add_err_8;
      387          end;
      388          if ^b.present (1)		/* any 1st one there?	       */
      389          then goto err_Aa1;
      390          next_in = next_in + 1;	/* skip over separator	       */
      391          if (ca_.l.re < b.b_.l.le)	/* before beginning?	       */
      392 	    | (ca_.r.le > b.b_.r.re)	/* ...after end		       */
      393          then goto q_fail;		/* too bad!		       */
      394          if q_sw			/* just finish up a prefix?	       */
      395          then do;
      396 	  q_sw = "0"b;		/* turn off prefix flag	       */
      397 	  if (ch = ",")
      398 	  then goto q_comma;
      399 	  goto q_semi;
      400          end;
      401          ca__p = addr (b.a_ (2));	/* point to 2nd result	       */
      402          if (ch = ",")		/* comma means		       */
      403          then adr_num = 0;		/* use same starting location	       */
      404          else adr_num = 1;		/* use updated location	       */
      405          ca_ = b.a_ (adr_num);	/* set "." value for next address    */
      406          b.present (2) = "0"b;	/* havent found 2nd one yet	       */
      407          adr_num = 2;		/* begining 2nd address	       */
      408          goto line2;
      409       end;
      410 
      411       if (ch = "\")
      412       then do;
      413          ch = in_c (next_in + 1);
      414          if (ch = "s")
      415          then do;
      416 	  string_sw = "1"b;
      417 	  next_in = next_in + 1;
      418 	  goto scan1;
      419          end;
      420          if (ch = "l")
      421          then do;
      422 	  string_sw = "0"b;
      423 	  next_in = next_in + 1;
      424 	  goto scan1;
      425          end;
      426       end;
      427 
      428 finished:
      429       ain_l = next_in - 1;
      430       if q_sw			/* end in prefix?		       */
      431       then b.present (1) = "0"b;	/* then no effective address	       */
      432       if db_addr
      433       then do;
      434          call ioa_$ioa_switch (db_output,
      435 	    """^1a""(^i) b(^a)", in_c (ain_l), ain_l, b.name);
      436          call tedshow_ (bp, ". adr a0 a1 a2");
      437       end;
      438       abp = bp;			/* tell him buffer we worked on      */
      439       return;			/* normal return to caller	       */
      440 				/* (acode = 0, 1 or 2)	       */
      441 
      442 q_fail:				/* "non-failing" failure	       */
      443       b.present (1), b.present (2) = "0"b;
      444       next_in = ain_l + 1;		/* throw away rest of line	       */
      445 fail:				/* here on any other failure	       */
      446       ain_l = next_in - 1;
      447       return;
      448 
      449 limit:				/* limit range of a search expr      */
      450       if negsw | possw		/* ### number missing	       */
      451       then goto err_Anm;
      452       if (start_scan = 0)
      453       then start_scan = next_in;
      454       next_in = next_in + 1;		/* skip over the [		       */
      455       if (in_c (next_in) = "@")	/* TRYING TO REF OTHER BUFFER HERE?  */
      456       then do;
      457          msg = "Misplaced @.";	/* no you dont!		       */
      458          goto add_err_8;
      459       end;
      460       b.rel_temp = b.a_;		/* keep the current address data     */
      461       if b.present (1)		/* WHAT TO DO?		       */
      462       then do;
      463          b.a_ (0) = ca_;
      464       end;
      465       apr (1) = b.present (1);
      466       apr (2) = b.present (2);
      467 dcl apr		(2) bit (1);
      468       used = -(in_l - next_in + 1);	/* <0 flags recursive entry	       */
      469       call tedaddr_ (adb_p, addr (in_c (next_in)), used, bp, msg, acode);
      470       next_in = next_in + used;
      471       if (acode = 8)
      472       then do;
      473          if q_sw
      474          then goto q_fail;
      475          goto add_err_text;
      476       end;
      477       if (in_c (next_in) ^= "]")	/* next thing up must be the closer  */
      478       then do;
      479          msg = "Anb) Missing ].";
      480          goto add_err_8;
      481       end;
      482       next_in = next_in + 1;		/* skip over "]", then SPs	       */
      483       next_in = next_in + verify (substr (in_s, next_in), " ") - 1;
      484       if b.present (1)
      485       then do;
      486          b.a_ (0) = b.a_ (1);
      487          if b.present (2)
      488          then b.a_.r (0) = b.a_.r (2);
      489       end;
      490       b.present (1) = apr (1);
      491       b.present (2) = apr (2);
      492       ch = in_c (next_in);
      493       if (ch = "<")
      494       then do;
      495          srb1 = 0;			/* must look at last line	       */
      496          srb2 = b.a_.l.le (0);
      497          sre2 = b.a_.r.re (0);
      498          b.a_ = b.rel_temp;		/* restore old address data	       */
      499          ca_.l.le = sre2;
      500          goto backup_limit;
      501       end;
      502       if (ch = "/")
      503       then do;
      504          srb1 = b.a_.l.re (0);
      505          sre1 = b.a_.r.le (0);
      506          srb2, sre2 = 0;
      507          b.a_ = b.rel_temp;		/* restore old address data	       */
      508          goto reg_limit;
      509       end;
      510 
      511       msg = "Invalid char follows [...].";
      512       goto add_err_8; 
      513 backup:
      514       if negsw | possw
      515       then goto err_Anm;
      516       srb1 = -1;			/* do not look at cur line	       */
      517       srb2 = b.b_.l.le;
      518       sre2 = ca_.l.le;
      519 backup_limit:
      520       next_in = next_in + 1;
      521       delim = in_c (next_in);
      522       bkp_sw = "1"b;
      523       goto scan_reg; 


      524 reg:
      525       if negsw | possw		/* ### number missing	       */
      526       then goto err_Anm;
      527       srb1 = ca_.r.le + 1;		/* from here to buffer end	       */
      528       sre1 = b.b_.r.re;
      529       srb2 = b.b_.l.le;		/* then from buffer begin to here    */
      530       sre2 = ca_.r.le;
      531 reg_limit:
      532       delim = "/";
      533       bkp_sw = "0"b; 


      534 scan_reg:
      535       b.rel_temp = tedcommon_$no_data;
      536       if (b.cur.sn = 0)
      537       then goto buffer_empty;
      538       if (start_scan = 0)
      539       then start_scan = next_in;
      540       i = next_in + 1;		/* here after "/" found, look for    */
      541 				/*  regular expression	       */
      542       concealsw = "0"b;
      543       do next_in = i to in_l;
      544          if concealsw
      545          then concealsw = "0"b;
      546          else do;
      547 	  ch = in_c (next_in);
      548 	  if (ch = delim)
      549 	  then goto reg1;
      550 	  if (ch = "")		/* is this \031 ?		       */
      551 	  then concealsw = "1"b;
      552 	  if (ch = "\")
      553 	  then do;
      554 	     if (in_c (next_in + 1) = "c")
      555 		| (in_c (next_in + 1) = "C")
      556 	     then do;
      557 	        next_in = next_in + 1;
      558 	        concealsw = "1"b;
      559 	     end;
      560 
      561 	  end;
      562          end;
      563       end;
      564       msg = "Ad2) No 2nd delimiter.";
      565       acode = 8;
      566       goto fail;
      567 
      568 reg1:
      569       expr_l = next_in - i;		/*  length of regular expression     */
      570 
      571       if (expr_l > 0)
      572       then do;
      573          call tedsrch_$compile (addr (in_c (i)), expr_l, addr (dbase.regexp),
      574 	    (string_sw), (dbase.lit_sw), msg, code);
      575          if (code ^= 0)
      576          then do;			/* #138*/
      577 	  acode = code;		/* #138*/
      578 	  goto fail;		/* #138*/
      579          end;			/* #138*/
      580       end;
      581 				/** b.newa = b.b_; */
      582       if bkp_sw
      583       then goto bkp1;
      584       if ^line_sw
      585       then goto creg;
      586       if (srb1 < 1)			/* undefined ".", search whole thing */
      587       then do;
      588          srb1 = b.b_.l.le;
      589          sre1 = b.b_.r.re;
      590          sre2 = 0;
      591       end;
      592       call tedsrch_$search (addr (dbase.regexp), bp,
      593 	 srb1, sre1, ca_.l.re, ca_.r.le, 0,
      594 	 msg, code);
      595 				/* try to match expression, pass 1   */
      596       if (code = 1) & (sre2 > 0)
      597       then call tedsrch_$search (addr (dbase.regexp), bp,
      598 	      srb2, sre2, ca_.l.re, ca_.r.le, 0,
      599 	      msg, code);
      600 				/* try to match expression, pass 2   */
      601       if (code ^= 0)
      602       then do;			/* error if match failed on 2nd pass */
      603          if (code = 2)
      604          then do;
      605 	  acode = 8;
      606 	  goto fail;
      607          end;
      608          if q_sw
      609          then goto q_fail;
      610          msg = "Als) Line search failed.";
      611          acode = 2;
      612          goto add_err_text;
      613       end;
      614 
      615       call find_line (0);		/* isolate /.../ line	       */
      616       if line_sw
      617       then goto a_line;
      618       goto scan;
      619 
      620 bkp1:				/* what if "." undefined?	       */
      621       ca_.l.re, ca_.r.le = ca_.l.le;
      622       do while (ca_.l.le > srb2);
      623          call find_line (srb1);	/* may go 0 or -1 the first time     */
      624          srb1 = -1;			/*  make sure any more go -1	       */
      625          call tedsrch_$search (addr (dbase.regexp), abp,
      626 	    ca_.l.le, ca_.r.re, ca_.l.re, ca_.r.le, 0, msg, code);
      627          if (code = 0)
      628          then do;
      629 	  if line_sw
      630 	  then goto a_line;
      631 	  goto scan;
      632          end;
      633          if (code ^= 1)
      634          then do;
      635 	  acode = 8;
      636 	  goto fail;
      637          end;
      638          expr_l = 0;
      639          ca_.l.re, ca_.r.le = ca_.l.le;
      640       end;
      641       if q_sw
      642       then goto q_fail;
      643       msg = "Abs) Backup search failed.";
      644       acode = 2;
      645       goto add_err_text;
      646 
      647 last:				/* $ found		       */
      648       if negsw | possw
      649       then goto err_Anm;
      650       if relsw
      651       then goto err_Ad1;
      652       if ^line_sw
      653       then do;			/* CHAR - last, i.e. the NL	       */
      654          if all_buffer		/* if referencing all of buffer      */
      655          then ca_.r.re = b.b_.r.re;	/*  then give him last char thereof  */
      656          if (ca_.r.re = -1)
      657          then do;
      658 err_Adn:
      659 	  msg = "A.n) ""."" undefined.";
      660 	  goto add_err_8;
      661          end;
      662          if (b_c (ca_.r.re) = NL)	/* is there a NL on EOL?	       */
      663          then ca_.l.re, ca_.r.le = ca_.r.re; /*  point to it	       */
      664          else ca_.l.re, ca_.r.le = ca_.r.re + 1; /*  point where it should be*/
      665          goto scan;			/* continue scan		       */
      666       end;
      667       if (b.cur.sn = 0)
      668       then goto scan;		/* "$" found, find last line	       */
      669       if (b.b_.r.re + 1 = b.b_.r.le)	/* upper part empty		       */
      670       then ca_.r.le = b.b_.l.re;
      671       else ca_.r.le = b.b_.r.re;
      672       ca_.l.re = ca_.r.le;
      673       ca_.l.ln, ca_.r.ln = b.b_.r.ln;
      674       call find_line (0);		/* isolate $ line		       */
      675       goto a_line;			/* resume line addr		       */
      676 
      677 neg:
      678       if possw | negsw
      679       then do;
      680 err_Anm:
      681          msg = "Amn) Missing number value.";
      682          goto add_err_8;
      683       end;
      684       dot_sw = "0"b;
      685       negsw = "1"b;			/* "-" found, note minus sign seen   */
      686 
      687 /* RW 88: bug 195 */
      688 /* If we are attempting to reference a relative address, '.' MUST be defined
      689* * command sequences such as  "$d; -1" have 1 address, but a_(0) is undefined
      690*   SH 89: bug 205
      691*   Complain '.' is undefined only when there is an attempt to reference it
      692* */
      693       if (b.a_.r.re (0) = -1) & (ca_.r.re = -1) /*# 205 */
      694       then do;			/*# 205 */
      695          msg = "A.u) ""."" undefined."; /*# 205 */
      696          goto add_err_8;		/*# 205 */
      697       end;			/*# 205 */
      698 
      699       goto scan;			/*  continue addr scan	       */
      700 
      701 
      702 pos:
      703       if possw | negsw
      704       then goto err_Anm;
      705       dot_sw = "0"b;
      706       possw = "1"b;			/* "+" found, note plus sign seen    */
      707 
      708 /* RW 88: bug 195 */
      709 /* If we are attempting to reference a relative address, '.' MUST be defined
      710* * command sequences such as  "$d; -1" have 1 address, but a_(0) is undefined
      711*   SH 89: bug 205
      712*   Complain '.' is undefined only when there is an attempt to reference it
      713* */
      714       if (b.a_.r.re (0) = -1) & (ca_.r.re = -1) /*# 205 */
      715       then do;			/*# 205 */
      716          msg = "A.u) ""."" undefined."; /*# 205 */
      717          goto add_err_8;		/*# 205 */
      718       end;			/*# 205 */
      719 
      720       goto scan;			/*  continue addr scan	       */ 
      721 get_num:
      722       if (start_scan = 0)
      723       then start_scan = next_in;
      724       i = verify (substr (in_s, next_in), "0123456789") - 1;
      725       num = fixed (substr (in_s, next_in, i));
      726       next_in = next_in + i - 1;
      727 				/* allow zero even if buffer empty   */
      728       if (b.cur.sn = 0) & ((num ^= 0) | relsw | ^line_sw)
      729       then goto buffer_empty;
      730       if dot_sw			/* back by popular demand:	       */
      731       then do;			/* i.e.  .35 -> +35		       */
      732          dot_sw = "0"b;
      733          possw = "1"b;
      734       end;
      735       if line_sw
      736       then do;
      737          if ^relsw
      738          then do;
      739          /*** see if we know any locations near here		       */
      740 	  do i = 1 to 2;
      741 	  end;
      742          end;
      743          if ^relsw			/* absolute line number	       */
      744          then do;			/* begin at left end	       */
      745 	  if (b.b_.l.le - 1 = b.b_.l.re) /* is lower part empty?	       */
      746 	  then ca_.l.le = b.b_.r.le;	/* YES, use upper		       */
      747 	  else ca_.l.le = b.b_.l.le;	/*  NO, use lower		       */
      748 	  if (num = 0)		/* line "0" is a special case	       */
      749 	  then do;
      750 	     all_buffer = "1"b;
      751 	     ca_.r.re = ca_.l.le - 1; /* undefined location	       */
      752 	  end;
      753 	  else do;
      754 	     ca_.l.re, ca_.r.le = ca_.l.le;
      755 	     ca_.r.ln = 1;		/* -> beginning of buffer	       */
      756 	     call find_line (num - 1);/* move ahead necessary amount      */
      757 	  end;
      758          end;
      759          else do;			/* relative line number	       */
      760 	  if (ca_.r.re = -1)	/* undefined?		       */
      761 	  then ca_.r.le, ca_.r.re = ca_.l.le;
      762 	  else ca_.r.le = ca_.r.re;
      763 	  ca_.l.re = ca_.l.le;
      764 	  if negsw
      765 	  then num = -num;
      766 	  else if ^possw
      767 	  then do;
      768 err_Axn:
      769 	     msg = "Axn) Extra number present.";
      770 	     goto add_err_8;
      771 	  end;
      772 	  call find_line (num);	/* isolate +- Nth line	       */
      773 	  negsw, possw = "0"b;
      774          end;
      775          goto a_line;		/* continue addr a_line	       */
      776       end; 


      777 cnum:				/* CHAR - numeric addr	       */
      778       if (ca_.r.re = -1)		/* no good if "." undefined	       */
      779       then goto err_Adn;
      780       ca_.l.ln, ca_.r.ln = -1;	/* #144*/
      781       if ^relsw
      782       then do;			/* #144*/
      783 /****    calc the absolute location, then if that is above		   #144*/
      784 /****      the lower part, adjust it into the upper part.		   #144*/
      785          i = ca_.l.le - 1 + num;
      786          if db_addr then call ioa_ ("(abs) ^i = ^i -1 + ^i", i, ca_.l.le, num);
      787 
      788          if (ca_.l.le <= b.b_.l.re) & (i > b.b_.l.re)
      789          then
      790 	  do;
      791 	  if db_addr then call ioa_ ("^i<=^i & ^i>^i", ca_.l.le, b.b_.l.re, i, b.b_.l.re);
      792 	  i = b.b_.r.le - b.b_.l.re + i - 1; /* #144*/
      793 	  if db_addr then call ioa_ ("^i = ^i - ^i +i-1", i, b.b_.r.le, b.b_.l.re);
      794          end;
      795       end;			/* #144*/
      796       else if negsw
      797       then do;			/* #144*/
      798 /****    apply the negative offset, then if that pushed it out	   #144*/
      799 /****    of the upper part, adjust it into the lower part.		   #144*/
      800          i = ca_.l.re - num;
      801          if (ca_.l.re >= b.b_.r.le) & (i < b.b_.r.le)
      802          then i = i - b.b_.r.le + b.b_.l.re + 1; /* #144*/
      803       end;			/* #144*/
      804       else if possw
      805       then do;			/* #144*/
      806 /****    apply the positive offset, then if that pushed it out	   #144*/
      807 /****    of the lower part, adjust it into the upper.		   #144*/
      808          i = ca_.l.re + num;
      809          if (ca_.l.re <= b.b_.l.re) & (i > b.b_.l.re)
      810          then i = b.b_.r.le - b.b_.l.re + i - 1; /* #144*/
      811       end;			/* #144*/
      812       else goto err_Axn;
      813       negsw, possw = "0"b;
      814       if (i < ca_.l.le)		/* is it before line begin?	       */
      815       then do;
      816          if ^string_sw		/* not OK in line mode	       */
      817          then goto addr_before_line;
      818          if (i < 1)			/* can't fall out of	       */
      819          then goto addr_before_buffer;	/*  the buffer		       */
      820          ca_.l.re, ca_.r.le = i;
      821          call find_line (0);		/* isolate (N) char		       */
      822          goto scan;
      823       end;
      824       if (i ^< ca_.r.re)		/* is it after line end?	       */
      825       then do;
      826          if string_sw | all_buffer	/* if in string mode	       */
      827          then do;
      828 				/* code deleted		   #144*/
      829 	  if (i > b.b_.r.re)	/* can't fall out of	       */
      830 	  then call addr_after_buffer;/*  the buffer		       */
      831 	  ca_.l.re, ca_.r.le = i;
      832 	  call find_line (0);
      833 	  goto scan;
      834          end;
      835          if (b_c (ca_.r.re) = NL)	/* find the NL		       */
      836          then ca_.r.le = ca_.r.re - 1;
      837          else ca_.r.le = ca_.r.re;	/*  or where it should be	       */
      838          if (i ^= ca_.r.le)		/* that is all that is	       */
      839          then goto addr_after_line;	/*  for "after" the line	       */
      840       end;
      841       ca_.l.re, ca_.r.le = i;		/* set str to this char	       */
      842       goto scan;			/* continue scan		       */ 


      843 creg:				/* CHAR - contextual addr	       */
      844       if string_sw
      845       then sre1 = b.b_.r.re;
      846       else sre1 = ca_.r.re;
      847       srb1 = ca_.l.re;
      848 /**** When a "first" expression search is specified, allow it to match at    */
      849 /****  the current location. Then any immediately following searches will    */
      850 /****  start at current+1. This is so (/abc/////) doesn't match the same     */
      851 /****  thing 3 times.					       */
      852       if reg_sw
      853       then srb1 = srb1 + 1;
      854       reg_sw = "1"b;
      855       call tedsrch_$search (addr (dbase.regexp), bp, srb1, sre1,
      856 	 ca_.l.re, ca_.r.le, 0, msg, code);
      857       if (code ^= 0)
      858       then do;
      859          if (code = 2)
      860          then do;
      861 	  acode = 8;
      862 	  goto fail;
      863          end;
      864          if q_sw
      865          then goto q_fail;
      866          msg = "Acs) Char search failed.";
      867          acode = 2;
      868          goto add_err_text;
      869       end;
      870       if string_sw
      871       then call find_line (0);
      872       goto scan; 
      873 /****  NOTE! --------------------------------------------------------------- */
      874 /****	    find_line assumes that a line will never be split.	       */
      875 /**** ---------------------------------------------------------------------- */
      876 find_line: proc (num);
      877 
      878 dcl num		fixed bin (21);	/* how many lines to move + or -     */
      879 
      880 dcl NLct		fixed bin (21);
      881 dcl i		fixed bin (21);
      882 dcl (lb, le, se)	fixed bin (21);
      883 
      884       lb = ca_.l.re;
      885       le = ca_.r.le;
      886       if db_addr
      887       then call ioa_$ioa_switch_nnl (db_output, "^i:^i", lb, le);
      888       if (lb = le + 2) | (lb = le + 1)
      889       then le = lb;
      890       if (le = -1)
      891       then goto err_Adn;
      892       if (le < 1)			/* & (le+1 ^= lb) */
      893       then call addr_after_buffer;
      894       NLct = 0; 



      895       if (NLct < num)
      896       then do;			/* go forward num lines	       */
      897          call set_file (le);
      898          do while ((NLct < num)
      899 	    & ((next_file_char < last_file_char) | ^in_part_2));
      900 	  i = index (substr (file_str, next_file_char), NL);
      901 	  if (i = 0)
      902 	  then next_file_char = last_file_char + 1;
      903 	  else next_file_char = next_file_char + i;
      904 	  if (next_file_char > last_file_char)
      905 	  then if ^in_part_2
      906 	       then call set_file (b.b_.r.le);
      907 	  NLct = NLct + 1;
      908          end;
      909 /**** coming out of this loop, next_file_char points just past a NL	       */
      910 /****  (unless none there )					       */
      911          lb, le = next_file_char;
      912          if (ca_.r.ln ^= -1)
      913          then ca_.r.ln = ca_.r.ln + NLct;
      914       end; 



      915       if (NLct > num)
      916       then do;			/* go backward num lines	       */
      917          call set_file (lb);
      918          do while ((NLct > num) & (first_file_char <= next_file_char));
      919 	  i = index (reverse (substr (file_str, first_file_char,
      920 	       next_file_char - first_file_char)), NL);
      921 	  if (i = 0)
      922 	  then do;
      923 	     if in_part_2
      924 	     then call set_file (b.b_.l.re);
      925 	     else do;
      926 	        if (NLct ^= num + 1)
      927 	        then goto addr_before_buffer;
      928 	        next_file_char = 0;	/* allow decr to line 0 (undefined)  */
      929 	        NLct = -1;
      930 	        goto set;
      931 	     end;
      932 	  end;
      933 	  next_file_char = next_file_char - i;
      934 	  NLct = NLct - 1;
      935          end;
      936 /**** coming out of this loop, next_file_char points just ahead of a	       */
      937 /****  NL unless there is none there.				       */
      938          lb, le = next_file_char;
      939          if (le = 0)
      940          then le = -1;
      941          if (ca_.r.ln ^= -1)
      942          then ca_.r.ln = ca_.r.ln + NLct;
      943       end;
      944       ca_.l.ln = ca_.r.ln;
      945       if (NLct = num)
      946 	 & (b.b_.l.le <= lb)	/* 82-3-4 don't remember why this
      947*         & (le <= b.b_.r.re)		/* 82-3-4 don't remember why this    */
      948       then do;			/* find both ends of current line    */
      949          call set_file (le);
      950          i = index (substr (file_str, le), NL);
      951          if (i = 0)
      952          then le = last_file_char + 1;
      953          else le = le + i - 1;
      954 
      955          call set_file (lb);
      956          i = index (reverse (substr (file_str, first_file_char,
      957 	    lb - first_file_char)), NL);
      958          if (i = 0)
      959          then lb = first_file_char;
      960          else lb = lb - i + 1;
      961       end;
      962 
      963       if (NLct < num)
      964       then call addr_after_buffer;
      965       if (NLct > num)
      966       then goto addr_before_buffer;
      967       if (b_c (b.b_.r.re) = NL)
      968       then se = b.b_.r.re;
      969       else se = b.b_.r.re + 1;
      970       if (le > se)
      971       then call addr_after_buffer;
      972       if (le = b.b_.r.re + 1)		/* if just barely fell out of part2  */
      973       then le = b.b_.r.re;		/* ..then reference end	       */
      974       else if (le = b.b_.l.re + 1)	/* if just barely fell out of part1  */
      975 	 & (b.b_.r.le > b.b_.r.re)	/* ..and part 2 is empty	       */
      976       then le = b.b_.l.re;		/* ..then reference end of part1     */
      977 set:
      978       ca_.l.le = lb;
      979       ca_.r.re = le;
      980       if (num ^= 0)
      981       then do;
      982          ca_.l.re = lb;
      983          ca_.r.le = le;
      984       end;
      985       if db_addr
      986       then do;
      987          call ioa_$ioa_switch (db_output,
      988 	    "^xfind[^d]a^d  l=^4d,^d(^d)^30.1tr=^4d,^d(^d) ^[str^;lin^]",
      989 	    num, adr_num,
      990 	    ca_.l.le, ca_.l.re, ca_.l.ln, ca_.r.le, ca_.r.re, ca_.r.ln,
      991 	    string_sw);
      992       end;
      993    end find_line; 



      994 set_file: proc (at);
      995 
      996 dcl at		fixed bin (21);	/* location which must be available  */
      997 
      998       next_file_char = at;
      999       if (next_file_char <= b.b_.l.re)
     1000       then do;
     1001          in_part_2 = ""b;
     1002          first_file_char = b.b_.l.le;
     1003          last_file_char = b.b_.l.re;
     1004       end;
     1005       else if (b.b_.r.le <= next_file_char)
     1006       then do;
     1007          in_part_2 = "1"b;
     1008          first_file_char = b.b_.r.le;
     1009          last_file_char = b.b_.r.re;
     1010       end;
     1011       else do;
     1012          msg = "next in gap";
     1013 range_err:
     1014          call ioa_ (" addr: ^a", msg);
     1015          signal condition (addr_error); dcl addr_error condition;
     1016          goto fail;
     1017       end;
     1018       if (next_file_char < first_file_char)
     1019       then goto addr_before_buffer;
     1020       if (last_file_char < next_file_char)
     1021       then call addr_after_buffer;
     1022 
     1023       if db_addr
     1024       then call ioa_$ioa_switch (db_output, "^-^[>>^;<<^] ^i)^i(^i",
     1025 	      in_part_2, first_file_char, next_file_char, last_file_char);
     1026 
     1027    end set_file; 
     1028 /*		      : : : ERROR messages : : :		       */
     1029 err_Aqe:
     1030       msg = "Aqe) Bad ? form.";
     1031       goto add_err_8;
     1032 
     1033 err_Aa1:
     1034       msg = "Aa1) No 1st addr.";
     1035       goto add_err_8;
     1036 
     1037 addr_before_buffer:
     1038       msg = "Abb) Addr- before buffer";
     1039       goto addr_outside;
     1040 
     1041 addr_before_line:
     1042       msg = "Abl) Addr- before line";
     1043       goto addr_outside;
     1044 
     1045 addr_after_buffer: proc;
     1046       msg = "Aab) Addr- after  buffer";
     1047       goto addr_outside;
     1048    end;
     1049 
     1050 addr_after_line:
     1051       msg = "Aal) Addr- after  line";
     1052       goto addr_outside;
     1053 
     1054 buffer_empty:
     1055       msg = "Abe) Buffer empty.";
     1056       goto addr_outside;
     1057 
     1058 addr_outside:
     1059       if ^q_sw
     1060       then do;
     1061          acode = 8;
     1062          goto fail;
     1063       end;
     1064       goto q_fail; 
  1     1 /* BEGIN INCLUDE FILE ..... tedbase.incl.pl1 ..... 02/09/82 J Falksen       */
  1     2 
  1     3 dcl NORMAL	fixed bin (24) int static init (0),
  1     4     SAFE		fixed bin (24) int static init (1),
  1     5     COM		fixed bin (24) int static init (2),
  1     6     RESTART	fixed bin (24) int static init (3);
  1     7 
  1     8 dcl rc_close	fixed bin (24) int static init (100);
  1     9 dcl rc_fail	fixed bin (24) int static init (10);
  1    10 dcl rc_nop	fixed bin (24) int static init (2);
  1    11 dcl rc_keyerr	fixed bin (24) int static init (1);
  1    12 
  1    13 /*** the request line as both string and character		       */
  1    14 dcl rl_b		fixed bin (21);	/* where current req begins	       */
  1    15 dcl rl_i		fixed bin (21) defined (dbase.rl.l.le);
  1    16 dcl rl_l		fixed bin (21) defined (dbase.rl.l.re);
  1    17 dcl rl_c		(rl_l) char (1) based (dbase.rl.sp);
  1    18 dcl rl_s		char (rl_l) based (dbase.rl.sp);
  1    19 
  1    20 dcl 1 seg_des	based,		/* segment descriptor	       */
  1    21       2 sp	ptr,		/* -> segment		       */
  1    22       2 sn	fixed bin,	/* sequence # in dbase	       */
  1    23       2 pn	fixed bin,	/* part #, if in pool	       */
  1    24       2 ast	fixed bin,	/* size of aste		       */
  1    25       2 mbz	fixed bin;	/* --reserved		       */
  1    26 
  1    27       
  1    28 
  1    29 dcl dbase_p	ptr;
  1    30 dcl dbase_vers_3	fixed bin int static init (3);
  1    31 dcl 1 dbase	based (dbase_p),
  1    32       2 version	fixed bin,
  1    33       2 recurs	fixed bin,	/* recursion level at which active   */
  1    34       2 bwd	ptr,		/* links active db's together	       */
  1    35       2 cba_p	ptr,		/* contains addr (cb (1))	       */
  1    36       2 eval_p	ptr,		/* contains cb (2).sp	       */
  1    37       2 rl,			/* describes the request buffer      */
  1    38         3 part1	like seg_des,	/* ..its segment		       */
  1    39         3 part2	like buf_des,	/* ..its limits		       */
  1    40       2 seg_p	(-1:72) ptr,	/* list of segment pointers	       */
  1    41 				/* seg_p(-1)is a temp for restart    */
  1    42 				/* seg_p(0) is the database	       */
  1    43 				/* seg_p(1) is the 1K/4K pool	       */
  1    44 				/* seg_p(2) is reserved for 16K pool */
  1    45 				/* seg_p(3) is reserved for call_stk */
  1    46       2 inuse_seg	bit (72) aligned,	/* which segments (1:72) are in use  */
  1    47 				/* seg_p(0) is ALWAYS in use	       */
  1    48       2 inuse_1K	bit (16) aligned,	/* which 1K buffers are in use       */
  1    49       2 inuse_4K	bit (12) aligned,	/* which 4K buffers are in use       */
  1    50       2 inuse_16K	bit (4) aligned,	/* which 16K buffers are in use      */
  1    51       2 reset	label,		/* where to go on a reset condition  */
  1    52       2 time	fixed bin (71),	/* time request id is based on       */
  1    53       2 seg_ct	fixed bin,	/* how many segments in use	       */
  1    54 				/* seg_p (0)--database	       */
  1    55 				/* seg_p (1)--4K pool (64K total)    */
  1    56 				/* seg_p (2)--16K pool (64K total)   */
  1    57       2 argct	fixed bin,	/* how many args to ted	       */
  1    58       2 S_count	fixed bin,	/* # matches on last substitute      */
  1    59       2 not_read_ct fixed bin,	/* how many "not-read" files	       */
  1    60       2 at_break	fixed bin,	/* 1-break pending, 2-break entered  */
  1    61       2 bufnum	fixed bin,	/* how many buffer control blocks    */
  1    62       2 lock        bit (36),		/* to find if active (set LAST!)     */
  1    63       2 cb_c_r	bit (18) aligned,	/* offset of current buffer	       */
  1    64       2 cb_w_r	bit (18) aligned,	/* offset of buffer being worked on  */
  1    65       2 sws,
  1    66         3 flow_sw	bit (1) unal,	/* -label specified		       */
  1    67         3 break_sw	bit (1) unal,	/* -break specified		       */
  1    68         3 edit_sw	bit (1) unal,	/* -trace_edit specified	       */
  1    69         3 input_sw	bit (1) unal,	/* -trace_input		       */
  1    70         3 old_style bit (1) unal,	/* 1-old-style escapes allowed       */
  1    71         3 remote_sw bit (1) unal,	/* 1-not in home_dir	       */
  1    72         3 read_sw   bit (1) unal,	/* 1-always read files	       */
  1    73         3 lit_sw    bit (1) unal,	/* 1-expressions are literal	       */
  1    74         3 fill	bit (28) unal,
  1    75       2 tedname	char (32) var,	/* name under which ted_ was called  */
  1    76       2 comment     char (256)var,	/* user ident of environment	       */
  1    77       2 err_msg	char (168)var,
  1    78       2 regexp	char (500),	/* holds the remembered regular expr */
  1    79 				/*  is placed here to get word       */
  1    80 				/*  alignment		       */
  1    81       2 dir_db	char (168),	/* where work segments live	       */
  1    82       2 person      char (22),	/* who started		       */
  1    83       2 project     char (9),		/* ...this environment	       */
  1    84       2 nulreq	char (2),		/* what is null request (p|P|!p)     */
  1    85       2 err_go	char (16),	/* label to go to on error	       */
  1    86       2 rq_id       char (19),	/* request id for this	       */
  1    87       2 stk_info,
  1    88         3 curp	ptr,		/* pointer to current buffer	       */
  1    89         3 top	ptr,		/* pointer to top of stack	       */
  1    90         3 level	fixed bin (21),	/* recursion depth		       */
  1    91         3 next	fixed bin (21);
  1    92       /* next space available in stack     */
  1    93       
  1    94 
  1    95 /* END INCLUDE FILE ..... tedbase.incl.pl1 .....			       */
     1065 
  2     1 /* BEGIN INCLUDE FILE ..... tedcommon_.incl.pl1 ..... 02/15/82 J Falksen */
  2     2 
  2     3 /*		         ted common data area			       */
  2     4 
  2     5 dcl 1 tedcommon_$id ext static,
  2     6       2 ted_vers char(12)var;		/*  version.revision	       */
  2     7 
  2     8 dcl 1 tedcommon_$no_data	like buf_des ext static;
  2     9 dcl 1 tedcommon_$no_seg	like seg_des ext static;
  2    10 
  2    11 dcl 1 tedcommon_$etc ext static,
  2    12       2 com_blank   bit(1)aligned,
  2    13       2 com1_blank  bit(1)aligned,
  2    14       2 caps	bit(1)aligned,
  2    15       2 reset_read	bit(1)aligned,
  2    16       2 sws,
  2    17         3 (db_ted, lg_ted)	bit(1)aligned,
  2    18         3 (db_addr, lg_addr)	bit(1)aligned,
  2    19         3 (db_eval, lg_eval)	bit(1)aligned,
  2    20         3 (db_sort, lg_sort)	bit(1)aligned,
  2    21         3 (db_gv, lg_gv)	bit(1)aligned,
  2    22         3 (db_util, lg_util)	bit(1)aligned,
  2    23         3 (db_srch, lg_srch)	bit(1)aligned,
  2    24         3 (db_glob, lg_glob)	bit(1)aligned,
  2    25         3 (db_trac, lg_sp4)	bit(1)aligned,
  2    26         3 (db_Ed, lg_sp3)	bit(1)aligned,
  2    27         3 (db_sp2, lg_sp2)	bit(1)aligned,
  2    28         3 (db_sp1, lg_sp1)	bit(1)aligned,
  2    29         3 (db_catch, lg_catch)bit(1)aligned,
  2    30       2 db_output ptr;
  2    31 
  2    32 /* END INCLUDE FILE ..... tedcommon_.incl.pl1 ..... */
     1066 
  3     1 /* BEGIN INCLUDE FILE ..... tedbcb.incl.pl1 ..... 01/29/82 J Falksen	       */
  3     2 
  3     3 /* UPDATE HISTORY (finally)					       */
  3     4 /* EL#   date	TR	comments				       */
  3     5 /* --- 84-10-19 -------- add sws.INPUT				       */
  3     6 /* --- 84-10-29 -------- add sws.invoking			       */
  3     7 
  3     8 /* if the structure of buf_des changes, tedcommon_.alm and		       */
  3     9 /*  tedcommon.incl.pl1 must be appropriately changed		       */
  3    10 
  3    11 dcl 1 buf_des	(all_des) based (bp),  /* buffer part descriptor	       */
  3    12       2 l,			/* left end (LHE) data (see Note 1)  */
  3    13         3 ln	fixed bin (21),	/*  line number		       */
  3    14         3 le	fixed bin (21),	/*  left  end (LE) offset	       */
  3    15         3 re	fixed bin (21),	/*  right end (RE) offset	       */
  3    16       2 r		like buf_des.l;	/* right end (RHE) data	       */
  3    17 
  3    18 /* Note1:	buf_des describes 2 slightly different things, buffer parts and    */
  3    19 /* 	addresses. These are the circumstances:			       */
  3    20 /*							       */
  3    21 /*							       */
  3    22 /*		|...............<buffer>..........................|      */
  3    23 /*	  b.cur.sp|	|..........<window>...........|	|      */
  3    24 /*	Buffer:	xxxxxxxxxxwwwwwwwwwwwww...<hole>...wwwwwwxxxxxxxxxx      */
  3    25 /*			|	  |	     |	|	|      */
  3    26 /*	           b.b_.l.le|  b.b_.l.re|   b.b_.r.le|	|     maxl|      */
  3    27 /*		    	   b.b_.l.ln|	 b.b_.r.le|    maxln|      */
  3    28 /*					 b.b_.r.ln|	       */
  3    29 /*    b.b_.l.ln (if known) tells the # of lines in left part of window       */
  3    30 /*    b.b_.r.ln (if known) tells the # of lines the whole window	       */
  3    31 /*    b.maxln   (if known) tells the # of lines in the whole buffer	       */
  3    32 /*	Either left or right part may be null. A ^read file	       */
  3    33 /*	is in the right part. A file is always read at the	       */
  3    34 /*	upper end of the hole. This will usually minimize the	       */
  3    35 /*	amount of data movement during subsequent editing		       */
  3    36 /*	operations.					       */
  3    37 /*							       */
  3    38 /* Data movement which occurs within a request, for example substitute, can  */
  3    39 /*  cause an offset to temporarily point into the hole. This will clear up   */
  3    40 /*  before the operation is complete.				       */
  3    41 
  3    42 /*						N	       */
  3    43 /*	Address:	....xxxxxxxxxxsssss -- sssssssxxxxxxxxxxL....	       */
  3    44 /*		    |	    |	         |	|	       */
  3    45 /*		l.le|	l.re|	     r.le|      r.re|	       */
  3    46 /*			l.ln|		      r.ln|	       */
  3    47 /*	l.re is the beginning of the string addressed.		       */
  3    48 /*	l.le is the beginning of line containing location l.re	       */
  3    49 /*		Thus l.ln is related to both l.re and l.le	       */
  3    50 /*	r.re is the end of the string addressed.		       */
  3    51 /*	r.le is the end of line containing location r.re		       */
  3    52 /*		Thus r.ln is related to both r.re and r.le	       */
  3    53 /*	(l.le and r.le relate to the same line when 1 line is addressed)   */
  3    54 /* In line mode each request starts with     l.re=l.le   &   r.re=r.le       */
  3    55 /* In string mode a global request forces these conditions.		       */
  3    56 
  3    57 /*** b_c/b_s reference the string which represents the buffer data.	       */
  3    58 dcl b_c		(b.maxl) char (1) based (b.cur.sp);
  3    59 dcl b_s		char (b.maxl) based (b.cur.sp);
  3    60 
  3    61 dcl (live_des	init (8),
  3    62     all_des	init (13),
  3    63     reloc_first	init (2),		/* where to begin minus 1	       */
  3    64     reloc_last	init (8)		/* where to stop		       */
  3    65     )		fixed bin int static options (constant);
  3    66 dcl bp		ptr;
  3    67 dcl 1 b		based (bp),	/* ted buffer control block	       */
  3    68       2 b_	like buf_des,	/* defines buffer limits	       */
  3    69       2 newb	like buf_des,	/* pending buffer values	       */
  3    70       2 ex	like buf_des,	/* execution limits		       */
  3    71       2 a_	(0:2) like buf_des, /* address data		       */
  3    72 				/*  (0)  "cur location"	       */
  3    73 				/*  (1)  1st addr result	       */
  3    74 				/*  (2)  2nd addr result	       */
  3    75       2 cd	like buf_des,	/* copy destination		       */
  3    76       2 gb	like buf_des,	/* info for global processing	       */
  3    77       2 newa	like buf_des,	/* pending address values	       */
  3    78 				/*    ----limit of relocation----    */
  3    79 /* these are not relocated because they define the relocation data	       */
  3    80       2 rel_temp	like buf_des,	/* hold during relocation	       */
  3    81       2 temp	(0:2) like buf_des,	/* hold during [.]addr processing    */
  3    82       2 old,			/* where string used to be	       */
  3    83         3 (le,re)	fixed bin (21),	/*   ends of range		       */
  3    84       2 new	like b.old,	/* where string has gone to	       */
  3    85       2 test	like b.old,	/* allowable relocatable range       */
  3    86 				/* (may be 1 or 2 larger than b.old) */
  3    87       2 cur	like seg_des,	/* CURRENT buffer area info	       */
  3    88 				/*    (see note 2)		       */
  3    89       2 pend	like seg_des,	/* PENDING buffer area info	       */
  3    90       2 file_d,			/* file related data	       */
  3    91         3 dtcm	bit(36),		/* when read seg was modified	       */
  3    92         3 uid	bit(36),		/* unique ID of segment	       */
  3    93         3 dname	char(168),	/* directory of file	       */
  3    94         3 ename	char(32),		/* entry of file		       */
  3    95         3 cname	char(32),		/* component of file	       */
  3    96         3 kind	char(1)unal,	/* kind of component	       */
  3    97 				/* " "-none, ":"-archive	       */
  3    98 				/*  "|"-superfile		       */
  3    99         3 sws	unal,
  3   100           4 file_sw	        bit(1),	/* 1-file associated	       */
  3   101           4 trust_sw        bit(1),	/* 1-file name trustable	       */
  3   102           4 mod_sw	        bit(1),	/* 1-buffer has been modified	       */
  3   103           4 terminate       bit(1),	/* 1-dp points to file, terminate    */
  3   104           4 get_bit_count   bit(1),	/* 1-get_bit_count before using this */
  3   105 			/*  buffer, it may have been modified by       */
  3   106 			/*  externally via [ted$buffer xx] usage       */
  3   107           4 force_name      bit(1),	/* 1-name has been forced	       */
  3   108           4 no_io	        bit(1),	/* 1-no r w ^b allowed	       */
  3   109 				/*  (external string edit)	       */
  3   110           4 not_pasted      bit(1),	/* 1-data was moved into buffer but  */
  3   111 				/*  has not been read anywhere       */
  3   112           4 initiate        bit(1),	/* 1-must initiate on restart	       */
  3   113 				/*  (b% and b!)		       */
  3   114           4 ck_ptr_sw       bit(1),	/* 1-if segment is external, must    */
  3   115 				/*  check pointer before ref	       */
  3   116           4 pseudo	        bit (1),	/* 1-^read or read-only buffer       */
  3   117           4 INPUT	        bit (1),	/* 1-active INPUT mode on buffer     */
  3   118           4 invoking        bit (1),	/* 1-buffer being invoked	       */
  3   119           4 fill	        bit (14),
  3   120       2 name	char(16),		/* buffer name		       */
  3   121       2 fill	char(27),
  3   122       2 stackl	bit (18)aligned,	/* offset of list of stacked data    */
  3   123       2 stack_o	bit (18)aligned,	/* offset of data being relocated    */
  3   124       2 present	(0:2) bit(1),	/* 1 if addr present	       */
  3   125       2 tw_sw	      bit(1),	/* 1-typewriter buffer	       */
  3   126       2 bs,			/* Old-style escapes in this buffer  */
  3   127         3 (c,b,r,f)       bit(1),	/* 1-\031,\030,\036,\034 found       */
  3   128       2 noref	      bit(1),	/* 1-not ref'ed, don't list	       */
  3   129       2 maxl	fixed bin(21),	/* max buffer length in this AST     */
  3   130       2 maxln	fixed bin(21),	/* number of lines in buffer	       */
  3   131       2 state_r	fixed bin(21),	/* what state is request in	       */
  3   132       2 (N1,N2,N3)	fixed bin(21),	/* values kept for -safe_ty	       */
  3   133       2 state_b	fixed bin(21);	/* what state is buffer change in    */
  3   134 
  3   135 /* Note2:	sn=0	means empty because the database segment will never      */
  3   136 /*		contain a buffer holder			       */
  3   137 /* 	sn=-1 (&^b.terminate) means read-only data, if modification is     */
  3   138 /* 		done, a copy will be made.			       */
  3   139 /* 	sn=-1 (& b.terminate) means ^read file, if modification is done    */
  3   140 /* 		the file is read first			       */
  3   141 /* 	sn>0	means a buffer holder segment			       */
  3   142 
  3   143 /* END INCLUDE FILE ..... tedbcb.incl.pl1 ..... */
     1067 
     1068 dcl tedaddr_	entry (		/* process request addresses	       */
     1069 		ptr,		/* -> database		       */
     1070 		ptr,		/* -> string containing address      */
     1071 		fixed bin (21),	/*   length of it		  [IN] */
     1072 				/* If <0 then recursive call	       */
     1073 				/*   how much was used up	 [OUT] */
     1074 		ptr,		/* -> buffer control block  [IN/OUT] */
     1075 		char (168) var,	/* place to hold err message if any  */
     1076 		fixed bin (35),	/* status code		       */
     1077 				/*   0- null address	       */
     1078 				/*   1- address found	       */
     1079 				/*   8- error, msg tells what        */
     1080 		);
     1081 
     1082 
     1083 dcl tedshow_	entry () options (variable);
  4     1 /* BEGIN INCLUDE FILE ..... tedsrch_.incl.pl1 ..... 10/21/82 J Falksen */
  4     2 
  4     3 dcl tedsrch_$init_exp entry (	/* initialize an expression area	       */
  4     4 	ptr,		/* -> compiled expression area	  [IN] */
  4     5 	fixed bin (21));	/*   length of area in words		  [IN] */
  4     6 
  4     7 dcl tedsrch_$compile entry (	/* compile a regular expression	       */
  4     8 	ptr,		/* -> regular expression to compile	  [IN] */
  4     9 	fixed bin (21),	/*   length thereof			  [IN] */
  4    10 	ptr,		/* -> compiled expression area	  [IN] */
  4    11 	bit (1)aligned,	/* 0- line mode	1- string mode	  [IN] */
  4    12 	bit (1)aligned,	/* 0- reg expr	1- literal expr	  [IN] */
  4    13 	char (168) var,	/* error message			 [OUT] */
  4    14 	fixed bin (35)	/* error status code		 [OUT] */
  4    15 		);
  4    16 
  4    17 dcl tedsrch_$search entry (	/* search for expression		       */
  4    18 	ptr,		/* -> compiled expression area	  [IN] */
  4    19 	ptr,		/* -> buffer ctl block for file	  [IN] */
  4    20 	fixed bin (21),	/* beginning of string to search in file  [IN] */
  4    21 	fixed bin (21),	/* end of string to search		  [IN] */
  4    22 	fixed bin (21),	/* beginning of match		 [OUT] */
  4    23 	fixed bin (21),	/* end of match			 [OUT] */
  4    24 	fixed bin (21),	/* end of string used for match	 [OUT] */
  4    25 	char (168)var,	/* error message return		 [OUT] */
  4    26 	fixed bin (35)	/* error status code		 [OUT] */
  4    27 		);
  4    28 
  4    29 
  4    30 /* END INCLUDE FILE ..... tedsrch_.incl.pl1 ..... */
     1084 
     1085 /*dcl tedget_existing_buffer_ entry (	/* find a named buffer	       */
     1086 /*		ptr,		/* -> database		       */
     1087 /*		ptr,		/* -> string containing buffer name  */
     1088 /*		fixed bin (21),	/*   length of string	  [IN] */
     1089 /*				/*   how much was used	 [OUT] */
     1090 /*		ptr,		/* buffer control block (OUT)        */
     1091 /*		char (168)var	/* error message text	       */
     1092 /*		);					       */
     1093 
     1094 dcl tedget_buffer_	entry (		/* find (or create) a buffer	       */
     1095 		ptr,		/* -> database		       */
     1096 		ptr,		/* -> string containing buffer name  */
     1097 		fixed bin (21),	/*   length of string	  [IN] */
     1098 				/*   how much was used	 [OUT] */
     1099 		ptr,		/* buffer control block (OUT)        */
     1100 		char (168) var	/* error message text	       */
     1101 		);
     1102 
     1103 
     1104 
     1105    end tedaddr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/02/89  1042.1  tedaddr_.pl1                      >spec>install>1037>tedaddr_.pl1
1065         1    11/23/82  1324.7  tedbase.incl.pl1                  >ldd>include>tedbase.incl.pl1
1066         2    12/18/84  0954.3  tedcommon_.incl.pl1               >ldd>include>tedcommon_.incl.pl1
1067         3    12/18/84  0954.3  tedbcb.incl.pl1                   >ldd>include>tedbcb.incl.pl1
1084         4    12/10/82  1305.8  tedsrch_.incl.pl1                 >ldd>include>tedsrch_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              005071 constant        char(1)                  initial packed unaligned dcl 176 ref 662 835 900 919
                                                                                  950 956 967
NLct                            000164 automatic       fixed bin(21,0)          dcl 880 set ref 894* 895 898 907* 907 912 915 918
                                                                                  926 929* 934* 934 941 945 963 965
a_                       22            based           structure                array level 2 unaligned dcl 3-67 set ref 229 230*
                                                                                  230 345* 345 401 405 460 463* 486* 486 498* 507*
abp                                    parameter       pointer                  dcl 47 set ref 45 188 438* 625*
acode                                  parameter       fixed bin(35,0)          dcl 47 set ref 45 212* 222* 234* 253* 272* 469* 471
                                                                                  565* 577* 605* 611* 635* 644* 861* 867* 1061*
adb_p                                  parameter       pointer                  dcl 47 set ref 45 187 207* 469*
addr                                                   builtin function         dcl 184 ref 207 207 229 344 401 469 469 573 573 573
                                                                                  573 592 592 596 596 625 625 855 855
addr_error                      000200 stack reference condition                dcl 1015 ref 1015
adr_num                         000111 automatic       fixed bin(17,0)          dcl 147 set ref 227* 255 285* 338 343* 382 402* 404*
                                                                                  405 407* 987*
ain_l                                  parameter       fixed bin(21,0)          dcl 47 set ref 45 191 193* 193 197 199* 428* 434
                                                                                  434* 444 445*
ain_p                                  parameter       pointer                  dcl 47 set ref 45 190 199*
all_buffer                      000112 automatic       bit(1)                   packed unaligned dcl 148 set ref 238* 654 750* 826
apr                             000147 automatic       bit(1)                   array packed unaligned dcl 467 set ref 465* 466* 490
                                                                                  491
at                                     parameter       fixed bin(21,0)          dcl 996 ref 994 998
b                                      based           structure                level 1 unaligned dcl 3-67
b_                                     based           structure                level 2 unaligned dcl 3-67
b_c                                    based           char(1)                  array packed unaligned dcl 3-58 ref 662 835 967
bkp_sw                          000113 automatic       bit(1)                   packed unaligned dcl 149 set ref 522* 533* 582
bp                              000152 automatic       pointer                  dcl 3-66 set ref 188* 199 215* 221 221 228 228 229
                                                                                  230 230 232 232 255 306 340 344 345 345 348 348
                                                                                  349 349 351 388 391 391 401 405 406 416 422 430
                                                                                  434 436* 438 442 442 460 460 461 463 465 466 469*
                                                                                  484 486 486 487 487 487 490 491 496 497 498 498
                                                                                  504 505 507 507 517 528 529 534 536 573 588 589
                                                                                  592* 596* 654 662 667 669 669 669 671 673 693 714
                                                                                  728 745 745 745 747 788 788 791 791 792 792 793
                                                                                  793 801 801 801 801 809 809 809 809 816 826 829
                                                                                  835 843 843 855* 870 900 904 919 923 945 950 956
                                                                                  967 967 967 969 972 972 974 974 974 974 987 999
                                                                                  1002 1003 1005 1008 1009
buf_des                                based           structure                array level 1 unaligned dcl 3-11
ca_                                    based           structure                level 1 unaligned dcl 132 set ref 405* 463
ca__p                           000114 automatic       pointer                  dcl 150 set ref 229* 250 250 252 252 344* 362 391
                                                                                  391 401* 405 463 499 518 527 530 592 592 596 596
                                                                                  620 620 620 622 625 625 625 625 639 639 639 654
                                                                                  656 662 662 662 662 664 664 664 669 671 672 672
                                                                                  673 673 693 714 745 747 751 751 754 754 754 755
                                                                                  760 760 760 760 762 762 763 763 777 780 780 785
                                                                                  786 788 791 800 801 808 809 814 820 820 824 831
                                                                                  831 835 835 835 837 837 838 841 841 846 847 855
                                                                                  855 884 885 912 912 912 941 941 941 944 944 977
                                                                                  979 982 983 987 987 987 987 987 987
ch                              000116 automatic       char(1)                  packed unaligned dcl 151 set ref 284* 289 292 297
                                                                                  299 300 301 302 302 303 304 313 324 332 332 346
                                                                                  360 369 374 380 380 397 402 411 413* 414 420 492*
                                                                                  493 502 547* 548 550 552
code                            000117 automatic       fixed bin(35,0)          dcl 152 set ref 573* 575 577 592* 596 596* 601 603
                                                                                  625* 627 633 855* 857 859
concealsw                       000120 automatic       bit(1)                   packed unaligned dcl 153 set ref 542* 544 544* 550*
                                                                                  558*
cur                     124            based           structure                level 2 unaligned dcl 3-67
db_addr                   6     000020 external static bit(1)                   level 3 dcl 2-11 ref 199 262 285 432 786 791 793 886
                                                                                  985 1023
db_output                36     000020 external static pointer                  level 2 dcl 2-11 set ref 199* 262* 285* 434* 886*
                                                                                  987* 1023*
dbase                                  based           structure                level 1 unaligned dcl 1-31
dbase_p                         000150 automatic       pointer                  dcl 1-29 set ref 187* 573 573 573 592 592 596 596
                                                                                  625 625 855 855
delim                           000121 automatic       char(1)                  packed unaligned dcl 154 set ref 521* 531* 548
dot_sw                          000122 automatic       bit(1)                   packed unaligned dcl 155 set ref 247* 321* 366* 371*
                                                                                  684* 705* 730 732*
end_sw                          000123 automatic       bit(1)                   packed unaligned dcl 156 set ref 242* 290 329*
expr_l                          000124 automatic       fixed bin(21,0)          dcl 157 set ref 568* 571 573* 638*
file_str                               based           char                     packed unaligned dcl 141 ref 900 919 950 956
first_file_char                 000105 automatic       fixed bin(21,0)          dcl 142 set ref 918 919 919 956 956 958 1002* 1008*
                                                                                  1018 1023*
fixed                                                  builtin function         dcl 184 ref 725
i                               000125 automatic       fixed bin(21,0)          dcl 158 in procedure "tedaddr_" set ref 540* 543 568
                                                                                  573 573 724* 725 726 740* 785* 786* 788 791* 792*
                                                                                  792 793* 800* 801 801* 801 808* 809 809* 809 814
                                                                                  818 820 824 829 831 838 841
i                               000165 automatic       fixed bin(21,0)          dcl 881 in procedure "find_line" set ref 900* 901
                                                                                  903 919* 921 933 950* 951 953 956* 958 960
in_c                                   based           char(1)                  array packed unaligned dcl 138 set ref 203 207 207
                                                                                  218 262* 284 413 434* 455 469 469 477 492 521 547
                                                                                  554 554 573 573
in_l                            000104 automatic       fixed bin(17,0)          dcl 136 set ref 197* 199 199 199 199 206 216 267 269
                                                                                  280 468 483 543 724 725
in_p                            000102 automatic       pointer                  dcl 135 set ref 190* 199 199 203 207 207 216 218 262
                                                                                  280 284 413 434 455 469 469 477 483 492 521 547
                                                                                  554 554 573 573 724 725
in_part_2                       000110 automatic       bit(1)                   packed unaligned dcl 145 set ref 189* 898 904 923
                                                                                  1001* 1007* 1023*
in_s                                   based           char                     packed unaligned dcl 137 ref 199 199 216 280 483 724
                                                                                  725
index                                                  builtin function         dcl 184 ref 900 919 950 956
ioa_                            000010 constant        entry                    external dcl 179 ref 786 791 793 1013
ioa_$ioa_switch                 000012 constant        entry                    external dcl 180 ref 199 285 434 987 1023
ioa_$ioa_switch_nnl             000014 constant        entry                    external dcl 181 ref 262 886
l                        74            based           structure                array level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                        14            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                        60            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                               000016 external static structure                level 2 in structure "tedcommon_$no_data" unaligned
                                                                                  dcl 2-8 in procedure "tedaddr_"
l                                      based           structure                array level 2 in structure "buf_des" unaligned
                                                                                  dcl 3-11 in procedure "tedaddr_"
l                                      based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                        44            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                         6            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                                      based           structure                level 2 in structure "ca_" unaligned dcl 132
                                                                                  in procedure "tedaddr_"
l                        66            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                        52            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
l                        22            based           structure                array level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_" set ref 344
l                        16            based           structure                level 4 in structure "dbase" unaligned dcl 1-31
                                                                                  in procedure "tedaddr_"
last_file_char                  000107 automatic       fixed bin(21,0)          dcl 144 set ref 898 900 901 904 919 950 951 956
                                                                                  1003* 1009* 1020 1023*
lb                              000166 automatic       fixed bin(21,0)          dcl 882 set ref 884* 886* 888 888 888 911* 917* 938*
                                                                                  945 955* 956 958* 960* 960 977 982
le                        4            based           fixed bin(21,0)          level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 669 745 792 793* 801 801 801
                                                                                  809 904* 974 1005 1008
le                        4            based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 252* 362 391 527 530 592* 596*
                                                                                  620* 625* 639* 662* 664* 669* 671* 672 754* 760*
                                                                                  762* 820* 831* 835* 837* 838 841* 855* 885 983*
                                                                                  987*
le                       23            based           fixed bin(21,0)          array level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 348 496
le                       26            based           fixed bin(21,0)          array level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 349* 505
le                        1            based           fixed bin(21,0)          level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" ref 391 517 529 588 745 747 945 1002
le                              000167 automatic       fixed bin(21,0)          dcl 882 in procedure "find_line" set ref 885* 886*
                                                                                  888 888 888* 890 892 897* 911* 938* 939 939* 949*
                                                                                  950 951* 953* 953 970 972 972* 974 974* 979 983
le                        1            based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 250 499* 518 620 622 625* 639
                                                                                  745* 747* 751 754 760 763 785 786* 788 791* 814
                                                                                  977* 987*
line_sw                         000126 automatic       bit(1)                   packed unaligned dcl 159 set ref 236* 311 328* 371*
                                                                                  584 616 629 652 728 735
lit_sw                  275(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-31 ref 573
ln                       25            based           fixed bin(21,0)          array level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 228* 228*
ln                        3            based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 673* 755* 780* 912 912* 912 941
                                                                                  941* 941 944 987*
ln                        3            based           fixed bin(21,0)          level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" ref 673
ln                                     based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 673* 780* 944* 987*
msg                                    parameter       varying char(168)        dcl 47 set ref 45 207* 270* 279* 279 280* 280 281*
                                                                                  281 317* 354* 384* 457* 469* 479* 511* 564* 573*
                                                                                  592* 596* 610* 625* 643* 658* 680* 695* 716* 768*
                                                                                  855* 866* 1012* 1013* 1029* 1033* 1037* 1041*
                                                                                  1046* 1050* 1054*
name                    235            based           char(16)                 level 2 packed packed unaligned dcl 3-67 set ref
                                                                                  199* 434*
negsw                           000127 automatic       bit(1)                   packed unaligned dcl 160 set ref 245* 285* 326 336
                                                                                  358 378 449 513 524 647 677 685* 702 764 773* 796
                                                                                  813*
next_file_char                  000106 automatic       fixed bin(21,0)          dcl 143 set ref 898 900 901* 903* 903 904 911 918
                                                                                  919 928* 933* 933 938 998* 999 1005 1018 1020
                                                                                  1023*
next_in                         000100 automatic       fixed bin(17,0)          dcl 134 set ref 198* 203 205* 205 206 207 207 209*
                                                                                  209 216* 216 216 218 225* 225 257 260* 260 262
                                                                                  262* 267 269* 277 280 284 342* 342 390* 390 413
                                                                                  417* 417 423* 423 428 444* 445 452 454* 454 455
                                                                                  468 469 469 470* 470 477 482* 482 483* 483 483 492
                                                                                  519* 519 521 538 540 543* 547 554 554 557* 557*
                                                                                  568 721 724 725 726* 726
null                                                   builtin function         dcl 184 ref 210
num                             000130 automatic       fixed bin(21,0)          dcl 161 in procedure "tedaddr_" set ref 725* 728 748
                                                                                  756 764* 764 772* 785 786* 800 808
num                                    parameter       fixed bin(21,0)          dcl 878 in procedure "find_line" set ref 876 895 898
                                                                                  915 918 926 945 963 965 980 987*
old                     116            based           structure                level 2 unaligned dcl 3-67
possw                           000131 automatic       bit(1)                   packed unaligned dcl 162 set ref 246* 285* 326 336
                                                                                  358 378 449 513 524 647 677 702 706* 733* 766 773*
                                                                                  804 813*
present                 252            based           bit(1)                   array level 2 packed packed unaligned dcl 3-67 set
                                                                                  ref 221* 221* 232* 232* 255* 306 340 351* 388 406*
                                                                                  416* 416 422* 422 430* 442* 442* 461 465 466 484
                                                                                  487 490* 491* 573 573 816 816 826 826 843 843 870
                                                                                  870 987 987
q_sw                            000132 automatic       bit(1)                   packed unaligned dcl 163 set ref 220* 243* 308* 334
                                                                                  362 394 396* 430 473 608 641 864 1058
r                         3            based           structure                level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_"
r                         3            based           structure                level 2 in structure "ca_" unaligned dcl 132
                                                                                  in procedure "tedaddr_"
r                        25            based           structure                array level 3 in structure "b" unaligned dcl 3-67
                                                                                  in procedure "tedaddr_" set ref 487* 487
re                        2            based           fixed bin(21,0)          level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 669 745 788 788 791* 791* 792
                                                                                  793* 801 809 809 809 923* 974 974 999 1003
re                        5            based           fixed bin(21,0)          level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" ref 391 528 589 654 669 671 829 843 967
                                                                                  967 969 972 972 974 1009
re                       24            based           fixed bin(21,0)          array level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 348* 504
re                        2            based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 250* 391 592* 596* 620* 625*
                                                                                  639* 662* 664* 672* 754* 763* 800 801 808 809 820*
                                                                                  831* 841* 847 855* 884 982* 987*
re                        5            based           fixed bin(21,0)          level 3 in structure "ca_" dcl 132 in procedure
                                                                                  "tedaddr_" set ref 252 625* 654* 656 662 662 664
                                                                                  693 714 751* 760 760* 762 777 824 835 835 837 846
                                                                                  979* 987*
re                       27            based           fixed bin(21,0)          array level 4 in structure "b" dcl 3-67 in procedure
                                                                                  "tedaddr_" set ref 349 497 693 714
recurring                       000133 automatic       bit(1)                   packed unaligned dcl 164 set ref 194* 196* 274
reg_sw                          000134 automatic       bit(1)                   packed unaligned dcl 165 set ref 239* 297* 852 854*
regexp                  463            based           char(500)                level 2 packed packed unaligned dcl 1-31 set ref 573
                                                                                  573 592 592 596 596 625 625 855 855
rel_temp                 66            based           structure                level 2 unaligned dcl 3-67 set ref 460* 498 507 534*
relsw                           000135 automatic       bit(1)                   packed unaligned dcl 166 set ref 244* 256* 285* 315
                                                                                  364 371* 650 728 737 743 781
reverse                                                builtin function         dcl 184 ref 919 956
se                              000170 automatic       fixed bin(21,0)          dcl 882 set ref 967* 969* 970
seg_des                                based           structure                level 1 unaligned dcl 1-20
sn                      126            based           fixed bin(17,0)          level 3 dcl 3-67 ref 536 667 728
sp                      124            based           pointer                  level 3 dcl 3-67 ref 662 835 900 919 950 956 967
srb1                            000136 automatic       fixed bin(21,0)          dcl 167 set ref 495* 504* 516* 527* 586 588* 592*
                                                                                  623* 624* 847* 852* 852 855*
srb2                            000137 automatic       fixed bin(21,0)          dcl 168 set ref 496* 506* 517* 529* 596* 622
sre1                            000140 automatic       fixed bin(21,0)          dcl 169 set ref 505* 528* 589* 592* 843* 846* 855*
sre2                            000141 automatic       fixed bin(21,0)          dcl 170 set ref 497* 499 506* 518* 530* 590* 596
                                                                                  596*
start_scan                      000142 automatic       fixed bin(21,0)          dcl 171 set ref 240* 257 257* 277 277* 280 280 452
                                                                                  452* 538 538* 721 721*
string_sw                              defined         bit(1)                   packed unaligned dcl 172 set ref 416* 422* 573 816
                                                                                  826 843 870 987*
substr                                                 builtin function         dcl 184 ref 199 199 216 280 483 724 725 900 919 950
                                                                                  956
sws                     275            based           structure                level 2 in structure "dbase" packed packed unaligned
                                                                                  dcl 1-31 in procedure "tedaddr_"
sws                       4     000020 external static structure                level 2 in structure "tedcommon_$etc" unaligned
                                                                                  dcl 2-11 in procedure "tedaddr_"
tbp                             000144 automatic       pointer                  dcl 173 set ref 207* 210 215
tedaddr_                        000022 constant        entry                    external dcl 1068 ref 469
tedcommon_$etc                  000020 external static structure                level 1 unaligned dcl 2-11
tedcommon_$no_data              000016 external static structure                level 1 unaligned dcl 2-8 ref 534
tedget_buffer_                  000032 constant        entry                    external dcl 1094 ref 207
tedshow_                        000024 constant        entry                    external dcl 1083 ref 436
tedsrch_$compile                000026 constant        entry                    external dcl 4-7 ref 573
tedsrch_$search                 000030 constant        entry                    external dcl 4-17 ref 592 596 625 855
used                            000146 automatic       fixed bin(21,0)          dcl 174 set ref 206* 207* 209 468* 469* 470
verify                                                 builtin function         dcl 184 ref 216 483 724

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
COM                                    internal static fixed bin(24,0)          initial dcl 1-3
NORMAL                                 internal static fixed bin(24,0)          initial dcl 1-3
RESTART                                internal static fixed bin(24,0)          initial dcl 1-3
SAFE                                   internal static fixed bin(24,0)          initial dcl 1-3
all_des                                internal static fixed bin(17,0)          initial dcl 3-61
b_s                                    based           char                     packed unaligned dcl 3-59
dbase_vers_3                           internal static fixed bin(17,0)          initial dcl 1-30
live_des                               internal static fixed bin(17,0)          initial dcl 3-61
rc_close                               internal static fixed bin(24,0)          initial dcl 1-8
rc_fail                                internal static fixed bin(24,0)          initial dcl 1-9
rc_keyerr                              internal static fixed bin(24,0)          initial dcl 1-11
rc_nop                                 internal static fixed bin(24,0)          initial dcl 1-10
reloc_first                            internal static fixed bin(17,0)          initial dcl 3-61
reloc_last                             internal static fixed bin(17,0)          initial dcl 3-61
rl_b                                   automatic       fixed bin(21,0)          dcl 1-14
rl_c                                   based           char(1)                  array packed unaligned dcl 1-17
rl_i                                   defined         fixed bin(21,0)          dcl 1-15
rl_l                                   defined         fixed bin(21,0)          dcl 1-16
rl_s                                   based           char                     packed unaligned dcl 1-18
tedcommon_$id                          external static structure                level 1 unaligned dcl 2-5
tedcommon_$no_seg                      external static structure                level 1 unaligned dcl 2-9
tedsrch_$init_exp               000000 constant        entry                    external dcl 4-3

NAMES DECLARED BY EXPLICIT CONTEXT.
a_line                          000631 constant        label                    dcl 250 ref 367 616 629 675 775
add_err_8                       000733 constant        label                    dcl 272 ref 319 355 386 458 480 512 660 682 696 717
                                                                                  770 1031 1035
add_err_text                    000736 constant        label                    dcl 274 ref 475 612 645 868
addr_after_buffer               004631 constant        entry                    internal dcl 1045 ref 829 892 963 970 1020
addr_after_line                 003714 constant        label                    dcl 1050 ref 838
addr_before_buffer              003674 constant        label                    dcl 1037 set ref 818 926 965 1018
addr_before_line                003704 constant        label                    dcl 1041 ref 816
addr_outside                    003734 constant        label                    dcl 1058 ref 1039 1043 1047 1052 1056
backup                          002126 constant        label                    dcl 513 ref 374
backup_limit                    002140 constant        label                    dcl 519 ref 500
bkp1                            002522 constant        label                    dcl 620 ref 582
buffer_empty                    003724 constant        label                    dcl 1054 ref 536 728
byte2                           000621 constant        label                    dcl 240 ref 352
cnum                            003231 constant        label                    dcl 777
creg                            003542 constant        label                    dcl 843 ref 584
err_Aa1                         003664 constant        label                    dcl 1033 ref 340 388
err_Ad1                         001127 constant        label                    dcl 317 ref 306 364 650
err_Adn                         002655 constant        label                    dcl 658 ref 777 890
err_Amn                         000724 constant        label                    dcl 270
err_Anm                         002737 constant        label                    dcl 680 ref 326 336 358 378 449 513 524 647 702
err_Aqe                         003654 constant        label                    dcl 1029 ref 334
err_Axn                         003213 constant        label                    dcl 768 ref 804
fail                            001541 constant        label                    dcl 445 ref 274 282 566 578 606 636 862 1016 1062
find_line                       003743 constant        entry                    internal dcl 876 ref 615 623 674 756 772 821 832 870
finished                        001417 constant        label                    dcl 428 ref 223
get_num                         003025 constant        label                    dcl 721 ref 302
last                            002630 constant        label                    dcl 647 ref 299
limit                           001546 constant        label                    dcl 449 ref 303
line2                           000615 constant        label                    dcl 236 ref 408
neg                             002731 constant        label                    dcl 677 ref 300
only_2                          001310 constant        label                    dcl 384 ref 338
pos                             002773 constant        label                    dcl 702 ref 301
q_comma                         000602 constant        label                    dcl 230 ref 397
q_fail                          001530 constant        label                    dcl 442 ref 362 391 473 608 641 864 1064
q_semi                          000606 constant        label                    dcl 232 ref 399
range_err                       004531 constant        label                    dcl 1013
reg                             002152 constant        label                    dcl 524 ref 292
reg1                            002277 constant        label                    dcl 568 ref 548
reg_limit                       002173 constant        label                    dcl 531 ref 508
scan                            000636 constant        label                    dcl 253 ref 322 618 631 665 667 699 720 822 833 842
                                                                                  872
scan0                           000650 constant        label                    dcl 257 ref 309 372
scan1                           000654 constant        label                    dcl 260 ref 289 330 418 424
scan2                           000655 constant        label                    dcl 262 ref 248
scan_reg                        002176 constant        label                    dcl 534 ref 523
set                             004374 constant        label                    dcl 977 ref 930
set_file                        004473 constant        entry                    internal dcl 994 ref 897 904 917 923 949 955
tedaddr_                        000345 constant        entry                    external dcl 45

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5220        5254    5100        5230
Length      5524    5100        34         233     117           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tedaddr_                            472 external procedure  is an external procedure.  
find_line                               internal procedure  shares stack frame of external procedure tedaddr_.  
set_file                                internal procedure  shares stack frame of external procedure tedaddr_.  
addr_after_buffer                       internal procedure  shares stack frame of external procedure tedaddr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tedaddr_                 000100 next_in                     tedaddr_
                         000102 in_p                        tedaddr_
                         000104 in_l                        tedaddr_
                         000105 first_file_char             tedaddr_
                         000106 next_file_char              tedaddr_
                         000107 last_file_char              tedaddr_
                         000110 in_part_2                   tedaddr_
                         000111 adr_num                     tedaddr_
                         000112 all_buffer                  tedaddr_
                         000113 bkp_sw                      tedaddr_
                         000114 ca__p                       tedaddr_
                         000116 ch                          tedaddr_
                         000117 code                        tedaddr_
                         000120 concealsw                   tedaddr_
                         000121 delim                       tedaddr_
                         000122 dot_sw                      tedaddr_
                         000123 end_sw                      tedaddr_
                         000124 expr_l                      tedaddr_
                         000125 i                           tedaddr_
                         000126 line_sw                     tedaddr_
                         000127 negsw                       tedaddr_
                         000130 num                         tedaddr_
                         000131 possw                       tedaddr_
                         000132 q_sw                        tedaddr_
                         000133 recurring                   tedaddr_
                         000134 reg_sw                      tedaddr_
                         000135 relsw                       tedaddr_
                         000136 srb1                        tedaddr_
                         000137 srb2                        tedaddr_
                         000140 sre1                        tedaddr_
                         000141 sre2                        tedaddr_
                         000142 start_scan                  tedaddr_
                         000144 tbp                         tedaddr_
                         000146 used                        tedaddr_
                         000147 apr                         tedaddr_
                         000150 dbase_p                     tedaddr_
                         000152 bp                          tedaddr_
                         000164 NLct                        find_line
                         000165 i                           find_line
                         000166 lb                          find_line
                         000167 le                          find_line
                         000170 se                          find_line

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          signal_op           shorten_stack
ext_entry           any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          ioa_$ioa_switch               ioa_$ioa_switch_nnl           tedaddr_
tedget_buffer_                tedshow_                      tedsrch_$compile              tedsrch_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
tedcommon_$etc                tedcommon_$no_data




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     45 000337       187 000352       188 000356       189 000361       190 000362       191 000365       193 000367
    194 000371       195 000373       196 000374       197 000375       198 000377       199 000401       203 000453
    205 000462       206 000463       207 000467       209 000514       210 000516       212 000522       213 000525
    215 000526       216 000530       218 000553       220 000557       221 000561       222 000566       223 000570
    225 000571       227 000572       228 000574       229 000600       230 000602       232 000606       234 000613
    236 000615       238 000617       239 000620       240 000621       242 000622       243 000623       244 000624
    245 000625       246 000626       247 000627       248 000630       250 000631       252 000634       253 000636
    255 000641       256 000646       257 000650       260 000654       262 000655       267 000717       269 000722
    270 000724       272 000733       274 000736       277 000740       279 000744       280 000760       281 001000
    282 001007       284 001010       285 001015       289 001056       290 001061       292 001063       297 001066
    299 001071       300 001073       301 001075       302 001077       303 001104       304 001106       306 001110
    308 001114       309 001116       311 001117       313 001121       315 001124       317 001127       319 001136
    321 001137       322 001141       324 001142       326 001144       328 001152       329 001154       330 001155
    332 001156       334 001162       336 001164       338 001172       340 001175       342 001201       343 001202
    344 001204       345 001206       346 001211       348 001214       349 001216       351 001220       352 001222
    354 001223       355 001232       358 001233       360 001242       362 001246       364 001253       366 001256
    367 001260       369 001261       371 001263       372 001267       374 001270       378 001272       380 001300
    382 001305       384 001310       386 001317       388 001320       390 001324       391 001325       394 001334
    396 001336       397 001337       399 001342       401 001343       402 001345       404 001352       405 001354
    406 001363       407 001365       408 001367       411 001370       413 001372       414 001400       416 001403
    417 001406       418 001407       420 001410       422 001412       423 001415       424 001416       428 001417
    430 001423       432 001430       434 001434       436 001501       438 001524       439 001527       442 001530
    444 001535       445 001541       447 001545       449 001546       452 001554       454 001560       455 001561
    457 001567       458 001576       460 001577       461 001626       463 001633       465 001637       466 001643
    468 001650       469 001656       470 001706       471 001710       473 001714       475 001716       477 001717
    479 001725       480 001733       482 001734       483 001735       484 001757       486 001763       487 001766
    490 001777       491 002004       492 002011       493 002016       495 002021       496 002022       497 002024
    498 002026       499 002054       500 002057       502 002060       504 002062       505 002064       506 002066
    507 002070       508 002116       511 002117       512 002125       513 002126       516 002130       517 002132
    518 002135       519 002140       521 002141       522 002147       523 002151       524 002152       527 002160
    528 002164       529 002167       530 002171       531 002173       533 002175       534 002176       536 002204
    538 002206       540 002212       542 002215       543 002216       544 002225       547 002231       548 002236
    550 002241       552 002245       554 002250       557 002260       558 002261       563 002263       564 002265
    565 002274       566 002276       568 002277       571 002301       573 002302       575 002347       577 002351
    578 002353       582 002354       584 002356       586 002360       588 002363       589 002366       590 002370
    592 002371       596 002426       601 002470       603 002472       605 002474       606 002477       608 002500
    610 002502       611 002511       612 002513       615 002514       616 002517       618 002521       620 002522
    622 002526       623 002532       624 002534       625 002536       627 002573       629 002575       631 002577
    633 002600       635 002602       636 002605       638 002606       639 002607       640 002613       641 002614
    643 002616       644 002625       645 002627       647 002630       650 002636       652 002641       654 002643
    656 002651       658 002655       660 002664       662 002665       664 002676       665 002701       667 002702
    669 002705       671 002715       672 002720       673 002722       674 002725       675 002730       677 002731
    680 002737       682 002746       684 002747       685 002750       693 002752       695 002762       696 002771
    699 002772       702 002773       705 003001       706 003002       714 003004       716 003014       717 003023
    720 003024       721 003025       724 003031       725 003051       726 003065       728 003071       730 003103
    732 003105       733 003106       735 003110       737 003112       740 003115       741 003123       743 003125
    745 003130       747 003141       748 003144       750 003146       751 003150       752 003153       754 003154
    755 003157       756 003161       758 003166       760 003167       762 003177       763 003200       764 003202
    766 003210       768 003213       770 003222       772 003223       773 003225       775 003230       777 003231
    780 003235       781 003240       785 003243       786 003247       788 003303       791 003313       792 003352
    793 003360       795 003411       796 003412       800 003415       801 003420       803 003432       804 003433
    808 003436       809 003441       813 003454       814 003457       816 003463       818 003467       820 003471
    821 003473       822 003476       824 003477       826 003501       829 003507       831 003512       832 003516
    833 003521       835 003522       837 003533       838 003534       841 003537       842 003541       843 003542
    846 003551       847 003554       852 003557       854 003562       855 003564       857 003620       859 003622
    861 003624       862 003627       864 003630       866 003632       867 003641       868 003643       870 003644
    872 003653      1029 003654      1031 003663      1033 003664      1035 003673      1037 003674      1039 003703
   1041 003704      1043 003713      1050 003714      1052 003723      1054 003724      1056 003733      1058 003734
   1061 003736      1062 003741      1064 003742       876 003743       884 003745       885 003750       886 003752
    888 004003       890 004015       892 004020       894 004023       895 004024       897 004030       898 004032
    900 004047       901 004070       903 004075       904 004076       907 004111       908 004112       911 004113
    912 004116       915 004124       917 004127       918 004131       919 004141       921 004160       923 004161
    926 004173       928 004177       929 004200       930 004202       933 004203       934 004205       935 004207
    938 004210       939 004213       941 004216       944 004224       945 004227       949 004236       950 004240
    951 004261       953 004266       955 004271       956 004273       958 004312       960 004316       963 004322
    965 004327       967 004333       969 004345       970 004350       972 004353       974 004363       977 004374
    979 004377       980 004401       982 004404       983 004406       985 004410       987 004414       993 004472
    994 004473       998 004475       999 004477      1001 004502      1002 004504      1003 004506      1004 004510
   1005 004511      1007 004513      1008 004515      1009 004517      1010 004521      1012 004522      1013 004531
   1015 004552      1016 004555      1018 004556      1020 004561      1023 004564      1027 004630      1045 004631
   1046 004632      1047 004641


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
