	COMPILATION LISTING OF SEGMENT ted_
	Compiled by: Multics PL/I Compiler, Release 31b, of April 24, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 05/02/89  1049.1 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-08-03,RWaters), approve(88-08-03,MCR7950), audit(88-09-29,Huen),
       18*     install(88-10-07,MR12.2-1146):
       19*     Bug fixes for MR12.2.
       20*  2) change(89-03-29,Huen), approve(89-03-29,MCR8062), audit(89-04-25,JRGray),
       21*     install(89-05-02,MR12.3-1037):
       22*     Fix bug 160: Modify ted to ignore trailing whitespace after a quit
       23*     request.
       24*  3) change(89-03-29,Huen), approve(89-03-29,MCR8079), audit(89-04-25,JRGray),
       25*     install(89-05-02,MR12.3-1037):
       26*               Fix bug 210: Modify ted to ltrim on the "help" request.
       27*               Fix bug 208: Modify ted to ignore leading <TAB> characters.
       28*               Fix bug 207: Modify ted to extend "help" request to work in
       29*     "f" request.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
       34 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
       35 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       36 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       37 
       38 /*							       */
       39 /*   _|_              |					       */
       40 /*    |      _      _ |					       */
       41 /*    |     / \    / \|					       */
       42 /*    |    (__/   (   |					       */
       43 /*    \_    \_/    \_/|					       */
       44 /*                       -----				       */
       45 /*							       */
       46 
       47 /* ted is an editor based on qedx.  There have been extensive changes and    */
       48 /*  additions						       */
       49 /* ted	06/01/72	James Falksen				       */
       50 /* ted3	01/01/73	James Falksen				       */
       51 /* ted4	11/01/74	James Falksen				       */
       52 /* ted2.5 05/01/80  jaf					       */
       53 /* ted2.6 02/25/81  jaf					       */
       54 /*        01/05/81  jaf  added g./  / request which uses null=X value	       */
       55 /* ted3.0 05/10/84  jaf  added db_output iocb pointer support	       */
       56 /*		     converted from tedmrl_ to mrl_		       */
       57 
       58 /* UPDATE HISTORY						       */
       59 /* EL#   date	TR	comments				       */
       60 /* 119	      phx15727 "#" doesn't always know a buffer is empty.	       */
       61 /* 131	      phx16660 "fo",no output. "+5" knows b(o) empty, "#" doesn't  */
       62 /* 142	      phx17283 g* "d" leaving empty buffer, "x" didn't show that   */
       63 /* 145	      phx17343 null_ptr_ref from "y" in empty buffer	       */
       64 /* 129 84-10-08 phx16839 handle "locked" buffers properly.		       */
       65 /* 137 84-10-09 phx16858 make initial b0 same state as all other new buffers */
       66 /* 140 84-10-09 phx17209 "x" on windowed buffer not show windowed size       */
       67 /* 157 84-10-09 phx18306 pathname processing sometimes messed up. Problem    */
       68 /*		was already fixed, but tightened things up a little.     */
       69 /* 147 84-10-10 phx17391 recursive fileout not always handled well	       */
       70 /* 152 84-10-11 phx17594 OOB fault on empty buffer (after [buffer X])	       */
       71 /* 153 84-10-12 phx17665 Got a no_read_permission fault doing a "w"	       */
       72 /* 159 84-10-12 phx15158 let ted$qedx "q" check for modified buffers	       */
       73 /* --a 84-10-19 -------- |function doesn't get right inp.lno if first line   */
       74 /*		of buffer is empty				       */
       75 /* 156 84-10-19 phx18195 prohibit invoking buffer in INPUT mode and	       */
       76 /*		modifying buffer being executed.		       */
       77 /* 160 84-10-19 phx17878 rtrim quit request lines (incomplete fix)	       */
       78 /* 1xx 84-11-05 -------- fixes up to this point broke m/M/k/K	       */
       79 /* 162 85-01-11 -------- "vd/x/" leaves "." undefined if last line deleted   */
       80 /* 191 88-08-07 phx19915,19147 print a better error message than             */
       81 /*     'unsupported operation' when reading a non-existent file              */
       82 /* 193 88-08-07 phx19382 tabin sometimes references thru null pointer when   */
       83 /*	'.' is undefined and buffer is empty                               */
       84 /* 194 88-08-07 phx19660 !f<NL> stopped working because of fix to #147       */
       85 /* 197 88-08-07 phx19916 rtrim all error messages                            */
       86 /* 200 88-09-07 phx20649 needed a ',' after "resetread" in 'o' request output*/
       87 /* 201 88-09-07 phx20688 et_$no_component rather than noentry should be      */
       88 /*	printed when talking about archive components                      */
       89 /* 160 89-01-11 phx17878 Rtrim the "quit" request.                           */
       90 /* 210 89-03-15 phx21267 Ltrim the "help" request.                           */
       91 /* 208 89-03-15 phx21260 Extend the ignoring of leading spaces to include    */
       92 /*       <TAB> character.                                                    */
       93 /* 207 89-03-15 phx21035 Extend "help" request to work in "f" request.       */
       94 /* END HISTORY						       */
       95 
       96 ted__:
       97 ted_:				/* main part of editor	       */
       98    proc (ated_data_p, acode) options (variable);
       99 dcl (				/* +++++ */
      100     ated_data_p	ptr,		/* -> data structure	       */
      101     acode		fixed bin (35)	/* return code		       */
      102     )		parm;		/* <<>> */
      103 
      104 dcl ted_data_p	ptr;
      105 
      106       ted_data_p = ated_data_p;
      107       if (ted_data.version ^= ted_data_version_1)
      108       then do;
      109          call ioa_ ("^a: Assuming old version of ted_data structure given.",
      110 	    ted_data.tedname);
      111          ted_data.version = 1000;
      112       end;
      113       DBA = ted_data.tedname;
      114       ted_mode = ted_data.ted_mode;
      115       hold_db_output = db_output;
      116       if (db_output = null ())	/* make sure there is a switch for   */
      117       then db_output = iox_$user_output;/* ..debugging output	       */
      118       if db_catch
      119       then do;
      120          if (db_output = iox_$user_output)
      121          then do;
      122 	  db_output = null ();	/* don't kill user_output	       */
      123 	  call iox_$attach_name ("ted_db_output_", db_output,
      124 	       "vfile_ ted.db_output", null (), code);
      125 	  if (code = 0)
      126 	  then call iox_$open (db_output, 2, ""b, code);
      127 	  if (code ^= 0)
      128 	  then do;
      129 	     call iox_$detach_iocb (db_output, 0);
      130 	     db_output = null ();
      131 	     acode = code;
      132 	     return;
      133 	  end;
      134          end;
      135       end;
      136 
      137       if (ted_mode ^= RESTART)
      138       then do;
      139 /**** A caller of ted_ may find it easier to include arguments in the call   */
      140 /****  instead of building an argument list for arg_list_p to point to. If   */
      141 /****  the arguments are fixed in number there is no good reason to have to  */
      142 /****  go to that trouble. To help this out, ted_ will allow additional      */
      143 /****  arguments to be passed to it. References to these will then be	       */
      144 /****  plugged into the structure.				       */
      145          call cu_$arg_count (hold_de, code);
      146          if (hold_de > 2)
      147          then do;
      148 	  call cu_$arg_list_ptr (ted_data.arg_list_p);
      149 	  ted_data.arg_list_1 = 3;
      150 	  ted_data.arg_list_n = hold_de;
      151          end;
      152       end;
      153 
      154       call tedinit_ (ted_data_p, dbase_p, code);
      155       if (code ^= 0)
      156       then do;
      157          acode = code;
      158          return;
      159       end;
      160       if db_catch
      161       then call ioa_$ioa_switch (db_output, "^/====Begin ted level ^i^/",
      162 	      dbase.recurs);
      163 
      164       bp = ptr (dbase_p, cb_c_r);
      165       call make_consistent;
      166       ted_safe = (dbase.dir_db ^= "");
      167       if (ted_data.return_string_p = null ())
      168       then af_bp = null ();
      169       else do;
      170          argname = "(argn)";
      171          call tedget_buffer_ (dbase_p, addr (argname), length (argname),
      172 	    af_bp, msg);
      173          if (af_bp = null ())
      174          then goto rq_err_msg;
      175       end;
      176       call tedsrch_$init_exp (addr (dbase.regexp),
      177 	 divide (length (dbase.regexp), 4, 21, 0));
      178       gbp = null ();
      179       edit_sw = db_ted | db_trac;
      180       input_sw = db_ted | db_trac;
      181       break_sw, flow_sw = "0"b;
      182       old_style = "1"b;		/* allowed for now		       */
      183 
      184 /*			 **** ***** ****			       */
      185 /* ------------------------------------------------------------------------- */
      186 /* Gapped standards permit a range to be split across the gap, but a line of */
      187 /*  text cannot be split between requests.  Some requests, like "w" and "p"  */
      188 /*  will function across the gap.  Others, like "i", or "r" will force the   */
      189 /*  gap to the place being worked at. Except, "d" will work differently      */
      190 /*  depending on whether when the gap is in the range or not.	       */
      191 /* ------------------------------------------------------------------------- */
      192 
      193 get_the_string: proc;
      194 
      195       if (ted_data.input_l > 0)
      196       then call tedpseudo_ (bp, -1, ted_data.input_p, ted_data.input_l);
      197       b.no_io = "1"b;
      198       b.dname = "<<<external string>>";
      199       b.ename = "";
      200       b.file_sw = "1"b;
      201       b.cname = "";
      202       b.kind = "";
      203    end get_the_string;
      204       msg_ptr = addrel (addr (msg), 1);
      205       pi_passthru = "0"b;
      206       maxseg = sys_info$max_seg_size * 4;
      207       query_info.version = query_info_version_5;
      208       query_info.yes_or_no_sw = "1"b;
      209       b.a_.l.le (0), b.a_.l.re (0) = 1; /* set current line to null	       */
      210       b.a_.r.le (0), b.a_.r.re (0) = addr_undef;
      211       gvx_p, sub_p = null ();
      212       if (ted_mode ^= RESTART)
      213       then do;
      214          nulreq = "p";
      215       end;
      216       else ted_mode = SAFE;
      217       b0_bp = bp;
      218       if (ted_data.input_p ^= null ())
      219       then call get_the_string;
      220       unspec (subf1) = "012014011011"b3;
      221       unspec (subf2) = "012012012"b3;
      222       qedx_mode = (DBA = "qedx");
      223       pi_sw, b_depth = 0;
      224       dbase.S_count = -1;
      225       app_sw, fo_sw, go_sw = "0"b;
      226       gvNL = ""b;
      227       read_sw = "1"b;
      228       on condition (program_interrupt)
      229          begin;
      230 dcl continue_to_signal_ entry (fixed bin (35));
      231 	  if pi_passthru
      232 	  then call continue_to_signal_ (code);
      233 	  else do;
      234 	     if (pi_sw = 1)		/* are we currently accepting PIs?   */
      235 	     then do;
      236 	        pi_sw = 0;		/* if so, reset enable switch	       */
      237 	        call iox_$control (iox_$user_output, "resetwrite", null (),
      238 		   code);
      239 	        goto pi_label;	/* goto (non-local) specified loc    */
      240 	     end;
      241 	     else if (pi_sw = 2)
      242 	     then do;
      243 	        pi_sw = 0;
      244 	        intsw = "1"b;	/*  just indicate interrupt occurred */
      245 	     end;
      246 	     else if (pi_sw = 3)	/* during INPUT mode	       */
      247 	     then do;
      248 	        pi_sw = 0;
      249 	        which_mode = "EOF";	/* #117*/
      250 	        goto pi_label;
      251 	     end;
      252 	     else goto nx_line;
      253 	  end;
      254          end;			/* PROGRAM_INTERRUPT	       */
      255 
      256       req_not, req_ch, req_chx = " ";
      257       svpath = "";			/* #157*/
      258       iocb_ptr = null ();
      259 
      260       on condition (cleanup) call cleaner;
      261 cleaner: proc;
      262 
      263       if (iocb_ptr ^= null ())
      264       then do;
      265          call iox_$close (iocb_ptr, code);
      266          call iox_$detach_iocb (iocb_ptr, code);
      267       end;
      268       if fo_sw
      269       then call detach ("1"b);
      270       i = dbase.recurs;		/* hang on to recursion depth	       */
      271       call tedcleanup_ (dbase_p);
      272       if db_catch
      273       then call ioa_$ioa_switch (db_output, "^/====End ted level ^i^/", i);
      274       if (hold_db_output = null ()) & (db_output ^= iox_$user_output)
      275       then do;
      276          call iox_$close (db_output, code);
      277          if ^lg_catch
      278          then do;
      279 	  call iox_$open (db_output, 2, ""b, code); /* throw away the data */
      280 	  call iox_$close (db_output, code);
      281          end;
      282          call iox_$detach_iocb (db_output, code);
      283       end;
      284       db_output = hold_db_output;
      285 
      286    end cleaner;
      287 
      288       reset = rq_err;
      289 
      290       on_quit, string_sw = "0"b;
      291       req_not = " ";
      292 
      293       if (ted_data.ted_com_l > 0)
      294       then do;
      295          call tedpseudo_ (dbase.cba_p, -1, ted_data.ted_com_p,
      296 	    ted_data.ted_com_l);
      297          dbase.cba_p -> b.ex.l.re = ted_data.ted_com_l;
      298          if db_ted
      299          then call tedshow_ (bp, ". rl* rl");
      300       end;
      301 /**** initialize b0 with the same code as all other buffers.	   #137*/
      302       rl_i = 1;			/* #137*/
      303       rl_l = 3;			/* #137*/
      304       rl_s = "b0 ";			/* #137*/
      305       goto next;			/* #137*/
      306 
      307 /* return here to process each new request line, from either a buffer or     */
      308 /*  user_input (which is not ever known to the request loop).  If there is   */
      309 /*  an error, control is returned here to cancel any unprocessed request     */
      310 /*  line.  Comes back here from "next" is there are no more requests on the  */
      311 /*  line.							       */
      312 
      313 nx_line:
      314       req_str = "";
      315 
      316       err_go = " ";
      317       rl_i = 1;
      318       if go_sw			/* goto does not turn off f req      */
      319       then goto nx_read;
      320       if fo_sw
      321       then call detach ("0"b);
      322 nx_read:
      323       if on_quit			/* is condition(quit) enabled?       */
      324       then do;
      325          if (not_read_ct < 1)		/* if there are no ^read files left  */
      326          then do;
      327 	  revert quit;		/*   get rid of the quit handler     */
      328 	  on_quit = "0"b;
      329          end;
      330       end;
      331       else do;			/* On the other hand, if no quit     */
      332          if (not_read_ct > 0)		/*  handler and there are ^read      */
      333          then do;			/*  files, get one established       */
      334 	  on condition (quit)
      335 	     begin;
      336 	        call tedset_ck_ptr_ (dbase_p);
      337 	        call continue_to_signal_ (code);
      338 	     end;
      339 	  on_quit = "1"b;
      340          end;
      341       end;
      342 kill_read_ptr:
      343       pi_label = kill_read_ptr;
      344       pi_sw = 1;
      345       which_mode = "EDIT";
      346       call tedread_ptr_ (dbase_p, dbase.rl.sp, 0, dbase.rl.r.re, rl_l,
      347 	 which_mode);
      348       pi_sw = 0;
      349       if (chars_moved >= 0)		/* count chars moved into request    */
      350       then chars_moved = chars_moved + rl_l; /* ..buffer also	       */
      351       if (which_mode = "\R\F")
      352       then goto eof_err;
      353       if (rl_l = dbase.rl.r.re) & (rl_c (dbase.rl.r.re) ^= NL)
      354       then call ioa_ ("*Request line exceeds ^i, error may follow.",
      355 	      dbase.rl.r.re);
      356       if db_Ed
      357       then hold_db_ted = db_ted; 
      358 next:
      359       if b.get_bit_count
      360 	 | b.ck_ptr_sw
      361       then do;			/* #152*/
      362          call tedcheck_buffer_state_ (dbase_p, bp, msg); /* #152*/
      363          if (b.b_.l.le > b.b_.l.re) & (b.b_.r.le < b.b_.r.re)
      364          then call demote (0);	/* #152*/
      365       end;			/* #152*/
      366       if db_Ed
      367       then db_ted = hold_db_ted;
      368       b.INPUT = ""b;		/* no INPUT in progress	   #156*/
      369       pi_passthru = "0"b;
      370       if rl_i >= rl_l		/* check after each req	       */
      371       then goto nx_line;		/*  if request line exhausted	       */
      372       rl_i
      373 	 = rl_i + verify (substr (rl_s, rl_i), " 	") - 1; /* #208*/
      374       if (rl_i >= rl_l)
      375       then goto nx_line;
      376 
      377       if (substr (rl_s, rl_i, 4) = "help") /* #207,210*/
      378       then do;
      379          if (rl_l = rl_i + 4)
      380          then do;
      381 	  if (length (dbase.err_msg) >= 4)
      382 	  then do;
      383 	     substr (rl_s, rl_i, 5) = "-msg ";
      384 	     substr (rl_s, rl_i + 5, 4) = substr (dbase.err_msg, 1, 4);
      385 	     substr (rl_s, rl_i + 9, length (err_req)) = err_req;
      386 	     rl_l = rl_l + 4 + length (err_req);
      387 	     substr (rl_s, rl_l, 1) = NL;
      388 	     rl_l = rl_l + 1;
      389 	  end;
      390          end;
      391          else substr (rl_s, rl_i, 4) = "";
      392          call tedhelp_ (substr (rl_s, rl_i));
      393 dcl tedhelp_	entry (char (*));
      394          goto nx_line;
      395       end;
      396 
      397       intsw = "0"b;			/* reset previous PI (if any)	       */
      398       if ^string_sw			/* if not in string mode	       */
      399       then do;
      400          b.a_.l.re (0) = b.a_.l.le (0); /* ignore carry-over strings	       */
      401          b.a_.r.le (0) = b.a_.r.re (0);
      402       end; 




      403       req_not, req_ch, req_chx, req_str = "";
      404       rl_b = 0;
      405       bp = ptr (dbase_p, dbase.cb_c_r);
      406       if (index ("0123456789,;+-/.$()<?\@[]", rl_c (rl_i)) = 0)
      407       then do;			/* no address chars here, fake it    */
      408 /**** don't destroy address status for option request.		       */
      409 				/* RW 88 */
      410          if (rl_c (rl_i) ^= "o")
      411          then do;
      412 	  b.present (1), b.present (2) = "0"b;
      413 	  b.a_ (1) = b.a_ (0);	/*#193*/
      414 	  goto got_add;
      415          end;
      416       end;
      417       used = rl_l - rl_i + 1;
      418       call tedaddr_ (dbase_p, addr (rl_c (rl_i)), used, bp, msg, code);
      419 				/* find address if any	       */
      420       rl_i = rl_i + used;
      421       if (code > 3)
      422       then goto print_error;
      423       if (code = 2)
      424       then do;
      425          if (err_go ^= " ")
      426          then goto print_error;
      427          goto cm_err;
      428       end;
      429       goto got_add; 





      430 /*	         various and sundry error message routines	       */
      431 
      432 dcl EOF		bit (1);
      433 eof_err:
      434       msg = "Xrf) \r read \f.";
      435 
      436 cm_err:
      437       code = ted_mode;		/* failure to match REGEXP	       */
      438       call tedend_buffer_ (dbase_p, level); /*  pop buffer stack	       */
      439       if level ^= 0			/* if already at request level       */
      440       then do;
      441          call tederror_ (dbase_p, msg);
      442          goto rq_err;		/* treat as normal error	       */
      443       end;
      444       goto nx_line;			/* resume input at next higher level */
      445 
      446 not_allowed:
      447       msg = "Xna) Not allowed on this buffer. ";
      448       goto add_request;
      449 
      450 err_Blv:
      451       msg = "Blv) Remembered >10 buffers.";
      452       goto add_request;
      453 
      454 err_Bnd:
      455       msg = "Bnd) Can't delete current or remembered buffer.";
      456       goto add_request;
      457 
      458 err_Bnr:
      459       msg = "Bnr) No buffer remembered.";
      460       goto add_request;
      461 
      462 err_Sbd:
      463       msg = "Sbd) Bad decimal digit.";
      464       goto add_request;
      465 
      466 err_Sd1:
      467       msg = "Sd1) No 1st delimiter.";
      468       goto add_request;
      469 
      470 err_Sd2:
      471       msg = "Sd2) No 2nd delimiter.";
      472       goto add_request;
      473 
      474 err_Sd3:
      475       msg = "Sd3) No 3rd delimiter.";
      476       goto add_request;
      477 
      478 err_Sje:
      479       msg = "Sje) Bad sort spec.";
      480       goto add_request;
      481 
      482 err_Sjk:
      483       msg = "Sjk) Bad key spec.";
      484       goto add_request;
      485 
      486 err_Slx:
      487       msg = "Slx) Label exceeds 16 chars.";
      488       goto add_request;
      489 
      490 err_Smp:
      491       msg = "Smp) Missing ).";
      492       goto add_request;
      493 
      494 err_Snb:
      495       msg = "Snb) No blank after ";
      496       goto add_request;
      497 
      498 err_Sne:
      499       msg = "Sne) No char for \=.";
      500       goto add_request;
      501 
      502 err_Sts:
      503       msg = "Sts) Tabstop not in 1-200.";
      504       goto add_request;
      505 
      506 err_Snf:
      507       msg = "Snf) No routine name supplied.";
      508       goto add_request;
      509 
      510 print_error_rc:
      511       call tederror_rc_ (dbase_p, msg, code);
      512       goto rq_err;
      513 
      514 syntax_error:
      515       msg = "Xse) Bad syntax for ";
      516 add_request:
      517       msg = msg || " ";
      518       msg = msg || req_str;
      519       if (rl_b > 0)
      520       then do;
      521          msg = msg || " """;
      522          msg = msg || substr (rl_s, rl_b, rl_i - rl_b + 1);
      523          msg = msg || """";
      524       end;
      525 print_error:
      526       if (rel (bp) ^= dbase.cb_c_r)	/* if working on some buffer other.. */
      527       then do;			/*   ..than the "current" one,       */
      528          msg = msg || " (in b(";	/*   ..tell them where we are.       */
      529          msg = msg || rtrim (b.name);
      530          msg = msg || "))";
      531       end;
      532 rq_err_msg:
      533       if (msg ^= "")
      534       then call tederror_ (dbase_p, msg);
      535 rq_err:
      536       err_req = req_str;
      537       if (err_go ^= " ")
      538       then do;
      539          err_gol = err_go;
      540 dcl err_gol	char (16);
      541          err_go = "";
      542          code = 0;
      543          call tedset_ptr_ (dbase_p, rtrim (err_gol), code);
      544          if (code = 0)
      545          then goto nx_line;
      546       end;
      547       call tedresetread_ (dbase_p);	/* reset buffer push down stack   */
      548 				/*  and input buffer	       */
      549       if (ted_mode = COM)
      550       then do;
      551          acode = tederror_table_$ted_com_abort;
      552 				/* call com_err_ (acode, DBA);       */
      553          call cleaner;
      554          return;
      555       end;
      556       go_sw = "0"b;
      557       b_depth = 0;
      558       goto nx_line;
      559 
      560 got_add:
      561       cb_w_r = rel (bp);		/* remember which we are working on  */
      562       if (rl_i >= rl_l)
      563       then ch = NL;
      564       else ch = rl_c (rl_i);		/* pick up first char. after address */
      565       alt_sw, not_sw = "0"b;
      566       if ch = NL
      567       then do;			/* if end of line		       */
      568          if b.present (1)		/* and "orphan" address	       */
      569          then do;			/* ...print line(s) referenced       */
      570 	  if nulreq ^= "p"		/* (chose which way)	       */
      571 	  then ch = "P";
      572 	  else ch = "p";
      573          end;
      574          else goto nx_line;		/* ...otherwise, done with line      */
      575       end;
      576       else rl_i = rl_i + 1;		/* bump request line char. index     */
      577 
      578       req_ch, req_str = ch;
      579       req_not, req_chx = "";
      580       if do_req (ch)
      581       then goto nx_line;
      582       goto next;
      583 
      584 exit:
      585       acode = 0;
      586       return;
      587 
      588 dcl (
      589     NX_LIN	init ("1"b),	/* forget rest of request line       */
      590     NX_REQ	init ("0"b)	/* continue execution on same line   */
      591     )		bit (1) int static options (constant); 
      592 do_req: proc (rqc) returns (bit (1));	/* returns 1 to abort request line   */
      593 				/*         0 to continue	       */
      594 dcl rqc		char (1);
      595 
      596 
      597       if (rqc < " ") | (rqc > "~") then goto invalid_request_octal;
      598       if ^caps
      599       then if (rqc >= "A") & (rqc <= "Z")
      600 	 then goto invalid_request;
      601       call tedshow_$init;
      602       goto cmd (rank (rqc));
      603 
      604 dcl fs_util_$suffix_info entry (char (*), char (*), ptr, fixed bin (35)); /* #--c*/
  1     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  1     2 
  1     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  1     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  1     5*
  1     6*   Jay Pattin 6/23/83 */
  1     7 
  1     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  1     9           2 names                       bit (1) unaligned,
  1    10           2 acl                         bit (1) unaligned,
  1    11           2 ring_brackets               bit (1) unaligned,
  1    12           2 max_length                  bit (1) unaligned,
  1    13           2 copy_switch                 bit (1) unaligned,
  1    14           2 safety_switch               bit (1) unaligned,
  1    15           2 dumper_switches             bit (1) unaligned,
  1    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  1    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  1    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  1    19           2 mbz                         bit (26) unaligned;
  1    20 
  1    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      605  /* #--c*/
  2     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  2     2 /* format: style3,indcomtxt,idind30 */
  2     3 /**** Jay Pattin 2/13/83
  2     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  2     5*
  2     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  2     7*
  2     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  2     9 
  2    10 declare   suffix_info_ptr               ptr;
  2    11 
  2    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  2    13             2 version                   char (8),
  2    14             2 type                      char (32) unaligned,
  2    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  2    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  2    17             2 flags                     unaligned,
  2    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  2    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  2    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  2    21               3 mbz1                    bit (33) unaligned,
  2    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  2    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  2    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  2    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  2    26             2 info_pathname             char (168) unaligned;
  2    27                                                             /* pathname of info segment containing more info */
  2    28 
  2    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  2    30 
  2    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  2    32 
  2    33 declare   switch_list_ptr               ptr,
  2    34           alloc_switch_count            fixed bin,
  2    35           alloc_switch_name_count       fixed bin;
  2    36 
  2    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  2    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  2    39             2 switch_count              fixed bin,          /* total number of switches */
  2    40             2 switch_name_count         fixed bin,          /* total number of names */
  2    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  2    42               3 name_index              fixed bin,          /* index of first name for this switch */
  2    43               3 name_count              fixed bin,          /* number of names for this switch */
  2    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  2    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  2    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  2    47 
  2    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  2    49 
  2    50 declare   (
  2    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  2    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  2    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  2    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  2    55           FS_OBJECT_TYPE_LINK           init ("-link")
  2    56           )                             char (32) unaligned int static options (constant);
  2    57 
  2    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      606  /* #--c*/
      607 dcl 1 SI		like suffix_info;	/* #--c*/
      608 dcl OC		(0:7) char (1) int static init
      609 		("0", "1", "2", "3", "4", "5", "6", "7");
      610 dcl 1 oct		based (addr (req_ch)),
      611       2 (A, B, C)	bit (3);
      612 
      613 
      614 invalid_request_octal:
      615       msg = "Xrq) Invalid request \***.";
      616       substr (msg, 23, 1) = OC (fixed (oct.A, 35));
      617       substr (msg, 24, 1) = OC (fixed (oct.B, 35));
      618       substr (msg, 25, 1) = OC (fixed (oct.C, 35));
      619       req_str = substr (msg, 24, 4);
      620       goto print_error; 


      621 /* . . . invalid requests . . */
      622 /* format: off */
      623 cmd (036):		/* $  ADDR- last line of buffer	       */
      624 cmd (038):		/* & */
      625 cmd (040):		/* (  ADDR- begin byte address	       */
      626 cmd (041):		/* )  ADDR- end byte address		       */
      627 cmd (043):		/* +  ADDR- positive relative address	       */
      628 cmd (044):		/* ,  ADDR- address separator		       */
      629 cmd (045):		/* -  ADDR- negative relative address	       */
      630 cmd (046):		/* .  ADDR- current location		       */
      631 cmd (047):		/* /  ADDR- expression delimiter	       */
      632 cmd (048):		/* 0  ADDR- linenumber/relative	       */
      633 cmd (049):		/* 1  ADDR- "			       */
      634 cmd (050):		/* 2  ADDR- "			       */
      635 cmd (051):		/* 3  ADDR- "			       */
      636 cmd (052):		/* 4  ADDR- "			       */
      637 cmd (053):		/* 5  ADDR- "			       */
      638 cmd (054):		/* 6  ADDR- "			       */
      639 cmd (055):		/* 7  ADDR- "			       */
      640 cmd (056):		/* 8  ADDR- "			       */
      641 cmd (057):		/* 9  ADDR- "			       */
      642 cmd (059):		/* ;  ADDR- address separator		       */
      643 cmd (060):		/* <  ADDR- backup search marker	       */
      644 cmd (063):		/* ?  ADDR- prefix marker		       */
      645 cmd (064):		/* @  ADDR- absolute buffer reference	       */
      646 cmd (065):		/* A */
      647 cmd (066):		/* B */
      648 cmd (067):		/* C */
      649 cmd (068):		/* D */
      650 cmd (071):		/* G */
      651 cmd (073):		/* I */
      652 cmd (078):		/* N */
      653 cmd (079):		/* O */
      654 cmd (086):		/* V */
      655 cmd (089):		/* Y */
      656 cmd (090):		/* Z */
      657 cmd (091):		/* [  ADDR- range on search		       */
      658 cmd (092):		/* \ */
      659 cmd (093):		/* ]  ADDR- range on search		       */
      660 cmd (095):		/* _ */
      661 cmd (096):		/* ` */
      662 cmd (125):		/* }  closing mark of evaluaton	       */
      663 invalid_request:;			/* format: on */
      664       msg = "Xrq) Invalid request ";
      665       msg = msg || req_str;
      666       goto print_error; 






      667 /* . . . call	: call specified buffer making parameters available      */
      668 
      669 cmd (037):			/* % */
      670       call ignore_both;
      671       call tedcall_ (dbase_p, code);
      672       if (code ^= 0)
      673       then goto rq_err;
      674       return (NX_LIN); 
      675 /* . . . read 	: read in specified file after addressed line in buffer  */
      676 
      677 abbrev: proc (ck_sw);
      678 dcl ck_sw		bit (1) aligned;
      679 
      680       if ck_sw then call ck_blank;
      681       begin;
      682 dcl hold		char (500);
      683 dcl it		fixed bin (21);
      684 dcl abbrev_$expanded_line entry (ptr, fixed bin (21), ptr, fixed bin (21), ptr,
      685 		fixed bin (21));
      686 
      687          i = rl_l - rl_i + 1;
      688          substr (hold, 1, i) = substr (rl_s, rl_i, i);
      689          call abbrev_$expanded_line (addr (hold), i, dbase.rl.sp, 512, tbp,
      690 	    it);
      691          if (tbp ^= dbase.rl.sp)
      692          then do;
      693 	  msg = "Iab) Abbrev result >512.";
      694 	  goto print_error;
      695          end;
      696          rl_i = 1;
      697          if (substr (rl_s, it, 1) ^= NL)
      698          then do;
      699 	  it = it + 1;
      700 	  substr (rl_s, it, 1) = NL;
      701          end;
      702          rl_l = it;
      703       end;			/* begin block */
      704    end abbrev;
      705 
      706 cmd (082):			/* R */
      707       call abbrev (com1_blank);
      708       if ""b
      709       then do;
      710 cmd (114):			/* r */
      711          if alt_sw
      712          then call abbrev ("1"b);
      713          else if com1_blank
      714          then call ck_blank;
      715       end;
      716       if ^b.present (1)		/* if no address given,	       */
      717       then b.a_.l.re (1), b.a_.r.le (1) = b.b_.r.re; /*  add to EOB window */
      718       else b.a_.l.re (1) = max (0, b.a_.r.le (1));
      719       call ignore_2;
      720       string (b.bs) = "0"b;		/* reset old-style escape seen       */
      721       if (b.cur.sn ^= 0)		/* if buffer not empty	       */
      722       then trustsw = "0"b;		/* ... then can't trust name	       */
      723       else trustsw = "1"b;		/* ... else can		       */
      724       wsw = "0"b;
      725       write_l = 0;
      726       if ^b.no_io
      727       then goto get_file;
      728       if (b.cur.sn ^= 0)		/* if buffer not empty	       */
      729       then goto not_allowed;		/* ..too bad		       */
      730       call get_the_string;
      731       return (NX_LIN); 
      732 /* . . . write 	: write out specified contents of buffer into a file     */
      733 
      734 cmd (087):			/* W */
      735       call abbrev ("1"b);
      736 cmd (119):			/* w */
      737       if alt_sw
      738       then call abbrev ("1"b);
      739       else if com1_blank
      740       then do;			/* optional writes		       */
      741          if (rl_c (rl_i) = "m")
      742          then do;			/* write-modified request	       */
      743 	  req_chx = "m";
      744 	  req_str = req_str || "m";
      745 	  rl_i = rl_i + 1;
      746          end;
      747          call ck_blank;
      748          if (req_chx = "m")
      749          then do;
      750 	  tbi = 2;
      751 	  call ignore_all;		/* tell 'em we won't take addr's     */
      752 	  b.present (1), b.present (2) = "1"b; /* make sure none there     */
      753 	  trustsw = "1"b;
      754 	  wct = 0;
      755 	  pi_label = write_loop_pi;
      756 	  pi_sw = 1;
      757 	  goto write_loop;
      758 write_loop_error:
      759 	  call ioa_ ("In b(^a)^/^a", b.name, substr (msg, 6));
      760 write_loop:
      761 	  tbi = tbi + 1;
      762 	  if (tbi > bufnum)
      763 	  then do;
      764 write_loop_pi:
      765 	     if (wct = 0)
      766 	     then call ioa_ ("No buffers written.");
      767 	     return (NX_REQ);
      768 	  end;
      769 	  bp = addr (CB (tbi));
      770 	  if (b.cur.sn = 0) | b.no_io
      771 	  then goto write_loop;
      772 	  if ((b.b_.l.re - b.b_.l.le + 1) + (b.b_.r.re - b.b_.r.le + 1) = 0)
      773 	  then goto write_loop;	/* no data		       */
      774 	  b.a_.l.re (1) = 1;	/* write whole buffer	       */
      775 	  b.a_.r.le (2) = b.maxl;
      776 	  svlen = 0;
      777 	  msg = "";
      778 	  mustreprotect = "0"b;
      779          end;
      780       end;
      781       if b.no_io
      782       then goto not_allowed;
      783       if b.present (1) & ^b.present (2)
      784 	 & (b.a_.l.re (1) = 1) & (b.a_.r.le (1) = 0)
      785       then write_l = 0;
      786       else do;
      787          if ^b.present (1)		/* default is whole buffer	       */
      788          then do;			/* ..regardless of window	       */
      789 	  if (b.cur.sn = 0)
      790 	  then do;
      791 	     msg = "Abe) Buffer empty.";
      792 	     goto print_error;
      793 	  end;
      794 	  b.a_.l.le (1), b.a_.l.re (1) = 1;
      795 	  b.a_.r.le (2), b.a_.r.re (2) = b.maxl;
      796 	  b.present (1), b.present (2) = "1"b;
      797          end;
      798          else call default$whole_buffer;
      799          call addr_status_ends (1, b.maxl);
      800          if (b.a_.l.re (1) ^= b_lhe) | (b.a_.r.le (2) ^= b_rhe)
      801          then trustsw = "0"b;		/* not writing whole thing	       */
      802          else trustsw = "1"b;
      803          write_l = b.a_.r.le (2) - b.a_.l.re (1) + 1;
      804          if (b_stat = B_LO_HI)	/* if range spans the hole, take out */
      805          then write_l = write_l - (b.b_.r.le - b.b_.l.re - 1); /* its size  */
      806       end;
      807       wsw = "1"b;
      808       if (req_chx ^= "m")
      809       then do;
      810 get_file:
      811          subfile_name = "%%%%%";	/* to catch uninitilized uses	       */
      812          msg = "";
      813          rl_i = rl_i + verify (substr (rl_s, rl_i), " ") - 1;
      814          if (rl_c (rl_i) = "(")	/* its a buffer read or write	       */
      815          then do;
      816 	  if wsw			/* w (x) is same as m (x) with..     */
      817 	  then goto mo3;		/*   ..different defaults	       */
      818 	  goto read_buffer;
      819          end;
      820          if b.no_io
      821          then goto not_allowed;
      822          mustreprotect = "0"b;
      823          svlen = rl_l - rl_i;		/* calc length of pathname	       */
      824       end;
      825       fd = b.file_d;		/* pull the remembered file data     */
      826       if (svlen = 0)		/* if no pathname supplied	       */
      827       then do;
      828          if ^fd.file_sw		/* ...do we have one saved?	       */
      829          then do;			/*  NO			       */
      830 	  if (req_chx = "m")
      831 	  then goto write_loop;
      832 	  msg = "Inp) No pathname given.";
      833 	  goto print_error;
      834          end;
      835          if ^fd.trust_sw		/* can we trust pathname?	       */
      836          then do;
      837 	  if (ted_mode ^= COM)
      838 	  then do;
      839 	     query_info.status_code = 0;
      840 	     call command_query_ (addr (query_info), answer, DBA,
      841 		"Do you want to ^a with the untrusted pathname ^a>^a^a^a?",
      842 		req_str, fd.dname, fd.ename, fd.kind, fd.cname);
      843 	     if (substr (answer, 1, 1) = "y")
      844 	     then do;
      845 	        fd.trust_sw = "1"b;	/* looks OK from here	       */
      846 	        if not_sw
      847 	        then trustsw = "1"b;
      848 	        goto accept_name;	/* (may look different there)	       */
      849 	     end;
      850 	  end;
      851 	  msg = "Int) Can't trust saved pathname ";
      852 	  call msg_path (fd.kind);
      853 	  if (req_chx = "m")
      854 	  then goto write_loop_error;
      855 	  if (ted_mode = COM)
      856 	  then goto print_error;
      857 	  return (NX_LIN);
      858          end;
      859 accept_name:
      860          if not_sw			/* we must force this name	       */
      861          then do;
      862 	  fd.trust_sw = "1"b;	/* ...remember the fact	       */
      863 	  fd.file_sw = "1"b;	/* ...and indicated that it is saved */
      864 	  fd.force_name = "1"b;
      865 	  b.file_d = fd;
      866 	  return (NX_LIN);
      867          end;
      868          if ^trustsw		/* if we can't trust pathname after  */
      869          then fd.trust_sw = "0"b;	/* ...this, remember the fact	       */
      870          else do;
      871 	  if ^fd.mod_sw & wsw	/* Don't write unmodified buffer     */
      872 	       & (req_chx = "m")	/*  if wm			       */
      873 	  then goto write_loop;
      874          end;
      875       end;			/*  (using remembered name)	       */
      876 
      877       else do;			/* process the supplied pathname     */
      878          if b.force_name & not_sw	/* don't let her change a	       */
      879          then do;			/* ..forced name		   #129*/
      880 	  msg = "Ifp) Cannot change forced pathname.";
      881 	  call msg_path (b.kind);
      882 	  goto print_error;
      883          end;
      884          svpath = substr (rl_s, rl_i, svlen);
      885          fd.kind = "";
      886          if ^qedx_mode
      887          then do;
      888 	  enl = search (reverse (svpath), "<>");
      889 	  if (enl = 0)
      890 	  then enl = 1;
      891 	  else enl = length (svpath) + 2 - enl; /* #157*/
      892 	  i = index (substr (svpath, enl + 1), "|");
      893 	  if (i ^= 0)
      894 	  then do;
      895 	     i = enl + i - 1;
      896 	     fd.kind = "|";
      897 	     subfile_name = substr (svpath, i + 2, svlen - i - 1);
      898 	     svpath = substr (svpath, 1, i);
      899 	     if (svlen - i > 32)
      900 	     then do;
      901 	        msg = "Isn) Subfile name too long. ";
      902 	        msg = msg || rtrim (svpath);
      903 	        call tederror_ (dbase_p, msg);
      904 	        goto rq_err;
      905 	     end;
      906 	     svlen = i;
      907 	  end;
      908          end;
      909          if (substr (svpath, 1, 4) = "[pd]")
      910          then do;
      911 	  if (pdname = " ")
      912 	  then pdname = get_pdir_ ();
      913 	  svpath = pdname || substr (svpath, 5, svlen - 4);
      914 	  svlen = svlen + 28;
      915          end;
      916          call expand_pathname_$component (svpath, fd.dname, fd.ename, fd.cname,
      917 	    code);
      918          if (code ^= 0)
      919          then do;
      920 bad_path:
      921 	  msg = rtrim (svpath);
      922 	  goto print_error_rc;
      923          end;
      924          if (fd.kind = "|")
      925          then fd.cname = subfile_name;
      926          else if (fd.cname ^= "")
      927          then fd.kind = ":";
      928          if trustsw | not_sw		/* if we can trust this pathname     */
      929          then do;
      930 	  fd.trust_sw = "1"b;	/* ...remember the fact	       */
      931 	  fd.file_sw = "1"b;	/* ...and indicated that it is saved */
      932 	  fd.force_name = not_sw;
      933 	  if not_sw		/* only remembering?	       */
      934 	  then do;
      935 	     b.file_d = fd;
      936 	     return (NX_LIN);
      937 	  end;
      938          end;
      939          else fd.trust_sw = "0"b;	/* ...mis-trust it		       */
      940       end;
      941 
      942       SI.version = SUFFIX_INFO_VERSION_1; /* #--c*/
      943       call fs_util_$suffix_info (fd.dname, fd.ename, addr (SI), code); /* #--c*/
      944       if (code ^= 0)
      945       then do;			/* #--c*/
      946 				/* RW 88 */
      947          if (code = error_table_$unsupported_operation) then do; /* #191*/
      948 				/* try to get more information about the problem...    /* #191*/
      949 	  call hcs_$status_minf (fd.dname, fd.ename, 1, 0, 0, code); /* #191*/
      950 				/* no error: stick with the unsupported op message     /* #191*/
      951 				/* otherwise use the new error code, whatever it is    /* #191*/
      952 	  if (code = 0) then	/* #191*/
      953 	       code = error_table_$unsupported_operation; /* #191*/
      954          end;			/* #191*/
      955          if (code = error_table_$noentry) & wsw
      956          then goto make_one;		/* #--c*/
      957          goto get_err;		/* #--c*/
      958       end;			/* #--c*/
      959       if (SI.type_name ^= "segment")
      960       then do;			/* #--c*/
      961          msg = "Ims) Can't process ";	/* #--c*/
      962          msg = msg || SI.type_name;	/* #--c*/
      963          call msg_path (fd.kind);	/* #--c*/
      964          if (req_chx = "m")
      965          then goto write_loop_error;	/* #--c*/
      966          goto print_error;		/* #--c*/
      967       end;			/* #--c*/
      968 
      969 
      970       call hcs_$initiate_count (fd.dname, fd.ename, "", bc, 0, file_p, code);
      971       if (file_p = null)
      972       then do;
      973          if ^wsw
      974          then goto get_err;
      975          if (fd.kind = ":")
      976          then do;
      977 no_ac_write:
      978 	  if (req_chx = "m")
      979 	  then do;
      980 	     msg = "Xwa) Can't write to an archive. ";
      981 	     call msg_path (fd.kind);
      982 	     goto write_loop_error;
      983 	  end;
      984 	  call com_err_ (0, DBA, "Can't write to an archive. ^a>^a::^a",
      985 	       fd.dname, fd.ename, fd.cname);
      986 	  goto rq_err;
      987          end;
      988 make_one:				/* #--c*/
      989          call tedcheck_entryname_ (fd.ename, code);
      990          if (code ^= 0)
      991          then goto bad_path;
      992 				/* try to create segment	       */
      993          call hcs_$make_seg (fd.dname, fd.ename, "", 01011b, file_p, code);
      994          if (file_p = null)
      995          then do;
      996 get_err:
      997 	  if trustsw & ^wsw
      998 	       & ^b.force_name	/* #129*/
      999 	  then b.file_d = fd;
     1000 	  call msg_path (fd.kind);
     1001 	  call tederror_rc_ (dbase_p, msg, code);
     1002 	  if (req_chx = "m")
     1003 	  then goto write_loop;
     1004 	  goto rq_err;
     1005          end;
     1006          bc = 0;
     1007       end;
     1008 
     1009 dcl real_dname	char (168);
     1010 dcl real_ename	char (32);
     1011 
     1012       call hcs_$fs_get_path_name (file_p, real_dname, 0, real_ename, code);
     1013       call hcs_$status_long (real_dname, real_ename, 1, addr (branch_status),
     1014 	 null, code);
     1015       if (branch_status.mode & "01000"b) ^= "01000"b
     1016       then do;			/* #153*/
     1017          code = error_table_$insufficient_access; /* #153*/
     1018          msg = "";			/* #153*/
     1019          goto get_err;		/* #153*/
     1020       end;			/* #153*/
     1021       file_l = divide (bc, 9, 21, 0);
     1022       if wsw			/* check for WRITE-protected file    */
     1023       then do;
     1024          if (fd.kind = ":")
     1025          then goto no_ac_write;
     1026          if b.pseudo		/* is this a ^read file?	       */
     1027          then call promote (b.maxl);	/*    materialize it	       */
     1028          if (branch_status.mode & "00010"b) ^= "00010"b
     1029          then do;			/* if segment has no w access	       */
     1030 	  query_info.status_code = error_table_$moderr;
     1031 	  call command_query_ (addr (query_info), answer, DBA,
     1032 	       "Do you want to write to the protected ^[file^]^[archive^]"
     1033 	       || "^[subfile^] ^a>^a^a^a?",
     1034 	       (fd.kind = " "), (fd.kind = ":"), (fd.kind = "|"),
     1035 	       fd.dname, fd.ename, fd.kind, fd.cname);
     1036 	  if (substr (answer, 1, 1) = "n")
     1037 	  then do;
     1038 	     if (req_chx = "m")
     1039 	     then goto write_loop;
     1040 	     return (NX_LIN);
     1041 	  end;
     1042 	  seg_acl.userid = get_group_id_ (); /* wants to update	       */
     1043 	  seg_acl.access = "1010"b;	/* give user rw		       */
     1044 	  seg_acl.ex_access = "0"b;
     1045 	  call hcs_$add_acl_entries (fd.dname, fd.ename, addr (seg_acl), 1,
     1046 	       code);
     1047 	  if (code ^= 0)
     1048 	  then do;
     1049 	     msg = "(add_acl) ";
     1050 	     goto get_err;
     1051 	  end;
     1052 	  mustreprotect = "1"b;
     1053          end;
     1054          bc = write_l * 9;		/* length of data to be written      */
     1055       end;
     1056 
     1057       if (fd.kind = ":")		/* processing an archive	       */
     1058       then goto find_archive_element;
     1059       if (fd.kind = "|")		/* processing a superfile	       */
     1060       then goto find_subfile;
     1061 
     1062       if wsw & (write_l = 0)
     1063       then do;
     1064          sub_type = " subfile ";
     1065 x_not_found:
     1066          msg = "";
     1067          call msg_path ((sub_type));
     1068 				/* RW 88 */
     1069          if (sub_type = " component ") then /*#201*/
     1070 	    call tederror_rc_ (dbase_p, msg, (error_table_$no_component)); /*#201*/
     1071          else			/*#201*/
     1072 	    call tederror_rc_ (dbase_p, msg, (error_table_$noentry));
     1073          call reprotect;		/* put things back, if necessary     */
     1074          if (req_chx = "m")
     1075          then goto write_loop;
     1076          goto rq_err;
     1077       end;
     1078 
     1079 file_ready:
     1080       if ^wsw
     1081       then goto read_file;
     1082       if (b_stat = B_LO_HI)		/* range is split, move high part    */
     1083       then do;			/*   into file first	       */
     1084          i = b.a_.r.le (2) - b.b_.r.le + 1;
     1085          call mrl_ (addr (b_c (b.b_.r.le)), i,
     1086 	    addr (file_c (write_l - i + 1)), i);
     1087          b.a_.r.le (2) = b.b_.l.re;	/* adjust to look like unsplit       */
     1088       end;
     1089 				/* here always looks like unsplit    */
     1090       i = b.a_.r.le (2) - b.a_.l.re (1) + 1;
     1091 /***** MRL is used to get bounds faults over with ASAP		       */
     1092       call mrl_ (addr (b_c (b.a_.l.re (1))), i, file_p, i);
     1093       if trustsw
     1094       then do;			/* #129*/
     1095          fd.not_pasted = "0"b;	/* #129*/
     1096 /****    clear mod_sw if the buffer is not "locked"		   #129*/
     1097 /****    or the default pathname is being used			   #129*/
     1098          if ^b.force_name | (svlen = 0) /* #129*/
     1099          then b.mod_sw, fd.mod_sw, fd.not_pasted = "0"b; /* #129*/
     1100       end;			/* #129*/
     1101       b.trust_sw = trustsw;
     1102 close_up_file:
     1103       if b.force_name
     1104       then b.trust_sw = "1"b;		/* #129*/
     1105       else if trustsw
     1106       then b.file_d = fd;
     1107       call terminate_file_ (file_p, (bc), TERM_FILE_TRUNC_BC_TERM, code);
     1108       if code ^= 0
     1109       then do;
     1110          msg = "(truncate) ";
     1111          goto get_err;
     1112       end;
     1113       call reprotect;
     1114       if (req_chx = "m")
     1115       then do;
     1116          wct = wct + 1;
     1117          if (wct = 1)
     1118          then call ioa_ ("Buffers written:");
     1119          call ioa_ ("  (^a)	^a>^a^a^a", b.name, b.dname, b.ename, b.kind,
     1120 	    b.cname);
     1121          goto write_loop;
     1122       end;
     1123       return (NX_LIN); 



     1124 reprotect: proc;
     1125       if mustreprotect		/* restore ACL to original state     */
     1126       then do;
     1127          delete_acl.userid = seg_acl.userid; /* delete ACL		       */
     1128          call hcs_$delete_acl_entries (fd.dname, fd.ename,
     1129 	    addr (delete_acl), 1, code);
     1130          if code ^= 0
     1131          then do;
     1132 	  msg = "(delete_acl) ";
     1133 	  goto get_err;
     1134          end;
     1135       end;
     1136    end reprotect; 



     1137 read_buffer:
     1138       b.cd.r.re = b.a_.r.le (1) + 1;	/* set destination point	       */
     1139       used = rl_l - rl_i + 1;
     1140       call tedget_existing_buffer_ (dbase_p, addr (rl_c (rl_i)),
     1141 	 used, tbp, msg);
     1142       rl_l = rl_l + used;
     1143       if (tbp = null)
     1144       then goto rq_err_msg;
     1145       if (tbp -> b.cur.sn = 0)
     1146       then do;
     1147          msg = "b(";
     1148          msg = msg || rtrim (tbp -> b.name);
     1149          msg = msg || ")";
     1150          call tederror_rc_ (dbase_p, msg, tederror_table_$zero_length_buffer);
     1151          goto rq_err;
     1152       end;
     1153       tbp -> b.cd.l.re = tbp -> b.a_.l.re (1); /* set source range	       */
     1154       tbp -> b.cd.r.le = tbp -> b.a_.r.le (2);
     1155 				/*  //			       */
     1156       b.a_.l.ln (1) = -1;		/* <<----------		       */
     1157 				/*  \\			       */
     1158       call buffer_buffer_copy (tbp, bp, "1"b); /* Add to right end for the */
     1159 				/*  same reason that files are added */
     1160 				/*  that way.		       */
     1161       b.a_.r.le (2) = b.a_.r.le (1) - 1;/*  [bbc set rle(1) for us]	       */
     1162       if (b.a_.r.le (2) < 1)		/* buffer was empty		       */
     1163       then b.a_.r.le (2) = b.b_.r.re;	/* ..so take end of data	       */
     1164       call iso_line;
     1165       return (NX_LIN); 
     1166 read_file:
     1167       if trustsw & ^b.force_name
     1168       then b.file_d = fd;
     1169       else b.trust_sw = b.force_name;
     1170       if (file_l = 0)
     1171       then do;
     1172          msg = "";
     1173          call msg_path (" ");
     1174          call tederror_rc_ (dbase_p, msg, (error_table_$zero_length_seg));
     1175          if (req_chx = "m")
     1176          then goto write_loop;
     1177          return (NX_LIN);
     1178       end;
     1179       if (b.cur.sp = null ())		/* if buffer empty		       */
     1180       then do;
     1181          b.dtcm = branch_status.date_time_modified;
     1182          b.uid = branch_status.unique_id;
     1183       end;
     1184 
     1185       b.newa = tedcommon_$no_data;
     1186       if ^read_sw			/* if ^read is in effect	       */
     1187 	 & (b.cur.sn = 0)		/* ..and buffer is empty	       */
     1188       then do;			/* just -> the data		       */
     1189          call tedpseudo_ (bp, -1, file_p, file_l);
     1190          b.terminate = "1"b;
     1191          dbase.not_read_ct = dbase.not_read_ct + 1;
     1192          b.initiate = "0"b;
     1193          b.ck_ptr_sw = "0"b;
     1194          b.a_.r.le (2) = b.b_.l.re;
     1195          call iso_line;
     1196          return (NX_LIN);
     1197       end;
     1198       else do;
     1199 /**** Various conditions:	(AAAA is addressed string)		       */
     1200 /**** xxxxxxxxxxAAAAxxxxxx..........zzzzzzzzzz	openup		       */
     1201 /**** xxxxxxxxxx..........AAAAxxxxxxzzzzzzzzzz	add(RIGHT)	       */
     1202 /**** xxxxxxxxxx......ffffAAAAxxxxxxzzzzzzzzzz	iso_line		       */
     1203 /**** xxxxxxxxxx......zzzzzzzzzzzzzzzzzzzzzzzz			       */
     1204 
     1205 /**** ........................................	openup		       */
     1206 /**** ........................................	add(RIGHT)	       */
     1207 /**** ....................................ffff	iso_line		       */
     1208 /**** ....................................zzzz			       */
     1209 
     1210 
     1211          if (b.cur.sn = 0)		/* if buffer is empty	       */
     1212 	    & ^b.force_name		/* ..and not "locked"	   #129*/
     1213          then fd.mod_sw = "0"b;	/* ..it is not modified by reading   */
     1214          else fd.mod_sw = "1"b;	/* ..otherwise it is.	       */
     1215          b.a_.l.re (1) = b.a_.l.re (1) + 1;
     1216          call openup;		/* move hole to where we need it     */
     1217          call add_2r (ted_safe, file_p, file_l, NLct_unknown);
     1218 				/* copy in specified file	       */
     1219          b.mod_sw = fd.mod_sw;	/* add doesn't really know	       */
     1220          b.a_.r.le (2) = b.b_.r.le + file_l - 1;
     1221          call iso_line;
     1222          call hcs_$terminate_noname (file_p, code); /* don't be sloppy!      */
     1223          if (req_chx = "m")
     1224          then goto write_loop;
     1225          return (NX_LIN);
     1226       end; 
     1227 find_archive_element:
     1228       call archive_$get_component (file_p, (bc), fd.cname, ttp, bc, code);
     1229       if (code ^= 0)
     1230       then do;
     1231          sub_type = " component ";
     1232          goto x_not_found;
     1233       end;
     1234       file_p = ttp;			/* -> component		       */
     1235       file_l = divide (bc, 9, 21, 0);
     1236       goto file_ready; 



     1237 find_subfile:			/* bc already contains size of data  */
     1238       subfile_name = rtrim (fd.cname);	/* .. to be written		       */
     1239       header_l = length (subfile_name) + 7;
     1240       bc = bc + file_l * 9;		/* add in length of existing segment */
     1241       if (file_l = 0)		/* no segment was found,	       */
     1242       then do;			/* ..initialize brand new superfile  */
     1243          substr (file_s, 1, length (superfile)) = superfile;
     1244          file_l = length (superfile);
     1245          bc = bc + file_l * 9;	/* add in length of segment header   */
     1246          after_l = 0;		/* nothing after component	       */
     1247 				/* (since its not there)	       */
     1248       end;
     1249       else do;			/* the file already exists	       */
     1250          xfi = index (file_s, subf1 || subfile_name || subf2);
     1251          if (xfi ^= 0)		/* found the subfile	       */
     1252          then do;
     1253 				/* look for end of subfile	       */
     1254 	  xfe = index (substr (file_s, xfi + 1), subf1);
     1255 	  if (xfe = 0)
     1256 	  then xfe = file_l - xfi + 1;
     1257 	  after_l = file_l - xfi - xfe + 1; /* ...after  this	       */
     1258 	  file_l = xfe - header_l;	/* length of subfile	       */
     1259 	  file_p = addr (file_c (xfi + header_l)); /* -> data	       */
     1260 	  if ^wsw
     1261 	  then do;
     1262 	     if db_ted
     1263 	     then call ioa_$ioa_switch (db_output,
     1264 		     "^10p wl=^i fl=^i al=^i bc=^i",
     1265 		     file_p, write_l, file_l, after_l, bc);
     1266 	     goto read_file;
     1267 	  end;
     1268 	  bc = bc - file_l * 9;	/* remove length of data being       */
     1269 				/* ..replaced		       */
     1270          end;
     1271          else after_l = 0;		/* subfile NOT FOUND	       */
     1272       end;
     1273 
     1274       if (write_l ^= 0)		/* writing a subfile	       */
     1275       then do;
     1276          if (after_l = 0)
     1277          then do;			/* new subfile, must create header   */
     1278 	  file_p = addr (file_c (file_l + 1)); /* ..at the end	       */
     1279 	  substr (file_s, 1, 4) = subf1;
     1280 	  substr (file_s, 5, length (subfile_name)) = subfile_name;
     1281 	  substr (file_s, length (subfile_name) + 5, 3) = subf2;
     1282 	  file_p = addr (file_c (header_l + 1));
     1283 	  file_l = write_l;
     1284 	  bc = bc + header_l * 9;	/* add in length of new header       */
     1285          end;
     1286 				/* move past the header	       */
     1287          if db_ted
     1288          then call ioa_$ioa_switch (db_output, "^10p wl=^i fl=^i al=^i bc=^i",
     1289 	         file_p, write_l, file_l, after_l, bc);
     1290          if (after_l > 0)
     1291          then do;
     1292 	  if (file_l > write_l)	/* more found than being written,    */
     1293 	  then do;		/* ..close up hole in file	       */
     1294 (nostringrange):
     1295 	     substr (file_s, write_l + 1, after_l)
     1296 		= substr (file_s, file_l + 1, after_l);
     1297 	  end;
     1298 	  else if (file_l < write_l)	/* less found than being written,    */
     1299 	  then do;		/* ..open up hole in file	       */
     1300 	     call mrl_ (addr (file_c (file_l + 1)), after_l,
     1301 		addr (file_c (write_l + 1)), after_l);
     1302 	  end;
     1303          end;
     1304          goto file_ready;
     1305       end;
     1306 				/* deleting a subfile	       */
     1307       if (after_l > 0)
     1308       then do;			/* move the following data down      */
     1309 (nostringrange):
     1310          substr (file_s, 1, after_l) = substr (file_s, file_l + 1, after_l);
     1311       end;
     1312       goto close_up_file; 
     1313 /* . . .  request 	: clean up and exit from ted editor (i.e., return to     */
     1314 /*		  caller)					       */
     1315 
     1316 cmd (113):			/* q */
     1317       if ^alt_sw & (substr (rl_s, rl_i, 1) = "f") /* #160*/
     1318       then do;			/* #160*/
     1319          rl_i = rl_i + 1;		/* #160*/
     1320          goto cmd (081);
     1321       end;
     1322       if ^alt_sw & (substr (rl_s, rl_i, 5) = "hold
     1323 ")
     1324       then do;
     1325          if ted_safe
     1326          then do;
     1327 	  do tbi = 3 to bufnum;
     1328 	     bp = addr (CB (tbi));
     1329 	     if (b.cur.sn > 2) & ^b.pseudo
     1330 	     then call promote$seg;	/* clean up garbage'ed words	       */
     1331 	  end;
     1332 	  call tedhold_ (dbase_p);
     1333 	  goto exit;
     1334          end;
     1335          msg = "Xns) Not in -safe mode";
     1336          goto print_error;
     1337       end;
     1338    /*** special syntax checks for quit request			   #160*/
     1339       if (b.present (1))
     1340       then goto syntax_error;		/* #160*/
     1341       if (rl_c (rl_i) ^= NL)
     1342       then do;			/* #160*/
     1343          rl_i = rl_i + verify (substr (rl_s, rl_i), SP_HT) - 1; /* #160*/
     1344          if (rl_c (rl_i) ^= NL)
     1345          then goto syntax_error;	/* #160*/
     1346       end;			/* #160*/
     1347       if ^alt_sw
     1348 /****            & ^qedx_mode					   #159*/
     1349       then do;
     1350 /**** really need to search for b0 since it could have been deleted	       */
     1351          save_mod = b0_bp -> b.mod_sw;
     1352          if (ted_data.input_p ^= null ())
     1353          then b0_bp -> b.mod_sw = "0"b;
     1354          call tedcheck_buffers_ (dbase_p, wct);
     1355          b0_bp -> b.mod_sw = save_mod;
     1356          if (wct ^= 0)
     1357          then do;
     1358 	  query_info.status_code = 0;
     1359 	  call command_query_ (addr (query_info), answer, DBA,
     1360 	       "Do you still wish to quit?");
     1361 	  if (substr (answer, 1, 1) = "n")
     1362 	  then return (NX_LIN);
     1363          end;
     1364       end;
     1365 cmd (081):			/* Q */
     1366    /*** special syntax checks for quit request			   #160*/
     1367       if (b.present (1))
     1368       then goto syntax_error;		/* #160*/
     1369       if (rl_c (rl_i) ^= NL)
     1370       then do;			/* #160*/
     1371          rl_i = rl_i + verify (substr (rl_s, rl_i), SP_HT) - 1; /* #160*/
     1372          if (rl_c (rl_i) ^= NL)
     1373          then goto syntax_error;	/* #160*/
     1374       end;			/* #160*/
     1375       bp = af_bp;
     1376       if (bp ^= null ())
     1377       then do;
     1378          af_value = "";
     1379          call addr_status_ends_set (1, b.maxl);
     1380          if (b_stat ^= B_MT)
     1381          then do;
     1382 	  if (b_stat ^= B_HI_HI)	/* range is split, add low part     */
     1383 	  then do;		/* ..in first		       */
     1384 	     af_value = af_value || substr (b_s, 1, b.b_.l.re);
     1385 	     if (b_stat = B_LO_HI)
     1386 	     then b_stat = B_HI_HI;
     1387 	  end;
     1388 	  if (b_stat ^= B_LO_LO)
     1389 	  then do;
     1390 	     af_value = af_value
     1391 		|| substr (b_s, b.b_.r.le, b.maxl - b.b_.r.le + 1);
     1392 	  end;
     1393          end;
     1394       end;
     1395       if (ted_data.input_p ^= null ())
     1396       then do;
     1397          bp = b0_bp;
     1398 /**** b0_bp approach wrong because b0 could be deleted and then some other   */
     1399 /****  buffer use its slot, while b0 gets regenerated somewhere else.	       */
     1400          call addr_status_ends_set (1, b.maxl);
     1401          if (b_stat ^= B_MT)
     1402          then do;
     1403 	  write_l = (b.b_.l.re - b.b_.l.le + 1)
     1404 	       + (b.b_.r.re - b.b_.r.le + 1);
     1405 	  if (ted_data.output_p ^= null ()) /* an output segment supplied  */
     1406 	  then do;
     1407 	     ted_data.output_l = write_l;
     1408 	     tbp = ted_data.output_p;
     1409 	     b.mod_sw = "1"b;	/* force it modified	       */
     1410 	  end;
     1411 	  else if b.mod_sw		/* don't replace input segment       */
     1412 	  then do;		/* ..unless it's changed	       */
     1413 	     ted_data.input_l = write_l;
     1414 	     tbp = ted_data.input_p;
     1415 	  end;
     1416 	  if b.mod_sw
     1417 	  then do;
     1418 	     if (b_stat = B_LO_HI)	/* range is split, move high part    */
     1419 	     then do;		/*   into segment first	       */
     1420 	        i = b.a_.r.le (2) - b.b_.r.le + 1;
     1421 	        call mrl_ (addr (b_c (b.b_.r.le)), i,
     1422 		   addr (tbp -> file_c (write_l - i + 1)), i);
     1423 	        b.a_.r.le (2) = b.b_.l.re; /* adjust to look unsplit      */
     1424 	     end;
     1425 				/* here always looks like unsplit    */
     1426 	     i = b.a_.r.le (2) - b.a_.l.re (1) + 1;
     1427 /***** MRL is used to get bounds faults over with ASAP		       */
     1428 	     call mrl_ (addr (b_c (b.a_.l.re (1))), i, tbp, i);
     1429 	  end;
     1430          end;
     1431       end;
     1432       call cleaner;
     1433       goto exit;			/* and return to caller of ted       */
     1434 
     1435 /* . . . line-feed	:					       */
     1436 
     1437 cmd (076):			/* L */
     1438       ttp = iox_$error_output;
     1439       goto line_feed;
     1440 cmd (108):			/* l */
     1441       if alt_sw
     1442       then ttp = iox_$error_output;
     1443       else ttp = iox_$user_output;
     1444 line_feed:
     1445       if com_blank then call ck_blank;
     1446       call ignore_all;
     1447       call iox_$put_chars (ttp, addr (NL), 1, 0);
     1448       return (NX_REQ);




     1449 
     1450 /* . . . print	: print out specified portion of current buffer file on  */
     1451 /*		  user's console				       */
     1452 
     1453 cmd (112):			/* p */
     1454       if com_blank then call ck_blank;
     1455       call default$cur_line;
     1456       if alt_sw then goto PRINTb;
     1457       call print;
     1458       call iso_line;		/* set "." to last line printed   */
     1459       return (NX_REQ); 




     1460 /* . . . delete 	: delete specified lines from current buffer	       */
     1461 
     1462 cmd (100):			/* d */
     1463       if com1_blank then call ck_blank;
     1464       call default$cur_line_extend;
     1465       call delete;			/* what about when last char?	       */
     1466       call iso_line;
     1467       return (NX_REQ); 
     1468 /* . . . append	: after addressed line			       */
     1469 /****	      b.a_.l.re(1)    b.a_.r.le (1)			       */
     1470 /**** Addr:    	       |    |				       */
     1471 /****		xxxxxxxAAAAAAxxxxx.............yyyy		       */
     1472 /**** adjust to:		   |				       */
     1473 /****			b.a_.l.re (1)			       */
     1474 
     1475 cmd (097):			/* a */
     1476       if com1_blank then call ck_blank;
     1477       if (b.cur.sn = 0)		/* if buffer empty		       */
     1478       then b.a_.r.re (1), b.a_.r.le (1) = 0;
     1479       else if ^b.present (1)
     1480       then call default$cur_line_extend;
     1481       call ignore_2;
     1482       b.a_.l.re (1) = b.a_.r.le (1) + 1;
     1483       goto in_mode; 



     1484 /* . . . change	: replace addressed line(s)			       */
     1485 /****	      b.a_.l.re(1)    b.a_.r.le (2)			       */
     1486 /**** Addr:    	       |    |				       */
     1487 /****		xxxxxxxAAAAAAxxxxx.............yyyy		       */
     1488 /**** adjust to:    xxxxxxx...................xxxxxyyyy		       */
     1489 /****				      |			       */
     1490 /****				b.a_.l.re (1)		       */
     1491 
     1492 cmd (099):			/* c */
     1493       if com1_blank then call ck_blank;
     1494       call default$cur_line;
     1495       call delete;
     1496       b.a_.l.re (1) = b.b_.r.le;
     1497       goto in_mode; 



     1498 /* . . . insert	: before addressed line			       */
     1499 /****	      b.a_.l.re(1)    b.a_.r.le (1)			       */
     1500 /**** Addr:     	       |    |				       */
     1501 /****		xxxxxxxAAAAAAxxxxx.............yyyy		       */
     1502 /**** adjust to:	       |					       */
     1503 /****		b.a_.l.re (1)				       */
     1504 cmd (105):			/* i */
     1505       if com1_blank then call ck_blank;
     1506       if (b.cur.sn = 0)		/* if buffer empty		       */
     1507       then b.a_.l.le (1), b.a_.l.re (1) = 1;
     1508       else call default$cur_line_extend;
     1509       call ignore_2;





     1510 
     1511 in_mode:				/* ---common code---	       */
     1512       if (b.cur.sn = 0)
     1513       then b.trust_sw = b.force_name;
     1514       call openup;
     1515       EOF = "0"b;
     1516       if alt_sw
     1517       then which_mode = "BULK";
     1518       else do;
     1519          which_mode = "INPUT";
     1520          if (rl_c (rl_i) = NL)	/* skip NL or		       */
     1521 	    | (rl_c (rl_i) = SP)	/* ..blank immediately following     */
     1522          then rl_i = rl_i + 1;	/* .. input request		       */
     1523 scan_req_line:
     1524          k = index (substr (rl_s, rl_i), "\"); /* Any escapes?	       */
     1525          if (k = 0)			/* if not found		       */
     1526          then k = rl_l - rl_i + 1;	/*  take rest of line	       */
     1527          else k = k - 1;		/*  take everything up to there      */
     1528          if (k > 0)			/* if anything in between	       */
     1529          then do;			/* ...add it to buffer	       */
     1530 	  call add_2l (ted_safe, addr (rl_c (rl_i)), k, NLct_check);
     1531 	  rl_i = rl_i + k;
     1532          end;
     1533          if (rl_i <= rl_l)		/* if something left, handle it    */
     1534          then do;
     1535 	  k = index ("fcFC", rl_c (rl_i + 1));
     1536 	  if (k > 2) then k = k - 2;
     1537 	  if (k > 0)
     1538 	  then do;
     1539 	     rl_i = rl_i + 2;	/* skip the \f or \c	       */
     1540 	     if (k = 1)
     1541 	     then goto input_finish;
     1542 	  end;
     1543 				/* just copy char across	       */
     1544 	  call add_2l (ted_safe, addr (rl_c (rl_i)), 1, NLct_check);
     1545 	  rl_i = rl_i + 1;
     1546 	  goto scan_req_line;
     1547          end;
     1548       end;
     1549 
     1550       if (b.cur.sn = 0)		/* if no buffer there,	       */
     1551       then call promote (1);		/* ..get one		       */
     1552       pi_label = input_pi;
     1553       pi_sw = 3;
     1554 
     1555       b.INPUT = "1"b;		/* indicate INPUT in progress	   #156*/
     1556       do while (which_mode ^= "EOF");
     1557          k = b.b_.l.re;		/* remember last char filled	       */
     1558          call tedread_ptr_ (dbase_p,	/* -> database		       */
     1559 	    b.cur.sp,		/* -> buffer		       */
     1560 	    k,			/* last char used in buffer	       */
     1561 	    b.b_.r.le - 2,		/* last char usable		       */
     1562 	    b.b_.l.re,		/* last char filled		  [OUT]*/
     1563 	    which_mode);		/* mode			       */
     1564 input_pi:
     1565          k = b.b_.l.re - k;		/* how many characters were input    */
     1566          if (k > 0)
     1567          then b.mod_sw = "1"b;
     1568          if (chars_moved >= 0)	/* count the chars that were put     */
     1569          then chars_moved = chars_moved + k; /* ..the data buffer	       */
     1570          if (b.b_.l.ln ^= -1)
     1571          then do;
     1572 				/* count NLs */
     1573          end;
     1574          b.maxln = -1;		/* say we don't know # lines	       */
     1575          if (which_mode = "\R\F")
     1576          then goto input_over;
     1577          if (which_mode ^= "EOF")
     1578          then call promote (b.b_.r.le - b.b_.l.re + 2); /* get more room   */
     1579       end;
     1580 
     1581 input_over:
     1582       if (b.b_.l.re < b.b_.l.le)	/* if no data present,	       */
     1583 	 & (b.b_.r.re < b.b_.r.le)
     1584       then call delete$all;
     1585       else do;
     1586 input_finish:
     1587          b.a_.r.le (2) = b.b_.l.re;
     1588          b.a_.r.ln (2) = b.b_.l.ln;
     1589       end;
     1590       call iso_line;		/* "."-> last line input	       */
     1591       if db_ted
     1592       then call tedshow_ (bp, ". inp bcb");
     1593       if (which_mode = "\R\F")
     1594       then goto eof_err;
     1595       return (NX_REQ); 
     1596 
     1597 cmd (074):			/* J */
     1598       alt_sw = "1"b;
     1599 
     1600 cmd (106):			/* j */
     1601       call scan;
     1602       if com_blank then call ck_blank;
     1603       if (substr (rl_s, expr_b, expr_l) = "?")
     1604       then do;
     1605          call tedsort_$show;
     1606          return (NX_REQ);
     1607       end;
     1608       if (substr (rl_s, expr_b, 2) = "s=")
     1609       then do;
     1610          call tedsort_$set (substr (rl_s, expr_b + 2, expr_l - 2));
     1611          return (NX_REQ);
     1612       end;
     1613       call default$whole_buffer;	/* Default: sorting whole window     */
     1614       ii = i;
     1615       do sort_l = 1 to 3;
     1616          sort_sn (sort_l) = 0;
     1617          call tedget_segment_ (dbase_p, sort_p (sort_l), sort_sn (sort_l));
     1618       end;
     1619       if alt_sw
     1620       then do;
     1621          expr_b = expr_b - 1;
     1622          rl_c (expr_b) = "s";
     1623          expr_l = expr_l + 1;
     1624       end;
     1625       rl_b = expr_b;
     1626       call openup;
     1627 dcl sort_l	fixed bin (21);	/* @@@@ */
     1628       call tedsort_ (addr (rl_c (expr_b)), expr_l,
     1629 	 addr (b_c (b.a_.l.re (1))), b.a_.r.le (2) - b.a_.l.re (1) + 1,
     1630 	 sort_p, sort_l,
     1631 	 msg, code);
     1632       call tedfree_segment_ (dbase_p, sort_sn (1));
     1633       call tedfree_segment_ (dbase_p, sort_sn (2));
     1634       if (code ^= 0)
     1635       then do;
     1636          call tedfree_segment_ (dbase_p, sort_sn (3));
     1637          if (code = 2)		/* only 1 line sorted	       */
     1638          then return (NX_REQ);
     1639          rl_i = expr_b + expr_l - 1;
     1640          goto add_request;
     1641       end;
     1642       else do;			/* there's a window here where ^safe */
     1643          b.b_.r.le = b.a_.r.le (2) + 1; /* delete old copy		       */
     1644          call add_2l (ted_safe, sort_p (3), sort_l, NLct_unknown);
     1645          b.a_.r.le (2) = b.b_.l.re;
     1646          call iso_line;
     1647          call tedfree_segment_ (dbase_p, sort_sn (3));
     1648          return (NX_REQ);
     1649       end;
     1650       goto rq_err; 



     1651 /* . . . type	: type a string				       */
     1652 
     1653 cmd (084):			/* T */
     1654       ttp = iox_$error_output;
     1655       goto type;
     1656 cmd (116):			/* t */
     1657       if alt_sw
     1658       then ttp = iox_$error_output;
     1659       else ttp = iox_$user_output;
     1660 type:
     1661       call ignore_all;
     1662       call scan;
     1663       if com_blank then call ck_blank;
     1664       call iox_$put_chars (ttp, addr (rl_c (expr_b)), (expr_l), 0);
     1665       return (NX_REQ); 



     1666 /* . . . not	: inverse of a request (sorta)		       */
     1667 
     1668 cmd (039):			/* ' */
     1669 cmd (094):			/* ^ */
     1670 
     1671       req_chx, ch = rl_c (rl_i);
     1672       req_str = req_str || req_chx;
     1673       rl_i = rl_i + 1;
     1674       not_sw = "1"b;
     1675       if (index ("#*>rb", req_chx) = 0)
     1676       then goto invalid_request;
     1677       req_not = req_ch;
     1678       req_ch = req_chx;
     1679       req_chx = " ";
     1680       req_not = " ";
     1681       goto cmd (rank (req_ch)); 




     1682 /* . . . alternate	: alternate form of a few requests		       */
     1683 
     1684 cmd (033):			/* ! */
     1685 
     1686       if (substr (DBA, 1, 1) = "q")
     1687       then goto invalid_request;
     1688       req_chx, ch = rl_c (rl_i);
     1689       req_str = req_str || req_chx;
     1690       rl_i = rl_i + 1;
     1691       alt_sw = "1"b;
     1692       if (index ("abcefijklmnpqrstuwx!", req_chx) = 0)
     1693       then goto invalid_request;
     1694       if (req_chx = "!")		/* this is slipped in to handle      */
     1695       then req_ch = "|";		/*    when a user has no "|" on his  */
     1696       else do;			/*    keyboard, i.e. unmodified      */
     1697          req_not = "!";		/*    Apple ][		       */
     1698          req_ch = req_chx;
     1699       end;
     1700       req_chx = " ";
     1701 				/* RW 88 */
     1702       if (req_ch = "f") then req_ch = "F"; /*#194*/
     1703       goto cmd (rank (req_ch)); 
     1704 /* . . . substitute	: replace all occurences of str1 with str2	       */
     1705 
     1706 cmd (042):			/*"*"*/
     1707 if:
     1708       call scan;
     1709       if com_blank then call ck_blank;
     1710       call default$cur_line;
     1711       if (expr_l > 0)
     1712       then call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
     1713 	      addr (dbase.regexp), (string_sw), (dbase.lit_sw), msg, code);
     1714       call tedsrch_$search (addr (dbase.regexp), bp,
     1715 	 b.a_.l.re (1), b.a_.r.le (2), mi, me, me2, msg, code);
     1716       if (code = 2)			/* syntax error		       */
     1717       then goto print_error;
     1718       if (code = 0)
     1719       then return (not_sw);		/* search succeeded		       */
     1720       else return (^not_sw);		/* search failed		       */ 





     1721 cmd (083):			/* S */
     1722       subsw = "1"b;			/* init switch so cannot fail	       */
     1723       if ""b
     1724       then do;
     1725 
     1726 cmd (115):			/* s */
     1727          subsw = "0"b;		/* init switch to nothing found yet  */
     1728          if alt_sw
     1729          then subsw = "1"b;		/*  wait! make it no-fail	       */
     1730       end;
     1731       call default$cur_line;
     1732       call scan;			/* isolate str1 from request line    */
     1733       call init_cfp (sub_p, repl_exp);
     1734       gvx.tot_len = 0;
     1735       call replace$compile;		/* compile str2		       */
     1736       cf.op = 0;
     1737       call end_cf;
     1738 dcl repl_exp	char (500);
     1739       if com_blank then call ck_blank;
     1740       if (expr_l > 0)
     1741       then call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
     1742 	      addr (dbase.regexp), (string_sw), (dbase.lit_sw), msg, code);
     1743       if (code = 2)
     1744       then goto print_error;
     1745       dbase.S_count = 0;
     1746       call init_cfp (sub_p, repl_exp);
     1747       call substitute (addr (dbase.regexp)); /* cfp -> replace	       */
     1748 
     1749    /*** code = 8 => search failed				       */
     1750       if ^subsw			/* error if nothing found	       */
     1751       then do;
     1752          if (err_go = "")		/* if user does not want to catch    */
     1753 				/*  errors attempt to pop buffer     */
     1754          then call tedend_buffer_ (dbase_p, code); /*  recur stack    */
     1755          if code = 0
     1756          then return (NX_LIN);	/* and continue in calling buffer    */
     1757          msg = "Xsf) Substitute failed.";
     1758          goto print_error;
     1759       end;
     1760       return (NX_REQ); 
     1761 /* . . . TRANSLATE UPPER/LOWER . . */
     1762 
     1763 cmd (085):			/* U */
     1764 cmd (117):			/* u */
     1765 
     1766       call scan;
     1767       call ck_blank;
     1768       call default$cur_line;
     1769       if b.pseudo
     1770       then call promote (b.maxl);	/* change buffer into real one       */
     1771       if (expr_l > 0)
     1772       then call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
     1773 	      addr (dbase.regexp), (string_sw), (dbase.lit_sw), msg, code);
     1774       call upper_lower (addr (dbase.regexp), (req_ch = "U") | alt_sw);
     1775       return (NX_REQ); 



     1776 /* . . . option request	: set or display options */
     1777 
     1778 cmd (111):			/* o */
     1779       if (rl_i = rl_l)
     1780       then do;
     1781 				/* RW 88 */ /*#200*/
     1782          call ioa_ ("^a^[(^a)^;^s^][^i]^[safe^] ^[part_^]^[^;^^^]blank,"
     1783 	    || "^[^;^^^]caps,^[^;^^^]resetread,^[^;^^^]break,^[^;^^^]edit,"
     1784 	    || "^[^;^^^]input,^[^;^^^]label,^[^;^^^]read,^[^;^^^]old-style,"
     1785 	    || "^[^;^^^]g*NL,"
     1786 	    || "^[^;^^^]string,null=^a^[^/^-comment=""^a""^]",
     1787 
     1788 	    DBA, (DBA = "ted"), ted_vers, dbase.recurs, (dbase.dir_db ^= ""),
     1789 	    (com_blank ^= com1_blank), com_blank, caps, reset_read,
     1790 	    break_sw, edit_sw, input_sw, flow_sw,
     1791 	    read_sw, old_style, gvNL, string_sw, nulreq,
     1792 	    (dbase.comment ^= ""), dbase.comment);
     1793       end;
     1794       else do;
     1795          substr (rl_s, rl_l, 1) = " ";
     1796          do rl_i = rl_i to rl_l;
     1797 	  if (substr (rl_s, rl_i, 1) ^= " ")
     1798 	       & (substr (rl_s, rl_i, 1) ^= ",")
     1799 	  then do;
     1800 	     if (substr (rl_s, rl_i, 1) = "^")
     1801 	     then do;
     1802 	        not_sw = "1"b;
     1803 	        rl_i = rl_i + 1;
     1804 	     end;
     1805 	     else not_sw = "0"b;
     1806 dcl optlen	fixed bin;
     1807 	     if (substr (rl_s, rl_i, 4) = "edit")
     1808 	     then do;
     1809 	        optlen = 4;
     1810 	        edit_sw = ^not_sw;
     1811 	     end;
     1812 	     else if (substr (rl_s, rl_i, 5) = "input")
     1813 	     then do;
     1814 	        optlen = 5;
     1815 	        input_sw = ^not_sw;
     1816 	     end;
     1817 	     else if (substr (rl_s, rl_i, 2) = "on")
     1818 	     then do;
     1819 	        optlen = 2;
     1820 	        input_sw, edit_sw = "1"b;
     1821 	     end;
     1822 	     else if (substr (rl_s, rl_i, 5) = "trace")
     1823 	     then do;
     1824 	        optlen = 5;
     1825 	        input_sw, edit_sw = ^not_sw;
     1826 	     end;
     1827 	     else if (substr (rl_s, rl_i, 3) = "off")
     1828 	     then do;
     1829 	        optlen = 3;
     1830 	        input_sw, edit_sw = "0"b;
     1831 	     end;
     1832 	     else if (substr (rl_s, rl_i, 5) = "label")
     1833 	     then do;
     1834 	        optlen = 5;
     1835 	        flow_sw = ^not_sw;
     1836 	     end;
     1837 	     else if (substr (rl_s, rl_i, 9) = "partblank")
     1838 	     then do;
     1839 	        optlen = 9;
     1840 	        com_blank = "0"b;
     1841 	        com1_blank = ^not_sw;
     1842 	     end;
     1843 	     else if (substr (rl_s, rl_i, 5) = "blank")
     1844 	     then do;
     1845 	        optlen = 5;
     1846 	        com_blank, com1_blank = ^not_sw;
     1847 	     end;
     1848 	     else if (substr (rl_s, rl_i, 4) = "caps")
     1849 	     then do;
     1850 	        optlen = 4;
     1851 	        caps = ^not_sw;
     1852 	     end;
     1853 	     else if (substr (rl_s, rl_i, 4) = "read")
     1854 	     then do;
     1855 	        optlen = 4;
     1856 	        read_sw = ^not_sw;
     1857 	     end;
     1858 	     else if (substr (rl_s, rl_i, 9) = "resetread")
     1859 	     then do;
     1860 	        optlen = 9;
     1861 	        reset_read = ^not_sw;
     1862 	     end;
     1863 	     else if (substr (rl_s, rl_i, 5) = "break")
     1864 	     then do;
     1865 	        optlen = 5;
     1866 	        break_sw = ^not_sw;
     1867 	     end;
     1868 	     else if (substr (rl_s, rl_i, 9) = "old-style")
     1869 	     then do;
     1870 	        optlen = 9;
     1871 	        old_style = ^not_sw;
     1872 	     end;
     1873 	     else if (substr (rl_s, rl_i, 4) = "g*NL")
     1874 	     then do;
     1875 	        optlen = 4;
     1876 	        gvNL = ^not_sw;
     1877 	     end;
     1878 	     else if (substr (rl_s, rl_i, 5) = "null=")
     1879 	     then do;
     1880 	        optlen = 5;
     1881 	        i = 0;
     1882 	        if (substr (rl_s, rl_i + 5, 2) = "!p")
     1883 	        then i = 2;
     1884 	        if (index ("pP", substr (rl_s, rl_i + 5, 1)) ^= 0)
     1885 	        then i = 1;
     1886 	        if i = 0
     1887 	        then goto inv_opt;
     1888 	        nulreq = substr (rl_s, rl_i + 5, i);
     1889 	        optlen = optlen + i;
     1890 	     end;
     1891 	     else if (substr (rl_s, rl_i, 9) = "comment=""")
     1892 	     then do;
     1893 	        optlen = 9;
     1894 	        i = index (substr (rl_s, rl_i + 9), """");
     1895 	        if (i = 0)
     1896 	        then do;
     1897 		 call ioa_ ("Missing terminal quote on comment");
     1898 		 return (NX_LIN);
     1899 	        end;
     1900 	        dbase.comment = substr (rl_s, rl_i + 9, i - 1);
     1901 	        optlen = optlen + i;
     1902 	     end;
     1903 	     else if (substr (rl_s, rl_i, 2) = "ct") /* OBSOLETE! */
     1904 	     then do;
     1905 	        optlen = 2;
     1906 	        call ioa_ ("ct= ^i", dbase.S_count);
     1907 	     end;
     1908 	     else if (substr (rl_s, rl_i, 2) = "gv")
     1909 	     then do;
     1910 	        optlen = 2;
     1911 	        call gv_dump;
     1912 	     end;
     1913 	     else if (substr (rl_s, rl_i, 1) = "*")
     1914 	     then do;
     1915 	        optlen = rl_l - rl_i + 1;
     1916 	        call tedshow_ (bp, "> opt", substr (rl_s, rl_i + 1), "<");
     1917 	     end;
     1918 	     else if (substr (rl_s, rl_i, 2) = "??")
     1919 	     then do;
     1920 	        optlen = 2;
     1921 	        call ioa_ ("gv	gv_dump");
     1922 	        call ioa_ ("*xx	tedshow xx");
     1923 	     end;
     1924 	     else do;
     1925 inv_opt:
     1926 	        msg = "Xio) Invalid option ";
     1927 	        msg = msg || substr (rl_s, rl_i,
     1928 		   rl_l - rl_i);
     1929 	        goto print_error;
     1930 	     end;
     1931 	     rl_i = rl_i + optlen - 1;
     1932 	  end;
     1933          end;
     1934       end;
     1935       return (NX_LIN); 
     1936 /* . . .  execute request	: pass remainder of line to command processor  */
     1937 
     1938 cmd (069):			/* E */
     1939 cmd (101):			/* e */
     1940       if com1_blank then call ck_blank;
     1941       call ignore_both;
     1942       substr (rl_s, 1, rl_i - 1) = SP;	/* blank out up to here      */
     1943       if (req_str ^= "e")
     1944       then call iox_$put_chars (iox_$user_output, addr (rl_c (rl_i)),
     1945 	      rl_l - rl_i + 1, 0);
     1946       pi_label = kill_execute;	/* allow request to be aborted       */
     1947       pi_sw = 1;			/* by means of a PI		       */
     1948       call tedset_ck_ptr_ (dbase_p);
     1949       call cu_$cp (dbase.rl.sp, rl_l, code);
     1950 kill_execute:
     1951       pi_sw = 0;			/* disable PI upon return	       */
     1952       if fo_sw
     1953       then fop -> b.get_bit_count = "0"b;
     1954 				/* delete    #152*/
     1955       return (NX_LIN);		/* get fresh request line from input stream */





     1956 
     1957 /* these routines are support for the dynamic call mechanism	       */
     1958 ckpt: proc (p1, p2);
     1959 
     1960 dcl (p1, p2)	fixed bin (21);
     1961 				/* Temporarily unsupported	       */
     1962 /****      ofe = p2;					       */
     1963 /****      ifse = p1;					       */
     1964 
     1965    end ckpt; 


     1966 getreq: proc ();
     1967 
     1968       call tedread_ptr_ (dbase_p, dbase.rl.sp, 0, dbase.rl.r.re,
     1969 	 ted_sup.req.de, "|DATA");
     1970       if (chars_moved >= 0)		/* count number of chars he asked to */
     1971       then chars_moved = chars_moved + ted_sup.req.de; /* ..be gotten	       */
     1972 
     1973    end getreq;
     1974 
     1975 
     1976 /* . . . dynamic call	: call ted support routine (perhaps user-written) */
     1977 cmd (124):			/* | */
     1978       i = verify (substr (rl_s, rl_i),
     1979 	 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
     1980       if (i = 1)
     1981       then goto err_Snf;
     1982       msg = "ted_";
     1983       msg = msg || substr (rl_s, rl_i, i - 1);
     1984       msg = msg || "_";
     1985       req_str = req_str || substr (rl_s, rl_i, i - 1);
     1986       rl_i = rl_i + i - 1;
     1987       call ck_blank;
     1988       rl_i = rl_i + 1;
     1989       if (rl_i > rl_l)
     1990       then rl_c (rl_i) = NL;
     1991       if (b.cur.sn = 0)
     1992       then do;
     1993          b.a_.l.re (1) = 1;
     1994          b.a_.r.le (2) = 0;
     1995       end;
     1996       else call default$cur_line;
     1997 do_call:				/* entry for old request simulators */
     1998       call hcs_$make_ptr (codeptr (do_call), (msg), (msg), file_p, code);
     1999       if (code ^= 0)
     2000       then goto print_error_rc;
     2001       ted_sup.version = ted_support_version_2;
     2002       ted_sup.addr_ct = 0;
     2003       if b.present (1)
     2004       then ted_sup.addr_ct = 1;
     2005       if b.present (2)
     2006       then ted_sup.addr_ct = ted_sup.addr_ct + 1;
     2007 
     2008 /**** All the stuff relating to the ted_sup.inp.* values have to be handled  */
     2009 /**** so that it will give the proper view when a window is in effect.       */
     2010 
     2011       b.a_.l.re (2) = b.a_.l.re (1);	/* save beginning address where it   */
     2012 				/* ..will be relocated	       */
     2013       b.a_.l.re (1) = b.b_.r.re + 1;	/* pack data within window	       */
     2014       call openup;			/* ..to left End		       */
     2015       b.a_.l.re (1) = b.a_.l.re (2);	/* restore beginning address	       */
     2016       call tedcount_lines_ (bp,	/*b.b_.l.le + 1,			   #--a*/
     2017 	 b.b_.l.le, b.a_.l.re (1), ted_sup.inp.lno);
     2018       ted_sup.inp.lno = max (ted_sup.inp.lno, 1); /* #--a*/
     2019       ted_sup.inp.pt = addr (b_c (b.b_.l.le));
     2020       ted_sup.inp.sb = b.a_.l.re (1) - b.b_.l.le + 1;
     2021       ted_sup.inp.se = min (b.a_.r.le (2), b.b_.r.le) - b.b_.l.le + 1;
     2022       ted_sup.inp.de = b.b_.l.re - b.b_.l.le + 1;
     2023       if db_ted
     2024       then call ioa_$ioa_switch (db_output, "inp.pt = ^10p inp.sb=^5i inp.se=^5i inp.de=^5i",
     2025 	      ted_sup.inp.pt, ted_sup.inp.sb, ted_sup.inp.se, ted_sup.inp.de);
     2026       sort_sn (1) = 0;
     2027       call tedget_segment_ (dbase_p, ted_sup.out.pt, sort_sn (1));
     2028       ted_sup.out.de = ted_sup.inp.sb - 1;
     2029       substr (ted_sup.out.pt -> b_s, 1, ted_sup.out.de)
     2030 	 = substr (ted_sup.inp.pt -> b_s, 1, ted_sup.out.de);
     2031 
     2032       ted_sup.out.ml = 1048184;
     2033       if db_ted
     2034       then call ioa_$ioa_switch (db_output, "out.pt = ^10p out.de=^5i",
     2035 	      ted_sup.out.pt, ted_sup.out.de);
     2036       ted_sup.current = 0;		/* "." undefined		       */
     2037       ted_sup.req.pt = dbase.rl.sp;	/* make request line available       */
     2038       ted_sup.req.de, ted_sup.req.nc = rl_l;
     2039       ted_sup.req.cc = rl_i;
     2040       ted_sup.req.ml = dbase.rl.r.re;
     2041       ted_sup.string_mode = string_sw;
     2042 /****      ifse = 0;					       */
     2043 /****      iife = b.b_.r.re;					       */
     2044       ted_sup.checkpoint = ckpt;
     2045       ted_sup.get_req = getreq;
     2046       ted_sup.proc_expr = tedglobal_$proc_expr;
     2047       ted_sup.do_global = tedglobal_$do_global;
     2048 dcl tedglobal_$proc_expr entry (ptr, char (168) var, fixed bin (35));
     2049 dcl tedglobal_$do_global entry (entry (), char (1), ptr, char (168) var,
     2050 		fixed bin (35));
     2051       ted_sup.reg_exp_p = addr (dbase.regexp);
     2052       ted_sup.bcb_p = bp;
     2053       msg = "";			/* clean up message		       */
     2054       code = 0;			/* ..and return code	       */
     2055       pi_label = nochange;		/* allow PI to abort the action      */
     2056       pi_sw = 1;
     2057 
     2058 call_again:
     2059       call cu_$ptr_call (file_p, addr (ted_sup), msg, code);
     2060       if (code = error_table_$unimplemented_version)
     2061 	 & (ted_sup.version = ted_support_version_2)
     2062       then do;
     2063          ted_sup.version = ted_support_version_1;
     2064          goto call_again;
     2065 dcl ted_support_version_1 fixed bin int static init (1);
     2066       end;
     2067       if (ted_sup.version = ted_support_version_1)
     2068       then do;			/* convert old style codes	       */
     2069          if (code = 0)
     2070          then code = tederror_table_$Copy_Set;
     2071          else if (code = 1)
     2072          then code = tederror_table_$NoChange;
     2073          else if (code = 2)
     2074          then code = tederror_table_$Set;
     2075          else if (code = 4)
     2076          then code = tederror_table_$Error_Msg;
     2077       end;
     2078 
     2079       if (code = tederror_table_$Copy_Set)
     2080       then do;			/* copy back his result	       */
     2081          if db_ted
     2082          then call ioa_$ioa_switch (db_output, "out.pt = ^10p out.de=^5i",
     2083 	         ted_sup.out.pt, ted_sup.out.de);
     2084          b.a_.r.le (2) = min (ted_sup.inp.se, ted_sup.inp.de) + b.b_.l.le - 1;
     2085          b.a_.l.re (1) = b.b_.l.le;	/* 1st, get rid everything up to     */
     2086          call delete;		/* ..the end of what he processed    */
     2087 				/* then add in his replacement       */
     2088          call add_2l (ted_safe, ted_sup.out.pt, ted_sup.out.de, NLct_check);
     2089          code = tederror_table_$Set;	/* copy part taken care of	       */
     2090       end;
     2091       if ""b
     2092       then do;
     2093 nochange:				/* PI resume point		       */
     2094          code = tederror_table_$NoChange;
     2095       end;
     2096       pi_sw = 0;			/* no more interrupts	       */
     2097       call tedfree_segment_ (dbase_p, sort_sn (1));
     2098 
     2099       if (code = tederror_table_$Set)
     2100       then do;
     2101          if (ted_sup.current > 0)
     2102          then b.a_.r.le (2) = ted_sup.current;
     2103          call iso_line;		/* set current line as he (maybe)    */
     2104          code = tederror_table_$NoChange;
     2105       end;
     2106       if (code = tederror_table_$NoChange)
     2107       then do;
     2108          rl_i = ted_sup.req.nc;	/* propagate request line status     */
     2109          rl_l = ted_sup.req.de;
     2110          return (NX_REQ);
     2111       end;
     2112       if (code = tederror_table_$Error_Msg)
     2113       then do;
     2114          if (substr (msg, 4, 2) ^= ") ")/* He didn't prefix his	       */
     2115          then msg = "Xef) " || msg;	/* ..message so add my prefix to it  */
     2116          goto print_error;
     2117       end;
     2118       goto print_error_rc; 
     2119 dcl 1 ted_sup	like ted_support;
     2120 dcl hcs_$make_ptr	entry (ptr, char (*), char (*), ptr, fixed bin (35));
     2121 dcl cu_$ptr_call	entry options (variable); 
     2122 /* . . . buffer request 	: change current buffer		       */
     2123 
     2124 cmd (098):			/* b */
     2125       call ignore_all;
     2126 
     2127       if (b.cur.sn ^= 0)		/* if buffer not empty	       */
     2128       then do;
     2129          if (b.b_.l.le ^= 1) | (b.b_.r.re ^= b.maxl)
     2130          then b.a_.l.ln (0), b.a_.r.ln (0), b.maxln = -1; /* #140*/
     2131          b.b_.l.le = 1;		/* open up window again	       */
     2132          b.b_.l.ln = 1;
     2133          b.b_.r.re = b.maxl;
     2134          b.b_.r.ln = b.maxln;
     2135          if ^b.pseudo
     2136          then if (b.cur.ast = 1) | (b.cur.ast = 2) /* if separate segment   */
     2137 	    then call promote$seg;	/* ..garbage collect it	       */
     2138       end;
     2139       if alt_sw
     2140       then do;
     2141          if (b_depth = 10)
     2142          then goto err_Blv;
     2143          b_depth = b_depth + 1;
     2144          b_stack (b_depth) = bp;
     2145       end;
     2146       if (substr (rl_s, rl_i, 2) = "()") & ^not_sw
     2147       then do;
     2148          req_str = req_str || "()";
     2149          rl_i = rl_i + 2;
     2150          if (b_depth = 0)
     2151          then goto err_Bnr;
     2152          if com_blank then call ck_blank;
     2153          bp = b_stack (b_depth);
     2154          b_depth = b_depth - 1;
     2155          if (b.b_.l.le ^= 1) | (b.b_.r.re ^= b.maxl)
     2156          then b.a_.l.ln (0), b.a_.r.ln (0), b.maxln = -1; /* #140*/
     2157          b.b_.l.le = 1;		/* open up window again	       */
     2158          b.b_.l.ln = 1;
     2159          b.b_.r.re = b.maxl;
     2160          b.b_.r.ln = b.maxln;
     2161       end;
     2162       else do;
     2163          used = rl_l - rl_i + 1;
     2164          if not_sw			/* must exist or is an error	       */
     2165          then call tedget_existing_buffer_ (dbase_p,
     2166 	         addr (rl_c (rl_i)), used, tbp, msg);
     2167          else call tedget_buffer_ (dbase_p,
     2168 	         addr (rl_c (rl_i)), used, tbp, msg);
     2169          rl_i = rl_i + used;
     2170          if tbp = null
     2171          then goto rq_err_msg;
     2172          if com_blank then call ck_blank;
     2173          if not_sw
     2174          then do;
     2175 	  if (tbp = bp)
     2176 	  then goto err_Bnd;
     2177 	  do i = 1 to b_depth;
     2178 	     if (tbp = b_stack (i))
     2179 	     then goto err_Bnd;
     2180 	  end;
     2181 	  if tbp -> b.no_io
     2182 	  then goto not_allowed;
     2183 	  bp = tbp;
     2184 	  call delete;
     2185 	  call iso_line;
     2186 	  b.name = "";
     2187 	  return (NX_REQ);
     2188          end;
     2189          bp = tbp;			/* Make new buffer current	       */
     2190 /**** Make sure the gap is within window or we're in trouble elsewhere.      */
     2191          if (b.b_.l.re > b.a_.r.le (2)) | (b.b_.r.le <= b.a_.l.re (1))
     2192          then do;
     2193 	  call openup;
     2194 	  b.a_.l.re (1) = b.b_.l.re + 1;
     2195          end;
     2196 /**** fix up LN stuff here					       */
     2197 
     2198          b.b_.l.le = b.a_.l.re (1);	/* setup the addressed window	       */
     2199          b.b_.l.ln = b.a_.l.ln (1);
     2200          b.b_.r.re = b.a_.r.le (2);
     2201          b.b_.r.ln = b.a_.l.ln (2);
     2202       end;
     2203 
     2204       if (b.b_.l.le > b.a_.r.re (0)) | (b.b_.r.re < b.a_.l.le (0))
     2205       then do;			/* "." outside window	       */
     2206          b.a_.l.le (0) = b.b_.l.le;
     2207          b.a_.r.re (0) = addr_undef;
     2208       end;
     2209       else do;
     2210       /*** anything here? */
     2211       end;
     2212       cb_w_r, cb_c_r = rel (bp);
     2213       if db_ted
     2214       then call tedshow_ (bp, ". b adr");
     2215 
     2216       return (NX_REQ); 
     2217 /* . . . move request 	: move data from one buffer to another	       */
     2218 
     2219 cmd (109):			/* m */
     2220 cmd (107):			/* k */
     2221       app_sw = alt_sw;
     2222       if ""b then do;
     2223 cmd (077):			/* M */
     2224 cmd (075):			/* K */
     2225          app_sw = "1"b;
     2226       end;
     2227       if db_Ed
     2228       then do;
     2229          db_ted = "1"b;
     2230       end;
     2231       call default$cur_line;
     2232 mo3:
     2233       sbp = bp;
     2234       b.a_.l.le (1) = b.a_.l.re (1);
     2235 /**** Setup source address range				       */
     2236       b.cd.l.re = b.a_.l.re (1);
     2237       b.cd.r.le = b.a_.r.le (2);
     2238       used = rl_l - rl_i + 1;
     2239       call tedget_buffer_ (dbase_p, addr (rl_c (rl_i)), used, dbp, msg);
     2240 				/* get ctl block of destination      */
     2241       rl_i = rl_i + used;
     2242       if (dbp = null)
     2243       then goto rq_err_msg;
     2244       if dbp -> b.present (2)
     2245       then do;
     2246          msg = "Gma) 2nd addr not allowed on destination.";
     2247          goto add_request;
     2248       end;
     2249       bp = dbp;
     2250       if ^b.present (1) & (b.cur.sn ^= 0)
     2251       then call default$whole_buffer;
     2252       bp = sbp;
     2253       if com_blank then call ck_blank;
     2254 /**** I don't remember why the 2nd line down got commented out.	   JAF */
     2255 /**** BECAUSE the only time b_.r.re<=a_.r.le(2) is when upper is empty       */
     2256       if (dbp -> b.b_.l.le <= dbp -> b.b_.l.re) /* lower part not empty,    */
     2257 /****    & (dbp -> b.b_.r.re < dbp -> b.b_.r.le) /* ..upper part empty, &    */
     2258 	 & (dbp -> b.b_.r.re <= dbp -> b.a_.r.le (2)) /* ..addr refs upper   */
     2259       then dbp -> b.a_.r.le (2) = dbp -> b.b_.l.re; /* ....use lower part    */
     2260 
     2261 /**** Setup destination address point				       */
     2262       dbp -> b.cd.r.re = dbp -> b.a_.r.le (2) + 1;
     2263       if (dbp = sbp)
     2264       then do;			/* destination is current buffer     */
     2265          if ^app_sw
     2266          then do;			/* doing "m" or "k"		       */
     2267 	  msg = "Bnm) Can't m/k to current buffer.";
     2268 	  goto add_request;
     2269          end;
     2270          else if (rqc = "M")		/* Can't move into middle of what    */
     2271          then do;			/* ..is being deleted by the move.   */
     2272 	  if (b.cd.l.re <= b.cd.r.re) & (b.cd.r.re <= b.cd.r.le)
     2273 	  then do;
     2274 	     msg = "Xbm) Bad move spec.";
     2275 	     goto add_request;
     2276 	  end;
     2277          end;
     2278       end;
     2279 
     2280       if ^app_sw			/* gonna wipe old buffer contents?   */
     2281       then do;
     2282          bp = dbp;
     2283          if (b.cur.sn ^= 0)		/* are there any old contents?       */
     2284          then if b.file_sw & b.mod_sw
     2285 				/* is this a modified file?	       */
     2286 	         | b.not_pasted	/* or is it unused, moved text?      */
     2287 	    then do;		/*    ask first		       */
     2288 	       query_info.status_code = error_table_$inconsistent;
     2289 	       call command_query_ (addr (query_info), answer, DBA,
     2290 		  "Do you want to overwrite b(^a)? " ||
     2291 		  "It contains ^[modified file ^a>^a^a^a^;text ^a^]",
     2292 		  b.name, b.file_sw, b.dname, b.ename, b.kind, b.cname);
     2293 	       if (substr (answer, 1, 1) = "n")
     2294 	       then return (NX_LIN);
     2295 	    end;
     2296          if ^b.force_name		/* if name not forced on buffer..    */
     2297          then b.file_sw = "0"b;	/*   ..set "no file associated" on.. */
     2298 				/*   ..receiving buffer	       */
     2299          call delete$all;
     2300          bp = sbp;
     2301       end;
     2302 /**** Since it is felt that M/K will be done most often without a	       */
     2303 /****  destination address, the data is being placed on the left end to      */
     2304 /****  minimize the movement as each new piece is appended.		       */
     2305       call buffer_buffer_copy (sbp, dbp, "0"b);
     2306       bp = dbp;			/* go check things about destination */
     2307       if (dbp ^= sbp)		/* if source^=destination buffer     */
     2308       then do;
     2309 /****    Make sure the gap is between lines.  Everything assumes this to be  */
     2310 /****      the case.					       */
     2311          if (b.b_.l.re >= b.b_.l.le)	/* is there a lower part?	       */
     2312          then do;
     2313 	  if (b_c (b.b_.l.re) ^= NL)	/* does lower part not end in NL...  */
     2314 	       & (b.b_.r.re >= b.b_.r.le) /* ..and is there an upper part?     */
     2315 	  then do;
     2316 /**** The hole gets moved to a line boundary. Data is moved upward.	       */
     2317 /****  N.B.: A file which does not end with NL could be all in lower part.   */
     2318 /****        such as after doing "$($)d"			       */
     2319 	     i = index (reverse (
     2320 		substr (b_s, b.b_.l.le, b.b_.l.re - b.b_.l.le + 1)), NL);
     2321 	     if (i = 0)
     2322 	     then b.a_.l.re (1) = b.b_.l.le; /* take what is left	       */
     2323 	     else b.a_.l.re (1) = b.b_.l.re - i + 2; /* -> just after NL   */
     2324 	     call openup;
     2325 	  end;
     2326          end;
     2327          b.a_.l.le (0), b.a_.l.re (0) = 1; /* set "." undefined	       */
     2328          b.a_.r.le (0), b.a_.r.re (0) = addr_undef;
     2329       end;
     2330       if ^b.file_sw
     2331       then do;			/* if there is no file name	       */
     2332          msg = "  ";		/* ..then tell where the data	       */
     2333          msg = msg || req_str;	/* ..came from.		       */
     2334          msg = msg || " from b(";
     2335          msg = msg || rtrim (sbp -> b.name);
     2336          msg = msg || ")";
     2337          b.dname = msg;
     2338       end;
     2339       bp = sbp;			/* go back to source buffer	       */
     2340 
     2341       if (rqc = "m") | (rqc = "M")
     2342       then do;
     2343          if (ted_mode ^= COM)
     2344          then dbp -> b.not_pasted = "1"b;
     2345          b.a_.l.re (1) = b.cd.l.re;	/* restore source address range      */
     2346          b.a_.r.le (2) = b.cd.r.le;
     2347          call delete;
     2348       end;
     2349       else dbp -> b.not_pasted = "0"b;
     2350       call iso_line;		/* This is done for both move and    */
     2351 				/*  kopy for consistency.	       */
     2352       return (NX_REQ); 
     2353 /* . . . status ("x") request 	: list status of all buffers   . . . */
     2354 
     2355 cmd (088):			/* X */
     2356 X_status:
     2357       if (rl_c (rl_i) = NL)
     2358       then select = b.name;
     2359       else do;
     2360          rl_i = rl_i + verify (substr (rl_s, rl_i), " ") - 1;
     2361          if (rl_c (rl_i) ^= "(")
     2362          then do;
     2363 	  select = rl_c (rl_i);
     2364 	  rl_i = rl_i + 1;
     2365          end;
     2366          else do;
     2367 	  i = index (substr (rl_s, rl_i + 1), ")");
     2368 	  if (i = 0)
     2369 	  then goto err_Smp;
     2370 	  select = substr (rl_s, rl_i + 1, i - 1);
     2371 	  rl_i = rl_i + i + 1;
     2372          end;
     2373       end;
     2374       goto status;
     2375 cmd (120):			/* x */
     2376       if alt_sw
     2377       then goto X_status;
     2378       select = " ";
     2379       if com_blank
     2380       then if (rl_c (rl_i) = "m")
     2381 	 then do;
     2382 	    req_chx = "m";
     2383 	    req_str = req_str || "m";
     2384 	    rl_i = rl_i + 1;
     2385 	 end;
     2386 status:
     2387       call ignore_both;
     2388       if com_blank then call ck_blank;
     2389       if (req_chx = " ")
     2390       then call tedlist_buffers_ (dbase_p, select, "1"b, ln_sw);
     2391       else do;
     2392          call tedcheck_buffers_ (dbase_p, wct);
     2393          if (wct = 0)
     2394          then call ioa_ ("No modified buffers.");
     2395       end;
     2396       return (NX_REQ); 


     2397 /* . . . print current line number ("=") request 	: prints out line # current line in buffer */
     2398 
     2399 cmd (061):			/* = */
     2400       if com_blank then call ck_blank;
     2401       call ignore_1;
     2402       call default$cur_line;
     2403       call iso_line;		/* set "." to addressed line	       */
     2404       msg = "";
     2405       if string_sw
     2406       then do;
     2407          msg = msg || "0(";
     2408          j = b.a_.l.re (1);
     2409          if (b.a_.l.re (1) > b.b_.l.re)
     2410          then j = j - (b.b_.r.le - b.b_.l.re - 1); /* subtract hole size    */
     2411          msg = msg || ltrim (char (j));
     2412          msg = msg || ")	";
     2413       end;
     2414       call tedcount_lines_ (bp, b.b_.l.le, b.a_.l.re (1), j);
     2415       msg = msg || ltrim (char (j));
     2416       jb = b.a_.l.re (1) - b.a_.l.le (1) + 1;
     2417       if (jb > 1)
     2418       then do;
     2419          msg = msg || "(";
     2420          msg = msg || ltrim (char (jb));
     2421          msg = msg || ")";
     2422       end;
     2423       if ln_sw
     2424       then do;
     2425          msg = msg || " <<";
     2426          msg = msg || ltrim (char (b.a_.r.ln (2)));
     2427       end;
     2428       msg = msg || NL;
     2429       call iox_$put_chars (iox_$user_output, msg_ptr, length (msg), 0);
     2430       return (NX_REQ); 
     2431 /* . . . global/exclude request       : repeat given request for lines       */
     2432 /*				(not) containing) regfexp	       */
     2433 
     2434 cmd (118):			/* v */
     2435       xsw = "1"b;			/* exclude request		       */
     2436       if ""b then do;
     2437 
     2438 cmd (103):			/* g */
     2439          xsw = "0"b;		/* global request		       */
     2440       end;
     2441       Psw = "0"b;			/* set to show not doing "P"	       */
     2442       call default$whole_buffer;	/* Default: global whole window      */
     2443       if rl_i > rl_l
     2444       then goto err_Sd1;		/* error if nothing follows g or v   */
     2445 				/*  request		       */
     2446       b.a_.l.re (1) = b.a_.l.le (1);	/* force line orientation	       */
     2447       b.a_.r.le (2) = b.a_.r.re (2);
     2448       req_chx = rl_c (rl_i);		/* get global sub-request	       */
     2449       req_str = req_str || req_chx;
     2450       if (req_chx = "*")
     2451       then do;
     2452          if (gbp = null ())
     2453          then do;
     2454 	  argname = "((g*))";
     2455 	  call tedget_buffer_ (dbase_p, addr (argname), length (argname),
     2456 	       gbp, msg);
     2457          end;
     2458          gbp -> b.noref = "1"b;	/* Mark buffer invisible to "x"      */
     2459          rl_i = rl_i + 1;
     2460          if (rl_i < rl_l)
     2461          then do;
     2462 	  call gv_compile;
     2463          /*** NLlast has been set by gv_compile		       */
     2464 	  NLlast = NLlast & gvNL;
     2465 	  if (code ^= 0)
     2466 	  then goto print_error;
     2467          end;
     2468       end;
     2469       else if (req_chx = "h") | (req_chx = "H")
     2470       then do;
     2471          rl_i = rl_i + 1;
     2472          msg = "ted_";
     2473          msg = msg || req_ch;
     2474          msg = msg || "tabout_";
     2475          goto do_tabout;
     2476       end;
     2477       else do;
     2478          if (substr (rl_s, rl_i, 2) = "!p")
     2479          then do;
     2480 	  req_not = req_ch;
     2481 	  req_str = req_str || "p";
     2482 	  req_ch = "!";
     2483 	  req_chx = "p";
     2484 	  alt_sw = "1"b;
     2485 	  rl_i = rl_i + 1;
     2486          end;
     2487          else if (req_chx = ".")
     2488          then do;
     2489 	  req_chx = substr (nulreq, 1, 1);
     2490 	  if (req_chx = "!")
     2491 	  then req_chx = "P";
     2492          end;
     2493          else if (index ("p=Pd", req_chx) = 0)
     2494          then goto invalid_request;
     2495          if (index ("p=P", req_chx) = 0)
     2496          then NLlast = ""b;
     2497          else NLlast = "1"b;
     2498          rl_i = rl_i + 1;
     2499          call scan;
     2500          if (expr_l > 0)
     2501          then call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
     2502 	         addr (dbase.regexp), (string_sw), (dbase.lit_sw), msg, code);
     2503 /****         if (req_chx = "h")				       */
     2504 /****         then do;					       */
     2505 /****	       call TABSCAN;				       */
     2506 /****         end;						       */
     2507       end;
     2508 dcl 1 the_line_no,
     2509       2 l6	pic "zzzzz9",
     2510       2 ch	char (1);
     2511 /**** During global processing, data is kept like this:		       */
     2512 /**** b.gb.l.le - current location				       */
     2513 /**** b.gb.l.re - last location to use in part			       */
     2514 /**** b.gb.l.ln - line number of current line			       */
     2515 /**** b.gb.r.re - last location to use in buffer			       */
     2516 
     2517       if com_blank then call ck_blank;
     2518 gb3:
     2519       b.gb.l.le = b.a_.l.re (1);	/* hide away the address range       */
     2520       b.gb.l.ln = b.a_.l.ln (1);
     2521       b.gb.r.re = b.a_.r.le (2);
     2522       b.gb.r.ln = b.a_.r.ln (2);
     2523       if (b.gb.r.re <= b.b_.l.re)	/* if ends in lower part	       */
     2524 	 | (b.gb.l.le >= b.b_.r.le)	/* ..or begins in upper part	       */
     2525       then b.gb.l.re = b.gb.r.re;	/* ..part limit is address limit     */
     2526       else b.gb.l.re = b.b_.l.re;	/* otherwise part limit is l.re      */
     2527       if (req_chx = "=")
     2528 	 | (req_chx = "*")
     2529 	 | ((req_chx = "p") & alt_sw)
     2530 	 | (req_chx = "P")
     2531       then do;
     2532          call tedcount_lines_ (bp, b.b_.l.le, b.gb.l.le, b.gb.l.ln);
     2533          pi_label = gb_quit;
     2534          pi_sw = 1;
     2535       end;
     2536       else do;
     2537          pi_sw = 2;
     2538          b.gb.l.ln = 1;
     2539       end;
     2540       if db_ted
     2541       then call ioa_$ioa_switch (db_output, "^2-gb:^i <<^i", b.gb.l.ln, b.a_.l.ln (1));
     2542       b.a_.l.ln (1) = b.gb.l.ln;
     2543       if (req_chx = "P") | ((req_chx = "p") | alt_sw)
     2544       then the_line_no.ch = HT;
     2545       if (req_chx = "=")
     2546       then the_line_no.ch = NL;
     2547 gb_loop:
     2548       b.a_.l.le (1), b.a_.l.re (1) = b.gb.l.le; /* get begin of cur line   */
     2549       b.a_.r.ln (2) = b.a_.l.ln (1);
     2550       i = index (			/* then find end of it	       */
     2551 	 substr (b_s, b.gb.l.le, b.gb.l.re - b.gb.l.le + 1), NL);
     2552       if (i = 0)			/* worry about no NL at EOB	       */
     2553       then b.a_.r.le (2) = b.gb.l.re;
     2554       else b.a_.r.le (2) = b.gb.l.le + i - 1;
     2555       b.a_.r.re (2) = b.a_.r.le (2);
     2556       b.gb.l.le = b.a_.r.le (2);	/* get beginning of next line..      */
     2557       if (b.gb.l.le <= b.gb.l.re)	/* ..if we can		       */
     2558       then b.gb.l.le = b.gb.l.le + 1;
     2559       if db_ted
     2560       then call tedshow_ (bp, ". gv a1 a2 gb");
     2561 
     2562       if Psw			/* it's P, don't bother searching    */
     2563       then goto gb_p1;
     2564       if (req_chx = "*")
     2565       then do;
     2566          call gv_srch;
     2567          goto gb_end;
     2568       end;
     2569 				/* search line for REGEXP	       */
     2570       call tedsrch_$search (addr (dbase.regexp), bp, b.a_.l.re (1),
     2571 	 b.a_.r.le (2), mi, me, me2, msg, code);
     2572       if (code = 2)
     2573       then goto print_error;
     2574       if xsw = (code ^= 0)		/* ^match w/ exclude request	       */
     2575       then do;			/*  OR match w/ global request       */
     2576 				/* this line is to be processed      */
     2577          if (req_chx = "p")		/* doing "p" request?	       */
     2578          then if alt_sw
     2579 	    then goto gb_p1;
     2580 	    else goto gb_p2; 



     2581          if (req_chx = "P")
     2582          then do;
     2583 gb_p1:
     2584 	  the_line_no.l6 = b.gb.l.ln;
     2585 	  call iox_$put_chars (iox_$user_output, addr (the_line_no), 7, 0);
     2586 gb_p2:
     2587 	  call iox_$put_chars (iox_$user_output, addr (b_c (b.a_.l.re (1))),
     2588 	       b.a_.r.le (2) - b.a_.l.re (1) + 1, 0);
     2589 	  if intsw then goto gb_quit; /* abort request if PI has occurred  */
     2590          end; 



     2591          else if (req_chx = "=")
     2592          then call ioa_$nnl ("^i^a", b.gb.l.ln, the_line_no.ch);
     2593          else do;
     2594 	  if (req_chx = "d")
     2595 	  then call delete;		/* iso_line not needed	       */
     2596          end;
     2597       end;
     2598 
     2599 gb_end:
     2600       if (b.gb.l.le <= b.gb.l.re)
     2601       then do;
     2602          b.gb.l.ln = b.gb.l.ln + 1;	/* increment line counter	       */
     2603          goto gb_loop;		/* check for last line processed     */
     2604       end;
     2605       if (b.gb.l.re ^= b.gb.r.re)	/* if there is a split	       */
     2606       then do;			/* ..move to upper part & continue   */
     2607          b.gb.l.le = b.b_.r.le;
     2608          b.gb.l.re = b.gb.r.re;
     2609          goto gb_end;
     2610       end;
     2611 gb_quit:
     2612       pi_sw = 0;
     2613       b.gb = tedcommon_$no_data;
     2614 /**** Don't leave unused buffer there.				       */
     2615       if (b.b_.l.le > b.b_.l.re) & (b.b_.r.le > b.b_.r.re)
     2616       then call delete$all;		/* #142*/
     2617       else if (b.a_ (2).r.le > b.b_.r.re) /* was last line deleted?	       */
     2618       then b.a_ (2).r.le = b.b_.l.re;	/* point to new last line.	   #162*/
     2619       call iso_line;		/* when done, leave current line at  */
     2620 				/* ..last line processed	       */
     2621       if (req_chx = "*")		/* g* uses the rest of the line      */
     2622       then rl_i = rl_l;
     2623       if NLlast
     2624       then call iox_$put_chars (iox_$user_output, addr (NL), 1, 0);
     2625       return (NX_REQ); 
     2626 /* . . . PRINT request 	: print with line numbers . . . */
     2627 
     2628 cmd (080):			/* P */
     2629       if com_blank then call ck_blank;
     2630       call default$cur_line;		/* default addr (.,.) if needed      */
     2631 PRINTb:
     2632       req_chx = req_ch;
     2633       req_ch = " ";
     2634       NLlast = ""b;
     2635       Psw = "1"b;			/* set sw to show PRINT */
     2636       goto gb3;
     2637 
     2638 /* . . . tab-out request . . . */
     2639 cmd (072):			/* H */
     2640 cmd (104):			/* h */
     2641 
     2642       msg = "ted_tabout_";
     2643 do_tabout:
     2644       if (rl_c (rl_i) = " ")
     2645       then goto err_Sd1;
     2646 				/* RW 88 */
     2647       call default$cur_line;		/*#193*/
     2648       goto do_call; 



     2649 /* . . . tab-in request  . . . */
     2650 
     2651 cmd (121):			/* y */
     2652 
     2653       if com_blank then call ck_blank;
     2654       b.a_.l.re (1) = b.a_.l.le (1);	/* line oriented only	       */
     2655       msg = "ted_tabin_";		/* simulate obsolete request	       */
     2656 				/* RW 88 */
     2657       call default$cur_line;		/*#193*/
     2658       goto do_call; 
     2659 /* . . . define label . . . */
     2660 
     2661 cmd (058):			/* : */
     2662       i = rl_i;
     2663       if (rl_c (rl_i) = "(")
     2664       then do;
     2665          il = index (substr (rl_s, rl_i), ")");
     2666          if (il = 0)
     2667          then goto err_Smp;
     2668          if (il > 16)
     2669          then goto err_Slx;
     2670       end;
     2671       else il = 1;
     2672       rl_i = rl_i + il;
     2673       if com_blank then call ck_blank;
     2674       if flow_sw
     2675       then call ioa_ ("**FLOW **	^a", substr (rl_s, i, il));
     2676       return (NX_REQ); 



     2677 /* . . . nop request 	: change value of "." and get next request from input line */
     2678 
     2679 cmd (110):			/* n */
     2680 nullrq:
     2681       if com_blank then call ck_blank;
     2682       if ^b.present (1)
     2683       then return (NX_REQ);		/* ignore if no address given	       */
     2684       if alt_sw & b.present (2)
     2685       then do;
     2686          b.a_.l (0) = b.a_.l (1);
     2687          b.a_.r (0) = b.a_.r (2);
     2688          return (NX_REQ);
     2689       end;
     2690       if (b.a_.r.le (1) = 0)
     2691       then do;
     2692          b.a_.l.le (0), b.a_.l.re (0) = 1;
     2693          b.a_.r.le (0), b.a_.r.re (0) = 0;
     2694          return (NX_REQ);
     2695       end;
     2696       b.a_.r.le (2) = b.a_.r.le (1);
     2697       call ignore_2;
     2698       call iso_line;		/* change "." to last line addressed */
     2699       return (NX_REQ);
     2700 
     2701 /* . . . goto label in this buffer . . . */
     2702 
     2703 cmd (062):			/* > */
     2704 ref_label:
     2705       call ignore_all;
     2706       tc = rl_c (rl_i);
     2707       i = rl_i;
     2708       if (tc = "(")
     2709       then do;
     2710          il = index (substr (rl_s, rl_i), ")");
     2711          if (il = 0)
     2712          then goto err_Smp;
     2713          if (il > 16)
     2714          then goto err_Slx;
     2715       end;
     2716       else if (tc = "+") then goto rel_go;
     2717       else if (tc = "-")
     2718       then do;
     2719 rel_go:
     2720          il = 2;
     2721          if (index ("0123456789", rl_c (rl_i + 1)) = 0)
     2722          then goto err_Sbd;
     2723       end;
     2724       else il = 1;
     2725       if (tc ^= NL)
     2726       then do;
     2727          rl_i = rl_i + il;
     2728          if (rl_c (rl_i) = ":")
     2729          then do;
     2730 	  rl_i = rl_i + 1;
     2731 	  code = 1;
     2732          end;
     2733          else code = 0;
     2734          if com_blank then call ck_blank;
     2735       end;
     2736       if not_sw
     2737       then do;
     2738          err_go = substr (rl_s, i, il);
     2739          return (NX_REQ);
     2740       end;
     2741       call tedset_ptr_ (dbase_p, substr (rl_s, i, il), code);
     2742       if (code = 0)
     2743       then do;
     2744          return (NX_LIN);
     2745       end;
     2746       if (code = 10)
     2747       then goto rq_err;
     2748       return (NX_REQ); 




     2749 /* . . . return from current buffer . . */
     2750 
     2751 cmd (126):			/* ~ */
     2752 
     2753       call tedend_buffer_ (dbase_p, code);
     2754       return (NX_LIN); 
     2755 /* . . . comment delimiter (") found 	: change value of "." to last line addressed and ignore rest of line */
     2756 
     2757 cmd (034):			/* " */
     2758 comment:
     2759       if ^b.present (1)		/* if no address given..	       */
     2760       then return (NX_LIN);		/* ..ignore completely	       */
     2761       call ignore_2;
     2762       b.a_.r.le (2) = b.a_.r.le (1);
     2763       call iso_line;		/* change "." to last line addressed */
     2764       return (NX_LIN);		/* ignore remainder of request line  */



     2765 
     2766 /* . . . if-line request 	: test if current line is a specific one . . . */
     2767 
     2768 cmd (035):			/* # */
     2769 if_line:
     2770       if com_blank then call ck_blank;
     2771       if (b.cur.sn = 0) then		/* defined to fail if buffer empty */
     2772 	 goto if_line_f;
     2773       if ^b.present (1)		/* if no addr supplied,	       */
     2774       then goto if_line_t;		/*    then buffer-empty test	       */
     2775       call default$cur_line;
     2776       if b.present (2)
     2777       then do;
     2778          if (b.a_.l.re (0) < b.a_.l.re (1))
     2779          then goto if_line_f;
     2780          if (b.a_.r.le (0) > b.a_.r.le (2))
     2781          then goto if_line_f;
     2782          goto if_line_t;
     2783       end;
     2784       else do;
     2785          if (b.a_.l.re (0) = b.a_.l.re (1))
     2786          then goto if_line_t;
     2787       end;
     2788 if_line_f:			/* if_line_false */
     2789       return (^not_sw);
     2790 if_line_t:			/* if_line_true */
     2791       return (not_sw);
     2792 
     2793 
     2794 /* . . . z-subsystem request . . . */
     2795 
     2796 cmd (122):			/* z */
     2797       i = index (substr (rl_s, rl_i), " ");
     2798       if (i = 0)
     2799       then i = rl_l - rl_i;
     2800       else i = i - 1;
     2801       req_str = req_str || substr (rl_s, rl_i, i);
     2802       if (substr (rl_s, rl_i, i) ^= "if")
     2803       then do;
     2804          if (b.cur.sn = 0)
     2805          then do;
     2806 	  msg = "Abe) Buffer empty.";
     2807 	  goto print_error;
     2808          end;
     2809          call default$line_eval;
     2810          if (substr (rl_s, rl_i, i) = "dump")
     2811          then do;
     2812 	  rl_i = rl_i + i;
     2813 	  msg = "ted_dump_";
     2814 	  goto do_call;
     2815          end;
     2816          if (substr (rl_s, rl_i, i) = ".fi.na")
     2817          then do;
     2818 	  rl_i = rl_i + i;
     2819 	  msg = "ted_fina_";
     2820 	  goto do_call;
     2821          end;
     2822          if (substr (rl_s, rl_i, i) = ".fi.ad")
     2823          then do;
     2824 	  rl_i = rl_i + i;
     2825 	  msg = "ted_fiad_";
     2826 	  goto do_call;
     2827          end;
     2828       end;
     2829       rl_i = rl_i + i;
     2830       rl_i = rl_i + verify (substr (rl_s, rl_i), " ");
     2831 
     2832 /**** "zif" falls into "{" routine, after having adjusted rl_i properly      */
     2833 
     2834 /* . . . evaluate request "{" . . . */
     2835 cmd (123):			/* { */
     2836 
     2837       rl_i = rl_i - 1;
     2838       if b.present (1)
     2839       then call default$line_eval;
     2840       used = rl_l - rl_i + 1;
     2841       call tedeval_ (dbase_p, addr (rl_c (rl_i)), used,
     2842 	 bp, null (), 0, result, msg, code);
     2843       rl_i = rl_i + used;
     2844       if (code ^= 0)
     2845       then do;
     2846 eval_err:
     2847          if (code < 100)
     2848          then goto print_error;
     2849          goto print_error_rc;
     2850       end;
     2851       if (req_str = "zif")
     2852       then do;
     2853          if (result = "0") | (result = "false")
     2854          then return (NX_LIN);
     2855          else return (NX_REQ);
     2856       end;
     2857       if (length (result) ^= 0)
     2858       then do;
     2859          msg = "{ has result """;
     2860          msg = msg || result;
     2861          msg = msg || """.
     2862 ";
     2863          call iox_$put_chars (iox_$error_output, msg_ptr, length (msg), 0);
     2864       end;
     2865       return (NX_REQ); 
     2866 /* . . . file-output request	: direct "user_output" to a buffer . . */
     2867 
     2868 cmd (102):			/* f */
     2869       if fo_sw
     2870       then do;			/* #147*/
     2871 fo_err:
     2872          if go_sw then msg = "EFo) F";	/* #147*/
     2873          else msg = "Efo) f";		/* #147*/
     2874          msg = msg || " already active";/* #147*/
     2875          goto print_error;		/* #147*/
     2876       end;			/* #147*/
     2877       go_sw = "0"b;
     2878       if alt_sw
     2879       then do;
     2880 cmd (070):			/* F */
     2881          if (rl_c (rl_i) = NL)
     2882          then do;
     2883 	  go_sw = "0"b;
     2884 	  return (NX_LIN);
     2885          end;
     2886          if fo_sw
     2887          then goto fo_err;		/* #147*/
     2888          go_sw = "1"b;
     2889       end;
     2890       call ignore_all;
     2891       used = rl_l - rl_i + 1;
     2892       call tedget_buffer_ (dbase_p, addr (rl_c (rl_i)), used, fop, msg);
     2893       rl_i = rl_i + used;
     2894       if (fop = null)
     2895       then goto rq_err_msg;
     2896       if com_blank then call ck_blank;
     2897       if (pdname = " ")
     2898       then pdname = get_pdir_ ();
     2899       begin;
     2900          fo_name = "ted_."; dcl pic2 pic "99";
     2901          substr (fo_name, 6, 2) = convert (pic2, dbase.recurs);
     2902          got_quit = "0"b;		/* We can't be interrupted while we  */
     2903          on quit got_quit = "1"b;	/* ..are messing with switches       */
     2904          call iox_$attach_name (fo_name, fcbp, "vfile_ " || pdname
     2905 	    || ">" || "ted_." || dbase.rq_id, null (), code);
     2906          if (code ^= 0)
     2907          then do;
     2908 	  call com_err_ (code, DBA, "attach ted_fo");
     2909 	  signal condition (ted_fo_err);
     2910          end;
     2911          call iox_$open (fcbp, 2, "0"b, code);
     2912          if (code ^= 0)
     2913          then do;
     2914 	  call com_err_ (code, DBA, "open ted_fo");
     2915 	  signal condition (ted_fo_err);
     2916          end;
     2917          call iox_$find_iocb (fo_name || "save", fcbsp, code);
     2918          if (code ^= 0)
     2919          then call com_err_ (code, DBA, "find ^asave", fo_name);
     2920          call iox_$move_attach (iox_$user_output, fcbsp, code);
     2921          if code ^= 0
     2922          then call com_err_ (code, DBA, "move attach user_output");
     2923          code = iox_$attach_iocb (iox_$user_output, "syn_ " || fo_name);
     2924          if (code ^= 0)
     2925          then do;
     2926 	  call com_err_ (code, DBA, "attach user_output");
     2927          end;
     2928          fo_sw = "1"b;
     2929          revert quit;
     2930       end;
     2931       if got_quit
     2932       then signal quit;
     2933       return (NX_REQ);
     2934 
     2935    end do_req; 
     2936 upper_lower: proc (expr_p, upper);
     2937 
     2938 dcl expr_p	ptr,		/* -> compiled expression area       */
     2939     upper		bit (1);		/* 1-to upper	0-to lower       */
     2940 
     2941 Uu_loop:
     2942       call tedsrch_$search (expr_p, bp,
     2943 	 b.a_.l.re (1), b.a_.r.le (2), mi, me, me2, msg, code);
     2944       if (code = 0)
     2945       then do;
     2946          b.mod_sw = "1"b;
     2947          ml = me - mi + 1;
     2948          if (ml = 0)
     2949          then b.a_.l.re (1) = mi + 1;
     2950          else do;
     2951 	  b.a_.l.re (1) = me + 1;
     2952 	  if upper
     2953 	  then substr (b.cur.sp -> b_s, mi, ml)
     2954 		  = translate (substr (b.cur.sp -> b_s, mi, ml), AZ, az);
     2955 	  else substr (b.cur.sp -> b_s, mi, ml)
     2956 		  = translate (substr (b.cur.sp -> b_s, mi, ml), az, AZ);
     2957          end;
     2958          if (b.a_.l.re (1) <= b.a_.r.le (2))
     2959          then goto Uu_loop;
     2960       end;
     2961       if (code = 2)
     2962       then goto print_error;
     2963       call iso_line;
     2964 
     2965    end upper_lower; 
     2966 substitute: proc (axp);
     2967 
     2968 dcl axp		ptr;		/* -> compiled search expression     */
     2969 /****comptr			** -> compiled replace expression    */
     2970 dcl IC		fixed bin;
     2971 
     2972       IC = gvx.ic;
     2973 sub_loop:
     2974       call tedsrch_$search (axp, bp,
     2975 	 b.a_.l.re (1), b.a_.r.le (2), mi, me, me2, msg, code);
     2976       if code = 0
     2977       then do;
     2978          dbase.S_count = dbase.S_count + 1;
     2979          subsw = "1"b;		/* indicate something found	       */
     2980          gvx.ic = IC;
     2981          cfp = addr (gvx.word (gvx.ic));
     2982          call replace (mi, me, me2);
     2983          if b.a_.l.re (1) <= b.a_.r.le (2)
     2984          then goto sub_loop;		/* until end of addressed portion    */
     2985 				/* of buffer reached	       */
     2986       end;
     2987       call iso_line;		/* set cur line to last line srched  */
     2988 
     2989    end substitute; 




     2990 replace: proc (ami, ame, ame2);
     2991 
     2992 dcl (
     2993     ami		fixed bin (21),	/* beginning of match	       */
     2994     ame		fixed bin (21),	/* end of match		       */
     2995     ame2		fixed bin (21));	/* last char searched	       */
     2996 /**** cfp points to next compiled expression entry		       */
     2997 
     2998 dcl ml		fixed bin (21);	/* length of string matched	       */
     2999 dcl i		fixed bin;
     3000 dcl rep_p		ptr;		/* ->matched string		       */
     3001 dcl temp_p	ptr;		/* ->temp seg for matched string     */
     3002 dcl temp_sn	fixed bin;	/* # of temp seg if it was needed    */
     3003 
     3004       b.a_.r.le (1) = ame;		/* save match end for relocation     */
     3005       b.a_.r.re (1) = ame2;		/* save search end for relocation    */
     3006       b.a_.l.re (1) = ami;		/* set location for openup	       */
     3007       call openup;
     3008       rep_p = addr (b_c (b.a_.l.re (1)));
     3009       temp_sn = 0;
     3010       ml = ame - ami + 1;		/* find out how long the match was   */
     3011       do cfp = cfp repeat (addr (gvx.word (gvx.ic)));
     3012          if db_srch
     3013          then call tedshow_ (comptr, "cf");
     3014          if (cf.op >= seval_op) & (cf.op <= srepl_op)
     3015          then goto repop (cf.op);
     3016 				/*  not a replace operation, quit    */
     3017          if ml = 0			/* if matched string was null	       */
     3018          then do;			/* insure we find a different	       */
     3019 				/*  null string next time	       */
     3020 	  b.a_.l.re (1) = b.a_.l.re (1) + 1;
     3021          end;
     3022          else do;			/* matched str not null	       */
     3023 	  i = index (substr (b_s, b.a_.l.re (1), ml), NL);
     3024 	  if (i > 0)		/* NL in old string?	       */
     3025 	  then do;
     3026 	     if (i = ml)		/* The NL is at the end, therefore   */
     3027 	     then do;		/* ..it must be the only one.	       */
     3028 	        if (b.maxln > 1)	/* If line count is known, decrement */
     3029 	        then b.maxln = b.maxln - 1;
     3030 	        else b.maxln = -1;
     3031 	     end;
     3032 	     else do;
     3033 				/* (could see if there are no more)  */
     3034 	        b.maxln = -1;	/* forget the count		       */
     3035 	     end;
     3036 	     b.b_.l.ln, b.b_.r.ln = -1; /* forget the rest	       */
     3037 	  end;
     3038 	  b.mod_sw = "1"b;
     3039 	  if (temp_sn ^= 0)		/* if we had to copy match, clean up */
     3040 	  then call tedfree_segment_ (dbase_p, temp_sn);
     3041 	  else b.b_.r.le = b.a_.r.le (1) + 1; /* throw away old string     */
     3042 	  b.a_.l.re (1) = b.a_.r.re (1) + 1; /* resume at me2 + 1	       */
     3043          end;
     3044          if db_ted
     3045          then call tedshow_ (bp, ". rep b_ a1");
     3046          return;
     3047 
     3048 repop (-1):			/* literal insert		       */
     3049          call add_rep (addr (cf.da), (cf.len), NLct_check);
     3050          goto end_rep;
     3051 
     3052 repop (-2):			/* (replace with matched string)     */
     3053          if (ml > 0)		/* .. skip if null string found      */
     3054          then do i = 1 to cf.len;
     3055 	  call add_rep (rep_p, ml, NLct_check);
     3056          end;
     3057          goto end_rep;
     3058 
     3059 repop (-3):			/* "equal" convention: x\= gives     */
     3060 				/*  x repeated matchlength times     */
     3061          if (ml > 0)
     3062          then begin;
     3063 dcl str		char (ml);
     3064 	     str = copy (cf.da, ml);
     3065 	     call add_rep (addr (str), ml, ml * fixed (cf.da = NL));
     3066 	  end;
     3067          goto end_rep;
     3068 
     3069 repop (-4):			/* evaluation		       */
     3070          call tedeval_ (dbase_p, addr (cf.da), (cf.len),
     3071 	    bp, addr (b_c (b.a_.l.re (1))), ml, result, msg, code);
     3072          if (code ^= 0)
     3073          then goto print_error;
     3074          if (length (result) > 0)
     3075          then call add_rep (addrel (addr (result), 1), length (result),
     3076 	         NLct_check);
     3077 end_rep:
     3078          gvx.ic = gvx.ic + cf.siz;
     3079       end;
     3080 add_rep: proc (r_p, r_l, NLcheck);
     3081 
     3082 dcl r_p		ptr,		/* ->replacement string	       */
     3083     r_l		fixed bin (21),	/* length of it		       */
     3084     NLcheck	fixed bin (21);	/* NL check flag		       */
     3085 dcl space		fixed bin (21);
     3086 dcl m		char (ml) based;
     3087 
     3088       if (b.cur.ast = 1)		/* if the buffer is full size	       */
     3089 	 & (temp_sn = 0)		/* ..& match string is still in      */
     3090       then do;			/* ..the buffer, do the check	       */
     3091          space = b.b_.r.le - b.b_.l.re - 1; /* how much room left	       */
     3092          space = space - r_l;		/* how much left after adding	       */
     3093          if (space < 0)		/* if not enough room left	       */
     3094 	    & ((space + ml) >= 0)	/* ..but removing match would help   */
     3095          then do;			/* move the match string elsewhere   */
     3096 	  call tedget_segment_ (dbase_p, temp_p, temp_sn);
     3097 	  temp_p -> m = rep_p -> m;	/* copy match out of buffer	       */
     3098 	  b.b_.r.le = b.a_.r.le (1) + 1; /* remove from buffer	       */
     3099 	  rep_p = temp_p;		/* point to new location	       */
     3100          end;
     3101       end;			/* we have done the best we could    */
     3102       call add_2l (ted_safe, r_p, r_l, NLcheck);
     3103 
     3104    end add_rep;
     3105 
     3106 
     3107 /* never gets here */ 
     3108 replace$compile: entry;
     3109 
     3110       concealsw = "0"b;		/* initialize concealed-char. switch */
     3111       cf.op = -255;
     3112       cf.len = 0;
     3113       do rl_i = j to rl_l;		/* compile char's from str2 */
     3114          ch = rl_c (rl_i);
     3115          if concealsw		/* check for concealed char.	       */
     3116          then do;
     3117 	  concealsw = "0"b;		/* reset concealed-char. switch      */
     3118 	  call make_rp (srepl_op, ch);
     3119          end;
     3120          else if (ch = delim)
     3121          then do;
     3122 	  cf.siz = size (cf);
     3123 	  call end_cf;
     3124 	  rl_i = rl_i + 1;
     3125 	  return;
     3126          end;
     3127          else if ch = BS_C		/* check for concealment char. BS_C  */
     3128          then concealsw = "1"b;	/* set switch to conceal next char.  */
     3129          else if (ch = "\")
     3130          then do;
     3131 	  if (index ("cC", rl_c (rl_i + 1)) > 0)
     3132 	  then do;
     3133 	     rl_i = rl_i + 1;
     3134 	     concealsw = "1"b;
     3135 	  end;
     3136 	  else if (index ("gG", rl_c (rl_i + 1)) > 0)
     3137 	  then do;
     3138 /**** really need to look for quoted strings in the process...	       */
     3139 	     i = index (substr (rl_s, rl_i + 1), "}");
     3140 	     if (i = 0)
     3141 	     then do;
     3142 	        msg = "Gvd) Missing } on \g{.";
     3143 	        goto gv_msg_com;
     3144 	     end;
     3145 	     call make_rp (seval_op, substr (rl_s, rl_i + 2, i - 1));
     3146 	     rl_i = rl_i + cf.len + 1;
     3147 
     3148 	  end;
     3149 	  else if (ch = "=")
     3150 	  then do;
     3151 	     rl_i = rl_i + 1;
     3152 	     if (cf.len = 0)
     3153 	     then goto err_Sne;
     3154 	     ch = substr (cf.da, cf.len, 1);
     3155 	     cf.len = cf.len - 1;
     3156 	     call make_rp (sdup_op, ch);
     3157 
     3158 	  end;
     3159 	  else call make_rp (srepl_op, ch);
     3160          end;
     3161          else if ch = "&"		/* (replace with matched string)     */
     3162          then do;
     3163 	  call make_rp (sself_op, "&");
     3164 
     3165          end;
     3166          else call make_rp (srepl_op, ch);
     3167       end;
     3168       goto err_Sd3;			/* shouldn't reach here	       */
     3169 
     3170 make_rp: proc (op1, ch);
     3171 dcl op1		fixed bin,
     3172     ch		char (*);
     3173 
     3174       if (cf.op ^= op1)		/* is element different than new one */
     3175       then do;
     3176          cf.siz = size (cf);
     3177          call end_cf;
     3178          cf.op = op1;
     3179          if (op1 = 0)
     3180          then return;
     3181       end;
     3182 (nostringrange): substr (cf.da, cf.len + 1, length (ch)) = ch;
     3183       cf.len = cf.len + length (ch);	/* add char to element	       */
     3184       cf.siz = size (cf);
     3185    end make_rp; 

     3186    end replace; 
     3187 print: proc;
     3188 
     3189       pi_label = end_pr;		/* allow printing to be aborted      */
     3190       pi_sw = 1;			/*  by means of a PI	       */
     3191       call addr_status (b.b_.l.le, b.b_.r.re);
     3192       if (b_stat = B_LO_HI)		/* range is split,		       */
     3193       then do;			/*   print left part	       */
     3194          call iox_$put_chars (iox_$user_output,
     3195 	    addr (b_c (b.a_.l.re (1))),
     3196 	    b.b_.l.re - b.a_.l.re (1) + 1, 0); /* (ignoring return code)   */
     3197          b.a_.l.re (1) = b.b_.r.le;	/* adjust to look unsplit	       */
     3198          if db_ted
     3199          then call ioa_$ioa_switch (db_output, "---- hole ----");
     3200       end;
     3201 				/* here always looks like unsplit    */
     3202       call iox_$put_chars (iox_$user_output,
     3203 	 addr (b_c (b.a_.l.re (1))),
     3204 	 b.a_.r.le (2) - b.a_.l.re (1) + 1, 0);
     3205 end_pr:
     3206       pi_sw = 0;			/* turn off PI handling	       */
     3207 
     3208    end print; 
     3209 dcl fcbsp		ptr;
     3210 dcl fo_name	char (7);
     3211 dcl fop		ptr;		/* -> destination of file_out	       */
     3212 detach: proc (finish);
     3213 
     3214 dcl finish	bit (1);
     3215 
     3216       fo_sw = "0"b;
     3217       begin;
     3218          got_quit = "0"b;		/* We can't be interrupted while we  */
     3219          on quit got_quit = "1"b;	/* ..are messing with switches       */
     3220          call iox_$detach_iocb (iox_$user_output, code);
     3221          if (code ^= 0)
     3222          then do;
     3223 	  call com_err_ (code, DBA, "detach user_output");
     3224          end;
     3225          call iox_$move_attach (fcbsp, iox_$user_output, code);
     3226          if (code ^= 0)
     3227          then do;
     3228 	  call com_err_ (code, DBA, "move attach ^asave", fo_name);
     3229          end;
     3230          call iox_$close (fcbp, code);
     3231          call iox_$detach_iocb (fcbp, code);
     3232          if (code ^= 0)
     3233          then do;
     3234 	  call com_err_ (code, DBA, "detach ted_fo");
     3235          end;
     3236          revert quit;		/* Now we can be interrupted again   */
     3237       end;
     3238       if got_quit			/* If he tried to get thru earlier,  */
     3239       then signal quit;		/* ..give it to him now.	       */
     3240       if finish
     3241       then return;
     3242       old_bp = bp;
     3243       bp = fop;
     3244       call hcs_$initiate_count (pdname, "ted_." || dbase.rq_id, "", bc, 0,
     3245 	 tbp, code);
     3246       if (tbp = null)
     3247       then do;
     3248          call com_err_ (code, "ted", "output_file (^a>ted_.^a)", pdname,
     3249 	    dbase.rq_id);
     3250       end;
     3251       else do;
     3252          call delete$all;		/* iso_line not needed	       */
     3253          call add_2l (ted_safe, tbp, divide (bc, 9, 21, 0), NLct_unknown);
     3254          call hcs_$truncate_seg (tbp, 0, 0);
     3255          call hcs_$terminate_noname (tbp, 0);
     3256       end;
     3257       if ^b.force_name
     3258       then do;
     3259          b.file_sw = "0"b;
     3260          b.dname = "";
     3261       end;
     3262       b.a_.l.le (0), b.a_.l.re (0) = 1;
     3263       b.a_.r.le (0), b.a_.r.re (0) = addr_undef;
     3264       b.get_bit_count = "0"b;
     3265       bp = old_bp;
     3266 dcl old_bp	ptr;
     3267 
     3268    end detach; 
     3269 
     3270 
     3271 
     3272 dcl superfile	char (196) int static init (
     3273 		"l t|		CONTENTS|
     3274 b(arg1) ?1,1n t| (match ""| p t|"")| S|/|\c\c/| >s
     3275 a ^\F
     3276 :s b(exec) l l
     3277 >a \B(exec)
     3278 l l Q
     3279 :a /^		/ s/// +3*/^""/ s/$/                                 / (33),+3(1)d
     3280 */\B(arg1)/ p
     3281 >a
     3282 
     3283 "); 




     3284 /* . . . MSG_PATH . . */
     3285 
     3286 msg_path: proc (mark1);
     3287 
     3288 dcl mark1		char (*);
     3289 
     3290 /* RW 88 */
     3291       msg = rtrim (msg) || " " || ltrim (rtrim (fd.dname)); /*#197*/
     3292       if (msg ^= ">")
     3293       then msg = msg || ">";
     3294       msg = msg || rtrim (fd.ename);
     3295       if (mark1 = " ")
     3296       then return;
     3297       msg = msg || mark1;
     3298       if (mark1 = ":")
     3299       then msg = msg || ":";
     3300       msg = msg || rtrim (fd.cname);
     3301 
     3302    end msg_path; 


     3303 ck_blank: proc;
     3304 
     3305       if (ted_mode ^= COM)
     3306       then if (index ("
     3307 	 ", rl_c (rl_i)) = 0)
     3308 	 then goto err_Snb;
     3309 
     3310    end ck_blank;
     3311 
     3312 ignore_1: proc;
     3313 
     3314 /**** tell user that 1st addr will be ignored if present (in qedx mode)      */
     3315       if ^b.present (2)		/* if there isn't any 2nd addr..     */
     3316       then return;			/*  ..AOK			       */
     3317       if ^qedx_mode			/* This warning only occurs in       */
     3318       then goto not_2;		/* ..qedx mode.		       */
     3319       b21 = "1st";
     3320       goto common;
     3321 
     3322 ignore_2: entry;
     3323 
     3324 /**** tell user that 2nd addr will be ignored if present (in qedx mode)      */
     3325       if ^b.present (2)		/* if there isn't any 2nd addr..     */
     3326       then return;			/*   ..no sweat		       */
     3327       if ^qedx_mode			/* if not in qedx mode	       */
     3328       then do;			/* ..jump on him about it	       */
     3329 not_2:
     3330          msg = "Sn2) 2 addrs not allowed.";
     3331          goto add_request;
     3332       end;
     3333       b21 = "2nd";
     3334       goto common;
     3335 
     3336 ignore_all: entry;			/* ignore buffer change & addr's     */
     3337 
     3338 dcl b21		char (4);
     3339 
     3340       bp = ptr (dbase_p, dbase.cb_c_r);
     3341       cb_w_r = rel (bp);
     3342 
     3343 ignore_both: entry;			/* keep buffer change, ignore addr's */
     3344 
     3345 /**** tell user that both addr will be ignored if present (in qedx mode)     */
     3346       if ^b.present (1)		/* if no addr..		       */
     3347       then return;			/*   ..all is well		       */
     3348       if ^qedx_mode			/* if not in qedx mode	       */
     3349       then do;			/* ..complain		       */
     3350          msg = "Sn1) No addrs allowed.";
     3351          goto add_request;
     3352       end;
     3353       b21 = "both";
     3354 common:
     3355       call ioa_ ("Warning: ^a ignores ^a addr.", req_str, b21);
     3356 
     3357    end ignore_1; 
     3358 scan: proc;
     3359 
     3360 dcl ch		char (1);
     3361 
     3362       delim = rl_c (rl_i);		/* pick up str delimiter	       */
     3363       if (delim = " ")
     3364 	 | (delim = NL)
     3365       then goto err_Sd1;
     3366       expr_b = rl_i + 1;
     3367       concealsw = "0"b;
     3368       do rl_i = rl_i + 1 to rl_l;	/* try to find end of str1      */
     3369          if ^concealsw
     3370          then do;
     3371 	  ch = rl_c (rl_i);
     3372 	  if (ch = delim)
     3373 	  then goto sub1;
     3374 	  if (ch = BS_C)
     3375 	  then concealsw = "1"b;
     3376 	  if (ch = "\")
     3377 	  then do;
     3378 	     if (rl_c (rl_i + 1) = "c")
     3379 	     then goto bs_c;
     3380 	     if (rl_c (rl_i + 1) = "C")
     3381 	     then do;
     3382 bs_c:
     3383 	        rl_i = rl_i + 1;
     3384 	        concealsw = "1"b;
     3385 	     end;
     3386 	  end;
     3387          end;
     3388          else concealsw = "0"b;
     3389       end;
     3390 
     3391       goto err_Sd2;			/*  no end of str1		       */
     3392 
     3393 sub1:
     3394       expr_l = rl_i - expr_b;
     3395       j, rl_i = rl_i + 1;		/*  first char of str2	       */
     3396 
     3397    end scan; 
     3398 dcl (
     3399     B_MT		init (0),		/* buffer empty		       */
     3400     B_LO_LO	init (1),		/* range is in low part	       */
     3401     B_LO_HI	init (2),		/* range spans the hole	       */
     3402     B_HI_HI	init (3)		/* range is in high part	       */
     3403     )		fixed bin int static options (constant);
     3404 
     3405 dcl b_stat	fixed bin;
     3406 dcl b_lhe		fixed bin (21);
     3407 dcl b_rhe		fixed bin (21);
     3408 
     3409 addr_status_ends_set: proc (lhe, rhe);	/* set address and then...	       */
     3410       b.a_.l.re (1) = lhe;
     3411       b.a_.r.le (2) = rhe;
     3412 
     3413 addr_status_ends: entry (lhe, rhe);	/* give status & left/right ends     */
     3414 
     3415 dcl (lhe, rhe)	fixed bin (21);	/* left-hand/right-hand ends to use  */
     3416 
     3417 /**** The A's represent the addressed range.			       */
     3418 /**** ................     buffer empty   --> b_stat = B_MT    (0)	       */
     3419 /**** xxAAAAxx...xxxxx - al=low   ar=low  --> b_stat = B_LO_LO (1)	       */
     3420 /**** xxxxxAAA...AAxxx - al=low   ar=high --> b_stat = B_LO_HI (2)	       */
     3421 /**** xxxx.....xAAAxxx - al=high  ar=high --> b_stat = B_HI_HI (3)	       */
     3422 /****	Any other conditions will cause an error message to be printed.    */
     3423 /**** b_lhe, b_rhe contain actual left and right data locations in buffer.   */
     3424 
     3425       if (b.cur.sn = 0)
     3426       then do;
     3427          b_stat = B_MT;
     3428          goto finis;
     3429       end;
     3430       b_lhe = lhe;			/* find lefthand end	       */
     3431       if (b.b_.l.re < b_lhe)		/* is lower part empty?	       */
     3432       then b_lhe = b.b_.r.le;		/* ..switch to upper	       */
     3433       b_rhe = rhe;			/* find righthand end	       */
     3434       if (b.b_.r.le > b_rhe)		/* is upper part empty?	       */
     3435       then b_rhe = b.b_.l.re;		/* ..switch to lower	       */
     3436       if db_ted
     3437       then call ioa_$ioa_switch (db_output, ".   :ends=^i,^i", b_lhe, b_rhe);
     3438 
     3439 addr_status: entry (lhe, rhe);	/* give status only		       */
     3440       if (b.cur.sn = 0)
     3441       then do;
     3442          b_stat = B_MT;
     3443          goto finis;
     3444       end;
     3445 /**** If there is an upper part & addr-left is just after lower part	       */
     3446       if (b.b_.r.re >= b.b_.r.le) & (b.a_.l.re (1) = b.b_.l.re + 1)
     3447       then b.a_.l.re (1) = b.b_.r.le;	/* switch to upper part	       */
     3448 /**** If there is a lower part & addr-right is just before upper part	       */
     3449       else if (b.b_.l.re >= b.b_.l.le) & (b.a_.r.le (2) = b.b_.r.le - 1)
     3450       then b.a_.r.le (2) = b.b_.l.re;	/* switch to lower part	       */
     3451       if (b.b_.l.re + 1 >= b.a_.l.re (1))
     3452       then do;
     3453          if (b.b_.l.re + 1 >= b.a_.r.le (2))
     3454          then do;
     3455 	  b_stat = B_LO_LO;
     3456 	  goto finis;
     3457          end;
     3458          if (b.b_.r.le <= b.a_.r.le (2))
     3459          then do;
     3460 	  b_stat = B_LO_HI;
     3461 	  goto finis;
     3462          end;
     3463       end;
     3464       else if (b.b_.r.le <= b.a_.l.re (1))
     3465 	 & (b.b_.r.le <= b.a_.r.le (2))
     3466       then do;
     3467          b_stat = B_HI_HI;
     3468 finis:
     3469          if db_ted
     3470          then call ioa_$ioa_switch (db_output, ".   :stat=^a",
     3471 	         substr ("MTLLLHHH", b_stat * 2 + 1, 2));
     3472          return;
     3473       end;
     3474       call ioa_ ("Error: b=^i,^i,^i,^i a=^i,^i", lhe, b.b_.l.re, b.b_.r.le,
     3475 	 rhe, b.a_.l.re (1), b.a_.r.le (2));
     3476       msg = "Aae) Addressing error occurred.";
     3477       goto print_error;
     3478 
     3479    end addr_status_ends_set; 
     3480 buffer_buffer_copy: proc (asbp, adbp, add_right);
     3481 
     3482 dcl asbp		ptr,		/* source buffer control block       */
     3483 				/* range to copy is-	       */
     3484 				/*    b.cd.l.re : b.cd.r.le	       */
     3485     adbp		ptr,		/* destination buffer control block  */
     3486 				/* data is INSERTed at-	       */
     3487 				/*    b.cd.r.re		       */
     3488     add_right	bit (1);		/* 0- data is added to left of hole  */
     3489 				/* 1- data is added right	       */
     3490 
     3491 dcl old_bp	ptr;
     3492 dcl (sbp, dbp)	ptr;		/* -> source, destination ctl block  */
     3493 dcl tbp		ptr;
     3494 dcl lndx		fixed bin (21) based; /* left index for cpy_2 call      */
     3495 dcl (l, tl, tr)	fixed bin (21);
     3496 
     3497 /**** Care must be taken to avoid being wiped out when source = destination. */
     3498 /**** These are various conditions which can happen when they are.	       */
     3499 /****   The "A"s represent the address range.			       */
     3500 /****   The "I"s represent the inserted data.			       */
     3501 /****   The "x"s represent the uninvolved data			       */
     3502 /****   The "."s represent the gap		Col 2 only happens with K. */
     3503 /**** Line 1  points to the destination.			       */
     3504 /**** Line 2  is the initial buffer state.			       */
     3505 /**** Line 3  is the state after openup.			       */
     3506 /**** Line 4  is the state after moving left part of range, if any.	       */
     3507 /**** Line 5  is the state after moving right part, if any.		       */
     3508 /**** Line 6  is the state after deletion (M only).		       */
     3509 
     3510 /**** Inserting in ?, ? addressed data.		?, ? pairs shown below     */
     3511 /****							       */
     3512 /**** ?,? |    upper, above    |   upper, within    |   upper, below     |   */
     3513 /**** 1)  |  ..........v.....  |  ..........v.....  |  ..........v.....  |   */
     3514 /**** 2)  |  AAAxx....xxxxxxx  |  xxx......AAAAxxx  |  xx....xxxxxxAAAx  |   */
     3515 /**** 3)  |  AAAxxx....xxxxxx  |  xxxA......AAAxxx  |  xxxxxx....xxAAAx  |   */
     3516 /**** 4)  |  AAAxxxMMM.xxxxxx  |  xxxAM.....AAAxxx  |		   |   */
     3517 /**** 5)  |                    |  xxxAMNNN..AAAxxx  |  xxxxxxNNN.xxAAAx  |   */
     3518 /**** 6)  |  ....xxxMMMxxxxxx  |                    |  xxxxxxNNNxx....x  |   */
     3519 
     3520 /**** ?,? |    lower, above    |   lower, within    |   lower, below     |   */
     3521 /**** 1)  |  ...v............  |  ....v...........  |  ...v............  |   */
     3522 /**** 2)  |  AAAxx....xxxxxxx  |  xxxAAAA......xxx  |  xxxxxxx....xAAAx  |   */
     3523 /**** 3)  |  AAA....xxxxxxxxx  |  xxxA......AAAxxx  |  xxx....xxxxxAAAx  |   */
     3524 /**** 4)  |  AAAMMM.xxxxxxxxx  |  xxxAM.....AAAxxx  |		   |   */
     3525 /**** 5)  |                    |  xxxAMNNN..AAAxxx  |  xxxNNN.xxxxxAAAx  |   */
     3526 /**** 6)  |  ....xxxMMMxxxxxx  |                    |  xxxxxxNNNxx....x  |   */
     3527 
     3528       sbp = asbp;			/* save parameter values, they get   */
     3529       dbp = adbp;			/* ..clobbered sometimes	       */
     3530       old_bp = bp;			/* keep current bp value	       */
     3531 
     3532       if db_ted
     3533       then do;
     3534          call ioa_$ioa_switch (db_output, ">bbc: b(^a,^i,^i)->b(^a,^i)^[right^;left^]",
     3535 	    sbp -> b.name, sbp -> b.cd.l.re, sbp -> b.cd.r.le,
     3536 	    dbp -> b.name, dbp -> b.cd.r.re, add_right);
     3537          if (sbp = dbp)
     3538          then call tedshow_ (sbp, ". s=d cd adr");
     3539          else do;
     3540 	  call tedshow_ (sbp, ". sb cd adr");
     3541 	  call tedshow_ (dbp, ". db cd adr");
     3542          end;
     3543       end;
     3544 
     3545       if (sbp -> b.cur.sn = 0)
     3546       then do;			/* The source is empty	       */
     3547          msg = "b(";
     3548          msg = msg || rtrim (sbp -> b.name);
     3549          msg = msg || ")";
     3550          call tederror_rc_ (dbase_p, msg,
     3551 	    (tederror_table_$zero_length_buffer));
     3552       end;
     3553 
     3554 /***** DESTINATION buffer  * * * * * * * * * * * * * * * * * * * * * * * * * */
     3555       bp = dbp;
     3556       b.a_.l.re (1), b.a_.r.le (2) = b.cd.r.re; /* set openup point	       */
     3557       call openup;			/* move hole to where data is to go  */
     3558       if (b.b_.r.re = 0)
     3559       then b.a_.r.le (1) = 0;		/* note buffer was empty	       */
     3560       else b.a_.r.le (1) = b.b_.r.le;	/* keep rle before data moved in     */
     3561       if db_ted then call tedshow_ (bp, "a1");
     3562 
     3563 /***** SOURCE buffer * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
     3564       bp = sbp;
     3565       call addr_status_ends (1, b.maxl);
     3566 
     3567       b.cd.l.re = max (b.cd.l.re, b_lhe);
     3568       b.cd.r.le = min (b.cd.r.le, b_rhe);
     3569       if (b_lhe = b.cd.l.re) & (b_rhe = b.cd.r.le) /* taking all there is?   */
     3570       then b.not_pasted = "0"b;	/* no longer worry		       */
     3571 
     3572 /**** When doing a move request within a buffer, the buffer will never be    */
     3573 /**** ..split at this point because openup has already been done at the      */
     3574 /**** ..destination. The destination may not be within the source.	       */
     3575       if (b_stat = B_LO_HI)		/* range being read is split	       */
     3576       then do;
     3577          tr = b.cd.r.le - b.b_.r.le + 1;/* calc right length	   #1xx*/
     3578          tl = b.b_.l.re - b.cd.l.re + 1;/* calc left  length	   #1xx*/
     3579          if add_right
     3580          then do;
     3581 	  tbp = addr (b.b_.r.le);	/* -> index of left of right part    */
     3582 	  l = tr;			/* #1xx*/
     3583          end;
     3584          else do;
     3585 	  tbp = addr (b.cd.l.re);	/* -> index of right of left part#1xx*/
     3586 	  l = tl;			/* #1xx*/
     3587          end;
     3588 /*****		DESTINATION buffer * * * * * * * * * * * * * * * * * * * */
     3589          bp = dbp;			/* switch to destination	       */
     3590          call cpy_2 (ted_safe, sbp -> b.cur.sp, l, NLct_unknown, tbp -> lndx,
     3591 	    add_right);		/* #1xx*/
     3592 /*****		SOURCE buffer  * * * * * * * * * * * * * * * * * * * * * */
     3593          bp = sbp;			/* switch to source again	       */
     3594          if add_right
     3595          then do;			/* #1xx*/
     3596 	  tbp = addr (b.cd.l.re);	/* -> index of right of left part#1xx*/
     3597 	  l = tl;			/* #1xx*/
     3598          end;			/* #1xx*/
     3599          else do;			/* #1xx*/
     3600 	  tbp = addr (b.b_.r.le);	/* -> index of left of right part#1xx*/
     3601 	  l = tr;			/* #1xx*/
     3602          end;			/* #1xx*/
     3603       end;
     3604       else do;			/* #1xx*/
     3605          tbp = addr (b.cd.l.re);	/* -> index of left of string	   #1xx*/
     3606          l = b.cd.r.le - b.cd.l.re + 1; /* calc length to move	   #1xx*/
     3607       end;			/* #1xx*/
     3608 /***** DESTINATION buffer  * * * * * * * * * * * * * * * * * * * * * * * * * */
     3609       bp = dbp;
     3610       call cpy_2 (ted_safe, sbp -> b.cur.sp, l, NLct_unknown, tbp -> lndx,
     3611 	 add_right);
     3612       if db_ted
     3613       then do;
     3614          call tedshow_ (dbp, ". db b_ a1");
     3615          call ioa_$ioa_switch (db_output, "<bbc");
     3616       end;
     3617       bp = old_bp;			/* restore old bp value	       */
     3618       asbp = sbp;			/* restore the parameters	       */
     3619       adbp = dbp;
     3620 
     3621    end buffer_buffer_copy; 
     3622 mov_2l:				/* move buffer data to the left      */
     3623    proc (safe_mode, Aastr_p, astr_l, NLct);
     3624 dcl (
     3625     safe_mode	bit (1) aligned,	/* 1- ensure strings don't overlay   */
     3626 				/* 0- don't worry about it	       */
     3627     Aastr_p	ptr,		/* -> string to add (^cpy_2)	       */
     3628 				/* -> base of string to add (cpy_2)  */
     3629     astr_l	fixed bin (21),	/*   length thereof		       */
     3630     NLct		fixed bin (21)	/*  -1 - don't know		       */
     3631 				/*  -2 - find out now many	       */
     3632 				/* >=0 - number present	       */
     3633     )		parm;
     3634 
     3635 dcl add_right	bit (1);		/* 0- add to left end of hole	       */
     3636 				/* 1- add to right end of hole       */
     3637 dcl make_room	bit (1);		/* 0- just moving the hole	       */
     3638 				/* 1- adding to buffer, make sure    */
     3639 				/*    there is enough room	       */
     3640 dcl adj		fixed bin (21);
     3641 dcl id		char (3);
     3642 
     3643       id = "m2l";
     3644       add_right = "0"b;
     3645       make_room = "0"b;
     3646       goto start;
     3647 
     3648 mov_2r:				/* move buffer data to the right     */
     3649    entry (safe_mode, Aastr_p, astr_l, NLct);
     3650       id = "m2r";
     3651       add_right = "1"b;
     3652       make_room = "0"b;
     3653       goto start;
     3654 
     3655 add_2l:				/* add data to the left of hole      */
     3656    entry (safe_mode, Aastr_p, astr_l, NLct);
     3657       id = "a2l";
     3658       add_right = "0"b;
     3659       make_room = "1"b;
     3660       goto start;
     3661 
     3662 add_2r:				/* add data to the right of hole     */
     3663    entry (safe_mode, Aastr_p, astr_l, NLct);
     3664       id = "a2r";
     3665       add_right = "1"b;
     3666       make_room = "1"b;
     3667       goto start;
     3668 
     3669 cpy_2:				/* add data where specified	       */
     3670    entry (safe_mode, Aastr_p, astr_l, NLct, lindex, which_side);
     3671 /****Aastr_p -> -> BASE of string				       */
     3672 dcl lindex	fixed bin (21);	/* index of left end of string       */
     3673 dcl which_side	bit (1);
     3674 /**** buffer_buffer_copy calls this entry.  One of the circumstances which   */
     3675 /****  can occur is 1) source-buffer=destination-buffer 2) promotion occurs. */
     3676 /**** Thus this entry points to the pointer and points to the left index so  */
     3677 /****  that if the source string gets moved, the reference to it will keep   */
     3678 /****  up with it.						       */
     3679       add_right = which_side;
     3680       if add_right
     3681       then id = "c2r";
     3682       else id = "c2l";
     3683       make_room = "1"b;
     3684       astr_p = addcharno (Aastr_p, lindex - 1);
     3685       if ""b
     3686       then do;
     3687 start:
     3688          astr_p = Aastr_p;
     3689       end;
     3690       if (astr_l = 0)
     3691       then return;
     3692       adj = NLct;
     3693       if (adj = -2)
     3694       then do;
     3695          j = index (astr, NL);
     3696          if (j = 0)
     3697          then do;			/* contains NO new-line	       */
     3698 	  if (b.b_.r.le > b.b_.r.re)	/* if upper part empty	       */
     3699 	  then adj = -1;		/* can't tell what change it makes   */
     3700 	  else adj = 0;		/* makes no change in linecount      */
     3701          end;
     3702          else if (j = astr_l)
     3703          then adj = 1;		/* contains ONE new-line	       */
     3704          else adj = -1;		/* >1 new-lines		       */
     3705       end;
     3706       if db_ted
     3707       then do;
     3708          call tedshow_ (bp, ">", id, "b_");
     3709          call ioa_$ioa_switch (db_output, " ^a:    ^[SAFE ^]l=^i adj=^i",
     3710 	    id, safe_mode, astr_l, adj);
     3711       end;
     3712       if (adj = NLct_unknown)
     3713       then do;
     3714          if ^add_right
     3715          then b.b_.l.ln = NLct_unknown;
     3716          b.maxln, b.b_.r.ln = NLct_unknown;
     3717       end;
     3718       else do;
     3719          if (b.maxln ^= -1)
     3720          then b.maxln = b.maxln + adj;
     3721          if (b.b_.l.ln ^= -1) & ^add_right
     3722          then b.b_.l.ln = b.b_.l.ln + adj;
     3723          if (b.b_.r.ln ^= -1)
     3724          then b.b_.r.ln = b.b_.r.ln + adj;
     3725       end;
     3726 
     3727       if make_room			/* adding new data to buffer	       */
     3728       then do;
     3729          b.mod_sw = "1"b;		/* buffer is modified	       */
     3730          hole = b.b_.r.le - b.b_.l.re - 1; /* how much room left	       */
     3731          hole = hole - astr_l;	/* how much left after adding	       */
     3732          if (hole < 0)		/* is enough room left?	       */
     3733          then call promote (-hole);	/* no, must try to get more	       */
     3734          if (substr (id, 1, 2) = "c2")
     3735          then do;
     3736 /**** This chases the source string which may have been moved by promotion.  */
     3737 	  astr_p = addcharno (Aastr_p, lindex - 1);
     3738          end;
     3739       end;
     3740       b.newb = b.b_;
     3741       if ^make_room
     3742       then b.newb.l.ln = NLct_unknown;
     3743       if db_ted & lg_ted
     3744       then if (astr_l > 100)
     3745 	 then call ioa_$ioa_switch (db_output, "astr=""^50a^/<^i chars>^/^50a""^[-->@^i^;<--@^s^i^]",
     3746 		 substr (astr, 1, 50), astr_l - 100, substr (astr, astr_l - 49, 50),
     3747 		 add_right, b.b_.r.le - 1, b.b_.l.re + 1);
     3748 	 else call ioa_$ioa_switch (db_output, "astr=""^va""^[-->@^i^;<--@^s^i^]", astr_l, astr,
     3749 		 add_right, b.b_.r.le - 1, b.b_.l.re + 1);
     3750       if (chars_moved >= 0)
     3751       then chars_moved = chars_moved + astr_l;
     3752       if add_right
     3753       then do;			/* put the data on right via MRL     */
     3754          b.new.re = b.b_.r.le - 1;
     3755          b.new.le = b.b_.r.le - astr_l;
     3756          b.newb.r.le = b.new.le;
     3757          if ^make_room		/* moving data within the buffer?    */
     3758          then do;
     3759 	  b.old.re, b.test.re = b.b_.l.re;
     3760 	  b.old.le, b.test.le = b.old.re - astr_l + 1;
     3761 	  b.test.re = b.test.re + 1;	/* allow l.re+1 to relocate	       */
     3762 	  if (b.test.le = 1)	/* if at beginning of buffer	       */
     3763 	  then b.test.le = b.test.le - 1; /* ..allow l.le-1 also	       */
     3764 	  b.newb.l.re = b.old.le - 1;
     3765          end;
     3766          call mrl_ (astr_p, astr_l, addr (b_c (b.new.le)), astr_l);
     3767       end;
     3768       else do;			/* put the data on left via MLR      */
     3769          b.new.le = b.b_.l.re + 1;	/* figure where its going to	       */
     3770          b.new.re = b.new.le + astr_l - 1;
     3771          b.newb.l.re = b.new.re;
     3772          if ^make_room		/* moving data within buffer?	       */
     3773          then do;			/* figure where its coming from      */
     3774 	  b.old.le, b.test.le = b.b_.r.le;
     3775 	  b.old.re, b.test.re = b.old.le + astr_l - 1;
     3776 	  b.test.le = b.test.le - 1;	/* allow r.le-1 to relocate	       */
     3777 	  if (b.test.re = b.maxl)	/* if at end of buffer	       */
     3778 	  then b.test.re = b.test.re + 1; /* ..allow r.re+1 also	       */
     3779 	  b.newb.r.le = b.old.re + 1;
     3780          end;
     3781          substr (b_s, b.new.le, astr_l) = astr;
     3782          if db_ted then call ioa_$ioa_switch (db_output,
     3783 /****	         1                 2  3   4            5		       */
     3784 	         "a2*: (^p->b_s,b.new.le(^i),^i)=^p->astr,len=^i",
     3785 	         b.cur.sp, b.new.le, astr_l, astr_p, b.new.le + astr_l - 1);
     3786       end;
     3787       if make_room
     3788       then call update;
     3789       else call relocate;
     3790       if db_ted
     3791       then call tedshow_ (bp, "< b_"); 

     3792 dcl astr		char (astr_l) based (astr_p);
     3793 dcl astr_p	ptr;
     3794 dcl hole		fixed bin (21);	/* size of hole		       */
     3795 
     3796    end mov_2l; 
     3797 delete:				/* delete a string from a buffer     */
     3798    proc;
     3799 
     3800 /**** The string to remove is defined by:   b.a_.l.re (1) : b.a_.r.le (2)  */
     3801 /**** Upon exit, l.re (1), r.le (2) = r.le (2) + 1;		       */
     3802 
     3803       if db_ted
     3804       then call tedshow_ (bp, "> del max adr");
     3805       call addr_status_ends (1, b.maxl);
     3806       if (b_lhe = b.a_.l.re (1)) & (b_rhe = b.a_.r.le (2))
     3807       then do;			/* deleting whole thing	       */
     3808 dcl which		char (1);
     3809          if ""b
     3810          then do;
     3811 delete$all: entry;
     3812 	  which = ".";
     3813          end;
     3814          else which = "<";
     3815          if db_ted
     3816          then call tedshow_ (bp, which, "[all b(" || rtrim (b.name) || ")");
     3817          call demote (0);		/* get rid of buffer space	       */
     3818          b.a_ (1) = tedcommon_$no_data;
     3819          b.a_ (2) = tedcommon_$no_data;
     3820          b.ex = tedcommon_$no_data;
     3821          b.mod_sw = "1"b;
     3822          return;
     3823       end;
     3824 
     3825       if b.pseudo			/* if ^read file..		       */
     3826       then do;
     3827          call promote (b.maxl);	/* ..then get it read	       */
     3828          call addr_status (b.b_.l.le, b.b_.r.re);
     3829       end;
     3830 
     3831 /**** select action based on where left and right ends of range are	       */
     3832 
     3833       if (b_stat = B_LO_LO)
     3834       then do; 


     3835 /****	Before:  xxxxxxAAAAyyyyyy............zzzzzzzzzz	al=low	       */
     3836 /****	openup:  xxxxxxAAAA............yyyyyyzzzzzzzzzz	ar=low	       */
     3837 /****	 After:  xxxxxx................yyyyyyzzzzzzzzzz		       */
     3838 /****	   ".":			 |			       */
     3839 /**** When AAAA is addressed, usually characters AAAAyyyyyy will be moved    */
     3840 /****  before the work begins. However, when deleting, only characters       */
     3841 /****  yyyyyy need to be moved before doing the adjust. The rest are going   */
     3842 /****  to be thrown away. We don't even care if zzzzzzzzzz is null.	       */
     3843 
     3844          b.a_.r.re (1) = b.a_.l.re (1); /* save beginning of range where it  */
     3845 				/*  will be relocated	       */
     3846          b.a_.l.re (1) = min (b.a_.r.le (2) + 1, b.b_.r.re + 1);
     3847 				/* set left of moved data      */
     3848          call openup;
     3849          b.newb = b.b_;
     3850          b.newb.l.re = b.a_.r.re (1) - 1; /* set new buffer left end from   */
     3851 				/*  saved data		       */
     3852       end; 



     3853       else if (b_stat = B_LO_HI)
     3854       then do;
     3855 /**** Before: zzzzzzzAAA............AAAAAyyyyyyyyyyy	al=low	       */
     3856 /****  After: zzzzzzz....................yyyyyyyyyyy	ar=high	       */
     3857 /****    ".":			 |			       */
     3858 /**** When the address spans the hole, adjusting does all		       */
     3859 
     3860          b.newb = b.b_;
     3861          b.newb.l.re = b.a_.l.re (1) - 1; /* set buffer left end	       */
     3862          b.newb.r.le = b.a_.r.le (2) + 1; /* set buffer right end	       */
     3863       end;
     3864       else do;
     3865 /**** Before: zzzzzzzzzz............xxxxxxAAAAyyyyyy	al=high	       */
     3866 /**** openup: zzzzzzzzzzxxxxxx............AAAAyyyyyy	ar=high	       */
     3867 /****  After: zzzzzzzzzzxxxxxx................yyyyyy		       */
     3868 /****    ".":			      |			       */
     3869 /**** When AAAA is addressed, characters xxxxxx are moved. Then the data is  */
     3870 /****  removed by adjusting.					       */
     3871 
     3872          call openup;
     3873          b.newb = b.b_;
     3874          if (b.b_.r.le <= b.b_.r.re)	/* if right part not empty	       */
     3875          then			/* ..set buffer right end	       */
     3876 	    b.newb.r.le = min (b.b_.r.re + 1, b.a_.r.le (2) + 1);
     3877       end; 



     3878 /**** must get smarter about line number handling			       */
     3879       b.newb.l.ln, b.newb.r.ln, b.maxln = NLct_unknown;
     3880       b.mod_sw = "1"b;
     3881 				/* set "." to first char after       */
     3882       call update;
     3883       b.a_.r.le (2) = b.b_.r.le;	/* fall off end?		       */
     3884       if db_ted
     3885       then call tedshow_ (bp, "< adr");
     3886 				/* ?should check for refs to data?   */
     3887       return;
     3888 
     3889    end delete; 
     3890 /**** open up the hole at designated location in current window of	       */
     3891 /****  designated buffer					       */
     3892 /****  ASSUMPTION: the hole is always within this window		       */
     3893 openup: proc;
     3894 
     3895       if db_ted
     3896       then call tedshow_ (bp, "> opn b_");
     3897       if b.invoking
     3898       then do;			/* #156*/
     3899          msg = "Bnm) Attempting to modify a buffer while it is being invoked.";
     3900          goto print_error;		/* #156*/
     3901       end;			/* #156*/
     3902       if b.pseudo			/* if ^read file then get it read    */
     3903       then call promote (b.maxl);	/*   first		       */
     3904       at = b.a_.l.re (1);
     3905 
     3906 /*common:*/
     3907       if db_ted
     3908       then call ioa_$ioa_switch (db_output, "    : b(^a)@^i", b.name, at);
     3909       action = "no seg";
     3910       if (b.cur.sn = 0)		/* if no segment, then there is...   */
     3911       then goto finis;		/*   ...only hole: you're in it.     */
     3912 
     3913       action = "already";
     3914       if (at = b.b_.r.le) | (at = b.b_.l.re + 1)
     3915       then goto finis;		/* already there		       */
     3916 
     3917 /**** If running in SAFE mode, the move must be done ensuring that the       */
     3918 /****  source and destination strings never overlap. If they did and a crash */
     3919 /****  occurred in the middle, there would be no way to restart the	       */
     3920 /****  operation. If not safe, then we don't care because we will never have */
     3921 /****  to try to restart. add takes this into account.		       */
     3922 
     3923       if (at > b.b_.l.re)		/* not in left part?	       */
     3924       then do;
     3925          if (at < b.b_.r.le)		/* in the hole?		       */
     3926          then do;
     3927 	  if (at = b.maxl)		/* right part empty?	       */
     3928 	  then goto finis;
     3929 	  signal condition (at_in_gap); dcl at_in_gap condition;
     3930          end;
     3931 				/* move left end of right part down  */
     3932          len = min (at, b.maxl + 1) - b.b_.r.le;
     3933          call mov_2l (ted_safe, addr (b_c (b.b_.r.le)), len, 0);
     3934       end;
     3935       else do;			/* move right end of left part down  */
     3936          len = b.b_.l.re - at + 1;
     3937          call mov_2r (ted_safe, addr (b_c (at)), len, 0);
     3938       end;
     3939       action = "";
     3940 finis:
     3941       if db_ted
     3942       then call tedshow_ (bp, "< [" || action);
     3943       return; 

     3944 dcl action	char (8);
     3945 dcl len		fixed bin (21);
     3946 dcl at		fixed bin (21);
     3947 
     3948    end openup; 
     3949 promote: proc (alen);
     3950       seg_sw = "pro";
     3951       if db_ted
     3952       then call tedshow_ (bp, "> pro max [" || ltrim (char (alen)));
     3953       dbase_p = ptr (bp, 0);		/* manufacture database ptr	       */
     3954 
     3955       len = alen + buf_max (b.cur.ast); /* how much total space needed    */
     3956       if (len > buf_max (1))
     3957       then do;
     3958          msg = "Xde) Data exceeds ";
     3959          msg = msg || ltrim (char (buf_max (1)));
     3960          msg = msg || " characters; request aborted.";
     3961          goto print_error;
     3962       end;
     3963       goto common;
     3964 
     3965 dcl seg_sw	char (3);
     3966 promote$seg: entry;
     3967       seg_sw = "p$s";
     3968       len = (b.b_.l.re - b.b_.l.le + 1) + (b.b_.r.re - b.b_.r.le + 1);
     3969       if db_ted
     3970       then call tedshow_ (bp, "> p$s max [" || ltrim (char (len)));
     3971 dcl (
     3972     alen		fixed bin (21)	/* amount of data which does not...  */
     3973     )		parm;		/*   ...fit in the current buffer    */
     3974 
     3975 /* this routine is called under these circumstances:		       */
     3976 /*  1) openup/delete in a ^read file; the file is "materialized".	       */
     3977 /*  2) add doesn't have a hole big enough for the data		       */
     3978 /*  3) buffer needs its own segment ([ted_buffer] or qhold use)	       */
     3979 
     3980 /* These are the various states of b.* (known as of 80-11-15)	       */
     3981 /*   name       sp       sn,pn,ast lle:lre       rle:rre		       */
     3982 /* b((ted))  234|32174   -1, 0, 0    1:67         69:68	-req data	       */
     3983 /* b((val))  77777|1      0, 1, 0    1:0           1:0	EMPTY	       */
     3984 /* b(args)   537|4000     1, 3, 0    1:13       4097:4096	PSEUDO (real)    */
     3985 /* b(arg1)   537|4000     1, 0, 0    1:5           7:6	PSEUDO (refer)   */
     3986 /* b(arg2)   537|4001(18) 1, 0, 0    1:6           8:7	PSEUDO (refer)   */
     3987 /* b(0)      622|0       -1, 0, 0    1:265894 265896:265894	^read file       */
     3988 /* b(1)      537|6000     1, 4, 5    1:0        1478:4097	read file	       */
     3989 /* b(2)      541|0        4, 1, 5    1:2620     4097:4096	[ted_buffered]   */
     3990 
     3991 common:
     3992 /**** Find buffer size which will hold the required amount.	       */
     3993       b.pend = tedcommon_$no_seg;
     3994       do b.pend.ast = 1 to hbound (buf_max, 1) - 1
     3995 	 while (buf_max (b.pend.ast + 1) >= len);
     3996       end;
     3997 
     3998       if (b.cur.ast <= b.pend.ast) & (b.cur.ast ^= 0) & (seg_sw = "pro")
     3999       then do;			/* are they trying to demote?	       */
     4000          msg = buf_size (b.cur.ast);
     4001          msg = msg || "K->";
     4002          msg = msg || buf_size (b.pend.ast);
     4003          msg = msg || "K logic error";
     4004          goto print_error;
     4005       end;
     4006 
     4007       b.newb = b.b_;
     4008       b.old.le, b.test.le = b.b_.r.le;
     4009       b.old.re, b.test.re = b.b_.r.re;
     4010       b.test.re = b.test.re + 1;	/* moving the data upward, so allow  */
     4011 				/*  1 more on high end since many    */
     4012 				/*  requests go until "this">"last". */
     4013 				/*  "this" can be outside of the     */
     4014 				/*  range and would not then get     */
     4015 				/*  relocated.		       */
     4016 /**** For right now r.le-1 is left stranded in gap. Can it happen?	       */
     4017       len = b.old.re - b.old.le + 1;	/* calc how much is being moved      */
     4018       b.new.re, b.newb.r.re = buf_max (b.pend.ast);
     4019       b.new.le, b.newb.r.le = b.new.re - len + 1;
     4020       if (b.cur.sn > 2) & ^b.pseudo	/* already have its own segment?     */
     4021       then do;
     4022          b.pend.sp = b.cur.sp;
     4023          b.pend.sn = b.cur.sn;
     4024          if (seg_sw = "pro")
     4025          then goto do_move;		/* we will just expand in place      */
     4026          b.new.le = b.b_.l.re + 1;
     4027          b.new.re = b.new.le + len - 1;
     4028          b.newb.r.le = buf_max (b.pend.ast) + 1;
     4029          b.newb.l.le = 1;
     4030          b.newb.l.re = b.new.re;
     4031          substr (b_s, b.new.le, len) = substr (b_s, b.old.le, len);
     4032          if db_ted then call ioa_$ioa_switch (db_output,
     4033 /****        1   2                3   4    5                6   7       8    */
     4034 	         "^a:(^p->b_s,b.new.le(^i),^i)=(^p->b_s,b.old.le(^i),^i),len=^i",
     4035 	         seg_sw, b.cur.sp, b.new.le, len, b.cur.sp, b.old.le, len,
     4036 	         b.new.le + len - 1);
     4037 				/* compressing the segment	       */
     4038          goto no_move;
     4039       end;
     4040       if (seg_sw = "pro")
     4041       then do;
     4042          if (b.pend.ast = 5)		/* smallest size		       */
     4043          then do;
     4044 	  i = index (dbase.inuse_1K, "0"b); /* any room in 1K pool?	       */
     4045 	  if (i = 0)
     4046 	  then do;		/* no, have to try next larger       */
     4047 	     b.pend.ast = 4;
     4048 	     b.new.re, b.newb.r.re = buf_max (b.pend.ast);
     4049 	     b.new.le, b.newb.r.le = b.new.re - len + 1;
     4050 	  end;
     4051 	  else do;		/* yes, we'll take one	       */
     4052 	     if (dbase.seg_p (1) = null ()) /* is there a 1/4K pool?       */
     4053 	     then call tedget_segment_ (dbase_p, dbase.seg_p (1), 1);
     4054 	     b.pend.sp = addr (seg_1K (i));
     4055 	     b.pend.sn = 1;
     4056 	     b.pend.pn = i;
     4057 	     substr (dbase.inuse_1K, i, 1) = "1"b; /* flag it used       */
     4058 	     if db_ted
     4059 	     then call ioa_$ioa_switch (db_output, "    : inuse_1K=^b", dbase.inuse_1K);
     4060 	     if ^b.pseudo
     4061 	     then goto no_move;
     4062 	  end;
     4063          end;
     4064 
     4065          if (b.pend.ast = 4)		/* next smallest size	       */
     4066          then do;
     4067 	  i = index (dbase.inuse_4K, "0"b); /* any room in 4K pool?	       */
     4068 	  if (i = 0)
     4069 	  then do;		/* no, have to try next larger       */
     4070 	     b.pend.ast = 3;
     4071 	     b.new.re, b.newb.r.re = buf_max (b.pend.ast);
     4072 	     b.new.le, b.newb.r.le = b.new.re - len + 1;
     4073 	  end;
     4074 	  else do;		/* yes, we'll take one	       */
     4075 	     if (dbase.seg_p (1) = null ()) /* is there a 1/4K pool?       */
     4076 	     then call tedget_segment_ (dbase_p, dbase.seg_p (1), 1);
     4077 	     b.pend.sp = addr (seg_4K (i));
     4078 	     b.pend.sn = 1;
     4079 	     b.pend.pn = i + 16;
     4080 	     substr (dbase.inuse_4K, i, 1) = "1"b;
     4081 	     if db_ted
     4082 	     then call ioa_$ioa_switch (db_output, "    : inuse_4K=^b", dbase.inuse_4K);
     4083 	     if (b.cur.ast = 0) & ^b.pseudo
     4084 	     then goto no_move;
     4085 	  end;
     4086          end;
     4087 
     4088          if (b.pend.ast = 3)
     4089          then do;
     4090 	  i = index (dbase.inuse_16K, "0"b); /* any room in 16K pool?    */
     4091 	  if (i = 0)
     4092 	  then do;		/* no, have to get full segment      */
     4093 	     b.pend.ast = 2;
     4094 	     b.new.re, b.newb.r.re = buf_max (b.pend.ast);
     4095 	     b.new.le, b.newb.r.le = b.new.re - len + 1;
     4096 	  end;
     4097 	  else do;		/* yes, we'll take one	       */
     4098 	     if (dbase.seg_p (2) = null ()) /* is there a 16K pool?	       */
     4099 	     then call tedget_segment_ (dbase_p, dbase.seg_p (2), 2);
     4100 	     b.pend.sp = addr (seg_16K (i));
     4101 	     b.pend.sn = 2;
     4102 	     b.pend.pn = i;
     4103 	     substr (dbase.inuse_16K, i, 1) = "1"b; /* flag it used       */
     4104 	     if db_ted
     4105 	     then call ioa_$ioa_switch (db_output, "    : inuse_16K=^b", dbase.inuse_16K);
     4106 	     if (b.cur.ast = 0) & ^b.pseudo
     4107 	     then goto no_move;
     4108 	  end;
     4109          end;
     4110       end;
     4111 
     4112       if (b.pend.sp = null ())	/* no current buffer space	       */
     4113       then do;
     4114          b.pend.pn = 1;
     4115          call tedget_segment_ (dbase_p, b.pend.sp, b.pend.sn);
     4116       end;
     4117 
     4118       if (b.cur.ast > 2) & ((b.cur.sn = 1) | (b.cur.sn = 2))
     4119 				/* got a 1K, 4K, or 16K already      */
     4120 	 | b.pseudo		/* ..or a fake one?		       */
     4121       then do;			/* copy left-hand data into new one  */
     4122          if (b.b_.l.re > 0)
     4123          then substr (b.pend.sp -> b_s, 1, b.b_.l.re)
     4124 	         = substr (b_s, 1, b.b_.l.re);
     4125       end;
     4126       if (seg_sw = "p$s")
     4127       then do;
     4128          b.new.le = b.b_.l.re + 1;
     4129          b.new.re = b.new.le + len - 1;
     4130          b.newb.l.re = b.newb.l.re + len;
     4131          b.newb.r.le = b.b_.r.re + 1;
     4132       end;
     4133 do_move:
     4134       if (len > 0)			/* if anything to move...	       */
     4135       then do;			/*   do it		       */
     4136 /**** During this move, the strings can never overlay, but MRL is being used */
     4137 /****  to get the maximum bounds fault out of the way immediately.	       */
     4138          call mrl_ (addr (b_c (b.old.le)), len,
     4139 	    addr (b.pend.sp -> b_c (b.new.le)), len);
     4140       end;
     4141 no_move:
     4142       call relocate;		/* 1) relocate refs to moved data    */
     4143 				/* 1a)(terminate ^read segment)      */
     4144 				/* 2) update b.maxl, b.cur	       */
     4145 				/* 3) update b.b_		       */
     4146       if (seg_sw = "p$s")
     4147       then call hcs_$truncate_seg
     4148 	      (b.cur.sp, divide (b.b_.l.re + 3, 4, 21, 0), 0);
     4149       b.pseudo = ""b;		/* buffer is now for real	       */
     4150       if db_ted
     4151       then call tedshow_ (bp, "max cur < b_");
     4152       return; 


     4153 free_buffer: entry;
     4154       if (b.cur.sn = 1) & (b.cur.ast = 5) /* free up old 1K buffer	       */
     4155       then do;
     4156          substr (dbase.inuse_1K, b.cur.pn, 1) = "0"b;
     4157          seg_1K (b.cur.pn) = low (buf_max (5));
     4158          if db_ted
     4159          then call ioa_$ioa_switch (db_output, "inuse_1K=^b ^i=0", dbase.inuse_1K, b.cur.pn);
     4160       end;
     4161       else if (b.cur.sn = 1) & (b.cur.ast = 4) /* free up old 4K buffer    */
     4162       then do;
     4163          substr (dbase.inuse_4K, b.cur.pn, 1) = "0"b;
     4164          seg_4K (b.cur.pn) = low (buf_max (4));
     4165          if db_ted
     4166          then call ioa_$ioa_switch (db_output, "inuse_4K=^b ^i=0", dbase.inuse_4K, b.cur.pn);
     4167       end;
     4168       else if (b.cur.sn = 2) & (b.cur.ast = 3) /* free up old 16K buffer   */
     4169       then do;
     4170          substr (dbase.inuse_16K, b.cur.pn, 1) = "0"b;
     4171          seg_16K (b.cur.pn) = low (buf_max (3));
     4172          if db_ted
     4173          then call ioa_$ioa_switch (db_output, "inuse_16K=^b ^i=0", dbase.inuse_16K, b.cur.pn);
     4174       end;
     4175       else if (b.cur.sn > 2)
     4176       then call tedfree_segment_ (dbase_p, b.cur.sn);
     4177       return;
     4178 
     4179 dcl i		fixed bin (21);
     4180 dcl len		fixed bin (21);
     4181 
     4182 
     4183 dcl buf_size	(0:5) char (6) var int static options (constant)
     4184 		init ("0", "255", "64", "16", "4", "1");
     4185 dcl 1 seg__	based (dbase.seg_p (1)),
     4186       2 seg_1K	(16),
     4187         3 xxx	char (4096),	/* 1K words		       */
     4188       2 seg_4K	(12),
     4189         3 xxx	char (16384);	/* 4K words		       */
     4190 dcl 1 seg_16K	(4) based (dbase.seg_p (2)),
     4191       2 xxx	char (66536);	/* 16K words		       */
     4192 
     4193    end promote;
     4194 dcl buf_max	(0:5) fixed bin (21) int static options (constant)
     4195 		init (0, 1044480, 0262144, 0065536, 0016384, 0004096);
     4196 /****		      0        1        2        3        4        5     */ 
     4197 make_consistent: proc;
     4198 
     4199 dcl (
     4200 /****are		fixed bin (21),	/*  right string offset	       */
     4201     ale		fixed bin (21)	/*  left string offset	       */
     4202     )		parm;
     4203 
     4204 
     4205       if db_ted
     4206       then call ioa_$ioa_switch (db_output, "make_consistent b(^a) ^i", b.name, b.state_b);
     4207       goto rtn (b.state_b);		/* go finish what was interrupted    */
     4208 
     4209 clean__up:
     4210 rtn (-2): b.state_b = -2;		/* clean up the temporaries	       */
     4211       b.newb = tedcommon_$no_data;
     4212       b.state_b = 0;
     4213       return;
     4214 
     4215 
     4216 rtn (-1):				/* in the middle of tedget_buffer_   */
     4217       b.b_ = b.newb;
     4218       b.a_ = b.temp;
     4219       goto clean__up;
     4220 
     4221 rtn (0):
     4222       return;			/* nothing interrupted	       */
     4223 
     4224 /* Notes on how to sequence the lines
     4225*rtn (x):     b.state_b = x;
     4226*   setq jaf 0
     4227*   setq jaf (+ jaf 1)
     4228*   insert-string (decimal-rep jaf)
     4229**/ 
     4230 relocate: entry;
     4231       if (b.old.re ^= 0)		/* if there is an "old" location...  */
     4232       then do;			/*   ...then must relocate	       */
     4233 
     4234 /****	b.old.(l r)e	is where the old data was		       */
     4235 /****	b.new.(l r)e	is where it now is			       */
     4236 /**** All references within the old range are updated to to the new range    */
     4237 /**** If b.terminate then clean up a ^read segment.		       */
     4238 
     4239          b.N1 = reloc_first;		/* init the reloc loop index	       */
     4240          b.N3 = b.new.le - b.old.le;	/* calc the adjustment needed	       */
     4241 next:
     4242 rtn (1): b.state_b = 1;
     4243          b.N2 = b.N1 + 1;		/* increment this index (safely)     */
     4244          if (b.N2 <= reloc_last)	/* still more to process?	       */
     4245          then do;
     4246 rtn (2):	  b.state_b = 2;
     4247 	  b.N1 = b.N2;		/* update the loop index	       */
     4248 rtn (3):	  b.state_b = 3;
     4249 	  if adjust (buf_des (b.N1), bd_name (b.N1))
     4250 	  then goto next;
     4251 rtn (4):	  b.state_b = 4;
     4252 	  buf_des (b.N1) = b.rel_temp;
     4253 	  goto next;
     4254          end;
     4255 rtn (5): b.state_b = 5;
     4256          if (b.stackl ^= ""b)
     4257          then do;
     4258 	  b.stack_o = b.stackl;
     4259 rel_svex:
     4260 rtn (6):	  b.state_b = 6;
     4261 	  if adjust (ptr (dbase.seg_p (3), b.stack_o) -> sv.ex, "so.ex")
     4262 	  then goto no_svex;
     4263 rtn (7):	  b.state_b = 7;
     4264 	  ptr (dbase.seg_p (3), b.stack_o) -> sv.ex = b.rel_temp;
     4265 no_svex:
     4266 rtn (8):	  b.state_b = 8;
     4267 	  if adjust (ptr (dbase.seg_p (3), b.stack_o) -> sv.a0, "so.a0")
     4268 	  then goto no_sva0;
     4269 rtn (9):	  b.state_b = 9;
     4270 	  ptr (dbase.seg_p (3), b.stack_o) -> sv.a0 = b.rel_temp;
     4271 no_sva0:
     4272 rtn (10):	  b.state_b = 10;
     4273 	  b.stack_o = ptr (dbase.seg_p (3), b.stack_o) -> sv.stackl;
     4274 rtn (11):	  b.state_b = 11;
     4275 	  if (b.stack_o ^= ""b)
     4276 	  then goto rel_svex;
     4277          end;
     4278 rtn (12): b.state_b = 12;
     4279          b.rel_temp = tedcommon_$no_data;
     4280          if b.pseudo		/* if read-only data or ^read file   */
     4281          then do;
     4282 	  if b.terminate
     4283 	  then do;
     4284 rtn (13):	     b.state_b = 13;
     4285 	     dbase_p = ptr (bp, 0);	/* manufacture -> database	       */
     4286 	     call hcs_$terminate_noname (b.cur.sp, 0); /* ignore code */
     4287 	     dbase.not_read_ct = max (0, dbase.not_read_ct - 1);
     4288 	     b.terminate = "0"b;
     4289 	     b.initiate = "0"b;
     4290 	  end;
     4291          end;
     4292       end;
     4293 update: entry;
     4294       if (b.cur.ast ^= b.pend.ast)	/* are we changing segments with...  */
     4295 	 & (b.cur.sn ^= b.pend.sn)
     4296       then do;			/*   ...this action?	       */
     4297 /**** free up old 4/16K buffer if there was one			       */
     4298 /**** set new value for b.maxl				       */
     4299 /**** b.pend --> b.cur					       */
     4300 rtn (14): b.state_b = 14;
     4301          if ^b.pseudo
     4302          then call free_buffer;
     4303       end;
     4304       b.pseudo = ""b;
     4305 rtn (15): b.state_b = 15;
     4306       b.maxl = buf_max (b.pend.ast);
     4307       b.cur = b.pend;
     4308       b.b_ = b.newb;
     4309       goto clean__up; 


     4310 new_cur: entry;			/* used by tedpseudo_	       */
     4311 rtn (16): b.state_b = 16;
     4312       b.maxl = b.newb.l.re;
     4313       b.cur = b.pend;
     4314       b.b_ = b.newb;
     4315       b.ex = b.newb;
     4316       goto clean__up;
     4317 adjust: proc (what, which) returns (bit (1));
     4318 dcl 1 what	like buf_des,
     4319     which		char (*);
     4320 
     4321       b.rel_temp = what;		/* begin a new buf_des	       */
     4322       if (unspec (b.rel_temp) = unspec (tedcommon_$no_data))
     4323       then return ("1"b);
     4324 
     4325       if (b.test.le <= b.rel_temp.l.le)
     4326 	 & (b.rel_temp.l.le <= b.test.re)
     4327       then b.rel_temp.l.le = b.rel_temp.l.le + b.N3;
     4328 
     4329       if (b.test.le <= b.rel_temp.l.re)
     4330 	 & (b.rel_temp.l.re <= b.test.re)
     4331       then b.rel_temp.l.re = b.rel_temp.l.re + b.N3;
     4332 
     4333       if (b.test.le <= b.rel_temp.r.le)
     4334 	 & (b.rel_temp.r.le <= b.test.re)
     4335       then b.rel_temp.r.le = b.rel_temp.r.le + b.N3;
     4336 
     4337       if (b.test.le <= b.rel_temp.r.re)
     4338 	 & (b.rel_temp.r.re <= b.test.re)
     4339       then b.rel_temp.r.re = b.rel_temp.r.re + b.N3;
     4340 
     4341       if (unspec (buf_des (b.N1)) = unspec (b.rel_temp))
     4342       then return ("1"b);
     4343 
     4344       if db_ted
     4345       then call tedshow_ (bp, which, "rt");
     4346       return ("0"b);
     4347 
     4348    end adjust;
     4349 dcl bd_name	(13) char (2) int static init (
     4350 		"b_", "nb", "ex", "a0", "a1", "a2", "cd", "gb", "na",
     4351 		"rt", "t0", "t1", "t2");
     4352 demote: entry (ale);
     4353 
     4354       if (b.cur.sn = 0)		/* if buffer already empty..	       */
     4355       then return;			/* ..don't need to do anything.      */
     4356       if b.pseudo			/* if read-only data or ^read file   */
     4357       then do;
     4358          if b.terminate
     4359          then do;
     4360 rtn (17):	  b.state_b = 17;
     4361 	  call hcs_$terminate_noname (b.cur.sp, 0); /* ignore code */
     4362 	  dbase.not_read_ct = max (0, dbase.not_read_ct - 1);
     4363 	  b.terminate = "0"b;
     4364 	  b.initiate = "0"b;
     4365          end;
     4366       end;
     4367       else do;
     4368 rtn (18): b.state_b = 18;
     4369          call free_buffer;
     4370       end;
     4371 rtn (19): b.state_b = 19;
     4372       b.pseudo = ""b;
     4373       b.uid = ""b;
     4374       b.maxl, b.maxln = 0;
     4375       b.cur = tedcommon_$no_seg;
     4376       b.b_ = tedcommon_$no_data;
     4377       b.a_ (0) = tedcommon_$no_data;
     4378       goto clean__up;
     4379 
     4380 
     4381 new_dot: entry;
     4382 
     4383 rtn (20): b.state_b = 20;
     4384       b.a_ (0) = b.newa;
     4385       b.newa = tedcommon_$no_data;
     4386       goto clean__up;
     4387 
     4388    end make_consistent; 
     4389 /**** This routine isolates the line boundaries of the last byte used and    */
     4390 /****  makes these be the current location.			       */
     4391 
     4392 iso_line: proc;			/* isolate the line defined by       */
     4393 				/*    b.a_.r.le (2)		       */
     4394 
     4395 dcl (sb, se)	fixed bin (21);
     4396 
     4397       se = b.a_.r.le (2);		/* Take the end of range value.      */
     4398       if (se = b.b_.l.re + 1)		/* value just after lower part       */
     4399 	 | (se = b.b_.l.le - 1)	/* ..or lower part empty	       */
     4400       then se = b.b_.r.le;		/* ..move to upper.		       */
     4401       if (se = b.b_.r.le - 1)		/* value just before upper part      */
     4402 /****    | (se = b.b_.r.re + 1)	/* ..or upper part empty	       */
     4403       then se = b.b_.l.re;		/* ..move to lower.		       */
     4404       b.a_.r.le (2) = se;		/* Take the end of range value.      */
     4405       if db_ted
     4406       then do;
     4407          call tedshow_ (bp, "> iso a2 b_");
     4408          call ioa_$ioa_switch (db_output, " iso: se=^i ", se);
     4409       end;
     4410       if (b.b_.l.re >= b.b_.l.le)	/* is there a lower part?	       */
     4411       then do;
     4412          if (b_c (b.b_.l.re) ^= NL)	/* does lower part not end in NL...  */
     4413 	    & (b.b_.r.re >= b.b_.r.le)/* ..and is there an upper part?     */
     4414          then do;
     4415 /**** The hole gets moved to a line boundary. Data is moved upward.	       */
     4416 /****  N.B.: A file which does not end with NL could be all in lower part.   */
     4417 /****        such as after doing "$($)d"			       */
     4418 	  i = index (reverse (
     4419 	       substr (b_s, b.b_.l.le, b.b_.l.re - b.b_.l.le + 1)), NL);
     4420 	  if (i = 0)
     4421 	  then b.a_.l.re (1) = b.b_.l.le;
     4422 	  else b.a_.l.re (1) = b.b_.l.re - i + 2; /* adjust to just after  */
     4423 				/* ..the NL		       */
     4424 	  call openup;
     4425 	  se = b.a_.r.le (2);	/* reclaim working location	       */
     4426          end;
     4427       end;
     4428       b.newa.l.re, b.newa.r.le = se;
     4429       b.newa.l.ln, b.newa.r.ln = b.a_.r.ln (2);
     4430       if (se < b.b_.l.le) | (b.b_.r.re < se)
     4431 	 | (b.b_.l.re < se) & (se < b.b_.r.le)
     4432       then do;			/* If not within buffer limits..     */
     4433          b.newa.l.re = b.b_.l.le;	/* ..set it undefined	       */
     4434          b.newa.r.le = addr_undef;
     4435       end;
     4436 
     4437       sb = b.newa.l.re;		/* set tentative limits	       */
     4438       se = b.newa.r.le;
     4439       if (se ^= addr_undef)
     4440       then do;
     4441          if (b_c (se) ^= NL)		/* If string-end not on a NL..       */
     4442          then do;			/* ..get it there (if possible).     */
     4443 	  i = b.b_.l.re;
     4444 	  if (se > i)
     4445 	  then i = b.b_.r.re;
     4446 	  j = index (substr (b_s, se, i - se + 1), NL);
     4447 	  if (j = 0)		/* no NL found		       */
     4448 	  then if (b.b_.r.re >= b.b_.r.le) /* set to EOB		       */
     4449 	       then se = b.b_.r.re;	/* (upper part exists)	       */
     4450 	       else se = b.b_.l.re;	/* (no upper part)		       */
     4451 	  else se = se - 1 + j;	/* otherwise set to that NL	       */
     4452          end;
     4453          i = b.b_.l.le;		/* start at lower part	       */
     4454          if (sb > b.b_.l.re)		/* If point is in upper part..       */
     4455          then i = b.b_.r.le;		/* ..shift up there.	       */
     4456          if (sb > i)
     4457          then if (b_c (sb - 1) ^= NL)	/* If not at BOL, get there	       */
     4458 	    then do;
     4459 	       j = index (reverse (substr (b_s, i, sb - i)), NL);
     4460 	       if (j = 0)
     4461 	       then sb = i;
     4462 	       else sb = sb - j + 1;
     4463 	    end;
     4464       end;
     4465       b.newa.l.le = sb;
     4466       b.newa.r.re = se;
     4467       call new_dot;
     4468       if db_ted
     4469       then call tedshow_ (bp, "< a0");
     4470 
     4471       return;
     4472 
     4473    end iso_line; 
     4474 default$line_eval: proc;
     4475       who = "le-"; bias = 1; extend = "0"b; cur_line = "1"b; goto work;
     4476 
     4477 default$cur_line_extend: entry;
     4478       who = "cle"; bias = 0; extend = "1"b; cur_line = "1"b; goto work;
     4479 
     4480 default$cur_line: entry;
     4481       who = "cl-"; bias = 0; extend = "0"b; cur_line = "1"b; goto work;
     4482 
     4483 default$whole_buffer: entry;
     4484       who = "wb-"; bias = 0; extend = "0"b; cur_line = ""b;
     4485 
     4486 work:
     4487       if ^b.present (1)		/* if no addresses provided	       */
     4488       then do;
     4489          if cur_line
     4490          then b.a_ (1), b.a_ (2) = b.a_ (0);
     4491          else do;
     4492 	  b.a_.l.ln (1) = 1;
     4493 	  b.a_.r.ln (2) = b.b_.r.ln;
     4494 	  if (b.b_.l.le > b.b_.l.re)	/* lower part empty		       */
     4495 	  then b.a_.l.le (1), b.a_.l.re (1) = b.b_.r.le;
     4496 	  else b.a_.l.le (1), b.a_.l.re (1) = b.b_.l.le;
     4497 	  if (b.b_.r.re < b.b_.r.le)
     4498 	  then b.a_.r.le (2), b.a_.r.re (2) = b.b_.l.re;
     4499 	  else b.a_.r.le (2), b.a_.r.re (2) = b.b_.r.re;
     4500          end;
     4501       end;
     4502       else if ^b.present (2)		/* if only one addr,	       */
     4503       then do;			/*  make second addr same as first   */
     4504          b.a_ (2) = b.a_ (1);
     4505       end;
     4506       if db_addr
     4507       then call tedshow_ (bp, ".", who, "adr");
     4508       if (b.cur.sn = 0)
     4509       then do;
     4510          msg = "Abe) Buffer empty.";
     4511          goto print_error;
     4512       end;
     4513       if (b.a_.r.re (2) = addr_undef)
     4514       then do;
     4515          msg = "A.u) ""."" undefined.";
     4516          goto print_error;
     4517       end;
     4518       if (b.a_.l.le (1) = 0)
     4519       then do;
     4520          msg = "Abb) Addr- before buffer.";
     4521          goto print_error;
     4522       end;
     4523       if (b.a_.l.le (1) > b.b_.r.re) | ^extend & (b.a_.r.le (2) > b.b_.r.re)
     4524       then do;
     4525          msg = "Aab) Addr- after buffer.";
     4526          goto print_error;
     4527       end;
     4528       if (b.a_.l.re (1) > b.a_.r.le (2) + bias)
     4529       then do;
     4530          msg = "Awa) Addr- wrap-around.";
     4531          goto print_error;
     4532       end;
     4533       return;
     4534 
     4535 dcl cur_line	bit (1);
     4536 dcl bias		fixed bin;
     4537 dcl extend	bit (1);
     4538 dcl who		char (3);
     4539 
     4540    end default$line_eval; 
  3     1 /* BEGIN INCLUDE FILE ..... tedgvd.incl.pl1 ..... 06/29/82 J Falksen */
  3     2 
  3     3 dcl (adr_op	init (01),	/* ( address processing	       */
  3     4 
  3     5     srepl_op	init (-1),	/* literal replace string	       */
  3     6     sself_op	init (-2),	/* "&" replace		       */
  3     7     sdup_op	init (-3),	/* "x\=" duplication	       */
  3     8     seval_op	init (-4),	/* "\g{}" processing	       */
  3     9     teval_op	init (-5),	/* evaluation test		       */
  3    10     tsrch_op	init (-6),	/* search test		       */
  3    11     tdone_op	init (-7)		/* test succeeds		       */
  3    12     )		fixed bin int static options (constant);
  3    13 
  3    14 dcl comptr	ptr;
  3    15 dcl 1 gvx		based (comptr),	/* compiled gv request	       */
  3    16       2 hdr,
  3    17         3 max_len	fixed bin (24),	/* max size available (words)	       */
  3    18         3 tot_len	fixed bin (24),	/* total size in use (words)	       */
  3    19         3 srch_len	fixed bin (24),	/* search size (words)	       */
  3    20         3 mk_list	fixed bin (24),	/* list of mk requests compiled      */
  3    21         3 printing	bit (1),		/* 1- contains "pP=lLtT"	       */
  3    22         3 ic	fixed bin,	/* instruction counter	       */
  3    23       2 word	(gvx.tot_len) fixed bin (35); /* compiled statement      */
  3    24 
  3    25 dcl cfp		ptr;
  3    26 dcl 1 cf		based (cfp),	/* compiled function	       */
  3    27       2 hdr,
  3    28         3 op	fixed bin,	/* operation		       */
  3    29         3 siz	fixed bin (24),	/* size of structure	       */
  3    30         3 len	fixed bin,	/* length of string		       */
  3    31       2 da	char (cf.len);	/* string data		       */
  3    32 
  3    33 dcl 1 cfmk	based (cfp),	/* compiled mk		       */
  3    34       2 hdr	like cf.hdr,
  3    35       2 cb_r	bit (18) aligned,	/* offset of destination bcb	       */
  3    36       2 link	fixed bin;	/* link to next mk entry	       */
  3    37 
  3    38 dcl 1 cfa		based (cfp),	/* compiled address		       */
  3    39       2 hdr	like cf.hdr,
  3    40       2 (ad1, ad2)	fixed bin (21);	/* 1st,2nd address values	       */
  3    41 
  3    42 dcl 1 cft		based (cfp),	/* compiled test		       */
  3    43       2 hdr	like cf.hdr,
  3    44       2 (t, f)	fixed bin,	/* true/false next location offset   */
  3    45       2 cexpml	fixed bin,	/* max length of expr area	       */
  3    46       2 cexpl	fixed bin,	/* length set by tedsrch_$compile    */
  3    47       2 da	char (cft.len);	/* text of {}, compiled //	       */
  3    48 
  3    49 dcl 1 cfx		based (cfp),	/* regexp / eval		       */
  3    50       2 hdr	like cf.hdr,
  3    51       2 cexpml	fixed bin,	/* max length of expr area	       */
  3    52       2 cexpl	fixed bin,	/* length set by tedsrch_$compile    */
  3    53       2 da	char (cft.len);	/* text of {}, compiled //	       */
  3    54 
  3    55 /* END INCLUDE FILE ..... tedgvd.incl.pl1 ..... */
     4541 
     4542 dcl gv_work	char (2048);	/* memory for compilation result     */



     4543 
     4544 gv_msg_com:
     4545       if (vgch ^= "")
     4546       then do;
     4547          req_str = req_str || "(sub-request ";
     4548          req_str = req_str || vgds;
     4549          req_str = req_str || ")";
     4550       end;
     4551       if (rl_c (rl_i) = NL)
     4552       then rl_i = rl_i - 1;
     4553       if (rl_i < rl_b)
     4554       then rl_b = rl_i + 1;
     4555       goto add_request; 


     4556 end_cf: proc;
     4557 
     4558       if (cf.op ^= -255)
     4559       then do;
     4560          gvx.tot_len = gvx.tot_len + cf.siz;
     4561          if db_gv | db_srch
     4562          then do;
     4563 	  call tedshow_ (comptr, "cf");
     4564          end;
     4565       end;
     4566 start_cf: entry;
     4567       gvx.ic = gvx.tot_len + 1;
     4568       cfp = addr (gvx.word (gvx.ic));
     4569       cf.op = -255;
     4570       cf.len = 0;
     4571       cf.siz = 5;
     4572 
     4573    end end_cf;
     4574 init_cfp: proc (area_p, space);
     4575 
     4576 dcl area_p	ptr,		/* base of area being setup	       */
     4577     space		char (*);		/* place for data to go	       */
     4578 
     4579       if (area_p = null ())
     4580       then do;
     4581          area_p, comptr = addr (space);
     4582          gvx.max_len = size (space) - 5;
     4583          gvx.tot_len, gvx.srch_len = 0;
     4584       end;
     4585       comptr = area_p;
     4586       gvx.ic = 1;
     4587       cfp = addr (gvx.word (1));
     4588       if db_gv | db_srch
     4589       then call ioa_$ioa_switch (db_output, "cfp=^p", cfp);
     4590 
     4591    end init_cfp; 
     4592 /****				        00000000011111111112222      */
     4593 /****				        12345678901234567890123      */
     4594 dcl op_mnem	char (22) int static init ("(pPKMkmsd=tTlLuU{aci >");
     4595 
     4596 gv_compile: proc;			/* compile a g* request	       */
     4597       call init_cfp (gvx_p, gv_work);
     4598 tedgv_: begin;
     4599 dcl it		fixed bin (21);
     4600 dcl (n1_sw, n2_sw)	bit (1);
     4601 dcl i		fixed bin (21);
     4602 dcl ch		char (1);
     4603 dcl n1		fixed bin (21);
     4604 dcl n2		fixed bin (21);
     4605 dcl adr_sw	bit (1);
     4606 
     4607          code = 0;
     4608          rl_b = rl_i - 2;
     4609          req_ch = rl_c (rl_b);
     4610          vgch, vgds = "";
     4611          NLlast = gvx.printing;
     4612          if (substr (rl_s, rl_i, 2) = "==")
     4613          then do;			/* wants to re-use it all	       */
     4614 	  rl_i = rl_l;
     4615 	  goto get_ready;
     4616          end;
     4617          else if (substr (rl_s, rl_i, 2) = "//")
     4618          then do;			/* wants to re-use search	       */
     4619 	  if (substr (rl_s, rl_i + 2, 1) ^= " ")
     4620 	  then do;		/* But, he must give something to do */
     4621 	     msg = "Xse) Bad syntax for ";
     4622 	     goto gv_msg_com;
     4623 	  end;
     4624 	  if (gvx.tot_len = 0)	/* There must also be something      */
     4625 	  then do;		/*  remembered.		       */
     4626 	     rl_i = rl_l;		/* (will give the error at	       */
     4627 	     return;		/*  execution time)		       */
     4628 	  end;
     4629 	  gvx.tot_len = gvx.srch_len;
     4630 	  call start_cf;
     4631 				/* going to re-use search part       */
     4632 	  rl_i = rl_i + 3;
     4633          end;
     4634          else do;			/* completely new request	       */
     4635 	  gvx.tot_len,
     4636 	       gvx.srch_len = 0;	/* wipe out the remembered stuff     */
     4637 	  cf.op = -255;
     4638 	  cf.len = 0;
     4639 	  cf.siz = 5;
     4640 	  call ted_gv_p_;
     4641 	  gvx.srch_len = gvx.tot_len;
     4642          end;
     4643          if (rl_i >= rl_l)
     4644          then do;
     4645 	  msg = "Gne) No execution part for";
     4646 	  rl_i = rl_l - 1;
     4647 	  goto gv_msg_com;
     4648          end; 
     4649 /*	         . . . INSTRUCTION COMPILATION LOOP . . .		       */
     4650 /*			   for g* / v*			       */
     4651 
     4652          gvx.printing = ""b;
     4653          gvx.mk_list = 0;
     4654          do while (rl_i < rl_l);
     4655 	  vgch, vgds = rl_c (rl_i);
     4656 	  if ^caps
     4657 	  then if (vgch >= "A") & (vgch <= "Z")
     4658 	       then goto inv_req;
     4659 	  if (vgch = "!")
     4660 	  then do;
     4661 	     vgds = vgds || rl_c (rl_i + 1);
     4662 	     it = index ("pkmtlu", rl_c (rl_i + 1));
     4663 	     if (it = 0)
     4664 	     then goto inv_req;
     4665 	     rl_i = rl_i + 1;
     4666 				/* make char UPPER CASE	       */
     4667 	     unspec (vgch) = unspec (rl_c (rl_i)) & "111011111"b;
     4668 	  end;
     4669 	  it = index (op_mnem, vgch);
     4670 	  if (it = 0)
     4671 	  then do;
     4672 	     if vgch = """"		/* allow a comment on the end	       */
     4673 	     then do;
     4674 	        rl_i = rl_l;
     4675 	        goto compiled;
     4676 	     end;
     4677 inv_req:
     4678 	     msg = "Grq) Unknown sub-request for";
     4679 	     vgch = "";
     4680 	     goto gv_msg_com;
     4681 	  end;
     4682 	  rl_i = rl_i + 1;
     4683 re_com:
     4684 /**** Need to continually check for gvx overflow!!		       */
     4685 
     4686 	  if (gvx.max_len < gvx.tot_len)
     4687 	  then do;
     4688 	  end;
     4689 	  call end_cf;
     4690 	  cf.op = it;
     4691 	  goto com (it); 
     4692 com (06):				/* k - kopy		       */
     4693 com (07):				/* m - move		       */
     4694 	  cfmk.link = gvx.mk_list;	/* buffer needs to be cleaned out    */
     4695 	  gvx.mk_list = gvx.tot_len + 1; /* ..before execution begins      */
     4696 
     4697 com (04):				/* K - kopyappend		       */
     4698 com (05):				/* M - moveappend		       */
     4699 	  used = rl_l - rl_i + 1;
     4700 	  call tedget_buffer_ (dbase_p, addr (rl_c (rl_i)), used, tbp, msg);
     4701 	  rl_i = rl_i + used;
     4702 	  if (tbp = null ())
     4703 	  then goto rq_err_msg;
     4704 	  if tbp -> b.present (1)
     4705 	  then do;
     4706 	     msg = "Gma) No addrs allowed on destination.";
     4707 	     goto gv_msg_com;
     4708 	  end;
     4709 	  cfmk.cb_r = rel (tbp);
     4710 	  cfmk.siz = size (cfmk);
     4711 	  goto comdone; 



     4712 com (08):				/* s -  substitute		       */
     4713 com (15):				/* u - lowercase translate	       */
     4714 com (16):				/* U - uppercase translate	       */
     4715 	  call scan;
     4716 	  cfx.cexpml = 100;		/* DO IT RIGHT!		       */
     4717 	  cfx.cexpl = 0;		/* zero length of remembered regexp  */
     4718 	  call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
     4719 	       addr (cfx.cexpml), "0"b, (dbase.lit_sw), msg, code);
     4720 	  if (code ^= 0)
     4721 	  then do;
     4722 	     rl_i = expr_b + expr_l;
     4723 	     goto print_error_rc;
     4724 	  end;
     4725 
     4726 	  cfx.cexpml = cfx.cexpl + 12;
     4727 	  call add_length ((cfx.cexpml));
     4728 	  if (it = 8)
     4729 	  then do;
     4730 	     cf.siz = size (cf);
     4731 	     call end_cf;
     4732 	     call replace$compile;
     4733 	  end;
     4734 	  cf.siz = size (cf);
     4735 	  goto comdone; 



     4736 com (13):				/* l - linefeed to user_output       */
     4737 com (14):				/* L - linefeed to error_output      */
     4738 	  call add_length (1);
     4739 	  cf.da = NL;
     4740 	  cf.siz = size (cf);
     4741 	  goto comdone_NL; 


     4742 com (11):				/* t - type to user_output	       */
     4743 com (12):				/* T - type to error_output	       */
     4744 	  call scan;
     4745 	  call add_length ((expr_l));
     4746 	  cf.da = substr (rl_s, expr_b, expr_l);
     4747 	  cf.siz = size (cf);
     4748 	  goto comdone_NL; 
     4749 com (01):				/* ( - byte address		       */
     4750 	  n1, n2 = 0;
     4751 	  n1_sw, n2_sw = "0"b;
     4752 	  adr_sw = "1"b;
     4753 	  do rl_i = rl_i to rl_l;
     4754 	     ch = rl_c (rl_i);
     4755 	     if (ch = ",")		/* means end of 1st addr	       */
     4756 	     then do;
     4757 	        if n1_sw | ^n2_sw
     4758 	        then do;
     4759 misplaced:
     4760 		 msg = "Gmc) Misplaced ";
     4761 		 msg = msg || ch;
     4762 		 msg = msg || ".";
     4763 		 vgch = "";
     4764 		 goto gv_msg_com;
     4765 	        end;
     4766 	        n1 = n2;
     4767 	        n1_sw = "1"b;
     4768 	        n2 = 0;
     4769 	        n2_sw = "0"b;
     4770 	     end;
     4771 	     else if (ch = "/")	/* expression (NOT YET)	       */
     4772 	     then do;
     4773 	        if n2_sw
     4774 	        then goto misplaced;
     4775 	        n2_sw = "1"b;
     4776 	        goto gv_nosrch;
     4777 	     end;
     4778 	     else if (ch = ")")
     4779 	     then do;
     4780 	        if ^n2_sw
     4781 	        then goto misplaced;
     4782 	        if ^n1_sw
     4783 	        then n1 = n2;
     4784 				/* if (sign (n1) = sign (n2))	       */
     4785 				/* then if (n2 < n1)	       */
     4786 				/* then goto gv_wrap;	       */
     4787 	        rl_i = rl_i + 1;
     4788 				/* if (rl_c (rl_i) = "(")	       */
     4789 				/* then goto misplaced;	       */
     4790 	        cfa.ad1 = n1;
     4791 	        cfa.ad2 = n2;
     4792 	        cfa.siz = size (cfa);
     4793 	        goto comdone;
     4794 	     end;
     4795 	     else do;
     4796 	        n2 = 0;
     4797 	        if (ch = "$")	/* means END-OF-LINE (where NL is)   */
     4798 	        then do;
     4799 		 if n2_sw
     4800 		 then goto misplaced;
     4801 		 n2_sw = "1"b;
     4802 		 if (rl_c (rl_i + 1) = "-")
     4803 		 then do;
     4804 		    rl_i = rl_i + 1;
     4805 		    i = verify (substr (rl_s, rl_i), "-0123456789");
     4806 		    goto gv_adrnum;
     4807 		 end;
     4808 	        end;
     4809 	        else do;
     4810 		 i = verify (substr (rl_s, rl_i), "0123456789");
     4811 gv_adrnum:
     4812 		 if (i = 0)	/* EVERYTHING is digits (no request) */
     4813 		      | (i = 1)	/* no digits		       */
     4814 		 then do;
     4815 		    msg = "Gia) Invalid addr char.";
     4816 		    vgch = "";
     4817 		    goto gv_msg_com;
     4818 		 end;
     4819 		 i = i - 1;
     4820 		 n2 = fixed (substr (rl_s, rl_i, i));
     4821 		 rl_i = rl_i + i - 1;
     4822 	        end;
     4823 	        n2_sw = "1"b;
     4824 	     end;
     4825 	  end;			/* control can never get here	       */
     4826 	  signal condition (cant_get_here);
     4827 dcl cant_get_here	condition; 




     4828 com (17):				/* { - evaluation		       */
     4829 	  rl_i = rl_i - 1;
     4830 	  i = index (substr (rl_s, rl_i), "}");
     4831 	  if (i = 0)
     4832 	  then do;
     4833 	     msg = "Gvd) Missing }.";
     4834 	     goto gv_msg_com;
     4835 	  end;
     4836 	  call add_length ((i));
     4837 	  cf.da = substr (rl_s, rl_i, i);
     4838 	  rl_i = rl_i + i;
     4839 	  cf.siz = size (cf);
     4840 	  goto comdone;
     4841 com (18):				/* a - append		       */
     4842 com (20):				/* i - insert		       */
     4843 com (19):				/* c - change		       */
     4844 	  if (rl_c (rl_i) ^= " ")
     4845 	  then goto gv_blank;
     4846 	  i = index (substr (rl_s, rl_i), "\f");
     4847 	  if (i = 0)
     4848 	  then i = index (substr (rl_s, rl_i), "\F");
     4849 	  if (i = 0)
     4850 	  then do;
     4851 	     msg = "Gei) Missing \F.";
     4852 	     goto gv_msg_com;
     4853 	  end;
     4854 	  i = i - 2;
     4855 	  call add_length ((i));
     4856 	  cf.da = substr (rl_s, rl_i + 1, i);
     4857 	  rl_i = rl_i + i + 3;
     4858 	  cf.siz = size (cf);
     4859 	  goto comdone;
     4860 com (22):				/* > */
     4861 	  if (rl_c (rl_i) = "(")
     4862 	  then do;
     4863 	     i = index (substr (rl_s, rl_i), ")");
     4864 	     if (i = 0)
     4865 	     then do;
     4866 	        msg = "Ggo) Missing ).";
     4867 	        goto gv_msg_com;
     4868 	     end;
     4869 	  end;
     4870 	  else if (rl_c (rl_i) = "-") | (rl_c (rl_i) = "+")
     4871 	  then i = 2;
     4872 	  else i = 1;
     4873 	  call add_length ((i));
     4874 	  cf.da = substr (rl_s, rl_i, i);
     4875 	  rl_i = rl_i + i;
     4876 	  cf.siz = size (cf);
     4877 	  goto comdone;
     4878 com (21):				/* SP			       */
     4879 	  cf.op = -255;
     4880 	  goto comdone;
     4881 com (10):				/* = - linenumber		       */
     4882 com (03):				/* P - print w/ linenumber	       */
     4883 com (02):				/* p - print		       */
     4884 	  cf.siz = size (cf);
     4885 comdone_NL:
     4886 	  gvx.printing = "1"b;
     4887 com (09):				/* d - delete		       */
     4888 comdone:
     4889 	  call end_cf;
     4890          end;
     4891 compiled:
     4892          cf.op, cf.len = 0;
     4893          cf.siz = 3;
     4894          call end_cf;
     4895 get_ready: begin;
     4896 dcl tbp		ptr;
     4897 
     4898 	  tbp = bp;
     4899 	  i = gvx.mk_list;		/* clean out all m/k buffers	       */
     4900 	  do cfp = addr (gvx.word (i))
     4901 	       repeat (addr (gvx.word (i))) while (i > 0);
     4902 	     bp = ptr (dbase_p, cfmk.cb_r);
     4903 	     call delete$all;	/* iso_line ^needed		       */
     4904 	     i = cfmk.link;
     4905 	  end;
     4906 	  bp = tbp;
     4907          end;
     4908          return;
     4909 
     4910 gv_1addr:
     4911          msg = "G1a) Only 1 addr allowed.";
     4912          goto gv_msg_com;
     4913 gv_wrap:
     4914          msg = "Gwa) Addr wrap-around.";
     4915          goto gv_msg_com;
     4916 gv_nosrch:
     4917          msg = "Gxx) Search addr not supported.";
     4918          goto gv_msg_com;
     4919 gv_blank:
     4920          msg = "Gnb) No blank after ";
     4921          goto gv_msg_com;
     4922 no_2nd_delim:
     4923          msg = "Gd2) No 2nd delimiter.";
     4924          rl_i = rl_i - 1;
     4925          goto gv_msg_com; 
     4926 /* . . . PARSE . . . */
     4927 
     4928 
  4     1 /* BEGIN INCLUDE FILE ..... ted_gv_p_.incl.pl1 ..... 07/10/81 J Falksen      */
  4     2 
  4     3 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
  4     4 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
  4     5 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
  4     6 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
  4     7 
  4     8 ted_gv_p_: proc ();
  4     9 
  4    10 /* Parser for tables created by LRK. */
  4    11 
  4    12       current_state = 1;
  4    13 
  4    14       ls_top, ps_top = 0;
  4    15       la_put, la_get = 1;
  4    16 
  4    17       la_ct = 0;
  4    18       call rule_0;
  4    19 
  4    20 /* The parsing loop. */
  4    21 NEXT:
  4    22       if (current_state = 0)
  4    23       then do;
  4    24 done_parse:
  4    25          if db_gv then call ioa_();
  4    26          call end_cf;
  4    27          cf.op = tdone_op;
  4    28          cf.len = 0;
  4    29          cf.siz = size (cf);
  4    30          call end_cf;
  4    31          if db_gv then call tedshow_ (comptr, "gvx");
  4    32          return;
  4    33       end;
  4    34       current_table = current_state;
  4    35 
  4    36       string (db_data) = "";
  4    37       db_data.state = current_state;
  4    38 
  4    39 (subscriptrange):
  4    40 TRY_AGAIN:
  4    41       goto CASE (DPDA.v1 (current_table));
  4    42 
  4    43 CASE (3):				/* Shared look		       */
  4    44       current_table = DPDA.v2 (current_table);
  4    45 CASE (1):				/* Look.			       */
  4    46       db_data.type = "LOOK";
  4    47       la_use = mod (la_get + la_need - 1, -lbound (ls, 1)) + 1;
  4    48       if (la_need = -lbound (ls, 1))
  4    49       then signal condition (lastk_ovflo);
  4    50 dcl lastk_ovflo	condition;
  4    51       la_need = la_need + 1;
  4    52       goto read_look;
  4    53 
  4    54 CASE (10):			/* Shared read		       */
  4    55       current_table = DPDA.v2 (current_table);
  4    56 
  4    57 CASE (9):				/* Read.			       */
  4    58 
  4    59       db_data.type = "READ";
  4    60 
  4    61       la_need = 1;
  4    62       la_use = la_get;
  4    63       goto read_look;
  4    64 
  4    65 CASE (2):				/* Stack and Shared read	       */
  4    66       current_table = DPDA.v2 (current_table);
  4    67 
  4    68 CASE (0):				/* Stack and Read		       */
  4    69 
  4    70       db_data.type = "READ";
  4    71       db_data.flag = "*";
  4    72 
  4    73       la_need = 1;
  4    74       la_use = la_get;
  4    75       if (ps_top = hbound (parse_stack, 1))
  4    76       then do;
  4    77          msg = "tedgv_ parse stk oflow";
  4    78          goto print_error;
  4    79       end;
  4    80       ps_top = ps_top + 1;		/* Top of  parsing stack.	       */
  4    81       parse_stack (ps_top) = current_state; /* Stack the current state.      */
  4    82       cur_lex_top (ps_top) = ls_top;	/* save cur lex top (for recovery)   */
  4    83 read_look:
  4    84       do while (la_ct < la_need);	/* ensure enough symbols available   */
  4    85          call scanner ();
  4    86          la_put = mod (la_put, -lbound (ls, 1)) + 1;
  4    87          la_ct = la_ct + 1;
  4    88       end;
  4    89       test_symbol = ls.symbol (-la_use);
  4    90 
  4    91       m = 0;
  4    92       do i = current_table + 1 to current_table + DPDA.v2 (current_table);
  4    93          if (DPDA.v1 (i) = test_symbol)
  4    94          then do;
  4    95 	  next_state = DPDA.v2 (i);
  4    96 	  goto got_symbol;
  4    97          end;
  4    98       end;
  4    99 
  4   100       msg = "Vxx) Syntax- ";
  4   101       goto gv_msg_com;
  4   102 
  4   103 got_symbol:
  4   104 
  4   105 
  4   106       if db_gv
  4   107       then do;
  4   108          if (next_state < 0)		/* is this a look-ahead state?       */
  4   109          then do;
  4   110 	  db_data.type = "LK01";
  4   111 	  db_look = la_need;
  4   112 				/* show only "name" on look-ahead    */
  4   113 	  db_data.data = geterm (test_symbol, 0);
  4   114 	  db_data.flag = " ";
  4   115          end;
  4   116          else db_data.data = getermc (test_symbol, la_get);
  4   117 				/* display terminal "name" and data, */
  4   118 				/*  if available		       */
  4   119 
  4   120          call ioa_$ioa_switch_nnl (iox_$user_output, "^a^/", string (db_data));
  4   121       end;
  4   122 
  4   123       current_state = next_state;
  4   124       if (current_state < 0)		/* Transition is a look-ahead state. */
  4   125       then current_state = -current_state;
  4   126       else do;
  4   127          if (ls_top = hbound (ls, 1))
  4   128          then do;
  4   129 	  msg = "tedgv_ lex stk oflow";
  4   130 	  goto print_error;
  4   131          end;
  4   132          ls_top = ls_top + 1;
  4   133          ls (ls_top) = ls (-la_get);
  4   134          la_get = mod (la_get, -lbound (ls, 1)) + 1;
  4   135          la_ct = la_ct - 1;
  4   136       end;
  4   137       goto NEXT;
  4   138 
  4   139 CASE (4):				/* Apply state. */ /* . . . */
  4   140 CASE (5):				/* Apply single */ /* . . . */
  4   141 CASE (6):				/* Apply Shared */ /* . . . */
  4   142       la_need = 1;
  4   143       rulen = DPDA.v1 (current_table + 2);
  4   144       altn = DPDA.v2 (current_table + 2);
  4   145 
  4   146       if db_gv
  4   147       then do;
  4   148          db_data.type = "APLY";
  4   149          db_data.data = "(";
  4   150          call ioa_$ioa_switch_nnl (iox_$user_output, "^a^i ^i)",
  4   151 	  string (db_data), rulen, altn);
  4   152       end;
  4   153 
  4   154       if (rulen > 0)
  4   155       then call sem (rulen, altn);
  4   156 
  4   157       if db_gv
  4   158       then do;
  4   159          call ioa_$ioa_switch_nnl (iox_$user_output, "^-pd=^i ld=^i(",
  4   160 	  DPDA.v1 (current_table + 1), DPDA.v2 (current_table + 1));
  4   161          do t = ps_top to ps_top - DPDA.v1 (current_table + 1) + 1 by -1;
  4   162 	  call ioa_$ioa_switch_nnl (iox_$user_output, " ^d",
  4   163 	     parse_stack (t));
  4   164          end;
  4   165          call ioa_$ioa_switch_nnl (iox_$user_output, ")^/");
  4   166       end;
  4   167 
  4   168 /* Delete parse and lex stack states				       */
  4   169       ps_top = ps_top - DPDA.v1 (current_table + 1);
  4   170       ls_top = ls_top - DPDA.v2 (current_table + 1);
  4   171       if (DPDA.v1 (current_state) = 5)
  4   172       then do;
  4   173          current_state = DPDA.v2 (current_table + 3);
  4   174          goto NEXT;
  4   175       end;
  4   176       if (DPDA.v1 (current_state) = 6)
  4   177       then do;
  4   178          current_table = DPDA.v2 (current_table + 3);
  4   179       end;
  4   180       do i = current_table + 4 to current_table + DPDA.v2 (current_table);
  4   181          if (DPDA.v1 (i) = parse_stack (ps_top))
  4   182          then do;
  4   183 	  current_state = DPDA.v2 (i);
  4   184 	  goto NEXT;
  4   185          end;
  4   186       end;
  4   187       current_state = DPDA.v2 (current_table + 3);
  4   188       goto NEXT;
  4   189 
  4   190 
  4   191 
  4   192 
  4   193 dcl (addr, mod, fixed) builtin;
  4   194 dcl db_look	pic "99" defined (db_data.type) pos (3);
  4   195 dcl 1 db_data,
  4   196       2 flag	char (1),		/* * means stacked		       */
  4   197       2 state	pic "zzz9",
  4   198       2 fil1	char (2),
  4   199       2 type	char (6),
  4   200       2 data	char (100);
  4   201 dcl DDop		(-1:2) char (4) int static init
  4   202 		("LOOK", "FINI", "READ", "ERR");
  4   203 dcl ioa_$ioa_switch_nnl entry options (variable);
  4   204 dcl iox_$user_output ptr ext static;
  4   205 
  4   206 dcl 1 ls		(-4:50),		/* -4:-1 look-ahead stack (FIFO)     */
  4   207 				/* 1:50 lexical stack (LIFO)	       */
  4   208       2 symptr	ptr,		/* pointer to symbol (must be valid) */
  4   209       2 symlen	fixed bin,	/* length of symbol (may be 0)       */
  4   210       2 line	fixed bin (21),	/* line where symbol begins	       */
  4   211       2 symbol	fixed bin,	/* encoding of symbol	       */
  4   212       2 true	fixed bin,
  4   213       2 false	fixed bin,
  4   214       2 loc	fixed bin;
  4   215 dcl ls_top	fixed bin;	/* location of top of lexical stack  */
  4   216 dcl cur_lex_top	(100) fixed bin; /* current lex top stack	       */
  4   217 dcl parse_stack	(100) fixed bin; /* parse stack		       */
  4   218 dcl altn		fixed bin;	/* APPLY alternative number	       */
  4   219 dcl current_state	fixed bin;	/* number of current state	       */
  4   220 dcl test_symbol	fixed bin;	/* encoding of current symbol	       */
  4   221 dcl current_table	fixed bin;	/* number of current table	       */
  4   222 dcl i		fixed bin (21);
  4   223 dcl la_ct		fixed bin;	/* # terminals in look-ahead stack   */
  4   224 dcl la_get	fixed bin;	/* where to get next symbol	       */
  4   225 dcl la_need	fixed bin;	/* # look-ahead symbols needed       */
  4   226 dcl la_put	fixed bin;	/* where to put next symbol	       */
  4   227 dcl la_use	fixed bin (22);	/* where stack to test with	       */
  4   228 
  4   229 dcl (m, n)	fixed bin;
  4   230 
  4   231 dcl next_state	fixed bin;	/* number of next state	       */
  4   232 dcl ps_top	fixed bin;	/* location of top of parse stack    */
  4   233 dcl recov_msg	char (150) var;
  4   234 dcl rulen		fixed bin;	/* APPLY rule number	       */
  4   235 dcl t		fixed bin;
  4   236 dcl ioa_		entry options (variable);
  4   237 
  4   238 geterm: proc (idx, ids) returns (char (100) var);
  4   239 
  4   240 dcl (idx, ids)	fixed bin;
  4   241 dcl temp		char (100) var;
  4   242 dcl c_str		char (20000) based;
  4   243 
  4   244       temp = "";
  4   245 get_rest:
  4   246       if (ids > 0)
  4   247       then if (ls (-ids).symlen > 0)
  4   248 	 then do;
  4   249 	    temp = temp || """";
  4   250 	    temp = temp || substr (ls (-ids).symptr -> c_str, 1,
  4   251 	       min (50, ls (-ids).symlen));
  4   252 	    temp = temp || """";
  4   253 	    return (temp);
  4   254 	 end;
  4   255       if (idx = 0)
  4   256       then temp = "--EOI--";
  4   257       else temp = substr (TC, TL.pt (idx), TL.ln (idx));
  4   258       return (temp);
  4   259 
  4   260 getermc: entry (idx, ids) returns (char (100) var);
  4   261 
  4   262       if (idx = 0)
  4   263       then temp = "--EOI--";
  4   264       else temp = substr (TC, TL.pt (idx), TL.ln (idx));
  4   265       temp = temp || " ";
  4   266       goto get_rest;
  4   267    end; 
  4   268 scanner: proc;
  4   269 
  4   270       ls (-la_put).symptr = addr (rl_c (rl_i));
  4   271       ls (-la_put).symlen = 0;
  4   272       cft.t, cft.f = 0;
  4   273       ls (-la_put).symbol = 9;
  4   274       ls (-la_put).loc = gvx.tot_len + 1;
  4   275       ls (-la_put).true = gvx.tot_len + 4;
  4   276       ls (-la_put).false = gvx.tot_len + 5;
  4   277       i = index ("(^|&)
  4   278  ", rl_c (rl_i));
  4   279       if (i > 0)
  4   280       then do;
  4   281          rl_i = rl_i + 1;
  4   282          ls (-la_put).symbol = min (8, i + 2);
  4   283          return;
  4   284       end;
  4   285       if (rl_c (rl_i) = "{")
  4   286       then do;
  4   287          cft.op = teval_op;
  4   288          i = index (substr (rl_s, rl_i), "}");
  4   289          call add_length (i);
  4   290          cft.da = substr (rl_s, rl_i, i);
  4   291          rl_i = rl_i + i;
  4   292       end;
  4   293       else do;
  4   294          cft.op = tsrch_op;
  4   295          call scan;
  4   296          rl_i = expr_b + expr_l + 1;
  4   297          cft.cexpml = 100;		/* DO THIS RIGHT!		       */
  4   298          call tedsrch_$compile (addr (rl_c (expr_b)), expr_l,
  4   299 	  addr (cft.cexpml), "1"b, (dbase.lit_sw), msg, code);
  4   300          if (code ^= 0)
  4   301          then goto print_error;
  4   302 dcl bfb		fixed bin based;
  4   303          cft.cexpml = cft.cexpl + 4;
  4   304         call add_length((cft.cexpml));
  4   305       end;
  4   306       cft.siz = size (cft);
  4   307       call end_cf;
  4   308    end scanner; 




  4   309 rule_0: proc;
  4   310 
  4   311       if req_ch = "g"
  4   312       then i = 1;
  4   313       else i = 2;
  4   314       ls (-1).symbol = i;
  4   315       ls (-1).symptr = addr (rl_c (rl_i));
  4   316       ls (-1).symlen = 0;
  4   317       ls (-1).loc, ls (-1).true, ls (-1).false = 0;
  4   318       la_put = 2;
  4   319       la_ct = 1;
  4   320 
  4   321       return;
  4   322    end rule_0;
  4   323 
  5     1 /* -table ted_gv_t_.incl.pl1
  5     2*-tl
  5     3*-sem ted_gv_.incl.pl1
  5     4*-parse */
  5     5 sem: proc(rulen,altn);
  5     6 
  5     7 dcl rulen		fixed bin,
  5     8     altn		fixed bin;
  5     9 
  5    10       goto rule(rulen);
  5    11 
  5    12 define: proc(where,which);
  5    13 
  5    14 dcl where		fixed bin,	/* where thread begins */
  5    15     which		fixed bin;	/* defined value */
  5    16 dcl i		fixed bin;
  5    17 dcl j		fixed bin;
  5    18 
  5    19       i = where;
  5    20       do while(i ^= 0);
  5    21          j = gvx.word (i);
  5    22          if db_gv then call ioa_$nnl ("^/^-define(^2i)=^i", i, which);
  5    23          gvx.word (i) = which;
  5    24          i = j;
  5    25       end;
  5    26 
  5    27    end define;



  5    28 thread: proc(where,which);
  5    29 dcl (where,which) fixed bin;
  5    30 
  5    31       do i = where
  5    32          repeat(gvx.word (i))
  5    33          while(gvx.word (i)^=0);
  5    34       end;
  5    35       if db_gv then call ioa_ ("^-thread(^2i)=^i", i, which);
  5    36       gvx.word (i) = which;
  5    37    end thread;



  5    38 /* <lex_order>	::= g* v* ( ^ '| & ) '040 X ! */
  5    39 
  5    40 /* <gv>	::= <rest> ! */
  5    41 
  5    42 /* <rest>	::= g* <srch> '040 ! */
  5    43 rule(0003):			/* inclusive search		       */
  5    44 /****		 bring the TRUE thread to here		       */
  5    45       if db_gv then call show_stk (2);
  5    46 /****      call define(ls.true(ls_top-1), gvx.tot_len+4);		       */
  5    47       call define(ls.true(ls_top-1), ls.loc (ls_top));
  5    48 /****		 Make False thread fail			       */
  5    49       call define(ls.false(ls_top-1),0);
  5    50 
  5    51 /* <rest>	::= g* '040 ! */
  5    52 rule(0004):			/* no search needed		       */
  5    53       goto done_parse;
  5    54 
  5    55 /* <rest>	::= v* <srch> '040 ! */
  5    56 rule(0005):			/* exclusive search wanted	       */
  5    57       if db_gv then call show_stk(2);
  5    58 /****		 Make TRUE thread fail			       */
  5    59       call define(ls.true(ls_top-1),0);
  5    60 /****		 bring FALSE thread to here			       */
  5    61 /****      call define(ls.false(ls_top-1),gvx.tot_len+5);		       */
  5    62       call define(ls.false(ls_top-1),ls.loc(ls_top));
  5    63       goto done_parse;
  5    64 
  5    65 show_stk: proc (N);
  5    66 dcl N		fixed bin;
  5    67 dcl db_I		fixed bin;
  5    68 	do db_I = ls_top-N to ls_top;
  5    69 	   call ioa_$nnl ("^/^2i loc=^i^-true=^i^-false=^i", db_I, ls.loc (db_I),
  5    70 	      ls.true (db_I), ls.false (db_I));
  5    71 	end;
  5    72        end show_stk;
  5    73 
  5    74 /* <srch>	::= <srch> '| <y> ! */
  5    75 rule(0006):
  5    76 /**** 		bring <srch> false thread to <y>		       */
  5    77       if db_gv then call show_stk (2);
  5    78       call define(ls.false(ls_top-2),ls.loc(ls_top));
  5    79 /**** 		thread <srch> true onto <y> true list		       */
  5    80       call thread(ls.true(ls_top), ls.true(ls_top-2));
  5    81       ls.true(ls_top-2) = ls.true(ls_top);
  5    82       ls.false(ls_top-2) = ls.false(ls_top);
  5    83       return;
  5    84 
  5    85 /* <srch>	::= <y> ! */
  5    86 /* <y>	::= <y> & <z> ! */
  5    87 rule(0008):
  5    88       if db_gv then call show_stk (2);
  5    89 /****		 bring <y> true thread to <z>			       */
  5    90 	call define(ls.true(ls_top-2),ls.loc(ls_top));
  5    91 /****		 thread <y> false onto <z> false list		       */
  5    92 	call thread(ls.false(ls_top), ls.false(ls_top-2));
  5    93 	ls.true(ls_top-2) = ls.true(ls_top);
  5    94 	ls.false(ls_top-2) = ls.false(ls_top);
  5    95 	return;
  5    96 
  5    97 /* <y>	::= <z> ! */
  5    98 /* <z>	::= ^ <w> ! */
  5    99 rule(0010):
  5   100 /****		just reverse the threads on the entry		       */
  5   101 	ls(ls_top-1) = ls(ls_top);
  5   102 	ls.true(ls_top-1) = ls.false(ls_top);
  5   103 	ls.false(ls_top-1) = ls.true(ls_top);
  5   104 	return;
  5   105 
  5   106 /* <z>	::= <w> ! */
  5   107 /* <w>	::= X ! */
  5   108 
  5   109 /* <w>	::= ( <srch> ) ! */
  5   110 rule(0013):
  5   111 /****		pull the entry out from the parens		       */
  5   112 	ls(ls_top-2) = ls(ls_top-1);
  5   113 	return;
  5   114 
  5   115 end;
  4   324 
  4   325 
  4   326    end;
  4   327 
  4   328 
  4   329 /* END INCLUDE FILE ..... ted_gv_p_.incl.pl1 .....		       */
     4929 
  6     1 /* BEGIN INCLUDE FILE ..... ted_gv_t_.incl.pl1 .....
  6     2* 8/04/77  1005.2 mst Th. From >udd>Multics>jaf>TED>ted_gv_.lrk */
  6     3 
  6     4 dcl	1 ted_gv_t_$TL	ext static,
  6     5 	  2 TLsize	fixed bin,
  6     6 	  2 TL(9),
  6     7 	    3(pt,ln)	fixed bin(17)unal;
  6     8 
  6     9 dcl	1 ted_gv_t_$TC	ext static,
  6    10 	  2 TCsize	fixed bin,
  6    11 	  2 TC	char(11);
  6    12 
  6    13 dcl	1 ted_gv_t_$DPDA	ext static,
  6    14 	  2 DPDAsize	fixed bin,
  6    15 	  2 DPDA(96),
  6    16 	    3(v1,v2)	fixed bin(17)unal;
  6    17 dcl	DPDAp	ptr;
  6    18 
  6    19 /*   END INCLUDE FILE ..... ted_gv_t_.incl.pl1 ..... */
     4930 
     4931 
     4932 dcl tbp		ptr;
     4933 /****dcl req_ch	char (1);					       */
     4934 
     4935 add_length: proc (incr);
     4936 
     4937 dcl incr		fixed bin (21);
     4938 
     4939       cf.len = cf.len + incr;
     4940       if (gvx.max_len < gvx.tot_len + divide (cf.len + 3, 4, 24, 0))
     4941       then do;
     4942          msg = "Gxx) Global statement too long.";
     4943          goto add_request;
     4944       end;
     4945 
     4946    end add_length;
     4947       end tedgv_;
     4948 
     4949 
     4950 dcl gme2		fixed bin (21);
     4951 
     4952 
     4953 gv_dump: entry;
     4954       call tedshow_ (comptr, "gvx");
     4955       return;
     4956 
     4957 
     4958 gv_srch: entry;
     4959 
     4960 dcl 1 gb		like b based (gbp);
     4961 dcl g_s		char (gb.b_.r.re) based (gb.cur.sp);
     4962 dcl g_c		(gb.b_.r.re) char (1) based (gb.cur.sp);
     4963 
     4964 dcl gsb		fixed bin (21) defined (gb.a_.l.re (1));
     4965 dcl gse		fixed bin (21) defined (gb.a_.r.le (2));
     4966 
     4967 common:
     4968       call init_cfp (gvx_p, gv_work);
     4969       if (gvx.tot_len = 0)
     4970       then do;
     4971          msg = "Gcu) No prior execution of";
     4972          goto add_request;
     4973       end;
     4974       NLlast = gvx.printing & gvNL;
     4975       if (db_gv & (b.a_.l.re (1) = 1))
     4976       then call tedshow_ (comptr, "gvx");
     4977 
     4978 dcl last_op	fixed bin;
     4979 dcl adr_sw	bit (1);
     4980       last_op = 0;
     4981       gvx.ic = 1;
     4982       b.present (1), b.present (2) = "1"b;
     4983       do while ("1"b);
     4984          cfp = addr (gvx.word (gvx.ic));
     4985          if (last_op ^= adr_op)
     4986          then do;
     4987 	  gsb = 1;
     4988 	  gse = 0;
     4989 	  adr_sw = "1"b;
     4990          end;
     4991          if fix_addr (gsb) & fix_addr (gse)
     4992          then do;
     4993 	  if (gsb > gse)		/* can't wrap-around, either	       */
     4994 	  then adr_sw = ""b;
     4995          end;
     4996          else adr_sw = ""b;
     4997          if ^adr_sw			/* address does not exist,	       */
     4998          then gse = 0;		/* ..skip next operation	       */
     4999 
     5000          last_op = cf.op;
     5001          if db_gv then do;
     5002 	  call tedshow_ (comptr, "cf");
     5003 	  call ioa_$ioa_switch (db_output, "sw=^b ^i:^i", adr_sw, gsb, gse);
     5004          end;
     5005 (subscriptrange): goto srch (cf.op);
     5006 
     5007 srch (01):			/* ( address processing	       */
     5008          gsb = cfa.ad1;
     5009          gse = cfa.ad2;
     5010          adr_sw = "1"b;
     5011          goto srchdone_inc;
     5012 
     5013 srch (-5):			/* evaluation test		       */
     5014          call tedeval_ (dbase_p, addr (cft.da), (cft.len), bp, null (), 0,
     5015 	    result, msg, code);
     5016          if (code ^= 0)
     5017          then goto print_error;
     5018          if (result = "0") | (result = "false")
     5019          then gvx.ic = cft.f;
     5020          else gvx.ic = cft.t;
     5021          goto testdone;
     5022 
     5023 srch (-6):			/* search test		       */
     5024          call tedsrch_$search (addr (cft.cexpml), bp, b.a_.l.le (1),
     5025 	    b.a_.r.re (2), b.a_.l.re (1), b.a_.r.le (2), gme2, msg, code);
     5026          if (code = 0)
     5027          then gvx.ic = cft.t;
     5028          else if (code = 1)
     5029          then gvx.ic = cft.f;
     5030          else goto print_error;
     5031 testdone:
     5032          if (gvx.ic = 0)
     5033          then return;
     5034          goto srchdone; 



     5035 srch (-7):			/* test done, was success	       */
     5036 				/* let's make the data available     */
     5037          cllen = b.a_.r.re (2) - b.a_.l.le (1) + 1;
     5038          clloc = b.a_.l.le (1);
     5039          call tedpseudo_ (gbp, b.cur.sn, addr (b_c (clloc)), cllen);
     5040          gbp -> b.gb.l.ln = b.gb.l.ln;
     5041          old_bp = bp;
     5042          bp = gbp;
     5043          b.a_.l.le (1), b.a_.l.re (1) = b.b_.l.le;
     5044          b.a_.r.le (2), b.a_.r.re (2) = b.b_.l.re;
     5045          goto srchdone_inc; 



     5046 fix_addr: proc (val) returns (bit (1)); /* 1-result exists  0-doesn't	       */
     5047 
     5048 dcl val		fixed bin (21);	/* value to be adjusted	       */
     5049 
     5050 dcl tv		fixed bin (21);	/* temp value		       */
     5051 
     5052       if (val < 1)			/* this means $ or $-N	       */
     5053       then do;
     5054          val = -val;		/* (I think better positive)	       */
     5055 				/* window never in effect here       */
     5056          tv = b.b_.r.re - b.b_.r.le + 1;/* how big upper part?	       */
     5057          if (val < tv)
     5058          then do;
     5059 	  val = b.b_.r.re - val;
     5060 	  return ("1"b);		/* it is:  r.le <= val <= r.re       */
     5061          end;
     5062          val = val - tv;		/* how much "hangs over"?	       */
     5063          val = b.b_.l.re - val;	/* go that far in lower part	       */
     5064          return (val > 0);
     5065       end;
     5066       if (val <= b.b_.l.re)		/* assumes b.b_.l.le=1 ALWAYS	       */
     5067       then return ("1"b);		/* it is: l.le <= val <= l.re	       */
     5068       val = val - b.b_.l.re;		/* how much "hangs over"?	       */
     5069       val = b.b_.r.le + val - 1;	/* go that far in upper part	       */
     5070       return (val <= b.b_.r.re);
     5071 
     5072    end fix_addr; 



     5073 dcl 1 ln_		int static,
     5074       2 dec6	pic "zzzzz9",
     5075       2 tab	char (1) init ("	"); 

     5076 srch (10):			/* = - linenumber */
     5077          if ^adr_sw
     5078          then goto srchdone_inc;
     5079          dec6 = b.gb.l.ln;
     5080          call iox_$put_chars (iox_$user_output, addr (dec6), 6, 0);
     5081          goto srchdone_inc; 




     5082 srch (03):			/* P - print w/ linenumber	       */
     5083          if ^adr_sw
     5084          then goto srchdone_inc;
     5085          dec6 = b.gb.l.ln;
     5086          call iox_$put_chars (iox_$user_output, addr (dec6), 7, 0);
     5087 
     5088 srch (02):			/* p - print */
     5089          if adr_sw
     5090          then call print;
     5091          goto srchdone_inc; 




     5092 /**** M and K (m and k) also are the same. Deleting the destination buffer   */
     5093 /****  was done before the request processing began.		       */
     5094 srch (04):			/* K - kopy-append */
     5095 srch (05):			/* M - move-append */
     5096 srch (06):			/* k - kopy */
     5097 srch (07):			/* m - move */
     5098          if ^adr_sw
     5099          then goto srchdone_inc;
     5100          b.cd.l.re = gsb;		/* set source		       */
     5101          b.cd.r.le = gse;
     5102          tbp = ptr (dbase_p, cfmk.cb_r);
     5103          tbp -> b.cd.r.re = tbp -> b.b_.r.re + 1; /* set destination       */
     5104          call buffer_buffer_copy (gbp, tbp, "0"b);
     5105          if (cf.op = 4) | (cf.op = 6)
     5106          then goto srchdone_inc;
     5107 
     5108 srch (09):			/* d - delete */
     5109          if ^adr_sw
     5110          then goto srchdone_inc;
     5111          call delete;
     5112          call iso_line;
     5113          goto srchdone_inc; 




     5114 /*-*/
     5115 srch (19):			/* c - change */
     5116          if ^adr_sw
     5117          then goto srchdone_inc;
     5118          call delete;
     5119          goto aci_com;
     5120 srch (18):			/* a - append */
     5121          gsb = gse + 1;
     5122 srch (20):			/* i - insert */
     5123          if ^adr_sw
     5124          then goto srchdone_inc;
     5125          call openup;
     5126 aci_com:
     5127          call add_2l (""b, addr (cf.da), (cf.len), NLct_check);
     5128          goto srchdone_inc; 



     5129 dcl tp		ptr;
     5130 srch (08):			/* s -  substitute */
     5131          tp = addr (cfx.cexpml);
     5132          gvx.ic = gvx.ic + cfx.siz;	/* move past the search part	       */
     5133          cfp = addr (gvx.word (gvx.ic));
     5134          if adr_sw
     5135          then call substitute (tp);
     5136          do while (cf.op < 0);	/* skip any unused "replace" parts   */
     5137 	  gvx.ic = gvx.ic + cfx.siz;
     5138 	  cfp = addr (gvx.word (gvx.ic));
     5139          end;
     5140          goto srchdone; 



     5141 srch (15):			/* u - lowercase translate */
     5142          if ^adr_sw
     5143          then goto srchdone_inc;
     5144          call upper_lower (addr (cfx.cexpml), "0"b);
     5145          goto srchdone_inc;
     5146 srch (16):			/* U - uppercase translate */
     5147          if ^adr_sw
     5148          then goto srchdone_inc;
     5149          call upper_lower (addr (cfx.cexpml), "1"b);
     5150          goto srchdone_inc; 




     5151 srch (13):			/* l - linefeed to user_output */
     5152 srch (11):			/* t - type to user_output */
     5153          tbp = iox_$user_output;
     5154          goto gv_tT;
     5155 
     5156 srch (14):			/* L - linefeed to error_output */
     5157 srch (12):			/* T - type to error_output */
     5158          tbp = iox_$error_output;
     5159 gv_tT:
     5160          if ^adr_sw
     5161          then goto srchdone_inc;
     5162          call iox_$put_chars (tbp, addr (cf.da), (cf.len), 0);
     5163          goto srchdone_inc;
     5164 
     5165 srch (17):			/* { - evaluation */
     5166          if ^adr_sw
     5167          then goto srchdone_inc;
     5168          gb.present (1), gb.present (2) = "1"b;
     5169 /****		tedeval_ modifies 3rd arg, so (cf.len) is used.	       */
     5170          call tedeval_ (dbase_p, addr (cf.da), (cf.len), gbp, null (), 0,
     5171 	    result, msg, code);
     5172          if (code ^= 0)
     5173          then goto print_error;
     5174          if (result ^= "")
     5175          then call ioa_ ("g* {...} has unexpected result of ""^a"".", result);
     5176          goto srchdone_inc; 




     5177 srch (22):			/* > -stop global if, goto */
     5178          if ^adr_sw
     5179          then goto srchdone_inc;
     5180          call tedset_ptr_ (dbase_p, cf.da, code);
     5181          if (code = 10)
     5182          then goto rq_err;		/*  return ("1"b); */
     5183          old_bp -> b.gb.l.le, old_bp -> b.gb.l.re
     5184 	    = old_bp -> b.gb.r.re;
     5185          old_bp -> b.gb.l.le = old_bp -> b.gb.l.le + 1;
     5186 				/* STOP here		       */
     5187          goto srch (0); 



     5188 dcl (cllen, clloc)	fixed bin (21);
     5189 dcl old_bp	ptr;
     5190 
     5191 srch (21):			/* \040 - never can happen	       */
     5192 srch (-1):			/* literal replacement	       */
     5193 srch (-2):			/* & replacement		       */
     5194 srch (-3):			/* x\= replacement		       */
     5195 srch (-4):			/* \g{...} replacement	       */
     5196          signal condition (should_not_be_here);
     5197          goto nx_line;
     5198 
     5199 srchdone_inc:
     5200          gvx.ic = gvx.ic + cf.siz;
     5201 srchdone:
     5202       end;
     5203 srch (00):			/* end of program		       */
     5204       bp = old_bp;
     5205       gb.noref = "1"b;
     5206       if ^gb.mod_sw
     5207       then return;			/* no change made		       */
     5208       llen = gb.b_.l.re - gb.b_.l.le + 1; /* how long is left part	       */
     5209       rlen = gb.b_.r.re - gb.b_.r.le + 1; /* how long is right part	       */
     5210       if (rlen + llen ^= cllen)
     5211       then goto srch_mod;
     5212       if (llen > 0)			/* is left part different than it    */
     5213       then do;			/* ..was when we started?	       */
     5214          if substr (b_s, clloc, llen) ^= substr (g_s, gb.b_.l.le, llen)
     5215          then goto srch_mod;
     5216       end;
     5217 dcl (llen, rlen)	fixed bin (21);
     5218       if (rlen > 0)			/* is right part different than it   */
     5219       then do;			/* ..was when we started?	       */
     5220          if substr (b_s, clloc + llen, rlen) ^= substr (g_s, gb.b_.r.le, rlen)
     5221          then goto srch_mod;
     5222       end;
     5223       return;			/* no effective change made	       */
     5224 srch_mod:
     5225       b.mod_sw = "1"b;		/* make sure modification is known   */
     5226 				/* ..(add_2l might not get done)     */
     5227       b.a_.l.re (1) = b.a_.l.le (1);
     5228       call openup;			/* insert "post" data	       */
     5229       if (b.maxln > -1)
     5230       then b.maxln = b.maxln - 1;	/* taking a line out	       */
     5231       if (llen > 0)
     5232       then call add_2l (ted_safe, addr (g_c (gb.b_.l.le)), llen, NLct_check);
     5233       if (rlen > 0)
     5234       then call add_2l (ted_safe, addr (g_c (gb.b_.r.le)), rlen, NLct_check);
     5235       b.b_.r.le = b.b_.r.le + cllen;	/* get rid of "pre" data	       */
     5236       b.a_.r.le (2) = b.b_.l.re;	/* ..get rid of dangling addr	       */
     5237       return;
     5238    end gv_compile; 
     5239 /* . . . EXTERNAL ENTRIES . . . */
     5240 
     5241 dcl (addcharno, addr, addrel, byte, char, codeptr, convert, copy, divide,
     5242     fixed, hbound, index, length, lbound, low, ltrim, max, min, null, ptr,
     5243     rank, rel, reverse, rtrim, search, size, string, substr, translate,
     5244     unspec, verify
     5245     )		builtin;
     5246 
     5247 /**** <<<<----- dcl_tedpromote_.incl.pl1 tedpromote_		       */
     5248 tedpromote_:			/* get a larger data buffer	       */
     5249    entry (abp, al);
     5250 /****dcl (
     5251*/****abp		ptr,		/* -> buffer to promote	       */
     5252 /****al		fixed bin (21)	/* amount not fitting	       */
     5253 /****)		parm;		/* ----->>>>		       */
     5254 
     5255       bp = abp;
     5256       dbase_p = ptr (bp, 0);
     5257       call promote (al);
     5258       return;
     5259 
     5260 /**** <<<<----- dcl_tedcloseup_.incl.pl1 tedcloseup_		       */
     5261 tedcloseup_:			/* move all buffer data to lower     */
     5262    entry (abp);
     5263 /****dcl (
     5264*/****abp		ptr		/* -> to buffer to convert	       */
     5265 /****)		parm;		/* ----->>>>		       */
     5266 
     5267       dbase_p = ptr (abp, 0);
     5268       bp = abp;
     5269       call promote$seg;
     5270       return;
     5271 
     5272 
     5273 /**** <<<<----- dcl_tedpseudo_.incl.pl1 tedpseudo_		       */
     5274 tedpseudo_:			/* make a pseudo (read-only) buffer  */
     5275    entry (abp, asn, asp, al);
     5276 dcl (
     5277     abp		ptr,		/* -> to buffer to convert	       */
     5278     asn		fixed bin,	/* segno of data (-1 if ^read)       */
     5279     asp		ptr,		/* -> the data		       */
     5280     al		fixed bin (21)	/* the length of it		       */
     5281     )		parm;		/* ----->>>>		       */
     5282 
     5283       bp = abp;
     5284       dbase_p = ptr (bp, 0);
     5285       if db_ted
     5286       then call ioa_$ioa_switch (db_output, "pseudo b(^a) ^i)^p ^i", b.name, asn, asp, al);
     5287       if (b.cur.sn ^= 0)		/* if something here, scrap it       */
     5288       then call delete$all;		/* iso_line not needed	       */
     5289       b.maxln = NLct_unknown;
     5290       b.pend.sp = asp;
     5291       b.pend.sn = asn;
     5292       b.pend.pn, b.pend.ast, b.pend.mbz = 0;
     5293       b.newb = tedcommon_$no_data;
     5294       b.newb.l.le = 1;
     5295       b.newb.l.re, b.newb.r.re = al;
     5296       b.newb.r.le = al + 1;		/* upper part is empty	       */
     5297       b.pseudo = "1"b;
     5298       call new_cur;			/* set new values for bl/br/al/ar    */
     5299       if db_ted
     5300       then call tedshow_ (bp, "bcb");
     5301 
     5302       return;			/* pseudo_buf */ 
     5303 act: entry;			/* handle the old form of active     */
     5304 				/*  function accessing.	       */
     5305 
     5306 dcl act_name	char (5) int static init ("(act)");
     5307 dcl marker	char (1);
     5308 dcl arg_max	fixed bin;
     5309 dcl arg_l		fixed bin (21);
     5310 
     5311       marker = byte (11);		/* VT - not likely in argument data  */
     5312 
     5313       call tedget_buffer_ (null (), addr (act_name), length (act_name), bp,
     5314 	 msg);
     5315       if (bp = null ())
     5316       then do;
     5317          call ioa_ ("Not in ted");
     5318          return;
     5319       end;
     5320       dbase_p = ptr (bp, 0);
     5321       call delete$all;		/* iso_line not needed	       */
     5322       call cu_$arg_count (arg_max, code);
     5323       j = 1;
     5324       do argno = 1 to arg_max;
     5325          call cu_$arg_ptr (argno, ttp, arg_l, code);
     5326          if (argno ^= 1)		/* place marker between args	       */
     5327          then call add_2l ("0"b, addr (marker), 1, 0);
     5328          call add_2l ("0"b, ttp, arg_l, 0);
     5329       end;
     5330 
     5331       return /* ted_act */; 
     5332 blank:				/* set blank mode		       */
     5333    entry;
     5334 				/* +++++ <<>> */
     5335       com_blank = "1"b;
     5336       com1_blank = "1"b;
     5337       return;
     5338 
     5339 noblank:				/* set ^blank mode		       */
     5340    entry;
     5341 				/* +++++ <<>> */
     5342       com_blank = "0"b;
     5343       com1_blank = "0"b;
     5344       return;
     5345 
     5346 partblank:			/* set partblank mode	       */
     5347    entry;
     5348 				/* +++++ <<>> */
     5349       com_blank = "0"b;
     5350       com1_blank = "1"b;
     5351       return;
     5352 
     5353 passthru:				/* disable PI then signal it	       */
     5354    entry;
     5355 				/* +++++ <<>> */
     5356       pi_passthru = "1"b;
     5357       signal condition (program_interrupt);
     5358       return;
     5359 
     5360 clear_chars_moved: entry (clear_name);
     5361 dcl clear_name	char (*);
     5362       cm_val = -1;
     5363 dcl cm_val	fixed bin (30) init (0);
     5364 
     5365 show_chars_moved: entry;
     5366 
     5367 show_again:
     5368       hold_db_output = db_output;
     5369       if (db_output = null ())	/* make sure there is a switch for   */
     5370       then db_output = iox_$user_output;/* ..debugging output	       */
     5371       if (chars_moved >= 0)
     5372       then do;
     5373          char_pic = chars_moved;
     5374          call ioa_$ioa_switch (db_output, "^a chars moved", char_pic);
     5375          total_chars_moved = total_chars_moved + chars_moved;
     5376       end;
     5377       chars_moved = cm_val;
     5378       if (cm_val = 0)
     5379       then return;
     5380       if (total_chars_moved >= 0)
     5381       then do;
     5382          char_pic = total_chars_moved;
     5383          call ioa_$ioa_switch (db_output, "^10a^a chars moved", clear_name, char_pic);
     5384       end;
     5385       chars_moved = -1;
     5386       total_chars_moved = 0;
     5387       db_output = hold_db_output;	/* put back old value	       */
     5388       return;
     5389 dcl char_pic	pic "zzz,zzz,zzz,zz9";
     5390 dcl (chars_moved	init (-1),
     5391     total_chars_moved init (0)
     5392     )		fixed bin (30) int static;
     5393 
     5394 lnn: entry; ln_sw = "1"b; return;
     5395 lnf: entry; ln_sw = ""b; return;
     5396 dcl ln_sw		bit (1) int static init (""b);
     5397 
     5398 lgn: entry;			/* turn on long switches	       */
     5399       dbs = "1"b;
     5400       i = 2;
     5401       goto set_db;
     5402 
     5403 lgf: entry;			/* turn off long switchs	       */
     5404       dbs = "0"b;
     5405       i = 2;
     5406       goto set_db;
     5407 
     5408 dbn: entry;			/* turn on debugging switches	       */
     5409 
     5410 dcl dbs		bit (1);
     5411       dbs = "1"b;
     5412       i = 1;
     5413       goto set_db;
     5414 dbf: entry;			/* turn off debugging switchs	       */
     5415       dbs = "0"b;
     5416       i = 1;
     5417 dcl dim		builtin;
     5418 dcl arg		char (arg_l) based (ttp);
     5419 set_db:
     5420       call cu_$arg_ptr (1, ttp, arg_l, code);
     5421       if (code ^= 0)
     5422       then dbsw (*, i) = dbs;
     5423       else do;
     5424          do j = 1 to dim (swname, 1);
     5425 	  if (swname (j) = arg)
     5426 	  then do;
     5427 	     dbsw (j, i) = dbs;
     5428 	     return;
     5429 	  end;
     5430          end;
     5431          if (arg = "*") | (arg = "**")
     5432          then dbsw (*, i) = dbs;
     5433          else begin;
     5434 				/* dcl string	builtin;					       */
     5435 	     call com_err_ (0, "ted$db", "Valid args: ^a", string (swname));
     5436 	  end;
     5437       end;
     5438       return;
     5439 
     5440 dcl 1 db_lg	(12) based (addr (tedcommon_$etc.sws)),
     5441       2 dbsw	(2) bit (1) aligned;
     5442 dcl swname	(13) char (5) unal int static init (
     5443 		"ted  ", "addr ", "eval ", "sort ",
     5444 		"gv   ", "util ", "srch ", "glob ",
     5445 		"trac ", "Ed   ", "     ", "     ", "catch");
     5446 
     5447 dcl AZ		char (26) int static init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
     5448 dcl BS_C		char (1) int static init (""); /* \c */
     5449 dcl DBA		char (32) var;
     5450 dcl HT		char (1) int static init ("	");
     5451 dcl NLct_check	fixed bin (21) int static init (-2);
     5452 dcl NLct_unknown	fixed bin (21) int static init (-1);
     5453 dcl NLlast	bit (1);
     5454 dcl Psw		bit (1);
     5455 dcl SP		char (1) int static init (" ");
     5456 dcl SP_HT		char (2) int static init (" 	"); /* #160*/
     5457 dcl addr_undef	fixed bin int static options (constant) init (-1);
     5458 dcl af_bp		ptr;
     5459 dcl af_value	char (ted_data.return_string_l) var
     5460 		based (ted_data.return_string_p);
     5461 dcl after_l	fixed bin (21);
     5462 dcl alt_sw	bit (1);
     5463 dcl app_sw	bit (1);
     5464 dcl archive_$get_component entry (ptr, fixed bin (24), char (*), ptr,
     5465 		fixed bin (24), fixed bin (35));
     5466 dcl argname	char (7);
     5467 dcl argno		fixed bin;
     5468 dcl az		char (26) int static init ("abcdefghijklmnopqrstuvwxyz");
     5469 dcl b0_bp		ptr;
     5470 dcl b_depth	fixed bin;	/* depth of buffer remember stack */
     5471 dcl b_stack	(10) ptr;		/* buff remember stack (!b request)  */
     5472 dcl bc		fixed bin (24);
     5473 dcl ch		char (1);
     5474 dcl cleanup	condition;
     5475 dcl code		fixed bin (35);
     5476 dcl concealsw	bit (1);
     5477 dcl continue_to_signal_ entry (fixed bin (35));
     5478 dcl delim		char (1);
     5479 dcl enl		fixed bin (21);
     5480 dcl err_req	char (16) var;
     5481 dcl error_table_$inconsistent fixed bin (35) ext static;
     5482 dcl error_table_$insufficient_access fixed bin (35) ext static;
     5483 dcl error_table_$moderr external fixed bin (35);
     5484 dcl error_table_$noentry fixed bin (35) ext static;
     5485 dcl error_table_$no_component fixed bin (35) ext static;
     5486 dcl error_table_$unsupported_operation fixed bin (35) ext static;
     5487 dcl error_table_$zero_length_seg fixed bin (35) ext static;
     5488 dcl expr_b	fixed bin (21);	/* beginning of expression	       */
     5489 dcl expr_l	fixed bin (21);	/* length of expression	       */
     5490 dcl fcbp		ptr;
     5491 dcl file_c	(file_l) char (1) based (file_p);
     5492 dcl file_l	fixed bin (21);
     5493 dcl file_p	ptr;
     5494 dcl file_s	char (file_l) based (file_p);
     5495 dcl fo_sw		bit (1);
     5496 dcl gbp		ptr;		/* -> g* pseudo buffer	       */
     5497 dcl go_sw		bit (1);
     5498 dcl got_quit	bit (1);
     5499 dcl gvx_p		ptr;
     5500 dcl header_l	fixed bin (21);
     5501 dcl hold_de	fixed bin;
     5502 dcl i		fixed bin (21);
     5503 dcl ii		fixed bin (21);
     5504 dcl il		fixed bin (21);
     5505 dcl intsw		bit (1);
     5506 dcl iocb_ptr	ptr;
     5507 dcl j		fixed bin (21);
     5508 dcl jb		fixed bin (21);
     5509 dcl k		fixed bin (21);
     5510 dcl level		fixed bin (35) init (0);
     5511 dcl maxseg	fixed bin (21);
     5512 dcl me		fixed bin (21);
     5513 dcl me2		fixed bin (21);
     5514 dcl mi		fixed bin (21);
     5515 dcl ml		fixed bin (21);
     5516 dcl mrl_		entry (ptr, fixed bin (21), ptr, fixed bin (21));
     5517 dcl mustreprotect	bit (1);
     5518 dcl not_sw	bit (1);
     5519 dcl on_quit	bit (1);
     5520 dcl pdname	char (32) int static init (" ");
     5521 dcl pi_label	label;
     5522 dcl pi_passthru	bit (1) int static;
     5523 dcl pi_sw		fixed bin;
     5524 dcl program_interrupt condition;
     5525 dcl qedx_mode	bit (1);
     5526 dcl quit		condition;
     5527 dcl req_ch	char (1);
     5528 dcl req_chx	char (4) var;
     5529 dcl req_not	char (1);
     5530 dcl req_str	char (36) var;
     5531 dcl result	char (500) var;
     5532 dcl save_mod	bit (1);
     5533 dcl select	char (16);
     5534 				/**/ dcl should_not_be_here condition;
     5535 dcl sort_p	(3) ptr;		/* sorting work/work/output segs     */
     5536 dcl sort_sn	(3) fixed bin;	/* sequence #'s of them	       */
     5537 				/*dcl str		char (262143) based aligned;			       */
     5538 dcl sub_type	char (12) var;
     5539 dcl subf1		char (4);
     5540 dcl subf2		char (3);
     5541 dcl subfile_name	char (32) var;
     5542 dcl sub_p		ptr;
     5543 dcl subsw		bit (1);
     5544 dcl svlen		fixed bin (21);
     5545 dcl svpath	char (204);	/* temp storage of pathname	       */
     5546 dcl sys_info$max_seg_size fixed bin (35) ext static;
     5547 dcl tbi		fixed bin;
     5548 dcl tbp		ptr;
     5549 dcl tc		char (1);
     5550 dcl ted_fo_err	condition;
     5551 dcl ted_mode	fixed bin;
     5552 dcl ted_safe	bit (1) aligned;
     5553 dcl tedcleanup_	entry (ptr);
     5554 dcl tederror_table_$zero_length_buffer fixed bin (35) ext static;
     5555 dcl trustsw	bit (1);
     5556 dcl ttp		ptr;
     5557 dcl used		fixed bin (21);
     5558 dcl vgch		char (1);
     5559 dcl vgds		char (2) var;
     5560 dcl wct		fixed bin;
     5561 dcl which_mode	char (5);
     5562 dcl write_l	fixed bin (21);	/* length of file		       */
     5563 dcl wsw		bit (1);		/* 0- reading, 1- writing	       */
     5564 dcl xfe		fixed bin (21);
     5565 dcl xfi		fixed bin (21);
     5566 dcl xsw		bit (1);
     5567 dcl (sbp, dbp)	ptr;



     5568 
     5569 dcl command_query_	entry () options (variable);
     5570 dcl expand_pathname_$component entry (char (*), char (*), char (*), char (*),
     5571 		fixed bin (35));
     5572 dcl get_group_id_	entry () returns (char (32));
     5573 dcl get_pdir_	entry () returns (char (168));
     5574 dcl hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24),
     5575 		fixed bin (2), ptr, fixed bin (35));
     5576 dcl hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr,
     5577 		fixed bin (35));
     5578 dcl hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin,
     5579 		fixed bin (35));
     5580 dcl hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
     5581 dcl hcs_$terminate_noname entry (ptr, fixed bin (35));
     5582 dcl terminate_file_ entry (ptr, fixed bin (21), bit (*), fixed bin (35));
     5583 dcl hcs_$delete_acl_entries entry (char (*), char (*), ptr, fixed bin,
     5584 		fixed bin (35));
     5585 dcl cu_$cp	entry (ptr, fixed bin (21), fixed bin (35));
     5586 dcl cu_$arg_count	entry (fixed bin, fixed bin (35));
     5587 dcl cu_$arg_list_ptr entry (ptr);
     5588 dcl cu_$arg_ptr	entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
     5589 dcl ioa_		entry () options (variable);
     5590 dcl ioa_$ioa_switch entry () options (variable);
     5591 dcl ioa_$nnl	entry () options (variable);
     5592 dcl com_err_	entry () options (variable);
     5593 dcl NL		char (1) int static init ("
     5594 ");
     5595 
     5596 
     5597 dcl 1 seg_acl	aligned,		/* structure for adding one acl      */
     5598       2 userid	char (32),
     5599       2 access	bit (36),
     5600       2 ex_access	bit (36),
     5601       2 status	fixed bin (35);
     5602 
     5603 dcl 1 delete_acl	aligned,		/* structure for deleting one acl    */
     5604       2 userid	char (32),
     5605       2 status	fixed bin (35);
     5606 
     5607 dcl 1 fd		like b.file_d;
     5608 dcl hold_db_output	ptr;
     5609 dcl answer	char (10) var;
     5610 
     5611 dcl hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*),
     5612 		fixed bin (35));
     5613 dcl hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr,
     5614 		fixed bin (35));
     5615 dcl hcs_$status_minf entry (char (*), char (*), fixed bin (1),
     5616 		fixed bin (2), fixed bin (24), fixed bin (35));
     5617 
     5618 dcl iox_$attach_iocb entry (ptr, char (*)) returns (fixed bin (35));
     5619 dcl iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
     5620 dcl iox_$close	entry (ptr, fixed bin (35));
     5621 dcl iox_$control	entry (ptr, char (*), ptr, fixed bin (35));
     5622 dcl iox_$detach_iocb entry (ptr, fixed bin (35));
     5623 dcl iox_$error_output ptr ext static;
     5624 dcl iox_$find_iocb	entry (char (*), ptr, fixed bin (35));
     5625 dcl iox_$move_attach entry (ptr, ptr, fixed bin (35));
     5626 dcl iox_$open	entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
     5627 dcl iox_$put_chars	entry (ptr, ptr, fixed bin (21), fixed bin (35));
     5628 dcl iox_$user_output ptr ext static;
     5629 dcl string_sw	bit (1) defined (b.present (0));
     5630 dcl hold_db_ted	bit (1) aligned;
     5631 
     5632 dcl 1 CB		(dbase.bufnum) like b based (dbase.cba_p); 
     5633 
  7     1 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
  7     2 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
  7     3 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
  7     4 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
  7     5 /* BEGIN INCLUDE FILE ..... ted_.incl.pl1 ..... 12/08/77 J Falksen	       */
  7     6 /* 08/11/81 jaf Added version number in place of implied pad field	       */
  7     7 
  7     8 dcl ted_		entry (ptr, fixed bin (35)) options(variable);
  7     9 
  7    10 /*       call ted_ (ted_data_p,code);				       */
  7    11 dcl ted_data_version_1 fixed bin int static options (constant) init (1001);
  7    12 
  7    13 dcl 1 ted_data	based (ted_data_p),
  7    14       2 tedname	char (32) var,	/* name which should appear in error */
  7    15 				/*  messages		       */
  7    16       2 version	fixed bin (35),
  7    17       2 ted_com_p	ptr,		/* string to be initially executed   */
  7    18       2 ted_com_l	fixed bin (21),	/* length thereof		       */
  7    19       2 ted_mode	fixed bin,	/* ted operating mode	       */
  7    20 				/* 0 - NORMAL		       */
  7    21 				/* 1 - SAFE		       */
  7    22 				/* 2 - COM		       */
  7    23 				/* 3 - RESTART		       */
  7    24 
  7    25       2 arg_list_p	ptr,		/* pointer to the argument list      */
  7    26       2 arg_list_1	fixed bin,	/* first argument to be used	       */
  7    27       2 arg_list_n	fixed bin,	/* last argument to be used	       */
  7    28 
  7    29 /* To avoid forcing the caller to always manufacture an argument list for    */
  7    30 /*  arg_list_p to point to, ted_ will accept additional arguments (3...n).   */
  7    31 /*  If more than 2 are present, ted_'s argument pointer will be placed in    */
  7    32 /*  arg_list_p, 3 into arg_list_1 and the number of args into arg_list_n.    */
  7    33 
  7    34       2 return_string_p ptr,		/* active function return string     */
  7    35       2 return_string_l fixed bin (21), /* length thereof		       */
  7    36 				/* b(argn) is copied into this       */
  7    37 				/*  string if it exists	       */
  7    38       2 input_p	ptr,		/* pointer to data to be edited      */
  7    39       2 input_l	fixed bin (21),	/* length of data to be edited       */
  7    40 				/* if this exists, the the data is   */
  7    41 				/*  copied into b0		       */
  7    42       2 output_p	ptr,		/* pointer to output segment	       */
  7    43       2 output_l	fixed bin (21),	/* length of output data (output)    */
  7    44 				/* if output_p = null the  data is   */
  7    45 				/*  put back into input area	       */
  7    46       2 temp_dir	char (168);	/* directory to hold work segments   */
  7    47 
  7    48 dcl tederror_table_$ted_com_abort fixed bin(35) ext static;
  7    49 
  7    50 
  7    51 /* END INCLUDE FILE ..... ted_.incl.pl1 .....			       */
     5634 
  8     1 /* BEGIN INCLUDE FILE ..... ted_support.incl.pl1 ..... 03/16/81	       */
  8     2 
  8     3 /* more information may be found in ted_support.gi.info		       */
  8     4 
  8     5 dcl  ted_support_p ptr;
  8     6 dcl ted_support_version_2 fixed bin int static init(2);
  8     7 dcl 1 ted_support based(ted_support_p),
  8     8     2 version fixed bin,	/* 1				       */
  8     9     2 addr_ct fixed bin,	/* number of addresses given: 0,1,2 	  (IN) */
  8    10     2 checkpoint entry (	/* routine to update "safe" status        (IN) */
  8    11 	fixed bin(21),	/* amount of input used up		       */
  8    12 	fixed bin(21)),	/* amount of output used up		       */
  8    13 
  8    14     2 inp,		/***** input string parameters	       */
  8    15 			/* The input data may NOT be modified.	       */
  8    16       3 pt ptr,		/* pointer to base of data string         (IN) */
  8    17       3 sb fixed bin(21),	/* index of addressed string begin        (IN) */
  8    18       3 lno fixed bin(21),	/* linenumber in data string of sb        (IN) */
  8    19       3 se fixed bin(21),	/* index of addressed string end      (IN/OUT) */
  8    20       3 de fixed bin(21),	/* index of data end		  (IN) */
  8    21 
  8    22     2 out,		/***** output string parameters	       */
  8    23       3 pt ptr,		/* pointer to base of output string       (IN) */
  8    24       3 de fixed bin(21),	/* index of data end (already copied) (IN/OUT) */
  8    25       3 ml fixed bin(21),	/* max length of output string	  (IN) */
  8    26 
  8    27     2 req,		/***** request string parameters	       */
  8    28       3 pt ptr,		/* pointer to base of request string	  (IN) */
  8    29       3 cc fixed bin(21),	/* index of current character		  (IN) */
  8    30       3 nc fixed bin(21),	/* index of next character	        (IN/OUT) */
  8    31       3 de fixed bin(21),	/* index of data end	        (IN/OUT) */
  8    32       3 ml fixed bin(21),	/* max length of requsest buffer 	  (IN) */
  8    33 
  8    34 /* req.nc is initialized to req.de, i.e.  request line used-up.  A routine   */
  8    35 /* can set req.nc to 1, put some data into req and set req.de	       */
  8    36 /* appropriately.  The data will be the next ted requests executed after     */
  8    37 /* the routine returns.					       */
  8    38 			
  8    39 /* Or if req.nc is set equal to req.cc then the rest of the request line     */
  8    40 /* will be executed after return.				       */
  8    41 
  8    42     2 string_mode bit(1),	/* 0- line mode, 1- string mode 	  (IN) */
  8    43     2 current fixed bin(21),	/* current location		        (IN/OUT) */
  8    44 			/* current is initialized to "undefined"       */
  8    45     2 get_req entry (),	/* fill the request string with the next line  */
  8    46 			/*  from ted's input stream. req.de will be    */
  8    47 			/*  updated to reflect the new length.	       */
  8    48 			/* req.cc and req.nc are not changed.	       */
  8    49     2 proc_expr entry	/* process the expression for global execution */
  8    50 	(ptr,		/* -> ted_support structure		  [IN] */
  8    51 	char (168) var,	/* message text			 [OUT] */
  8    52 	fixed bin (35)),	/* completion code			 [OUT] */
  8    53     2 do_global entry	/* globally execute some action	       */
  8    54 	(entry (),	/* worker procedure			  [IN] */
  8    55 	char (1),		/* which action, "g" or "v"		  [IN] */
  8    56 	ptr,		/* -> ted_support structure		  [IN] */
  8    57 	char (168) var,	/* message text			 [OUT] */
  8    58 	fixed bin (35)),	/* completion code			 [OUT] */
  8    59     2 reg_exp_p ptr,	/* -> the remembered regular expression area   */
  8    60     2 bcb_p ptr;		/* -> buffer control block		       */
  8    61 /* _________________________________________________________________________ */
  8    62 /*			 ENTRY CONDITIONS			       */
  8    63 /* _________________________________________________________________________ */
  8    64 /* Upon entering, three substructures describe the environment in which the  */
  8    65 /* request is to operate. (Refer to the INPUT diagram) Note that the	       */
  8    66 /* "normal" operational steps are:				       */
  8    67 /* 1) ted copies the string from 1:inp.sb-1 to the output string	       */
  8    68 /* 2) ted_xyz_ takes care of the data from inp.sb:inp.se		       */
  8    69 /* 3) ted copies the string from inp.se+1:inp.de to the output string	       */
  8    70 /* 4) ted sets "." as (possibly) specified by xyz			       */
  8    71 
  8    72 /* The following 3 diagrams represent conditions upon entering ted_xyz_:     */
  8    73 /* _________________________________________________________________________ */
  8    74 /*	       req.pt		(\ represents NL)		       */
  8    75 /*    		|					       */
  8    76 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  8    77 /*		          |            |                      |	       */
  8    78 /*		       req.cc       req.de		   req.ml	       */
  8    79 /*				req.nc			       */
  8    80 /* _________________________________________________________________________ */
  8    81 /*	       inp.pt		(\ represents NL)		       */
  8    82 /*		|					       */
  8    83 /* [INPUT]	now is\the time\for all\good men\to come.\.....	       */
  8    84 /*		       |               |                 |	       */
  8    85 /*		    inp.sb          inp.se            inp.de	       */
  8    86 /* The request may make no modifications to the input string. It may make no */
  8    87 /*  assumptions about its location, i.e. that it occupies a segment all by   */
  8    88 /*  itself.						       */
  8    89 /* _________________________________________________________________________ */
  8    90 /*	       out.pt		(\ represents NL)		       */
  8    91 /*    		|					       */
  8    92 /* [OUTPUT]  ?	now is\........................................	       */
  8    93 /*	   |	      |                                       |	       */
  8    94 /*	current	   out.de				   out.ml	       */
  8    95 /* _________________________________________________________________________ */
  8    96 
  8    97 /* _________________________________________________________________________ */
  8    98 /*			 EXIT CONDITIONS			       */
  8    99 /* _________________________________________________________________________ */
  8   100 /* Assume a request replaces each addressed line with the string following   */
  8   101 /* it, (in this case "farfle") and leaves "." at the beginning of the range. */
  8   102 /*	       out.pt		(\ represents NL)		       */
  8   103 /*    		|					       */
  8   104 /* [OUTPUT]	now is\farfle\farfle\..........................	       */
  8   105 /*		       |            |                         |	       */
  8   106 /*		   current       out.de		   out.ml	       */
  8   107 
  8   108 /* _________________________________________________________________________ */
  8   109 /* 1) If the data after the string are to be treated as more ted requests,   */
  8   110 /*  the request data would be left like this.			       */
  8   111 /*	       req.pt		(\ represents NL)		       */
  8   112 /*    		|					       */
  8   113 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  8   114 /*		                   |   |                      |	       */
  8   115 /*			    req.nc   req.de		   req.ml	       */
  8   116 /* _________________________________________________________________________ */
  8   117 /* 2) If the request is going to return a string to be executed, the request */
  8   118 /*  data (and buffer) would be left like this:			       */
  8   119 /*	       req.pt		(\ represents NL)		       */
  8   120 /*    		|        					       */
  8   121 /* [REQUEST]	-1,.1p w\ /farfle/ 1,$P\.......................	       */
  8   122 /*		|       |                                     |	       */
  8   123 /*	       req.nc  req.de			   req.ml	       */
  8   124 
  8   125 /* These are special return codes relating to ted:		       */
  8   126 dcl (tederror_table_$Copy_Set,/* copy rest of input to output, and set "."   */
  8   127 			/*  from current. "rest of input" is the       */
  8   128 			/*  string which begins at char inp.se+1 and   */
  8   129 			/*  extends to inp.de. If the input has all    */
  8   130 			/*  been processed, then inp.se should be set  */
  8   131 			/*  to inp.de+1.			       */
  8   132      tederror_table_$NoChange,/* dont copy, dont set current	       */
  8   133      tederror_table_$Set,	/* dont copy, set current (in input buffer)    */
  8   134      tederror_table_$Error_Msg,/* msg is being returned.		       */
  8   135 			/*  no copy or set is done		       */
  8   136      tederror_table_$No_Delim1,/* missing 1st delimiter		       */
  8   137      tederror_table_$No_Delim2,/* missing 2nd delimiter		       */
  8   138      tederror_table_$No_Delim3)/* missing 3nd delimiter		       */
  8   139 		fixed bin(35)ext static;
  8   140 /* Any other codes returned must be standard system codes.		       */
  8   141 dcl  error_table_$unimplemented_version fixed bin(35) ext static;
  8   142 
  8   143 dcl  istr char(inp.de) based(inp.pt);	/* the input string		       */
  8   144 dcl  ichr(inp.de) char(1) based(inp.pt);
  8   145 dcl  ostr char(out.ml) based(out.pt);	/* the output string	       */
  8   146 dcl  ochr(out.ml) char(1) based(out.pt);
  8   147 dcl  rstr char(req.ml) based(req.pt);	/* the request string	       */
  8   148 dcl  rchr(req.ml) char(1) based(req.pt);
  8   149 
  8   150 /* These declarations are used if the expression search is needed by the     */
  8   151 /* request. There are 2 parts to getting an expression search done:	       */
  8   152 /* 	1) compiling	2) searching			       */
  8   153 /* If a function uses the remembered expression, it does this:	       */
  8   154 /*	call tedsrch_$search (ted_support.reg_exp_p,		       */
  8   155 /*	  ted_support.bcbp, string_begin, string_end, match_begin,	       */
  8   156 /*	  match_end, search_end, msg, code);			       */
  8   157 
  8   158 /* If a function utilizes an expression the user supplies, it must first be  */
  8   159 /* compiled:
  8   160*/*	if (expression_length > 0)				       */
  8   161 /*	then call tedsrch_$compile (addr (ichr (expression_begin)),	       */
  8   162 /*	  expression_length, ted_support.reg_exp_p,		       */
  8   163 /*	  ted_support.string_mode, ""b, msg, code);		       */
  8   164 /* This results in the remembered expression being changed to the one just   */
  8   165 /* compiled.						       */
  8   166 
  8   167 /* If a function wishes to utilize a function without it being remembered    */
  8   168 /* by ted, it may declare an area of its own and compile into it. It first   */
  8   169 /* must be initialized:					       */
  8   170 /*	dcl expr_area (200) bit (36);				       */
  8   171 /*	call tedsrch_$init_exp (addr (expr_area), size (expr_area));       */
  9     1 /* BEGIN INCLUDE FILE ..... tedsrch_.incl.pl1 ..... 10/21/82 J Falksen */
  9     2 
  9     3 dcl tedsrch_$init_exp entry (	/* initialize an expression area	       */
  9     4 	ptr,		/* -> compiled expression area	  [IN] */
  9     5 	fixed bin (21));	/*   length of area in words		  [IN] */
  9     6 
  9     7 dcl tedsrch_$compile entry (	/* compile a regular expression	       */
  9     8 	ptr,		/* -> regular expression to compile	  [IN] */
  9     9 	fixed bin (21),	/*   length thereof			  [IN] */
  9    10 	ptr,		/* -> compiled expression area	  [IN] */
  9    11 	bit (1)aligned,	/* 0- line mode	1- string mode	  [IN] */
  9    12 	bit (1)aligned,	/* 0- reg expr	1- literal expr	  [IN] */
  9    13 	char (168) var,	/* error message			 [OUT] */
  9    14 	fixed bin (35)	/* error status code		 [OUT] */
  9    15 		);
  9    16 
  9    17 dcl tedsrch_$search entry (	/* search for expression		       */
  9    18 	ptr,		/* -> compiled expression area	  [IN] */
  9    19 	ptr,		/* -> buffer ctl block for file	  [IN] */
  9    20 	fixed bin (21),	/* beginning of string to search in file  [IN] */
  9    21 	fixed bin (21),	/* end of string to search		  [IN] */
  9    22 	fixed bin (21),	/* beginning of match		 [OUT] */
  9    23 	fixed bin (21),	/* end of match			 [OUT] */
  9    24 	fixed bin (21),	/* end of string used for match	 [OUT] */
  9    25 	char (168)var,	/* error message return		 [OUT] */
  9    26 	fixed bin (35)	/* error status code		 [OUT] */
  9    27 		);
  9    28 
  9    29 
  9    30 /* END INCLUDE FILE ..... tedsrch_.incl.pl1 ..... */
  8   172 
  8   173 
  8   174 /* END INCLUDE FILE ..... ted_support.incl.pl1 .....		       */
     5635 
 10     1 /* BEGIN INCLUDE FILE ..... tedcommon_.incl.pl1 ..... 02/15/82 J Falksen */
 10     2 
 10     3 /*		         ted common data area			       */
 10     4 
 10     5 dcl 1 tedcommon_$id ext static,
 10     6       2 ted_vers char(12)var;		/*  version.revision	       */
 10     7 
 10     8 dcl 1 tedcommon_$no_data	like buf_des ext static;
 10     9 dcl 1 tedcommon_$no_seg	like seg_des ext static;
 10    10 
 10    11 dcl 1 tedcommon_$etc ext static,
 10    12       2 com_blank   bit(1)aligned,
 10    13       2 com1_blank  bit(1)aligned,
 10    14       2 caps	bit(1)aligned,
 10    15       2 reset_read	bit(1)aligned,
 10    16       2 sws,
 10    17         3 (db_ted, lg_ted)	bit(1)aligned,
 10    18         3 (db_addr, lg_addr)	bit(1)aligned,
 10    19         3 (db_eval, lg_eval)	bit(1)aligned,
 10    20         3 (db_sort, lg_sort)	bit(1)aligned,
 10    21         3 (db_gv, lg_gv)	bit(1)aligned,
 10    22         3 (db_util, lg_util)	bit(1)aligned,
 10    23         3 (db_srch, lg_srch)	bit(1)aligned,
 10    24         3 (db_glob, lg_glob)	bit(1)aligned,
 10    25         3 (db_trac, lg_sp4)	bit(1)aligned,
 10    26         3 (db_Ed, lg_sp3)	bit(1)aligned,
 10    27         3 (db_sp2, lg_sp2)	bit(1)aligned,
 10    28         3 (db_sp1, lg_sp1)	bit(1)aligned,
 10    29         3 (db_catch, lg_catch)bit(1)aligned,
 10    30       2 db_output ptr;
 10    31 
 10    32 /* END INCLUDE FILE ..... tedcommon_.incl.pl1 ..... */
     5636 
 11     1 /* BEGIN INCLUDE FILE ..... tedbase.incl.pl1 ..... 02/09/82 J Falksen       */
 11     2 
 11     3 dcl NORMAL	fixed bin (24) int static init (0),
 11     4     SAFE		fixed bin (24) int static init (1),
 11     5     COM		fixed bin (24) int static init (2),
 11     6     RESTART	fixed bin (24) int static init (3);
 11     7 
 11     8 dcl rc_close	fixed bin (24) int static init (100);
 11     9 dcl rc_fail	fixed bin (24) int static init (10);
 11    10 dcl rc_nop	fixed bin (24) int static init (2);
 11    11 dcl rc_keyerr	fixed bin (24) int static init (1);
 11    12 
 11    13 /*** the request line as both string and character		       */
 11    14 dcl rl_b		fixed bin (21);	/* where current req begins	       */
 11    15 dcl rl_i		fixed bin (21) defined (dbase.rl.l.le);
 11    16 dcl rl_l		fixed bin (21) defined (dbase.rl.l.re);
 11    17 dcl rl_c		(rl_l) char (1) based (dbase.rl.sp);
 11    18 dcl rl_s		char (rl_l) based (dbase.rl.sp);
 11    19 
 11    20 dcl 1 seg_des	based,		/* segment descriptor	       */
 11    21       2 sp	ptr,		/* -> segment		       */
 11    22       2 sn	fixed bin,	/* sequence # in dbase	       */
 11    23       2 pn	fixed bin,	/* part #, if in pool	       */
 11    24       2 ast	fixed bin,	/* size of aste		       */
 11    25       2 mbz	fixed bin;	/* --reserved		       */
 11    26 
 11    27       
 11    28 
 11    29 dcl dbase_p	ptr;
 11    30 dcl dbase_vers_3	fixed bin int static init (3);
 11    31 dcl 1 dbase	based (dbase_p),
 11    32       2 version	fixed bin,
 11    33       2 recurs	fixed bin,	/* recursion level at which active   */
 11    34       2 bwd	ptr,		/* links active db's together	       */
 11    35       2 cba_p	ptr,		/* contains addr (cb (1))	       */
 11    36       2 eval_p	ptr,		/* contains cb (2).sp	       */
 11    37       2 rl,			/* describes the request buffer      */
 11    38         3 part1	like seg_des,	/* ..its segment		       */
 11    39         3 part2	like buf_des,	/* ..its limits		       */
 11    40       2 seg_p	(-1:72) ptr,	/* list of segment pointers	       */
 11    41 				/* seg_p(-1)is a temp for restart    */
 11    42 				/* seg_p(0) is the database	       */
 11    43 				/* seg_p(1) is the 1K/4K pool	       */
 11    44 				/* seg_p(2) is reserved for 16K pool */
 11    45 				/* seg_p(3) is reserved for call_stk */
 11    46       2 inuse_seg	bit (72) aligned,	/* which segments (1:72) are in use  */
 11    47 				/* seg_p(0) is ALWAYS in use	       */
 11    48       2 inuse_1K	bit (16) aligned,	/* which 1K buffers are in use       */
 11    49       2 inuse_4K	bit (12) aligned,	/* which 4K buffers are in use       */
 11    50       2 inuse_16K	bit (4) aligned,	/* which 16K buffers are in use      */
 11    51       2 reset	label,		/* where to go on a reset condition  */
 11    52       2 time	fixed bin (71),	/* time request id is based on       */
 11    53       2 seg_ct	fixed bin,	/* how many segments in use	       */
 11    54 				/* seg_p (0)--database	       */
 11    55 				/* seg_p (1)--4K pool (64K total)    */
 11    56 				/* seg_p (2)--16K pool (64K total)   */
 11    57       2 argct	fixed bin,	/* how many args to ted	       */
 11    58       2 S_count	fixed bin,	/* # matches on last substitute      */
 11    59       2 not_read_ct fixed bin,	/* how many "not-read" files	       */
 11    60       2 at_break	fixed bin,	/* 1-break pending, 2-break entered  */
 11    61       2 bufnum	fixed bin,	/* how many buffer control blocks    */
 11    62       2 lock        bit (36),		/* to find if active (set LAST!)     */
 11    63       2 cb_c_r	bit (18) aligned,	/* offset of current buffer	       */
 11    64       2 cb_w_r	bit (18) aligned,	/* offset of buffer being worked on  */
 11    65       2 sws,
 11    66         3 flow_sw	bit (1) unal,	/* -label specified		       */
 11    67         3 break_sw	bit (1) unal,	/* -break specified		       */
 11    68         3 edit_sw	bit (1) unal,	/* -trace_edit specified	       */
 11    69         3 input_sw	bit (1) unal,	/* -trace_input		       */
 11    70         3 old_style bit (1) unal,	/* 1-old-style escapes allowed       */
 11    71         3 remote_sw bit (1) unal,	/* 1-not in home_dir	       */
 11    72         3 read_sw   bit (1) unal,	/* 1-always read files	       */
 11    73         3 lit_sw    bit (1) unal,	/* 1-expressions are literal	       */
 11    74         3 fill	bit (28) unal,
 11    75       2 tedname	char (32) var,	/* name under which ted_ was called  */
 11    76       2 comment     char (256)var,	/* user ident of environment	       */
 11    77       2 err_msg	char (168)var,
 11    78       2 regexp	char (500),	/* holds the remembered regular expr */
 11    79 				/*  is placed here to get word       */
 11    80 				/*  alignment		       */
 11    81       2 dir_db	char (168),	/* where work segments live	       */
 11    82       2 person      char (22),	/* who started		       */
 11    83       2 project     char (9),		/* ...this environment	       */
 11    84       2 nulreq	char (2),		/* what is null request (p|P|!p)     */
 11    85       2 err_go	char (16),	/* label to go to on error	       */
 11    86       2 rq_id       char (19),	/* request id for this	       */
 11    87       2 stk_info,
 11    88         3 curp	ptr,		/* pointer to current buffer	       */
 11    89         3 top	ptr,		/* pointer to top of stack	       */
 11    90         3 level	fixed bin (21),	/* recursion depth		       */
 11    91         3 next	fixed bin (21);
 11    92       /* next space available in stack     */
 11    93       
 11    94 
 11    95 /* END INCLUDE FILE ..... tedbase.incl.pl1 .....			       */
     5637 
 12     1 /* BEGIN INCLUDE FILE ..... tedbcb.incl.pl1 ..... 01/29/82 J Falksen	       */
 12     2 
 12     3 /* UPDATE HISTORY (finally)					       */
 12     4 /* EL#   date	TR	comments				       */
 12     5 /* --- 84-10-19 -------- add sws.INPUT				       */
 12     6 /* --- 84-10-29 -------- add sws.invoking			       */
 12     7 
 12     8 /* if the structure of buf_des changes, tedcommon_.alm and		       */
 12     9 /*  tedcommon.incl.pl1 must be appropriately changed		       */
 12    10 
 12    11 dcl 1 buf_des	(all_des) based (bp),  /* buffer part descriptor	       */
 12    12       2 l,			/* left end (LHE) data (see Note 1)  */
 12    13         3 ln	fixed bin (21),	/*  line number		       */
 12    14         3 le	fixed bin (21),	/*  left  end (LE) offset	       */
 12    15         3 re	fixed bin (21),	/*  right end (RE) offset	       */
 12    16       2 r		like buf_des.l;	/* right end (RHE) data	       */
 12    17 
 12    18 /* Note1:	buf_des describes 2 slightly different things, buffer parts and    */
 12    19 /* 	addresses. These are the circumstances:			       */
 12    20 /*							       */
 12    21 /*							       */
 12    22 /*		|...............<buffer>..........................|      */
 12    23 /*	  b.cur.sp|	|..........<window>...........|	|      */
 12    24 /*	Buffer:	xxxxxxxxxxwwwwwwwwwwwww...<hole>...wwwwwwxxxxxxxxxx      */
 12    25 /*			|	  |	     |	|	|      */
 12    26 /*	           b.b_.l.le|  b.b_.l.re|   b.b_.r.le|	|     maxl|      */
 12    27 /*		    	   b.b_.l.ln|	 b.b_.r.le|    maxln|      */
 12    28 /*					 b.b_.r.ln|	       */
 12    29 /*    b.b_.l.ln (if known) tells the # of lines in left part of window       */
 12    30 /*    b.b_.r.ln (if known) tells the # of lines the whole window	       */
 12    31 /*    b.maxln   (if known) tells the # of lines in the whole buffer	       */
 12    32 /*	Either left or right part may be null. A ^read file	       */
 12    33 /*	is in the right part. A file is always read at the	       */
 12    34 /*	upper end of the hole. This will usually minimize the	       */
 12    35 /*	amount of data movement during subsequent editing		       */
 12    36 /*	operations.					       */
 12    37 /*							       */
 12    38 /* Data movement which occurs within a request, for example substitute, can  */
 12    39 /*  cause an offset to temporarily point into the hole. This will clear up   */
 12    40 /*  before the operation is complete.				       */
 12    41 
 12    42 /*						N	       */
 12    43 /*	Address:	....xxxxxxxxxxsssss -- sssssssxxxxxxxxxxL....	       */
 12    44 /*		    |	    |	         |	|	       */
 12    45 /*		l.le|	l.re|	     r.le|      r.re|	       */
 12    46 /*			l.ln|		      r.ln|	       */
 12    47 /*	l.re is the beginning of the string addressed.		       */
 12    48 /*	l.le is the beginning of line containing location l.re	       */
 12    49 /*		Thus l.ln is related to both l.re and l.le	       */
 12    50 /*	r.re is the end of the string addressed.		       */
 12    51 /*	r.le is the end of line containing location r.re		       */
 12    52 /*		Thus r.ln is related to both r.re and r.le	       */
 12    53 /*	(l.le and r.le relate to the same line when 1 line is addressed)   */
 12    54 /* In line mode each request starts with     l.re=l.le   &   r.re=r.le       */
 12    55 /* In string mode a global request forces these conditions.		       */
 12    56 
 12    57 /*** b_c/b_s reference the string which represents the buffer data.	       */
 12    58 dcl b_c		(b.maxl) char (1) based (b.cur.sp);
 12    59 dcl b_s		char (b.maxl) based (b.cur.sp);
 12    60 
 12    61 dcl (live_des	init (8),
 12    62     all_des	init (13),
 12    63     reloc_first	init (2),		/* where to begin minus 1	       */
 12    64     reloc_last	init (8)		/* where to stop		       */
 12    65     )		fixed bin int static options (constant);
 12    66 dcl bp		ptr;
 12    67 dcl 1 b		based (bp),	/* ted buffer control block	       */
 12    68       2 b_	like buf_des,	/* defines buffer limits	       */
 12    69       2 newb	like buf_des,	/* pending buffer values	       */
 12    70       2 ex	like buf_des,	/* execution limits		       */
 12    71       2 a_	(0:2) like buf_des, /* address data		       */
 12    72 				/*  (0)  "cur location"	       */
 12    73 				/*  (1)  1st addr result	       */
 12    74 				/*  (2)  2nd addr result	       */
 12    75       2 cd	like buf_des,	/* copy destination		       */
 12    76       2 gb	like buf_des,	/* info for global processing	       */
 12    77       2 newa	like buf_des,	/* pending address values	       */
 12    78 				/*    ----limit of relocation----    */
 12    79 /* these are not relocated because they define the relocation data	       */
 12    80       2 rel_temp	like buf_des,	/* hold during relocation	       */
 12    81       2 temp	(0:2) like buf_des,	/* hold during [.]addr processing    */
 12    82       2 old,			/* where string used to be	       */
 12    83         3 (le,re)	fixed bin (21),	/*   ends of range		       */
 12    84       2 new	like b.old,	/* where string has gone to	       */
 12    85       2 test	like b.old,	/* allowable relocatable range       */
 12    86 				/* (may be 1 or 2 larger than b.old) */
 12    87       2 cur	like seg_des,	/* CURRENT buffer area info	       */
 12    88 				/*    (see note 2)		       */
 12    89       2 pend	like seg_des,	/* PENDING buffer area info	       */
 12    90       2 file_d,			/* file related data	       */
 12    91         3 dtcm	bit(36),		/* when read seg was modified	       */
 12    92         3 uid	bit(36),		/* unique ID of segment	       */
 12    93         3 dname	char(168),	/* directory of file	       */
 12    94         3 ename	char(32),		/* entry of file		       */
 12    95         3 cname	char(32),		/* component of file	       */
 12    96         3 kind	char(1)unal,	/* kind of component	       */
 12    97 				/* " "-none, ":"-archive	       */
 12    98 				/*  "|"-superfile		       */
 12    99         3 sws	unal,
 12   100           4 file_sw	        bit(1),	/* 1-file associated	       */
 12   101           4 trust_sw        bit(1),	/* 1-file name trustable	       */
 12   102           4 mod_sw	        bit(1),	/* 1-buffer has been modified	       */
 12   103           4 terminate       bit(1),	/* 1-dp points to file, terminate    */
 12   104           4 get_bit_count   bit(1),	/* 1-get_bit_count before using this */
 12   105 			/*  buffer, it may have been modified by       */
 12   106 			/*  externally via [ted$buffer xx] usage       */
 12   107           4 force_name      bit(1),	/* 1-name has been forced	       */
 12   108           4 no_io	        bit(1),	/* 1-no r w ^b allowed	       */
 12   109 				/*  (external string edit)	       */
 12   110           4 not_pasted      bit(1),	/* 1-data was moved into buffer but  */
 12   111 				/*  has not been read anywhere       */
 12   112           4 initiate        bit(1),	/* 1-must initiate on restart	       */
 12   113 				/*  (b% and b!)		       */
 12   114           4 ck_ptr_sw       bit(1),	/* 1-if segment is external, must    */
 12   115 				/*  check pointer before ref	       */
 12   116           4 pseudo	        bit (1),	/* 1-^read or read-only buffer       */
 12   117           4 INPUT	        bit (1),	/* 1-active INPUT mode on buffer     */
 12   118           4 invoking        bit (1),	/* 1-buffer being invoked	       */
 12   119           4 fill	        bit (14),
 12   120       2 name	char(16),		/* buffer name		       */
 12   121       2 fill	char(27),
 12   122       2 stackl	bit (18)aligned,	/* offset of list of stacked data    */
 12   123       2 stack_o	bit (18)aligned,	/* offset of data being relocated    */
 12   124       2 present	(0:2) bit(1),	/* 1 if addr present	       */
 12   125       2 tw_sw	      bit(1),	/* 1-typewriter buffer	       */
 12   126       2 bs,			/* Old-style escapes in this buffer  */
 12   127         3 (c,b,r,f)       bit(1),	/* 1-\031,\030,\036,\034 found       */
 12   128       2 noref	      bit(1),	/* 1-not ref'ed, don't list	       */
 12   129       2 maxl	fixed bin(21),	/* max buffer length in this AST     */
 12   130       2 maxln	fixed bin(21),	/* number of lines in buffer	       */
 12   131       2 state_r	fixed bin(21),	/* what state is request in	       */
 12   132       2 (N1,N2,N3)	fixed bin(21),	/* values kept for -safe_ty	       */
 12   133       2 state_b	fixed bin(21);	/* what state is buffer change in    */
 12   134 
 12   135 /* Note2:	sn=0	means empty because the database segment will never      */
 12   136 /*		contain a buffer holder			       */
 12   137 /* 	sn=-1 (&^b.terminate) means read-only data, if modification is     */
 12   138 /* 		done, a copy will be made.			       */
 12   139 /* 	sn=-1 (& b.terminate) means ^read file, if modification is done    */
 12   140 /* 		the file is read first			       */
 12   141 /* 	sn>0	means a buffer holder segment			       */
 12   142 
 12   143 /* END INCLUDE FILE ..... tedbcb.incl.pl1 ..... */
     5638 
 13     1 /* BEGIN INCLUDE FILE ..... tedstk.incl.pl1 ..... 04/16/76 J Falksen	       */
 13     2 
 13     3 dcl sv_p		ptr;
 13     4 dcl 1 sv		based (sv_p),
 13     5       2 prev	ptr,		/* ->previous frame		       */
 13     6       2 bp	ptr,		/* ->buffer control block last used  */
 13     7       2 ex	like b.ex,	/* execution limits in buffer	       */
 13     8       2 a0	like b.a_,	/* "." in buffer		       */
 13     9       2 stackl	bit (18)aligned,	/* linked list of occurances of same */
 13    10 				/*  buffer in the stack	       */
 13    11       2 fill	bit (36)aligned,
 13    12       2 this	fixed bin (21),	/* space index before this frame was */
 13    13 				/*  allocated		       */
 13    14       2 pn	fixed bin (21),	/* parameter number		       */
 13    15       2 pv (0:sv.pn),
 13    16         3 pp ptr,			/* pointer to parameter	       */
 13    17         3 pl fixed bin (21);		/* length of parameter	       */
 13    18 
 13    19 dcl  pstr		based char (256);
 13    20 
 13    21 dcl 1 call_stk	based (dbase.seg_p (3)),
 13    22       2 space	(2000) ptr;	/* place to put stack frames	       */
 13    23 
 13    24 /* END INCLUDE FILE ..... tedstk.incl.pl1 .....			       */
     5639 
 14     1 /* BEGIN INCLUDE FILE ..... tederror_.incl.pl1 ..... 09/02/76 J Falksen      */
 14     2 
 14     3 dcl tederror_	entry(ptr, char(168)var);
 14     4 dcl tederror_rc_	entry(ptr, char(168)var,fixed bin(35));
 14     5 
 14     6 dcl msg		char(168)var;
 14     7 dcl msg_ptr	ptr;
 14     8 
 14     9 /* END INCLUDE FILE ..... tederror_.incl.pl1 .....			       */
     5640 
 15     1 /*  */
 15     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 15     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 15     4 /* Modified 07/07/76 by Morris for fault register data */
 15     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 15     6 /* Modified '82 to make values constant */
 15     7 
 15     8 /* words 0-15 pointer registers */
 15     9 
 15    10 dcl  mcp ptr;
 15    11 
 15    12 dcl 1 mc based (mcp) aligned,
 15    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 15    14    (2 regs,					/* registers */
 15    15       3 x (0:7) bit (18),				/* index registers */
 15    16       3 a bit (36),					/* accumulator */
 15    17       3 q bit (36),					/* q-register */
 15    18       3 e bit (8),					/* exponent */
 15    19       3 pad1 bit (28),
 15    20       3 t bit (27),					/* timer register */
 15    21       3 pad2 bit (6),
 15    22       3 ralr bit (3),				/* ring alarm register */
 15    23 
 15    24     2 scu (0:7) bit (36),
 15    25 
 15    26     2 mask bit (72),				/* mem controller mask at time of fault */
 15    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 15    28     2 errcode fixed bin (35),				/* fault handler's error code */
 15    29     2 fim_temp,
 15    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 15    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 15    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 15    33     2 fault_reg bit (36),				/* fault register */
 15    34     2 pad2 bit (1),
 15    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 15    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 15    37     2 fault_time bit (54),				/* time of fault */
 15    38 
 15    39     2 eis_info (0:7) bit (36)) unaligned;
 15    40 
 15    41 
 15    42 dcl (apx fixed bin init (0),
 15    43      abx fixed bin init (1),
 15    44      bpx fixed bin init (2),
 15    45      bbx fixed bin init (3),
 15    46      lpx fixed bin init (4),
 15    47      lbx fixed bin init (5),
 15    48      spx fixed bin init (6),
 15    49      sbx fixed bin init (7)) internal static options (constant);
 15    50 
 15    51 
 15    52 
 15    53 
 15    54 dcl  scup ptr;
 15    55 
 15    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 15    57 
 15    58 
 15    59 /*	WORD (0)		*/
 15    60 
 15    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 15    62       3 prr bit (3),				/* procedure ring register */
 15    63       3 psr bit (15),				/* procedure segment register */
 15    64       3 p bit (1),					/* procedure privileged bit */
 15    65 
 15    66     2 apu,					/* APPENDING UNIT STATUS */
 15    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 15    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 15    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 15    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 15    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 15    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 15    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 15    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 15    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 15    76       3 ptw bit (1),				/* Fetch of PTW */
 15    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 15    78       3 fap bit (1),				/* Fetch of final address paged */
 15    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 15    80       3 fabs bit (1),				/* Fetch of final address absolute */
 15    81 
 15    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 15    83 
 15    84 
 15    85 /*	WORD (1)		*/
 15    86 
 15    87     2 fd,						/* FAULT  DATA */
 15    88       3 iro bit (1),				/* illegal ring order */
 15    89       3 oeb bit (1),				/* out of execute bracket */
 15    90       3 e_off bit (1),				/* no execute */
 15    91       3 orb bit (1),				/* out of read bracket */
 15    92       3 r_off bit (1),				/* no read */
 15    93       3 owb bit (1),				/* out of write bracket */
 15    94       3 w_off bit (1),				/* no write */
 15    95       3 no_ga bit (1),				/* not a gate */
 15    96       3 ocb bit (1),				/* out of call bracket */
 15    97       3 ocall bit (1),				/* outward call */
 15    98       3 boc bit (1),				/* bad outward call */
 15    99       3 inret bit (1),				/* inward return */
 15   100       3 crt bit (1),				/* cross ring transfer */
 15   101       3 ralr bit (1),				/* ring alarm register */
 15   102       3 am_er bit (1),				/* associative memory fault */
 15   103       3 oosb bit (1),				/* out of segment bounds */
 15   104       3 paru bit (1),				/* processor parity upper */
 15   105       3 parl bit (1),				/* processor parity lower */
 15   106       3 onc_1 bit (1),				/* op not complete type 1 */
 15   107       3 onc_2 bit (1),				/* op not complete type 2 */
 15   108 
 15   109     2 port_stat,					/* PORT  STATUS */
 15   110       3 ial bit (4),				/* illegal action lines */
 15   111       3 iac bit (3),				/* illegal action channel */
 15   112       3 con_chan bit (3),				/* connect channel */
 15   113 
 15   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 15   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 15   116 
 15   117 
 15   118 /*	WORD (2)		*/
 15   119 
 15   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 15   121       3 trr bit (3),				/* temporary ring register */
 15   122       3 tsr bit (15),				/* temporary segment register */
 15   123 
 15   124     2 pad2 bit (9),
 15   125 
 15   126     2 cpu_no bit (3),				/* CPU number */
 15   127 
 15   128     2 delta bit (6),				/* tally modification DELTA */
 15   129 
 15   130 
 15   131 /*	WORD (3)		*/
 15   132 
 15   133     2 word3 bit (18),
 15   134 
 15   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 15   136       3 tsna,					/* Word 1 status */
 15   137         4 prn bit (3),				/* Word 1  PR  number */
 15   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 15   139       3 tsnb,					/* Word 2  status */
 15   140         4 prn bit (3),				/* Word 2  PR  number */
 15   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 15   142       3 tsnc,					/* Word 3  status */
 15   143         4 prn bit (3),				/* Word 3  PR  number */
 15   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 15   145 
 15   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 15   147 
 15   148 
 15   149 /* 	WORD (4)		*/
 15   150 
 15   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 15   152 
 15   153     2 ir,						/* INDICATOR  REGISTERS */
 15   154       3 zero bit (1),				/* zero indicator */
 15   155       3 neg bit (1),				/* negative indicator */
 15   156       3 carry bit (1),				/* carryry indicator */
 15   157       3 ovfl bit (1),				/* overflow indicator */
 15   158       3 eovf bit (1),				/* eponent overflow */
 15   159       3 eufl bit (1),				/* exponent underflow */
 15   160       3 oflm bit (1),				/* overflow mask */
 15   161       3 tro bit (1),				/* tally runout */
 15   162       3 par bit (1),				/* parity error */
 15   163       3 parm bit (1),				/* parity mask */
 15   164       3 bm bit (1),					/* ^bar mode */
 15   165       3 tru bit (1),				/* truncation mode */
 15   166       3 mif bit (1),				/* multi-word instruction mode */
 15   167       3 abs bit (1),				/* absolute mode */
 15   168       3 hex bit (1),				/* hexadecimal exponent mode */
 15   169       3 pad bit (3),
 15   170 
 15   171 
 15   172 /*	WORD (5)		*/
 15   173 
 15   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 15   175 
 15   176     2 cu,						/* CONTROL UNIT STATUS */
 15   177       3 rf bit (1),					/* on first cycle of repeat instr */
 15   178       3 rpt bit (1),				/* repeat instruction */
 15   179       3 rd bit (1),					/* repeat double instruction */
 15   180       3 rl bit (1),					/* repeat link instruciton */
 15   181       3 pot bit (1),				/* IT  modification */
 15   182       3 pon bit (1),				/* return type instruction */
 15   183       3 xde bit (1),				/* XDE from Even location */
 15   184       3 xdo bit (1),				/* XDE from Odd  location */
 15   185       3 poa bit (1),				/* operation preparation */
 15   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 15   187       3 its bit (1),				/* ITS modification */
 15   188       3 if bit (1),					/* fault occured during instruction fetch */
 15   189 
 15   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 15   191 
 15   192 
 15   193 /*	WORDS (6,7)	*/
 15   194 
 15   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 15   196 
 15   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 15   198 
 15   199 
 15   200 
 15   201 
 15   202 
 15   203 
 15   204 /*	ALTERNATE   SCU  DECLARATION		*/
 15   205 
 15   206 
 15   207 dcl 1 scux based (scup) aligned,
 15   208 
 15   209    (2 pad0 bit (36),
 15   210 
 15   211     2 fd,						/* GROUP II  FAULT DATA */
 15   212       3 isn bit (1),				/* illegal segment number */
 15   213       3 ioc bit (1),				/* illegal op  code  */
 15   214       3 ia_am bit (1),				/* illegal address - modifier */
 15   215       3 isp bit (1),				/* illegal slave  procedure */
 15   216       3 ipr bit (1),				/* illegal procedure */
 15   217       3 nea bit (1),				/* non existent address */
 15   218       3 oobb bit (1),				/* out of bounds */
 15   219       3 pad bit (29),
 15   220 
 15   221     2 pad2 bit (36),
 15   222 
 15   223     2 pad3a bit (18),
 15   224 
 15   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 15   226       3 prn bit (3),				/* PR  number */
 15   227       3 prv bit (1),				/* PR  valid bit */
 15   228 
 15   229     2 pad3b bit (6)) unaligned,
 15   230 
 15   231     2 pad45 (0:1) bit (36),
 15   232 
 15   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 15   234 
 15   235 
 15   236 
 15   237 /*  END INCLUDE FILE   mc.incl.pl1 */
     5641 
 16     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 16     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 16     3 /*	version number changed to 4, 08/10/78 WOS */
 16     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 16     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 16     6 
 16     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 16     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 16     9     2 switches aligned,                                     /* various bit switch values */
 16    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 16    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 16    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 16    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 16    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 16    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 16    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 16    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 16    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 16    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 16    20 
 16    21 /*  Limit of data defined for version 2 */
 16    22 
 16    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 16    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 16    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 16    26 						/* minimum of 30 seconds required for repeat */
 16    27 						/* otherwise, no repeat will occur */
 16    28 /* Limit of data defined for version 4 */
 16    29 
 16    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 16    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 16    32 
 16    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 16    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 16    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 16    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 16    37 
 16    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     5642 
 17     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
 17     2 /* format: style2,^inddcls,idind32 */
 17     3 
 17     4 declare 1 terminate_file_switches	based,
 17     5 	2 truncate		bit (1) unaligned,
 17     6 	2 set_bc			bit (1) unaligned,
 17     7 	2 terminate		bit (1) unaligned,
 17     8 	2 force_write		bit (1) unaligned,
 17     9 	2 delete			bit (1) unaligned;
 17    10 
 17    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
 17    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
 17    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
 17    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
 17    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
 17    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
 17    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
 17    18 
 17    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     5643 
 18     1      declare		/* Structure returned by hcs_$status_long */
 18     2 
 18     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
 18     4 
 18     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
 18     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
 18     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
 18     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
 18     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
 18    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
 18    11 	  2 raw_mode bit(5) unaligned,
 18    12 	  2 pad1 bit(8) unaligned,
 18    13 	  2 records bit(18) unaligned,			/* number of records in use */
 18    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
 18    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
 18    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
 18    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
 18    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
 18    19 	  2 pad3 bit(8) unaligned,
 18    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
 18    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
 18    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
 18    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
 18    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
 18    25 	  2 pad4 bit(5) unaligned,
 18    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
 18    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
 18    28 
 18    29 
 18    30 	     /* The types of each class of branch */
 18    31 	segment_type bit(2) aligned internal static initial ("01"b),
 18    32 	directory_type bit(2) aligned internal static initial ("10"b),
 18    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
 18    34 	link_type bit(2) aligned internal static initial ("00"b);
 18    35 
 18    36 
     5644 
     5645 dcl tedaddr_	entry (		/* process request addresses	       */
     5646 		ptr,		/* -> database		       */
     5647 		ptr,		/* -> string containing address      */
     5648 		fixed bin (21),	/*   length of it		  [IN] */
     5649 				/* If <0 then recursive call	       */
     5650 				/*   how much was used up	 [OUT] */
     5651 		ptr,		/* -> buffer control block  [IN/OUT] */
     5652 		char (168) var,	/* place to hold err message if any  */
     5653 		fixed bin (35),	/* status code		       */
     5654 				/*   0- null address	       */
     5655 				/*   1- address found	       */
     5656 				/*   8- error, msg tells what        */
     5657 		);
     5658 
     5659 
     5660 dcl tedcall_	entry (		/* call a buffer		       */
     5661 		ptr,		/* -> database		       */
     5662 		fixed bin (35)
     5663 		);
     5664 
     5665 dcl tedcount_lines_ entry (		/* return # lines in string	       */
     5666 		ptr,		/* -> buffer in which to count       */
     5667 		fixed bin (21),	/* where string begins in segment    */
     5668 		fixed bin (21),	/* where string ends in segment      */
     5669 		fixed bin (21)	/* # lines		 [OUT] */
     5670 		);
     5671 
     5672 
     5673 dcl tedcheck_buffer_state_ entry (
     5674 		ptr,		/* -> database		       */
     5675 		ptr,		/* -> buffer control block	       */
     5676 		char (168) var	/* error message, if any	       */
     5677 		);
     5678 
     5679 
     5680 dcl tedcheck_buffers_ entry (		/* check for modified buffers        */
     5681 		ptr,		/* -> database		       */
     5682 		fixed bin		/* number of modified buffers found  */
     5683 		);
     5684 
     5685 dcl tedcheck_entryname_ entry (char (*), fixed bin (35));
     5686 dcl tedend_buffer_	entry (		/* pop buffer recursion 1 level      */
     5687 		ptr,		/* -> database		       */
     5688 		fixed bin (35)	/* 1- already at level 0, 0- ok      */
     5689 		);
     5690 
     5691 dcl tedeval_	entry (		/* process evaluations	       */
     5692 		ptr,		/* -> database		       */
     5693 		ptr,		/* -> evaluation string	       */
     5694 		fixed bin (21),	/*   length thereof 	  [IN] */
     5695 				/*   amount used up 	 [OUT] */
     5696 		ptr,		/* -> buffer control block	       */
     5697 		ptr,		/* -> matched string in \g{...}      */
     5698 				/*    null otherwise	       */
     5699 		fixed bin (21),	/*  length of string in \g{...}      */
     5700 				/* <0 in \{...}, 0 otherwise	       */
     5701 		char (500) var,	/* output string, if any	       */
     5702 		char (168) var,	/* error message, if any	       */
     5703 		fixed bin (35)	/* return code		       */
     5704 		);
     5705 
     5706 
     5707 dcl tedfree_segment_ entry (		/* give back a work segment	       */
     5708 		ptr,		/* -> database		       */
     5709 		fixed bin		/* sequence # of segment to free     */
     5710 		);
     5711 
     5712 dcl tedget_existing_buffer_ entry (	/* find a named buffer	       */
     5713 		ptr,		/* -> database		       */
     5714 		ptr,		/* -> string containing buffer name  */
     5715 		fixed bin (21),	/*   length of string	  [IN] */
     5716 				/*   how much was used	 [OUT] */
     5717 		ptr,		/* buffer control block (OUT)        */
     5718 		char (168) var	/* error message text	       */
     5719 		);
     5720 
     5721 dcl tedget_buffer_	entry (		/* find (or create) a buffer	       */
     5722 		ptr,		/* -> database		       */
     5723 		ptr,		/* -> string containing buffer name  */
     5724 		fixed bin (21),	/*   length of string	  [IN] */
     5725 				/*   how much was used	 [OUT] */
     5726 		ptr,		/* buffer control block (OUT)        */
     5727 		char (168) var	/* error message text	       */
     5728 		);
     5729 
     5730 
     5731 dcl tedget_segment_ entry (		/* get a segment to work in	       */
     5732 		ptr,		/* -> database		       */
     5733 		ptr,		/* -> gotten segment	 [OUT] */
     5734 		fixed bin,	/* sequence # of it         [IN/OUT] */
     5735 				/* if >0 upon entry, it will then    */
     5736 				/*  fill that entry in seg_p array   */
     5737 				/* otherwise it will take any one    */
     5738 		);
     5739 
     5740 
     5741 dcl tedhold_	entry (ptr);
     5742 dcl tedinit_	entry (		/* create a ted environment	       */
     5743 		ptr,		/* -> ted_ input structure	       */
     5744 		ptr,		/* -> dbase		 (OUT) */
     5745 		fixed bin (35)	/* status code		       */
     5746 		);
     5747 
     5748 dcl tedlist_buffers_ entry (		/* show the status of buffers        */
     5749 		ptr,		/* -> database		       */
     5750 		char (16),	/* name of buffer to show	       */
     5751 		bit (1),		/* 0- listing inactive environment   */
     5752 				/* 1- listing active one	       */
     5753 		bit (1)		/* 1- validate b.maxln	       */
     5754 		);
     5755 
     5756 dcl tedpseudo_	entry (		/* make a pseudo (read-only) buffer  */
     5757 		ptr,		/* -> to buffer to convert	       */
     5758 		fixed bin,	/* segno of data (-1 if ^read)       */
     5759 		ptr,		/* -> the data		       */
     5760 		fixed bin (21)	/* the length of it 	       */
     5761 		);
     5762 
     5763 
     5764 dcl tedread_ptr_	entry (		/* read a line from input stream     */
     5765 		ptr,		/* -> database		       */
     5766 		ptr,		/* -> input buffer		       */
     5767 		fixed bin (21),	/* last char in use in buffer        */
     5768 		fixed bin (21),	/* last char useable in buffer       */
     5769 		fixed bin (21),	/* last char filled in buffer  [OUT] */
     5770 		char (5)		/* mode in which read is being done  */
     5771 		);
     5772 
     5773 dcl tedresetread_	entry (ptr);
     5774 dcl tedset_ck_ptr_	entry (ptr);
     5775 dcl tedset_ptr_	entry (		/* find label in local buffer        */
     5776 		ptr,		/* -> database		       */
     5777 		char (*),		/* label to find		       */
     5778 		fixed bin (35)	/* return code		       */
     5779 		);
     5780 
     5781 dcl tedshow_	entry options (variable);
     5782 dcl tedshow_$init	entry;
     5783 dcl tedsort_	entry (		/* sort in a buffer 	       */
     5784 		ptr,		/* -> key specifications	       */
     5785 		fixed bin (21),	/*   length thereof 	       */
     5786 		ptr,		/* -> string to be sorted	       */
     5787 		fixed bin (21),	/*   length thereof 	       */
     5788 		(3) ptr,		/* working segments 	       */
     5789 				/*  (1) temp seg		       */
     5790 				/*  (2) temp seg		       */
     5791 				/*  (3) output seg		       */
     5792 		fixed bin (21),	/* length of result 	 [OUT] */
     5793 		char (168) var,	/* error details		       */
     5794 		fixed bin (35)	/* return code		 [OUT] */
     5795 		);
     5796 
     5797 dcl tedsort_$show	entry (		/* print special collating sequence  */
     5798 				/* no arguments		       */
     5799 		);
     5800 
     5801 dcl tedsort_$set	entry (		/* set special collating sequence    */
     5802 		char (*)		/* user's specification	       */
     5803 		);
     5804 
     5805 /*dcl tedsort_$compare entry (	/* compare strings w/ spec collate  * /
     5806*		ptr,		/* points to seg containin/g strings* /
     5807*		ptr,		/* points to R array	      * /
     5808*		bit (3)		/* the 3 bits represent <=>	      * /
     5809*		);					       */
     5810 
     5811 dcl gvNL		bit (1);
     5812    end ted_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/02/89  1041.8  ted_.pl1                          >spec>install>1037>ted_.pl1
605          1    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
606          2    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
4541         3    11/23/82  1324.7  tedgvd.incl.pl1                   >ldd>include>tedgvd.incl.pl1
4929         4    12/18/84  0954.2  ted_gv_p_.incl.pl1                >ldd>include>ted_gv_p_.incl.pl1
4-324        5    11/23/82  1324.6  ted_gv_.incl.pl1                  >ldd>include>ted_gv_.incl.pl1
4930         6    11/23/82  1324.6  ted_gv_t_.incl.pl1                >ldd>include>ted_gv_t_.incl.pl1
5634         7    11/23/82  1324.6  ted_.incl.pl1                     >ldd>include>ted_.incl.pl1
5635         8    12/10/82  1305.8  ted_support.incl.pl1              >ldd>include>ted_support.incl.pl1
8-172        9    12/10/82  1305.8  tedsrch_.incl.pl1                 >ldd>include>tedsrch_.incl.pl1
5636        10    12/18/84  0954.3  tedcommon_.incl.pl1               >ldd>include>tedcommon_.incl.pl1
5637        11    11/23/82  1324.7  tedbase.incl.pl1                  >ldd>include>tedbase.incl.pl1
5638        12    12/18/84  0954.3  tedbcb.incl.pl1                   >ldd>include>tedbcb.incl.pl1
5639        13    11/23/82  1324.7  tedstk.incl.pl1                   >ldd>include>tedstk.incl.pl1
5640        14    11/23/82  1324.7  tederror_.incl.pl1                >ldd>include>tederror_.incl.pl1
5641        15    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
5642        16    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
5643        17    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
5644        18    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           bit(3)                   level 2 packed packed unaligned dcl 610 ref 616
AZ                              000342 constant        char(26)                 initial packed unaligned dcl 5447 ref 2952 2955
Aastr_p                                parameter       pointer                  dcl 3624 ref 3622 3648 3655 3662 3669 3684 3687 3737
B                         0(03)        based           bit(3)                   level 2 packed packed unaligned dcl 610 ref 617
BS_C                                   constant        char(1)                  initial packed unaligned dcl 5448 ref 3127 3374
B_HI_HI                                constant        fixed bin(17,0)          initial dcl 3398 ref 1382 1385 3467
B_LO_HI                                constant        fixed bin(17,0)          initial dcl 3398 ref 804 1082 1385 1418 3192 3460
                                                                                  3575 3853
B_LO_LO                                constant        fixed bin(17,0)          initial dcl 3398 ref 1388 3455 3833
B_MT                                   constant        fixed bin(17,0)          initial dcl 3398 ref 1380 1401 3427 3442
C                         0(06)        based           bit(3)                   level 2 packed packed unaligned dcl 610 ref 618
CB                                     based           structure                array level 1 unaligned dcl 5632 set ref 769 1328
COM                                    constant        fixed bin(24,0)          initial dcl 11-3 ref 549 837 855 2343 3305
DBA                             001137 automatic       varying char(32)         dcl 5449 set ref 113* 222 840* 984* 1031* 1359* 1684
                                                                                  1782* 1782 2289* 2908* 2914* 2918* 2921* 2926*
                                                                                  3223* 3228* 3234*
DPDA                      1     000342 external static structure                array level 2 packed packed unaligned dcl 6-13
EOF                             000102 automatic       bit(1)                   packed unaligned dcl 432 set ref 1515*
HT                                     constant        char(1)                  initial packed unaligned dcl 5450 ref 2543
IC                              003122 automatic       fixed bin(17,0)          dcl 2970 set ref 2972* 2980
INPUT                   234(20)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  368* 1555*
N                                      parameter       fixed bin(17,0)          dcl 5-66 ref 5-65 5-68
N1                      256            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 4239* 4243 4247* 4249 4249
                                                                                  4252 4341
N2                      257            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 4243* 4244 4247
N3                      260            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 4240* 4325 4329 4333 4337
NL                              000030 internal static char(1)                  initial packed unaligned dcl 5593 set ref 353 387
                                                                                  562 566 697 700 1341 1344 1369 1372 1447 1447 1520
                                                                                  1989 2313 2319 2355 2428 2545 2550 2623 2623 2725
                                                                                  2880 3023 3065 3363 3695 4412 4418 4441 4446 4456
                                                                                  4459 4551 4739
NLcheck                                parameter       fixed bin(21,0)          dcl 3082 set ref 3080 3102*
NLct                                   parameter       fixed bin(21,0)          dcl 3624 ref 3622 3648 3655 3662 3669 3692
NLct_check                      000015 internal static fixed bin(21,0)          initial dcl 5451 set ref 1530* 1544* 2088* 3048*
                                                                                  3055* 3074* 5126* 5231* 5233*
NLct_unknown                    000016 internal static fixed bin(21,0)          initial dcl 5452 set ref 1217* 1644* 3253* 3590*
                                                                                  3610* 3712 3714 3716 3741 3879 5289
NLlast                          001150 automatic       bit(1)                   packed unaligned dcl 5453 set ref 2464* 2464 2495*
                                                                                  2497* 2623 2634* 4611* 4974*
NX_LIN                                 constant        bit(1)                   initial packed unaligned dcl 588 ref 674 731 857 866
                                                                                  936 1040 1123 1165 1177 1196 1225 1361 1755 1898
                                                                                  1935 1955 2293 2744 2754 2757 2764 2853 2884
NX_REQ                                 constant        bit(1)                   initial packed unaligned dcl 588 ref 767 1448 1459
                                                                                  1467 1595 1606 1611 1637 1648 1665 1760 1775 2110
                                                                                  2187 2216 2352 2396 2430 2625 2676 2682 2688 2694
                                                                                  2699 2739 2748 2855 2865 2933
OC                              000326 constant        char(1)                  initial array packed unaligned dcl 608 ref 616 617
                                                                                  618
Psw                             001151 automatic       bit(1)                   packed unaligned dcl 5454 set ref 2441* 2562 2635*
RESTART                                constant        fixed bin(24,0)          initial dcl 11-3 ref 137 212
SAFE                                   constant        fixed bin(24,0)          initial dcl 11-3 ref 216
SI                              002206 automatic       structure                level 1 unaligned dcl 607 set ref 943 943
SP                                     constant        char(1)                  initial packed unaligned dcl 5455 ref 1520 1942
SP_HT                                  constant        char(2)                  initial packed unaligned dcl 5456 ref 1343 1371
SUFFIX_INFO_VERSION_1           000330 constant        char(8)                  initial packed unaligned dcl 2-29 ref 942
S_count                 266            based           fixed bin(17,0)          level 2 dcl 11-31 set ref 224* 1745* 1906* 2978*
                                                                                  2978
TC                        1     000340 external static char(11)                 level 2 packed packed unaligned dcl 6-9 ref 4-257
                                                                                  4-264
TERM_FILE_TRUNC_BC_TERM         000332 constant        bit(3)                   initial packed unaligned dcl 17-15 set ref 1107*
TL                        1     000336 external static structure                array level 2 packed packed unaligned dcl 6-4
a0                       12            based           structure                level 2 unaligned dcl 13-4 set ref 4267* 4270*
a_                       22            based           structure                array level 2 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
a_                       22            based           structure                array level 2 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
a_                       22            based           structure                array level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 413* 413 3818* 3819*
                                                                                  4218* 4377* 4384* 4489 4489* 4489* 4504* 4504
abbrev_$expanded_line           000334 constant        entry                    external dcl 684 ref 689
abp                                    parameter       pointer                  dcl 5276 ref 5248 5255 5261 5267 5268 5274 5283
access                   10     001722 automatic       bit(36)                  level 2 dcl 5597 set ref 1043*
acode                                  parameter       fixed bin(35,0)          dcl 99 set ref 96 96 131* 157* 551* 584*
act_name                        000010 internal static char(5)                  initial packed unaligned dcl 5306 set ref 5313 5313
                                                                                  5313 5313
action                          000106 automatic       char(8)                  packed unaligned dcl 3944 set ref 3909* 3913* 3939*
                                                                                  3940
ad1                       3            based           fixed bin(21,0)          level 2 dcl 3-38 set ref 4790* 5007
ad2                       4            based           fixed bin(21,0)          level 2 dcl 3-38 set ref 4791* 5009
adbp                                   parameter       pointer                  dcl 3482 set ref 3480 3529 3619*
add_right                       000100 automatic       bit(1)                   packed unaligned dcl 3635 in procedure "mov_2l" set
                                                                                  ref 3644* 3651* 3658* 3665* 3679* 3680 3714 3721
                                                                                  3743* 3748* 3752
add_right                              parameter       bit(1)                   packed unaligned dcl 3482 in procedure
                                                                                  "buffer_buffer_copy" set ref 3480 3534* 3579 3590*
                                                                                  3594 3610*
addcharno                                              builtin function         dcl 5241 ref 3684 3737
addr                                                   builtin function         dcl 4-193 in procedure "ted_gv_p_" ref 4-270 4-298
                                                                                  4-298 4-298 4-298 4-315
addr                                                   builtin function         dcl 5241 in procedure "ted_" ref 171 171 176 176 204
                                                                                  418 418 616 617 618 689 689 769 840 840 943 943
                                                                                  1013 1013 1031 1031 1045 1045 1085 1085 1085 1085
                                                                                  1092 1092 1128 1128 1140 1140 1259 1278 1282 1300
                                                                                  1300 1300 1300 1328 1359 1359 1421 1421 1421 1421
                                                                                  1428 1428 1447 1447 1530 1530 1544 1544 1628 1628
                                                                                  1628 1628 1664 1664 1711 1711 1711 1711 1714 1714
                                                                                  1740 1740 1740 1740 1747 1747 1771 1771 1771 1771
                                                                                  1774 1774 1943 1943 2019 2051 2058 2058 2164 2164
                                                                                  2167 2167 2239 2239 2289 2289 2455 2455 2500 2500
                                                                                  2500 2500 2570 2570 2585 2585 2586 2586 2623 2623
                                                                                  2841 2841 2892 2892 2981 3008 3048 3048 3065 3065
                                                                                  3069 3069 3069 3069 3074 3074 3079 3194 3194 3202
                                                                                  3202 3581 3585 3596 3600 3605 3766 3766 3933 3933
                                                                                  3937 3937 4054 4077 4100 4138 4138 4138 4138 4568
                                                                                  4581 4587 4700 4700 4718 4718 4718 4718 4900 4905
                                                                                  4984 5013 5013 5023 5023 5039 5039 5080 5080 5086
                                                                                  5086 5126 5126 5130 5133 5138 5144 5144 5149 5149
                                                                                  5162 5162 5170 5170 5231 5231 5233 5233 5313 5313
                                                                                  5326 5326 5421 5427 5431
addr_ct                   1     002610 automatic       fixed bin(17,0)          level 2 dcl 2119 set ref 2002* 2003* 2005* 2005
addr_undef                      000673 constant        fixed bin(17,0)          initial dcl 5457 ref 210 2207 2328 3263 4434 4439
                                                                                  4513
addrel                                                 builtin function         dcl 5241 ref 204 3074 3074
adj                             000102 automatic       fixed bin(21,0)          dcl 3640 set ref 3692* 3693 3698* 3700* 3702* 3704*
                                                                                  3709* 3712 3719 3721 3723
adr_op                                 constant        fixed bin(17,0)          initial dcl 3-3 ref 4985
adr_sw                          003311 automatic       bit(1)                   packed unaligned dcl 4605
                                                                                  in begin block on line 4598 set ref 4752*
adr_sw                          003262 automatic       bit(1)                   packed unaligned dcl 4979 in procedure "gv_compile"
                                                                                  set ref 4989* 4993* 4996* 4997 5003* 5010* 5076
                                                                                  5082 5088 5094 5108 5115 5122 5134 5141 5146 5159
                                                                                  5165 5177
af_bp                           001152 automatic       pointer                  dcl 5458 set ref 167* 171* 173 1375
af_value                               based           varying char             dcl 5459 set ref 1378* 1384* 1384 1390* 1390
after_l                         001154 automatic       fixed bin(21,0)          dcl 5461 set ref 1246* 1257* 1262* 1271* 1276 1287*
                                                                                  1290 1294 1294 1300* 1300* 1307 1309 1309
al                                     parameter       fixed bin(21,0)          dcl 5276 set ref 5248 5257* 5274 5285* 5295 5296
ale                                    parameter       fixed bin(21,0)          dcl 4199 ref 4352
alen                                   parameter       fixed bin(21,0)          dcl 3971 ref 3949 3951 3955
alt_sw                          001155 automatic       bit(1)                   packed unaligned dcl 5462 set ref 565* 710 736 1316
                                                                                  1322 1347 1440 1456 1516 1597* 1619 1656 1691*
                                                                                  1728 1774 2139 2219 2375 2484* 2527 2543 2577 2684
                                                                                  2878
altn                                   parameter       fixed bin(17,0)          dcl 5-7 in procedure "sem" ref 5-5
altn                            004601 automatic       fixed bin(17,0)          dcl 4-218 in procedure "ted_gv_p_" set ref 4-144*
                                                                                  4-150* 4-154*
ame                                    parameter       fixed bin(21,0)          dcl 2992 ref 2990 3004 3010
ame2                                   parameter       fixed bin(21,0)          dcl 2992 ref 2990 3005
ami                                    parameter       fixed bin(21,0)          dcl 2992 ref 2990 3006 3010
answer                          002046 automatic       varying char(10)         dcl 5609 set ref 840* 843 1031* 1036 1359* 1361
                                                                                  2289* 2293
answer_iocbp              6     002136 automatic       pointer                  initial level 2 dcl 16-7 set ref 16-7*
app_sw                          001156 automatic       bit(1)                   packed unaligned dcl 5463 set ref 225* 2219* 2223*
                                                                                  2265 2280
archive_$get_component          000044 constant        entry                    external dcl 5464 ref 1227
area_p                                 parameter       pointer                  dcl 4576 set ref 4574 4579 4581* 4585
arg                                    based           char                     packed unaligned dcl 5418 ref 5425 5431 5431
arg_l                           001130 automatic       fixed bin(21,0)          dcl 5309 set ref 5325* 5328* 5419* 5425 5431 5431
arg_list_1               20            based           fixed bin(17,0)          level 2 dcl 7-13 set ref 149*
arg_list_n               21            based           fixed bin(17,0)          level 2 dcl 7-13 set ref 150*
arg_list_p               16            based           pointer                  level 2 dcl 7-13 set ref 148*
arg_max                         001127 automatic       fixed bin(17,0)          dcl 5308 set ref 5322* 5324
argname                         001160 automatic       char(7)                  packed unaligned dcl 5466 set ref 170* 171 171 171
                                                                                  171 2454* 2455 2455 2455 2455
argno                           001162 automatic       fixed bin(17,0)          dcl 5467 set ref 5324* 5325* 5326*
asbp                                   parameter       pointer                  dcl 3482 set ref 3480 3528 3618*
asn                                    parameter       fixed bin(17,0)          dcl 5276 set ref 5274 5285* 5291
asp                                    parameter       pointer                  dcl 5276 set ref 5274 5285* 5290
ast                     130            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2135 2135 3088 3955 3998 3998 4000
                                                                                  4083 4106 4118 4154 4161 4168 4294
ast                     136            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3994* 3994* 3998 4002 4018 4028
                                                                                  4042 4047* 4048 4065 4070* 4071 4088 4093* 4094
                                                                                  4294 4306 5292*
astr                                   based           char                     packed unaligned dcl 3792 set ref 3695 3743 3743
                                                                                  3743 3743 3748* 3781
astr_l                                 parameter       fixed bin(21,0)          dcl 3624 set ref 3622 3648 3655 3662 3669 3690 3695
                                                                                  3702 3709* 3731 3743 3743 3743 3743 3743 3743 3743
                                                                                  3743 3748* 3748 3748 3750 3755 3760 3766* 3766*
                                                                                  3770 3775 3781 3781 3782* 3782
astr_p                          000104 automatic       pointer                  dcl 3793 set ref 3684* 3687* 3695 3737* 3743 3743
                                                                                  3743 3743 3748 3766* 3781 3782*
at                              000111 automatic       fixed bin(21,0)          dcl 3946 set ref 3904* 3907* 3914 3914 3923 3925
                                                                                  3927 3932 3936 3937 3937
at_in_gap                       000100 stack reference condition                dcl 3929 ref 3929
ated_data_p                            parameter       pointer                  dcl 99 ref 96 96 106
axp                                    parameter       pointer                  dcl 2968 set ref 2966 2973*
az                              000333 constant        char(26)                 initial packed unaligned dcl 5468 ref 2952 2955
b                                      based           structure                level 1 unaligned dcl 12-67
b0_bp                           001164 automatic       pointer                  dcl 5469 set ref 217* 1351 1352 1355 1397
b21                             003166 automatic       char(4)                  packed unaligned dcl 3338 set ref 3319* 3333* 3353*
                                                                                  3354*
b_                                     based           structure                level 2 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
b_                                     based           structure                level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 3740 3849 3860 3873
                                                                                  4007 4216* 4308* 4314* 4376*
b_c                                    based           char(1)                  array packed unaligned dcl 12-58 set ref 1085 1085
                                                                                  1092 1092 1421 1421 1428 1428 1628 1628 2019 2313
                                                                                  2586 2586 3008 3069 3069 3194 3194 3202 3202 3766
                                                                                  3766 3933 3933 3937 3937 4138 4138 4138 4138 4412
                                                                                  4441 4456 5039 5039
b_depth                         001166 automatic       fixed bin(17,0)          dcl 5470 set ref 223* 557* 2141 2143* 2143 2144 2150
                                                                                  2153 2154* 2154 2177
b_lhe                           000117 automatic       fixed bin(21,0)          dcl 3406 set ref 800 3430* 3431 3431* 3436* 3567
                                                                                  3569 3806
b_rhe                           000120 automatic       fixed bin(21,0)          dcl 3407 set ref 800 3433* 3434 3434* 3436* 3568
                                                                                  3569 3806
b_s                                    based           char                     packed unaligned dcl 12-59 set ref 1384 1390 2029*
                                                                                  2029 2319 2550 2952* 2952 2955* 2955 3023 3781*
                                                                                  4031* 4031 4122* 4122 4418 4446 4459 5214 5220
b_stack                         001170 automatic       pointer                  array dcl 5471 set ref 2144* 2153 2178
b_stat                          000116 automatic       fixed bin(17,0)          dcl 3405 set ref 804 1082 1380 1382 1385 1385* 1388
                                                                                  1401 1418 3192 3427* 3442* 3455* 3460* 3467* 3468
                                                                                  3468 3575 3833 3853
bc                              001214 automatic       fixed bin(24,0)          dcl 5472 set ref 970* 1006* 1021 1054* 1107 1227
                                                                                  1227* 1235 1240* 1240 1245* 1245 1262* 1268* 1268
                                                                                  1284* 1284 1287* 3244* 3253 3253
bcb_p                    46     002610 automatic       pointer                  level 2 dcl 2119 set ref 2052*
bd_name                         000031 internal static char(2)                  initial array packed unaligned dcl 4349 set ref
                                                                                  4249*
bias                            003241 automatic       fixed bin(17,0)          dcl 4536 set ref 4475* 4478* 4481* 4484* 4528
bp                              002056 automatic       pointer                  dcl 12-66 set ref (more) 1581 1581 1586 1586 1588
                                                                                  1588 1591* 1628 1628 1628 1628 1628 1628 1643 1643
                                                                                  1645 1645 1711 1714* 1714 1714 1740 1769 1769 1771
                                                                                  1782 1916* 1991 1993 1994 2003 2005 2011 2011 2013
                                                                                  2013 2015 2015 2016* 2016 2016 2019 2019 2020 2020
                                                                                  2021 2021 2021 2022 2022 2029 2029 2041 2052 2084
                                                                                  2084 2085 2085 2101 2127 2129 2129 2129 2129 2129
                                                                                  2129 2131 2132 2133 2133 2134 2134 2135 2135 2135
                                                                                  2144 2153* 2155 2155 2155 2155 2155 2155 2157 2158
                                                                                  2159 2159 2160 2160 2175 2183* 2186 2189* 2191
                                                                                  2191 2191 2191 2194 2194 2198 2198 2199 2199 2200
                                                                                  2200 2201 2201 2204 2204 2204 2204 2206 2206 2207
                                                                                  2212 2213* 2232 2234 2234 2236 2236 2237 2237
                                                                                  2249* 2250 2250 2252* 2272 2272 2272 2272 2282*
                                                                                  2283 2283 2283 2283 2289 2289 2289 2289 2289 2289
                                                                                  2296 2296 2300* 2306* 2311 2311 2313 2313 2313
                                                                                  2313 2319 2319 2319 2319 2319 2321 2321 2323 2323
                                                                                  2327 2327 2328 2328 2330 2337 2339* 2345 2345 2346
                                                                                  2346 2355 2405 2408 2409 2409 2409 2409 2414* 2414
                                                                                  2414 2416 2416 2426 2446 2446 2447 2447 2500 2518
                                                                                  2518 2520 2520 2521 2521 2522 2522 2523 2523 2523
                                                                                  2523 2523 2523 2526 2526 2532* 2532 2532 2532 2538
                                                                                  2540 2540 2542 2542 2547 2547 2547 2549 2549 2550
                                                                                  2550 2550 2550 2550 2552 2552 2554 2554 2555 2555
                                                                                  2556 2556 2557 2557 2557 2557 2559* 2570* 2570
                                                                                  2570 2583 2586 2586 2586 2586 2586 2586 2591 2599
                                                                                  2599 2602 2602 2605 2605 2607 2607 2608 2608 2613
                                                                                  2615 2615 2615 2615 2617 2617 2617 2617 2654 2654
                                                                                  2682 2684 2686 2686 2687 2687 2690 2692 2692 2693
                                                                                  2693 2696 2696 2757 2762 2762 2771 2773 2776 2778
                                                                                  2778 2780 2780 2785 2785 2804 2838 2841* 2941*
                                                                                  2941 2941 2946 2948 2951 2952 2952 2952 2952 2955
                                                                                  2955 2955 2955 2958 2958 2973* 2973 2973 2983 2983
                                                                                  3004 3005 3006 3008 3008 3020 3020 3023 3023 3023
                                                                                  3028 3028 3028 3030 3034 3036 3036 3038 3041 3041
                                                                                  3042 3042 3044* 3069* 3069 3069 3069 3069 3088
                                                                                  3091 3091 3098 3098 3191 3191 3194 3194 3194 3194
                                                                                  3194 3194 3197 3197 3202 3202 3202 3202 3202 3202
                                                                                  3242 3243* 3257 3259 3260 3262 3262 3263 3263 3264
                                                                                  3265* 3315 3325 3340* 3341 3346 3410 3411 3425
                                                                                  3431 3431 3434 3434 3440 3446 3446 3446 3446 3446
                                                                                  3446 3449 3449 3449 3449 3449 3449 3451 3451 3453
                                                                                  3453 3458 3458 3464 3464 3464 3464 3474 3474 3474
                                                                                  3474 3530 3555* 3556 3556 3556 3558 3558 3560 3560
                                                                                  3561* 3564* 3565 3567 3567 3568 3568 3569 3569
                                                                                  3569 3577 3577 3578 3578 3581 3585 3589* 3593*
                                                                                  3596 3600 3605 3606 3606 3609* 3617* 3698 3698
                                                                                  3708* 3714 3716 3716 3719 3719 3719 3721 3721 3721
                                                                                  3723 3723 3723 3729 3730 3730 3740 3740 3741 3743
                                                                                  3743 3748 3748 3754 3754 3755 3755 3756 3756 3759
                                                                                  3759 3759 3760 3760 3760 3761 3761 3762 3762 3762
                                                                                  3764 3764 3766 3766 3766 3766 3769 3769 3770 3770
                                                                                  3771 3771 3774 3774 3774 3775 3775 3775 3776 3776
                                                                                  3777 3777 3777 3777 3779 3779 3781 3781 3781 3782
                                                                                  3782 3782 3790* 3803* 3805 3806 3806 3815* 3815
                                                                                  3818 3819 3820 3821 3825 3827 3828 3828 3844 3844
                                                                                  3846 3846 3846 3849 3849 3850 3850 3860 3860 3861
                                                                                  3861 3862 3862 3873 3873 3874 3874 3874 3874 3874
                                                                                  3879 3879 3879 3880 3883 3883 3884* 3895* 3897
                                                                                  3902 3902 3904 3907 3910 3914 3914 3923 3925 3927
                                                                                  3932 3932 3933 3933 3933 3933 3936 3937 3937 3940*
                                                                                  3951* 3953 3955 3968 3968 3968 3968 3969* 3991
                                                                                  3994 3994 3998 3998 3998 4000 4002 4007 4007 4008
                                                                                  4008 4008 4009 4009 4009 4010 4010 4017 4017 4018
                                                                                  4018 4018 4019 4019 4019 4020 4020 4022 4022 4023
                                                                                  4023 4026 4026 4027 4027 4028 4028 4029 4030 4030
                                                                                  4031 4031 4031 4031 4031 4031 4032 4032 4032 4032
                                                                                  4032 4042 4047 4048 4048 4048 4049 4049 4049 4054
                                                                                  4055 4056 4060 4065 4070 4071 4071 4071 4072 4072
                                                                                  4072 4077 4078 4079 4083 4083 4088 4093 4094 4094
                                                                                  4094 4095 4095 4095 4100 4101 4102 4106 4106 4112
                                                                                  4114 4115 4115 4118 4118 4118 4118 4122 4122 4122
                                                                                  4122 4122 4122 4122 4128 4128 4129 4129 4130 4130
                                                                                  4131 4131 4138 4138 4138 4138 4138 4138 4138 4138
                                                                                  4146 4146 4146 4149 4150* 4154 4154 4156 4157 4158
                                                                                  4161 4161 4163 4164 4165 4168 4168 4170 4171 4172
                                                                                  4175 4175 4205 4205 4207 4209 4211 4212 4216 4216
                                                                                  4218 4218 4231 4239 4240 4240 4240 4241 4243 4243
                                                                                  4244 4246 4247 4247 4248 4249 4249 4249 4251 4252
                                                                                  4252 4252 4255 4256 4258 4258 4259 4261 4263 4264
                                                                                  4264 4265 4267 4269 4270 4270 4271 4273 4273 4274
                                                                                  4275 4278 4279 4280 4282 4284 4285 4286 4288 4289
                                                                                  4294 4294 4294 4294 4300 4301 4304 4305 4306 4306
                                                                                  4307 4307 4308 4308 4311 4312 4312 4313 4313 4314
                                                                                  4314 4315 4315 4321 4322 4325 4325 4325 4325 4325
                                                                                  4325 4325 4329 4329 4329 4329 4329 4329 4329 4333
                                                                                  4333 4333 4333 4333 4333 4333 4337 4337 4337 4337
                                                                                  4337 4337 4337 4341 4341 4341 4344* 4354 4356 4358
                                                                                  4360 4361 4363 4364 4368 4371 4372 4373 4374 4374
                                                                                  4375 4376 4377 4383 4384 4384 4385 4397 4398 4398
                                                                                  4398 4401 4401 4404 4407* 4410 4410 4412 4412 4412
                                                                                  4412 4418 4418 4418 4418 4418 4420 4420 4422 4422
                                                                                  4425 4428 4428 4429 4429 4429 4430 4430 4430 4430
                                                                                  4433 4433 4434 4437 4438 4441 4443 4444 4446 4446
                                                                                  4447 4447 4447 4450 4453 4454 4454 4456 4459 4459
                                                                                  4465 4466 4468* 4486 4489 4489 4489 4492 4493 4493
                                                                                  4494 4494 4494 4494 4494 4496 4496 4496 4497 4497
                                                                                  4497 4497 4497 4499 4499 4499 4502 4504 4504 4506*
                                                                                  4508 4513 4518 4523 4523 4523 4523 4528 4528 4898
                                                                                  4902* 4906* 4975 4982 4982 5013* 5023* 5023 5023
                                                                                  5023 5023 5035 5035 5038 5039 5039 5039 5040 5041
                                                                                  5042* 5043 5043 5043 5044 5044 5044 5056 5056 5059
                                                                                  5063 5066 5068 5069 5070 5079 5085 5100 5101 5203*
                                                                                  5214 5214 5220 5220 5224 5227 5227 5229 5229 5229
                                                                                  5235 5235 5236 5236
branch_status                   002153 automatic       structure                level 1 dcl 18-1 set ref 1013 1013
break_sw                275(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  181* 1782* 1866*
bs                      252(04)        based           structure                level 2 packed packed unaligned dcl 12-67 set ref
                                                                                  720*
buf_des                                based           structure                array level 1 unaligned dcl 12-11 set ref 4249*
                                                                                  4252* 4341
buf_max                         000400 constant        fixed bin(21,0)          initial array dcl 4194 ref 3955 3956 3959 3994 3994
                                                                                  4018 4028 4048 4071 4094 4157 4164 4171 4306
buf_size                        000303 constant        varying char(6)          initial array dcl 4183 ref 4000 4002
bufnum                  271            based           fixed bin(17,0)          level 2 dcl 11-31 ref 762 1327
byte                                                   builtin function         dcl 5241 ref 5311
c_str                                  based           char(20000)              packed unaligned dcl 4-242 ref 4-250
cant_get_here                   003312 stack reference condition                dcl 4827 ref 4826
caps                      2     000230 external static bit(1)                   level 2 dcl 10-11 set ref 598 1782* 1851* 4656
cb_c_r                  273            based           bit(18)                  level 2 dcl 11-31 set ref 164 405 525 2212* 3340
cb_r                      3            based           bit(18)                  level 2 dcl 3-33 set ref 4709* 4902 5102
cb_w_r                  274            based           bit(18)                  level 2 dcl 11-31 set ref 560* 2212* 3341*
cba_p                     4            based           pointer                  level 2 dcl 11-31 set ref 295* 297 769 1328
cc                       22     002610 automatic       fixed bin(21,0)          level 3 dcl 2119 set ref 2039*
cd                       44            based           structure                level 2 unaligned dcl 12-67
cexpl                     4            based           fixed bin(17,0)          level 2 in structure "cfx" dcl 3-49 in procedure
                                                                                  "ted_" set ref 4717* 4726
cexpl                     6            based           fixed bin(17,0)          level 2 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" ref 4-303
cexpml                    5            based           fixed bin(17,0)          level 2 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" set ref 5023 5023 4-297* 4-298 4-298 4-303*
                                                                                  4-304
cexpml                    3            based           fixed bin(17,0)          level 2 in structure "cfx" dcl 3-49 in procedure
                                                                                  "ted_" set ref 4716* 4718 4718 4726* 4727 5130
                                                                                  5144 5144 5149 5149
cf                                     based           structure                level 1 unaligned dcl 3-26 set ref 3122 3176 3184
                                                                                  4730 4734 4740 4747 4839 4858 4876 4881 4-29
cfa                                    based           structure                level 1 unaligned dcl 3-38 set ref 4792
cfmk                                   based           structure                level 1 unaligned dcl 3-33 set ref 4710
cfp                             000124 automatic       pointer                  dcl 3-25 set ref 1736 2981* 3011* 3011* 3014 3014
                                                                                  3014 3048 3048 3048 3048 3048 3052 3064 3064 3065
                                                                                  3065 3069 3069 3069 3069 3069 3077* 3111 3112 3122
                                                                                  3122 3122 3146 3152 3154 3154 3154 3155 3155 3174
                                                                                  3176 3176 3176 3178 3182 3182 3182 3183 3183 3184
                                                                                  3184 3184 4558 4560 4568* 4569 4570 4571 4587*
                                                                                  4588* 4637 4638 4639 4690 4692 4709 4710 4710 4716
                                                                                  4717 4718 4718 4726 4726 4727 4730 4730 4730 4734
                                                                                  4734 4734 4739 4739 4740 4740 4740 4746 4746 4747
                                                                                  4747 4747 4790 4791 4792 4792 4837 4837 4839 4839
                                                                                  4839 4856 4856 4858 4858 4858 4874 4874 4876 4876
                                                                                  4876 4878 4881 4881 4881 4891 4891 4893 4900* 4902
                                                                                  4904* 4984* 5000 5005 5007 5009 5013 5013 5013
                                                                                  5013 5013 5018 5020 5023 5023 5026 5028 5102 5105
                                                                                  5105 5126 5126 5126 5126 5126 5130 5132 5133* 5136
                                                                                  5137 5138* 5144 5144 5149 5149 5162 5162 5162 5162
                                                                                  5162 5170 5170 5170 5170 5170 5180 5180 5180 5199
                                                                                  4-27 4-28 4-29 4-29 4-29 4-272 4-272 4-287 4-290
                                                                                  4-290 4-294 4-297 4-298 4-298 4-303 4-303 4-304
                                                                                  4-306 4-306 4-306 4939 4939 4940
cft                                    based           structure                level 1 unaligned dcl 3-42 set ref 4-306
cfx                                    based           structure                level 1 unaligned dcl 3-49
ch                        1(18) 002660 automatic       char(1)                  level 2 in structure "the_line_no" packed packed
                                                                                  unaligned dcl 2508 in procedure "do_req" set ref
                                                                                  1668* 1688* 2543* 2545* 2591*
ch                                     parameter       char                     packed unaligned dcl 3171 in procedure "make_rp" ref
                                                                                  3170 3182 3182 3183
ch                              001215 automatic       char(1)                  packed unaligned dcl 5473 in procedure "ted_" set
                                                                                  ref 562* 564* 566 570* 572* 578 580* 3114* 3118*
                                                                                  3120 3127 3129 3149 3154* 3156* 3159* 3161 3166*
ch                              003306 automatic       char(1)                  packed unaligned dcl 4602
                                                                                  in begin block on line 4598 set ref 4754* 4755
                                                                                  4761 4771 4778 4797
ch                              003176 automatic       char(1)                  packed unaligned dcl 3360 in procedure "scan" set
                                                                                  ref 3371* 3372 3374 3376
char                                                   builtin function         dcl 5241 ref 2411 2415 2420 2426 3951 3959 3969
char_pic                        001132 automatic       picture(15)              packed unaligned dcl 5389 set ref 5373* 5374* 5382*
                                                                                  5383*
chars_moved                     000012 internal static fixed bin(30,0)          initial dcl 5390 set ref 349 349* 349 1568 1568*
                                                                                  1568 1970 1970* 1970 3750 3750* 3750 5371 5373
                                                                                  5375 5377* 5385*
checkpoint                2     002610 automatic       entry variable           level 2 dcl 2119 set ref 2044*
ck_ptr_sw               234(18)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  358 1193*
ck_sw                                  parameter       bit(1)                   dcl 678 ref 677 680
cleanup                         001216 stack reference condition                dcl 5474 ref 260
clear_name                             parameter       char                     packed unaligned dcl 5361 set ref 5360 5383*
cllen                           003266 automatic       fixed bin(21,0)          dcl 5188 set ref 5035* 5039* 5210 5235
clloc                           003267 automatic       fixed bin(21,0)          dcl 5188 set ref 5038* 5039 5039 5214 5220
cm_val                          001131 automatic       fixed bin(30,0)          initial dcl 5363 set ref 5362* 5363* 5377 5378
cname                    64     001746 automatic       char(32)                 level 2 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 840* 916*
                                                                                  924* 926 984* 1031* 1227* 1237 3300
cname                   224            based           char(32)                 level 3 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 201* 1119*
                                                                                  2289*
code                            001224 automatic       fixed bin(35,0)          dcl 5475 set ref 123* 125 125* 127 131 145* 154* 155
                                                                                  157 231* 237* 265* 266* 276* 279* 280* 282* 337*
                                                                                  418* 421 423 436* 510* 542* 543* 544 671* 672 916*
                                                                                  918 943* 944 947 949* 952 952* 955 970* 988* 990
                                                                                  993* 1001* 1012* 1013* 1017* 1045* 1047 1107* 1108
                                                                                  1128* 1130 1222* 1227* 1229 1628* 1634 1637 1711*
                                                                                  1714* 1716 1718 1740* 1743 1752* 1755 1771* 1949*
                                                                                  1997* 1999 2054* 2058* 2060 2069 2069* 2071 2071*
                                                                                  2073 2073* 2075 2075* 2079 2089* 2093* 2099 2104*
                                                                                  2106 2112 2465 2500* 2570* 2572 2574 2731* 2733*
                                                                                  2741* 2742 2746 2751* 2841* 2844 2846 2904* 2906
                                                                                  2908* 2911* 2912 2914* 2917* 2918 2918* 2920* 2921
                                                                                  2921* 2923* 2924 2926* 2941* 2944 2961 2973* 2976
                                                                                  3069* 3072 3220* 3221 3223* 3225* 3226 3228* 3230*
                                                                                  3231* 3232 3234* 3244* 3248* 4607* 4718* 4720
                                                                                  5013* 5016 5023* 5026 5028 5170* 5172 5180* 5181
                                                                                  5322* 5325* 5419* 5421 4-298* 4-300
codeptr                                                builtin function         dcl 5241 ref 1997 1997
com1_blank                1     000230 external static bit(1)                   level 2 dcl 10-11 set ref 706* 713 739 1462 1475
                                                                                  1492 1504 1782 1841* 1846* 1938 5336* 5343* 5350*
com_blank                       000230 external static bit(1)                   level 2 dcl 10-11 set ref 1444 1453 1602 1663 1709
                                                                                  1739 1782 1782* 1840* 1846* 2152 2172 2253 2379
                                                                                  2388 2399 2517 2628 2651 2673 2679 2734 2768 2896
                                                                                  5335* 5342* 5349*
com_err_                        000142 constant        entry                    external dcl 5592 ref 984 2908 2914 2918 2921 2926
                                                                                  3223 3228 3234 3248 5435
command_query_                  000076 constant        entry                    external dcl 5569 ref 840 1031 1359 2289
comment                 307            based           varying char(256)        level 2 dcl 11-31 set ref 1782 1782* 1900*
comptr                          000122 automatic       pointer                  dcl 3-14 set ref 1734 2972 2980 2981 2981 3012* 3077
                                                                                  3077 3079 3079 4560 4560 4563* 4567 4567 4568 4568
                                                                                  4581* 4582 4583 4583 4585* 4586 4587 4611 4624
                                                                                  4629 4629 4635 4635 4641 4641 4652 4653 4683 4683
                                                                                  4692 4695 4695 4885 4899 4900 4905 4954* 4969 4974
                                                                                  4975* 4981 4984 4984 5002* 5018 5020 5026 5028
                                                                                  5031 5132 5132 5133 5133 5137 5137 5138 5138 5199
                                                                                  5199 4-31* 4-274 4-275 4-276 5-21 5-23 5-31 5-34
                                                                                  5-36 4940 4940
concealsw                       001225 automatic       bit(1)                   packed unaligned dcl 5476 set ref 3110* 3115 3117*
                                                                                  3127* 3134* 3367* 3369 3374* 3384* 3388*
continue_to_signal_             000320 constant        entry                    external dcl 230 in on unit on line 228 ref 231
continue_to_signal_             000046 constant        entry                    external dcl 5477 in procedure "ted_" ref 337
convert                                                builtin function         dcl 5241 ref 2901
copy                                                   builtin function         dcl 5241 ref 3064
copy_flags                             based           structure                level 1 dcl 1-8
cp_escape_control         1(02) 002136 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
cu_$arg_count                   000126 constant        entry                    external dcl 5586 ref 145 5322
cu_$arg_list_ptr                000130 constant        entry                    external dcl 5587 ref 148
cu_$arg_ptr                     000132 constant        entry                    external dcl 5588 ref 5325 5419
cu_$cp                          000124 constant        entry                    external dcl 5585 ref 1949
cu_$ptr_call                    000332 constant        entry                    external dcl 2121 ref 2058
cur                     124            based           structure                level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 4307* 4313* 4375*
cur                     124            based           structure                level 2 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
cur_lex_top                     004271 automatic       fixed bin(17,0)          array dcl 4-216 set ref 4-82*
cur_line                        003240 automatic       bit(1)                   packed unaligned dcl 4535 set ref 4475* 4478* 4481*
                                                                                  4484* 4489
current                  27     002610 automatic       fixed bin(21,0)          level 2 dcl 2119 set ref 2036* 2101 2101
current_state                   004602 automatic       fixed bin(17,0)          dcl 4-219 set ref 4-12* 4-21 4-34 4-37 4-81 4-123*
                                                                                  4-124 4-124* 4-124 4-171 4-173* 4-176 4-183*
                                                                                  4-187*
current_table                   004604 automatic       fixed bin(17,0)          dcl 4-221 set ref 4-34* 4-39 4-43* 4-43 4-54* 4-54
                                                                                  4-65* 4-65 4-92 4-92 4-92 4-143 4-144 4-159 4-159
                                                                                  4-161 4-169 4-170 4-173 4-178* 4-178 4-180 4-180
                                                                                  4-180 4-187
da                        7            based           char                     level 2 in structure "cft" packed packed unaligned
                                                                                  dcl 3-42 in procedure "ted_" set ref 5013 5013
                                                                                  4-290*
da                        3            based           char                     level 2 in structure "cf" packed packed unaligned
                                                                                  dcl 3-26 in procedure "ted_" set ref 3048 3048
                                                                                  3064 3065 3069 3069 3154 3182* 4739* 4746* 4837*
                                                                                  4856* 4874* 5126 5126 5162 5162 5170 5170 5180*
data                      3(09) 003342 automatic       char(100)                level 2 packed packed unaligned dcl 4-195 set ref
                                                                                  4-113* 4-116* 4-149*
date_time_modified        1     002153 automatic       bit(36)                  level 2 packed packed unaligned dcl 18-1 set ref
                                                                                  1181
db_Ed                    26     000230 external static bit(1)                   level 3 dcl 10-11 set ref 356 366 2227
db_I                            004732 automatic       fixed bin(17,0)          dcl 5-67 set ref 5-68* 5-69* 5-69 5-69 5-69*
db_addr                   6     000230 external static bit(1)                   level 3 dcl 10-11 set ref 4506
db_catch                 34     000230 external static bit(1)                   level 3 dcl 10-11 set ref 118 160 272
db_data                         003342 automatic       structure                level 1 packed packed unaligned dcl 4-195 set ref
                                                                                  4-36* 4-120 4-120 4-150 4-150
db_gv                    14     000230 external static bit(1)                   level 3 dcl 10-11 set ref 4561 4588 4975 5001 4-24
                                                                                  4-31 4-103 4-146 4-157 5-22 5-35 5-43 5-56 5-75
                                                                                  5-87
db_lg                                  based           structure                array level 1 unaligned dcl 5440
db_look                                defined         picture(2)               packed unaligned dcl 4-194 set ref 4-111*
db_output                36     000230 external static pointer                  level 2 dcl 10-11 set ref 115 116 116* 120 122* 123*
                                                                                  125* 129* 130* 160* 272* 274 276* 279* 280* 282*
                                                                                  284* 1262* 1287* 2023* 2033* 2081* 2540* 3198*
                                                                                  3436* 3468* 3534* 3615* 3709* 3743* 3748* 3782*
                                                                                  3907* 4032* 4058* 4081* 4104* 4158* 4165* 4172*
                                                                                  4205* 4408* 4588* 5003* 5285* 5367 5369 5369*
                                                                                  5374* 5383* 5387*
db_srch                  20     000230 external static bit(1)                   level 3 dcl 10-11 set ref 3012 4561 4588
db_ted                    4     000230 external static bit(1)                   level 3 dcl 10-11 set ref 179 180 298 356 366* 1262
                                                                                  1287 1591 2023 2033 2081 2213 2229* 2540 2559 3044
                                                                                  3198 3436 3468 3532 3561 3612 3706 3743 3782 3790
                                                                                  3803 3815 3884 3895 3907 3940 3951 3969 4032 4058
                                                                                  4081 4104 4150 4158 4165 4172 4205 4344 4405 4468
                                                                                  5285 5299
db_trac                  24     000230 external static bit(1)                   level 3 dcl 10-11 set ref 179 180
dbase                                  based           structure                level 1 unaligned dcl 11-31
dbase_p                         002054 automatic       pointer                  dcl 11-29 set ref 154* 160 164 164 166 171* 176 176
                                                                                  176 176 179 180 181 181 182 214 224 227 270 271*
                                                                                  288 295 297 302 303 304 304 316 317 325 332 336*
                                                                                  346* 346 346 346 349 353 353 353 353 353 362* 370
                                                                                  370 372 372 372 372 372 374 374 377 377 377 379
                                                                                  379 381 383 383 383 384 384 384 384 385 385 385
                                                                                  386 386 387 387 387 388 388 391 391 391 392 392
                                                                                  392 392 392 392 405 405 406 406 410 410 417 417
                                                                                  418* 418 418 418 418 420 420 425 438* 441* 510*
                                                                                  522 522 522 525 532* 537 539 541 543* 547* 560 562
                                                                                  562 564 564 570 576 576 671* 687 687 688 688 688
                                                                                  689 691 696 697 697 700 700 702 741 741 745 745
                                                                                  762 769 813 813 813 813 813 814 814 823 823 884
                                                                                  884 884 903* 1001* 1069* 1071* 1139 1139 1140*
                                                                                  1140 1140 1140 1140 1142 1142 1150* 1174* 1186
                                                                                  1191 1191 1316 1316 1316 1319 1319 1322 1322 1322
                                                                                  1327 1328 1332* 1341 1341 1343 1343 1343 1343 1343
                                                                                  1344 1344 1354* 1369 1369 1371 1371 1371 1371 1371
                                                                                  1372 1372 1520 1520 1520 1520 1520 1520 1523 1523
                                                                                  1523 1525 1525 1530 1530 1530 1530 1531 1531 1533
                                                                                  1533 1535 1535 1539 1539 1544 1544 1544 1544 1545
                                                                                  1545 1558* 1603 1603 1608 1608 1610 1610 1610 1610
                                                                                  1617* 1622 1628 1628 1632* 1633* 1636* 1639 1647*
                                                                                  1664 1664 1668 1668 1673 1673 1688 1688 1690 1690
                                                                                  1711 1711 1711 1711 1711 1714 1714 1740 1740 1740
                                                                                  1740 1740 1745 1747 1747 1752 1752* 1771 1771 1771
                                                                                  1771 1771 1774 1774 1778 1778 1782 1782 1782 1782
                                                                                  1782 1782 1782 1782 1782 1782 1782 1795 1795 1795
                                                                                  1796 1796 1796 1797 1797 1797 1797 1797 1797 1800
                                                                                  1800 1800 1803 1803 1807 1807 1807 1810 1812 1812
                                                                                  1812 1815 1817 1817 1817 1820 1820 1822 1822 1822
                                                                                  1825 1825 1827 1827 1827 1830 1830 1832 1832 1832
                                                                                  1835 1837 1837 1837 1843 1843 1843 1848 1848 1848
                                                                                  1853 1853 1853 1856 1858 1858 1858 1863 1863 1863
                                                                                  1866 1868 1868 1868 1871 1873 1873 1873 1878 1878
                                                                                  1878 1882 1882 1882 1884 1884 1884 1888 1888 1888
                                                                                  1888 1891 1891 1891 1894 1894 1894 1900 1900 1900
                                                                                  1900 1903 1903 1903 1906 1908 1908 1908 1913 1913
                                                                                  1913 1915 1915 1916 1916 1916 1916 1916 1916 1918
                                                                                  1918 1918 1927 1927 1927 1927 1927 1931 1931 1942
                                                                                  1942 1942 1943 1943 1943 1943 1943 1943 1948* 1949
                                                                                  1949 1968* 1968 1968 1977 1977 1977 1983 1983 1983
                                                                                  1985 1985 1985 1986 1986 1988 1988 1989 1989 1989
                                                                                  1989 2027* 2037 2038 2039 2040 2051 2097* 2108
                                                                                  2109 2146 2146 2146 2149 2149 2163 2163 2164* 2164
                                                                                  2164 2164 2164 2167* 2167 2167 2167 2167 2169 2169
                                                                                  2212 2212 2238 2238 2239* 2239 2239 2239 2239 2241
                                                                                  2241 2355 2355 2360 2360 2360 2360 2360 2361 2361
                                                                                  2363 2363 2364 2364 2367 2367 2367 2370 2370 2370
                                                                                  2371 2371 2379 2379 2384 2384 2389* 2392* 2443
                                                                                  2443 2448 2448 2455* 2459 2459 2460 2460 2471 2471
                                                                                  2478 2478 2478 2485 2485 2489 2498 2498 2500 2500
                                                                                  2500 2500 2500 2570 2570 2621 2621 2643 2643 2661
                                                                                  2663 2663 2665 2665 2665 2672 2672 2674 2674 2674
                                                                                  2674 2674 2706 2706 2707 2710 2710 2710 2721 2721
                                                                                  2727 2727 2728 2728 2730 2730 2738 2738 2738 2741*
                                                                                  2741 2741 2741 2741 2751* 2796 2796 2796 2798 2798
                                                                                  2801 2801 2801 2802 2802 2802 2810 2810 2810 2812
                                                                                  2812 2816 2816 2816 2818 2818 2822 2822 2822 2824
                                                                                  2824 2829 2829 2830 2830 2830 2830 2830 2835 2835
                                                                                  2840 2840 2841* 2841 2841 2841 2841 2843 2843 2880
                                                                                  2880 2891 2891 2892* 2892 2892 2892 2892 2893 2893
                                                                                  2901 2904 2978 2978 3039* 3069* 3096* 3113 3113
                                                                                  3114 3114 3124 3124 3131 3131 3133 3133 3136 3136
                                                                                  3139 3139 3139 3145 3145 3145 3145 3145 3145 3146
                                                                                  3146 3151 3151 3244 3248 3305 3305 3340 3340 3341
                                                                                  3362 3362 3366 3368 3368 3368 3371 3371 3378 3378
                                                                                  3380 3380 3382 3382 3393 3395 3395 3550* 3953*
                                                                                  4044 4052 4052* 4052 4054 4057 4058 4067 4075
                                                                                  4075* 4075 4077 4080 4081 4090 4098 4098* 4098
                                                                                  4100 4103 4104 4115* 4156 4157 4158 4163 4164 4165
                                                                                  4170 4171 4172 4175* 4261 4264 4267 4270 4273
                                                                                  4285* 4287 4287 4362 4362 4551 4551 4551 4551 4553
                                                                                  4553 4608 4609 4612 4612 4612 4614 4614 4617 4617
                                                                                  4617 4619 4619 4619 4626 4626 4632 4632 4643 4643
                                                                                  4646 4646 4654 4654 4655 4655 4661 4661 4662 4662
                                                                                  4665 4665 4667 4667 4674 4674 4682 4682 4697 4697
                                                                                  4700* 4700 4700 4700 4700 4701 4701 4718 4718 4718
                                                                                  4722 4746 4746 4753 4753 4753 4754 4754 4787 4787
                                                                                  4802 4802 4804 4804 4805 4805 4805 4810 4810 4810
                                                                                  4820 4820 4820 4821 4821 4828 4828 4830 4830 4830
                                                                                  4837 4837 4837 4838 4838 4841 4841 4846 4846 4846
                                                                                  4847 4847 4847 4856 4856 4856 4857 4857 4860 4860
                                                                                  4863 4863 4863 4870 4870 4870 4870 4874 4874 4874
                                                                                  4875 4875 4902 4924 4924 5013* 5102 5170* 5180*
                                                                                  5256* 5267* 5284* 5320* 4-270 4-270 4-277 4-277
                                                                                  4-281 4-281 4-285 4-285 4-288 4-288 4-288 4-290
                                                                                  4-290 4-290 4-291 4-291 4-296 4-298 4-298 4-298
                                                                                  4-315 4-315
dbp                             001720 automatic       pointer                  dcl 5567 in procedure "ted_" set ref 2239* 2242 2244
                                                                                  2249 2256 2256 2256 2256 2256 2256 2262 2262 2263
                                                                                  2282 2305* 2306 2307 2343 2349
dbp                             003212 automatic       pointer                  dcl 3492 in procedure "buffer_buffer_copy" set ref
                                                                                  3529* 3534 3534 3537 3541* 3555 3589 3609 3614*
                                                                                  3619
dbs                             001136 automatic       bit(1)                   packed unaligned dcl 5410 set ref 5399* 5404* 5411*
                                                                                  5415* 5421 5427 5431
dbsw                                   based           bit(1)                   array level 2 dcl 5440 set ref 5421* 5427* 5431*
de                       13     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2022* 2023* 2084
de                       16     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2028* 2029 2029 2033* 2081* 2088*
de                       24     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 1968* 1970 2038* 2109
dec6                            000040 internal static picture(6)               level 2 packed packed unaligned dcl 5073 set ref
                                                                                  5079* 5080 5080 5085* 5086 5086
delete_acl                      001735 automatic       structure                level 1 dcl 5603 set ref 1128 1128
delim                           001226 automatic       char(1)                  packed unaligned dcl 5478 set ref 3120 3362* 3363
                                                                                  3363 3372
dim                                                    builtin function         dcl 5417 ref 5424
dir_db                  660            based           char(168)                level 2 packed packed unaligned dcl 11-31 ref 166
                                                                                  1782
divide                                                 builtin function         dcl 5241 ref 176 176 1021 1235 3253 3253 4146 4146
                                                                                  4940
dname                     2     001746 automatic       char(168)                level 2 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 840* 916*
                                                                                  943* 949* 970* 984* 993* 1031* 1045* 1128* 3291
dname                   142            based           char(168)                level 3 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 198* 1119*
                                                                                  2289* 2337* 3260*
do_global                40     002610 automatic       entry variable           level 2 dcl 2119 set ref 2047*
dtcm                    140            based           bit(36)                  level 3 packed packed unaligned dcl 12-67 set ref
                                                                                  1181*
edit_sw                 275(02)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  179* 1782* 1810* 1820* 1825* 1830*
ename                    54     001746 automatic       char(32)                 level 2 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 840* 916*
                                                                                  943* 949* 970* 984* 988* 993* 1031* 1045* 1128*
                                                                                  3294
ename                   214            based           char(32)                 level 3 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 199* 1119*
                                                                                  2289*
enl                             001227 automatic       fixed bin(21,0)          dcl 5479 set ref 888* 889 889* 891* 891 892 895
err_go                  742(09)        based           char(16)                 level 2 packed packed unaligned dcl 11-31 set ref
                                                                                  316* 425 537 539 541* 1752 2738*
err_gol                         000103 automatic       char(16)                 packed unaligned dcl 540 set ref 539* 543 543
err_msg                 410            based           varying char(168)        level 2 dcl 11-31 ref 381 384
err_req                         001230 automatic       varying char(16)         dcl 5480 set ref 385 385 386 535*
error_table_$inconsistent       000050 external static fixed bin(35,0)          dcl 5481 ref 2288
error_table_$insufficient_access
                                000052 external static fixed bin(35,0)          dcl 5482 ref 1017
error_table_$moderr             000054 external static fixed bin(35,0)          dcl 5483 ref 1030
error_table_$no_component       000060 external static fixed bin(35,0)          dcl 5485 ref 1069
error_table_$noentry            000056 external static fixed bin(35,0)          dcl 5484 ref 955 1071
error_table_$unimplemented_version
                                000212 external static fixed bin(35,0)          dcl 8-141 ref 2060
error_table_$unsupported_operation
                                000062 external static fixed bin(35,0)          dcl 5486 ref 947 952
error_table_$zero_length_seg    000064 external static fixed bin(35,0)          dcl 5487 ref 1174
ex                       14            based           structure                level 2 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
ex                       14            based           structure                level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 3820* 4315*
ex                       14            based           structure                array level 2 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
ex                        4            based           structure                level 2 in structure "sv" unaligned dcl 13-4
                                                                                  in procedure "ted_" set ref 4261* 4264*
ex_access                11     001722 automatic       bit(36)                  level 2 dcl 5597 set ref 1044*
expand_pathname_$component      000100 constant        entry                    external dcl 5570 ref 916
explanation_len          14     002136 automatic       fixed bin(21,0)          initial level 2 dcl 16-7 set ref 16-7*
explanation_ptr          12     002136 automatic       pointer                  initial level 2 dcl 16-7 set ref 16-7*
expr_b                          001235 automatic       fixed bin(21,0)          dcl 5488 set ref 1603 1608 1610 1610 1621* 1621 1622
                                                                                  1625 1628 1628 1639 1664 1664 1711 1711 1740 1740
                                                                                  1771 1771 2500 2500 3366* 3393 4718 4718 4722 4746
                                                                                  4-296 4-298 4-298
expr_l                          001236 automatic       fixed bin(21,0)          dcl 5489 set ref 1603 1610 1610 1623* 1623 1628*
                                                                                  1639 1664 1711 1711* 1740 1740* 1771 1771* 2500
                                                                                  2500* 3393* 4718* 4722 4745 4746 4-296 4-298*
expr_p                                 parameter       pointer                  dcl 2938 set ref 2936 2941*
extend                          003242 automatic       bit(1)                   packed unaligned dcl 4537 set ref 4475* 4478* 4481*
                                                                                  4484* 4523
f                         4            based           fixed bin(17,0)          level 2 dcl 3-42 set ref 5018 5028 4-272*
false                     6     003400 automatic       fixed bin(17,0)          array level 2 dcl 4-206 set ref 4-276* 4-317* 5-49*
                                                                                  5-62* 5-69* 5-78* 5-82* 5-82 5-92* 5-92* 5-94*
                                                                                  5-94 5-102 5-103*
fcbp                            001240 automatic       pointer                  dcl 5490 set ref 2904* 2911* 3230* 3231*
fcbsp                           000110 automatic       pointer                  dcl 3209 set ref 2917* 2920* 3225*
fd                              001746 automatic       structure                level 1 packed packed unaligned dcl 5607 set ref
                                                                                  825* 865 935 996 1105 1166
file_c                                 based           char(1)                  array packed unaligned dcl 5491 set ref 1085 1085
                                                                                  1259 1278 1282 1300 1300 1300 1300 1421 1421
file_d                  140            based           structure                array level 2 in structure "CB" packed packed
                                                                                  unaligned dcl 5632 in procedure "ted_"
file_d                  140            based           structure                level 2 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 825 865*
                                                                                  935* 996* 1105* 1166*
file_d                  140            based           structure                level 2 in structure "gb" packed packed unaligned
                                                                                  dcl 4960 in procedure "gv_compile"
file_l                          001242 automatic       fixed bin(21,0)          dcl 5492 set ref 1021* 1170 1189* 1217* 1220 1235*
                                                                                  1240 1241 1243 1244* 1245 1250 1254 1255 1257
                                                                                  1258* 1262* 1268 1278 1279 1280 1281 1283* 1287*
                                                                                  1292 1294 1294 1294 1298 1300 1300 1309 1309 1309
file_p                          001244 automatic       pointer                  dcl 5493 set ref 970* 971 993* 994 1012* 1085 1085
                                                                                  1092* 1107* 1189* 1217* 1222* 1227* 1234* 1243
                                                                                  1250 1254 1259* 1259 1262* 1278* 1278 1279 1280
                                                                                  1281 1282* 1282 1287* 1294 1294 1300 1300 1300
                                                                                  1300 1309 1309 1997* 2058*
file_s                                 based           char                     packed unaligned dcl 5494 set ref 1243* 1250 1254
                                                                                  1279* 1280* 1281* 1294* 1294 1309* 1309
file_sw                 234(09)        based           bit(1)                   level 4 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 200* 2283
                                                                                  2289* 2296* 2330 3259*
file_sw                  74(09) 001746 automatic       bit(1)                   level 3 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 828 863* 931*
finish                                 parameter       bit(1)                   packed unaligned dcl 3214 ref 3212 3240
fixed                                                  builtin function         dcl 5241 ref 616 617 618 3065 4820
flag                            003342 automatic       char(1)                  level 2 packed packed unaligned dcl 4-195 set ref
                                                                                  4-71* 4-114*
flow_sw                 275            based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  181* 1782* 1835* 2674
fo_name                         000112 automatic       char(7)                  packed unaligned dcl 3210 set ref 2900* 2901* 2904*
                                                                                  2917 2918* 2923 3228*
fo_sw                           001246 automatic       bit(1)                   packed unaligned dcl 5495 set ref 225* 268 320 1952
                                                                                  2868 2886 2928* 3216*
fop                             000114 automatic       pointer                  dcl 3211 set ref 1952 2892* 2894 3243
force_name               74(14) 001746 automatic       bit(1)                   level 3 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 864* 932*
force_name              234(14)        based           bit(1)                   level 4 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 878 996 1098
                                                                                  1102 1166 1169 1211 1511 2296 3257
fs_util_$suffix_info            000322 constant        entry                    external dcl 604 ref 943
g_c                                    based           char(1)                  array packed unaligned dcl 4962 set ref 5231 5231
                                                                                  5233 5233
g_s                                    based           char                     packed unaligned dcl 4961 ref 5214 5220
gb                       52            based           structure                level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 2613*
gb                                     based           structure                level 1 unaligned dcl 4960 in procedure "gv_compile"
gbp                             001250 automatic       pointer                  dcl 5496 set ref 178* 2452 2455* 2458 4987 4988 4991
                                                                                  4991 4993 4993 4997 5003 5003 5007 5009 5039* 5040
                                                                                  5042 5100 5101 5104* 5120 5120 5168 5168 5170*
                                                                                  5205 5206 5208 5208 5209 5209 5214 5214 5214 5220
                                                                                  5220 5220 5231 5231 5231 5231 5233 5233 5233 5233
get_bit_count           234(13)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  358 1952* 3264*
get_group_id_                   000102 constant        entry                    external dcl 5572 ref 1042
get_pdir_                       000104 constant        entry                    external dcl 5573 ref 911 2897
get_req                  30     002610 automatic       entry variable           level 2 dcl 2119 set ref 2045*
gme2                            003260 automatic       fixed bin(21,0)          dcl 4950 set ref 5023*
go_sw                           001252 automatic       bit(1)                   packed unaligned dcl 5497 set ref 225* 318 556* 2871
                                                                                  2877* 2883* 2888*
got_quit                        001253 automatic       bit(1)                   packed unaligned dcl 5498 set ref 2902* 2903* 2931
                                                                                  3218* 3219* 3238
gsb                                    defined         fixed bin(21,0)          dcl 4964 set ref 4987* 4991* 4993 5003* 5007* 5100
                                                                                  5120*
gse                                    defined         fixed bin(21,0)          dcl 4965 set ref 4988* 4991* 4993 4997* 5003* 5009*
                                                                                  5101 5120
gvNL                            002165 automatic       bit(1)                   packed unaligned dcl 5811 set ref 226* 1782* 1876*
                                                                                  2464 4974
gv_work                         000126 automatic       char(2048)               packed unaligned dcl 4542 set ref 4597* 4967*
gvx                                    based           structure                level 1 unaligned dcl 3-15
gvx_p                           001254 automatic       pointer                  dcl 5499 set ref 211* 4597* 4967*
hbound                                                 builtin function         dcl 5241 ref 3994 4-75 4-127
hcs_$add_acl_entries            000112 constant        entry                    external dcl 5578 ref 1045
hcs_$delete_acl_entries         000122 constant        entry                    external dcl 5583 ref 1128
hcs_$fs_get_path_name           000144 constant        entry                    external dcl 5611 ref 1012
hcs_$initiate_count             000106 constant        entry                    external dcl 5574 ref 970 3244
hcs_$make_ptr                   000330 constant        entry                    external dcl 2120 ref 1997
hcs_$make_seg                   000110 constant        entry                    external dcl 5576 ref 993
hcs_$status_long                000146 constant        entry                    external dcl 5613 ref 1013
hcs_$status_minf                000150 constant        entry                    external dcl 5615 ref 949
hcs_$terminate_noname           000116 constant        entry                    external dcl 5581 ref 1222 3255 4286 4361
hcs_$truncate_seg               000114 constant        entry                    external dcl 5580 ref 3254 4146
hdr                                    based           structure                level 2 in structure "cfx" unaligned dcl 3-49
                                                                                  in procedure "ted_"
hdr                                    based           structure                level 2 in structure "cft" unaligned dcl 3-42
                                                                                  in procedure "ted_"
hdr                                    based           structure                level 2 in structure "gvx" unaligned dcl 3-15
                                                                                  in procedure "ted_"
hdr                                    based           structure                level 2 in structure "cfmk" unaligned dcl 3-33
                                                                                  in procedure "ted_"
hdr                                    based           structure                level 2 in structure "cfa" unaligned dcl 3-38
                                                                                  in procedure "ted_"
hdr                                    based           structure                level 2 in structure "cf" unaligned dcl 3-26
                                                                                  in procedure "ted_"
header_l                        001256 automatic       fixed bin(21,0)          dcl 5500 set ref 1239* 1258 1259 1282 1284
hold                            002702 automatic       char(500)                packed unaligned dcl 682 set ref 688* 689 689
hold_db_output                  002044 automatic       pointer                  dcl 5608 set ref 115* 274 284 5367* 5387
hold_db_ted                     002052 automatic       bit(1)                   dcl 5630 set ref 356* 366
hold_de                         001257 automatic       fixed bin(17,0)          dcl 5501 set ref 145* 146 150
hole                            000106 automatic       fixed bin(21,0)          dcl 3794 set ref 3730* 3731* 3731 3732 3732
i                               003305 automatic       fixed bin(21,0)          dcl 4601 in begin block on line 4598 set ref 4805*
                                                                                  4810* 4811 4811 4819* 4819 4820 4821 4830* 4831
                                                                                  4836 4837 4838 4846* 4847 4847* 4849 4854* 4854
                                                                                  4855 4856 4857 4863* 4864 4870* 4872* 4873 4874
                                                                                  4875 4899* 4900 4900 4904* 4905
i                               004605 automatic       fixed bin(21,0)          dcl 4-222 in procedure "ted_gv_p_" set ref 4-92*
                                                                                  4-93 4-95* 4-180* 4-181 4-183* 4-277* 4-279 4-282
                                                                                  4-288* 4-289* 4-290 4-291 4-311* 4-313* 4-314
                                                                                  5-31* 5-31* 5-34 5-35* 5-36
i                               000101 automatic       fixed bin(21,0)          dcl 4179 in procedure "promote" set ref 4044* 4045
                                                                                  4054 4056 4057 4067* 4068 4077 4079 4080 4090*
                                                                                  4091 4100 4102 4103
i                               001260 automatic       fixed bin(21,0)          dcl 5502 in procedure "ted_" set ref 270* 272* 687*
                                                                                  688 688 689* 892* 893 895* 895 897 897 898 899 906
                                                                                  1084* 1085* 1085 1085 1085* 1090* 1092* 1092*
                                                                                  1420* 1421* 1421 1421 1421* 1426* 1428* 1428* 1614
                                                                                  1881* 1882* 1884* 1886 1888 1889 1894* 1895 1900
                                                                                  1901 1977* 1980 1983 1985 1986 2177* 2178* 2319*
                                                                                  2321 2323 2367* 2368 2370 2371 2550* 2552 2554
                                                                                  2661* 2674 2674 2707* 2738 2741 2741 2796* 2798
                                                                                  2798* 2800* 2800 2801 2802 2810 2812 2816 2818
                                                                                  2822 2824 2829 4418* 4420 4422 4443* 4444 4444*
                                                                                  4446 4453* 4454* 4456 4459 4459 4460 5400* 5405*
                                                                                  5412* 5416* 5421 5427 5431
i                               003133 automatic       fixed bin(17,0)          dcl 2999 in procedure "replace" set ref 3023* 3024
                                                                                  3026 3052* 3139* 3140 3145 3145
i                               004714 automatic       fixed bin(17,0)          dcl 5-16 in procedure "define" set ref 5-19* 5-20
                                                                                  5-21 5-22* 5-23 5-24*
ic                        5            based           fixed bin(17,0)          level 3 dcl 3-15 set ref 2972 2980* 2981 3077* 3077
                                                                                  3079 4567* 4568 4586* 4981* 4984 5018* 5020* 5026*
                                                                                  5028* 5031 5132* 5132 5133 5137* 5137 5138 5199*
                                                                                  5199
id                              000103 automatic       char(3)                  packed unaligned dcl 3641 set ref 3643* 3650* 3657*
                                                                                  3664* 3680* 3682* 3708* 3709* 3734
ids                                    parameter       fixed bin(17,0)          dcl 4-240 ref 4-238 4-245 4-245 4-250 4-250 4-260
idx                                    parameter       fixed bin(17,0)          dcl 4-240 ref 4-238 4-255 4-257 4-257 4-260 4-262
                                                                                  4-264 4-264
ii                              001261 automatic       fixed bin(21,0)          dcl 5503 set ref 1614*
il                              001262 automatic       fixed bin(21,0)          dcl 5504 set ref 2665* 2666 2668 2671* 2672 2674
                                                                                  2674 2710* 2711 2713 2719* 2724* 2727 2738 2741
                                                                                  2741
incr                                   parameter       fixed bin(21,0)          dcl 4937 ref 4935 4939
index                                                  builtin function         dcl 5241 ref 406 892 1250 1254 1523 1535 1675 1692
                                                                                  1884 1894 2319 2367 2493 2495 2550 2665 2710 2721
                                                                                  2796 3023 3131 3136 3139 3305 3695 4044 4067 4090
                                                                                  4418 4446 4459 4662 4669 4830 4846 4847 4863 4-277
                                                                                  4-288
initiate                234(17)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  1192* 4289* 4364*
inp                       6     002610 automatic       structure                level 2 unaligned dcl 2119
input_l                  30            based           fixed bin(21,0)          level 2 dcl 7-13 set ref 195 195* 1413*
input_p                  26            based           pointer                  level 2 dcl 7-13 set ref 195* 218 1352 1395 1414
input_sw                275(03)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  180* 1782* 1815* 1820* 1825* 1830*
intsw                           001263 automatic       bit(1)                   packed unaligned dcl 5505 set ref 244* 397* 2589
inuse_16K               254            based           bit(4)                   level 2 dcl 11-31 set ref 4090 4103* 4104* 4170*
                                                                                  4172*
inuse_1K                252            based           bit(16)                  level 2 dcl 11-31 set ref 4044 4057* 4058* 4156*
                                                                                  4158*
inuse_4K                253            based           bit(12)                  level 2 dcl 11-31 set ref 4067 4080* 4081* 4163*
                                                                                  4165*
invoking                234(21)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  3897
ioa_                            000134 constant        entry                    external dcl 5589 in procedure "ted_" ref 109 353
                                                                                  758 764 1117 1119 1782 1897 1906 1921 1922 2393
                                                                                  2674 3354 3474 5174 5317
ioa_                            000350 constant        entry                    external dcl 4-236 in procedure "ted_gv_p_" ref 4-24
                                                                                  5-35
ioa_$ioa_switch                 000136 constant        entry                    external dcl 5590 ref 160 272 1262 1287 2023 2033
                                                                                  2081 2540 3198 3436 3468 3534 3615 3709 3743 3748
                                                                                  3782 3907 4032 4058 4081 4104 4158 4165 4172 4205
                                                                                  4408 4588 5003 5285 5374 5383
ioa_$ioa_switch_nnl             000344 constant        entry                    external dcl 4-203 ref 4-120 4-150 4-159 4-162 4-165
ioa_$nnl                        000140 constant        entry                    external dcl 5591 ref 2591 5-22 5-69
iocb_ptr                        001264 automatic       pointer                  dcl 5506 set ref 258* 263 265* 266*
iox_$attach_iocb                000152 constant        entry                    external dcl 5618 ref 2923
iox_$attach_name                000154 constant        entry                    external dcl 5619 ref 123 2904
iox_$close                      000156 constant        entry                    external dcl 5620 ref 265 276 280 3230
iox_$control                    000160 constant        entry                    external dcl 5621 ref 237
iox_$detach_iocb                000162 constant        entry                    external dcl 5622 ref 129 266 282 3220 3231
iox_$error_output               000164 external static pointer                  dcl 5623 set ref 1437 1440 1653 1656 2863* 5156
iox_$find_iocb                  000166 constant        entry                    external dcl 5624 ref 2917
iox_$move_attach                000170 constant        entry                    external dcl 5625 ref 2920 3225
iox_$open                       000172 constant        entry                    external dcl 5626 ref 125 279 2911
iox_$put_chars                  000174 constant        entry                    external dcl 5627 ref 1447 1664 1943 2429 2585 2586
                                                                                  2623 2863 3194 3202 5080 5086 5162
iox_$user_output                000346 external static pointer                  dcl 4-204 in procedure "ted_gv_p_" set ref 4-120*
                                                                                  4-150* 4-159* 4-162* 4-165*
iox_$user_output                000176 external static pointer                  dcl 5628 in procedure "ted_" set ref 116 120 237*
                                                                                  274 1443 1659 1943* 2429* 2585* 2586* 2623* 2920*
                                                                                  2923* 3194* 3202* 3220* 3225* 5080* 5086* 5151
                                                                                  5369
it                              003077 automatic       fixed bin(21,0)          dcl 683 in begin block on line 681 set ref 689* 697
                                                                                  699* 699 700 702
it                              003302 automatic       fixed bin(21,0)          dcl 4599 in begin block on line 4598 set ref 4662*
                                                                                  4663 4669* 4670 4690 4691 4728
j                               001266 automatic       fixed bin(21,0)          dcl 5507 in procedure "ted_" set ref 2408* 2409*
                                                                                  2409 2411 2414* 2415 3113 3395* 3695* 3696 3702
                                                                                  4446* 4447 4451 4459* 4460 4462 5323* 5424* 5425
                                                                                  5427*
j                               004715 automatic       fixed bin(17,0)          dcl 5-17 in procedure "define" set ref 5-21* 5-24
jb                              001267 automatic       fixed bin(21,0)          dcl 5508 set ref 2416* 2417 2420
k                               001270 automatic       fixed bin(21,0)          dcl 5509 set ref 1523* 1525 1525* 1527* 1527 1528
                                                                                  1530* 1531 1535* 1536 1536* 1536 1537 1540 1557*
                                                                                  1558* 1564* 1564 1566 1568
kind                    234            based           char(1)                  level 3 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 202* 881*
                                                                                  1119* 2289*
kind                     74     001746 automatic       char(1)                  level 2 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 840* 852*
                                                                                  885* 896* 924 926* 963* 975 981* 1000* 1024 1031
                                                                                  1031 1031 1031* 1057 1059
l                                      parameter       structure                level 2 in structure "what" unaligned dcl 4318
                                                                                  in procedure "adjust"
l                        52            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                         6            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                        60            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        74            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                               003216 automatic       fixed bin(21,0)          dcl 3495 in procedure "buffer_buffer_copy" set ref
                                                                                  3582* 3586* 3590* 3597* 3601* 3606* 3610*
l                        44            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                                      based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                        52            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        60            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        12            based           structure                level 3 in structure "sv" unaligned dcl 13-4
                                                                                  in procedure "ted_"
l                        14            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        52            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        66            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                         6            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        44            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        14            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        16            based           structure                level 4 in structure "dbase" unaligned dcl 11-31
                                                                                  in procedure "ted_"
l                                      based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        22            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                        44            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                               000224 external static structure                level 2 in structure "tedcommon_$no_data" unaligned
                                                                                  dcl 10-8 in procedure "ted_"
l                         6            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        66            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                         4            based           structure                level 3 in structure "sv" unaligned dcl 13-4
                                                                                  in procedure "ted_"
l                        74            based           structure                array level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                                      based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
l                        60            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                        74            based           structure                array level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        14            based           structure                array level 3 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
l                        66            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        22            based           structure                array level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
l                        22            based           structure                array level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 2686* 2686
l                                      based           structure                array level 2 in structure "buf_des" unaligned
                                                                                  dcl 12-11 in procedure "ted_"
l6                              002660 automatic       picture(6)               level 2 packed packed unaligned dcl 2508 set ref
                                                                                  2583*
la_ct                           004606 automatic       fixed bin(17,0)          dcl 4-223 set ref 4-17* 4-83 4-87* 4-87 4-135* 4-135
                                                                                  4-319*
la_get                          004607 automatic       fixed bin(17,0)          dcl 4-224 set ref 4-15* 4-47 4-62 4-74 4-116* 4-133
                                                                                  4-134* 4-134
la_need                         004610 automatic       fixed bin(17,0)          dcl 4-225 set ref 4-47 4-48 4-51* 4-51 4-61* 4-73*
                                                                                  4-83 4-111 4-139*
la_put                          004611 automatic       fixed bin(17,0)          dcl 4-226 set ref 4-15* 4-86* 4-86 4-270 4-271 4-273
                                                                                  4-274 4-275 4-276 4-282 4-318*
la_use                          004612 automatic       fixed bin(22,0)          dcl 4-227 set ref 4-47* 4-62* 4-74* 4-89
last_op                         003261 automatic       fixed bin(17,0)          dcl 4978 set ref 4980* 4985 5000*
lastk_ovflo                     003334 stack reference condition                dcl 4-50 ref 4-48
lbound                                                 builtin function         dcl 5241 ref 4-47 4-48 4-86 4-134
le                       50            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 1154* 2237* 2272 2346 3534* 3568*
                                                                                  3568 3569 3577 3606 5101*
le                        4            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 363 772 804 1084 1085 1085 1220
                                                                                  1390 1390 1403 1420 1421 1421 1496 1558 1577 1581
                                                                                  1643* 2021 2191 2313 2409 2523 2607 2615 3041*
                                                                                  3091 3098* 3197 3431 3434 3446 3446 3449 3458 3464
                                                                                  3464 3474* 3560 3577 3581 3600 3698 3730 3743 3748
                                                                                  3754 3755 3774 3874 3883 3914 3925 3932 3933 3933
                                                                                  3968 4008 4398 4401 4412 4430 4447 4454 4494 4497
                                                                                  5056 5069 5235* 5235
le                      120            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3755* 3756 3766 3766 3769* 3770
                                                                                  3781 3782* 3782 4019* 4026* 4027 4031 4032* 4032
                                                                                  4049* 4072* 4095* 4128* 4129 4138 4138 4240
le                       17            based           fixed bin(21,0)          level 5 in structure "dbase" dcl 11-31 in procedure
                                                                                  "ted_" set ref 302* 302 317* 317 370 370 372* 372
                                                                                  372 372 372 372 374 374 377 377 379 379 383 383
                                                                                  384 384 385 385 391 391 392 392 392 392 406 406
                                                                                  410 410 417 417 418 418 418 418 420* 420 420 420
                                                                                  522 522 562 562 564 564 576* 576 576 576 687 687
                                                                                  688 688 696* 696 741 741 745* 745 745 745 813* 813
                                                                                  813 813 813 813 814 814 823 823 884 884 1139 1139
                                                                                  1140 1140 1140 1140 1316 1316 1319* 1319 1319 1319
                                                                                  1322 1322 1341 1341 1343* 1343 1343 1343 1343 1343
                                                                                  1344 1344 1369 1369 1371* 1371 1371 1371 1371 1371
                                                                                  1372 1372 1520 1520 1520 1520 1520* 1520 1520 1520
                                                                                  1523 1523 1525 1525 1530 1530 1530 1530 1531* 1531
                                                                                  1531 1531 1533 1533 1535 1535 1539* 1539 1539 1539
                                                                                  1544 1544 1544 1544 1545* 1545 1545 1545 1639*
                                                                                  1639 1668 1668 1673* 1673 1673 1673 1688 1688
                                                                                  1690* 1690 1690 1690 1778 1778 1796* 1796 1796
                                                                                  1796 1797 1797 1797 1797 1800 1800 1803* 1803 1803
                                                                                  1803 1807 1807 1812 1812 1817 1817 1822 1822 1827
                                                                                  1827 1832 1832 1837 1837 1843 1843 1848 1848 1853
                                                                                  1853 1858 1858 1863 1863 1868 1868 1873 1873 1878
                                                                                  1878 1882 1882 1884 1884 1888 1888 1891 1891 1894
                                                                                  1894 1900 1900 1903 1903 1908 1908 1913 1913 1915
                                                                                  1915 1916 1916 1916 1916 1918 1918 1927 1927 1927
                                                                                  1927 1931* 1931 1931 1931 1942 1942 1943 1943 1943
                                                                                  1943 1943 1943 1977 1977 1983 1983 1985 1985 1986*
                                                                                  1986 1986 1986 1988* 1988 1988 1988 1989 1989 1989
                                                                                  1989 2039 2039 2108* 2108 2146 2146 2149* 2149
                                                                                  2149 2149 2163 2163 2164 2164 2164 2164 2167 2167
                                                                                  2167 2167 2169* 2169 2169 2169 2238 2238 2239 2239
                                                                                  2239 2239 2241* 2241 2241 2241 2355 2355 2360*
                                                                                  2360 2360 2360 2360 2360 2361 2361 2363 2363 2364*
                                                                                  2364 2364 2364 2367 2367 2370 2370 2371* 2371 2371
                                                                                  2371 2379 2379 2384* 2384 2384 2384 2443 2443 2448
                                                                                  2448 2459* 2459 2459 2459 2460 2460 2471* 2471
                                                                                  2471 2471 2478 2478 2485* 2485 2485 2485 2498*
                                                                                  2498 2498 2498 2621* 2621 2643 2643 2661 2661 2663
                                                                                  2663 2665 2665 2672* 2672 2672 2672 2706 2706 2707
                                                                                  2707 2710 2710 2721 2721 2727* 2727 2727 2727 2728
                                                                                  2728 2730* 2730 2730 2730 2796 2796 2798 2798 2801
                                                                                  2801 2802 2802 2810 2810 2812* 2812 2812 2812 2816
                                                                                  2816 2818* 2818 2818 2818 2822 2822 2824* 2824
                                                                                  2824 2824 2829* 2829 2829 2829 2830* 2830 2830
                                                                                  2830 2830 2830 2835* 2835 2835 2835 2840 2840 2841
                                                                                  2841 2841 2841 2843* 2843 2843 2843 2880 2880 2891
                                                                                  2891 2892 2892 2892 2892 2893* 2893 2893 2893
                                                                                  3113* 3113 3114 3114 3124* 3124 3124 3124 3131
                                                                                  3131 3133* 3133 3133 3133 3136 3136 3139 3139 3145
                                                                                  3145 3145 3145 3146* 3146 3146 3146 3151* 3151
                                                                                  3151 3151 3305 3305 3362 3362 3366 3366 3368* 3368
                                                                                  3368 3368 3371 3371 3378 3378 3380 3380 3382* 3382
                                                                                  3382 3382 3393 3393 3395 3395 3395* 3395 4551 4551
                                                                                  4551* 4551 4551 4551 4553 4553 4553 4553 4608 4608
                                                                                  4612 4612 4614* 4614 4617 4617 4619 4619 4626*
                                                                                  4626 4632* 4632 4632 4632 4643 4643 4646* 4646
                                                                                  4654 4654 4655 4655 4661 4661 4662 4662 4665* 4665
                                                                                  4665 4665 4667 4667 4674* 4674 4682* 4682 4682
                                                                                  4682 4697 4697 4700 4700 4700 4700 4701* 4701 4701
                                                                                  4701 4722* 4722 4753* 4753 4753 4753 4754 4754
                                                                                  4787* 4787 4787 4787 4802 4802 4804* 4804 4804
                                                                                  4804 4805 4805 4810 4810 4820 4820 4821* 4821 4821
                                                                                  4821 4828* 4828 4828 4828 4830 4830 4837 4837
                                                                                  4838* 4838 4838 4838 4841 4841 4846 4846 4847 4847
                                                                                  4856 4856 4857* 4857 4857 4857 4860 4860 4863 4863
                                                                                  4870 4870 4870 4870 4874 4874 4875* 4875 4875 4875
                                                                                  4924* 4924 4924 4924 4-270 4-270 4-277 4-277
                                                                                  4-281* 4-281 4-281 4-281 4-285 4-285 4-288 4-288
                                                                                  4-290 4-290 4-291* 4-291 4-291 4-291 4-296* 4-296
                                                                                  4-315 4-315
le                       72            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4333 4333 4333* 4333
le                       26            based           fixed bin(21,0)          array level 4 in structure "gb" dcl 4960
                                                                                  in procedure "gv_compile" set ref 4988* 4988 4991
                                                                                  4991 4993 4993 4997* 4997 5003 5003 5009* 5009
                                                                                  5101 5101 5120 5120
le                       61            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4465*
le                       64            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4428* 4434* 4438
le                      122            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3760* 3762 3762* 3762 3774* 3776*
                                                                                  3776 4008* 4325 4329 4333 4337
le                      116            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3760* 3764 3774* 3775 4008* 4017
                                                                                  4031 4032* 4138 4138 4240
le                       53            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2518* 2523 2532* 2547 2550 2550
                                                                                  2554 2556* 2557 2557* 2557 2599 2607* 5183* 5185*
                                                                                  5185
le                       12            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3756* 3779* 3862* 3874* 4019* 4028*
                                                                                  4049* 4072* 4095* 4131* 5296*
le                        4            based           fixed bin(21,0)          level 4 in structure "gb" dcl 4960 in procedure
                                                                                  "gv_compile" ref 5209 5220 5233 5233
le                       26            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 210* 401* 716* 718
                                                                                  775* 783 795* 800 803 1084 1087* 1090 1137 1154
                                                                                  1161* 1161 1162 1162* 1194* 1220* 1420 1423* 1426
                                                                                  1477* 1482 1586* 1628 1643 1645* 1714* 1994* 2021
                                                                                  2084* 2101* 2191 2200 2237 2256 2256* 2262 2328*
                                                                                  2346* 2447* 2521 2552* 2554* 2555 2556 2570* 2586
                                                                                  2617 2617* 2690 2693* 2696* 2696 2762* 2762 2780
                                                                                  2780 2941* 2958 2973* 2983 3004* 3041 3098 3202
                                                                                  3263* 3411* 3449 3449* 3453 3458 3464 3474* 3556*
                                                                                  3558* 3560* 3806 3846 3862 3874 3883* 4397 4404*
                                                                                  4425 4497* 4499* 4523 4528 5023* 5044* 5236*
le                       23            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 209* 400 794* 1506*
                                                                                  2204 2206* 2234* 2327* 2416 2446 2547* 2654 2692*
                                                                                  3262* 4494* 4496* 4518 4523 5023* 5035 5038 5043*
                                                                                  5227
le                        7            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4029* 5294*
le                       67            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4325 4325 4325* 4325
le                        1            based           fixed bin(21,0)          level 4 in structure "gb" dcl 4960 in procedure
                                                                                  "gv_compile" ref 5208 5214 5231 5231
le                        1            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 363 772 1403 1581 2016* 2019 2020
                                                                                  2021 2022 2084 2085 2129 2131* 2155 2157* 2198*
                                                                                  2204 2206 2256 2311 2319 2319 2321 2414* 2532*
                                                                                  2615 3191* 3449 3828* 3968 4398 4410 4418 4418
                                                                                  4420 4430 4433 4453 4494 4496 5043
len                       2            based           fixed bin(17,0)          level 3 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" ref 5013 5013 5013 4-290 4-306
len                       2            based           fixed bin(17,0)          level 3 in structure "cf" dcl 3-26 in procedure
                                                                                  "ted_" set ref 3048 3048 3048 3052 3064 3065 3069
                                                                                  3069 3069 3112* 3122 3146 3152 3154 3154 3155*
                                                                                  3155 3176 3182 3182 3183* 3183 3184 4570* 4638*
                                                                                  4730 4734 4739 4740 4746 4747 4837 4839 4856 4858
                                                                                  4874 4876 4881 4891* 5126 5126 5126 5162 5162 5162
                                                                                  5170 5170 5170 5180 5180 4-28* 4-29 4939* 4939
                                                                                  4940
len                             000102 automatic       fixed bin(21,0)          dcl 4180 in procedure "promote" set ref 3955* 3956
                                                                                  3968* 3969 3994 4017* 4019 4027 4031 4031 4032*
                                                                                  4032* 4032 4049 4072 4095 4129 4130 4133 4138*
                                                                                  4138*
len                             000110 automatic       fixed bin(21,0)          dcl 3945 in procedure "openup" set ref 3932* 3933*
                                                                                  3936* 3937*
length                                                 builtin function         dcl 5241 ref 171 171 176 176 381 385 386 891 1239
                                                                                  1243 1244 1280 1281 2429 2429 2455 2455 2857 2863
                                                                                  2863 3074 3074 3074 3182 3183 5313 5313
level                           001271 automatic       fixed bin(35,0)          initial dcl 5510 set ref 438* 439 5510*
lg_catch                 35     000230 external static bit(1)                   level 3 dcl 10-11 set ref 277
lg_ted                    5     000230 external static bit(1)                   level 3 dcl 10-11 set ref 3743
lhe                                    parameter       fixed bin(21,0)          dcl 3415 set ref 3409 3410 3413 3430 3439 3474*
lindex                                 parameter       fixed bin(21,0)          dcl 3672 ref 3669 3684 3737
link                      4            based           fixed bin(17,0)          level 2 dcl 3-33 set ref 4692* 4904
lit_sw                  275(07)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 ref 1711
                                                                                  1740 1771 2500 4718 4-298
literal_sw                1(05) 002136 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
llen                            003272 automatic       fixed bin(21,0)          dcl 5217 set ref 5208* 5210 5212 5214 5214 5220 5231
                                                                                  5231*
ln                        3            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2134* 2160* 2201* 3036* 3716* 3723
                                                                                  3723* 3723 4493
ln                       63            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4429*
ln                       60            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4429*
ln                        1(18) 000336 external static fixed bin(17,0)          array level 3 in structure "ted_gv_t_$TL" packed
                                                                                  packed unaligned dcl 6-4
                                                                                  in begin block on line 4598 ref 4-257 4-264
ln                       11            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3879*
ln                                     based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 1570 1588 2132* 2158* 2199* 3036*
                                                                                  3714* 3721 3721* 3721
ln                       25            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 1588* 2129* 2155* 2426
                                                                                  2522 2549* 4429 4493*
ln                        6            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3741* 3879*
ln                       22            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 1156* 2129* 2155* 2199
                                                                                  2201 2520 2540* 2542* 2549 4492*
ln                       55            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2522*
ln                       52            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2520* 2532* 2538* 2540* 2542 2583
                                                                                  2591* 2602* 2602 5040* 5040 5079 5085
ln_                             000040 internal static structure                level 1 packed packed unaligned dcl 5073
ln_sw                           000014 internal static bit(1)                   initial packed unaligned dcl 5396 set ref 2389* 2423
                                                                                  5394* 5395*
lndx                                   based           fixed bin(21,0)          dcl 3494 set ref 3590* 3610*
lno                      11     002610 automatic       fixed bin(21,0)          level 3 dcl 2119 set ref 2016* 2018* 2018
loc                       7     003400 automatic       fixed bin(17,0)          array level 2 dcl 4-206 set ref 4-274* 4-317* 5-47*
                                                                                  5-62* 5-69* 5-78* 5-90*
low                                                    builtin function         dcl 5241 ref 4157 4164 4171
ls                              003400 automatic       structure                array level 1 unaligned dcl 4-206 set ref 4-47 4-48
                                                                                  4-86 4-127 4-133* 4-133 4-134 5-99* 5-99 5-110*
                                                                                  5-110
ls_top                          004270 automatic       fixed bin(17,0)          dcl 4-215 set ref 4-14* 4-82 4-127 4-132* 4-132
                                                                                  4-133 4-170* 4-170 5-47 5-47 5-49 5-59 5-62 5-62
                                                                                  5-68 5-68 5-78 5-78 5-80 5-80 5-81 5-81 5-82 5-82
                                                                                  5-90 5-90 5-92 5-92 5-93 5-93 5-94 5-94 5-99 5-99
                                                                                  5-102 5-102 5-103 5-103 5-110 5-110
ltrim                                                  builtin function         dcl 5241 ref 2411 2415 2420 2426 3291 3951 3959 3969
m                                      based           char                     packed unaligned dcl 3086 in procedure "add_rep" set
                                                                                  ref 3097* 3097
m                               004613 automatic       fixed bin(17,0)          dcl 4-229 in procedure "ted_gv_p_" set ref 4-91*
make_room                       000101 automatic       bit(1)                   packed unaligned dcl 3637 set ref 3645* 3652* 3659*
                                                                                  3666* 3683* 3727 3741 3757 3772 3787
mark1                                  parameter       char                     packed unaligned dcl 3288 ref 3286 3295 3297 3298
marker                          001126 automatic       char(1)                  packed unaligned dcl 5307 set ref 5311* 5326 5326
max                                                    builtin function         dcl 5241 ref 718 2018 3567 4287 4362
max_len                                based           fixed bin(24,0)          level 3 dcl 3-15 set ref 4582* 4683 4940
maxl                    253            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 775 795 799* 1026* 1379*
                                                                                  1384 1390 1390 1400* 1769* 2029 2029 2129 2133
                                                                                  2155 2159 2319 2550 2952 2952 2955 2955 3023 3565*
                                                                                  3777 3781 3805* 3827* 3902* 3927 3932 4031 4031
                                                                                  4122 4122 4306* 4312* 4374* 4418 4446 4459 5214
                                                                                  5220
maxln                   254            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 1574* 2129* 2134 2155*
                                                                                  2160 3028 3028* 3028 3030* 3034* 3716* 3719 3719*
                                                                                  3719 3879* 4374* 5229 5229* 5229 5289*
maxseg                          001272 automatic       fixed bin(21,0)          dcl 5511 set ref 206*
mbz                     137            based           fixed bin(17,0)          level 3 dcl 12-67 set ref 5292*
me                              001273 automatic       fixed bin(21,0)          dcl 5512 set ref 1714* 2570* 2941* 2947 2951 2973*
                                                                                  2982*
me2                             001274 automatic       fixed bin(21,0)          dcl 5513 set ref 1714* 2570* 2941* 2973* 2982*
mi                              001275 automatic       fixed bin(21,0)          dcl 5514 set ref 1714* 2570* 2941* 2947 2948 2952
                                                                                  2952 2955 2955 2973* 2982*
min                                                    builtin function         dcl 5241 ref 2021 2084 3568 3846 3874 3932 4-250
                                                                                  4-282
mk_list                   3            based           fixed bin(24,0)          level 3 dcl 3-15 set ref 4653* 4692 4695* 4899
ml                              001276 automatic       fixed bin(21,0)          dcl 5515 in procedure "ted_" set ref 2947* 2948 2952
                                                                                  2952 2955 2955
ml                       17     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2032*
ml                       25     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2040*
ml                              003132 automatic       fixed bin(21,0)          dcl 2998 in procedure "replace" set ref 3010* 3017
                                                                                  3023 3026 3052 3055* 3059 3063 3064 3065* 3065
                                                                                  3069* 3093 3097 3097
mod                                                    builtin function         dcl 4-193 ref 4-47 4-86 4-134
mod_sw                  234(11)        based           bit(1)                   level 4 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 1098* 1219*
                                                                                  1351 1352* 1355* 1409* 1411 1416 1566* 2283 2946*
                                                                                  3038* 3729* 3821* 3880* 5224*
mod_sw                  234(11)        based           bit(1)                   level 4 in structure "gb" packed packed unaligned
                                                                                  dcl 4960 in procedure "gv_compile" ref 5206
mod_sw                   74(11) 001746 automatic       bit(1)                   level 3 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 871 1098*
                                                                                  1211* 1214* 1219
mode                      3     002153 automatic       bit(5)                   level 2 packed packed unaligned dcl 18-1 set ref
                                                                                  1015 1028
mrl_                            000066 constant        entry                    external dcl 5516 ref 1085 1092 1300 1421 1428 3766
                                                                                  4138
msg                             002060 automatic       varying char(168)        dcl 14-6 set ref 171* 204 362* 418* 433* 441* 446*
                                                                                  450* 454* 458* 462* 466* 470* 474* 478* 482* 486*
                                                                                  490* 494* 498* 502* 506* 510* 514* 516* 516 518*
                                                                                  518 521* 521 522* 522 523* 523 528* 528 529* 529
                                                                                  530* 530 532 532* 614* 616* 617* 618* 619 664*
                                                                                  665* 665 693* 758 758 777* 791* 812* 832* 851*
                                                                                  880* 901* 902* 902 903* 920* 961* 962* 962 980*
                                                                                  1001* 1018* 1049* 1065* 1069* 1071* 1110* 1132*
                                                                                  1140* 1147* 1148* 1148 1149* 1149 1150* 1172*
                                                                                  1174* 1335* 1628* 1711* 1714* 1740* 1757* 1771*
                                                                                  1925* 1927* 1927 1982* 1983* 1983 1984* 1984 1997
                                                                                  1997 2053* 2058* 2114 2114* 2114 2164* 2167* 2239*
                                                                                  2246* 2267* 2274* 2332* 2333* 2333 2334* 2334
                                                                                  2335* 2335 2336* 2336 2337 2404* 2407* 2407 2411*
                                                                                  2411 2412* 2412 2415* 2415 2419* 2419 2420* 2420
                                                                                  2421* 2421 2425* 2425 2426* 2426 2428* 2428 2429
                                                                                  2429 2455* 2472* 2473* 2473 2474* 2474 2500* 2570*
                                                                                  2639* 2655* 2806* 2813* 2819* 2825* 2841* 2859*
                                                                                  2860* 2860 2861* 2861 2863 2863 2871* 2873* 2874*
                                                                                  2874 2892* 2941* 2973* 3069* 3142* 3291* 3291 3292
                                                                                  3292* 3292 3294* 3294 3297* 3297 3298* 3298 3300*
                                                                                  3300 3329* 3350* 3476* 3547* 3548* 3548 3549* 3549
                                                                                  3550* 3899* 3958* 3959* 3959 3960* 3960 4000*
                                                                                  4001* 4001 4002* 4002 4003* 4003 4510* 4515* 4520*
                                                                                  4525* 4530* 4621* 4645* 4677* 4700* 4706* 4718*
                                                                                  4759* 4761* 4761 4762* 4762 4815* 4833* 4851*
                                                                                  4866* 4910* 4913* 4916* 4919* 4922* 4971* 5013*
                                                                                  5023* 5170* 5313* 4-77* 4-100* 4-129* 4-298* 4942*
msg_ptr                         002134 automatic       pointer                  dcl 14-7 set ref 204* 2429* 2863*
mustreprotect                   001277 automatic       bit(1)                   packed unaligned dcl 5517 set ref 778* 822* 1052*
                                                                                  1125
n1                              003307 automatic       fixed bin(21,0)          dcl 4603 set ref 4749* 4766* 4782* 4790
n1_sw                           003303 automatic       bit(1)                   packed unaligned dcl 4600 set ref 4751* 4757 4767*
                                                                                  4782
n2                              003310 automatic       fixed bin(21,0)          dcl 4604 set ref 4749* 4766 4768* 4782 4791 4796*
                                                                                  4820*
n2_sw                           003304 automatic       bit(1)                   packed unaligned dcl 4600 set ref 4751* 4757 4769*
                                                                                  4773 4775* 4780 4799 4801* 4823*
name                    235            based           char(16)                 level 2 packed packed unaligned dcl 12-67 set ref
                                                                                  529 758* 1119* 1148 2186* 2289* 2335 2355 3534*
                                                                                  3534* 3548 3815 3907* 4205* 5285*
nc                       23     002610 automatic       fixed bin(21,0)          level 3 dcl 2119 set ref 2038* 2108
new                     120            based           structure                level 2 unaligned dcl 12-67
newa                     60            based           structure                level 2 unaligned dcl 12-67 set ref 1185* 4384 4385*
newb                      6            based           structure                level 2 unaligned dcl 12-67 set ref 3740* 3849*
                                                                                  3860* 3873* 4007* 4211* 4216 4308 4314 4315 5293*
next_state                      004614 automatic       fixed bin(17,0)          dcl 4-231 set ref 4-95* 4-108 4-123
no_io                   234(15)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  197* 726 770 781 820 2181
noref                   252(08)        based           bit(1)                   level 2 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 2458*
noref                   252(08)        based           bit(1)                   level 2 in structure "gb" packed packed unaligned
                                                                                  dcl 4960 in procedure "gv_compile" set ref 5205*
not_pasted               74(16) 001746 automatic       bit(1)                   level 3 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 1095* 1098*
not_pasted              234(16)        based           bit(1)                   level 4 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 2283 2343*
                                                                                  2349* 3569*
not_read_ct             267            based           fixed bin(17,0)          level 2 dcl 11-31 set ref 325 332 1191* 1191 4287*
                                                                                  4287 4362* 4362
not_sw                          001300 automatic       bit(1)                   packed unaligned dcl 5518 set ref 565* 846 859 878
                                                                                  928 932 933 1674* 1718 1720 1802* 1805* 1810 1815
                                                                                  1825 1835 1841 1846 1851 1856 1861 1866 1871 1876
                                                                                  2146 2164 2173 2736 2788 2790
null                                                   builtin function         dcl 5241 ref 116 122 123 123 130 167 167 173 178 211
                                                                                  218 258 5313 5313 5315 5369 16-7 16-7 16-7 237 237
                                                                                  263 274 971 994 1013 1013 1143 1179 1352 1376 1395
                                                                                  1405 2170 2242 2452 2841 2841 2894 2904 2904 3246
                                                                                  4052 4075 4098 4112 4579 4702 5013 5013 5170 5170
nulreq                  741(27)        based           char(2)                  level 2 packed packed unaligned dcl 11-31 set ref
                                                                                  214* 570 1782* 1888* 2489
oct                                    based           structure                level 1 packed packed unaligned dcl 610
old                     116            based           structure                array level 2 in structure "CB" unaligned dcl 5632
                                                                                  in procedure "ted_"
old                     116            based           structure                level 2 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
old                     116            based           structure                level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
old_bp                          003206 automatic       pointer                  dcl 3491 in procedure "buffer_buffer_copy" set ref
                                                                                  3530* 3617
old_bp                          003270 automatic       pointer                  dcl 5189 in procedure "gv_compile" set ref 5041*
                                                                                  5183 5183 5183 5185 5185 5203
old_bp                          000100 automatic       pointer                  dcl 3266 in procedure "detach" set ref 3242* 3265
old_style               275(04)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  182* 1782* 1871*
on_quit                         001301 automatic       bit(1)                   packed unaligned dcl 5519 set ref 290* 322 328* 339*
op                                     based           fixed bin(17,0)          level 3 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" set ref 4-287* 4-294*
op                                     based           fixed bin(17,0)          level 3 in structure "cf" dcl 3-26 in procedure
                                                                                  "ted_" set ref 1736* 3014 3014 3014 3111* 3174
                                                                                  3178* 4558 4569* 4637* 4690* 4878* 4891* 5000 5005
                                                                                  5105 5105 5136 4-27*
op1                                    parameter       fixed bin(17,0)          dcl 3171 ref 3170 3174 3178 3179
op_mnem                         000372 constant        char(22)                 initial packed unaligned dcl 4594 ref 4669
optlen                          002607 automatic       fixed bin(17,0)          dcl 1806 set ref 1809* 1814* 1819* 1824* 1829* 1834*
                                                                                  1839* 1845* 1850* 1855* 1860* 1865* 1870* 1875*
                                                                                  1880* 1889* 1889 1893* 1901* 1901 1905* 1910*
                                                                                  1915* 1920* 1931
out                      14     002610 automatic       structure                level 2 unaligned dcl 2119
output_l                 34            based           fixed bin(21,0)          level 2 dcl 7-13 set ref 1407*
output_p                 32            based           pointer                  level 2 dcl 7-13 ref 1405 1408
p1                                     parameter       fixed bin(21,0)          dcl 1960 ref 1958
p2                                     parameter       fixed bin(21,0)          dcl 1960 ref 1958
padding                   1(07) 002136 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
parse_stack                     004435 automatic       fixed bin(17,0)          array dcl 4-217 set ref 4-75 4-81* 4-162* 4-181
part1                    10            based           structure                level 3 unaligned dcl 11-31
part2                    16            based           structure                level 3 unaligned dcl 11-31
pdname                          000017 internal static char(32)                 initial packed unaligned dcl 5520 set ref 911 911*
                                                                                  913 2897 2897* 2904 3244* 3248*
pend                    132            based           structure                level 2 unaligned dcl 12-67 set ref 3991* 4307 4313
pi_label                        001302 automatic       label variable           dcl 5521 set ref 239 250 342* 755* 1552* 1946* 2055*
                                                                                  2533* 3189*
pi_passthru                     000027 internal static bit(1)                   packed unaligned dcl 5522 set ref 205* 231 369*
                                                                                  5356*
pi_sw                           001306 automatic       fixed bin(17,0)          dcl 5523 set ref 223* 234 236* 241 243* 246 248*
                                                                                  344* 348* 756* 1553* 1947* 1950* 2056* 2096* 2534*
                                                                                  2537* 2611* 3190* 3205*
pic2                                   automatic       picture(2)               packed unaligned dcl 2900 ref 2901
pn                      135            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4056* 4079* 4102* 4114* 5292*
pn                      127            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4156 4157 4158* 4163 4164 4165*
                                                                                  4170 4171 4172*
present                 252            based           bit(1)                   array level 2 in structure "gb" packed packed
                                                                                  unaligned dcl 4960 in procedure "gv_compile" set
                                                                                  ref 5168* 5168*
present                 252            based           bit(1)                   array level 2 in structure "b" packed packed
                                                                                  unaligned dcl 12-67 in procedure "ted_" set ref
                                                                                  290* 290 398 398 412* 412* 568 716 752* 752* 783
                                                                                  783 787 796* 796* 1339 1365 1479 1711 1711 1740
                                                                                  1740 1771 1771 1782 1782 2003 2005 2041 2041 2244
                                                                                  2250 2405 2405 2500 2500 2682 2684 2757 2773 2776
                                                                                  2838 3315 3325 3346 4486 4502 4704 4982* 4982*
printing                  4            based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  4611 4652* 4885* 4974
proc_expr                34     002610 automatic       entry variable           level 2 dcl 2119 set ref 2046*
program_interrupt               001310 stack reference condition                dcl 5524 ref 228 5357
prompt_after_explanation
                          1(06) 002136 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
ps_top                          004615 automatic       fixed bin(17,0)          dcl 4-232 set ref 4-14* 4-75 4-80* 4-80 4-81 4-82
                                                                                  4-161 4-161 4-169* 4-169 4-181
pseudo                  234(19)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  1026 1329 1769 2135 3825 3902 4020 4060 4083 4106
                                                                                  4118 4149* 4280 4301 4304* 4356 4372* 5297*
pt                       14     002610 automatic       pointer                  level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2027* 2029 2033* 2081* 2088*
pt                       20     002610 automatic       pointer                  level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2037*
pt                        1     000336 external static fixed bin(17,0)          array level 3 in structure "ted_gv_t_$TL" packed
                                                                                  packed unaligned dcl 6-4
                                                                                  in begin block on line 4598 ref 4-257 4-264
pt                        6     002610 automatic       pointer                  level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2019* 2023* 2029
ptr                                                    builtin function         dcl 5241 ref 164 405 3340 3953 4261 4264 4267 4270
                                                                                  4273 4285 4902 5102 5256 5267 5284 5320
qedx_mode                       001316 automatic       bit(1)                   packed unaligned dcl 5525 set ref 222* 886 3317 3327
                                                                                  3348
query_code                3     002136 automatic       fixed bin(35,0)          initial level 2 dcl 16-7 set ref 16-7*
query_info                      002136 automatic       structure                level 1 dcl 16-7 set ref 840 840 1031 1031 1359 1359
                                                                                  2289 2289
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 16-35 ref 207
question_iocbp            4     002136 automatic       pointer                  initial level 2 dcl 16-7 set ref 16-7*
quit                            001320 stack reference condition                dcl 5526 ref 327 334 2903 2929 2931 3219 3236 3238
r                        21            based           structure                level 4 in structure "dbase" unaligned dcl 11-31
                                                                                  in procedure "ted_"
r                         3            based           structure                level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
r                        25            based           structure                array level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" set ref 2687* 2687
r                        71            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r                        25            based           structure                array level 3 in structure "gb" unaligned dcl 4960
                                                                                  in procedure "gv_compile"
r                        11            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r                        47            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r                        55            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r                        63            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r                         3            based           structure                level 3 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_"
r_l                                    parameter       fixed bin(21,0)          dcl 3082 set ref 3080 3092 3102*
r_p                                    parameter       pointer                  dcl 3082 set ref 3080 3102*
rank                                                   builtin function         dcl 5241 ref 602 1681 1703
re                       20            based           fixed bin(21,0)          level 5 in structure "dbase" dcl 11-31 in procedure
                                                                                  "ted_" set ref 303* 303 304 304 346 346 349 349
                                                                                  353 353 370 370 372 372 374 374 377 377 379 379
                                                                                  383 383 384 384 385 385 386* 386 386 386 387 387
                                                                                  387 387 388* 388 388 388 391 391 392 392 392 392
                                                                                  417 417 522 522 562 562 687 687 688 688 697 697
                                                                                  700 700 702* 702 813 813 823 823 884 884 1139 1139
                                                                                  1142* 1142 1142 1142 1316 1316 1322 1322 1343 1343
                                                                                  1371 1371 1523 1523 1525 1525 1533 1533 1603 1603
                                                                                  1608 1608 1610 1610 1610 1610 1778 1778 1795 1795
                                                                                  1795 1795 1796 1796 1797 1797 1797 1797 1800 1800
                                                                                  1807 1807 1812 1812 1817 1817 1822 1822 1827 1827
                                                                                  1832 1832 1837 1837 1843 1843 1848 1848 1853 1853
                                                                                  1858 1858 1863 1863 1868 1868 1873 1873 1878 1878
                                                                                  1882 1882 1884 1884 1888 1888 1891 1891 1894 1894
                                                                                  1900 1900 1903 1903 1908 1908 1913 1913 1915 1915
                                                                                  1916 1916 1916 1916 1918 1918 1927 1927 1927 1927
                                                                                  1942 1942 1943 1943 1949 1949 1977 1977 1983 1983
                                                                                  1985 1985 1989 1989 2038 2038 2109* 2109 2146 2146
                                                                                  2163 2163 2238 2238 2360 2360 2367 2367 2370 2370
                                                                                  2443 2443 2460 2460 2478 2478 2621 2621 2665 2665
                                                                                  2674 2674 2674 2674 2710 2710 2738 2738 2741 2741
                                                                                  2741 2741 2796 2796 2798 2798 2801 2801 2802 2802
                                                                                  2810 2810 2816 2816 2822 2822 2830 2830 2840 2840
                                                                                  2891 2891 3113 3113 3139 3139 3145 3145 3145 3145
                                                                                  3368 3368 4612 4612 4614 4614 4617 4617 4619 4619
                                                                                  4626 4626 4643 4643 4646 4646 4654 4654 4674 4674
                                                                                  4697 4697 4746 4746 4753 4753 4805 4805 4810 4810
                                                                                  4820 4820 4830 4830 4837 4837 4846 4846 4847 4847
                                                                                  4856 4856 4863 4863 4874 4874 4-288 4-288 4-290
                                                                                  4-290
re                       51            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 1137* 2262* 2272 2272 3534* 3556
                                                                                  5103*
re                       13            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4018* 4048* 4071* 4094* 5295*
re                      123            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3759* 3761* 3761 3775* 3777 3777*
                                                                                  3777 4009* 4010* 4010 4325 4329 4333 4337
re                       62            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4428* 4433* 4437
re                       65            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4466*
re                       23            based           fixed bin(21,0)          level 5 in structure "dbase" dcl 11-31 in procedure
                                                                                  "ted_" set ref 346* 353 353 353* 1968* 2040
re                        2            based           fixed bin(21,0)          level 4 in structure "gb" dcl 4960 in procedure
                                                                                  "gv_compile" ref 5208
re                       24            based           fixed bin(21,0)          array level 4 in structure "gb" dcl 4960
                                                                                  in procedure "gv_compile" set ref 4987* 4987 4991
                                                                                  4991 4993 4993 5003 5003 5007* 5007 5100 5100
                                                                                  5120* 5120
re                       73            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4337 4337 4337* 4337
re                       57            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2521* 2523 2523 2605 2608 5183
re                       10            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3764* 3771* 3850* 3861* 4030* 4130*
                                                                                  4130 4312 5295*
re                       24            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 209* 400* 716* 718*
                                                                                  774* 783 794* 800 803 1090 1092 1092 1153 1215*
                                                                                  1215 1426 1428 1428 1482* 1496* 1506* 1628 1628
                                                                                  1628 1714* 1993* 2011* 2011 2013* 2015* 2015 2016*
                                                                                  2020 2085* 2191 2194* 2198 2234 2236 2321* 2323*
                                                                                  2327* 2345* 2408 2409 2414* 2416 2446* 2518 2547*
                                                                                  2570* 2586 2586 2586 2654* 2692* 2778 2778 2785
                                                                                  2785 2941* 2948* 2951* 2958 2973* 2983 3006* 3008
                                                                                  3020* 3020 3023 3042* 3069 3069 3194 3194 3194
                                                                                  3197* 3202 3202 3202 3262* 3410* 3446 3446* 3451
                                                                                  3464 3474* 3556* 3806 3844 3846* 3861 3904 4420*
                                                                                  4422* 4494* 4496* 4528 4975 5023* 5043* 5227*
re                      117            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3759* 3760 3775* 3779 4009* 4017
                                                                                  4231
re                       27            based           fixed bin(21,0)          array level 4 in structure "b" dcl 12-67
                                                                                  in procedure "ted_" set ref 210* 401 795* 1477*
                                                                                  2204 2207* 2328* 2447 2555* 2693* 3005* 3042 3263*
                                                                                  3844* 3850 4497* 4499* 4513 5023* 5035 5044*
re                      121            based           fixed bin(21,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 3754* 3770* 3771 4018* 4019 4027*
                                                                                  4030 4048* 4049 4071* 4072 4094* 4095 4129*
re                        5            based           fixed bin(21,0)          level 4 in structure "gb" dcl 4960 in procedure
                                                                                  "gv_compile" ref 5209 5214 5220
re                       16            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 297*
re                       54            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 2523* 2526* 2550 2552 2557 2599
                                                                                  2605 2608* 5183*
re                        5            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 363 716 772 1162 1403 1581 2013
                                                                                  2129 2133* 2155 2159* 2200* 2204 2256 2313 2615
                                                                                  2617 3191* 3446 3558 3698 3828* 3846 3874 3874
                                                                                  3968 4009 4131 4412 4430 4444 4447 4447 4497 4499
                                                                                  4523 4523 5056 5059 5070 5103
re                       46            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 1153* 2236* 2272 2345 3534* 3567*
                                                                                  3567 3569 3578 3585 3596 3605 3606 5100*
re                       70            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4329 4329 4329* 4329
re                        2            based           fixed bin(21,0)          level 4 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 363 772 804 1087 1194 1384 1403
                                                                                  1423 1557 1558* 1564 1577 1581 1586 1645 2022 2191
                                                                                  2194 2256 2256 2311 2313 2319 2323 2409 2409 2523
                                                                                  2526 2615 2617 3091 3194 3431 3434 3446 3449 3449
                                                                                  3451 3453 3474* 3578 3730 3743 3748 3759 3769 3914
                                                                                  3923 3936 3968 4026 4122 4122 4122 4128 4146 4146
                                                                                  4398 4401 4410 4412 4418 4422 4430 4443 4450 4454
                                                                                  4494 4497 5044 5063 5066 5068 5236
read_sw                 275(06)        based           bit(1)                   level 3 packed packed unaligned dcl 11-31 set ref
                                                                                  227* 1186 1782* 1856*
real_dname                      002327 automatic       char(168)                packed unaligned dcl 1009 set ref 1012* 1013*
real_ename                      002401 automatic       char(32)                 packed unaligned dcl 1010 set ref 1012* 1013*
recurs                    1            based           fixed bin(17,0)          level 2 dcl 11-31 set ref 160* 270 1782* 2901
reg_exp_p                44     002610 automatic       pointer                  level 2 dcl 2119 set ref 2051*
regexp                  463            based           char(500)                level 2 packed packed unaligned dcl 11-31 set ref
                                                                                  176 176 176 176 1711 1711 1714 1714 1740 1740 1747
                                                                                  1747 1771 1771 1774 1774 2051 2500 2500 2570 2570
rel                                                    builtin function         dcl 5241 ref 525 560 2212 3341 4709
rel_temp                 66            based           structure                level 2 unaligned dcl 12-67 set ref 4252 4264 4270
                                                                                  4279* 4321* 4322 4341
reloc_first                            constant        fixed bin(17,0)          initial dcl 12-61 ref 4239
reloc_last                             constant        fixed bin(17,0)          initial dcl 12-61 ref 4244
rep_p                           003134 automatic       pointer                  dcl 3000 set ref 3008* 3055* 3097 3099*
repeat_time              10     002136 automatic       fixed bin(71,0)          initial level 2 dcl 16-7 set ref 16-7*
repl_exp                        002412 automatic       char(500)                packed unaligned dcl 1738 set ref 1733* 1746*
req                      20     002610 automatic       structure                level 2 unaligned dcl 2119
req_ch                          001326 automatic       char(1)                  packed unaligned dcl 5527 set ref 256* 403* 578* 616
                                                                                  617 618 1677 1678* 1681 1694* 1698* 1702 1702*
                                                                                  1703 1774 2473 2480 2482* 2631 2633* 4609* 4-311
req_chx                         001330 automatic       varying char(4)          dcl 5528 set ref 256* 403* 579* 743* 748 808 830 853
                                                                                  871 964 977 1002 1038 1074 1114 1175 1223 1668*
                                                                                  1672 1675 1678 1679* 1688* 1689 1692 1694 1698
                                                                                  1700* 2382* 2389 2448* 2449 2450 2469 2469 2483*
                                                                                  2487 2489* 2490 2490* 2493 2495 2527 2527 2527
                                                                                  2527 2543 2543 2545 2564 2577 2581 2591 2594 2621
                                                                                  2631*
req_not                         001332 automatic       char(1)                  packed unaligned dcl 5529 set ref 256* 291* 403*
                                                                                  579* 1677* 1680* 1697* 2480*
req_str                         001333 automatic       varying char(36)         dcl 5530 set ref 313* 403* 518 535 578* 619* 665
                                                                                  744* 744 840* 1672* 1672 1689* 1689 1943 1985*
                                                                                  1985 2148* 2148 2333 2383* 2383 2449* 2449 2481*
                                                                                  2481 2801* 2801 2851 3354* 4547* 4547 4548* 4548
                                                                                  4549* 4549
reset                   256            based           label variable           level 2 dcl 11-31 set ref 288*
reset_read                3     000230 external static bit(1)                   level 2 dcl 10-11 set ref 1782* 1861*
result                          001345 automatic       varying char(500)        dcl 5531 set ref 2841* 2853 2853 2857 2860 3069*
                                                                                  3074 3074 3074 3074 3074 5013* 5018 5018 5170*
                                                                                  5174 5174*
return_string_l          24            based           fixed bin(21,0)          level 2 dcl 7-13 ref 1378 1384 1390
return_string_p          22            based           pointer                  level 2 dcl 7-13 ref 167 1378 1384 1384 1390 1390
reverse                                                builtin function         dcl 5241 ref 888 2319 4418 4459
rhe                                    parameter       fixed bin(21,0)          dcl 3415 set ref 3409 3411 3413 3433 3439 3474*
rl                       10            based           structure                level 2 unaligned dcl 11-31
rl_b                            002053 automatic       fixed bin(21,0)          dcl 11-14 set ref 404* 519 522 522 1625* 4553 4553*
                                                                                  4608* 4609
rl_c                                   based           char(1)                  array packed unaligned dcl 11-17 set ref 353 406 410
                                                                                  418 418 564 741 814 1140 1140 1341 1344 1369 1372
                                                                                  1520 1520 1530 1530 1535 1544 1544 1622* 1628 1628
                                                                                  1664 1664 1668 1688 1711 1711 1740 1740 1771 1771
                                                                                  1943 1943 1989* 2164 2164 2167 2167 2239 2239 2355
                                                                                  2361 2363 2379 2448 2500 2500 2643 2663 2706 2721
                                                                                  2728 2841 2841 2880 2892 2892 3114 3131 3136 3305
                                                                                  3362 3371 3378 3380 4551 4609 4655 4661 4662 4667
                                                                                  4700 4700 4718 4718 4754 4802 4841 4860 4870 4870
                                                                                  4-270 4-277 4-285 4-298 4-298 4-315
rl_i                                   defined         fixed bin(21,0)          dcl 11-15 set ref 302* 317* 370 372* 372 372 374 377
                                                                                  379 383 384 385 391 392 392 406 410 417 418 418
                                                                                  420* 420 522 562 564 576* 576 687 688 696* 741
                                                                                  745* 745 813* 813 813 814 823 884 1139 1140 1140
                                                                                  1316 1319* 1319 1322 1341 1343* 1343 1343 1344
                                                                                  1369 1371* 1371 1371 1372 1520 1520 1520* 1520
                                                                                  1523 1525 1530 1530 1531* 1531 1533 1535 1539*
                                                                                  1539 1544 1544 1545* 1545 1639* 1668 1673* 1673
                                                                                  1688 1690* 1690 1778 1796* 1796* 1797 1797 1800
                                                                                  1803* 1803 1807 1812 1817 1822 1827 1832 1837 1843
                                                                                  1848 1853 1858 1863 1868 1873 1878 1882 1884 1888
                                                                                  1891 1894 1900 1903 1908 1913 1915 1916 1916 1918
                                                                                  1927 1927 1931* 1931* 1942 1943 1943 1943 1977
                                                                                  1983 1985 1986* 1986 1988* 1988 1989 1989 2039
                                                                                  2108* 2146 2149* 2149 2163 2164 2164 2167 2167
                                                                                  2169* 2169 2238 2239 2239 2241* 2241 2355 2360*
                                                                                  2360 2360 2361 2363 2364* 2364 2367 2370 2371*
                                                                                  2371 2379 2384* 2384 2443 2448 2459* 2459 2460
                                                                                  2471* 2471 2478 2485* 2485 2498* 2498 2621* 2643
                                                                                  2661 2663 2665 2672* 2672 2706 2707 2710 2721
                                                                                  2727* 2727 2728 2730* 2730 2796 2798 2801 2802
                                                                                  2810 2812* 2812 2816 2818* 2818 2822 2824* 2824
                                                                                  2829* 2829 2830* 2830 2830 2835* 2835 2840 2841
                                                                                  2841 2843* 2843 2880 2891 2892 2892 2893* 2893
                                                                                  3113* 3114 3124* 3124 3131 3133* 3133 3136 3139
                                                                                  3145 3145 3146* 3146 3151* 3151* 3305 3362 3366
                                                                                  3368* 3368* 3371 3378 3380 3382* 3382* 3393 3395
                                                                                  3395* 4551 4551* 4551 4553 4553 4608 4612 4614*
                                                                                  4617 4619 4626* 4632* 4632 4643 4646* 4654 4655
                                                                                  4661 4662 4665* 4665 4667 4674* 4682* 4682 4697
                                                                                  4700 4700 4701* 4701 4722* 4753* 4753* 4754 4787*
                                                                                  4787 4802 4804* 4804 4805 4810 4820 4821* 4821*
                                                                                  4828* 4828 4830 4837 4838* 4838 4841 4846 4847
                                                                                  4856 4857* 4857 4860 4863 4870 4870 4874 4875*
                                                                                  4875 4924* 4924 4-270 4-277 4-281* 4-281 4-285
                                                                                  4-288 4-290 4-291* 4-291 4-296* 4-315
rl_l                                   defined         fixed bin(21,0)          dcl 11-16 set ref 303* 304 346* 349 353 370 372 374
                                                                                  377 379 383 384 385 386* 386 387 387 388* 388 391
                                                                                  392 392 417 522 562 687 688 697 700 702* 813 823
                                                                                  884 1139 1142* 1142 1316 1322 1343 1371 1523 1525
                                                                                  1533 1603 1608 1610 1610 1778 1795 1795 1796 1797
                                                                                  1797 1800 1807 1812 1817 1822 1827 1832 1837 1843
                                                                                  1848 1853 1858 1863 1868 1873 1878 1882 1884 1888
                                                                                  1891 1894 1900 1903 1908 1913 1915 1916 1916 1918
                                                                                  1927 1927 1942 1943 1949* 1977 1983 1985 1989 2038
                                                                                  2109* 2146 2163 2238 2360 2367 2370 2443 2460 2478
                                                                                  2621 2665 2674 2674 2710 2738 2741 2741 2796 2798
                                                                                  2801 2802 2810 2816 2822 2830 2840 2891 3113 3139
                                                                                  3145 3145 3368 4612 4614 4617 4619 4626 4643 4646
                                                                                  4654 4674 4697 4746 4753 4805 4810 4820 4830 4837
                                                                                  4846 4847 4856 4863 4874 4-288 4-290
rl_s                                   based           char                     packed unaligned dcl 11-18 set ref 304* 372 377 383*
                                                                                  384* 385* 387* 391* 392 392 522 688 697 700* 813
                                                                                  884 1316 1322 1343 1371 1523 1603 1608 1610 1610
                                                                                  1795* 1797 1797 1800 1807 1812 1817 1822 1827 1832
                                                                                  1837 1843 1848 1853 1858 1863 1868 1873 1878 1882
                                                                                  1884 1888 1891 1894 1900 1903 1908 1913 1916 1916
                                                                                  1918 1927 1942* 1977 1983 1985 2146 2360 2367 2370
                                                                                  2478 2665 2674 2674 2710 2738 2741 2741 2796 2801
                                                                                  2802 2810 2816 2822 2830 3139 3145 3145 4612 4617
                                                                                  4619 4746 4805 4810 4820 4830 4837 4846 4847 4856
                                                                                  4863 4874 4-288 4-290
rlen                            003273 automatic       fixed bin(21,0)          dcl 5217 set ref 5209* 5210 5218 5220 5220 5233
                                                                                  5233*
rq_id                   746(09)        based           char(19)                 level 2 packed packed unaligned dcl 11-31 set ref
                                                                                  2904 3244 3248*
rqc                                    parameter       char(1)                  packed unaligned dcl 594 ref 592 597 597 598 598 602
                                                                                  2270 2341 2341
rtrim                                                  builtin function         dcl 5241 ref 529 543 543 902 920 1148 1237 2335 3291
                                                                                  3291 3294 3300 3548 3815
rulen                                  parameter       fixed bin(17,0)          dcl 5-7 in procedure "sem" ref 5-5 5-10
rulen                           004616 automatic       fixed bin(17,0)          dcl 4-234 in procedure "ted_gv_p_" set ref 4-143*
                                                                                  4-150* 4-154 4-154*
safe_mode                              parameter       bit(1)                   dcl 3624 set ref 3622 3648 3655 3662 3669 3709*
save_mod                        001543 automatic       bit(1)                   packed unaligned dcl 5532 set ref 1351* 1355
sb                              003230 automatic       fixed bin(21,0)          dcl 4395 in procedure "iso_line" set ref 4437* 4454
                                                                                  4456 4456 4459 4460* 4462* 4462 4465
sb                       10     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2020* 2023* 2028
sbp                             001716 automatic       pointer                  dcl 5567 in procedure "ted_" set ref 2232* 2252 2263
                                                                                  2300 2305* 2307 2335 2339
sbp                             003210 automatic       pointer                  dcl 3492 in procedure "buffer_buffer_copy" set ref
                                                                                  3528* 3534 3534 3534 3537 3537* 3540* 3545 3548
                                                                                  3564 3590 3593 3610 3618
sdup_op                         000645 constant        fixed bin(17,0)          initial dcl 3-3 set ref 3156*
se                       12     002610 automatic       fixed bin(21,0)          level 3 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2021* 2023* 2084
se                              003231 automatic       fixed bin(21,0)          dcl 4395 in procedure "iso_line" set ref 4397* 4398
                                                                                  4398 4398* 4401 4401* 4404 4408* 4425* 4428 4430
                                                                                  4430 4430 4430 4438* 4439 4441 4444 4446 4446
                                                                                  4447* 4450* 4451* 4451 4466
search                                                 builtin function         dcl 5241 ref 888
seg_16K                                based           structure                array level 1 packed packed unaligned dcl 4190 set
                                                                                  ref 4100 4171*
seg_1K                                 based           structure                array level 2 packed packed unaligned dcl 4185 set
                                                                                  ref 4054 4157*
seg_4K                40000            based           structure                array level 2 packed packed unaligned dcl 4185 set
                                                                                  ref 4077 4164*
seg__                                  based           structure                level 1 packed packed unaligned dcl 4185
seg_acl                         001722 automatic       structure                level 1 dcl 5597 set ref 1045 1045
seg_des                                based           structure                level 1 unaligned dcl 11-20
seg_p                    24            based           pointer                  array level 2 dcl 11-31 set ref 4052 4052* 4054 4075
                                                                                  4075* 4077 4098 4098* 4100 4157 4164 4171 4261
                                                                                  4264 4267 4270 4273
seg_sw                          000100 automatic       char(3)                  packed unaligned dcl 3965 set ref 3950* 3967* 3998
                                                                                  4024 4032* 4040 4126 4146
select                          001544 automatic       char(16)                 packed unaligned dcl 5533 set ref 2355* 2363* 2370*
                                                                                  2378* 2389*
seval_op                        000476 constant        fixed bin(17,0)          initial dcl 3-3 set ref 3014 3145*
should_not_be_here              000000 stack reference condition                dcl 5534 ref 5191
siz                       1            based           fixed bin(24,0)          level 3 in structure "cfx" dcl 3-49 in procedure
                                                                                  "ted_" ref 5132 5137
siz                       1            based           fixed bin(24,0)          level 3 in structure "cfmk" dcl 3-33 in procedure
                                                                                  "ted_" set ref 4710*
siz                       1            based           fixed bin(24,0)          level 3 in structure "cf" dcl 3-26 in procedure
                                                                                  "ted_" set ref 3077 3122* 3176* 3184* 4560 4571*
                                                                                  4639* 4730* 4734* 4740* 4747* 4839* 4858* 4876*
                                                                                  4881* 4893* 5199 4-29*
siz                       1            based           fixed bin(24,0)          level 3 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" set ref 4-306*
siz                       1            based           fixed bin(24,0)          level 3 in structure "cfa" dcl 3-38 in procedure
                                                                                  "ted_" set ref 4792*
size                                                   builtin function         dcl 5241 ref 3122 3176 3184 4582 4710 4730 4734 4740
                                                                                  4747 4792 4839 4858 4876 4881 4-29 4-306
sn                      126            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 721 728 770 789 1145 1186 1211 1329
                                                                                  1477 1506 1511 1550 1991 2127 2250 2283 2771 2804
                                                                                  3425 3440 3545 3910 4020 4023 4118 4118 4154 4161
                                                                                  4168 4175 4175* 4294 4354 4508 5039* 5287
sn                      134            based           fixed bin(17,0)          level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4023* 4055* 4078* 4101* 4115* 4294
                                                                                  5291*
sort_l                          002411 automatic       fixed bin(21,0)          dcl 1627 set ref 1615* 1616 1617 1617* 1628* 1644*
sort_p                          001550 automatic       pointer                  array dcl 5535 set ref 1617* 1628* 1644*
sort_sn                         001556 automatic       fixed bin(17,0)          array dcl 5536 set ref 1616* 1617* 1632* 1633* 1636*
                                                                                  1647* 2026* 2027* 2097*
sp                      124            based           pointer                  level 3 in structure "gb" dcl 4960 in procedure
                                                                                  "gv_compile" ref 5214 5220 5231 5231 5233 5233
sp                       10            based           pointer                  level 4 in structure "dbase" dcl 11-31 in procedure
                                                                                  "ted_" set ref 304 346* 353 372 377 383 384 385
                                                                                  387 391 392 392 406 410 418 418 522 564 688 689*
                                                                                  691 697 700 741 813 814 884 1140 1140 1316 1322
                                                                                  1341 1343 1344 1369 1371 1372 1520 1520 1523 1530
                                                                                  1530 1535 1544 1544 1603 1608 1610 1610 1622 1628
                                                                                  1628 1664 1664 1668 1688 1711 1711 1740 1740 1771
                                                                                  1771 1795 1797 1797 1800 1807 1812 1817 1822 1827
                                                                                  1832 1837 1843 1848 1853 1858 1863 1868 1873 1878
                                                                                  1882 1884 1888 1891 1894 1900 1903 1908 1913 1916
                                                                                  1916 1918 1927 1942 1943 1943 1949* 1968* 1977
                                                                                  1983 1985 1989 2037 2146 2164 2164 2167 2167 2239
                                                                                  2239 2355 2360 2361 2363 2367 2370 2379 2448 2478
                                                                                  2500 2500 2643 2663 2665 2674 2674 2706 2710 2721
                                                                                  2728 2738 2741 2741 2796 2801 2802 2810 2816 2822
                                                                                  2830 2841 2841 2880 2892 2892 3114 3131 3136 3139
                                                                                  3145 3145 3305 3362 3371 3378 3380 4551 4609 4612
                                                                                  4617 4619 4655 4661 4662 4667 4700 4700 4718 4718
                                                                                  4746 4754 4802 4805 4810 4820 4830 4837 4841 4846
                                                                                  4847 4856 4860 4863 4870 4870 4874 4-270 4-277
                                                                                  4-285 4-288 4-290 4-298 4-298 4-315
sp                      124            based           pointer                  level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 1085 1085 1092 1092 1179 1384 1390
                                                                                  1421 1421 1428 1428 1558* 1628 1628 2019 2313 2319
                                                                                  2550 2586 2586 2952 2952 2955 2955 3008 3023 3069
                                                                                  3069 3194 3194 3202 3202 3590* 3610* 3766 3766
                                                                                  3781 3782* 3933 3933 3937 3937 4022 4031 4031
                                                                                  4032* 4032* 4122 4138 4138 4146* 4286* 4361* 4412
                                                                                  4418 4441 4446 4456 4459 5039 5039 5214 5220
sp                      132            based           pointer                  level 3 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" set ref 4022* 4054* 4077* 4100* 4112 4115*
                                                                                  4122 4138 4138 5290*
space                           000100 automatic       fixed bin(21,0)          dcl 3085 in procedure "add_rep" set ref 3091* 3092*
                                                                                  3092 3093 3093
space                                  parameter       char                     packed unaligned dcl 4576 in procedure "init_cfp"
                                                                                  set ref 4574 4581 4582
srch_len                  2            based           fixed bin(24,0)          level 3 dcl 3-15 set ref 4583* 4629 4635* 4641*
srepl_op                        000673 constant        fixed bin(17,0)          initial dcl 3-3 set ref 3014 3118* 3159* 3166*
sself_op                        000615 constant        fixed bin(17,0)          initial dcl 3-3 set ref 3163*
stack_o                 251            based           bit(18)                  level 2 dcl 12-67 set ref 4258* 4261 4264 4267 4270
                                                                                  4273* 4273 4275
stackl                   20            based           bit(18)                  level 2 in structure "sv" dcl 13-4 in procedure
                                                                                  "ted_" ref 4273
stackl                  250            based           bit(18)                  level 2 in structure "b" dcl 12-67 in procedure
                                                                                  "ted_" ref 4256 4258
state                     0(09) 003342 automatic       picture(4)               level 2 packed packed unaligned dcl 4-195 set ref
                                                                                  4-37*
state_b                 261            based           fixed bin(21,0)          level 2 dcl 12-67 set ref 4205* 4207 4209* 4212*
                                                                                  4241* 4246* 4248* 4251* 4255* 4259* 4263* 4265*
                                                                                  4269* 4271* 4274* 4278* 4284* 4300* 4305* 4311*
                                                                                  4360* 4368* 4371* 4383*
status_code               2     002136 automatic       fixed bin(35,0)          initial level 2 dcl 16-7 set ref 16-7* 839* 1030*
                                                                                  1358* 2288*
str                             000100 automatic       char                     packed unaligned dcl 3063 set ref 3064* 3065 3065
string                                                 builtin function         dcl 5241 set ref 720* 4-36* 4-120 4-120 4-150 4-150
                                                                                  5435 5435
string_mode              26     002610 automatic       bit(1)                   level 2 packed packed unaligned dcl 2119 set ref
                                                                                  2041*
string_sw                              defined         bit(1)                   packed unaligned dcl 5629 set ref 290* 398 1711 1740
                                                                                  1771 1782* 2041 2405 2500
sub_p                           001600 automatic       pointer                  dcl 5542 set ref 211* 1733* 1746*
sub_type                        001561 automatic       varying char(12)         dcl 5538 set ref 1064* 1067 1069 1231*
subf1                           001565 automatic       char(4)                  packed unaligned dcl 5539 set ref 220* 1250 1254
                                                                                  1279
subf2                           001566 automatic       char(3)                  packed unaligned dcl 5540 set ref 221* 1250 1281
subfile_name                    001567 automatic       varying char(32)         dcl 5541 set ref 810* 897* 924 1237* 1239 1250 1280
                                                                                  1280 1281
substr                                                 builtin function         dcl 5241 set ref 372 377 383* 384* 384 385* 387*
                                                                                  391* 392 392 522 616* 617* 618* 619 688* 688 697
                                                                                  700* 758 758 813 843 884 892 897 898 909 913 1036
                                                                                  1243* 1254 1279* 1280* 1281* 1294* 1294 1309* 1309
                                                                                  1316 1322 1343 1361 1371 1384 1390 1523 1603 1608
                                                                                  1610 1610 1684 1795* 1797 1797 1800 1807 1812 1817
                                                                                  1822 1827 1832 1837 1843 1848 1853 1858 1863 1868
                                                                                  1873 1878 1882 1884 1888 1891 1894 1900 1903 1908
                                                                                  1913 1916 1916 1918 1927 1942* 1977 1983 1985
                                                                                  2029* 2029 2114 2146 2293 2319 2360 2367 2370 2478
                                                                                  2489 2550 2665 2674 2674 2710 2738 2741 2741 2796
                                                                                  2801 2802 2810 2816 2822 2830 2901* 2952* 2952
                                                                                  2955* 2955 3023 3139 3145 3145 3154 3182* 3468
                                                                                  3468 3734 3743 3743 3743 3743 3781* 4031* 4031
                                                                                  4057* 4080* 4103* 4122* 4122 4156* 4163* 4170*
                                                                                  4418 4446 4459 4612 4617 4619 4746 4805 4810 4820
                                                                                  4830 4837 4846 4847 4856 4863 4874 5214 5214 5220
                                                                                  5220 4-250 4-257 4-264 4-288 4-290
subsw                           001602 automatic       bit(1)                   packed unaligned dcl 5543 set ref 1721* 1726* 1728*
                                                                                  1750 2979*
suffix_info                            based           structure                level 1 dcl 2-12
superfile                       000406 constant        char(196)                initial packed unaligned dcl 3272 ref 1243 1243 1244
suppress_name_sw          1(01) 002136 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
suppress_spacing          1(04) 002136 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 16-7*
sv                                     based           structure                level 1 unaligned dcl 13-4
svlen                           001603 automatic       fixed bin(21,0)          dcl 5544 set ref 776* 823* 826 884 897 899 906* 913
                                                                                  914* 914 1098
svpath                          001604 automatic       char(204)                packed unaligned dcl 5545 set ref 257* 884* 888 891
                                                                                  892 897 898* 898 902 909 913* 913 916* 920
switches                  1     002136 automatic       structure                level 2 dcl 16-7
swname                          000351 constant        char(5)                  initial array packed unaligned dcl 5442 ref 5424
                                                                                  5425 5435 5435
sws                     234(09)        based           structure                level 3 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_"
sws                      74(09) 001746 automatic       structure                level 2 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_"
sws                       4     000230 external static structure                level 2 in structure "tedcommon_$etc" unaligned
                                                                                  dcl 10-11 in procedure "ted_" set ref 5421 5427
                                                                                  5431
sws                     234(09)        based           structure                level 3 in structure "gb" packed packed unaligned
                                                                                  dcl 4960 in procedure "gv_compile"
sws                     275            based           structure                level 2 in structure "dbase" packed packed unaligned
                                                                                  dcl 11-31 in procedure "ted_"
symbol                    4     003400 automatic       fixed bin(17,0)          array level 2 dcl 4-206 set ref 4-89 4-273* 4-282*
                                                                                  4-314*
symlen                    2     003400 automatic       fixed bin(17,0)          array level 2 dcl 4-206 set ref 4-245 4-250 4-271*
                                                                                  4-316*
symptr                          003400 automatic       pointer                  array level 2 dcl 4-206 set ref 4-250 4-270* 4-315*
sys_info$max_seg_size           000070 external static fixed bin(35,0)          dcl 5546 ref 206
t                               004617 automatic       fixed bin(17,0)          dcl 4-235 in procedure "ted_gv_p_" set ref 4-161*
                                                                                  4-162*
t                         3            based           fixed bin(17,0)          level 2 in structure "cft" dcl 3-42 in procedure
                                                                                  "ted_" set ref 5020 5026 4-272*
tbi                             001667 automatic       fixed bin(17,0)          dcl 5547 set ref 750* 760* 760 762 769 1327* 1328*
tbp                             003214 automatic       pointer                  dcl 3493 in procedure "buffer_buffer_copy" set ref
                                                                                  3581* 3585* 3590 3596* 3600* 3605* 3610
tbp                             003320 automatic       pointer                  dcl 4932 in begin block on line 4598 set ref 4700*
                                                                                  4702 4704 4709
tbp                             003324 automatic       pointer                  dcl 4896 in begin block on line 4895 set ref 4898*
                                                                                  4906
tbp                             001670 automatic       pointer                  dcl 5548 in procedure "ted_" set ref 689* 691 1140*
                                                                                  1143 1145 1148 1153 1153 1154 1154 1158* 1408*
                                                                                  1414* 1421 1421 1428* 2164* 2167* 2170 2175 2178
                                                                                  2181 2183 2189 3244* 3246 3253* 3254* 3255* 5102*
                                                                                  5103 5103 5104* 5151* 5156* 5162*
tc                              001672 automatic       char(1)                  packed unaligned dcl 5549 set ref 2706* 2708 2716
                                                                                  2717 2725
tdone_op                               constant        fixed bin(17,0)          initial dcl 3-3 ref 4-27
ted_com_l                14            based           fixed bin(21,0)          level 2 dcl 7-13 set ref 293 295* 297
ted_com_p                12            based           pointer                  level 2 dcl 7-13 set ref 295*
ted_data                               based           structure                level 1 unaligned dcl 7-13
ted_data_p                      000100 automatic       pointer                  dcl 104 set ref 106* 107 109 111 113 114 148 149 150
                                                                                  154* 167 195 195 195 218 293 295 295 297 1352 1378
                                                                                  1378 1384 1384 1384 1390 1390 1390 1395 1405 1407
                                                                                  1408 1413 1414
ted_data_version_1                     constant        fixed bin(17,0)          initial dcl 7-11 ref 107
ted_fo_err                      000000 stack reference condition                dcl 5550 ref 2909 2915
ted_gv_t_$DPDA                  000342 external static structure                level 1 unaligned dcl 6-13
ted_gv_t_$TC                    000340 external static structure                level 1 unaligned dcl 6-9
ted_gv_t_$TL                    000336 external static structure                level 1 unaligned dcl 6-4
ted_mode                        001673 automatic       fixed bin(17,0)          dcl 5551 in procedure "ted_" set ref 114* 137 212
                                                                                  216* 436 549 837 855 2343 3305
ted_mode                 15            based           fixed bin(17,0)          level 2 in structure "ted_data" dcl 7-13
                                                                                  in procedure "ted_" ref 114
ted_safe                        001674 automatic       bit(1)                   dcl 5552 set ref 166* 1217* 1325 1530* 1544* 1644*
                                                                                  2088* 3102* 3253* 3590* 3610* 3933* 3937* 5231*
                                                                                  5233*
ted_sup                         002610 automatic       structure                level 1 unaligned dcl 2119 set ref 2058 2058
ted_support                            based           structure                level 1 unaligned dcl 8-7
ted_support_version_1                  constant        fixed bin(17,0)          initial dcl 2065 ref 2063 2067
ted_support_version_2                  constant        fixed bin(17,0)          initial dcl 8-6 ref 2001 2060
ted_vers                        000222 external static varying char(12)         level 2 dcl 10-5 set ref 1782*
tedaddr_                        000236 constant        entry                    external dcl 5645 ref 418
tedcall_                        000240 constant        entry                    external dcl 5660 ref 671
tedcheck_buffer_state_          000244 constant        entry                    external dcl 5673 ref 362
tedcheck_buffers_               000246 constant        entry                    external dcl 5680 ref 1354 2392
tedcheck_entryname_             000250 constant        entry                    external dcl 5685 ref 988
tedcleanup_                     000072 constant        entry                    external dcl 5553 ref 271
tedcommon_$etc                  000230 external static structure                level 1 unaligned dcl 10-11
tedcommon_$id                   000222 external static structure                level 1 unaligned dcl 10-5
tedcommon_$no_data              000224 external static structure                level 1 unaligned dcl 10-8 ref 1185 2613 3818 3819
                                                                                  3820 4211 4279 4322 4376 4377 4385 5293
tedcommon_$no_seg               000226 external static structure                level 1 unaligned dcl 10-9 ref 3991 4375
tedcount_lines_                 000242 constant        entry                    external dcl 5665 ref 2016 2414 2532
tedend_buffer_                  000252 constant        entry                    external dcl 5686 ref 438 1752 2751
tederror_                       000232 constant        entry                    external dcl 14-3 ref 441 532 903
tederror_rc_                    000234 constant        entry                    external dcl 14-4 ref 510 1001 1069 1071 1150 1174
                                                                                  3550
tederror_table_$Copy_Set        000202 external static fixed bin(35,0)          dcl 8-126 ref 2069 2079
tederror_table_$Error_Msg       000210 external static fixed bin(35,0)          dcl 8-126 ref 2075 2112
tederror_table_$NoChange        000204 external static fixed bin(35,0)          dcl 8-126 ref 2071 2093 2104 2106
tederror_table_$Set             000206 external static fixed bin(35,0)          dcl 8-126 ref 2073 2089 2099
tederror_table_$ted_com_abort   000200 external static fixed bin(35,0)          dcl 7-48 ref 551
tederror_table_$zero_length_buffer
                                000074 external static fixed bin(35,0)          dcl 5554 set ref 1150* 3550
tedeval_                        000254 constant        entry                    external dcl 5691 ref 2841 3069 5013 5170
tedfree_segment_                000256 constant        entry                    external dcl 5707 ref 1632 1633 1636 1647 2097 3039
                                                                                  4175
tedget_buffer_                  000262 constant        entry                    external dcl 5721 ref 171 2167 2239 2455 2892 4700
                                                                                  5313
tedget_existing_buffer_         000260 constant        entry                    external dcl 5712 ref 1140 2164
tedget_segment_                 000264 constant        entry                    external dcl 5731 ref 1617 2027 3096 4052 4075 4098
                                                                                  4115
tedglobal_$do_global            000326 constant        entry                    external dcl 2049 ref 2047
tedglobal_$proc_expr            000324 constant        entry                    external dcl 2048 ref 2046
tedhelp_                        000042 constant        entry                    external dcl 393 ref 392
tedhold_                        000266 constant        entry                    external dcl 5741 ref 1332
tedinit_                        000270 constant        entry                    external dcl 5742 ref 154
tedlist_buffers_                000272 constant        entry                    external dcl 5748 ref 2389
tedname                                based           varying char(32)         level 2 dcl 7-13 set ref 109* 113
tedpseudo_                      000274 constant        entry                    external dcl 5756 ref 195 295 1189 5039
tedread_ptr_                    000276 constant        entry                    external dcl 5764 ref 346 1558 1968
tedresetread_                   000300 constant        entry                    external dcl 5773 ref 547
tedset_ck_ptr_                  000302 constant        entry                    external dcl 5774 ref 336 1948
tedset_ptr_                     000304 constant        entry                    external dcl 5775 ref 543 2741 5180
tedshow_                        000306 constant        entry                    external dcl 5781 ref 298 1591 1916 2213 2559 3012
                                                                                  3044 3537 3540 3541 3561 3614 3708 3790 3803 3815
                                                                                  3884 3895 3940 3951 3969 4150 4344 4407 4468 4506
                                                                                  4563 4954 4975 5002 5299 4-31
tedshow_$init                   000310 constant        entry                    external dcl 5782 ref 601
tedsort_                        000312 constant        entry                    external dcl 5783 ref 1628
tedsort_$set                    000316 constant        entry                    external dcl 5801 ref 1610
tedsort_$show                   000314 constant        entry                    external dcl 5797 ref 1605
tedsrch_$compile                000216 constant        entry                    external dcl 9-7 ref 1711 1740 1771 2500 4718 4-298
tedsrch_$init_exp               000214 constant        entry                    external dcl 9-3 ref 176
tedsrch_$search                 000220 constant        entry                    external dcl 9-17 ref 1714 2570 2941 2973 5023
temp                            004632 automatic       varying char(100)        dcl 4-241 in procedure "geterm" set ref 4-244*
                                                                                  4-249* 4-249 4-250* 4-250 4-252* 4-252 4-253
                                                                                  4-255* 4-257* 4-258 4-262* 4-264* 4-265* 4-265
temp                     74            based           structure                array level 2 in structure "b" unaligned dcl 12-67
                                                                                  in procedure "ted_" ref 4218
temp_p                          003136 automatic       pointer                  dcl 3001 set ref 3096* 3097 3099
temp_sn                         003140 automatic       fixed bin(17,0)          dcl 3002 set ref 3009* 3039 3039* 3088 3096*
terminate               234(12)        based           bit(1)                   level 4 packed packed unaligned dcl 12-67 set ref
                                                                                  1190* 4282 4288* 4358 4363*
terminate_file_                 000120 constant        entry                    external dcl 5582 ref 1107
test                    122            based           structure                level 2 unaligned dcl 12-67
test_symbol                     004603 automatic       fixed bin(17,0)          dcl 4-220 set ref 4-89* 4-93 4-113* 4-116*
teval_op                               constant        fixed bin(17,0)          initial dcl 3-3 ref 4-287
the_line_no                     002660 automatic       structure                level 1 packed packed unaligned dcl 2508 set ref
                                                                                  2585 2585
tl                              003217 automatic       fixed bin(21,0)          dcl 3495 set ref 3578* 3586 3597
tot_len                   1            based           fixed bin(24,0)          level 3 dcl 3-15 set ref 1734* 4560* 4560 4567 4583*
                                                                                  4624 4629* 4635* 4641 4683 4695 4969 4-274 4-275
                                                                                  4-276 4940
total_chars_moved               000013 internal static fixed bin(30,0)          initial dcl 5390 set ref 5375* 5375 5380 5382 5386*
tp                              003264 automatic       pointer                  dcl 5129 set ref 5130* 5134*
tr                              003220 automatic       fixed bin(21,0)          dcl 3495 set ref 3577* 3582 3601
translate                                              builtin function         dcl 5241 ref 2952 2955
true                      5     003400 automatic       fixed bin(17,0)          array level 2 dcl 4-206 set ref 4-275* 4-317* 5-47*
                                                                                  5-59* 5-69* 5-80* 5-80* 5-81* 5-81 5-90* 5-93*
                                                                                  5-93 5-102* 5-103
trust_sw                 74(10) 001746 automatic       bit(1)                   level 3 in structure "fd" packed packed unaligned
                                                                                  dcl 5607 in procedure "ted_" set ref 835 845* 862*
                                                                                  868* 930* 939*
trust_sw                234(10)        based           bit(1)                   level 4 in structure "b" packed packed unaligned
                                                                                  dcl 12-67 in procedure "ted_" set ref 1101* 1102*
                                                                                  1169* 1511*
trustsw                         001675 automatic       bit(1)                   packed unaligned dcl 5555 set ref 721* 723* 753*
                                                                                  800* 802* 846* 868 928 996 1093 1101 1105 1166
tsrch_op                               constant        fixed bin(17,0)          initial dcl 3-3 ref 4-294
ttp                             001676 automatic       pointer                  dcl 5556 set ref 1227* 1234 1437* 1440* 1443* 1447*
                                                                                  1653* 1656* 1659* 1664* 5325* 5328* 5419* 5425
                                                                                  5431 5431
tv                              004750 automatic       fixed bin(21,0)          dcl 5050 set ref 5056* 5057 5062
type                      1(27) 003342 automatic       char(6)                  level 2 packed packed unaligned dcl 4-195 set ref
                                                                                  4-45* 4-57* 4-68* 4-110* 4-111* 4-111 4-148*
type_name                12     002206 automatic       char(32)                 level 2 packed packed unaligned dcl 607 set ref 959
                                                                                  962
uid                     141            based           bit(36)                  level 3 packed packed unaligned dcl 12-67 set ref
                                                                                  1182* 4373*
unique_id                11     002153 automatic       bit(36)                  level 2 packed packed unaligned dcl 18-1 set ref
                                                                                  1182
unspec                                                 builtin function         dcl 5241 set ref 220* 221* 4322 4322 4341 4341 4667*
                                                                                  4667
upper                                  parameter       bit(1)                   packed unaligned dcl 2938 ref 2936 2952
used                            001700 automatic       fixed bin(21,0)          dcl 5557 set ref 417* 418* 420 1139* 1140* 1142
                                                                                  2163* 2164* 2167* 2169 2238* 2239* 2241 2840*
                                                                                  2841* 2843 2891* 2892* 2893 4697* 4700* 4701
userid                          001735 automatic       char(32)                 level 2 in structure "delete_acl" dcl 5603
                                                                                  in procedure "ted_" set ref 1127*
userid                          001722 automatic       char(32)                 level 2 in structure "seg_acl" dcl 5597 in procedure
                                                                                  "ted_" set ref 1042* 1127
v1                        1     000342 external static fixed bin(17,0)          array level 3 packed packed unaligned dcl 6-13 set
                                                                                  ref 4-39 4-93 4-143 4-159* 4-161 4-169 4-171 4-176
                                                                                  4-181
v2                        1(18) 000342 external static fixed bin(17,0)          array level 3 packed packed unaligned dcl 6-13 set
                                                                                  ref 4-43 4-54 4-65 4-92 4-95 4-144 4-159* 4-170
                                                                                  4-173 4-178 4-180 4-183 4-187
val                                    parameter       fixed bin(21,0)          dcl 5048 set ref 5046 5052 5054* 5054 5057 5059*
                                                                                  5059 5062* 5062 5063* 5063 5064 5066 5068* 5068
                                                                                  5069* 5069 5070
verify                                                 builtin function         dcl 5241 ref 372 813 1343 1371 1977 2360 2830 4805
                                                                                  4810
version                         002610 automatic       fixed bin(17,0)          level 2 in structure "ted_sup" dcl 2119 in procedure
                                                                                  "do_req" set ref 2001* 2060 2063* 2067
version                  11            based           fixed bin(35,0)          level 2 in structure "ted_data" dcl 7-13
                                                                                  in procedure "ted_" set ref 107 111*
version                         002206 automatic       char(8)                  level 2 in structure "SI" packed packed unaligned
                                                                                  dcl 607 in procedure "do_req" set ref 942*
version                         002136 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 16-7
                                                                                  in procedure "ted_" set ref 207*
vgch                            001701 automatic       char(1)                  packed unaligned dcl 5558 set ref 4544 4610* 4655*
                                                                                  4656 4656 4659 4667* 4669 4672 4679* 4763* 4816*
vgds                            001702 automatic       varying char(2)          dcl 5559 set ref 4548 4610* 4655* 4661* 4661
wct                             001704 automatic       fixed bin(17,0)          dcl 5560 set ref 754* 764 1116* 1116 1117 1354* 1356
                                                                                  2392* 2393
what                                   parameter       structure                level 1 unaligned dcl 4318 ref 4317 4321
where                                  parameter       fixed bin(17,0)          dcl 5-29 in procedure "thread" ref 5-28 5-31
where                                  parameter       fixed bin(17,0)          dcl 5-14 in procedure "define" ref 5-12 5-19
which                                  parameter       fixed bin(17,0)          dcl 5-14 in procedure "define" set ref 5-12 5-22*
                                                                                  5-23
which                                  parameter       char                     packed unaligned dcl 4318 in procedure "adjust" set
                                                                                  ref 4317 4344*
which                           000100 automatic       char(1)                  packed unaligned dcl 3808 in procedure "delete" set
                                                                                  ref 3812* 3814* 3815*
which                                  parameter       fixed bin(17,0)          dcl 5-29 in procedure "thread" set ref 5-28 5-35*
                                                                                  5-36
which_mode                      001706 automatic       char(5)                  packed unaligned dcl 5561 set ref 249* 345* 346* 351
                                                                                  1516* 1519* 1556 1558* 1575 1577 1593
which_side                             parameter       bit(1)                   packed unaligned dcl 3673 ref 3669 3679
who                             003243 automatic       char(3)                  packed unaligned dcl 4538 set ref 4475* 4478* 4481*
                                                                                  4484* 4506*
word                      6            based           fixed bin(35,0)          array level 2 dcl 3-15 set ref 2981 3079 4568 4587
                                                                                  4900 4905 4984 5133 5138 5-21 5-23* 5-31 5-34
                                                                                  5-36*
write_l                         001710 automatic       fixed bin(21,0)          dcl 5562 set ref 725* 783* 803* 804* 804 1054 1062
                                                                                  1085 1085 1262* 1274 1283 1287* 1292 1294 1298
                                                                                  1300 1300 1403* 1407 1413 1421 1421
wsw                             001711 automatic       bit(1)                   packed unaligned dcl 5563 set ref 724* 807* 816 871
                                                                                  955 973 996 1022 1062 1079 1260
xfe                             001712 automatic       fixed bin(21,0)          dcl 5564 set ref 1254* 1255 1255* 1257 1258
xfi                             001713 automatic       fixed bin(21,0)          dcl 5565 set ref 1250* 1251 1254 1255 1257 1259
xsw                             001714 automatic       bit(1)                   packed unaligned dcl 5566 set ref 2434* 2438* 2574
yes_or_no_sw              1     002136 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 16-7 set
                                                                                  ref 208* 16-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DDop                                   internal static char(4)                  initial array packed unaligned dcl 4-201
DPDAp                                  automatic       pointer                  dcl 6-17
FS_OBJECT_TYPE_DIRECTORY               internal static char(32)                 initial packed unaligned dcl 2-50
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial packed unaligned dcl 2-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial packed unaligned dcl 2-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial packed unaligned dcl 2-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial packed unaligned dcl 2-50
NORMAL                                 internal static fixed bin(24,0)          initial dcl 11-3
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 2-48
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 17-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 17-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 17-16
TERM_FILE_TERM                         internal static bit(3)                   initial packed unaligned dcl 17-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 17-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 17-13
abx                                    internal static fixed bin(17,0)          initial dcl 15-42
all_des                                internal static fixed bin(17,0)          initial dcl 12-61
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 2-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 2-33
apx                                    internal static fixed bin(17,0)          initial dcl 15-42
bbx                                    internal static fixed bin(17,0)          initial dcl 15-42
bfb                                    based           fixed bin(17,0)          dcl 4-302
bpx                                    internal static fixed bin(17,0)          initial dcl 15-42
call_stk                               based           structure                level 1 unaligned dcl 13-21
dbase_vers_3                           internal static fixed bin(17,0)          initial dcl 11-30
directory_type                         internal static bit(2)                   initial dcl 18-1
fixed                                                  builtin function         dcl 4-193
ichr                                   based           char(1)                  array packed unaligned dcl 8-144
istr                                   based           char                     packed unaligned dcl 8-143
lbx                                    internal static fixed bin(17,0)          initial dcl 15-42
link_type                              internal static bit(2)                   initial dcl 18-1
live_des                               internal static fixed bin(17,0)          initial dcl 12-61
lpx                                    internal static fixed bin(17,0)          initial dcl 15-42
mc                                     based           structure                level 1 dcl 15-12
mcp                                    automatic       pointer                  dcl 15-10
msf_type                               internal static bit(2)                   initial dcl 18-1
n                                      automatic       fixed bin(17,0)          dcl 4-229
ochr                                   based           char(1)                  array packed unaligned dcl 8-146
ostr                                   based           char                     packed unaligned dcl 8-145
pstr                                   based           char(256)                packed unaligned dcl 13-19
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 16-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 16-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 16-36
rc_close                               internal static fixed bin(24,0)          initial dcl 11-8
rc_fail                                internal static fixed bin(24,0)          initial dcl 11-9
rc_keyerr                              internal static fixed bin(24,0)          initial dcl 11-11
rc_nop                                 internal static fixed bin(24,0)          initial dcl 11-10
rchr                                   based           char(1)                  array packed unaligned dcl 8-148
recov_msg                              automatic       varying char(150)        dcl 4-233
rstr                                   based           char                     packed unaligned dcl 8-147
sbx                                    internal static fixed bin(17,0)          initial dcl 15-42
scu                                    based           structure                level 1 dcl 15-56
scup                                   automatic       pointer                  dcl 15-54
scux                                   based           structure                level 1 dcl 15-207
segment_type                           internal static bit(2)                   initial dcl 18-1
spx                                    internal static fixed bin(17,0)          initial dcl 15-42
suffix_info_ptr                        automatic       pointer                  dcl 2-10
sv_p                                   automatic       pointer                  dcl 13-3
switch_list                            based           structure                level 1 dcl 2-37
switch_list_ptr                        automatic       pointer                  dcl 2-33
ted_                            000000 constant        entry                    external dcl 7-8
ted_support_p                          automatic       pointer                  dcl 8-5
tederror_table_$No_Delim1              external static fixed bin(35,0)          dcl 8-126
tederror_table_$No_Delim2              external static fixed bin(35,0)          dcl 8-126
tederror_table_$No_Delim3              external static fixed bin(35,0)          dcl 8-126
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 17-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CASE                            000255 constant        label                    array(0:10) dcl 4-43 ref 4-39
NEXT                            041372 constant        label                    dcl 4-21 ref 4-137 4-174 4-184 4-188
PRINTb                          023635 constant        label                    dcl 2631 set ref 1456
TRY_AGAIN                       041463 constant        label                    dcl 4-39
Uu_loop                         026076 constant        label                    dcl 2941 ref 2958
X_status                        021654 constant        label                    dcl 2355 ref 2375
abbrev                          025646 constant        entry                    internal dcl 677 ref 706 710 734 736
accept_name                     010334 constant        label                    dcl 859 ref 848
aci_com                         044347 constant        label                    dcl 5126 ref 5119
act                             006066 constant        entry                    external dcl 5303
add_2l                          032120 constant        entry                    internal dcl 3655 ref 1530 1544 1644 2088 3102 3253
                                                                                  5126 5231 5233 5326 5328
add_2r                          032135 constant        entry                    internal dcl 3662 ref 1217
add_length                      043434 constant        entry                    internal dcl 4935 ref 4727 4736 4745 4836 4855 4873
                                                                                  4-289 4-304
add_rep                         027273 constant        entry                    internal dcl 3080 ref 3048 3055 3065 3074
add_request                     005143 constant        label                    dcl 516 ref 448 452 456 460 464 468 472 476 480 484
                                                                                  488 492 496 500 504 508 1640 2247 2268 2275 3331
                                                                                  3351 4555 4943 4972
addr_status                     031117 constant        entry                    internal dcl 3439 ref 3191 3828
addr_status_ends                031032 constant        entry                    internal dcl 3413 ref 799 3565 3805
addr_status_ends_set            031014 constant        entry                    internal dcl 3409 ref 1379 1400
adjust                          036625 constant        entry                    internal dcl 4317 ref 4249 4261 4267
bad_path                        010661 constant        label                    dcl 920 ref 990
blank                           006265 constant        entry                    external dcl 5332
bs_c                            030773 constant        label                    dcl 3382 ref 3378
buffer_buffer_copy              031321 constant        entry                    internal dcl 3480 ref 1158 2305 5104
call_again                      020210 constant        label                    dcl 2058 ref 2064
ck_blank                        030552 constant        entry                    internal dcl 3303 ref 680 713 747 1444 1453 1462
                                                                                  1475 1492 1504 1602 1663 1709 1739 1767 1938 1987
                                                                                  2152 2172 2253 2388 2399 2517 2628 2651 2673 2679
                                                                                  2734 2768 2896
ckpt                            026024 constant        entry                    internal dcl 1958 ref 2044
clean__up                       035774 constant        label                    dcl 4209 ref 4219 4309 4316 4378 4386
cleaner                         007067 constant        entry                    internal dcl 261 ref 260 553 1432
clear_chars_moved               006353 constant        entry                    external dcl 5360
close_up_file                   012220 constant        label                    dcl 1102 ref 1312
cm_err                          004732 constant        label                    dcl 436 ref 427
cmd                             000000 constant        label                    array(33:126) dcl 623 ref 602 1320 1681 1703
com                             000227 constant        label                    array(22) dcl 4692 set ref 4691
comdone                         041245 constant        label                    dcl 4887 set ref 4711 4735 4793 4840 4859 4877 4880
comdone_NL                      041242 constant        label                    dcl 4885 ref 4741 4748
comment                         024335 constant        label                    dcl 2757
common                          043502 constant        label                    dcl 4967 in procedure "gv_compile"
common                          030661 constant        label                    dcl 3354 in procedure "ignore_1" ref 3320 3334
common                          034273 constant        label                    dcl 3991 in procedure "promote" ref 3963
compiled                        041252 constant        label                    dcl 4891 ref 4675
cpy_2                           032152 constant        entry                    internal dcl 3669 ref 3590 3610
dbf                             006630 constant        entry                    external dcl 5414
dbn                             006614 constant        entry                    external dcl 5408
default$cur_line                037357 constant        entry                    internal dcl 4480 ref 1455 1494 1710 1731 1768 1996
                                                                                  2231 2402 2630 2647 2657 2775
default$cur_line_extend         037347 constant        entry                    internal dcl 4477 ref 1464 1479 1508
default$line_eval               037336 constant        entry                    internal dcl 4474 ref 2809 2838
default$whole_buffer            037367 constant        entry                    internal dcl 4483 ref 798 1613 2250 2442
define                          043237 constant        entry                    internal dcl 5-12 ref 5-47 5-49 5-59 5-62 5-78 5-90
delete                          033115 constant        entry                    internal dcl 3797 ref 1465 1495 2086 2184 2347 2594
                                                                                  5111 5118
delete$all                      033177 constant        entry                    internal dcl 3811 ref 1581 2299 2615 3252 4903 5287
                                                                                  5321
demote                          036470 constant        entry                    internal dcl 4352 ref 363 3817
detach                          027607 constant        entry                    internal dcl 3212 ref 268 320
do_call                         017641 constant        label                    dcl 1997 ref 1997 1997 2648 2658 2814 2820 2826
do_move                         035303 constant        label                    dcl 4133 ref 4024
do_req                          007306 constant        entry                    internal dcl 592 ref 580
do_tabout                       023654 constant        label                    dcl 2643 ref 2475
done_parse                      041374 constant        label                    dcl 4-24 ref 5-52 5-63
end_cf                          037571 constant        entry                    internal dcl 4556 ref 1737 3123 3177 4689 4731 4887
                                                                                  4894 4-26 4-30 4-307
end_pr                          027604 constant        label                    dcl 3205 ref 3189
end_rep                         026741 constant        label                    dcl 3077 ref 3050 3057 3067
eof_err                         004725 constant        label                    dcl 433 set ref 351 1593
err_Blv                         004770 constant        label                    dcl 450 set ref 2141
err_Bnd                         004776 constant        label                    dcl 454 ref 2175 2178
err_Bnr                         005004 constant        label                    dcl 458 ref 2150
err_Sbd                         005012 constant        label                    dcl 462 ref 2721
err_Sd1                         005020 constant        label                    dcl 466 ref 2443 2643 3363
err_Sd2                         005026 constant        label                    dcl 470 ref 3391
err_Sd3                         005034 constant        label                    dcl 474 ref 3168
err_Sje                         005042 constant        label                    dcl 478
err_Sjk                         005050 constant        label                    dcl 482
err_Slx                         005056 constant        label                    dcl 486 ref 2668 2713
err_Smp                         005064 constant        label                    dcl 490 ref 2368 2666 2711
err_Snb                         005072 constant        label                    dcl 494 ref 3305
err_Sne                         005100 constant        label                    dcl 498 ref 3152
err_Snf                         005114 constant        label                    dcl 506 ref 1980
err_Sts                         005106 constant        label                    dcl 502
eval_err                        024671 constant        label                    dcl 2846
exit                            005540 constant        label                    dcl 584 ref 1333 1433
file_ready                      012076 constant        label                    dcl 1079 ref 1236 1304
find_archive_element            013010 constant        label                    dcl 1227 ref 1057
find_subfile                    013063 constant        label                    dcl 1237 ref 1059
finis                           031206 constant        label                    dcl 3468 in procedure "addr_status_ends_set" ref
                                                                                  3428 3443 3456 3461
finis                           033757 constant        label                    dcl 3940 in procedure "openup" ref 3910 3914 3927
fix_addr                        045054 constant        entry                    internal dcl 5046 ref 4991 4991
fo_err                          025012 constant        label                    dcl 2871 ref 2886
free_buffer                     035426 constant        entry                    internal dcl 4153 ref 4301 4369
gb3                             023017 constant        label                    dcl 2518 ref 2636
gb_end                          023517 constant        label                    dcl 2599 ref 2567 2609
gb_loop                         023206 constant        label                    dcl 2547 ref 2603
gb_p1                           023364 constant        label                    dcl 2583 ref 2562 2577
gb_p2                           023416 constant        label                    dcl 2586 ref 2580
gb_quit                         023535 constant        label                    dcl 2611 ref 2533 2589
get_err                         011351 constant        label                    dcl 996 ref 957 973 1019 1050 1111 1133
get_file                        010107 constant        label                    dcl 810 ref 726
get_ready                       041263 constant        label                    dcl 4895 ref 4615
get_rest                        042354 constant        label                    dcl 4-245 ref 4-266
get_the_string                  007022 constant        entry                    internal dcl 193 ref 218 730
geterm                          042351 constant        entry                    internal dcl 4-238 ref 4-113
getermc                         042466 constant        entry                    internal dcl 4-260 ref 4-116
getreq                          026033 constant        entry                    internal dcl 1966 ref 2045
got_add                         005441 constant        label                    dcl 560 ref 414 429
got_symbol                      041674 constant        label                    dcl 4-103 ref 4-96
gv_1addr                        041317 constant        label                    dcl 4910
gv_adrnum                       040703 constant        label                    dcl 4811 ref 4806
gv_blank                        041341 constant        label                    dcl 4919 set ref 4841
gv_compile                      037746 constant        entry                    internal dcl 4596 ref 2462
gv_dump                         043460 constant        entry                    internal dcl 4953 ref 1911
gv_msg_com                      005543 constant        label                    dcl 4544 ref 3143 4622 4647 4680 4707 4764 4817 4834
                                                                                  4852 4867 4912 4915 4918 4921 4925 4-101
gv_nosrch                       041333 constant        label                    dcl 4916 ref 4776
gv_srch                         043501 constant        entry                    internal dcl 4958 ref 2566
gv_tT                           044466 constant        label                    dcl 5159 ref 5154
gv_wrap                         041325 constant        label                    dcl 4913
if                              015704 constant        label                    dcl 1706
if_line                         024362 constant        label                    dcl 2768
if_line_f                       024414 constant        label                    dcl 2788 ref 2771 2778 2780
if_line_t                       024425 constant        label                    dcl 2790 ref 2773 2782 2785
ignore_1                        030573 constant        entry                    internal dcl 3312 ref 2401
ignore_2                        030606 constant        entry                    internal dcl 3322 ref 719 1481 1509 2697 2761
ignore_all                      030627 constant        entry                    internal dcl 3336 ref 751 1446 1660 2124 2703 2890
ignore_both                     030641 constant        entry                    internal dcl 3343 ref 669 1941 2386
in_mode                         014452 constant        label                    dcl 1511 ref 1483 1497
init_cfp                        037655 constant        entry                    internal dcl 4574 ref 1733 1746 4597 4967
input_finish                    015032 constant        label                    dcl 1586 ref 1540
input_over                      015016 constant        label                    dcl 1581 ref 1575
input_pi                        014740 constant        label                    dcl 1564 ref 1552
inv_opt                         017344 constant        label                    dcl 1925 ref 1886
inv_req                         040210 constant        label                    dcl 4677 ref 4656 4663
invalid_request                 007404 constant        label                    dcl 623 set ref 598 1675 1684 1692 2493
invalid_request_octal           007350 constant        label                    dcl 614 ref 597
iso_line                        036770 constant        entry                    internal dcl 4392 ref 1164 1195 1221 1458 1466 1590
                                                                                  1646 2103 2185 2350 2403 2619 2698 2763 2963 2987
                                                                                  5112
kill_execute                    017507 constant        label                    dcl 1950 ref 1946
kill_read_ptr                   004276 constant        label                    dcl 342 ref 342
lgf                             006601 constant        entry                    external dcl 5403
lgn                             006565 constant        entry                    external dcl 5398
line_feed                       014267 constant        label                    dcl 1444 ref 1439
lnf                             006552 constant        entry                    external dcl 5395
lnn                             006537 constant        entry                    external dcl 5394
make_consistent                 035727 constant        entry                    internal dcl 4197 ref 165
make_one                        011267 constant        label                    dcl 988 ref 955
make_rp                         027370 constant        entry                    internal dcl 3170 ref 3118 3145 3156 3159 3163 3166
misplaced                       040536 constant        label                    dcl 4759 ref 4773 4780 4799
mo3                             021114 constant        label                    dcl 2232 ref 816
mov_2l                          032071 constant        entry                    internal dcl 3622 ref 3933
mov_2r                          032104 constant        entry                    internal dcl 3648 ref 3937
msg_path                        030317 constant        entry                    internal dcl 3286 ref 852 881 963 981 1000 1067 1173
new_cur                         036436 constant        entry                    internal dcl 4310 ref 5298
new_dot                         036603 constant        entry                    internal dcl 4381 ref 4467
next                            004410 constant        label                    dcl 358 in procedure "ted_" ref 305 582
next                            036036 constant        label                    dcl 4241 in procedure "make_consistent" ref 4249
                                                                                  4253
no_2nd_delim                    041347 constant        label                    dcl 4922
no_ac_write                     011203 constant        label                    dcl 977 ref 1024
no_move                         035340 constant        label                    dcl 4141 ref 4038 4060 4083 4106
no_sva0                         036271 constant        label                    dcl 4271 ref 4267
no_svex                         036220 constant        label                    dcl 4265 set ref 4261
noblank                         006302 constant        entry                    external dcl 5339
nochange                        020372 constant        label                    dcl 2093 ref 2055
not_2                           030616 constant        label                    dcl 3329 ref 3317
not_allowed                     004762 constant        label                    dcl 446 ref 728 781 820 2181
nullrq                          024016 constant        label                    dcl 2679
nx_line                         004201 constant        label                    dcl 313 set ref 246 370 374 394 444 544 558 568 580
                                                                                  5197
nx_read                         004224 constant        label                    dcl 322 ref 318
openup                          033520 constant        entry                    internal dcl 3893 ref 1216 1514 1626 2014 2193 2324
                                                                                  3007 3557 3848 3872 4424 5125 5228
partblank                       006316 constant        entry                    external dcl 5346
passthru                        006333 constant        entry                    external dcl 5353
print                           027451 constant        entry                    internal dcl 3187 ref 1457 5088
print_error                     005230 constant        label                    dcl 525 ref 421 425 620 666 694 792 833 855 882 966
                                                                                  1336 1716 1743 1758 1929 2116 2465 2572 2807 2846
                                                                                  2875 2961 3072 3477 3900 3961 4004 4511 4516 4521
                                                                                  4526 4531 5016 5028 5172 4-78 4-130 4-300
print_error_rc                  005122 constant        label                    dcl 510 ref 922 1999 2118 2849 4723
promote                         034010 constant        entry                    internal dcl 3949 ref 1026 1550 1577 1769 3732 3827
                                                                                  3902 5257
promote$seg                     034173 constant        entry                    internal dcl 3966 ref 1329 2135 5269
re_com                          040221 constant        label                    dcl 4683
read_buffer                     012372 constant        label                    dcl 1137 ref 818
read_file                       012544 constant        label                    dcl 1166 ref 1079 1266
read_look                       041612 constant        label                    dcl 4-83 ref 4-52 4-63
ref_label                       024112 constant        label                    dcl 2703
rel_go                          024156 constant        label                    dcl 2719 ref 2716
rel_svex                        036147 constant        label                    dcl 4259 set ref 4275
relocate                        036020 constant        entry                    internal dcl 4230 ref 3789 4141
replace                         026310 constant        entry                    internal dcl 2990 ref 2982
replace$compile                 026752 constant        entry                    internal dcl 3108 ref 1735 4732
repop                           000136 constant        label                    array(-4:-1) dcl 3048 ref 3014
reprotect                       025747 constant        entry                    internal dcl 1124 ref 1073 1113
rq_err                          005323 constant        label                    dcl 535 ref 288 442 512 672 904 986 1004 1076 1151
                                                                                  1650 2746 5181
rq_err_msg                      005305 constant        label                    dcl 532 ref 173 1143 2170 2242 2894 4702
rtn                             000142 constant        label                    array(-2:20) dcl 4209 ref 4207
rule                            000270 constant        label                    array(3:13) dcl 5-43 ref 5-10
rule_0                          042750 constant        entry                    internal dcl 4-309 ref 4-18
scan                            030706 constant        entry                    internal dcl 3358 ref 1600 1662 1706 1732 1763 2499
                                                                                  4712 4742 4-295
scan_req_line                   014516 constant        label                    dcl 1523 ref 1546
scanner                         042526 constant        entry                    internal dcl 4-268 ref 4-85
sem                             043002 constant        entry                    internal dcl 5-5 ref 4-154
set_db                          006641 constant        label                    dcl 5419 ref 5401 5406 5413
show_again                      006401 constant        label                    dcl 5367
show_chars_moved                006373 constant        entry                    external dcl 5365
show_stk                        043365 constant        entry                    internal dcl 5-65 ref 5-43 5-56 5-75 5-87
srch                            000171 constant        label                    array(-7:22) dcl 5007 ref 5005 5187
srch_mod                        044753 constant        label                    dcl 5224 ref 5210 5214 5220
srchdone                        044666 constant        label                    dcl 5201 ref 5034 5140
srchdone_inc                    044662 constant        label                    dcl 5199 set ref 5011 5045 5076 5081 5082 5091 5094
                                                                                  5105 5108 5113 5115 5122 5128 5141 5145 5146 5150
                                                                                  5159 5163 5165 5176 5177
start                           032206 constant        label                    dcl 3687 ref 3646 3653 3660 3667
start_cf                        037633 constant        entry                    internal dcl 4566 ref 4630
status                          022020 constant        label                    dcl 2386 ref 2374
sub1                            031004 constant        label                    dcl 3393 ref 3372
sub_loop                        026224 constant        label                    dcl 2973 ref 2983
substitute                      026217 constant        entry                    internal dcl 2966 ref 1747 5134
syntax_error                    005136 constant        label                    dcl 514 ref 1339 1344 1365 1372
ted_                            003167 constant        entry                    external dcl 96
ted__                           003200 constant        entry                    external dcl 96
ted_gv_p_                       041361 constant        entry                    internal dcl 4-8 ref 4640
tedcloseup_                     005664 constant        entry                    external dcl 5261
tedgv_                          037752 constant        label                    dcl 4598
tedpromote_                     005633 constant        entry                    external dcl 5248
tedpseudo_                      005713 constant        entry                    external dcl 5274
testdone                        044106 constant        label                    dcl 5031 ref 5021
thread                          043314 constant        entry                    internal dcl 5-28 ref 5-80 5-92
type                            015455 constant        label                    dcl 1660 ref 1655
update                          036362 constant        entry                    internal dcl 4293 ref 3787 3882
upper_lower                     026074 constant        entry                    internal dcl 2936 ref 1774 5144 5149
work                            037375 constant        label                    dcl 4486 ref 4475 4478 4481
write_loop                      007676 constant        label                    dcl 760 ref 757 770 772 830 871 1002 1038 1074 1121
                                                                                  1175 1223
write_loop_error                007637 constant        label                    dcl 758 ref 853 964 982
write_loop_pi                   007704 constant        label                    dcl 764 ref 755
x_not_found                     012005 constant        label                    dcl 1065 ref 1232

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     51144       51516   47254       51154
Length     53150   47254       352        1415    1670          32

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ted_                               3641 external procedure  is an external procedure.  
get_the_string                          internal procedure  shares stack frame of external procedure ted_.  
on unit on line 228                  88 on unit               
on unit on line 260                  64 on unit               
cleaner                              86 internal procedure  is called by several nonquick procedures.  
on unit on line 334                  68 on unit               
do_req                                  internal procedure  shares stack frame of external procedure ted_.  
abbrev                                  internal procedure  shares stack frame of external procedure ted_.  
begin block on line 681                 begin block         shares stack frame of external procedure ted_.  
reprotect                               internal procedure  shares stack frame of external procedure ted_.  
ckpt                                 64 internal procedure  is assigned to an entry variable.  
getreq                               82 internal procedure  is assigned to an entry variable.  
begin block on line 2899            119 begin block         enables or reverts conditions.  
on unit on line 2903                 64 on unit               
upper_lower                             internal procedure  shares stack frame of external procedure ted_.  
substitute                              internal procedure  shares stack frame of external procedure ted_.  
replace                                 internal procedure  shares stack frame of external procedure ted_.  
begin block on line 3059             84 begin block         uses auto adjustable storage.  
add_rep                              86 internal procedure  is called by several nonquick procedures.  
make_rp                              65 internal procedure  is called during a stack extension.  
print                                   internal procedure  shares stack frame of external procedure ted_.  
detach                              110 internal procedure  is called by several nonquick procedures.  
begin block on line 3217            108 begin block         enables or reverts conditions.  
on unit on line 3219                 64 on unit               
msg_path                             69 internal procedure  is called during a stack extension.  
ck_blank                                internal procedure  shares stack frame of external procedure ted_.  
ignore_1                                internal procedure  shares stack frame of external procedure ted_.  
scan                                    internal procedure  shares stack frame of external procedure ted_.  
addr_status_ends_set                118 internal procedure  is called by several nonquick procedures.  
buffer_buffer_copy                      internal procedure  shares stack frame of external procedure ted_.  
mov_2l                              168 internal procedure  is called by several nonquick procedures.  
delete                              100 internal procedure  is called by several nonquick procedures.  
openup                              105 internal procedure  is called by several nonquick procedures.  
promote                             154 internal procedure  is called by several nonquick procedures.  
make_consistent                     132 internal procedure  is called by several nonquick procedures.  
adjust                                  internal procedure  shares stack frame of internal procedure make_consistent.  
iso_line                                internal procedure  shares stack frame of external procedure ted_.  
default$line_eval                       internal procedure  shares stack frame of external procedure ted_.  
end_cf                               76 internal procedure  is called by several nonquick procedures.  
init_cfp                                internal procedure  shares stack frame of external procedure ted_.  
gv_compile                              internal procedure  shares stack frame of external procedure ted_.  
begin block on line 4598                begin block         shares stack frame of external procedure ted_.  
begin block on line 4895                begin block         shares stack frame of external procedure ted_.  
ted_gv_p_                               internal procedure  shares stack frame of external procedure ted_.  
geterm                                  internal procedure  shares stack frame of external procedure ted_.  
scanner                                 internal procedure  shares stack frame of external procedure ted_.  
rule_0                                  internal procedure  shares stack frame of external procedure ted_.  
sem                                     internal procedure  shares stack frame of external procedure ted_.  
define                                  internal procedure  shares stack frame of external procedure ted_.  
thread                                  internal procedure  shares stack frame of external procedure ted_.  
show_stk                                internal procedure  shares stack frame of external procedure ted_.  
add_length                              internal procedure  shares stack frame of external procedure ted_.  
fix_addr                                internal procedure  shares stack frame of external procedure ted_.  
begin block on line 5433                begin block         shares stack frame of external procedure ted_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 act_name                    ted_
000012 chars_moved                 ted_
000013 total_chars_moved           ted_
000014 ln_sw                       ted_
000015 NLct_check                  ted_
000016 NLct_unknown                ted_
000017 pdname                      ted_
000027 pi_passthru                 ted_
000030 NL                          ted_
000031 bd_name                     make_consistent
000040 ln_                         gv_compile

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
add_rep                  000100 space                       add_rep
begin block on line 3059 000100 str                         begin block on line 3059
delete                   000100 which                       delete
detach                   000100 old_bp                      detach
mov_2l                   000100 add_right                   mov_2l
                         000101 make_room                   mov_2l
                         000102 adj                         mov_2l
                         000103 id                          mov_2l
                         000104 astr_p                      mov_2l
                         000106 hole                        mov_2l
openup                   000106 action                      openup
                         000110 len                         openup
                         000111 at                          openup
promote                  000100 seg_sw                      promote
                         000101 i                           promote
                         000102 len                         promote
ted_                     000100 ted_data_p                  ted_
                         000102 EOF                         ted_
                         000103 err_gol                     ted_
                         000110 fcbsp                       ted_
                         000112 fo_name                     ted_
                         000114 fop                         ted_
                         000116 b_stat                      ted_
                         000117 b_lhe                       ted_
                         000120 b_rhe                       ted_
                         000122 comptr                      ted_
                         000124 cfp                         ted_
                         000126 gv_work                     ted_
                         001126 marker                      ted_
                         001127 arg_max                     ted_
                         001130 arg_l                       ted_
                         001131 cm_val                      ted_
                         001132 char_pic                    ted_
                         001136 dbs                         ted_
                         001137 DBA                         ted_
                         001150 NLlast                      ted_
                         001151 Psw                         ted_
                         001152 af_bp                       ted_
                         001154 after_l                     ted_
                         001155 alt_sw                      ted_
                         001156 app_sw                      ted_
                         001160 argname                     ted_
                         001162 argno                       ted_
                         001164 b0_bp                       ted_
                         001166 b_depth                     ted_
                         001170 b_stack                     ted_
                         001214 bc                          ted_
                         001215 ch                          ted_
                         001224 code                        ted_
                         001225 concealsw                   ted_
                         001226 delim                       ted_
                         001227 enl                         ted_
                         001230 err_req                     ted_
                         001235 expr_b                      ted_
                         001236 expr_l                      ted_
                         001240 fcbp                        ted_
                         001242 file_l                      ted_
                         001244 file_p                      ted_
                         001246 fo_sw                       ted_
                         001250 gbp                         ted_
                         001252 go_sw                       ted_
                         001253 got_quit                    ted_
                         001254 gvx_p                       ted_
                         001256 header_l                    ted_
                         001257 hold_de                     ted_
                         001260 i                           ted_
                         001261 ii                          ted_
                         001262 il                          ted_
                         001263 intsw                       ted_
                         001264 iocb_ptr                    ted_
                         001266 j                           ted_
                         001267 jb                          ted_
                         001270 k                           ted_
                         001271 level                       ted_
                         001272 maxseg                      ted_
                         001273 me                          ted_
                         001274 me2                         ted_
                         001275 mi                          ted_
                         001276 ml                          ted_
                         001277 mustreprotect               ted_
                         001300 not_sw                      ted_
                         001301 on_quit                     ted_
                         001302 pi_label                    ted_
                         001306 pi_sw                       ted_
                         001316 qedx_mode                   ted_
                         001326 req_ch                      ted_
                         001330 req_chx                     ted_
                         001332 req_not                     ted_
                         001333 req_str                     ted_
                         001345 result                      ted_
                         001543 save_mod                    ted_
                         001544 select                      ted_
                         001550 sort_p                      ted_
                         001556 sort_sn                     ted_
                         001561 sub_type                    ted_
                         001565 subf1                       ted_
                         001566 subf2                       ted_
                         001567 subfile_name                ted_
                         001600 sub_p                       ted_
                         001602 subsw                       ted_
                         001603 svlen                       ted_
                         001604 svpath                      ted_
                         001667 tbi                         ted_
                         001670 tbp                         ted_
                         001672 tc                          ted_
                         001673 ted_mode                    ted_
                         001674 ted_safe                    ted_
                         001675 trustsw                     ted_
                         001676 ttp                         ted_
                         001700 used                        ted_
                         001701 vgch                        ted_
                         001702 vgds                        ted_
                         001704 wct                         ted_
                         001706 which_mode                  ted_
                         001710 write_l                     ted_
                         001711 wsw                         ted_
                         001712 xfe                         ted_
                         001713 xfi                         ted_
                         001714 xsw                         ted_
                         001716 sbp                         ted_
                         001720 dbp                         ted_
                         001722 seg_acl                     ted_
                         001735 delete_acl                  ted_
                         001746 fd                          ted_
                         002044 hold_db_output              ted_
                         002046 answer                      ted_
                         002052 hold_db_ted                 ted_
                         002053 rl_b                        ted_
                         002054 dbase_p                     ted_
                         002056 bp                          ted_
                         002060 msg                         ted_
                         002134 msg_ptr                     ted_
                         002136 query_info                  ted_
                         002153 branch_status               ted_
                         002165 gvNL                        ted_
                         002206 SI                          do_req
                         002327 real_dname                  do_req
                         002401 real_ename                  do_req
                         002411 sort_l                      do_req
                         002412 repl_exp                    do_req
                         002607 optlen                      do_req
                         002610 ted_sup                     do_req
                         002660 the_line_no                 do_req
                         002702 hold                        begin block on line 681
                         003077 it                          begin block on line 681
                         003122 IC                          substitute
                         003132 ml                          replace
                         003133 i                           replace
                         003134 rep_p                       replace
                         003136 temp_p                      replace
                         003140 temp_sn                     replace
                         003166 b21                         ignore_1
                         003176 ch                          scan
                         003206 old_bp                      buffer_buffer_copy
                         003210 sbp                         buffer_buffer_copy
                         003212 dbp                         buffer_buffer_copy
                         003214 tbp                         buffer_buffer_copy
                         003216 l                           buffer_buffer_copy
                         003217 tl                          buffer_buffer_copy
                         003220 tr                          buffer_buffer_copy
                         003230 sb                          iso_line
                         003231 se                          iso_line
                         003240 cur_line                    default$line_eval
                         003241 bias                        default$line_eval
                         003242 extend                      default$line_eval
                         003243 who                         default$line_eval
                         003260 gme2                        gv_compile
                         003261 last_op                     gv_compile
                         003262 adr_sw                      gv_compile
                         003264 tp                          gv_compile
                         003266 cllen                       gv_compile
                         003267 clloc                       gv_compile
                         003270 old_bp                      gv_compile
                         003272 llen                        gv_compile
                         003273 rlen                        gv_compile
                         003302 it                          begin block on line 4598
                         003303 n1_sw                       begin block on line 4598
                         003304 n2_sw                       begin block on line 4598
                         003305 i                           begin block on line 4598
                         003306 ch                          begin block on line 4598
                         003307 n1                          begin block on line 4598
                         003310 n2                          begin block on line 4598
                         003311 adr_sw                      begin block on line 4598
                         003320 tbp                         begin block on line 4598
                         003324 tbp                         begin block on line 4895
                         003342 db_data                     ted_gv_p_
                         003400 ls                          ted_gv_p_
                         004270 ls_top                      ted_gv_p_
                         004271 cur_lex_top                 ted_gv_p_
                         004435 parse_stack                 ted_gv_p_
                         004601 altn                        ted_gv_p_
                         004602 current_state               ted_gv_p_
                         004603 test_symbol                 ted_gv_p_
                         004604 current_table               ted_gv_p_
                         004605 i                           ted_gv_p_
                         004606 la_ct                       ted_gv_p_
                         004607 la_get                      ted_gv_p_
                         004610 la_need                     ted_gv_p_
                         004611 la_put                      ted_gv_p_
                         004612 la_use                      ted_gv_p_
                         004613 m                           ted_gv_p_
                         004614 next_state                  ted_gv_p_
                         004615 ps_top                      ted_gv_p_
                         004616 rulen                       ted_gv_p_
                         004617 t                           ted_gv_p_
                         004632 temp                        geterm
                         004714 i                           define
                         004715 j                           define
                         004732 db_I                        show_stk
                         004750 tv                          fix_addr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             r_le_a              alloc_char_temp     cat_realloc_chars
enter_begin_block   leave_begin_block   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           tra_ext_2           alloc_auto_adj      bound_ck_signal
mpfx2               mdfx1               signal_op           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      repeat              set_chars_eis       index_chars_eis
index_bs_1_eis      any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
abbrev_$expanded_line         archive_$get_component        com_err_                      command_query_
continue_to_signal_           continue_to_signal_           cu_$arg_count                 cu_$arg_list_ptr
cu_$arg_ptr                   cu_$cp                        cu_$ptr_call                  expand_pathname_$component
fs_util_$suffix_info          get_group_id_                 get_pdir_                     hcs_$add_acl_entries
hcs_$delete_acl_entries       hcs_$fs_get_path_name         hcs_$initiate_count           hcs_$make_ptr
hcs_$make_seg                 hcs_$status_long              hcs_$status_minf              hcs_$terminate_noname
hcs_$truncate_seg             ioa_                          ioa_                          ioa_$ioa_switch
ioa_$ioa_switch_nnl           ioa_$nnl                      iox_$attach_iocb              iox_$attach_name
iox_$close                    iox_$control                  iox_$detach_iocb              iox_$find_iocb
iox_$move_attach              iox_$open                     iox_$put_chars                mrl_
tedaddr_                      tedcall_                      tedcheck_buffer_state_        tedcheck_buffers_
tedcheck_entryname_           tedcleanup_                   tedcount_lines_               tedend_buffer_
tederror_                     tederror_rc_                  tedeval_                      tedfree_segment_
tedget_buffer_                tedget_existing_buffer_       tedget_segment_               tedglobal_$do_global
tedglobal_$proc_expr          tedhelp_                      tedhold_                      tedinit_
tedlist_buffers_              tedpseudo_                    tedread_ptr_                  tedresetread_
tedset_ck_ptr_                tedset_ptr_                   tedshow_                      tedshow_$init
tedsort_                      tedsort_$set                  tedsort_$show                 tedsrch_$compile
tedsrch_$init_exp             tedsrch_$search               terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$inconsistent     error_table_$insufficient_access                            error_table_$moderr
error_table_$no_component     error_table_$noentry          error_table_$unimplemented_version
error_table_$unsupported_operation                          error_table_$zero_length_seg  iox_$error_output
iox_$user_output              iox_$user_output              sys_info$max_seg_size         ted_gv_t_$DPDA
ted_gv_t_$TC                  ted_gv_t_$TL                  tedcommon_$etc                tedcommon_$id
tedcommon_$no_data            tedcommon_$no_seg             tederror_table_$Copy_Set      tederror_table_$Error_Msg
tederror_table_$NoChange      tederror_table_$Set           tederror_table_$ted_com_abort
tederror_table_$zero_length_buffer




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   5363 003127      5510 003130   16    7 003131        96 003163       106 003206       107 003212       109 003215
    111 003235       113 003240       114 003246       115 003250       116 003254       118 003264       120 003266
    122 003272       123 003274       125 003337       127 003363       129 003365       130 003400       131 003404
    132 003407       137 003410       145 003413       146 003424       148 003427       149 003437       150 003442
    154 003444       155 003457       157 003461       158 003463       160 003464       164 003514       165 003521
    166 003525       167 003533       170 003543       171 003545       173 003570       176 003574       178 003613
    179 003615       180 003626       181 003634       182 003640       204 003642       205 003646       206 003647
    207 003652       208 003654       209 003656       210 003662       211 003665       212 003670       214 003674
    215 003677       216 003700       217 003702       218 003703       220 003711       221 003713       222 003715
    223 003723       224 003725       225 003730       226 003733       227 003734       228 003736       231 003752
    234 003764       236 003770       237 003771       239 004023       241 004026       243 004030       244 004031
    245 004033       246 004034       248 004041       249 004043       250 004045       254 004047       256 004050
    257 004056       258 004061       260 004063       288 004105       290 004111       293 004115       295 004120
    297 004137       298 004144       302 004166       303 004171       304 004173       305 004200       313 004201
    316 004202       317 004206       318 004210       320 004212       322 004224       325 004226       327 004232
    328 004233       330 004234       332 004235       334 004240       336 004254       337 004263       338 004273
    339 004274       342 004276       344 004301       345 004303       346 004306       348 004331       349 004332
    351 004340       353 004351       356 004402       358 004410       362 004414       363 004427       366 004445
    368 004453       369 004456       370 004457       372 004463       374 004505       377 004510       379 004514
    381 004517       383 004522       384 004526       385 004531       386 004536       387 004542       388 004546
    390 004550       391 004551       392 004555       394 004602       397 004604       398 004605       400 004610
    401 004612       403 004614       404 004621       405 004622       406 004626       410 004643       412 004646
    413 004652       414 004655       417 004656       418 004662       420 004707       421 004712       423 004715
    425 004717       427 004723       429 004724       433 004725       436 004732       438 004734       439 004745
    441 004747       442 004760       444 004761       446 004762       448 004767       450 004770       452 004775
    454 004776       456 005003       458 005004       460 005011       462 005012       464 005017       466 005020
    468 005025       470 005026       472 005033       474 005034       476 005041       478 005042       480 005047
    482 005050       484 005055       486 005056       488 005063       490 005064       492 005071       494 005072
    496 005077       498 005100       500 005105       502 005106       504 005113       506 005114       508 005121
    510 005122       512 005135       514 005136       516 005143       518 005152       519 005164       521 005166
    522 005200       523 005221       525 005230       528 005234       529 005246       530 005273       532 005305
    535 005323       537 005333       539 005340       541 005343       542 005346       543 005347       544 005410
    547 005413       549 005422       551 005425       553 005431       554 005435       556 005436       557 005437
    558 005440       560 005441       562 005444       564 005453       565 005457       566 005461       568 005466
    570 005472       572 005507       575 005511       576 005512       578 005515       579 005521       580 005524
    582 005537       584 005540       586 005542      4544 005543      4547 005553      4548 005565      4549 005577
   4551 005606      4553 005621      4555 005626      5248 005627      5255 005644      5256 005650      5257 005652
   5258 005660      5261 005661      5267 005672      5268 005676      5269 005701      5270 005705      5274 005706
   5283 005724      5284 005730      5285 005732      5287 005774      5289 006003      5290 006007      5291 006013
   5292 006015      5293 006020      5294 006024      5295 006026      5296 006031      5297 006034      5298 006036
   5299 006042      5302 006064      5303 006065      5311 006074      5313 006077      5315 006124      5317 006130
   5318 006145      5320 006146      5321 006150      5322 006154      5323 006165      5324 006167      5325 006177
   5326 006214      5328 006242      5329 006261      5331 006263      5332 006264      5335 006273      5336 006276
   5337 006300      5339 006301      5342 006310      5343 006312      5344 006314      5346 006315      5349 006324
   5350 006326      5351 006331      5353 006332      5356 006341      5357 006344      5358 006347      5360 006350
   5362 006367      5365 006371      5367 006401      5369 006405      5371 006415      5373 006417      5374 006426
   5375 006452      5377 006455      5378 006457      5380 006460      5382 006462      5383 006471      5385 006526
   5386 006531      5387 006532      5388 006535      5394 006536      5394 006545      5394 006550      5395 006551
   5395 006560      5395 006563      5398 006564      5399 006573      5400 006575      5401 006577      5403 006600
   5404 006607      5405 006610      5406 006612      5408 006613      5411 006622      5412 006624      5413 006626
   5414 006627      5415 006636      5416 006637      5419 006641      5421 006660      5424 006702      5425 006707
   5427 006716      5428 006725      5430 006726      5431 006730      5435 006762      5438 007021       193 007022
    195 007023       197 007045       198 007050       199 007053       200 007056       201 007060       202 007063
    203 007065       261 007066       263 007074       265 007101       266 007111       268 007123       270 007137
    271 007143       272 007152       274 007202       276 007215       277 007225       279 007231       280 007252
    282 007265       284 007300       286 007305       592 007306       597 007310       598 007322       601 007335
    602 007341       614 007350       616 007355       617 007362       618 007370       619 007376       620 007403
    623 007404       664 007405       665 007412       666 007424       669 007425       671 007426       672 007437
    674 007441       706 007447       708 007457       710 007461       713 007470       716 007476       718 007506
    719 007513       720 007514       721 007517       723 007523       724 007525       725 007526       726 007527
    728 007532       730 007534       731 007535       734 007543       736 007547       739 007556       741 007563
    743 007572       744 007576       745 007605       747 007610       748 007611       750 007616       751 007620
    752 007621       753 007626       754 007630       755 007631       756 007634       757 007636       758 007637
    760 007676       762 007700       764 007704       767 007725       769 007733       770 007737       772 007744
    774 007755       775 007757       776 007761       777 007762       778 007763       781 007764       783 007770
    787 010007       789 010011       791 010013       792 010020       794 010021       795 010024       796 010027
    797 010033       798 010034       799 010035       800 010050       802 010061       803 010063       804 010067
    807 010100       808 010102       810 010107       812 010113       813 010114       814 010140       816 010145
    818 010147       820 010150       822 010153       823 010154       825 010157       826 010162       828 010164
    830 010167       832 010174       833 010201       835 010202       837 010205       839 010210       840 010211
    843 010266       845 010272       846 010274       848 010300       851 010301       852 010306       853 010316
    855 010323       857 010326       859 010334       862 010336       863 010340       864 010342       865 010344
    866 010350       868 010356       871 010363       875 010375       878 010376       880 010403       881 010410
    882 010420       884 010421       885 010427       886 010431       888 010433       889 010445       891 010451
    892 010453       893 010467       895 010470       896 010473       897 010475       898 010510       899 010513
    901 010517       902 010524       903 010550       904 010561       906 010562       909 010564       911 010567
    913 010606       914 010624       916 010627       918 010657       920 010661       922 010701       924 010702
    926 010713       928 010721       930 010725       931 010727       932 010731       933 010736       935 010740
    936 010744       938 010752       939 010753       942 010755       943 010757       944 011006       947 011010
    949 011013       952 011053       955 011060       957 011065       959 011066       961 011072       962 011077
    963 011111       964 011121       966 011126       970 011127       971 011171       973 011175       975 011177
    977 011203       980 011210       981 011215       982 011225       984 011226       986 011266       988 011267
    990 011304       993 011306       994 011345       996 011351      1000 011364      1001 011374      1002 011407
   1004 011414      1006 011415      1012 011416      1013 011450      1015 011512      1017 011517      1018 011522
   1019 011523      1021 011524      1022 011527      1024 011531      1026 011535      1028 011547      1030 011554
   1031 011557      1036 011657      1038 011663      1040 011670      1042 011676      1043 011710      1044 011712
   1045 011713      1047 011750      1049 011752      1050 011757      1052 011760      1054 011762      1057 011765
   1059 011772      1062 011774      1064 012000      1065 012005      1067 012006      1069 012026      1071 012052
   1073 012067      1074 012070      1076 012075      1079 012076      1082 012100      1084 012103      1085 012110
   1087 012140      1090 012143      1092 012150      1093 012173      1095 012175      1098 012177      1101 012212
   1102 012220      1105 012227      1107 012234      1108 012263      1110 012265      1111 012272      1113 012273
   1114 012274      1116 012301      1117 012302      1119 012322      1121 012363      1123 012364      1137 012372
   1139 012375      1140 012401      1142 012425      1143 012430      1145 012434      1147 012437      1148 012443
   1149 012467      1150 012476      1151 012511      1153 012512      1154 012514      1156 012516      1158 012521
   1161 012525      1162 012531      1164 012535      1165 012536      1166 012544      1169 012561      1170 012566
   1172 012570      1173 012571      1174 012603      1175 012620      1177 012625      1179 012633      1181 012637
   1182 012641      1185 012643      1186 012650      1189 012656      1190 012674      1191 012677      1192 012701
   1193 012703      1194 012705      1195 012707      1196 012710      1211 012716      1214 012726      1215 012730
   1216 012731      1217 012735      1219 012752      1220 012757      1221 012763      1222 012764      1223 012775
   1225 013002      1227 013010      1229 013045      1231 013047      1232 013054      1234 013055      1235 013057
   1236 013062      1237 013063      1239 013103      1240 013106      1241 013111      1243 013113      1244 013117
   1245 013121      1246 013123      1248 013124      1250 013125      1251 013157      1254 013162      1255 013175
   1257 013201      1258 013205      1259 013210      1260 013220      1262 013222      1266 013266      1268 013267
   1270 013274      1271 013275      1274 013276      1276 013300      1278 013302      1279 013306      1280 013311
   1281 013316      1282 013322      1283 013325      1284 013327      1287 013332      1290 013376      1292 013400
   1294 013403      1297 013413      1298 013414      1300 013415      1304 013441      1307 013442      1309 013444
   1312 013451      1316 013452      1319 013465      1320 013467      1322 013470      1325 013501      1327 013504
   1328 013513      1329 013520      1331 013532      1332 013534      1333 013543      1335 013544      1336 013551
   1339 013552      1341 013556      1343 013566      1344 013607      1347 013614      1351 013616      1352 013623
   1354 013632      1355 013642      1356 013650      1358 013652      1359 013653      1361 013705      1365 013717
   1369 013723      1371 013733      1372 013754      1375 013761      1376 013763      1378 013767      1379 013771
   1380 014004      1382 014006      1384 014010      1385 014026      1388 014033      1390 014035      1395 014063
   1397 014070      1400 014072      1401 014105      1403 014107      1405 014121      1407 014126      1408 014130
   1409 014132      1410 014135      1411 014136      1413 014141      1414 014143      1416 014145      1418 014151
   1420 014154      1421 014160      1423 014210      1426 014213      1428 014217      1432 014242      1433 014246
   1437 014247      1439 014253      1440 014254      1443 014263      1444 014267      1446 014273      1447 014274
   1448 014316      1453 014324      1455 014331      1456 014332      1457 014334      1458 014335      1459 014336
   1462 014344      1464 014352      1465 014353      1466 014357      1467 014360      1475 014366      1477 014374
   1479 014402      1481 014406      1482 014407      1483 014413      1492 014414      1494 014422      1495 014423
   1496 014427      1497 014432      1504 014433      1506 014441      1508 014450      1509 014451      1511 014452
   1514 014462      1515 014466      1516 014467      1519 014475      1520 014500      1523 014516      1525 014537
   1527 014545      1528 014547      1530 014551      1531 014573      1533 014576      1535 014601      1536 014613
   1537 014617      1539 014621      1540 014623      1544 014626      1545 014652      1546 014654      1550 014655
   1552 014670      1553 014673      1555 014675      1556 014700      1557 014711      1558 014714      1564 014740
   1566 014743      1568 014747      1570 014754      1574 014757      1575 014761      1577 014772      1579 015015
   1581 015016      1586 015032      1588 015035      1590 015037      1591 015040      1593 015065      1595 015076
   1597 015104      1600 015106      1602 015107      1603 015114      1605 015124      1606 015131      1608 015137
   1610 015143      1611 015165      1613 015174      1614 015175      1615 015177      1616 015205      1617 015206
   1618 015223      1619 015225      1621 015227      1622 015231      1623 015237      1625 015240      1626 015242
   1628 015246      1632 015315      1633 015326      1634 015337      1636 015341      1637 015352      1639 015363
   1640 015370      1643 015371      1644 015375      1645 015412      1646 015415      1647 015416      1648 015427
   1653 015435      1655 015441      1656 015442      1659 015451      1660 015455      1662 015456      1663 015457
   1664 015464      1665 015513      1668 015521      1672 015536      1673 015550      1674 015553      1675 015555
   1677 015564      1678 015566      1679 015573      1680 015577      1681 015600      1684 015603      1688 015607
   1689 015624      1690 015636      1691 015641      1692 015643      1694 015652      1697 015662      1698 015664
   1700 015671      1702 015675      1703 015702      1706 015704      1709 015705      1710 015712      1711 015713
   1714 015761      1716 016014      1718 016017      1720 016027      1721 016040      1723 016042      1726 016044
   1728 016045      1731 016051      1732 016052      1733 016053      1734 016056      1735 016060      1736 016061
   1737 016062      1739 016066      1740 016073      1743 016141      1745 016144      1746 016146      1747 016151
   1750 016156      1752 016160      1755 016176      1757 016206      1758 016213      1760 016214      1763 016222
   1767 016223      1768 016224      1769 016225      1771 016237      1774 016305      1775 016317      1778 016325
   1782 016331      1793 016517      1795 016520      1796 016525      1797 016536      1800 016547      1802 016551
   1803 016553      1804 016555      1805 016556      1807 016557      1809 016566      1810 016570      1811 016576
   1812 016577      1814 016606      1815 016610      1816 016616      1817 016617      1819 016626      1820 016630
   1821 016634      1822 016635      1824 016640      1825 016642      1826 016656      1827 016657      1829 016664
   1830 016666      1831 016672      1832 016673      1834 016676      1835 016700      1836 016705      1837 016706
   1839 016713      1840 016715      1841 016717      1842 016723      1843 016724      1845 016727      1846 016731
   1847 016737      1848 016740      1850 016743      1851 016745      1852 016752      1853 016753      1855 016755
   1856 016757      1857 016765      1858 016766      1860 016773      1861 016775      1862 017002      1863 017003
   1865 017006      1866 017010      1867 017016      1868 017017      1870 017024      1871 017026      1872 017034
   1873 017035      1875 017040      1876 017042      1877 017047      1878 017050      1880 017053      1881 017055
   1882 017056      1884 017065      1886 017101      1888 017103      1889 017107      1890 017110      1891 017111
   1893 017116      1894 017120      1895 017137      1897 017140      1898 017154      1900 017162      1901 017173
   1902 017175      1903 017176      1905 017201      1906 017203      1907 017222      1908 017223      1910 017225
   1911 017227      1912 017230      1913 017231      1915 017235      1916 017242      1917 017303      1918 017305
   1920 017307      1921 017311      1922 017326      1923 017343      1925 017344      1927 017351      1929 017367
   1931 017370      1933 017375      1935 017377      1938 017405      1941 017413      1942 017414      1943 017423
   1946 017457      1947 017462      1948 017464      1949 017473      1950 017507      1952 017510      1955 017515
   1977 017523      1980 017545      1982 017547      1983 017553      1984 017571      1985 017600      1986 017612
   1987 017616      1988 017617      1989 017621      1991 017631      1993 017634      1994 017636      1995 017637
   1996 017640      1997 017641      1999 017712      2001 017715      2002 017717      2003 017720      2005 017726
   2011 017732      2013 017734      2014 017737      2015 017743      2016 017746      2018 017763      2019 017770
   2020 017777      2021 020004      2022 020013      2023 020017      2026 020057      2027 020060      2028 020073
   2029 020076      2032 020103      2033 020105      2036 020137      2037 020140      2038 020143      2039 020147
   2040 020151      2041 020153      2044 020157      2045 020162      2046 020165      2047 020172      2051 020175
   2052 020177      2053 020201      2054 020202      2055 020203      2056 020206      2058 020210      2060 020236
   2063 020245      2064 020247      2067 020250      2069 020253      2071 020260      2073 020265      2075 020272
   2079 020276      2081 020301      2084 020332      2085 020342      2086 020344      2088 020350      2089 020365
   2091 020370      2093 020372      2096 020375      2097 020376      2099 020406      2101 020412      2103 020416
   2104 020417      2106 020422      2108 020424      2109 020427      2110 020431      2112 020437      2114 020441
   2116 020470      2118 020472      2124 020473      2127 020474      2129 020477      2131 020511      2132 020513
   2133 020514      2134 020516      2135 020520      2139 020534      2141 020536      2143 020541      2144 020542
   2146 020546      2148 020557      2149 020571      2150 020574      2152 020576      2153 020603      2154 020607
   2155 020611      2157 020623      2158 020625      2159 020626      2160 020630      2161 020632      2163 020633
   2164 020637      2167 020666      2169 020712      2170 020715      2172 020721      2173 020726      2175 020730
   2177 020734      2178 020743      2180 020751      2181 020753      2183 020757      2184 020760      2185 020764
   2186 020765      2187 020771      2189 020777      2191 021001      2193 021010      2194 021014      2198 021020
   2199 021022      2200 021024      2201 021026      2204 021030      2206 021036      2207 021040      2208 021042
   2212 021043      2213 021047      2216 021071      2219 021077      2222 021101      2223 021103      2227 021105
   2229 021111      2231 021113      2232 021114      2234 021116      2236 021121      2237 021123      2238 021125
   2239 021132      2241 021157      2242 021162      2244 021166      2246 021172      2247 021177      2249 021200
   2250 021201      2252 021210      2253 021212      2256 021217      2262 021230      2263 021233      2265 021237
   2267 021241      2268 021246      2270 021247      2272 021255      2274 021264      2275 021271      2280 021272
   2282 021274      2283 021275      2288 021307      2289 021312      2293 021374      2296 021406      2299 021414
   2300 021420      2305 021422      2306 021426      2307 021430      2311 021434      2313 021440      2319 021451
   2321 021467      2323 021473      2324 021477      2327 021503      2328 021507      2330 021512      2332 021516
   2333 021522      2334 021534      2335 021546      2336 021573      2337 021602      2339 021606      2341 021610
   2343 021622      2345 021630      2346 021633      2347 021635      2348 021641      2349 021642      2350 021645
   2352 021646      2355 021654      2360 021674      2361 021715      2363 021724      2364 021727      2365 021732
   2367 021733      2368 021747      2370 021750      2371 021755      2374 021761      2375 021762      2378 021764
   2379 021767      2382 022002      2383 022006      2384 022015      2386 022020      2388 022021      2389 022026
   2392 022053      2393 022064      2396 022105      2399 022113      2401 022120      2402 022121      2403 022122
   2404 022123      2405 022124      2407 022130      2408 022142      2409 022144      2411 022155      2412 022211
   2414 022223      2415 022240      2416 022274      2417 022301      2419 022303      2420 022312      2421 022346
   2423 022355      2425 022361      2426 022373      2428 022427      2429 022436      2430 022455      2434 022463
   2436 022465      2438 022467      2441 022470      2442 022471      2443 022472      2446 022476      2447 022501
   2448 022503      2449 022512      2450 022524      2452 022531      2454 022535      2455 022537      2458 022562
   2459 022565      2460 022567      2462 022572      2464 022573      2465 022576      2468 022600      2469 022601
   2471 022613      2472 022616      2473 022622      2474 022631      2475 022643      2478 022644      2480 022650
   2481 022652      2482 022661      2483 022663      2484 022667      2485 022671      2486 022674      2487 022675
   2489 022702      2490 022707      2492 022717      2493 022720      2495 022727      2497 022740      2498 022742
   2499 022743      2500 022744      2517 023012      2518 023017      2520 023022      2521 023024      2522 023026
   2523 023030      2526 023041      2527 023043      2532 023071      2533 023106      2534 023111      2535 023113
   2537 023114      2538 023116      2540 023120      2542 023154      2543 023157      2545 023175      2547 023206
   2549 023212      2550 023214      2552 023233      2554 023237      2555 023242      2556 023244      2557 023246
   2559 023251      2562 023274      2564 023276      2566 023303      2567 023304      2570 023305      2572 023340
   2574 023343      2577 023347      2580 023356      2581 023357      2583 023364      2585 023374      2586 023416
   2589 023447      2590 023451      2591 023452      2594 023506      2599 023517      2602 023523      2603 023524
   2605 023525      2607 023530      2608 023532      2609 023534      2611 023535      2613 023536      2615 023544
   2617 023557      2619 023564      2621 023565      2623 023575      2625 023621      2628 023627      2630 023634
   2631 023635      2633 023641      2634 023643      2635 023644      2636 023646      2639 023647      2643 023654
   2647 023663      2648 023664      2651 023665      2654 023672      2655 023675      2657 023702      2658 023703
   2661 023704      2663 023707      2665 023715      2666 023733      2668 023734      2670 023736      2671 023737
   2672 023741      2673 023743      2674 023750      2676 024007      2679 024016      2682 024023      2684 024035
   2686 024042      2687 024050      2688 024056      2690 024064      2692 024066      2693 024071      2694 024073
   2696 024101      2697 024102      2698 024103      2699 024104      2703 024112      2706 024113      2707 024122
   2708 024124      2710 024127      2711 024146      2713 024147      2715 024151      2716 024152      2717 024154
   2719 024156      2721 024160      2723 024172      2724 024173      2725 024175      2727 024201      2728 024203
   2730 024210      2731 024213      2732 024215      2733 024216      2734 024217      2736 024223      2738 024225
   2739 024234      2741 024242      2742 024275      2744 024300      2746 024306      2748 024310      2751 024316
   2754 024327      2757 024335      2761 024347      2762 024350      2763 024353      2764 024354      2768 024362
   2771 024367      2773 024372      2775 024375      2776 024376      2778 024402      2780 024405      2782 024410
   2785 024411      2788 024414      2790 024425      2796 024433      2798 024454      2800 024461      2801 024463
   2802 024476      2804 024503      2806 024506      2807 024513      2809 024514      2810 024515      2812 024525
   2813 024527      2814 024534      2816 024535      2818 024541      2819 024543      2820 024550      2822 024551
   2824 024555      2825 024557      2826 024564      2829 024565      2830 024566      2835 024607      2838 024612
   2840 024617      2841 024624      2843 024664      2844 024667      2846 024671      2849 024673      2851 024674
   2853 024701      2855 024721      2857 024727      2859 024731      2860 024736      2861 024750      2863 024762
   2865 025002      2868 025010      2871 025012      2873 025022      2874 025027      2875 025041      2877 025042
   2878 025043      2880 025045      2883 025055      2884 025056      2886 025064      2888 025066      2890 025070
   2891 025071      2892 025076      2893 025123      2894 025126      2896 025132      2897 025137      2899 025156
   2900 025161      2901 025164      2902 025200      2903 025201      2904 025222      2906 025306      2908 025312
   2909 025337      2911 025342      2912 025364      2914 025367      2915 025414      2917 025417      2918 025447
   2920 025504      2921 025520      2923 025547      2924 025577      2926 025602      2928 025626      2929 025631
   2930 025632      2931 025633      2933 025640       677 025646       680 025650       687 025654       688 025661
    689 025666       691 025713       693 025720       694 025725       696 025726       697 025730       699 025737
    700 025740       702 025744       704 025746      1124 025747      1125 025750      1127 025752      1128 025755
   1130 026012      1132 026014      1133 026021      1136 026022      1958 026023      1965 026031      1966 026032
   1968 026040      1970 026065      1973 026073      2936 026074      2941 026076      2944 026127      2946 026131
   2947 026134      2948 026140      2951 026145      2952 026150      2955 026172      2957 026206      2958 026207
   2961 026212      2963 026215      2965 026216      2966 026217      2972 026221      2973 026224      2976 026255
   2978 026257      2979 026261      2980 026263      2981 026266      2982 026270      2983 026302      2987 026306
   2989 026307      2990 026310      3004 026312      3005 026315      3006 026317      3007 026321      3008 026325
   3009 026334      3010 026335      3011 026342      3012 026344      3014 026366      3017 026374      3020 026376
   3021 026400      3023 026401      3024 026416      3026 026417      3028 026421      3030 026427      3031 026431
   3034 026432      3036 026434      3038 026437      3039 026441      3041 026454      3042 026457      3044 026463
   3046 026507      3048 026510      3050 026531      3052 026532      3055 026545      3056 026560      3057 026562
   3059 026563      3063 026570      3064 026600      3065 026614      3066 026646      3067 026647      3069 026650
   3072 026714      3074 026716      3077 026741      3079 026745      3108 026751      3110 026753      3111 026754
   3112 026756      3113 026760      3114 026772      3115 026776      3117 027000      3118 027001      3119 027015
   3120 027016      3122 027022      3123 027030      3124 027034      3125 027036      3127 027037      3129 027044
   3131 027046      3133 027063      3134 027066      3135 027070      3136 027071      3139 027102      3140 027116
   3142 027117      3143 027124      3145 027125      3146 027152      3148 027161      3149 027162      3151 027164
   3152 027167      3154 027172      3155 027175      3156 027177      3158 027213      3159 027214      3160 027230
   3161 027231      3163 027233      3165 027251      3166 027252      3167 027266      3168 027271      3080 027272
   3088 027300      3091 027307      3092 027313      3093 027316      3096 027322      3097 027334      3098 027343
   3099 027347      3102 027350      3104 027366      3170 027367      3174 027403      3176 027410      3177 027416
   3178 027423      3179 027427      3182 027431      3183 027441      3184 027443      3185 027450      3187 027451
   3189 027452      3190 027455      3191 027457      3192 027470      3194 027473      3197 027524      3198 027527
   3202 027553      3205 027604      3208 027605      3212 027606      3216 027614      3217 027616      3218 027621
   3219 027624      3220 027646      3221 027661      3223 027665      3225 027714      3226 027731      3228 027735
   3230 027765      3231 030000      3232 030013      3234 030017      3236 030044      3237 030045      3238 030046
   3240 030054      3242 030062      3243 030065      3244 030071      3246 030142      3248 030147      3250 030210
   3252 030211      3253 030216      3254 030240      3255 030256      3257 030271      3259 030276      3260 030300
   3262 030303      3263 030306      3264 030311      3265 030313      3268 030315      3286 030316      3291 030332
   3292 030427      3294 030444      3295 030470      3297 030477      3298 030511      3300 030525      3302 030551
   3303 030552      3305 030553      3310 030572      3312 030573      3315 030574      3317 030601      3319 030603
   3320 030605      3322 030606      3325 030607      3327 030614      3329 030616      3331 030623      3333 030624
   3334 030626      3336 030627      3340 030630      3341 030635      3343 030640      3346 030642      3348 030647
   3350 030651      3351 030656      3353 030657      3354 030661      3357 030705      3358 030706      3362 030707
   3363 030716      3366 030724      3367 030727      3368 030730      3369 030742      3371 030744      3372 030751
   3374 030754      3376 030760      3378 030763      3380 030771      3382 030773      3384 030775      3387 030777
   3388 031000      3389 031001      3391 031003      3393 031004      3395 031006      3397 031012      3409 031013
   3410 031021      3411 031026      3413 031030      3425 031037      3427 031043      3428 031045      3430 031046
   3431 031051      3433 031055      3434 031057      3436 031063      3439 031115      3440 031124      3442 031130
   3443 031132      3446 031133      3449 031145      3451 031156      3453 031163      3455 031165      3456 031167
   3458 031170      3460 031173      3461 031175      3463 031176      3464 031177      3467 031204      3468 031206
   3472 031245      3474 031246      3476 031310      3477 031316      3480 031321      3528 031323      3529 031326
   3530 031331      3532 031333      3534 031337      3537 031404      3540 031432      3541 031454      3545 031475
   3547 031500      3548 031504      3549 031530      3550 031537      3555 031554      3556 031556      3557 031562
   3558 031566      3560 031573      3561 031575      3564 031617      3565 031621      3567 031634      3568 031642
   3569 031647      3575 031657      3577 031662      3578 031666      3579 031672      3581 031700      3582 031702
   3583 031704      3585 031705      3586 031707      3589 031710      3590 031712      3593 031734      3594 031736
   3596 031744      3597 031747      3598 031751      3600 031752      3601 031755      3603 031757      3605 031760
   3606 031762      3609 031766      3610 031770      3612 032013      3614 032017      3615 032040      3617 032060
   3618 032062      3619 032065      3621 032067      3622 032070      3643 032076      3644 032100      3645 032101
   3646 032102      3648 032103      3650 032111      3651 032113      3652 032115      3653 032116      3655 032117
   3657 032125      3658 032127      3659 032131      3660 032133      3662 032134      3664 032142      3665 032144
   3666 032146      3667 032150      3669 032151      3679 032157      3680 032164      3682 032172      3683 032174
   3684 032176      3685 032204      3687 032206      3690 032212      3692 032214      3693 032216      3695 032220
   3696 032235      3698 032236      3700 032245      3701 032246      3702 032247      3704 032254      3706 032256
   3708 032262      3709 032313      3712 032354      3714 032360      3716 032366      3717 032373      3719 032374
   3721 032403      3723 032413      3727 032420      3729 032422      3730 032424      3731 032430      3732 032433
   3734 032446      3737 032452      3740 032461      3741 032466      3743 032475      3748 032575      3750 032647
   3752 032655      3754 032660      3755 032665      3756 032671      3757 032672      3759 032674      3760 032677
   3761 032704      3762 032705      3764 032712      3766 032715      3767 032737      3769 032740      3770 032745
   3771 032751      3772 032752      3774 032754      3775 032757      3776 032764      3777 032766      3779 032772
   3781 032775      3782 033004      3787 033053      3789 033063      3790 033070      3796 033113      3797 033114
   3803 033122      3805 033146      3806 033163      3809 033173      3811 033175      3812 033204      3813 033206
   3814 033207      3815 033211      3817 033275      3818 033306      3819 033315      3820 033320      3821 033323
   3822 033325      3825 033326      3827 033331      3828 033340      3833 033353      3844 033357      3846 033362
   3848 033373      3849 033400      3850 033405      3852 033410      3853 033411      3860 033413      3861 033417
   3862 033422      3863 033425      3872 033426      3873 033433      3874 033440      3879 033454      3880 033461
   3882 033463      3883 033470      3884 033474      3887 033516      3893 033517      3895 033525      3897 033547
   3899 033554      3900 033561      3902 033564      3904 033576      3907 033602      3909 033636      3910 033640
   3913 033644      3914 033646      3923 033655      3925 033660      3927 033662      3929 033664      3932 033667
   3933 033700      3934 033724      3936 033725      3937 033731      3939 033755      3940 033757      3943 034006
   3949 034007      3950 034015      3951 034017      3953 034077      3955 034103      3956 034111      3958 034113
   3959 034120      3960 034154      3961 034166      3963 034171      3966 034172      3967 034200      3968 034202
   3969 034215      3991 034273      3994 034306      3996 034330      3998 034332      4000 034345      4001 034356
   4002 034370      4003 034406      4004 034420      4007 034423      4008 034426      4009 034431      4010 034434
   4017 034435      4018 034441      4019 034445      4020 034452      4022 034460      4023 034462      4024 034465
   4026 034471      4027 034474      4028 034477      4029 034503      4030 034505      4031 034507      4032 034521
   4038 034603      4040 034604      4042 034610      4044 034613      4045 034621      4047 034622      4048 034624
   4049 034627      4050 034634      4052 034635      4054 034656      4055 034666      4056 034671      4057 034673
   4058 034677      4060 034726      4065 034733      4067 034740      4068 034746      4070 034747      4071 034751
   4072 034754      4073 034761      4075 034762      4077 035003      4078 035013      4079 035016      4080 035021
   4081 035026      4083 035060      4088 035067      4090 035072      4091 035100      4093 035101      4094 035103
   4095 035106      4096 035113      4098 035114      4100 035135      4101 035146      4102 035151      4103 035153
   4104 035157      4106 035206      4112 035215      4114 035223      4115 035225      4118 035240      4122 035255
   4126 035264      4128 035270      4129 035273      4130 035276      4131 035300      4133 035303      4138 035305
   4141 035340      4146 035345      4149 035373      4150 035377      4152 035424      4153 035425      4154 035433
   4156 035445      4157 035452      4158 035470      4160 035526      4161 035527      4163 035534      4164 035541
   4165 035557      4167 035615      4168 035616      4170 035624      4171 035631      4172 035650      4174 035710
   4175 035711      4177 035725      4197 035726      4205 035734      4207 035770      4209 035774      4211 036000
   4212 036005      4213 036006      4216 036007      4218 036012      4219 036015      4221 036016      4230 036017
   4231 036025      4239 036031      4240 036033      4241 036036      4243 036042      4244 036045      4246 036047
   4247 036051      4248 036053      4249 036055      4251 036126      4252 036132      4253 036141      4255 036142
   4256 036144      4258 036146      4259 036147      4261 036153      4263 036205      4264 036211      4265 036220
   4267 036224      4269 036256      4270 036262      4271 036271      4273 036275      4274 036303      4275 036305
   4278 036307      4279 036311      4280 036316      4282 036321      4284 036324      4285 036326      4286 036330
   4287 036343      4288 036353      4289 036356      4293 036360      4294 036367      4300 036377      4301 036401
   4304 036411      4305 036415      4306 036417      4307 036422      4308 036430      4309 036434      4310 036435
   4311 036443      4312 036447      4313 036451      4314 036457      4315 036463      4316 036466      4352 036467
   4354 036475      4356 036501      4358 036504      4360 036507      4361 036511      4362 036523      4363 036533
   4364 036536      4366 036540      4368 036541      4369 036543      4371 036550      4372 036554      4373 036556
   4374 036557      4375 036561      4376 036571      4377 036576      4378 036601      4381 036602      4383 036610
   4384 036614      4385 036617      4386 036624      4317 036625      4321 036636      4322 036645      4325 036660
   4329 036670      4333 036700      4337 036710      4341 036720      4344 036734      4346 036762      4392 036770
   4397 036771      4398 036774      4401 037006      4404 037014      4405 037016      4407 037022      4408 037042
   4410 037071      4412 037075      4418 037106      4420 037124      4422 037130      4424 037134      4425 037140
   4428 037143      4429 037146      4430 037151      4433 037162      4434 037164      4437 037166      4438 037170
   4439 037172      4441 037174      4443 037202      4444 037204      4446 037210      4447 037224      4450 037232
   4451 037235      4453 037241      4454 037243      4456 037250      4459 037257      4460 037273      4462 037277
   4465 037303      4466 037305      4467 037307      4468 037313      4471 037335      4474 037336      4475 037337
   4475 037341      4475 037343      4475 037344      4475 037346      4477 037347      4478 037350      4478 037352
   4478 037353      4478 037355      4478 037356      4480 037357      4481 037360      4481 037362      4481 037363
   4481 037364      4481 037366      4483 037367      4484 037370      4484 037372      4484 037373      4484 037374
   4486 037375      4489 037401      4492 037415      4493 037417      4494 037421      4496 037430      4497 037432
   4499 037441      4501 037443      4502 037444      4504 037447      4506 037452      4508 037506      4510 037511
   4511 037516      4513 037517      4515 037522      4516 037527      4518 037530      4520 037532      4521 037537
   4523 037540      4525 037547      4526 037554      4528 037555      4530 037561      4531 037566      4533 037567
   4556 037570      4558 037576      4560 037602      4561 037606      4563 037613      4566 037631      4567 037640
   4568 037645      4569 037647      4570 037651      4571 037652      4573 037654      4574 037655      4579 037666
   4581 037673      4582 037677      4583 037704      4585 037707      4586 037712      4587 037714      4588 037716
   4591 037745      4596 037746      4597 037747      4607 037752      4608 037753      4609 037757      4610 037764
   4611 037767      4612 037772      4614 040001      4615 040003      4617 040004      4619 040006      4621 040012
   4622 040017      4624 040020      4626 040022      4627 040024      4629 040025      4630 040027      4632 040033
   4633 040036      4635 040037      4637 040041      4638 040043      4639 040045      4640 040047      4641 040050
   4643 040053      4645 040057      4646 040064      4647 040067      4652 040070      4653 040072      4654 040073
   4655 040100      4656 040112      4659 040126      4661 040132      4662 040142      4663 040153      4665 040154
   4667 040157      4669 040167      4670 040200      4672 040201      4674 040205      4675 040207      4677 040210
   4679 040215      4680 040217      4682 040220      4683 040221      4689 040225      4690 040231      4691 040233
   4692 040234      4695 040240      4697 040243      4700 040250      4701 040275      4702 040300      4704 040304
   4706 040310      4707 040315      4709 040316      4710 040321      4711 040323      4712 040324      4716 040325
   4717 040330      4718 040331      4720 040373      4722 040375      4723 040401      4726 040402      4727 040406
   4728 040411      4730 040414      4731 040422      4732 040426      4734 040427      4735 040435      4736 040436
   4739 040442      4740 040450      4741 040455      4742 040456      4745 040457      4746 040463      4747 040474
   4748 040501      4749 040502      4751 040504      4752 040506      4753 040510      4754 040522      4755 040527
   4757 040532      4759 040536      4761 040543      4762 040552      4763 040561      4764 040563      4766 040564
   4767 040566      4768 040570      4769 040571      4770 040572      4771 040573      4773 040575      4775 040577
   4776 040601      4778 040602      4780 040604      4782 040606      4787 040612      4790 040615      4791 040620
   4792 040622      4793 040624      4796 040625      4797 040626      4799 040630      4801 040632      4802 040634
   4804 040640      4805 040642      4806 040662      4808 040663      4810 040664      4811 040703      4815 040706
   4816 040713      4817 040715      4819 040716      4820 040720      4821 040736      4823 040743      4825 040745
   4826 040750      4828 040753      4830 040756      4831 040776      4833 040777      4834 041004      4836 041005
   4837 041010      4838 041021      4839 041023      4840 041030      4841 041031      4846 041040      4847 041057
   4849 041072      4851 041073      4852 041100      4854 041101      4855 041103      4856 041107      4857 041120
   4858 041123      4859 041130      4860 041131      4863 041142      4864 041163      4866 041164      4867 041171
   4869 041172      4870 041173      4872 041202      4873 041204      4874 041210      4875 041221      4876 041223
   4877 041230      4878 041231      4880 041233      4881 041234      4885 041242      4887 041245      4890 041251
   4891 041252      4893 041255      4894 041257      4898 041263      4899 041265      4900 041270      4902 041274
   4903 041301      4904 041305      4905 041310      4906 041314      4908 041316      4910 041317      4912 041324
   4913 041325      4915 041332      4916 041333      4918 041340      4919 041341      4921 041346      4922 041347
   4924 041354      4925 041357      4947 041360    4    8 041361    4   12 041362    4   14 041364    4   15 041366
 4   17 041370    4   18 041371    4   21 041372    4   24 041374    4   26 041404    4   27 041410    4   28 041412
 4   29 041414    4   30 041421    4   31 041425    4   32 041447    4   34 041450    4   36 041451    4   37 041454
 4   39 041463    4   43 041504    4   45 041512    4   47 041515    4   48 041526    4   51 041534    4   52 041535
 4   54 041536    4   57 041544    4   61 041547    4   62 041551    4   63 041553    4   65 041554    4   68 041562
 4   71 041565    4   73 041567    4   74 041571    4   75 041573    4   77 041576    4   78 041603    4   80 041604
 4   81 041605    4   82 041610    4   83 041612    4   85 041615    4   86 041616    4   87 041625    4   88 041626
 4   89 041627    4   91 041633    4   92 041634    4   93 041651    4   95 041656    4   96 041663    4   98 041664
 4  100 041666    4  101 041673    4  103 041674    4  108 041677    4  110 041701    4  111 041704    4  113 041713
 4  114 041722    4  115 041724    4  116 041725    4  120 041733    4  123 041761    4  124 041763    4  127 041767
 4  129 041772    4  130 041777    4  132 042000    4  133 042001    4  134 042013    4  135 042022    4  137 042024
 4  139 042025    4  143 042027    4  144 042035    4  146 042043    4  148 042046    4  149 042051    4  150 042054
 4  154 042110    4  157 042114    4  159 042120    4  161 042155    4  162 042175    4  164 042220    4  165 042223
 4  169 042242    4  170 042252    4  171 042262    4  173 042270    4  174 042276    4  176 042277    4  178 042301
 4  180 042307    4  181 042323    4  183 042331    4  184 042336    4  186 042337    4  187 042341    4  188 042350
 4  238 042351    4  244 042353    4  245 042354    4  249 042364    4  250 042373    4  252 042414    4  253 042423
 4  255 042432    4  257 042442    4  258 042457    4  260 042466    4  262 042470    4  264 042501    4  265 042516
 4  266 042525    4  268 042526    4  270 042527    4  271 042540    4  272 042541    4  273 042544    4  274 042547
 4  275 042553    4  276 042556    4  277 042561    4  279 042573    4  281 042575    4  282 042576    4  283 042604
 4  285 042605    4  287 042612    4  288 042614    4  289 042632    4  290 042634    4  291 042645    4  292 042647
 4  294 042650    4  295 042652    4  296 042653    4  297 042660    4  298 042663    4  300 042724    4  303 042726
 4  304 042732    4  306 042735    4  307 042743    4  308 042747    4  309 042750    4  311 042751    4  313 042757
 4  314 042761    4  315 042762    4  316 042771    4  317 042772    4  318 042775    4  319 042777    4  321 043001
 5    5 043002    5   10 043004    5   43 043006    5   47 043016    5   49 043030    5   52 043043    5   56 043044
 5   59 043054    5   62 043067    5   63 043101    5   75 043102    5   78 043112    5   80 043124    5   81 043136
 5   82 043143    5   83 043145    5   87 043146    5   90 043156    5   92 043170    5   93 043202    5   94 043207
 5   95 043211    5   99 043212    5  102 043221    5  103 043224    5  104 043226    5  110 043227    5  113 043236
 5   12 043237    5   19 043241    5   20 043243    5   21 043246    5   22 043251    5   23 043303    5   24 043310
 5   25 043312    5   27 043313    5   28 043314    5   31 043316    5   34 043324    5   35 043326    5   36 043357
 5   37 043364    5   65 043365    5   68 043367    5   69 043377    5   71 043431    5   72 043433      4935 043434
   4939 043436      4940 043441      4942 043450      4943 043455      4946 043456      4953 043457      4954 043461
   4955 043500      4958 043501      4967 043502      4969 043505      4971 043510      4972 043515      4974 043516
   4975 043522      4980 043550      4981 043551      4982 043554      4983 043561      4984 043562      4985 043566
   4987 043571      4988 043574      4989 043575      4991 043577      4993 043630      4995 043636      4996 043637
   4997 043641      5000 043646      5001 043650      5002 043654      5003 043672      5005 043730      5007 043737
   5009 043743      5010 043745      5011 043747      5013 043750      5016 044010      5018 044012      5020 044031
   5021 044035      5023 044036      5026 044071      5028 044100      5031 044106      5034 044111      5035 044112
   5038 044117      5039 044121      5040 044143      5041 044147      5042 044150      5043 044151      5044 044155
   5045 044160      5076 044161      5079 044164      5080 044175      5081 044216      5082 044217      5085 044222
   5086 044233      5088 044254      5091 044260      5094 044261      5100 044264      5101 044270      5102 044272
   5103 044277      5104 044302      5105 044306      5108 044313      5111 044316      5112 044322      5113 044323
   5115 044324      5118 044327      5119 044333      5120 044334      5122 044340      5125 044343      5126 044347
   5128 044374      5130 044375      5132 044400      5133 044404      5134 044407      5136 044414      5137 044416
   5138 044422      5139 044425      5140 044426      5141 044427      5144 044432      5145 044441      5146 044442
   5149 044445      5150 044454      5151 044455      5154 044461      5156 044462      5159 044466      5162 044471
   5163 044514      5165 044515      5168 044520      5170 044525      5172 044565      5174 044567      5176 044614
   5177 044615      5180 044620      5181 044645      5183 044650      5185 044654      5187 044655      5191 044656
   5197 044661      5199 044662      5201 044666      5203 044667      5205 044671      5206 044674      5208 044700
   5209 044704      5210 044710      5212 044713      5214 044715      5218 044732      5220 044734      5223 044752
   5224 044753      5227 044756      5228 044760      5229 044764      5231 044772      5233 045020      5235 045046
   5236 045051      5237 045053      5046 045054      5052 045056      5054 045061      5056 045063      5057 045070
   5059 045072      5060 045074      5062 045101      5063 045103      5064 045105      5066 045115      5068 045125
   5069 045127      5070 045133


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
