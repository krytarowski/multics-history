	COMPILATION LISTING OF SEGMENT tedeval_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/18/84  0922.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
       11 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
       12 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       13 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       14 
       15 /*                                              _			       */
       16 /*    _|_              |                         |		       */
       17 /*     |      _      _ |    _            ___     |		       */
       18 /*     |     / \    / \|   / \   \   /   ___\    |		       */
       19 /*     |    (__/   (   |  (__/    \ /   /   |    |		       */
       20 /*     \_    \_/    \_/|   \_/     V    \__/|   _|_		       */
       21 /*                                                    -----		       */
       22 /*							       */
       23 
       24 /**** <<<<----- dcl_tedeval_.incl.pl1 tedeval_			       */
       25 tedeval_:				/* process evaluations	       */
       26       proc (adb_p, ain_p, ain_l, buf_ptr, ams_p, ams_l, result, msg, code);
       27 dcl (
       28     adb_p		ptr,		/* -> database		       */
       29     ain_p		ptr,		/* -> evaluation string	       */
       30     ain_l		fixed bin (21),	/*   length thereof		  [IN] */
       31 				/*   amount used up		 [OUT] */
       32     buf_ptr	ptr,		/* -> buffer control block	       */
       33     ams_p		ptr,		/* -> matched string in \g{...}      */
       34 				/*    null otherwise	       */
       35     ams_l		fixed bin (21),	/*  length of string in \g{...}      */
       36 				/* <0 in \{...}, 0 otherwise	       */
       37     result	char (500) var,	/* output string, if any	       */
       38     msg		char (168) var,	/* error message, if any	       */
       39     code		fixed bin (35)	/* return code		       */
       40     )		parm;		/* ----->>>>		       */
       41 
       42 /* stk(top) corresponds to the rightmost symbol in the production	       */
       43 /*  (rule,alternative) being "applied".				       */
       44 
       45 dcl 1 s1		like ls based (s1_ptr);
       46 dcl 1 s2		like ls based (s2_ptr);
       47 dcl 1 sr		like ls based (sr_ptr);
       48 dcl (s1_ptr, s2_ptr, sr_ptr) ptr;
       49 
       50 dcl ex_sw		bit (1);
       51 dcl ch2		char (1);
       52 
       53 dcl ind		fixed bin (21);
       54 dcl cat_p		ptr;
       55 dcl cat_l		fixed bin (21);
       56 dcl 1 catv	based (cat_p),
       57       2 link	ptr,		/* pointer to next temporary	       */
       58       2 len	fixed bin (21),
       59       2 text	char (cat_l refer (catv.len));
       60 dcl ii		fixed bin (21);
       61 dcl lval_ptr	ptr;
       62 dcl 1 val		based (lval_ptr),
       63       2 temp	ptr,		/* pointer to temp variable list     */
       64       2 version	fixed bin,
       65       2 avar	bit (18) aligned,
       66       2 spare	(123) bit (36) aligned,
       67       2 av	(-200:200) fixed bin (24),
       68       2 k		(-200:200) char (32) var,
       69       2 K		(-10:30) char (500) var,
       70       2 cata	area;
       71 dcl nextab	bit (18);
       72 dcl avar_len	fixed bin (21);
       73 dcl avar_ptr	ptr;
       74 dcl unary		bit (1);
       75 dcl char16	char (16) var;
       76 dcl 1 avar	based (avar_ptr),
       77       2 next	bit (18) aligned,
       78       2 name	char (16),
       79       2 type	fixed bin,
       80       2 num	fixed bin (35),
       81       2 txt_r	bit (18);		/* offset of catv if any	       */
       82 
       83 dcl alb		fixed bin static internal init (-200),
       84     aub		fixed bin static internal init (200),
       85     klb		fixed bin static internal init (-200),
       86     kub		fixed bin static internal init (200),
       87     Klb		fixed bin static internal init (-10),
       88     Kub		fixed bin static internal init (30),
       89     ns_string	char (256) var,
       90     ns_num	fixed bin;
       91 dcl define_area_	entry (ptr, fixed bin(35));
       92 dcl iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       93 dcl tedwhere_	entry (ptr);
       94 dcl conc_sw	bit (1);
       95 
       96       code = 1;			/* FAILURE.		       */
       97       dbase_p = adb_p;
       98       bp = dbase.eval_p;
       99       lval_ptr = b.cur.sp;
      100       if (lval_ptr = null())
      101       then do;
      102          call tedget_segment_ (dbase_p, b.cur.sp, b.cur.sn);
      103          lval_ptr = b.cur.sp;
      104          val.version = 1;
      105          val.temp = null ();
      106          val.avar = "0"b;
      107          ai.version = area_info_version_1;
      108          ai.extend = "0"b;
      109          ai.zero_on_alloc = "1"b;
      110          ai.zero_on_free = "0"b;
      111          ai.dont_free = "0"b;
      112          ai.no_freeing = "0"b;
      113          ai.owner = dbase.tedname;
      114          ai.size = sys_info$max_seg_size - 8901;
      115          ai.areap = addr (cata);
      116          call define_area_ (addr (ai), code);
      117          if (code ^= 0)
      118          then do;
      119 	  msg = "Error defining eval area.";
      120 	  return;
      121          end;
      122 dcl 1 ai		like area_info;
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      123 
      124 dcl sys_info$max_seg_size fixed bin ext static;
      125       end;
      126 
      127 
      128       bp = buf_ptr;
      129       conc_sw = "1"b;
      130 /****      IP = ain_p;		/* Point at the input.	       */
      131 /****      ti = 1;						       */
      132 /****      te = ain_l;					       */
      133 				/* Initialize variables.	       */
      134       do l = lbound (ls, 1) to hbound (ls, 1);
      135          ls.pt (l) = null ();
      136       end;
      137       ex_sw = "0"b;
      138       level = -1;
      139       lnl = 0;			/* where is last NL char	       */
      140       call ns_alt (ain_p, 1, ain_l);	/* setup level 0 execute string      */
      141       ind = 0;
      142       result = "";
      143       code = 0;
      144       unary = "0"b;
      145       if (substr (is, 1, 3) = "{?}")
      146       then do;
      147          ain_l = 3;
      148          call ioa_ ("Type ""help <eval>"" for more help");
      149          return;
      150       end;
      151 
  2     1 /**** Parser for tables created by LRK.				       */
  2     2 
  2     3 dcl iti		fixed bin;
  2     4 
  2     5 	current_state = 1;
  2     6 	lst, ps_top = 0;
  2     7 	la_put, la_get = 1;
  2     8 	la_ct = 0;
  2     9 
  2    10 /* The parsing loop. */
  2    11 NEXT:
  2    12 	if (current_state = 0)
  2    13 	then do;
  2    14 done_parse:
  2    15 finish:
  2    16 	   if db_eval
  2    17 	   then call ioa_$ioa_switch_nnl (db_output, " **FINI**^2/");
  2    18 	   code = 0;
  2    19 	   ain_l = nc - 1;
  2    20 	   return;
  2    21 	end;
  2    22 	current_table = current_state;
  2    23 	string (db_data) = "";
  2    24 	db_data.state = current_state;
  2    25 (subscriptrange):
  2    26 	goto CASE (DPDA.v1 (current_table));
  2    27 
  2    28 CASE (3): /*** Shared look */
  2    29 	current_table = DPDA.v2 (current_table);
  2    30 CASE (1): /**** Look. */
  2    31 	la_use = mod (la_get + la_need - 1, -lbound (ls, 1)) + 1;
  2    32 	if (la_need = -lbound (ls, 1))
  2    33 	then signal condition (lastk_ovflo);
  2    34 dcl lastk_ovflo	condition;
  2    35 	la_need = la_need + 1;
  2    36 	goto read_look;
  2    37 
  2    38 CASE (10):
  2    39 	current_table = DPDA.v2 (current_table);
  2    40 
  2    41 CASE (9):
  2    42 	db_data.type = "READ";
  2    43 	la_need = 1;
  2    44 	la_use = la_get;
  2    45 	goto read_look;
  2    46 CASE (2): /*** Stack and Shared read */
  2    47 	current_table = DPDA.v2 (current_table);
  2    48 
  2    49 CASE (0): /*** Stack and Read. */
  2    50 	db_data.type = "READ";
  2    51 	db_data.flag = "*";
  2    52 	la_need = 1;
  2    53 	la_use = la_get;
  2    54 	if (ps_top = hbound (parse_stack, 1))
  2    55 	then signal condition (pstk_ovflo);
  2    56 dcl pstk_ovflo	condition;
  2    57 	ps_top = ps_top + 1;	/* Top of  parsing stack.	       */
  2    58 	parse_stack (ps_top) = current_state; /* Stack the current state.  */
  2    59 	cur_lex_top (ps_top) = lst;	/* save cur lex top (for recovery)   */
  2    60 read_look:
  2    61 	do while (la_ct < la_need);	/* make sure enuf symbols available  */
  2    62 	   ls.symbol (-la_put) = scanner ();
  2    63 	   la_put = mod (la_put, -lbound (ls, 1)) + 1;
  2    64 	   la_ct = la_ct + 1;
  2    65 	end;
  2    66 	test_symbol = ls.symbol (-la_use);
  2    67 	if (test_symbol = 56) & (current_state ^= 1)
  2    68 	then do;			/* execute MACRO (bad news)	       */
  2    69 	   ps_top = ps_top + 1;
  2    70 	   parse_stack (ps_top) = current_state;
  2    71 	   next_state = -1;
  2    72 	   ind = ind + 2;
  2    73 	   goto got_symbol;
  2    74 	end;
  2    75 	else do i = current_table + 1
  2    76 	   to current_table + DPDA.v2 (current_table);
  2    77 	   if (DPDA.v1 (i) = test_symbol)
  2    78 	   then do;
  2    79 	      next_state = DPDA.v2 (i);
  2    80 	      goto got_symbol;
  2    81 	   end;
  2    82 	end;
  2    83 
  2    84 
  2    85 error:
  2    86 	if db_eval
  2    87 	then do;
  2    88 	   db_data.type = "ERR";
  2    89 	   db_data.data = getermc (test_symbol, la_get);
  2    90 	   call ioa_$ioa_switch_nnl (db_output, "^vx^a^/", ind,
  2    91 	      string (db_data));
  2    92 	end;
  2    93 	msg = "Vxx) Syntax- eval. ";
  2    94 err_text:
  2    95 	iti = input.loc1 (0);
  2    96 	input.loc1 (level) = nc;
  2    97 	input.loc0 (level) = lgnc;
  2    98 	msg = msg || """";
  2    99 	do i = 0 to level;
  2   100 	   if (i ^= 0)
  2   101 	   then msg = msg || "
  2   102 	";
  2   103 	   msg = msg || substr (input.pt (i) -> is,
  2   104 	      input.loc0 (i), input.loc1 (i) - input.loc0 (i));
  2   105 	end;
  2   106 	msg = msg || """";
  2   107 err_ret:
  2   108 	code = 10;
  2   109 	return;
  2   110 
  2   111 got_symbol:
  2   112 	if db_eval
  2   113 	then do;
  2   114 	   if (next_state < 0)	/* is this a look-ahead state?       */
  2   115 	   then do;
  2   116 	      db_data.type = "LK01";
  2   117 	      db_look = la_need;
  2   118 	      db_data.data = geterm (test_symbol, 0);
  2   119 				/* 0 means display only terminal     */
  2   120 				/*  "name" on look-ahead	       */
  2   121 /****           if (la_need = 1) then db_data.flag = "*";		       */
  2   122 	   end;
  2   123 	   else do;
  2   124 	      db_data.data = getermc (test_symbol, la_get);
  2   125 				/* display terminal "name" and data, */
  2   126 				/*  if available		       */
  2   127 /****           db_data.flag = "*";				       */
  2   128 	   end;
  2   129 	   call ioa_$ioa_switch_nnl (db_output, "^vx^a^/", ind,
  2   130 	      string (db_data));
  2   131 	end;
  2   132 	current_state = next_state;
  2   133 	if (current_state < 0) then do; /* Transition is look-ahead state. */
  2   134 	   current_state = -current_state;
  2   135 	end;
  2   136 	else do;
  2   137 	   if (lst = hbound (ls, 1))
  2   138 	   then signal condition (lstk_ovflo);
  2   139 dcl lstk_ovflo	condition;
  2   140 	   lst = lst + 1;
  2   141 	   ls (lst) = ls (-la_get);
  2   142 	   if db_eval then call dump_ls;
  2   143 	   la_get = mod (la_get, -lbound (ls, 1)) + 1;
  2   144 	   la_ct = la_ct - 1;
  2   145 	end;
  2   146 	goto NEXT;
  2   147 
  2   148 CASE (7):
  2   149 	msg = "CASE7 encountered.";
  2   150 	goto err_text;
  2   151 
  2   152 CASE (8):
  2   153 	msg = "CASE8 encountered.";
  2   154 	goto err_text;
  2   155 
  2   156 CASE (4): /*** Apply state. */
  2   157 CASE (5): /*** Apply single */
  2   158 CASE (6): /*** Apply Shared */
  2   159 	la_need = 1;
  2   160 	p_del = DPDA.v1 (current_table + 1);
  2   161 	l_del = DPDA.v2 (current_table + 1);
  2   162 	rulen = DPDA.v1 (current_table + 2);
  2   163 	altn = DPDA.v2 (current_table + 2);
  2   164 	if (rulen > 0)
  2   165 	then call ted_vtab_ (rulen, altn);
  2   166 	if db_eval
  2   167 	then do;
  2   168 	   db_data.type = "APLY";
  2   169 	   db_data.data = "(";
  2   170 	   call ioa_$ioa_switch_nnl (db_output, "^vx^a^i ^i)", ind,
  2   171 	      string (db_data), rulen, altn);
  2   172 	end;
  2   173 	if ex_sw
  2   174 	then do;
  2   175 	   if db_eval
  2   176 	      then call ioa_$ioa_switch_nnl (db_output, "[ex]");
  2   177 	   p_del = p_del + 2;
  2   178 	   l_del = l_del + 1;
  2   179 	end;
  2   180 	if db_eval
  2   181 	then do;
  2   182 	   call ioa_$ioa_switch_nnl (db_output, "^-pd=^i ld=^i(",
  2   183 	      p_del, l_del);
  2   184 	   do t = ps_top to ps_top - p_del + 1 by -1;
  2   185 	      call ioa_$ioa_switch_nnl (db_output, " ^d",
  2   186 	         parse_stack (t));
  2   187 	   end;
  2   188 	   call ioa_$ioa_switch_nnl (db_output, ")^/");
  2   189 	end;
  2   190 	if (DPDA.v1 (current_table + 1) = -1) /* Empty rule	       */
  2   191 	then parse_stack (ps_top + 1) = current_table;
  2   192 	ps_top = ps_top - p_del;	/* drop "p_del" parse stack states.  */
  2   193 	lst = lst - l_del;		/* drop "l_del" lex stack states     */
  2   194 	if db_eval then call dump_ls;
  2   195 /**** l_del is (number of symbols in production)-1		       */
  2   196 dump_ls: proc;
  2   197      call ioa_
  2   198         ("ls(^i)=^p,^3i [^i] ^i-^[aexp ^s^i^;cat ^p,^i,^i^;lexp ^s^i^]",
  2   199         lst, ls(lst).symptr, ls(lst).symlen, ls(lst).symbol, ls(lst).type,
  2   200         ls(lst).type+1, ls(lst).pt, ls(lst).num, ls(lst).loc);
  2   201   end dump_ls;
  2   202 	if ex_sw
  2   203 	then do;
  2   204 	   ex_sw = "0"b;
  2   205 	   current_state = parse_stack (ps_top + 1);
  2   206 	   ind = ind - 2;
  2   207 	   goto NEXT;
  2   208 	end;
  2   209 	if (DPDA.v1 (current_state) = 6)
  2   210 	then do;
  2   211 	   current_table = DPDA.v2 (current_table + 3);
  2   212 	end;
  2   213 	jaf = parse_stack (ps_top);
  2   214 	do i = current_table + 4 to current_table + DPDA.v2 (current_table);
  2   215 	   if (DPDA.v1 (i) = jaf)
  2   216 	   then do;
  2   217 	      current_state = DPDA.v2 (i);
  2   218 	      goto NEXT;
  2   219 	   end;
  2   220 	end;
  2   221 	current_state = DPDA.v2 (current_table + 3);
  2   222 	goto NEXT;
  2   223 
  2   224 dcl (addr, mod, fixed) builtin;
  2   225 dcl db_look	pic "99" defined (db_data.type) pos (3);
  2   226 dcl 1 db_data,
  2   227       2 flag	char (1),		/* "*" means stacked	       */
  2   228       2 state	pic "zzz9",
  2   229       2 fil1	char (2),
  2   230       2 type	char (6),
  2   231       2 data	char (100);
  2   232 dcl ioa_$ioa_switch_nnl entry options (variable);
  2   233 dcl iox_$user_output ptr ext static;
  2   234 dcl 1 ls		(-4:50),		/* -4:-1   look-ahead stack (FIFO)   */
  2   235 				/*  1:50   lexical stack (LIFO)      */
  2   236       2 symptr	ptr,		/* pointer to symbol (must be valid) */
  2   237       2 symlen	fixed bin (21),	/* length of symbol (may be 0)       */
  2   238       2 line	fixed bin (21),	/* line where symbol begins	       */
  2   239       2 symbol	fixed bin (21),	/* encoding of symbol	       */
  2   240       2 pt	ptr,
  2   241       2 mask	bit (36),
  2   242       2 type	fixed bin,	/* 0-aexp 1-cat 2-lexp	       */
  2   243       2 num	fixed bin (21),
  2   244       2 loc	fixed bin (21);
  2   245 
  2   246 dcl (ABREV	init (-1),
  2   247     AEXP		init (0),
  2   248     CAT		init (1),
  2   249     LEXP		init (2)
  2   250     )		fixed bin (21) int static options (constant);
  2   251 dcl lst		fixed bin (21);	/* location of top of lexical stack  */
  2   252 dcl cur_lex_top	(100) fixed bin;	/* current lex top stack	       */
  2   253 				/*  (with parse_stack)	       */
  2   254 dcl parse_stack	(100) fixed bin;	/* parse stack		       */
  2   255 dcl altn		fixed bin (21);	/* APPLY alternative number	       */
  2   256 dcl current_state	fixed bin;	/* number of current state	       */
  2   257 dcl test_symbol	fixed bin;	/* encoding of current symbol	       */
  2   258 dcl current_table	fixed bin;	/* number of current table	       */
  2   259 dcl i		fixed bin (21);	/* temp			       */
  2   260 dcl la_ct		fixed bin;	/* # terms in look-ahead stack       */
  2   261 dcl la_get	fixed bin;	/* look_ahead stack get next symbol  */
  2   262 dcl la_need	fixed bin;	/* # look-ahead symbols needed       */
  2   263 dcl la_put	fixed bin;	/* look_ahead stack put next symbol  */
  2   264 dcl la_use	fixed bin (22);	/* look-ahead stack test symbol      */
  2   265 dcl next_state	fixed bin;	/* # next state		       */
  2   266 dcl nil_sym	fixed bin;
  2   267 dcl ps_top	fixed bin;	/* top of parse stack	       */
  2   268 dcl recov_msg	char (150) var;
  2   269 dcl rulen		fixed bin (21);	/* APPLY rule number	       */
  2   270 dcl t		fixed bin (21);
  2   271 dcl jaf		fixed bin (21);
  2   272 dcl ioa_		entry options (variable);
  2   273 dcl (l_del, p_del)	fixed bin;
  2   274 
  2   275 geterm: proc (idx, ids) returns (char (100) var);
  2   276 
  2   277 dcl (idx, ids)	fixed bin;
  2   278 dcl temp		char (100) var;
  2   279 dcl c_str		char (20000) based;
  2   280 
  2   281       temp = "";
  2   282 get_rest:
  2   283       if (ids > 0)
  2   284       then if (ls (-ids).symlen > 0)
  2   285 	 then do;
  2   286 	    temp = temp || """";
  2   287 	    temp = temp || substr (ls (-ids).symptr -> c_str,
  2   288 	       1, min (50, ls (-ids).symlen));
  2   289 	    temp = temp || """";
  2   290 	    return (temp);
  2   291 	 end;
  2   292       if (idx = 0)
  2   293       then temp = "--EOI--";
  2   294       else temp = substr (TC, TL.pt (idx), TL.ln (idx));
  2   295       return (temp);
  2   296 getermc: entry (idx, ids) returns (char (100) var);
  2   297 
  2   298       if (idx = 0)
  2   299       then temp = "--EOI--";
  2   300       else temp = substr (TC, TL.pt (idx), TL.ln (idx));
  2   301       temp = temp || " ";
  2   302       goto get_rest;
  2   303    end;
      152 
      153 
      154 scanner: proc returns (fixed bin (21));
      155 
      156 dcl ret_val	fixed bin;	/* hold ret val during unary check   */
      157 
      158 /*   Return one of the following encodings:
      159*   0	EOI	End Of Input.
      160*   1	<integer>	0->9...
      161*   2	<string>	pl1 string.
      162*   3	]	Array right bracket.
      163*   4	,
      164*   5	{
      165*   6	}
      166*   7	(
      167*   8	)
      168*   9	:
      169*   10	;
      170*   11	:=	Assignment.
      171*   12	*	Multiply.
      172*   13	/
      173*   14	|	Mod.
      174*   15	+
      175*   16	-
      176*   17	<
      177*   18	>
      178*   19	=
      179*   20	<=
      180*   21	>=
      181*   22	^=
      182*   23	a[	Array of numbers.
      183*   24	k[	Array of short strings.
      184*   25	K[	Array of long strings.
      185*   26	Ks Kt	addressed string
      186*   27	be	buffer end, last byte in buffer
      187*   28	bn	buffer name
      188*   29	fl	function, length
      189*   30	fs	function, substr
      190*   31	lb	line begin, first line addressed
      191*   32	le	linne end, last line addressed
      192*   33	sb	string begin, first byte addressed
      193*   34	se	string end, last byte addressed
      194*   35	da	dump a-var
      195*   36	dk	dump k-var
      196*   37	dK	dump K-var
      197*   38	dn	directory name
      198*   39	en	entry name
      199*   40	sn	subfile name
      200*   41	fak	function, a to k
      201*   42	fka	function, k to a
      202*   43	em	error message
      203*   44	fi	function, index
      204*   45	fir	function, index-reverse
      205*   46	fv	function, verify
      206*   47	fvr	function, verify-reverse
      207*   48	ff	function, find
      208*   49	ffr	function, find-reverse
      209*   50	fln	function, linenumber
      210*   51	sk	component kind
      211*   52	J	special compare indicator
      212*   53	Kl	line reference
      213*   54	Kb	buffer reference
      214*   55	if	if command
      215*   56	ex	execute MACRO
      216*   57	ag	number of arguments to ted
      217*   58	cs	collate9() value
      218*   59	<set>	set description
      219*   60	pn	parameter number (% call)
      220*   61	p[	parameter reference (% call)
      221*   62	fmx	function, max
      222*   63	fmn	function, min
      223*   64	frs	function, rearrange string
      224*   65	||	concatenate
      225*   66	<var>	variable
      226*   67     d (   	dump function
      227*   68	mct (	match count (substitute)
      228*   69	emt (	error message text
      229*   70	emc ( 	error message code
      230*   71	<u+>	unary plus
      231*   72	<u->	unary minus
      232**/
      233 
      234 
      235 MORE:
      236       ls.symptr (-la_put) = addr (ib (nc));
      237       ls.symlen (-la_put) = 0;
      238       ls.symbol (-la_put) = 0;
      239       ls.type (-la_put) = 0;
      240       ls.num (-la_put) = 0;
      241       ls.loc (-la_put) = 0;
      242       if (nc > te)			/* last char may not be a NL	       */
      243       then do;
      244          if (level = 0)
      245          then do;			/* no more input		       */
      246 	  test_symbol = 0;
      247 	  goto error;
      248          end;
      249          level = level - 1;
      250          IP = input.pt (level);
      251          lgnc = input.loc0 (level);
      252          nc = input.loc1 (level);
      253          te = input.loc2 (level);
      254          goto MORE;
      255       end;
      256       fc = nc;
      257       ret_val = val_mad (fixed (ib (nc), 9));
      258       nc = nc + 1;
      259       if (nc <= te)
      260       then ch2 = ic (nc);
      261       else ch2 = " ";
      262       i = verify (substr (is, nc - 1), azAZ09);
      263       char16 = substr (is, nc - 1, i - 1);
      264 (subscriptrange): goto LS (ret_val);
      265 
      266 LS (0):				/* Characters that are skipped. */
      267       if ic (fc) > " " then goto error;
      268       goto MORE;
      269 LS (1):				/* <digit>. */
      270       k = nc - 1;
      271       ns_num = index ("0123456789", ic (nc - 1)) - 1;
      272       do nc = nc to te while (val_mad (fixed (ib (nc), 9)) = 1);
      273          ns_num = (10 * ns_num) + index ("0123456789", ic (nc)) - 1;
      274       end;
      275       ls.num (-la_put) = ns_num;
      276       ls.symlen (-la_put) = nc - k;
      277       return (1);
      278 
      279 LS (2):				/* <string>. */
      280       j = te - nc + 1;
      281       ns_string = "";
      282       do while (j > 0);
      283          k = index (substr (is, nc, j), """");
      284          if k < 1 then j = 0;
      285          else do;
      286 	  if k > 1 then ns_string = ns_string || substr (is, nc, (k - 1));
      287 	  ls.symlen (-la_put) = k;
      288 	  nc = nc + k;		/* The location of the char after ". */
      289 	  if nc > te then return ((STRING_TYPE ()));
      290 	  if ic (nc) = """"		/* "Internal" quote.	       */
      291 	  then do;
      292 	     ns_string = ns_string || """"; /* Catenate in one quote.      */
      293 	     nc = nc + 1;
      294 	     j = te - nc + 1;
      295 	  end;
      296 	  else return ((STRING_TYPE ()));
      297          end;
      298       end;
      299       msg = "Vmq) Missing "".";
      300       goto err_ret;
      301 
      302 LS (3): return (3);			/* ] */
      303 
      304 LS (4):				/* , */
      305 LS (5):				/* { */
      306 LS (7):				/* ( */
      307 LS (10):				/* ; */
      308 LS (19):				/* = */
      309 unary_check:
      310       do nc = nc to te while (ic (nc) < "!");
      311       end;
      312       if (ic (nc) = "+") | (ic (nc) = "-")
      313       then unary = "1"b;
      314       return (ret_val);
      315 
      316 LS (6): return (6);			/* } */
      317 LS (8): return (8);			/* ) */
      318 
      319 LS (9):				/* :. */
      320       if (ch2 = "=") then do; nc = nc + 1; ret_val = 11; end;
      321       goto unary_check;
      322 
      323 LS (11):				/* p */
      324       if (char16 = "pn") then do; nc = nc + 1; return (60); end;
      325       ret_val = 61;			/* might be p[ */
      326       goto LS (24);
      327 
      328 
      329 LS (12): return (12);		/* * */
      330 LS (13): return (13);		/* / */
      331 
      332 LS (14):				/* | */
      333       if ch2 = "|" then do; nc = nc + 1; return (65); end;
      334       return (14);
      335 
      336 LS (15):				/* + */
      337 LS (16):				/* - */
      338       if unary
      339       then do;
      340          unary = "0"b;
      341          ret_val = ret_val + 56;
      342       end;
      343       return (ret_val);
      344 
      345 LS (17):				/* <. */
      346       if ch2 = "=" then do; nc = nc + 1; ret_val = 20; end;
      347       goto unary_check;
      348 
      349 LS (18):				/* >. */
      350       if ch2 = "=" then do; nc = nc + 1; ret_val = 21; end;
      351       goto unary_check;
      352 
      353 LS (21):				/* azAZ */
      354 alpha:
      355       nc = nc + length (char16) - 1;
      356       ls.symlen (-la_put) = length (char16);
      357       nextab = val.avar;
      358       do avar_ptr = pointer (lval_ptr, nextab)
      359          repeat (pointer (lval_ptr, nextab))
      360          while (nextab ^= "0"b);
      361          if (avar.txt_r = "0"b)
      362          then cat_p = null ();
      363          else cat_p = pointer (lval_ptr, avar.txt_r);
      364          if (char16 = "abbreviations") & (avar.type = ABREV)
      365          then call ioa_ ("^8a  ^a", avar.name, catv.text);
      366          else if (char16 = avar.name)
      367          then do;
      368 	  if (avar.type = ABREV)
      369 	  then do;
      370 	     call ns_alt (addr (catv.text), 1, catv.len);
      371 	     goto MORE;
      372 	  end;
      373 	  ls.pt (-la_put) = avar_ptr;
      374 	  return (66);		/* defined variable		       */
      375          end;
      376          nextab = avar.next;
      377       end;
      378       if (char16 = "abbreviations")
      379       then goto MORE;
      380       ls.pt (-la_put) = null ();
      381       return (66);			/* undefined var		       */
      382 
      383 LS (22):				/* ^ */
      384       if ch2 = "=" then do; nc = nc + 1; goto unary_check; end;
      385       goto error;
      386 
      387 LS (25):				/* K[ or Kt. */
      388       if (char16 = "Kt") then do; nc = nc + 1; return (26); end;
      389       if (char16 = "Ks") then do; nc = nc + 1; return (26); end;
      390       if (char16 = "Kl") then do; nc = nc + 1; return (53); end;
      391       if (char16 = "Kb") then do; nc = nc + 1; return (54); end;
      392       if ("0"b) then do;
      393 LS (23):				/* a. */
      394          if (char16 = "ag") then do; nc = nc + 1; return (57); end;
      395       end;
      396 LS (24):				/* k */
      397       do nc = nc to te while (ic (nc) < "!");
      398       end;
      399       if nc <= te then if ic (nc) = "["
      400 	 then do;
      401 	    nc = nc + 1;
      402 	    goto unary_check;
      403 	 end;
      404       goto alpha;
      405 
      406 LS (27):				/* "b". */
      407       if (char16 = "be") then do; nc = nc + 1; return (27); end;
      408       if (char16 = "bn") then do; nc = nc + 1; return (28); end;
      409       goto alpha;
      410 
      411 LS (28):				/* c */
      412       if (char16 = "cs") then do; nc = nc + 1; return (58); end;
      413       goto alpha;
      414 
      415 dcl fxx		(14) char (03) int static init (
      416 		"fl ", "fs ", "fak", "fka", "fi ", "fir", "fv ", "fvr",
      417 		"ff ", "ffr", "fln", "fmx", "fmn", "frs");
      418 dcl fvv		(14) fixed bin int static init (
      419 		00029, 00030, 00041, 00042, 00044, 00045, 00046, 00047,
      420 		00048, 00049, 00050, 00062, 00063, 00064);
      421 LS (29):				/* "f". */
      422       do i = 1 to 14;
      423          if (char16 = fxx (i))
      424          then do;
      425 	  k = fvv (i);
      426 test_for_paren:
      427 	  ii = nc + length (char16) - 1;
      428 	  if (ic (ii) ^= "(")
      429 	  then goto alpha;
      430 	  nc = ii;
      431 	  return (k);
      432          end;
      433       end;
      434       goto alpha;
      435 
      436 LS (31):				/* "l". */
      437       if (char16 = "lb") then do; nc = nc + 1; return (31); end;
      438       if (char16 = "le") then do; nc = nc + 1; return (32); end;
      439       goto alpha;
      440 
      441 LS (33):				/* "s". */
      442       if (char16 = "sb") then do; nc = nc + 1; return (33); end;
      443       if (char16 = "se") then do; nc = nc + 1; return (34); end;
      444       if (char16 = "sn") then do; nc = nc + 1; return (40); end;
      445       if (char16 = "sk") then do; nc = nc + 1; return (51); end;
      446       goto alpha;
      447 
      448 LS (35):				/* "d". */
      449       if (char16 = "da") then do; nc = nc + 1; return (35); end;
      450       if (char16 = "dk") then do; nc = nc + 1; return (36); end;
      451       if (char16 = "dK") then do; nc = nc + 1; return (37); end;
      452       if (char16 = "dn") then do; nc = nc + 1; return (38); end;
      453       k = 67;
      454       goto test_for_paren;
      455 
      456 LS (36):				/* "e". */
      457       if (char16 = "en") then do; nc = nc + 1; return (39); end;
      458       if (char16 = "em") then do; nc = nc + 1; return (43); end;
      459 /**** if (char16 = "ex") then do; nc = nc + 1; return (56); end;	       */
      460       if (char16 = "emt") then do; k = 69; goto test_for_paren; end;
      461       if (char16 = "emc") then do; k = 70; goto test_for_paren; end;
      462       goto alpha;
      463 
      464 LS (37):				/* J */
      465       if (char16 = "J") then return (52);
      466       goto alpha;
      467 
      468 LS (38):				/* i */
      469       if (char16 = "if") then do; nc = nc + 1; return (55); end;
      470       goto alpha;
      471 
      472 LS (39):				/* S */
      473       if (ch2 ^= "(") then goto alpha;
      474       ls.mask (-la_put) = "0"b;
      475       ls.symlen (-la_put) = index (substr (is, nc - 1, te - nc), ")");
      476       nc = nc + 1;
      477       do while ("1"b);
      478 
      479 /*	A alphabetic	a->z_A->Z
      480*   N numeric		0->9
      481*   U upper case	A->Z
      482*   L lower case	a->z
      483*   M carriage motion	BSP HT NL VT FF SP
      484*   O octal		0->7
      485*   X hex		0->9a->fA->F
      486*   g graphic		!->~
      487**/
      488          k = index ("ANULMOXGA)anulmoxga)", ic (nc)); /* the last A is for future expansion */
      489          if (k = 0)
      490          then goto error;
      491          if (k > 10)
      492          then k = k - 10;
      493          nc = nc + 1;
      494          if (k = 10)
      495          then return (59);
      496          substr (ls.mask (-la_put), k, 1) = "1"b;
      497       end;
      498 
      499 /* NEVER gets here */
      500 
      501 LS (40):				/* m */
      502       if (char16 = "mct") then do; k = 68; goto test_for_paren; end;
      503       goto alpha;
      504 
      505 
      506 dcl azAZ09	char (63) int static init (
      507 		"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
      508 dcl (k, j)	fixed bin (21);
      509 dcl val_mad	(0:511) fixed bin (8) unaligned static internal init (
      510 
      511 /* "mad" array initialized to:
      512*   '000'777	0
      513*   09	1
      514*   "	2
      515*   ]	3
      516*   ,	4
      517*   {	5
      518*   }	6
      519*   (	7
      520*   )	8
      521*   :	9
      522*   ;	10
      523*   *	12
      524*   /	13
      525*   |	14
      526*   +	15
      527*   -	16
      528*   <	17
      529*   >	18
      530*   =	19
      531*   az	21
      532*   AZ	21
      533*   ^	22
      534*   a	23
      535*   k	24
      536*   K	25
      537*   b	27
      538*   c	28
      539*   f	29
      540*   l	31
      541*   p	11
      542*   s	33
      543*   d	35
      544*   e	36
      545*   J	37
      546*   i	38
      547*   S	39
      548*   m	40
      549*
      550**/
      551 		(34) 0, 2, (5) 0, 7, 8, 12, 15, 4, 16, 0, 13, (10) 1, 9,
      552 		10, 17, 19, 18, (2) 0, (9) 21, 37, 25, (7) 21, 39, (7) 21,
      553 		(2) 0, 3, 22, (2) 0, 23, 27, 28, 35, 36, 29, (2) 21, 38,
      554 		21, 24, 31, 40, (2) 21, 11, 21, 21, 33, (7) 21, 5, 14, 6,
      555 		(386) 0);
      556 ns_alt: entry (ipt, ilc, iln);
      557 
      558 dcl ipt		ptr,		/* pointer to command string */
      559     ilc		fixed bin (21),	/* beginning location */
      560     iln		fixed bin (21);	/* length */
      561 
      562       if (level = 5)
      563       then do;
      564          ain_l = input.loc1 (1);
      565          msg = "Vlv) Evaluation depth > 5.";
      566          goto err_ret;
      567       end;
      568       if (level >= 0)
      569       then do;
      570          input.pt (level) = IP;
      571          input.loc0 (level) = lgnc;
      572          input.loc1 (level) = nc;
      573          input.loc2 (level) = te;
      574       end;
      575       level = level + 1;
      576       input.pt (level), IP = ipt;
      577       input.loc0 (level), lgnc,
      578          input.loc1 (level), nc = ilc;
      579       input.loc2 (level), te = ilc + iln - 1;
      580       return;
      581    end scanner;
      582 dcl level		fixed bin (21);
      583 dcl 1 input	(0:5),
      584     2 pt ptr,
      585     2 loc0 fixed bin (21),
      586     2 loc1 fixed bin (21),
      587     2 loc2 fixed bin (21);
      588 
      589 
      590 
  3     1 /* -order	<integer>
  3     2*	<string>
  3     3*	]
  3     4*	,
  3     5*	{
  3     6*	}
  3     7*	(
  3     8*	)
  3     9*	:
  3    10*	;
  3    11*	:=
  3    12*	*
  3    13*	/
  3    14*	'|
  3    15*	+
  3    16*	-
  3    17*	'<
  3    18*	'>
  3    19*	=
  3    20*	'<=
  3    21*	'>=
  3    22*	^=
  3    23*	a[
  3    24*	k[
  3    25*	K[
  3    26*	Ks
  3    27*	be
  3    28*	bn
  3    29*	fl
  3    30*	fs
  3    31*	lb
  3    32*	le
  3    33*	sb
  3    34*	se
  3    35*	da
  3    36*	dk
  3    37*	dK
  3    38*	dn
  3    39*	en
  3    40*	sn
  3    41*	fak
  3    42*	fka
  3    43*	em
  3    44*	fi
  3    45*	fir
  3    46*	fv
  3    47*	fvr
  3    48*	ff
  3    49*	ffr
  3    50*	fln
  3    51*	sk
  3    52*	J
  3    53*	Kl
  3    54*	Kb
  3    55*	if
  3    56*	ex
  3    57*	ag
  3    58*	cs
  3    59*	<set>
  3    60*	pn
  3    61*	p[
  3    62*	fmx
  3    63*	fmn
  3    64*	frs
  3    65*	'|'|
  3    66*	<var>
  3    67*	d
  3    68*	mct
  3    69*	emt
  3    70*	emc
  3    71*	<u+>
  3    72*	<u->
  3    73*-table ted_eval_t_.incl.pl1
  3    74*-tl
  3    75*-alm
  3    76*-sem ted_eval_.incl.pl1
  3    77*-parse */
  3    78 ted_vtab_:			proc(rule_number,alternative_number);
  3    79 	goto rule( rule_number);
  3    80 
  3    81 alloc:	proc;
  3    82 
  3    83 	allocate catv in (cata);
  3    84 	catv.link = val.temp;
  3    85 	val.temp = cat_p;
  3    86 	sr.pt = addr(catv.text);
  3    87 	sr.loc = 1;
  3    88 	sr.num = cat_l;
  3    89 	sr.type = CAT;
  3    90 
  3    91 end;
  3    92 
  3    93 
  3    94 /* <val>	::= <line> ! */
  3    95 /* <val>	::= <exec> ! */
  3    96 rule(0002):
  3    97 	ex_sw = "1"b;
  3    98 	return;
  3    99 
  3   100 dcl	comp	bit(3);
  3   101 dcl	i	fixed bin(21);
  3   102 dcl	j	fixed bin(21);
  3   103 dcl	mc	char(1);
  3   104 dcl	cv	char(24) var;
  3   105 
  3   106 /* <line>	::= { <parts> <lpart> }	! */;
  3   107 rule(0003):
  3   108 
  3   109 /* <line>	::= { <lpart> }	! */;
  3   110 rule(0004):
  3   111 
  3   112 /* <line>	::= { <parts> }	! */;
  3   113 rule(0005):
  3   114 
  3   115 /* <line>	::= { }	! */
  3   116 rule(0006):				/* release all temp variables */
  3   117 dcl  tp ptr;
  3   118 	do while (val.temp ^= null());
  3   119 	     tp = val.temp;
  3   120 	     val.temp = tp->catv.link;
  3   121 	     free tp->catv;
  3   122 	end;
  3   123 	goto finish;
  3   124 
  3   125 /* <parts>	::= <parts> <part>	! */;
  3   126 
  3   127 /* <parts>	::= <part>	! */
  3   128 
  3   129 /* <part>	::= <cat>:
  3   130*	  | <lexp>:	! */;
  3   131 rule(0009):
  3   132 
  3   133 /* <part>	::= <cat>;
  3   134*	  | <lexp>;	! */;
  3   135 rule(0010):
  3   136 dcl NL char(1)int static init("
  3   137 ");
  3   138           call make(CAT,lst-1);
  3   139 	call iox_$put_chars(iox_$user_output,addr(ls.pt(lst-1)->ic(ls.loc(lst-1))),ls.num(lst-1),0);
  3   140 	if (rule_number = 0010)
  3   141 	then call iox_$put_chars(iox_$user_output,addr(NL),1,0);
  3   142 	lgnc = nc;
  3   143 	return;
  3   144 
  3   145 /* <lpart>	::= <cat>
  3   146*	  | <lexp>	! */;
  3   147 rule(0011):
  3   148           call make(CAT, lst);
  3   149 	result = substr(ls.pt(lst)->is,ls.loc(lst),ls.num(lst));
  3   150 	return;
  3   151 
  3   152 /* <part>	::= <assign>;	! */;
  3   153 rule(0012):
  3   154 	lgnc = nc;
  3   155 	return;
  3   156 
  3   157 /* <part>	::= da ;	! */;
  3   158 rule(0013):
  3   159 	ns_string = "a";
  3   160 	call vdump;
  3   161 	lgnc = nc;
  3   162 	return;
  3   163 
  3   164 /* <part>	::= dk ;	! */;
  3   165 rule(0014):
  3   166 	ns_string = "k";
  3   167           call vdump;
  3   168 	lgnc = nc;
  3   169 	return;
  3   170 
  3   171 /* <part>	::= dK ;	! */;
  3   172 rule(0015):
  3   173           ns_string = "K";
  3   174           call vdump;
  3   175 	lgnc = nc;
  3   176 	return;
  3   177 
  3   178 /* <part>	::= d ( <cat> ) ; ! */
  3   179 rule(0016):
  3   180 	s1_ptr = addr(ls(lst-2));
  3   181 	ns_string = substr (s1.pt->is,s1.loc,s1.num);
  3   182           call vdump;
  3   183 	lgnc = nc;
  3   184 	return;
  3   185  vdump: proc;
  3   186                do ii = 1 to length(ns_string);
  3   187 		ch2 = substr (ns_string, ii, 1);
  3   188 		if (ch2 = "a")
  3   189 		then do i = alb to aub;
  3   190 		     if (av(i) ^= 0)
  3   191 		     then call ioa_("a[^4d] = ^d",i,av(i));
  3   192 		end;
  3   193 		else if (ch2 = "k")
  3   194 		then do i = klb to kub;
  3   195 		     if (k(i) ^= "")
  3   196 		     then call ioa_("k[^4d] = ""^va""",i,length(k(i)),k(i));
  3   197 		end;
  3   198 		else if (ch2 = "K")
  3   199 		then do i = Klb to Kub;
  3   200 		     if (K(i) ^= "")
  3   201 		     then call ioa_("K[^4d] = ""^va""",i,length(K(i)),K(i));
  3   202 		end;
  3   203 		else if (ch2 = "v")
  3   204 		then do;
  3   205 		     next_avar = val.avar;
  3   206 		     do avar_ptr = pointer (lval_ptr, next_avar)
  3   207 			repeat (pointer (lval_ptr, next_avar))
  3   208 			while (next_avar ^= "0"b);
  3   209 			next_avar = avar.next;
  3   210 			if (avar.type = AEXP)
  3   211 			then call ioa_ ("^a = ^i", avar.name, avar.num);
  3   212 			else if (avar.type = LEXP)
  3   213 			then call ioa_ ("^a = ^[true^;false^]",
  3   214 			     avar.name, (avar.num^=0));
  3   215 			else if (avar.type = CAT)
  3   216 			then do;
  3   217 			     cat_p = pointer (lval_ptr, avar.txt_r);
  3   218 			     call ioa_ ("^a = ""^va""", avar.name,
  3   219 				length (catv.text), catv.text);
  3   220 			end;
  3   221 		     end;
  3   222 		end;
  3   223 		else do;
  3   224 		     msg = "Vds) Invalid dump specifier ";
  3   225 		     goto err_text;
  3   226 		end;
  3   227 	     end;
  3   228 	end;
  3   229 
  3   230 /* <lpart>	::= <assign>	! */
  3   231 
  3   232 
  3   233 /* <assign>	::= a[ <cat> ] := <cat>	! */;
  3   234 rule(0018):
  3   235           call make(AEXP,lst-3);
  3   236           call make(AEXP,lst);
  3   237 	av(cka(ls.num(lst-3))) = ls.num(lst);
  3   238 	ls(lst-4) = ls(lst);
  3   239 	return;
  3   240 
  3   241 /* <assign>	::= k[ <cat> ] := <cat>	! */;
  3   242 rule(0019):
  3   243           call make(AEXP,lst-3);
  3   244           call make(CAT,lst);
  3   245 	k(ckk(ls.num(lst-3))) = substr(ls.pt(lst)->is,ls.loc(lst),ls.num(lst));
  3   246 	ls(lst-4) = ls(lst);
  3   247 	return;
  3   248 
  3   249 /* <assign>	::= K[ <cat> ] := <cat>	! */;
  3   250 rule(0020):
  3   251           call make(AEXP,lst-3);
  3   252           call make(CAT,lst);
  3   253 	K(ckK(ls.num(lst-3))) = substr(ls.pt(lst)->is,ls.loc(lst),ls.num(lst));
  3   254 	ls(lst-4) = ls(lst);
  3   255 	return;
  3   256 
  3   257 /* <assign>	::= <ab_set> <cat> ! */
  3   258 rule(0021):
  3   259           call make(CAT,lst);
  3   260           ls.type(lst) = ABREV;
  3   261 
  3   262 /* <assign>	::= <var_set> <cat> ! */
  3   263 rule(0022):
  3   264 	avar_ptr = ls.pt (lst-1);
  3   265           avar.type = ls.type (lst);
  3   266 	if (ls.type (lst) = AEXP)
  3   267 	| (ls.type (lst) = LEXP)
  3   268           then do;
  3   269 	     if (avar.txt_r ^= "0"b)	/* old left-over string?	       */
  3   270 	     then do;
  3   271 		cat_p = pointer (lval_ptr, avar.txt_r);
  3   272 		free catv in (cata);
  3   273 		avar.txt_r = "0"b;
  3   274 	     end;
  3   275 	     avar.num = ls.num (lst);
  3   276 	     ls(lst-1) = ls(lst);
  3   277 	     return;
  3   278 	end;
  3   279 	avar_len, cat_l = ls.num (lst);
  3   280 	if (avar.txt_r = "0"b)
  3   281 	then do;
  3   282 	     allocate catv in (cata);
  3   283 	     avar.txt_r = rel (cat_p);
  3   284 	end;
  3   285 	else cat_p = pointer (lval_ptr, avar.txt_r);
  3   286 	if (catv.len ^=  avar_len)
  3   287 	then do;
  3   288 	     free catv in (cata);
  3   289 	     allocate catv in (cata);
  3   290 	     avar.txt_r = rel (cat_p);
  3   291 	end;
  3   292 	catv.text = substr(ls.pt(lst)->is,ls.loc(lst),avar_len);
  3   293 	ls(lst-1) = ls(lst);
  3   294 	return;
  3   295 
  3   296 dcl azAZ09 char(62) int static init("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
  3   297 
  3   298 /* <var_set>	::= <var> := ! */
  3   299 rule(0023):
  3   300 	if (ls.pt (lst-1) ^= null())
  3   301 	then return;		/* var already allocated	       */
  3   302 	ns_string = substr (ls.symptr(lst-1) ->is, 1, ls.symlen(lst-1));
  3   303 	ls.type (lst-1) = AEXP;
  3   304 	goto setup_avar;
  3   305 	
  3   306 /* <ab_set>	::= <string> := ! */
  3   307 rule(0024):
  3   308 	if (length(ns_string)>16)
  3   309           | (length(ns_string)=0)
  3   310 	then do;
  3   311 	     msg = "Vnl) Abbrev-name length not 1-16 ";
  3   312 	     goto err_text;
  3   313 	end;
  3   314 	if (verify(ns_string,azAZ09) ^= 0)
  3   315 	| (substr(ns_string,1,1) < "A")
  3   316 	then do;
  3   317 	     msg = "Vin) Illegal abbrev name ";
  3   318 	     goto err_text;
  3   319 	end;
  3   320 	ls.type (lst-1) = ABREV;
  3   321 dcl next_avar bit (18);
  3   322 	next_avar = val.avar;
  3   323 	do avar_ptr = pointer (lval_ptr, next_avar)
  3   324 	          repeat (pointer (lval_ptr, next_avar))
  3   325 	          while (next_avar ^= "0"b);
  3   326 	     next_avar = avar.next;
  3   327 	     if (avar.name = ns_string)
  3   328 	     then do;
  3   329 		ls.pt (lst-1) = avar_ptr;
  3   330 		return;
  3   331 	     end;
  3   332 	end;
  3   333 setup_avar:
  3   334 	allocate avar in (cata);	/* get a new descriptor	       */
  3   335 	avar.name = ns_string;
  3   336 
  3   337 	avar.txt_r = "0"b;		/* show no text		       */
  3   338 	avar.type = ls.type (lst-1);	/* set the type trying for	       */
  3   339 	ls.pt (lst-1) = avar_ptr;	/* fill in the stack reference       */
  3   340 	avar.next = val.avar;	/* link into symbol list	       */
  3   341 	val.avar = rel (avar_ptr);
  3   342 	return;
  3   343 
  3   344 
  3   345 /* <aref>	::= k[ <cat> ]	! */;
  3   346 rule(0025):
  3   347 	sr_ptr = addr(ls(lst-2));
  3   348 	i = ls.num(lst-1);
  3   349 	sr.pt = addrel(addr(k(ckk(i))),1);
  3   350 	sr.loc = 1;
  3   351 	sr.num = length(k(i));
  3   352 	goto kexp_return;
  3   353 
  3   354 /* <aref>	::= K[ <cat> ]	! */;
  3   355 rule(0026):
  3   356 	sr_ptr = addr(ls(lst-2));
  3   357 	i = ls.num(lst-1);
  3   358 	sr.pt = addrel(addr(K(ckK(i))),1);
  3   359 	sr.loc = 1;
  3   360 	sr.num = length(K(i));
  3   361 	goto kexp_return;
  3   362 
  3   363 /* <aref>	::= p[ <cat> ] ! */
  3   364 rule(0027):
  3   365 	i = ls.num(lst-1);
  3   366 	sr_ptr = addr(ls(lst-2));
  3   367 	sv_p = dbase.stk_info.top;
  3   368           if (sv_p = null())
  3   369 	then do;
  3   370 maybe_null_str:
  3   371 	     if (i = 0)
  3   372 	     then do;
  3   373 		sr.pt = addr(dbase.err_go);  /* point to something	       */
  3   374 		sr.loc = 1;
  3   375 		sr.num = 0;
  3   376 		goto kexp_return;
  3   377 	     end;
  3   378 	end;
  3   379 	else if (sv.pn = 0)
  3   380 	then goto maybe_null_str;
  3   381 	if (i < 0)
  3   382 	 | (i > sv.pn)
  3   383 	then do;
  3   384 	     msg = "Vsp) Subscript not in range p[0:pn] ";
  3   385 	     goto err_text;
  3   386 	end;
  3   387 	sr.pt = sv.pp(i);
  3   388 	sr.loc = 1;
  3   389 	sr.num = sv.pl(i);
  3   390 	goto kexp_return;
  3   391 
  3   392 /* <aref>	::= Ks	! */;
  3   393 rule(0028):
  3   394 	lsbe = "Ks";
  3   395 	sr_ptr = addr(ls(lst));
  3   396 	if (ams_p ^= null())	/* If this is a \g{...} usage, it    */
  3   397 	then do;			/*   is special.		       */
  3   398 	   sr.pt = ams_p;
  3   399 	   sr.loc = 1;
  3   400 	   sr.num = ams_l;
  3   401 	   goto kexp_return;
  3   402 	end;
  3   403 	sr.pt = b.cur.sp;
  3   404 	sr.loc = valid(b.a_.l.re(1),"Ks ");
  3   405 	sr.num = b.a_.r.le(2);
  3   406 	goto check_split;
  3   407 
  3   408 /* <aref>	::= Kl	! */;
  3   409 rule(0029):
  3   410 	lsbe = "Kl";
  3   411 	sr_ptr = addr(ls(lst));
  3   412 	sr.pt = b.cur.sp;
  3   413 	sr.loc = valid(b.a_.l.le(1),"Kl ");
  3   414 	sr.num = b.a_.r.re(2);
  3   415 	goto check_split;
  3   416 
  3   417 /* <aref>	::= Kb	! */;
  3   418 rule(0030):
  3   419 	lsbe = "Kb";
  3   420 	sr_ptr = addr(ls(lst));
  3   421 	sr.pt = b.cur.sp;
  3   422 	sr.loc = b.b_.l.le;
  3   423 	if (b.b_.l.re < b.b_.l.le)	/* lower part empty?	       */
  3   424 	then sr.loc = b.b_.r.le;	/* ..yes, use upper		       */
  3   425 	sr.num = b.b_.r.re;
  3   426 	if (b.b_.r.le > b.b_.r.re)	/* upper part empty?	       */
  3   427 	then sr.num = b.b_.l.re;	/* ..yes, use lower		       */
  3   428 check_split:			/*  sr.loc is LHE,   sr.num is RHE   */
  3   429 	tsb = sr.loc;
  3   430 	tse = sr.num;
  3   431 dcl (tsb, tse) fixed bin (21);
  3   432 	if (sr.loc <= b.b_.l.re) & (sr.num >= b.b_.r.le)
  3   433 	then do;			/* String is split, must create a    */
  3   434 				/*   "pure" string.		       */
  3   435 	   ti = sr.loc;		/* alloc will clobber sr.loc	       */
  3   436 	   j = b.b_.l.re - sr.loc + 1;/* size of left part	       */
  3   437 	   i = sr.num - b.b_.r.le + 1;/* size of right part	       */
  3   438 	   cat_l = j + i;		/* size of whole thing	       */
  3   439 	   call alloc;
  3   440 	   
  3   441 	   substr (catv.text, 1, j) = substr (b_s, ti, j);
  3   442 	   substr (catv.text, j+1, i) = substr (b_s, b.b_.r.le, i);
  3   443 	end;
  3   444 	if db_eval | db_sw then call ioa_$ioa_switch (db_output,
  3   445 	   "^a^4(,^i^)  ^5i:^5i->^5i:^5i",
  3   446 	   lsbe, b.b_.l.le, b.b_.l.re, b.b_.r.le, b.b_.r.re,
  3   447 	   tsb, tse, sr.loc, sr.num);
  3   448 	sr.num = sr.num - sr.loc + 1;
  3   449 	goto kexp_return;
  3   450 
  3   451 /* <aref>	::= cs ! */;
  3   452 rule(0031):
  3   453 	ascii = collate9();
  3   454 	sr_ptr = addr(ls(lst));
  3   455 	sr.pt = addr(ascii);
  3   456 	sr.loc = 1;
  3   457 	sr.num = 512;
  3   458 	goto kexp_return;
  3   459 
  3   460 dcl	ascii	char(512);
  3   461 /* <aref>	::= <string>	! */;
  3   462 rule(0032):
  3   463 	sr_ptr = addr(ls(lst));
  3   464 	cat_l = length(ns_string);
  3   465 	call alloc;
  3   466 	catv.text = ns_string;
  3   467 	goto kexp_return;
  3   468 
  3   469 /* <aref>	::= fak ( <cat> , <cat> )	! */;
  3   470 rule(0033):
  3   471           call make(CAT,lst-1);
  3   472           call make(CAT,lst-3);
  3   473 	sr_ptr = addr(ls(lst-5));
  3   474 	ns_string = substr(ls.pt(lst-1)->is,ls.loc(lst-1),ls.num(lst-1));
  3   475 	cv = substr(ls.pt(lst-3)->is,ls.loc(lst-3),ls.num(lst-3));
  3   476 	if (length(ns_string) = 0)
  3   477 	then sr = ls (lst-3);
  3   478 	else do;
  3   479 dcl	(sign,fill)	char(1);
  3   480 dcl	(units,z_sup)		bit(1);
  3   481 dcl	(hexd,ti,nibble)	fixed bin(21);
  3   482 dcl	hexdigits		char(16)int static init("0123456789ABCDEF");
  3   483 	   j = length(cv);
  3   484 	   if (substr(cv,1,1) = "-") then do;
  3   485 	      sign = "-";
  3   486 	      cv = substr(cv,2,j-1);
  3   487 	      j = j - 1;
  3   488 	   end;
  3   489 	   else
  3   490 	      sign = " ";
  3   491 	   units = "1"b;
  3   492 	   z_sup = "0"b;
  3   493 	   fill = " ";
  3   494 	   do i = length(ns_string) to 1 by -1;
  3   495 	      mc = substr(ns_string,i,1);
  3   496 	      if (mc = " ") then do;
  3   497 	         z_sup = "1"b;
  3   498 	         if units then do;
  3   499 	            if (cv = "0") then
  3   500 	               j = 0;
  3   501 	         end;
  3   502 	      end;
  3   503 	      if units then
  3   504 	         if (mc = "*")
  3   505 	          | (mc = "$") then do;
  3   506 	            fill = mc;
  3   507 	            mc = " ";
  3   508 	         end;
  3   509 	         else
  3   510 	            if (mc = "-") then do;
  3   511 	               fill = sign;
  3   512 	               mc = " ";
  3   513 	            end;
  3   514 	            else do;
  3   515 	               hexd = index("XxOo",mc);
  3   516 	               if (hexd ^= 0)
  3   517 		     then do;
  3   518 		        if (hexd > 2)
  3   519 		        then nibble = 3;
  3   520 		        else nibble = 4;
  3   521 		        j = fixed(cv,35);
  3   522 dcl  jb		bit(36)based(addr(j));
  3   523 		        cv = "";
  3   524 		        do ti = 1 to 36 by nibble;
  3   525 			 hexd = fixed(substr(jb,ti,nibble),17);
  3   526 			 if (cv ^= "") | (hexd ^= 0)
  3   527 			 then cv = cv || substr(hexdigits,hexd+1,1);
  3   528 		        end;
  3   529 		        if (cv = "")
  3   530 		        then cv = "0";
  3   531 		        j = length(cv);
  3   532 	                  mc = " ";
  3   533 	               end;
  3   534 	            end;
  3   535 	      if (mc = " ")
  3   536 	       | (mc = "0") then do;
  3   537 	         if (j > 0) then do;
  3   538 	            substr(ns_string,i,1) = substr(cv,j,1);
  3   539 	            j = j - 1;
  3   540 	         end;
  3   541 	         else
  3   542 	            if (mc = " ") then
  3   543 	               if ^units then do;
  3   544 	                  mc = ".";
  3   545 	               end;
  3   546 	         units = "0"b;
  3   547 	      end;
  3   548 	      if (mc = ",")
  3   549 	       | (mc = ".") then do;
  3   550 	         if z_sup & (j < 1) then do;
  3   551 	            substr(ns_string,i,1) = fill;
  3   552 	            if (fill ^= "*") then
  3   553 	               fill = " ";
  3   554 	         end;
  3   555 	      end;
  3   556 	      if (mc = "~") then
  3   557 	         substr(ns_string,i,1) = " ";
  3   558 	   end;
  3   559 	   if (substr(ns_string,1,1) = "-") then
  3   560 	      substr(ns_string,1,1) = sign;
  3   561 	   cat_l = length(ns_string);
  3   562 	   call alloc;
  3   563 	   catv.text = ns_string;
  3   564 	end;
  3   565 	goto kexp_return;
  3   566 
  3   567 /* <aref>	::= fs ( <cat> , <cat> )
  3   568*	  | fs ( <cat> , <cat> , <cat> )
  3   569*	  | fs ( <cat> , <cat> : <cat> )	! */;
  3   570 rule(0034):
  3   571 	begin;
  3   572 
  3   573 dcl (i, ifr, ito) fixed bin (21);
  3   574 
  3   575                call make(AEXP,lst-1);
  3   576 	     if (alternative_number = 1) 
  3   577 	     then do;
  3   578 		call make(CAT,lst-3);
  3   579 		s1_ptr = addr(ls(lst-3));
  3   580 		sr_ptr = addr(ls(lst-5));
  3   581 		ito, ifr = ls.num(lst-1);
  3   582 		if (ifr > 0)
  3   583 		then ito = s1.num - ito + 1;
  3   584 	     end;
  3   585 	     else do;
  3   586 		call make(AEXP, lst-3);
  3   587 		call make(CAT,lst-5);
  3   588 		s1_ptr = addr(ls(lst-5));
  3   589 		sr_ptr = addr(ls(lst-7));
  3   590 		ifr = ls.num(lst-3);
  3   591 		ito = ls.num(lst -1);
  3   592 		if (alternative_number = 3)
  3   593 		then do;
  3   594 		     if (ito < 0)
  3   595 		     then ito = s1.num + ito + 1;
  3   596 		     if (ifr > ito)
  3   597 		     then ifr = 0; /* force error condition	       */
  3   598 		     ito = ito - ifr + 1;
  3   599 		end;
  3   600 	     end;
  3   601 	     if (ifr < 0)
  3   602 	     then ifr = max (1, s1.num + ifr + 1);
  3   603 	     if (ifr > s1.num) | (ifr = 0)
  3   604 	     then do;
  3   605 		msg = "Vfs) substr from outside string ";
  3   606 		goto err_text;
  3   607 	     end;
  3   608 	     cat_l = abs(ito);
  3   609 	     call alloc;
  3   610 	     sr.num = 0;
  3   611 	     if (ifr < 0)
  3   612 	     then do;
  3   613 		ifr = -ifr;
  3   614 		if (ito > 0)
  3   615 		then do;
  3   616 		     ifr = min(ifr + 1,ito);
  3   617 		     ito = max(0,ito - ifr);
  3   618 		end;
  3   619 		else do;
  3   620 		     ifr = min(ifr,-ito);
  3   621 		     ito = min(ito + ifr,0);
  3   622 		end;
  3   623 		substr(catv.text,1,ifr) = " ";
  3   624 		sr.num = ifr;
  3   625 		ifr = 1;
  3   626 	     end;
  3   627 	     if (ito < 0) then do;
  3   628 		ito = -ito;
  3   629 		i = s1.num - ifr + 1;
  3   630 		if (i < ito) then do;
  3   631 		     i = ito - i;
  3   632 		     substr (catv.text, sr.num+1, i) = " ";
  3   633 		     sr.num = sr.num + i;
  3   634 		     ito = ito - i;
  3   635 		end;
  3   636 	     end;
  3   637 	     substr (catv.text, sr.num+1, ito)
  3   638 		= substr (s1.pt->is, ifr + s1.loc - 1, min ((s1.num-ifr+1), ito));
  3   639 	     sr.num  = sr.num + ito;
  3   640 	end;
  3   641 	goto kexp_return;
  3   642 
  3   643 /* <aref>	::= frs ( <cat> , <cat> , <cat> ) ! */;
  3   644 dcl  XXloc(4) ptr;
  3   645 dcl  XXnum(4) fixed bin(21);
  3   646 rule(0035):
  3   647           call make(CAT,lst-1);
  3   648           call make(CAT,lst-3);
  3   649           call make(CAT,lst-5);
  3   650 	s1_ptr = addr(ls(lst-5));
  3   651 	s2_ptr = addr(ls(lst-3));
  3   652 	XXloc(4) = addr(s2.pt->ic(s2.loc));
  3   653 	XXnum(4) = s2.num;
  3   654 	i = index(substr(s1.pt->is,s1.loc,s1.num),substr(s2.pt->is,s2.loc,s2.num));
  3   655 	if (i = 0)
  3   656 	then do;
  3   657 	     XXloc(1), XXloc(2), XXloc(3) = addr(s1.pt->ic(s1.loc));
  3   658 	     XXnum(1) = s1.num;
  3   659 	     XXnum(2), XXnum(3) = 0;
  3   660 	end;
  3   661 	else do;
  3   662 	     XXloc(1) = addr(s1.pt->ic(s1.loc));
  3   663 	     XXnum(1) = i-1;
  3   664 	     XXloc(2) = addr(XXloc(1)->ic(i));
  3   665 	     XXnum(2) = s2.num;
  3   666 	     XXloc(3) = addr(XXloc(2)->ic(s2.num+1));
  3   667 	     XXnum(3) = s1.num - XXnum(1) - XXnum(2);
  3   668 	end;
  3   669 	s2_ptr = addr(ls(lst-1));
  3   670 	cat_l = 0;
  3   671 	do i = 1 to s2.num;
  3   672 	     ii = index("bmas",substr(s2.pt->is,i,1));
  3   673 	     if (ii = 0)
  3   674 	     then do;
  3   675 		msg = "Vrs) Improper control string. ";
  3   676 		goto err_text;
  3   677 	     end;
  3   678 	     cat_l = cat_l + XXnum(ii);
  3   679 	end;
  3   680 	sr_ptr = addr(ls(lst-7));
  3   681 	call alloc;
  3   682 	sr.num = 0;
  3   683 	do i = 1 to s2.num;
  3   684 	     ii = index("bmas",substr(s2.pt->is,i,1));
  3   685 	     substr(catv.text,sr.num+1,XXnum(ii))
  3   686 	        = substr(XXloc(ii)->is,1,XXnum(ii));
  3   687 	     sr.num = sr.num + XXnum(ii);
  3   688 	end;
  3   689 	goto kexp_return;
  3   690 
  3   691 /* <aref>	::= if ( <lexp> , <cat> ) ! */;
  3   692 rule(0036):
  3   693           sr_ptr = addr( ls(lst-5));
  3   694           call make(LEXP,lst-3);
  3   695 	sr.pt = ls.pt(lst-1);	/* plug in the given value	       */
  3   696 	sr.type = ls.type(lst-1);
  3   697 	sr.loc = ls.loc(lst-1);
  3   698 	sr.num = ls.num(lst-1);
  3   699 	if (ls.num(lst-3) = 0)
  3   700 	then do;			/* if false		       */
  3   701 	     sr.type = CAT;		/* ..convert to a null string	       */
  3   702 	     sr.num = 0;
  3   703 	end;
  3   704 	goto kexp_return;
  3   705 
  3   706 /* <aref>	::= if ( <lexp> , <cat> , <cat> ) ! */;
  3   707 rule(0037):
  3   708           sr_ptr = addr( ls(lst-7));
  3   709           call make(LEXP,lst-5);
  3   710 	if (ls.num(lst-5) ^= 0)
  3   711 	then do;
  3   712 	     sr.pt = ls.pt(lst-3);
  3   713 	     sr.type = ls.type(lst-3);
  3   714 	     sr.loc = ls.loc(lst-3);
  3   715 	     sr.num = ls.num(lst-3);
  3   716 	end;
  3   717 	else do;
  3   718 	     sr.pt = ls.pt(lst-1);
  3   719 	     sr.type = ls.type(lst-1);
  3   720 	     sr.loc = ls.loc(lst-1);
  3   721 	     sr.num = ls.num(lst-1);
  3   722 	end;
  3   723 	return;
  3   724 
  3   725 /* <aref>	::= <var> ! */;
  3   726 rule(0038):
  3   727 	avar_ptr = ls.pt (lst);
  3   728           if (avar_ptr = null())
  3   729 	then do;
  3   730 	     msg = "Vnd) Variable not defined";
  3   731 	     goto err_text;
  3   732 	end;
  3   733 	ls.type (lst) = avar.type;
  3   734 	if (avar.type ^= CAT)
  3   735 	then ls.num(lst) = avar.num;
  3   736 	else do;
  3   737 	     cat_p = pointer (lval_ptr, avar.txt_r);
  3   738 	     ls.pt (lst) =addr (catv.text);
  3   739 	     ls.loc (lst) = 1;
  3   740 	     ls.num (lst) = catv.len;
  3   741 	end;
  3   742 	return;
  3   743 
  3   744 /* <aref>	::= bn	! */;
  3   745 rule(0039):
  3   746 	sr_ptr = addr(ls(lst));
  3   747 	i = index(b.name," ")-1;
  3   748 	if (i = -1) then
  3   749 	   i = 16;
  3   750 	sr.pt = addr(b.name);
  3   751 	sr.loc = 1;
  3   752 	sr.num = i;
  3   753 	goto kexp_return;
  3   754 
  3   755 /* <aref>	::= dn	! */;
  3   756 rule(0040):
  3   757 	sr_ptr = addr(ls(lst));
  3   758 	i = index(b.dname," ")-1;
  3   759 	if (i = -1) then
  3   760 	   i = 168;
  3   761 	sr.pt = addr(b.dname);
  3   762 	goto kexp_path;
  3   763 
  3   764 /* <aref>	::= en	! */;
  3   765 rule(0041):
  3   766 	sr_ptr = addr(ls(lst));
  3   767 	i = index(b.ename," ")-1;
  3   768 	if (i = -1) then
  3   769 	   i = 32;
  3   770 	sr.pt = addr(b.ename);
  3   771 	goto kexp_path;
  3   772 
  3   773 /* <aref>	::= sn	! */;
  3   774 rule(0042):
  3   775 	sr_ptr = addr(ls(lst));
  3   776 	i = index(b.cname," ")-1;
  3   777 	if (i = -1) then
  3   778 	   i = 32;
  3   779 	sr.pt = addr(b.cname);
  3   780 	goto kexp_path;
  3   781 
  3   782 /* <aref>	::= sk	! */;
  3   783 rule(0043):
  3   784 	sr_ptr = addr(ls(lst));
  3   785 	i = 1;
  3   786 	sr.pt = addr(b.kind);
  3   787 kexp_path:
  3   788 	sr.loc = 1;
  3   789 	if b.file_sw
  3   790 	then sr.num = i;
  3   791 	else sr.num = 0;
  3   792 	goto kexp_return;
  3   793 
  3   794 
  3   795 /* <aref>	::= em	! */
  3   796 rule(0044):
  3   797 	sr_ptr = addr(ls(lst));
  3   798 	sr.pt = addrel(addr(err_msg),1);
  3   799 	sr.loc = 1;
  3   800 	sr.num = length(err_msg);
  3   801 	goto kexp_return;	
  3   802 
  3   803 /* <aref>	::= emt ( )	! */
  3   804 rule(0045):
  3   805 	sr_ptr = addr(ls(lst-2));
  3   806 	sr.pt = addrel(addr(err_msg),1);
  3   807 	sr.loc = 6;
  3   808 	sr.num = max (0, length(err_msg)-5);
  3   809 	goto kexp_return;	
  3   810 
  3   811 /* <aref>	::= emc ( )	! */
  3   812 rule(0046):
  3   813 	sr_ptr = addr(ls(lst-2));
  3   814 	sr.pt = addrel(addr(err_msg),1);
  3   815 	sr.loc = 1;
  3   816 	sr.num = 3;
  3   817 	goto kexp_return;	
  3   818 
  3   819 /* <cat>	::= <aexp>	! */;
  3   820 /* <cat>	::= <cat> '|'| <aexp>	! */
  3   821 rule(0048):
  3   822 	call make (CAT, lst);
  3   823 	call make (CAT, lst-2);
  3   824 	sr_ptr, s1_ptr = addr(ls(lst-2));
  3   825 	s2_ptr = addr(ls(lst));
  3   826 	goto concatenate;
  3   827 
  3   828 /* <cat>	::= <cat> <aexp>	! */
  3   829 rule(0049):
  3   830 	call make (CAT, lst);
  3   831 	call make (CAT, lst-1);
  3   832 	sr_ptr, s1_ptr = addr(ls(lst-1));
  3   833 	s2_ptr = addr(ls(lst));
  3   834 	if ^conc_sw
  3   835 	then do;
  3   836 	   conc_sw = "1"b;
  3   837 	   call ioa_$nnl("Warning: || operator missing. ");
  3   838 	   call tedwhere_ (dbase_p);
  3   839 	end;
  3   840 concatenate:
  3   841 	sx_ptr = addr( ls(lst+1));	/* borrow a stack element	       */
  3   842 	sx = s1;			/* because alloc clobbers sr which   */
  3   843 	cat_l = sx.num + s2.num;	/* is the same as s1	       */
  3   844 dcl 1 sx like ls based(sx_ptr);
  3   845 dcl  sx_ptr ptr;
  3   846 	call alloc;
  3   847 	substr(catv.text,1,s1.num) = substr(sx.pt->is,sx.loc,sx.num);
  3   848 	substr(catv.text,sx.num+1,s2.num) = substr(s2.pt->is,s2.loc,s2.num);
  3   849 kexp_return:
  3   850           sr.type = CAT;
  3   851 	return;
  3   852 
  3   853 /* <exec>	::= ex ( <cat> ) ! */
  3   854 rule(0050):			/* this is the execute MACRO	       */
  3   855           call make(CAT,lst-1);
  3   856 	if (ls.num(lst-1) > 0)
  3   857 	then call ns_alt(ls.pt(lst-1),ls.loc(lst-1),ls.num(lst-1));
  3   858 	return;
  3   859 
  3   860 
  3   861 /* <lexp>	::= <cat> <rel> <cat>	! */;
  3   862 rule(0051):
  3   863           i = max (ls.type (lst), ls.type (lst-2));
  3   864           call make (i, lst);
  3   865           call make (i, lst-2);
  3   866 	ls.type(lst-2) = LEXP;
  3   867 	s1_ptr = addr(ls(lst-2));
  3   868 	s2_ptr = addr(ls(lst));
  3   869 	if (i = CAT)
  3   870 	then do;
  3   871 	     if (substr(s1.pt->is,s1.loc,s1.num) < substr(s2.pt->is,s2.loc,s2.num))
  3   872 	     then comp = "100"b;
  3   873 	     else if (substr(s1.pt->is,s1.loc,s1.num) > substr(s2.pt->is,s2.loc,s2.num))
  3   874 	     then comp = "001"b;
  3   875 	     else comp = "010"b;
  3   876 	end;
  3   877 	else do;
  3   878 	     if (s1.num < s2.num)
  3   879 	     then comp = "100"b;
  3   880 	     else if (s1.num > s2.num)
  3   881 	     then comp = "001"b;
  3   882 	     else comp = "010"b;
  3   883 	end;
  3   884 	if ls.mask(lst-1)&comp
  3   885 	then ls.num(lst-2) = 1;
  3   886 	else ls.num(lst-2) = 0;
  3   887 	ls.type (lst-2) = LEXP;
  3   888 	return;
  3   889 
  3   890 /* <lexp>	::= <cat> J <rel> <cat>	! */
  3   891 rule(0052):
  3   892 dcl	R(1:4)	fixed bin(21);
  3   893 
  3   894           call make (CAT,lst);
  3   895 	call make (CAT,lst-3);
  3   896 	ls.type(lst-3) = LEXP;
  3   897 	s1_ptr = addr(ls(lst-3));
  3   898 	s2_ptr = addr(ls(lst));
  3   899 	cat_l = s1.num + s2.num;
  3   900 	allocate catv in (cata);
  3   901 	R(1) = 1;
  3   902 	substr(catv.text,R(1),s1.num) = substr(s1.pt->is,s1.loc,s1.num);
  3   903 	R(2), R(3) = R(1) + s1.num;
  3   904 	substr(catv.text,R(3),s2.num) = substr(s2.pt->is,s2.loc,s2.num);
  3   905 	R(4) = R(3) + s2.num;
  3   906 dcl	tedsort_$compare	entry(ptr,ptr,bit(3));
  3   907 	call tedsort_$compare (addr(catv.text),addr(R),comp);
  3   908 	free catv;
  3   909 	if ls.mask(lst-1)&comp
  3   910 	then ls.num(lst-3) = 1;
  3   911 	else ls.num(lst-3) = 0;
  3   912 	ls.type (lst-3) = LEXP;
  3   913 	return;
  3   914 
  3   915 /* <rel>	::=  =  |  ^=  |  '>=  |  '<=  |  '<  |  '>	! */
  3   916 rule(0053):
  3   917 dcl relmask(1:6) bit(36)int static init("010"b, "101"b, "011"b, "110"b, "100"b, "001"b );
  3   918 	ls.mask(lst) = relmask(alternative_number);
  3   919 	return;
  3   920 
  3   921 /* <aexp>	::= <aexp> + <term>	! */;
  3   922 rule(0054):
  3   923           call make (AEXP,lst);
  3   924           call make (AEXP,lst-2);
  3   925 	ls.type(lst-2) = AEXP;
  3   926 	ls.num(lst-2) = ls.num(lst-2) + ls.num(lst);
  3   927 	return;
  3   928 
  3   929 /* <aexp>	::= <aexp> - <term>	! */;
  3   930 rule(0055):
  3   931           call make (AEXP,lst);
  3   932           call make (AEXP,lst-2);
  3   933 	ls.type(lst-2) = AEXP;
  3   934 	ls.num(lst-2) = ls.num(lst-2) - ls.num(lst);
  3   935 	return;
  3   936 
  3   937 /* <aexp>	::= <term>	! */
  3   938 
  3   939 
  3   940 /* <term>	::= <term> * <factor>	! */;
  3   941 rule(0057):
  3   942           call make (AEXP,lst);
  3   943           call make (AEXP,lst-2);
  3   944 	ls.type(lst-2) = AEXP;
  3   945 	ls.num(lst-2) = ls.num(lst-2) * ls.num(lst);
  3   946 	return;
  3   947 
  3   948 /* <term>	::= <term> / <factor>	! */;
  3   949 rule(0058):
  3   950           call make (AEXP,lst);
  3   951           call make (AEXP,lst-2);
  3   952 	ls.type(lst-2) = AEXP;
  3   953 	ls.num(lst-2) = divide(ls.num(lst-2),ls.num(lst),17,0);
  3   954 	return;
  3   955 
  3   956 /* <term>	::= <term> '| <factor>	! */;
  3   957 rule(0059):
  3   958           call make (AEXP,lst);
  3   959           call make (AEXP,lst-2);
  3   960 	ls.type(lst-2) = AEXP;
  3   961 	ls.num(lst-2) =  mod(ls.num(lst-2),ls.num(lst));
  3   962 	return;
  3   963 
  3   964 /* <term>	::= <factor>	! */
  3   965 
  3   966 /* <factor>	::= <fact> ! */;
  3   967 
  3   968 /* <factor>	::= <u+> <fact> ! */;
  3   969 rule(0062):
  3   970 	call make(AEXP, lst);
  3   971           ls(lst-1) = ls(lst);
  3   972 	return;
  3   973 
  3   974 /* <factor>	::= <u-> <fact> ! */
  3   975 rule(0063):
  3   976 	call make(AEXP, lst);
  3   977 	ls(lst-1) = ls(lst);
  3   978 	ls.num(lst-1) = - ls.num(lst-1);
  3   979 	return;
  3   980 
  3   981 /* <fact>	::= <aref>	! */;
  3   982 
  3   983 /* <fact>	::= ( <cat> ) | ( <lexp> ) | ( <assign> ) ! */
  3   984 rule(0065):
  3   985 	ls(lst-2) = ls(lst-1);
  3   986 	return;
  3   987 
  3   988 /* <aref>	::= a[ <cat> ]	! */;
  3   989 rule(0066):
  3   990 	ls.num(lst-2) = av((cka(ls.num(lst-1))));
  3   991           ls.type(lst-2) = AEXP;
  3   992 	return;
  3   993 
  3   994 /* <aref>	::= fka ( <cat> )	! */;
  3   995 rule(0067):
  3   996           call make(AEXP,lst-1);
  3   997 	ls(lst-3) = ls(lst-1);
  3   998 	return;
  3   999 
  3  1000 /* <aref>	::= <integer>	! */;
  3  1001 rule(0068):
  3  1002           ls.type(lst) = AEXP;
  3  1003 	return;
  3  1004 
  3  1005 /* <aref>	::= pn ! */
  3  1006 rule(0069):
  3  1007 	sv_p = dbase.stk_info.top;
  3  1008 	if (sv_p = null())
  3  1009           then ls.num (lst) = 0;
  3  1010 	else ls.num(lst) = sv.pn;
  3  1011           ls.type(lst) = AEXP;
  3  1012 	return;
  3  1013 
  3  1014 /* <aref>	::= ag ! */
  3  1015 rule(0070):
  3  1016 	ls.num(lst) = argct;
  3  1017           ls.type(lst) = AEXP;
  3  1018 	return;
  3  1019 
  3  1020 
  3  1021 /* <aref>	::= mct ( ) ! */
  3  1022 rule(0071):
  3  1023 	ls.num(lst-2) = S_count;
  3  1024           ls.type(lst-2) = AEXP;
  3  1025 	return;
  3  1026 
  3  1027 
  3  1028 dcl lsbe		char (4);
  3  1029 /* <aref>	::= lb	! */;
  3  1030 rule(0072):
  3  1031 	lsbe = "lb";
  3  1032 	if (b.cur.sn > 0)		/* if buffer not empty	       */
  3  1033 	then ls.num(lst) = valid(b.a_.l.le(1),"lb ");
  3  1034 	else ls.num(lst) = 0;
  3  1035 	goto check_offset;
  3  1036 
  3  1037 /* <aref>	::= sb	! */;
  3  1038 rule(0073):
  3  1039 	lsbe = "sb";
  3  1040 	if (ams_p ^= null())	/* if a \g{...} usage	       */
  3  1041 	then ls.num(lst) = 1;
  3  1042 	else if (b.cur.sn > 0)
  3  1043 	then ls.num(lst) = valid(b.a_.l.re(1),"sb ");
  3  1044 	else ls.num(lst) = 0;
  3  1045 	goto check_offset;
  3  1046 
  3  1047 /* <aref>	::= se	! */;
  3  1048 rule(0074):
  3  1049 	lsbe = "se";
  3  1050 	if (ams_p ^= null())	/* if a \g{...} usage	       */
  3  1051 	then ls.num(lst) = ams_l;
  3  1052 	else if (b.cur.sn > 0)	/* if buffer not empty	       */
  3  1053 	then ls.num(lst) = valid(b.a_.r.le(2),"se ");
  3  1054 	else ls.num(lst) = 0;
  3  1055 	goto check_offset;
  3  1056 
  3  1057 /* <aref>	::= le	! */;
  3  1058 rule(0075):
  3  1059 	lsbe = "le";
  3  1060 	if (b.cur.sn > 0)
  3  1061 	then ls.num(lst) = valid(b.a_.r.re(2),"le ");
  3  1062 	else ls.num(lst) = 0;
  3  1063 	goto check_offset;
  3  1064 
  3  1065 /* <aref>	::= be	! */;
  3  1066 rule(0076):
  3  1067 	lsbe = "be";
  3  1068 /*          if (b.b_.r.re < b.b_.r.le)
  3  1069*	then ls.num(lst) = b.b_.l.re;
  3  1070*	else */ ls.num(lst) = b.b_.r.re;
  3  1071 check_offset:
  3  1072           ls.type(lst) = AEXP;
  3  1073 	if (ams_p ^= null())
  3  1074 	then do;
  3  1075 	   if db_eval | db_sw then call ioa_$ioa_switch (db_output,
  3  1076 	      "^a \g{ ^i", lsbe, i);
  3  1077 	   return;
  3  1078 	end;
  3  1079 	tsb = ls.num (lst);
  3  1080 	if (ls.num(lst) > b.b_.l.re)	/* if number is in right part,       */
  3  1081 	then do;			/*  must deduct hole size	       */
  3  1082 	   ls.num(lst) = ls.num(lst) - (b.b_.r.le - b.b_.l.re - 1);
  3  1083 	end;
  3  1084 	if db_eval | db_sw then call ioa_$ioa_switch (db_output,
  3  1085 	   "^a^4(,^i^) ^5i->^5i", lsbe,
  3  1086 	   b.b_.l.le, b.b_.l.re, b.b_.r.le, b.b_.r.re, tsb, ls.num(lst));
  3  1087 	return;	   
  3  1088 
  3  1089 /* <fmx>	::= fmx ! */;
  3  1090 rule(0077):
  3  1091 	ls.num(lst) = 2;
  3  1092 	return;
  3  1093 
  3  1094 /* <fmn>	::= fmn ! */;
  3  1095 rule(0078):
  3  1096 	ls.num(lst) = 1;
  3  1097 	return;
  3  1098 
  3  1099 /* <aref>	::= <fmx> ( <cat...> ) ! */
  3  1100 rule(0079):
  3  1101 /* <aref>	::= <fmn> ( <cat...> ) ! */
  3  1102 rule(0080):
  3  1103 	ls(lst-3) = ls(lst-1);
  3  1104 	return;
  3  1105 
  3  1106 /* <cat...>	::= <cat> ! */;
  3  1107 /* <cat...>	::= <cat...> , <cat> ! */
  3  1108 /* this rule is used in the above environment, it therefore looks back       */
  3  1109 /*   to the min/max preceeding to find out which kind to do		       */
  3  1110 rule(0082):
  3  1111           call make(AEXP,lst);
  3  1112           call make(AEXP,lst-2);
  3  1113 	if (ls.num(lst-4) = 1)
  3  1114 	then ls.num(lst-2) = min(ls.num(lst-2),ls.num(lst));
  3  1115 	else ls.num(lst-2) = max(ls.num(lst-2),ls.num(lst));
  3  1116 	ls.type (lst-2) = AEXP;
  3  1117 	return;
  3  1118 
  3  1119 /* <aref>	::= fl ( <cat> )	! */;
  3  1120 rule(0083):
  3  1121           call make (CAT,lst-1);
  3  1122 	ls.num(lst-3) = ls.num(lst-1);
  3  1123 	ls.type (lst-3) = AEXP;
  3  1124 	return;
  3  1125 
  3  1126 /* <aref>	::= ff  ( <cat> , <cat> )	! */;
  3  1127 rule(0084):
  3  1128           call make (CAT,lst-1);
  3  1129           call make (CAT,lst-3);
  3  1130 	s1_ptr = addr(ls(lst-3));
  3  1131 	s2_ptr = addr(ls(lst-1));
  3  1132 	ls.num(lst -5) = search (
  3  1133 	     substr(s1.pt->is,s1.loc,s1.num),
  3  1134 	     substr(s2.pt->is,s2.loc,s2.num));
  3  1135 	ls.type (lst-5) = AEXP;
  3  1136 	return;
  3  1137 /* <aref>	::= ffr ( <cat> , <cat> )	! */;
  3  1138 rule(0085):
  3  1139           call make (CAT,lst-1);
  3  1140           call make (CAT,lst-3);
  3  1141 	s1_ptr = addr(ls(lst-3));
  3  1142 	s2_ptr = addr(ls(lst-1));
  3  1143 	ls.num(lst -5) = search(reverse(substr(s1.pt->is,s1.loc,s1.num)),
  3  1144 	     substr(s2.pt->is,s2.loc,s2.num));
  3  1145 	ls.type (lst-5) = AEXP;
  3  1146 	return;
  3  1147 
  3  1148 /* <aref>	::= fi  ( <cat> , <cat> )	! */;
  3  1149 rule(0086):
  3  1150 	call make (CAT,lst-1);
  3  1151 	call make (CAT,lst-3);
  3  1152 	s1_ptr = addr(ls(lst-3));
  3  1153 	s2_ptr = addr(ls(lst-1));
  3  1154 	ls.num(lst -5) = index (
  3  1155 	     substr(s1.pt->is,s1.loc,s1.num),
  3  1156 	     substr(s2.pt->is,s2.loc,s2.num));
  3  1157 	ls.type (lst-5) = AEXP;
  3  1158 	return;
  3  1159 
  3  1160 /* <aref>	::= fir ( <cat> , <cat> )	! */;
  3  1161 rule(0087):
  3  1162           call make (CAT,lst-1);
  3  1163           call make (CAT,lst-3);
  3  1164 	s1_ptr = addr(ls(lst-3));
  3  1165 	s2_ptr = addr(ls(lst-1));
  3  1166 	if (s2.num = 1)		/* pl1_operators blows it sometimes  */
  3  1167 				/*  when length of 2nd is 1	       */
  3  1168 	then ls.num(lst -5)
  3  1169 	   = index (reverse( substr(s1.pt->is,s1.loc,s1.num)),
  3  1170 	   substr(s2.pt->is,s2.loc,s2.num));
  3  1171 	else ls.num(lst -5)
  3  1172 	   = index (reverse( substr(s1.pt->is,s1.loc,s1.num)),
  3  1173 	   reverse (substr(s2.pt->is,s2.loc,s2.num)));
  3  1174 	ls.type (lst-5) = AEXP;
  3  1175 	return;
  3  1176 
  3  1177 /* <aref>	::= fv  ( <cat> , <cat> )	! */;
  3  1178 rule(0088):
  3  1179           call make (CAT,lst-1);
  3  1180           call make (CAT,lst-3);
  3  1181 	s1_ptr = addr(ls(lst-3));
  3  1182 	s2_ptr = addr(ls(lst-1));
  3  1183 	ls.num(lst -5) = verify(substr(s1.pt->is,s1.loc,s1.num),substr(s2.pt->is,s2.loc,s2.num));
  3  1184 	ls.type (lst-5) = AEXP;
  3  1185 	return;
  3  1186 /* <aref>	::= fvr ( <cat> , <cat> )	! */;
  3  1187 rule(0089):
  3  1188           call make (CAT,lst-1);
  3  1189           call make (CAT,lst-3);
  3  1190 	s1_ptr = addr(ls(lst-3));
  3  1191 	s2_ptr = addr(ls(lst-1));
  3  1192 	ls.num(lst -5) = verify(reverse(substr(s1.pt->is,s1.loc,s1.num)),
  3  1193 	   substr(s2.pt->is,s2.loc,s2.num));
  3  1194 	ls.type (lst-5) = AEXP;
  3  1195 	return;
  3  1196 /* <aref>	::= ff  ( <cat> , <set> )	! */;
  3  1197 rule(0090):
  3  1198           call make (CAT,lst-3);
  3  1199 	s1_ptr = addr(ls(lst-3));
  3  1200 	s2_ptr = addr(ls(lst-1));
  3  1201 	ii = 0;
  3  1202 	do i = s1.loc to s1.loc+s1.num-1;
  3  1203 	     ii = ii + 1;
  3  1204 	     j = fixed(unspec(substr(s1.pt->is,i,1)));
  3  1205 	     if set(j) & s2.mask
  3  1206 	     then do;
  3  1207 		ls.num(lst-5) = ii;
  3  1208 		ls.type (lst-5) = AEXP;
  3  1209 		return;
  3  1210 	     end;
  3  1211 	end;
  3  1212 	ls.num(lst-5) = 0;
  3  1213 	ls.type (lst-5) = AEXP;
  3  1214 	return;
  3  1215 
  3  1216 
  3  1217 /* <aref>	::= ffr ( <cat> , <set> )	! */;
  3  1218 rule(0091):
  3  1219           call make (CAT,lst-3);
  3  1220 	s1_ptr = addr(ls(lst-3));
  3  1221 	s2_ptr = addr(ls(lst-1));
  3  1222 	ii = 0;
  3  1223 	do i = s1.loc+s1.num-1 to s1.loc by -1;
  3  1224 	     ii = ii + 1;
  3  1225 	     j = fixed(unspec(substr(s1.pt->is,i,1)));
  3  1226 	     if set(j) & s2.mask
  3  1227 	     then do;
  3  1228 		ls.num(lst-5) = ii;
  3  1229 		ls.type (lst-5) = AEXP;
  3  1230 		return;
  3  1231 	     end;
  3  1232 	end;
  3  1233 	ls.num(lst-5) = 0;
  3  1234 	ls.type (lst-5) = AEXP;
  3  1235 	return;
  3  1236 
  3  1237 
  3  1238 /* <aref>	::= fv  ( <cat> , <set> )	! */;
  3  1239 rule(0092):
  3  1240           call make (CAT,lst-3);
  3  1241 	s1_ptr = addr(ls(lst-3));
  3  1242 	s2_ptr = addr(ls(lst-1));
  3  1243 	ii = 0;
  3  1244 	do i = s1.loc to s1.loc+s1.num-1;
  3  1245 	     ii = ii + 1;
  3  1246 	     j = fixed(unspec(substr(s1.pt->is,i,1)));
  3  1247 	     if set(j) & s2.mask
  3  1248 	     then;
  3  1249 	     else do;
  3  1250 		ls.num(lst-5) = ii;
  3  1251 		ls.type (lst-5) = AEXP;
  3  1252 		return;
  3  1253 	     end;
  3  1254 	end;
  3  1255 	ls.num(lst-5) = 0;
  3  1256 	ls.type (lst-5) = AEXP;
  3  1257 	return;
  3  1258 
  3  1259 
  3  1260 /* <aref>	::= fvr ( <cat> , <set> )	! */;
  3  1261 rule(0093):
  3  1262           call make (CAT,lst-3);
  3  1263 	s1_ptr = addr(ls(lst-3));
  3  1264 	s2_ptr = addr(ls(lst-1));
  3  1265 	ii = 0;
  3  1266 	do i = s1.loc+s1.num-1 to s1.loc by -1;
  3  1267 	     ii = ii + 1;
  3  1268 	     j = fixed(unspec(substr(s1.pt->is,i,1)));
  3  1269 	     if set(j) & s2.mask
  3  1270 	     then;
  3  1271 	     else do;
  3  1272 		ls.num(lst-5) = ii;
  3  1273 		ls.type (lst-5) = AEXP;
  3  1274 		return;
  3  1275 	     end;
  3  1276 	end;
  3  1277 	ls.num(lst-5) = 0;
  3  1278 	ls.type (lst-5) = AEXP;
  3  1279 	return;
  3  1280 
  3  1281 
  3  1282 /* <aref>	::= fln ( lb )
  3  1283*	  | fln ( le )
  3  1284*	  | fln ( be )	! */
  3  1285 rule(0094):
  3  1286 	begin;
  3  1287 dcl	leng	fixed bin(21);
  3  1288 dcl	lc	fixed bin(21);
  3  1289 dcl	i	fixed bin(21);
  3  1290 dcl	ii	fixed bin(21);
  3  1291 dcl	NL	char(1)int static init("
  3  1292 ");
  3  1293 
  3  1294 	     leng = b.b_.r.re;
  3  1295 	     if (alternative_number = 1)
  3  1296 	     then leng = valid(b.a_.l.le(1),"lb ");
  3  1297 	     if (alternative_number = 2)
  3  1298 	     then leng = valid(b.a_.r.re(2),"le ");
  3  1299 	     call tedcount_lines_ (bp, b.b_.l.le, leng, ls.num (lst-3));
  3  1300 				/* %include dcl_tedcount_lines_;     */
  3  1301 	     ls.type (lst-3) = AEXP;
  3  1302 	end;
  3  1303 	return;
  3  1304 
  3  1305 make:	proc(typ,at);
  3  1306 
  3  1307 dcl	typ	fixed bin (21);	/* type needed		       */
  3  1308 dcl 	at	fixed bin (21);	/* where in stack?		       */
  3  1309 
  3  1310 (subscriptrange): goto fn(ls.type(at)*3+typ);	/* from->to	       */
  3  1311 fn(0): /* AEXP->AEXP */
  3  1312 fn(8): /* LEXP->LEXP */
  3  1313 fn(4): /* CAT ->CAT  */
  3  1314 	return;
  3  1315 
  3  1316 dcl fb35		fixed bin (35);
  3  1317 fn(1): /* AEXP->CAT  */
  3  1318 	fb35 = ls.num(at);
  3  1319 	cv = ltrim(char(fb35));
  3  1320 set_string:
  3  1321 	sr_ptr = addr(ls(at));
  3  1322 	cat_l = length (cv);
  3  1323 	call alloc;
  3  1324 	catv.text = cv;
  3  1325 	ls.type (at) = CAT;
  3  1326 	return;
  3  1327 
  3  1328 fn(2): /* AEXP->LEXP */
  3  1329 	if (ls.num(at) ^= 0)
  3  1330 	then ls.num(at) = 1;
  3  1331 	ls.type (at) = LEXP;
  3  1332 	return;
  3  1333 
  3  1334 fn(3): /* CAT ->AEXP */
  3  1335 	ns_string = substr(ls.pt(at)->is,ls.loc(at),ls.num(at));
  3  1336 	if (verify(ns_string," 0123456789") ^= 0)
  3  1337 	then do;
  3  1338 	   if (index ("+-", substr (ns_string,1,1)) = 0)
  3  1339 	   | (verify( substr (ns_string, 2)," 0123456789") ^= 0)
  3  1340 	   then do;
  3  1341 	      msg = "Vbd) Bad decimal digit. """;
  3  1342 	      msg = msg || ns_string;
  3  1343 	      msg = msg || """";
  3  1344 	      goto err_ret;
  3  1345 	   end;
  3  1346           end;
  3  1347 	ls.num(at) = fixed(ns_string,35);
  3  1348 	ls.type(at) = AEXP;
  3  1349 	return;
  3  1350 
  3  1351 fn(5): /* CAT ->LEXP */
  3  1352 	ns_string = "-";
  3  1353 	ns_string = ns_string
  3  1354 	   || substr(ls.pt(at)->is,ls.loc(at),ls.num(at));
  3  1355 	ns_string = ns_string || "-";
  3  1356 	if (index ("-false-no-f-n-",ns_string) ^= 0)
  3  1357 	then ls.num(at) = 0;
  3  1358 	else ls.num(at) = 1;
  3  1359 	ls.type(at) = LEXP;
  3  1360 	return;
  3  1361 
  3  1362 fn(6): /* LEXP->AEXP */
  3  1363 	ls.type(at) = AEXP;
  3  1364 	return;
  3  1365 
  3  1366 fn(7): /* LEXP->CAT  */
  3  1367 	if (ls.num(at) = 0)
  3  1368 	then cv = "false";
  3  1369 	else cv = "true";
  3  1370 	goto set_string;
  3  1371 
  3  1372 	end;
  3  1373 
  3  1374 
  3  1375 valid$match: proc (val,str)returns(fixed bin (21));
  3  1376 
  3  1377 	
  3  1378 
  3  1379 valid:	entry(val,str)returns(fixed bin(21));
  3  1380 
  3  1381 dcl	val	fixed bin(21);
  3  1382 dcl	str	char(3);
  3  1383 
  3  1384 	if (ams_p ^= null())	/* if a \g{...} usage	       */
  3  1385 	then msg = "Vng) Value undefined in \g{} usage- ";
  3  1386 	else if ^b.present(1)
  3  1387 	then do;
  3  1388 	   if (ams_l < 0)	/* if a \{...} usage	       */
  3  1389 	   then msg = "Vni) Value undefined in input function- ";
  3  1390 	   else msg = "Vna) Value undefined when no addr- ";
  3  1391 	   msg = msg || str;
  3  1392 	   goto err_text;
  3  1393 	end;
  3  1394 	return(val);
  3  1395 
  3  1396 end;
  3  1397 
  3  1398 dcl (	rule_number,
  3  1399 	alternative_number )	fixed bin(21) parm;
  3  1400 
  3  1401 dcl  ii fixed bin(21);
  3  1402 dcl bits(2000)	bit(9)based(s1.pt);
  3  1403 dcl  set(0:511)	bit(9)int static init(
  3  1404 "00000000"b	/* \000  */	/*..*/
  3  1405 /*ANULMOXGx*/	/**/
  3  1406 ,"00000000"b	/* \001  */	/*..*/
  3  1407 ,"00000000"b	/* \002  */	/*..*/
  3  1408 ,"00000000"b	/* \003  */	/*..*/
  3  1409 ,"00000000"b	/* \004  */	/*..*/
  3  1410 ,"00000000"b	/* \005  */	/*..*/
  3  1411 ,"00000000"b	/* \006  */	/*..*/
  3  1412 ,"00001000"b	/* \007  */	/*..*/
  3  1413 ,"00001000"b	/* \010  */	/*..*/
  3  1414 /*ANULMOXGx*/	/**/
  3  1415 ,"00001000"b	/* \011  */	/*..*/
  3  1416 ,"00001000"b	/* \012  */	/*..*/
  3  1417 ,"00001000"b	/* \013  */	/*..*/
  3  1418 ,"00001000"b	/* \014  */	/*..*/
  3  1419 ,"00000000"b	/* \015  */	/*..*/
  3  1420 ,"00000000"b	/* \016  */	/*..*/
  3  1421 ,"00000000"b	/* \017  */	/*..*/
  3  1422 ,"00000000"b	/* \020  */	/*..*/
  3  1423 /*ANULMOXGx*/	/**/
  3  1424 ,"00000000"b	/* \021  */	/*..*/
  3  1425 ,"00000000"b	/* \022  */	/*..*/
  3  1426 ,"00000000"b	/* \023  */	/*..*/
  3  1427 ,"00000000"b	/* \024  */	/*..*/
  3  1428 ,"00000000"b	/* \025  */	/*..*/
  3  1429 ,"00000000"b	/* \026  */	/*..*/
  3  1430 ,"00000000"b	/* \027  */	/*..*/
  3  1431 ,"00000000"b	/* \030  */	/*..*/
  3  1432 /*ANULMOXGx*/	/**/
  3  1433 ,"00000000"b	/* \031  */	/*..*/
  3  1434 ,"00000000"b	/* \032  */	/*..*/
  3  1435 ,"00000000"b	/* \033  */	/*..*/
  3  1436 ,"00000000"b	/* \034  */	/*..*/
  3  1437 ,"00000000"b	/* \035  */	/*..*/
  3  1438 ,"00000000"b	/* \036  */	/*..*/
  3  1439 ,"000000010"b	/* \037  */	/*..*/
  3  1440 ,"00001000"b	/* \040  */	/*..*/
  3  1441 /*ANULMOXGx*/	/**/
  3  1442 ,"00000001"b	/* \041 ! */	/*..*/
  3  1443 ,"00000001"b	/* \042 " */	/*..*/
  3  1444 ,"00000001"b	/* \043 # */	/*..*/
  3  1445 ,"00000001"b	/* \044 $ */	/*..*/
  3  1446 ,"00000001"b	/* \045 % */	/*..*/
  3  1447 ,"00000001"b	/* \046 & */	/*..*/
  3  1448 ,"00000001"b	/* \047 ' */	/*..*/
  3  1449 ,"00000001"b	/* \050 ( */	/*..*/
  3  1450 /*ANULMOXGx*/	/**/
  3  1451 ,"00000001"b	/* \051 ) */	/*..*/
  3  1452 ,"00000001"b	/* \052 * */	/*..*/
  3  1453 ,"00000001"b	/* \053 + */	/*..*/
  3  1454 ,"00000001"b	/* \054 , */	/*..*/
  3  1455 ,"00000001"b	/* \055 - */	/*..*/
  3  1456 ,"00000001"b	/* \056 . */	/*..*/
  3  1457 ,"00000001"b	/* \057 / */	/*..*/
  3  1458 ,"01000111"b	/* \060 0 */	/*..*/
  3  1459 /*ANULMOXGx*/	/**/
  3  1460 ,"01000111"b	/* \061 1 */	/*..*/
  3  1461 ,"01000111"b	/* \062 2 */	/*..*/
  3  1462 ,"01000111"b	/* \063 3 */	/*..*/
  3  1463 ,"01000111"b	/* \064 4 */	/*..*/
  3  1464 ,"01000111"b	/* \065 5 */	/*..*/
  3  1465 ,"01000111"b	/* \066 6 */	/*..*/
  3  1466 ,"01000111"b	/* \067 7 */	/*..*/
  3  1467 ,"01000011"b	/* \070 8 */	/*..*/
  3  1468 /*ANULMOXGx*/	/**/
  3  1469 ,"01000011"b	/* \071 9 */	/*..*/
  3  1470 ,"00000001"b	/* \072 : */	/*..*/
  3  1471 ,"00000001"b	/* \073 ; */	/*..*/
  3  1472 ,"00000001"b	/* \074 < */	/*..*/
  3  1473 ,"00000001"b	/* \075 = */	/*..*/
  3  1474 ,"00000001"b	/* \076 > */	/*..*/
  3  1475 ,"00000001"b	/* \077 ? */	/*..*/
  3  1476 ,"00000001"b	/* \100 @ */	/*..*/
  3  1477 /*ANULMOXGx*/	/**/
  3  1478 ,"10100011"b	/* \101 A */	/*..*/
  3  1479 ,"10100011"b	/* \102 B */	/*..*/
  3  1480 ,"10100011"b	/* \103 C */	/*..*/
  3  1481 ,"10100011"b	/* \104 D */	/*..*/
  3  1482 ,"10100011"b	/* \105 E */	/*..*/
  3  1483 ,"10100011"b	/* \106 F */	/*..*/
  3  1484 ,"10100001"b	/* \107 G */	/*..*/
  3  1485 ,"10100001"b	/* \110 H */	/*..*/
  3  1486 /*ANULMOXGx*/	/**/
  3  1487 ,"10100001"b	/* \111 I */	/*..*/
  3  1488 ,"10100001"b	/* \112 J */	/*..*/
  3  1489 ,"10100001"b	/* \113 K */	/*..*/
  3  1490 ,"10100001"b	/* \114 L */	/*..*/
  3  1491 ,"10100001"b	/* \115 M */	/*..*/
  3  1492 ,"10100001"b	/* \116 N */	/*..*/
  3  1493 ,"10100001"b	/* \117 O */	/*..*/
  3  1494 ,"10100001"b	/* \120 P */	/*..*/
  3  1495 /*ANULMOXGx*/	/**/
  3  1496 ,"10100001"b	/* \121 Q */	/*..*/
  3  1497 ,"10100001"b	/* \122 R */	/*..*/
  3  1498 ,"10100001"b	/* \123 S */	/*..*/
  3  1499 ,"10100001"b	/* \124 T */	/*..*/
  3  1500 ,"10100001"b	/* \125 U */	/*..*/
  3  1501 ,"10100001"b	/* \126 V */	/*..*/
  3  1502 ,"10100001"b	/* \127 W */	/*..*/
  3  1503 ,"10100001"b	/* \130 X */	/*..*/
  3  1504 /*ANULMOXGx*/	/**/
  3  1505 ,"10100001"b	/* \131 Y */	/*..*/
  3  1506 ,"10100001"b	/* \132 Z */	/*..*/
  3  1507 ,"00000001"b	/* \133 [ */	/*..*/
  3  1508 ,"00000001"b	/* \134 \ */	/*..*/
  3  1509 ,"00000001"b	/* \135 ] */	/*..*/
  3  1510 ,"00000001"b	/* \136 ^ */	/*..*/
  3  1511 ,"10000001"b	/* \137 _ */	/*..*/
  3  1512 ,"00000001"b	/* \140 ` */	/*..*/
  3  1513 /*ANULMOXGx*/	/**/
  3  1514 ,"10010011"b	/* \141 a */	/*..*/
  3  1515 ,"10010011"b	/* \142 b */	/*..*/
  3  1516 ,"10010011"b	/* \143 c */	/*..*/
  3  1517 ,"10010011"b	/* \144 d */	/*..*/
  3  1518 ,"10010011"b	/* \145 e */	/*..*/
  3  1519 ,"10010011"b	/* \146 f */	/*..*/
  3  1520 ,"10010001"b	/* \147 g */	/*..*/
  3  1521 ,"10010001"b	/* \150 h */	/*..*/
  3  1522 /*ANULMOXGx*/	/**/
  3  1523 ,"10010001"b	/* \151 i */	/*..*/
  3  1524 ,"10010001"b	/* \152 j */	/*..*/
  3  1525 ,"10010001"b	/* \153 k */	/*..*/
  3  1526 ,"10010001"b	/* \154 l */	/*..*/
  3  1527 ,"10010001"b	/* \155 m */	/*..*/
  3  1528 ,"10010001"b	/* \156 n */	/*..*/
  3  1529 ,"10010001"b	/* \157 o */	/*..*/
  3  1530 ,"10010001"b	/* \160 p */	/*..*/
  3  1531 /*ANULMOXGx*/	/**/
  3  1532 ,"10010001"b	/* \161 q */	/*..*/
  3  1533 ,"10010001"b	/* \162 r */	/*..*/
  3  1534 ,"10010001"b	/* \163 s */	/*..*/
  3  1535 ,"10010001"b	/* \164 t */	/*..*/
  3  1536 ,"10010001"b	/* \165 u */	/*..*/
  3  1537 ,"10010001"b	/* \166 v */	/*..*/
  3  1538 ,"10010001"b	/* \167 w */	/*..*/
  3  1539 ,"10010001"b	/* \170 x */	/*..*/
  3  1540 /*ANULMOXGx*/	/**/
  3  1541 ,"10010001"b	/* \171 y */	/*..*/
  3  1542 ,"10010001"b	/* \172 z */	/*..*/
  3  1543 ,"00000001"b	/* \173 { */	/*..*/
  3  1544 ,"00000001"b	/* \174 | */	/*..*/
  3  1545 ,"00000001"b	/* \175 } */	/*..*/
  3  1546 ,"00000001"b	/* \176 ~ */	/*..*/
  3  1547 ,"00000000"b	/* \177 */	/*..*/
  3  1548 ,(384)(9)"0"b
  3  1549 );
  3  1550 
  3  1551 end	ted_vtab_;
      591 
  4     1 /* BEGIN INCLUDE FILE ..... ted_eval_t_.incl.pl1 .....
  4     2* 6/05/80  1504.3 mst Th. From >udd>m>jaf>install>ev.lrk */
  4     3 
  4     4 dcl  1 ted_eval_t_$TL	ext static,
  4     5 	  2 TLsize	fixed bin,
  4     6 	  2 TL(72),
  4     7 	    3(pt,ln)	fixed bin(17)unal;
  4     8 
  4     9 dcl  1 ted_eval_t_$TC	ext static,
  4    10 	  2 TCsize	fixed bin,
  4    11 	  2 TC	char(161);
  4    12 
  4    13 dcl  1 ted_eval_t_$DPDA	ext static,
  4    14 	  2 DPDAsize	fixed bin,
  4    15 	  2 DPDA(4210),
  4    16 	    3(v1,v2)	fixed bin(17)unal;
  4    17 dcl  DPDAp	ptr;
  4    18 
  4    19 /*   END INCLUDE FILE ..... ted_eval_t_.incl.pl1 ..... */
      592 
      593 
      594 /* . . . cka . . . */
      595 cka: proc (i) returns (fixed bin (21));
      596 				/* Check "i" as a valid index for    */
      597 				/*  the "a" array.		       */
      598       if (i < alb) | (i > aub)
      599       then do;
      600          msg = "Vsa) Subscript not in a[-200:200].";
      601          goto err_ret;
      602       end;
      603       return (i);
      604 dcl i		fixed bin (21) parm;
      605    end cka;
      606 
      607 
      608 /* . . . ckk . . . */
      609 ckk: proc (i) returns (fixed bin (21));
      610 				/* Check "i" as a valid index for    */
      611 				/*  the "k" array.		       */
      612       if (i < klb) | (i > kub)
      613       then do;
      614          msg = "VSk) Subscript not in k[-200:200].";
      615          goto err_ret;
      616       end;
      617       return (i);
      618 dcl i		fixed bin (21) parm;
      619    end ckk;
      620 
      621 
      622 /* . . . ckK . . . */
      623 ckK: proc (i) returns (fixed bin (21));
      624 				/* Check "i" as a valid index for    */
      625 				/*  the "K" array.		       */
      626       if (i < Klb) | (i > Kub)
      627       then do;
      628          msg = "VsK) Subscript not in K[-10:10].";
      629          goto err_ret;
      630       end;
      631       return (i);
      632 dcl i		fixed bin (21) parm;
      633    end ckK;
      634 
      635 /* . . . STRING_TYPE . . . */
      636 STRING_TYPE: proc returns (fixed bin);
      637 
      638 dcl hold_string	char (20);
      639 
      640       hold_string = ns_string;
      641 				/* Evaluate the string. */
      642       if nc > te then return (2);	/* <string>. */
      643       goto typ (index ("xXoO", substr (is, nc, 1)));
      644 typ (0): return (2);		/* <string>. */
      645 typ (1):
      646 typ (2):				/* <hexvalue>. */
      647       nc = nc + 1;			/* Skip the "x". */
      648       rn = 9;			/* location of the right hex field.  */
      649       ns_num = 0;
      650 				/* Proliferate first bit left. */
      651       if length (ns_string) > 0
      652       then if substr (hold_string, 1, 1) > "7"
      653 	 then unspec (ns_num) = (36)"1"b;
      654       do i = length (ns_string) to 1 by -1; /* Assign right to left. */
      655          j = index ("0123456789ABCDEFabcdef", substr (hold_string, i, 1));
      656          if j < 1
      657          then do;
      658 	  msg = "Vbx) Bad hex digit, """;
      659 	  msg = msg || ns_string;
      660 	  msg = msg || """";
      661 	  goto err_ret;
      662          end;
      663          if j > 16
      664          then j = j - 6;		/* Adjust for lower case letters. */
      665          addr (ns_num) -> hex (rn) = hexv (j);
      666          rn = rn - 1;
      667       end;
      668       ls.num (-la_put) = ns_num;
      669       return (1);			/* <integer> */
      670 typ (3):
      671 typ (4):				/* <octvalue>. */
      672       nc = nc + 1;			/* Skip the "o". */
      673       rn = 12;			/* location of the right oct field.  */
      674       ns_num = 0;
      675 				/* Proliferate first bit left. */
      676       if length (ns_string) > 0
      677       then if substr (hold_string, 1, 1) > "3"
      678 	 then unspec (ns_num) = (36)"1"b;
      679       do i = length (ns_string) to 1 by -1; /* Assign right to left. */
      680          j = index ("01234567", substr (hold_string, i, 1));
      681          if j < 1
      682          then do;
      683 	  msg = "Vbo) Bad octal digit. """;
      684 	  msg = msg || ns_string;
      685 	  msg = msg || """";
      686 	  goto err_ret;
      687          end;
      688          addr (ns_num) -> oct (rn) = octv (j);
      689          rn = rn - 1;
      690       end;
      691       ls.num (-la_put) = ns_num;
      692       return (1);			/* <integer> */
      693 
      694 dcl (i, j,
      695     rn)		fixed bin (21),
      696     hex		(9) bit (4) based,
      697     hexv		(16) bit (4) static internal init (
      698 		"0000"b, "0001"b, "0010"b, "0011"b,
      699 		"0100"b, "0101"b, "0110"b, "0111"b,
      700 		"1000"b, "1001"b, "1010"b, "1011"b,
      701 		"1100"b, "1101"b, "1110"b, "1111"b),
      702     oct		(12) bit (3) based,
      703     octv		(8) bit (3) static internal init (
      704 		"000"b, "001"b, "010"b, "011"b,
      705 		"100"b, "101"b, "110"b, "111"b);
      706    end STRING_TYPE;
      707 
      708 /* . . . Global declarations . . . */
      709 dcl
      710     (ioa_$ioa_switch,
      711      ioa_$nnl)	entry options (variable),
      712 
      713 /* Input files. */
      714     IP		ptr,
      715     te		fixed bin (24),
      716     is		char (te) aligned based (IP),
      717     1 CHAR_ARRAY	aligned based (IP),
      718       2 ic	(te) char (1) unaligned,
      719     1 BIT_ARRAY	aligned based (IP),
      720       2 ib	(te) bit (9) unaligned;
      721 
      722 dcl (abs, addrel, char, collate9, divide, hbound, index, lbound, length, 
      723     ltrim, max, min, null, pointer, rel, reverse, search, string, substr,
      724     unspec, verify
      725     )		builtin;
      726 
      727 /* Declaration of Automatic data. */
      728 dcl fc		fixed bin (21);
      729 dcl l		fixed bin (21);
      730 dcl lgnc		fixed bin (21);
      731 dcl lnl		fixed bin (21);
      732 dcl nc		fixed bin (21);
      733 
  5     1 /* BEGIN INCLUDE FILE ..... tedcommon_.incl.pl1 ..... 02/15/82 J Falksen */
  5     2 
  5     3 /*		         ted common data area			       */
  5     4 
  5     5 dcl 1 tedcommon_$id ext static,
  5     6       2 ted_vers char(12)var;		/*  version.revision	       */
  5     7 
  5     8 dcl 1 tedcommon_$no_data	like buf_des ext static;
  5     9 dcl 1 tedcommon_$no_seg	like seg_des ext static;
  5    10 
  5    11 dcl 1 tedcommon_$etc ext static,
  5    12       2 com_blank   bit(1)aligned,
  5    13       2 com1_blank  bit(1)aligned,
  5    14       2 caps	bit(1)aligned,
  5    15       2 reset_read	bit(1)aligned,
  5    16       2 sws,
  5    17         3 (db_ted, lg_ted)	bit(1)aligned,
  5    18         3 (db_addr, lg_addr)	bit(1)aligned,
  5    19         3 (db_eval, lg_eval)	bit(1)aligned,
  5    20         3 (db_sort, lg_sort)	bit(1)aligned,
  5    21         3 (db_gv, lg_gv)	bit(1)aligned,
  5    22         3 (db_util, lg_util)	bit(1)aligned,
  5    23         3 (db_srch, lg_srch)	bit(1)aligned,
  5    24         3 (db_glob, lg_glob)	bit(1)aligned,
  5    25         3 (db_trac, lg_sp4)	bit(1)aligned,
  5    26         3 (db_Ed, lg_sp3)	bit(1)aligned,
  5    27         3 (db_sp2, lg_sp2)	bit(1)aligned,
  5    28         3 (db_sp1, lg_sp1)	bit(1)aligned,
  5    29         3 (db_catch, lg_catch)bit(1)aligned,
  5    30       2 db_output ptr;
  5    31 
  5    32 /* END INCLUDE FILE ..... tedcommon_.incl.pl1 ..... */
      734 
  6     1 /* BEGIN INCLUDE FILE ..... tedbase.incl.pl1 ..... 02/09/82 J Falksen       */
  6     2 
  6     3 dcl NORMAL	fixed bin (24) int static init (0),
  6     4     SAFE		fixed bin (24) int static init (1),
  6     5     COM		fixed bin (24) int static init (2),
  6     6     RESTART	fixed bin (24) int static init (3);
  6     7 
  6     8 dcl rc_close	fixed bin (24) int static init (100);
  6     9 dcl rc_fail	fixed bin (24) int static init (10);
  6    10 dcl rc_nop	fixed bin (24) int static init (2);
  6    11 dcl rc_keyerr	fixed bin (24) int static init (1);
  6    12 
  6    13 /*** the request line as both string and character		       */
  6    14 dcl rl_b		fixed bin (21);	/* where current req begins	       */
  6    15 dcl rl_i		fixed bin (21) defined (dbase.rl.l.le);
  6    16 dcl rl_l		fixed bin (21) defined (dbase.rl.l.re);
  6    17 dcl rl_c		(rl_l) char (1) based (dbase.rl.sp);
  6    18 dcl rl_s		char (rl_l) based (dbase.rl.sp);
  6    19 
  6    20 dcl 1 seg_des	based,		/* segment descriptor	       */
  6    21       2 sp	ptr,		/* -> segment		       */
  6    22       2 sn	fixed bin,	/* sequence # in dbase	       */
  6    23       2 pn	fixed bin,	/* part #, if in pool	       */
  6    24       2 ast	fixed bin,	/* size of aste		       */
  6    25       2 mbz	fixed bin;	/* --reserved		       */
  6    26 
  6    27       
  6    28 
  6    29 dcl dbase_p	ptr;
  6    30 dcl dbase_vers_3	fixed bin int static init (3);
  6    31 dcl 1 dbase	based (dbase_p),
  6    32       2 version	fixed bin,
  6    33       2 recurs	fixed bin,	/* recursion level at which active   */
  6    34       2 bwd	ptr,		/* links active db's together	       */
  6    35       2 cba_p	ptr,		/* contains addr (cb (1))	       */
  6    36       2 eval_p	ptr,		/* contains cb (2).sp	       */
  6    37       2 rl,			/* describes the request buffer      */
  6    38         3 part1	like seg_des,	/* ..its segment		       */
  6    39         3 part2	like buf_des,	/* ..its limits		       */
  6    40       2 seg_p	(-1:72) ptr,	/* list of segment pointers	       */
  6    41 				/* seg_p(-1)is a temp for restart    */
  6    42 				/* seg_p(0) is the database	       */
  6    43 				/* seg_p(1) is the 1K/4K pool	       */
  6    44 				/* seg_p(2) is reserved for 16K pool */
  6    45 				/* seg_p(3) is reserved for call_stk */
  6    46       2 inuse_seg	bit (72) aligned,	/* which segments (1:72) are in use  */
  6    47 				/* seg_p(0) is ALWAYS in use	       */
  6    48       2 inuse_1K	bit (16) aligned,	/* which 1K buffers are in use       */
  6    49       2 inuse_4K	bit (12) aligned,	/* which 4K buffers are in use       */
  6    50       2 inuse_16K	bit (4) aligned,	/* which 16K buffers are in use      */
  6    51       2 reset	label,		/* where to go on a reset condition  */
  6    52       2 time	fixed bin (71),	/* time request id is based on       */
  6    53       2 seg_ct	fixed bin,	/* how many segments in use	       */
  6    54 				/* seg_p (0)--database	       */
  6    55 				/* seg_p (1)--4K pool (64K total)    */
  6    56 				/* seg_p (2)--16K pool (64K total)   */
  6    57       2 argct	fixed bin,	/* how many args to ted	       */
  6    58       2 S_count	fixed bin,	/* # matches on last substitute      */
  6    59       2 not_read_ct fixed bin,	/* how many "not-read" files	       */
  6    60       2 at_break	fixed bin,	/* 1-break pending, 2-break entered  */
  6    61       2 bufnum	fixed bin,	/* how many buffer control blocks    */
  6    62       2 lock        bit (36),		/* to find if active (set LAST!)     */
  6    63       2 cb_c_r	bit (18) aligned,	/* offset of current buffer	       */
  6    64       2 cb_w_r	bit (18) aligned,	/* offset of buffer being worked on  */
  6    65       2 sws,
  6    66         3 flow_sw	bit (1) unal,	/* -label specified		       */
  6    67         3 break_sw	bit (1) unal,	/* -break specified		       */
  6    68         3 edit_sw	bit (1) unal,	/* -trace_edit specified	       */
  6    69         3 input_sw	bit (1) unal,	/* -trace_input		       */
  6    70         3 old_style bit (1) unal,	/* 1-old-style escapes allowed       */
  6    71         3 remote_sw bit (1) unal,	/* 1-not in home_dir	       */
  6    72         3 read_sw   bit (1) unal,	/* 1-always read files	       */
  6    73         3 lit_sw    bit (1) unal,	/* 1-expressions are literal	       */
  6    74         3 fill	bit (28) unal,
  6    75       2 tedname	char (32) var,	/* name under which ted_ was called  */
  6    76       2 comment     char (256)var,	/* user ident of environment	       */
  6    77       2 err_msg	char (168)var,
  6    78       2 regexp	char (500),	/* holds the remembered regular expr */
  6    79 				/*  is placed here to get word       */
  6    80 				/*  alignment		       */
  6    81       2 dir_db	char (168),	/* where work segments live	       */
  6    82       2 person      char (22),	/* who started		       */
  6    83       2 project     char (9),		/* ...this environment	       */
  6    84       2 nulreq	char (2),		/* what is null request (p|P|!p)     */
  6    85       2 err_go	char (16),	/* label to go to on error	       */
  6    86       2 rq_id       char (19),	/* request id for this	       */
  6    87       2 stk_info,
  6    88         3 curp	ptr,		/* pointer to current buffer	       */
  6    89         3 top	ptr,		/* pointer to top of stack	       */
  6    90         3 level	fixed bin (21),	/* recursion depth		       */
  6    91         3 next	fixed bin (21);
  6    92       /* next space available in stack     */
  6    93       
  6    94 
  6    95 /* END INCLUDE FILE ..... tedbase.incl.pl1 .....			       */
      735 
  7     1 /* BEGIN INCLUDE FILE ..... tedbcb.incl.pl1 ..... 01/29/82 J Falksen	       */
  7     2 
  7     3 /* UPDATE HISTORY (finally)					       */
  7     4 /* EL#   date	TR	comments				       */
  7     5 /* --- 84-10-19 -------- add sws.INPUT				       */
  7     6 /* --- 84-10-29 -------- add sws.invoking			       */
  7     7 
  7     8 /* if the structure of buf_des changes, tedcommon_.alm and		       */
  7     9 /*  tedcommon.incl.pl1 must be appropriately changed		       */
  7    10 
  7    11 dcl 1 buf_des	(all_des) based (bp),  /* buffer part descriptor	       */
  7    12       2 l,			/* left end (LHE) data (see Note 1)  */
  7    13         3 ln	fixed bin (21),	/*  line number		       */
  7    14         3 le	fixed bin (21),	/*  left  end (LE) offset	       */
  7    15         3 re	fixed bin (21),	/*  right end (RE) offset	       */
  7    16       2 r		like buf_des.l;	/* right end (RHE) data	       */
  7    17 
  7    18 /* Note1:	buf_des describes 2 slightly different things, buffer parts and    */
  7    19 /* 	addresses. These are the circumstances:			       */
  7    20 /*							       */
  7    21 /*							       */
  7    22 /*		|...............<buffer>..........................|      */
  7    23 /*	  b.cur.sp|	|..........<window>...........|	|      */
  7    24 /*	Buffer:	xxxxxxxxxxwwwwwwwwwwwww...<hole>...wwwwwwxxxxxxxxxx      */
  7    25 /*			|	  |	     |	|	|      */
  7    26 /*	           b.b_.l.le|  b.b_.l.re|   b.b_.r.le|	|     maxl|      */
  7    27 /*		    	   b.b_.l.ln|	 b.b_.r.le|    maxln|      */
  7    28 /*					 b.b_.r.ln|	       */
  7    29 /*    b.b_.l.ln (if known) tells the # of lines in left part of window       */
  7    30 /*    b.b_.r.ln (if known) tells the # of lines the whole window	       */
  7    31 /*    b.maxln   (if known) tells the # of lines in the whole buffer	       */
  7    32 /*	Either left or right part may be null. A ^read file	       */
  7    33 /*	is in the right part. A file is always read at the	       */
  7    34 /*	upper end of the hole. This will usually minimize the	       */
  7    35 /*	amount of data movement during subsequent editing		       */
  7    36 /*	operations.					       */
  7    37 /*							       */
  7    38 /* Data movement which occurs within a request, for example substitute, can  */
  7    39 /*  cause an offset to temporarily point into the hole. This will clear up   */
  7    40 /*  before the operation is complete.				       */
  7    41 
  7    42 /*						N	       */
  7    43 /*	Address:	....xxxxxxxxxxsssss -- sssssssxxxxxxxxxxL....	       */
  7    44 /*		    |	    |	         |	|	       */
  7    45 /*		l.le|	l.re|	     r.le|      r.re|	       */
  7    46 /*			l.ln|		      r.ln|	       */
  7    47 /*	l.re is the beginning of the string addressed.		       */
  7    48 /*	l.le is the beginning of line containing location l.re	       */
  7    49 /*		Thus l.ln is related to both l.re and l.le	       */
  7    50 /*	r.re is the end of the string addressed.		       */
  7    51 /*	r.le is the end of line containing location r.re		       */
  7    52 /*		Thus r.ln is related to both r.re and r.le	       */
  7    53 /*	(l.le and r.le relate to the same line when 1 line is addressed)   */
  7    54 /* In line mode each request starts with     l.re=l.le   &   r.re=r.le       */
  7    55 /* In string mode a global request forces these conditions.		       */
  7    56 
  7    57 /*** b_c/b_s reference the string which represents the buffer data.	       */
  7    58 dcl b_c		(b.maxl) char (1) based (b.cur.sp);
  7    59 dcl b_s		char (b.maxl) based (b.cur.sp);
  7    60 
  7    61 dcl (live_des	init (8),
  7    62     all_des	init (13),
  7    63     reloc_first	init (2),		/* where to begin minus 1	       */
  7    64     reloc_last	init (8)		/* where to stop		       */
  7    65     )		fixed bin int static options (constant);
  7    66 dcl bp		ptr;
  7    67 dcl 1 b		based (bp),	/* ted buffer control block	       */
  7    68       2 b_	like buf_des,	/* defines buffer limits	       */
  7    69       2 newb	like buf_des,	/* pending buffer values	       */
  7    70       2 ex	like buf_des,	/* execution limits		       */
  7    71       2 a_	(0:2) like buf_des, /* address data		       */
  7    72 				/*  (0)  "cur location"	       */
  7    73 				/*  (1)  1st addr result	       */
  7    74 				/*  (2)  2nd addr result	       */
  7    75       2 cd	like buf_des,	/* copy destination		       */
  7    76       2 gb	like buf_des,	/* info for global processing	       */
  7    77       2 newa	like buf_des,	/* pending address values	       */
  7    78 				/*    ----limit of relocation----    */
  7    79 /* these are not relocated because they define the relocation data	       */
  7    80       2 rel_temp	like buf_des,	/* hold during relocation	       */
  7    81       2 temp	(0:2) like buf_des,	/* hold during [.]addr processing    */
  7    82       2 old,			/* where string used to be	       */
  7    83         3 (le,re)	fixed bin (21),	/*   ends of range		       */
  7    84       2 new	like b.old,	/* where string has gone to	       */
  7    85       2 test	like b.old,	/* allowable relocatable range       */
  7    86 				/* (may be 1 or 2 larger than b.old) */
  7    87       2 cur	like seg_des,	/* CURRENT buffer area info	       */
  7    88 				/*    (see note 2)		       */
  7    89       2 pend	like seg_des,	/* PENDING buffer area info	       */
  7    90       2 file_d,			/* file related data	       */
  7    91         3 dtcm	bit(36),		/* when read seg was modified	       */
  7    92         3 uid	bit(36),		/* unique ID of segment	       */
  7    93         3 dname	char(168),	/* directory of file	       */
  7    94         3 ename	char(32),		/* entry of file		       */
  7    95         3 cname	char(32),		/* component of file	       */
  7    96         3 kind	char(1)unal,	/* kind of component	       */
  7    97 				/* " "-none, ":"-archive	       */
  7    98 				/*  "|"-superfile		       */
  7    99         3 sws	unal,
  7   100           4 file_sw	        bit(1),	/* 1-file associated	       */
  7   101           4 trust_sw        bit(1),	/* 1-file name trustable	       */
  7   102           4 mod_sw	        bit(1),	/* 1-buffer has been modified	       */
  7   103           4 terminate       bit(1),	/* 1-dp points to file, terminate    */
  7   104           4 get_bit_count   bit(1),	/* 1-get_bit_count before using this */
  7   105 			/*  buffer, it may have been modified by       */
  7   106 			/*  externally via [ted$buffer xx] usage       */
  7   107           4 force_name      bit(1),	/* 1-name has been forced	       */
  7   108           4 no_io	        bit(1),	/* 1-no r w ^b allowed	       */
  7   109 				/*  (external string edit)	       */
  7   110           4 not_pasted      bit(1),	/* 1-data was moved into buffer but  */
  7   111 				/*  has not been read anywhere       */
  7   112           4 initiate        bit(1),	/* 1-must initiate on restart	       */
  7   113 				/*  (b% and b!)		       */
  7   114           4 ck_ptr_sw       bit(1),	/* 1-if segment is external, must    */
  7   115 				/*  check pointer before ref	       */
  7   116           4 pseudo	        bit (1),	/* 1-^read or read-only buffer       */
  7   117           4 INPUT	        bit (1),	/* 1-active INPUT mode on buffer     */
  7   118           4 invoking        bit (1),	/* 1-buffer being invoked	       */
  7   119           4 fill	        bit (14),
  7   120       2 name	char(16),		/* buffer name		       */
  7   121       2 fill	char(27),
  7   122       2 stackl	bit (18)aligned,	/* offset of list of stacked data    */
  7   123       2 stack_o	bit (18)aligned,	/* offset of data being relocated    */
  7   124       2 present	(0:2) bit(1),	/* 1 if addr present	       */
  7   125       2 tw_sw	      bit(1),	/* 1-typewriter buffer	       */
  7   126       2 bs,			/* Old-style escapes in this buffer  */
  7   127         3 (c,b,r,f)       bit(1),	/* 1-\031,\030,\036,\034 found       */
  7   128       2 noref	      bit(1),	/* 1-not ref'ed, don't list	       */
  7   129       2 maxl	fixed bin(21),	/* max buffer length in this AST     */
  7   130       2 maxln	fixed bin(21),	/* number of lines in buffer	       */
  7   131       2 state_r	fixed bin(21),	/* what state is request in	       */
  7   132       2 (N1,N2,N3)	fixed bin(21),	/* values kept for -safe_ty	       */
  7   133       2 state_b	fixed bin(21);	/* what state is buffer change in    */
  7   134 
  7   135 /* Note2:	sn=0	means empty because the database segment will never      */
  7   136 /*		contain a buffer holder			       */
  7   137 /* 	sn=-1 (&^b.terminate) means read-only data, if modification is     */
  7   138 /* 		done, a copy will be made.			       */
  7   139 /* 	sn=-1 (& b.terminate) means ^read file, if modification is done    */
  7   140 /* 		the file is read first			       */
  7   141 /* 	sn>0	means a buffer holder segment			       */
  7   142 
  7   143 /* END INCLUDE FILE ..... tedbcb.incl.pl1 ..... */
      736 
  8     1 /* BEGIN INCLUDE FILE ..... tedstk.incl.pl1 ..... 04/16/76 J Falksen	       */
  8     2 
  8     3 dcl sv_p		ptr;
  8     4 dcl 1 sv		based (sv_p),
  8     5       2 prev	ptr,		/* ->previous frame		       */
  8     6       2 bp	ptr,		/* ->buffer control block last used  */
  8     7       2 ex	like b.ex,	/* execution limits in buffer	       */
  8     8       2 a0	like b.a_,	/* "." in buffer		       */
  8     9       2 stackl	bit (18)aligned,	/* linked list of occurances of same */
  8    10 				/*  buffer in the stack	       */
  8    11       2 fill	bit (36)aligned,
  8    12       2 this	fixed bin (21),	/* space index before this frame was */
  8    13 				/*  allocated		       */
  8    14       2 pn	fixed bin (21),	/* parameter number		       */
  8    15       2 pv (0:sv.pn),
  8    16         3 pp ptr,			/* pointer to parameter	       */
  8    17         3 pl fixed bin (21);		/* length of parameter	       */
  8    18 
  8    19 dcl  pstr		based char (256);
  8    20 
  8    21 dcl 1 call_stk	based (dbase.seg_p (3)),
  8    22       2 space	(2000) ptr;	/* place to put stack frames	       */
  8    23 
  8    24 /* END INCLUDE FILE ..... tedstk.incl.pl1 .....			       */
      737 
      738 dcl tedget_segment_ entry (		/* get a segment to work in	       */
      739 		ptr,		/* -> database		       */
      740 		ptr,		/* -> gotten segment	 [OUT] */
      741 		fixed bin,	/* sequence # of it         [IN/OUT] */
      742 				/* if >0 upon entry, it will then    */
      743 				/*  fill that entry in seg_p array   */
      744 				/* otherwise it will take any one    */
      745 		);
      746 
      747 
      748 dcl tedcount_lines_ entry (		/* return # lines in string	       */
      749 		ptr,		/* -> buffer in which to count       */
      750 		fixed bin (21),	/* where string begins in segment    */
      751 		fixed bin (21),	/* where string ends in segment      */
      752 		fixed bin (21)	/* # lines		 [OUT] */
      753 		);
      754 
      755 
      756 dcl db_sw bit (1) int static init ("0"b);
      757 dbn: entry; db_sw = "1"b; return;
      758 dbf: entry; db_sw = "0"b; return;
      759    end tedeval_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/18/84  0907.8  tedeval_.pl1                      >spec>online>7008>tedeval_.pl1
123          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
152          2    12/18/84  0904.8  ted_eval_p_.incl.pl1              >spec>online>7008>ted_eval_p_.incl.pl1
591          3    12/18/84  0904.7  ted_eval_.incl.pl1                >spec>online>7008>ted_eval_.incl.pl1
592          4    11/23/82  1324.6  ted_eval_t_.incl.pl1              >ldd>include>ted_eval_t_.incl.pl1
734          5    12/18/84  0904.9  tedcommon_.incl.pl1               >spec>online>7008>tedcommon_.incl.pl1
735          6    11/23/82  1324.7  tedbase.incl.pl1                  >ldd>include>tedbase.incl.pl1
736          7    12/18/84  0906.0  tedbcb.incl.pl1                   >spec>online>7008>tedbcb.incl.pl1
737          8    11/23/82  1324.7  tedstk.incl.pl1                   >ldd>include>tedstk.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABREV                           016441 constant        fixed bin(21,0)          initial dcl 2-246 ref 364 368 3-260 3-320
AEXP                                   constant        fixed bin(21,0)          initial dcl 2-246 set ref 3-210 3-234* 3-236* 3-242*
                                                                                  3-250* 3-266 3-303 3-575* 3-586* 3-922* 3-924*
                                                                                  3-925 3-930* 3-932* 3-933 3-941* 3-943* 3-944
                                                                                  3-949* 3-951* 3-952 3-957* 3-959* 3-960 3-969*
                                                                                  3-975* 3-991 3-995* 3-1001 3-1011 3-1017 3-1024
                                                                                  3-1071 3-1110* 3-1112* 3-1116 3-1123 3-1135 3-1145
                                                                                  3-1157 3-1174 3-1184 3-1194 3-1208 3-1213 3-1229
                                                                                  3-1234 3-1251 3-1256 3-1273 3-1278 3-1301 3-1348
                                                                                  3-1362
BIT_ARRAY                              based           structure                level 1 dcl 709
CAT                                    constant        fixed bin(21,0)          initial dcl 2-246 set ref 3-89 3-138* 3-147* 3-215
                                                                                  3-244* 3-252* 3-258* 3-470* 3-472* 3-578* 3-587*
                                                                                  3-646* 3-648* 3-649* 3-701 3-734 3-821* 3-823*
                                                                                  3-829* 3-831* 3-849 3-854* 3-869 3-894* 3-895*
                                                                                  3-1120* 3-1127* 3-1129* 3-1138* 3-1140* 3-1149*
                                                                                  3-1151* 3-1161* 3-1163* 3-1178* 3-1180* 3-1187*
                                                                                  3-1189* 3-1197* 3-1218* 3-1239* 3-1261* 3-1325
CHAR_ARRAY                             based           structure                level 1 dcl 709
DPDA                      1     000034 external static structure                array level 2 packed unaligned dcl 4-13
IP                              002170 automatic       pointer                  dcl 709 set ref 145 235 250* 257 259 262 263 266 271
                                                                                  272 273 283 286 290 304 312 312 396 399 428 475
                                                                                  488 570 576* 643
K                     10051            based           varying char(500)        array level 2 dcl 62 set ref 3-200 3-200 3-200
                                                                                  3-200* 3-253* 3-358 3-360
Klb                             016442 constant        fixed bin(17,0)          initial dcl 83 ref 3-198 626
Kub                                    constant        fixed bin(17,0)          initial dcl 83 ref 3-198 626
LEXP                                   constant        fixed bin(21,0)          initial dcl 2-246 set ref 3-212 3-266 3-694* 3-709*
                                                                                  3-866 3-887 3-896 3-912 3-1331 3-1359
NL                              000011 internal static char(1)                  initial unaligned dcl 3-135 set ref 3-140 3-140
R                               002534 automatic       fixed bin(21,0)          array dcl 3-891 set ref 3-901* 3-902 3-903 3-903*
                                                                                  3-903* 3-904 3-905* 3-905 3-907 3-907
S_count                 266            based           fixed bin(17,0)          level 2 dcl 6-31 ref 3-1022
TC                        1     000032 external static char(161)                level 2 packed unaligned dcl 4-9 ref 2-294 2-300
TL                        1     000030 external static structure                array level 2 packed unaligned dcl 4-4
XXloc                           002516 automatic       pointer                  array dcl 3-644 set ref 3-652* 3-657* 3-657* 3-657*
                                                                                  3-662* 3-664* 3-664 3-666* 3-666 3-685
XXnum                           002526 automatic       fixed bin(21,0)          array dcl 3-645 set ref 3-653* 3-658* 3-659* 3-659*
                                                                                  3-663* 3-665* 3-667* 3-667 3-667 3-678 3-685 3-685
                                                                                  3-687
a_                       22            based           structure                array level 2 unaligned dcl 7-67
abs                                                    builtin function         dcl 722 ref 3-608
adb_p                                  parameter       pointer                  dcl 27 ref 25 97
addr                                                   builtin function         dcl 2-224 ref 115 116 116 235 370 370 3-86 3-139
                                                                                  3-139 3-140 3-140 3-179 3-346 3-349 3-355 3-358
                                                                                  3-366 3-373 3-395 3-411 3-420 3-454 3-455 3-462
                                                                                  3-473 3-525 3-579 3-580 3-588 3-589 3-650 3-651
                                                                                  3-652 3-657 3-662 3-664 3-666 3-669 3-680 3-692
                                                                                  3-707 3-738 3-745 3-750 3-756 3-761 3-765 3-770
                                                                                  3-774 3-779 3-783 3-786 3-796 3-798 3-804 3-806
                                                                                  3-812 3-814 3-824 3-825 3-832 3-833 3-840 3-867
                                                                                  3-868 3-897 3-898 3-907 3-907 3-907 3-907 3-1130
                                                                                  3-1131 3-1141 3-1142 3-1152 3-1153 3-1164 3-1165
                                                                                  3-1181 3-1182 3-1190 3-1191 3-1199 3-1200 3-1220
                                                                                  3-1221 3-1241 3-1242 3-1263 3-1264 3-1320 665 688
addrel                                                 builtin function         dcl 722 ref 3-349 3-358 3-798 3-806 3-814
ai                              000236 automatic       structure                level 1 unaligned dcl 122 set ref 116 116
ain_l                                  parameter       fixed bin(21,0)          dcl 27 set ref 25 140* 147* 2-19* 564*
ain_p                                  parameter       pointer                  dcl 27 set ref 25 140*
alb                             016443 constant        fixed bin(17,0)          initial dcl 83 ref 3-188 598
alternative_number                     parameter       fixed bin(21,0)          dcl 3-1398 ref 3-78 3-576 3-592 3-918 3-1295 3-1297
altn                            002101 automatic       fixed bin(21,0)          dcl 2-255 set ref 2-163* 2-164* 2-170*
ams_l                                  parameter       fixed bin(21,0)          dcl 27 ref 25 3-400 3-1050 3-1388
ams_p                                  parameter       pointer                  dcl 27 ref 25 3-396 3-398 3-1040 3-1050 3-1073
                                                                                  3-1384
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 1-3 ref 107
areap                    16     000236 automatic       pointer                  level 2 dcl 122 set ref 115*
argct                   265            based           fixed bin(17,0)          level 2 dcl 6-31 ref 3-1015
ascii                           002307 automatic       char(512)                unaligned dcl 3-460 set ref 3-452* 3-455
at                                     parameter       fixed bin(21,0)          dcl 3-1308 ref 3-1305 3-1310 3-1317 3-1320 3-1325
                                                                                  3-1328 3-1328 3-1331 3-1334 3-1334 3-1334 3-1347
                                                                                  3-1348 3-1353 3-1353 3-1353 3-1356 3-1358 3-1359
                                                                                  3-1362 3-1366
aub                                    constant        fixed bin(17,0)          initial dcl 83 ref 3-188 598
av                      177            based           fixed bin(24,0)          array level 2 dcl 62 set ref 3-190 3-190* 3-237*
                                                                                  3-989
avar                      3            based           bit(18)                  level 2 in structure "val" dcl 62 in procedure
                                                                                  "tedeval_" set ref 106* 357 3-205 3-322 3-340
                                                                                  3-341*
avar                                   based           structure                level 1 unaligned dcl 76 in procedure "tedeval_" set
                                                                                  ref 3-333
avar_len                        000121 automatic       fixed bin(21,0)          dcl 72 set ref 3-279* 3-286 3-292
avar_ptr                        000122 automatic       pointer                  dcl 73 set ref 358* 361 363 364 364 366 368 373 376*
                                                                                  3-206* 3-209 3-210 3-210 3-210 3-212 3-212 3-212
                                                                                  3-215 3-217 3-218* 3-263* 3-265 3-269 3-271 3-273
                                                                                  3-275 3-280 3-283 3-285 3-290 3-323* 3-326 3-327
                                                                                  3-329* 3-333* 3-335 3-337 3-338 3-339 3-340 3-341
                                                                                  3-726* 3-728 3-733 3-734 3-734 3-737
azAZ09                          000674 constant        char(63)                 initial unaligned dcl 506 in procedure "scanner" ref
                                                                                  262
azAZ09                          000454 constant        char(62)                 initial unaligned dcl 3-296 in procedure "ted_vtab_"
                                                                                  ref 3-314
b                                      based           structure                level 1 unaligned dcl 7-67
b_                                     based           structure                level 2 unaligned dcl 7-67
b_s                                    based           char                     unaligned dcl 7-59 ref 3-441 3-442
bp                              002202 automatic       pointer                  dcl 7-66 set ref 98* 99 102 102 103 128* 3-403 3-404
                                                                                  3-405 3-412 3-413 3-414 3-421 3-422 3-423 3-423
                                                                                  3-423 3-425 3-426 3-426 3-426 3-432 3-432 3-436
                                                                                  3-437 3-441 3-441 3-442 3-442 3-442 3-444 3-444
                                                                                  3-444 3-444 3-747 3-750 3-758 3-761 3-767 3-770
                                                                                  3-776 3-779 3-786 3-789 3-1032 3-1032 3-1042
                                                                                  3-1042 3-1052 3-1052 3-1060 3-1060 3-1070 3-1080
                                                                                  3-1082 3-1082 3-1084 3-1084 3-1084 3-1084 3-1294
                                                                                  3-1295 3-1297 3-1299* 3-1299 3-1386
buf_des                                based           structure                array level 1 unaligned dcl 7-11
buf_ptr                                parameter       pointer                  dcl 27 ref 25 128
c_str                                  based           char(20000)              unaligned dcl 2-279 ref 2-287
cat_l                           000114 automatic       fixed bin(21,0)          dcl 55 set ref 3-83 3-83 3-88 3-279* 3-282 3-282
                                                                                  3-289 3-289 3-438* 3-464* 3-561* 3-608* 3-670*
                                                                                  3-678* 3-678 3-843* 3-899* 3-900 3-900 3-1322*
cat_p                           000112 automatic       pointer                  dcl 54 set ref 361* 363* 364 370 370 370 3-83* 3-84
                                                                                  3-85 3-86 3-217* 3-218 3-218 3-218 3-271* 3-272
                                                                                  3-282* 3-283 3-285* 3-286 3-288 3-289* 3-290 3-292
                                                                                  3-441 3-442 3-466 3-563 3-623 3-632 3-637 3-685
                                                                                  3-737* 3-738 3-740 3-847 3-848 3-900* 3-902 3-904
                                                                                  3-907 3-907 3-908 3-1324
cata                  22130            based           area(1024)               level 2 dcl 62 set ref 115 3-83 3-272 3-282 3-288
                                                                                  3-289 3-333 3-900
catv                                   based           structure                level 1 unaligned dcl 56 set ref 3-83 3-121 3-272
                                                                                  3-282 3-288 3-289 3-900 3-908
ch2                             000107 automatic       char(1)                  unaligned dcl 51 set ref 259* 261* 319 332 345 349
                                                                                  383 472 3-187* 3-188 3-193 3-198 3-203
char                                                   builtin function         dcl 722 ref 3-1319
char16                          000125 automatic       varying char(16)         dcl 75 set ref 263* 323 353 356 364 366 378 387 389
                                                                                  390 391 393 406 408 411 423 426 436 438 441 443
                                                                                  444 445 448 450 451 452 456 458 460 461 464 468
                                                                                  501
cname                   224            based           char(32)                 level 3 packed unaligned dcl 7-67 set ref 3-776
                                                                                  3-779
code                                   parameter       fixed bin(35,0)          dcl 27 set ref 25 96* 116* 117 143* 2-18* 2-107*
collate9                                               builtin function         dcl 722 ref 3-452
comp                            002266 automatic       bit(3)                   unaligned dcl 3-100 set ref 3-871* 3-873* 3-875*
                                                                                  3-878* 3-880* 3-882* 3-884 3-907* 3-909
conc_sw                         000234 automatic       bit(1)                   unaligned dcl 94 set ref 129* 3-834 3-836*
control                   1     000236 automatic       structure                level 2 dcl 122
cur                     124            based           structure                level 2 unaligned dcl 7-67
cur_lex_top                     001571 automatic       fixed bin(17,0)          array dcl 2-252 set ref 2-59*
current_state                   002102 automatic       fixed bin(17,0)          dcl 2-256 set ref 2-5* 2-11 2-22 2-24 2-58 2-67 2-70
                                                                                  2-132* 2-133 2-134* 2-134 2-205* 2-209 2-217*
                                                                                  2-221*
current_table                   002104 automatic       fixed bin(17,0)          dcl 2-258 set ref 2-22* 2-25 2-28* 2-28 2-38* 2-38
                                                                                  2-46* 2-46 2-75 2-75 2-75 2-160 2-161 2-162 2-163
                                                                                  2-190 2-190 2-211* 2-211 2-214 2-214 2-214 2-221
cv                              002272 automatic       varying char(24)         dcl 3-104 set ref 3-475* 3-483 3-484 3-486* 3-486
                                                                                  3-499 3-521 3-523* 3-526 3-526* 3-526 3-529 3-529*
                                                                                  3-531 3-538 3-1319* 3-1322 3-1324 3-1366* 3-1369*
data                      3(09) 000306 automatic       char(100)                level 2 packed unaligned dcl 2-226 set ref 2-89*
                                                                                  2-118* 2-124* 2-169*
db_data                         000306 automatic       structure                level 1 packed unaligned dcl 2-226 set ref 2-23*
                                                                                  2-90 2-90 2-129 2-129 2-170 2-170
db_eval                  10     000042 external static bit(1)                   level 3 dcl 5-11 ref 2-14 2-85 2-111 2-142 2-166
                                                                                  2-175 2-180 2-194 3-444 3-1075 3-1084
db_look                                defined         picture(2)               unaligned dcl 2-225 set ref 2-117*
db_output                36     000042 external static pointer                  level 2 dcl 5-11 set ref 2-14* 2-90* 2-129* 2-170*
                                                                                  2-175* 2-182* 2-185* 2-188* 3-444* 3-1075* 3-1084*
db_sw                           000010 internal static bit(1)                   initial unaligned dcl 756 set ref 757* 758* 3-444
                                                                                  3-1075 3-1084
dbase                                  based           structure                level 1 unaligned dcl 6-31
dbase_p                         002200 automatic       pointer                  dcl 6-29 set ref 97* 98 102* 113 3-367 3-373 3-798
                                                                                  3-800 3-806 3-808 3-814 3-838* 3-1006 3-1015
                                                                                  3-1022
define_area_                    000012 constant        entry                    external dcl 91 ref 116
divide                                                 builtin function         dcl 722 ref 3-953
dname                   142            based           char(168)                level 3 packed unaligned dcl 7-67 set ref 3-758
                                                                                  3-761
dont_free                 1(03) 000236 automatic       bit(1)                   level 3 packed unaligned dcl 122 set ref 111*
ename                   214            based           char(32)                 level 3 packed unaligned dcl 7-67 set ref 3-767
                                                                                  3-770
err_go                  742(09)        based           char(16)                 level 2 packed unaligned dcl 6-31 set ref 3-373
err_msg                 410            based           varying char(168)        level 2 dcl 6-31 set ref 3-798 3-800 3-806 3-808
                                                                                  3-814
eval_p                    6            based           pointer                  level 2 dcl 6-31 ref 98
ex                       14            based           structure                level 2 unaligned dcl 7-67
ex_sw                           000106 automatic       bit(1)                   unaligned dcl 50 set ref 137* 2-173 2-202 2-204*
                                                                                  3-96*
extend                    1     000236 automatic       bit(1)                   level 3 packed unaligned dcl 122 set ref 108*
fb35                            002604 automatic       fixed bin(35,0)          dcl 3-1316 set ref 3-1317* 3-1319
fc                              002173 automatic       fixed bin(21,0)          dcl 728 set ref 256* 266
file_d                  140            based           structure                level 2 packed unaligned dcl 7-67
file_sw                 234(09)        based           bit(1)                   level 4 packed unaligned dcl 7-67 ref 3-789
fill                            002510 automatic       char(1)                  unaligned dcl 3-479 set ref 3-493* 3-506* 3-511*
                                                                                  3-551 3-552 3-552*
fixed                                                  builtin function         dcl 2-224 ref 257 272 3-521 3-525 3-1204 3-1225
                                                                                  3-1246 3-1268 3-1347
flag                            000306 automatic       char(1)                  level 2 packed unaligned dcl 2-226 set ref 2-51*
fvv                             000714 constant        fixed bin(17,0)          initial array dcl 418 ref 425
fxx                             000732 constant        char(3)                  initial array unaligned dcl 415 ref 423
hbound                                                 builtin function         dcl 722 ref 134 2-54 2-137
hex                                    based           bit(4)                   array unaligned dcl 694 set ref 665*
hexd                            002513 automatic       fixed bin(21,0)          dcl 3-481 set ref 3-515* 3-516 3-518 3-525* 3-526
                                                                                  3-526
hexdigits                       000450 constant        char(16)                 initial unaligned dcl 3-482 ref 3-526
hexv                            000240 constant        bit(4)                   initial array unaligned dcl 694 ref 665
hold_string                     000116 automatic       char(20)                 unaligned dcl 638 set ref 640* 651 655 676 680
i                                      parameter       fixed bin(21,0)          dcl 618 in procedure "ckk" ref 609 612 612 617
i                                      parameter       fixed bin(21,0)          dcl 604 in procedure "cka" ref 595 598 598 603
i                               000123 automatic       fixed bin(21,0)          dcl 694 in procedure "STRING_TYPE" set ref 654* 655*
                                                                                  679* 680*
i                               002105 automatic       fixed bin(21,0)          dcl 2-259 in procedure "tedeval_" set ref 2-75* 2-77
                                                                                  2-79* 2-99* 2-100 2-103 2-103 2-103 2-103* 2-214*
                                                                                  2-215 2-217* 262* 263 421* 423 425*
i                                      parameter       fixed bin(21,0)          dcl 632 in procedure "ckK" ref 623 626 626 631
i                               002572 automatic       fixed bin(21,0)          dcl 3-573 in begin block on line 3-570 set ref
                                                                                  3-629* 3-630 3-631* 3-631 3-632 3-633 3-634
i                               002267 automatic       fixed bin(21,0)          dcl 3-101 in procedure "ted_vtab_" set ref 3-188*
                                                                                  3-190 3-190* 3-190* 3-193* 3-195 3-195* 3-195
                                                                                  3-195 3-195* 3-198* 3-200 3-200* 3-200 3-200
                                                                                  3-200* 3-348* 3-349* 3-351 3-357* 3-358* 3-360
                                                                                  3-364* 3-370 3-381 3-381 3-387 3-389 3-437* 3-438
                                                                                  3-442 3-442 3-494* 3-495 3-538 3-551 3-556* 3-654*
                                                                                  3-655 3-663 3-664 3-671* 3-672* 3-683* 3-684*
                                                                                  3-747* 3-748 3-748* 3-752 3-758* 3-759 3-759*
                                                                                  3-767* 3-768 3-768* 3-776* 3-777 3-777* 3-785*
                                                                                  3-789 3-862* 3-864* 3-865* 3-869 3-1075* 3-1202*
                                                                                  3-1204* 3-1223* 3-1225* 3-1244* 3-1246* 3-1266*
                                                                                  3-1268*
ib                                     based           bit(9)                   array level 2 packed unaligned dcl 709 set ref 235
                                                                                  257 272
ic                                     based           char(1)                  array level 2 packed unaligned dcl 709 set ref 259
                                                                                  266 271 273 290 304 312 312 396 399 428 488 3-139
                                                                                  3-139 3-652 3-657 3-662 3-664 3-666
ids                                    parameter       fixed bin(17,0)          dcl 2-277 ref 2-275 2-282 2-282 2-287 2-287 2-296
idx                                    parameter       fixed bin(17,0)          dcl 2-277 ref 2-275 2-292 2-294 2-294 2-296 2-298
                                                                                  2-300 2-300
ifr                             002573 automatic       fixed bin(21,0)          dcl 3-573 set ref 3-581* 3-582 3-590* 3-596 3-596*
                                                                                  3-598 3-601 3-601* 3-601 3-603 3-603 3-611 3-613*
                                                                                  3-613 3-616* 3-616 3-617 3-620* 3-620 3-621 3-623
                                                                                  3-624 3-625* 3-629 3-637 3-637
ii                              000115 automatic       fixed bin(21,0)          dcl 60 in procedure "tedeval_" set ref 426* 428 430
ii                              002541 automatic       fixed bin(21,0)          dcl 3-1401 in procedure "ted_vtab_" set ref 3-186*
                                                                                  3-187* 3-672* 3-673 3-678 3-684* 3-685 3-685 3-685
                                                                                  3-687 3-1201* 3-1203* 3-1203 3-1207 3-1222*
                                                                                  3-1224* 3-1224 3-1228 3-1243* 3-1245* 3-1245
                                                                                  3-1250 3-1265* 3-1267* 3-1267 3-1272
ilc                                    parameter       fixed bin(21,0)          dcl 558 ref 556 577 579
iln                                    parameter       fixed bin(21,0)          dcl 558 ref 556 579
ind                             000110 automatic       fixed bin(21,0)          dcl 53 set ref 141* 2-72* 2-72 2-90* 2-129* 2-170*
                                                                                  2-206* 2-206
index                                                  builtin function         dcl 722 ref 271 273 283 475 488 3-515 3-654 3-672
                                                                                  3-684 3-747 3-758 3-767 3-776 3-1154 3-1166 3-1171
                                                                                  3-1338 3-1356 643 655 680
input                           002124 automatic       structure                array level 1 unaligned dcl 583
ioa_                            000026 constant        entry                    external dcl 2-272 ref 148 2-197 364 3-190 3-195
                                                                                  3-200 3-210 3-212 3-218
ioa_$ioa_switch                 000036 constant        entry                    external dcl 709 ref 3-444 3-1075 3-1084
ioa_$ioa_switch_nnl             000022 constant        entry                    external dcl 2-232 ref 2-14 2-90 2-129 2-170 2-175
                                                                                  2-182 2-185 2-188
ioa_$nnl                        000040 constant        entry                    external dcl 709 ref 3-837
iox_$put_chars                  000014 constant        entry                    external dcl 92 ref 3-139 3-140
iox_$user_output                000024 external static pointer                  dcl 2-233 set ref 3-139* 3-140*
ipt                                    parameter       pointer                  dcl 558 ref 556 576
is                                     based           char                     dcl 709 ref 145 2-103 262 263 283 286 475 3-149
                                                                                  3-181 3-245 3-253 3-292 3-302 3-474 3-475 3-637
                                                                                  3-654 3-654 3-672 3-684 3-685 3-847 3-848 3-871
                                                                                  3-871 3-873 3-873 3-902 3-904 3-1132 3-1132 3-1143
                                                                                  3-1143 3-1154 3-1154 3-1166 3-1166 3-1171 3-1171
                                                                                  3-1183 3-1183 3-1192 3-1192 3-1204 3-1225 3-1246
                                                                                  3-1268 3-1334 3-1353 643
iti                             000262 automatic       fixed bin(17,0)          dcl 2-3 set ref 2-94*
ito                             002574 automatic       fixed bin(21,0)          dcl 3-573 set ref 3-581* 3-582* 3-582 3-591* 3-594
                                                                                  3-594* 3-594 3-596 3-598* 3-598 3-608 3-614 3-616
                                                                                  3-617* 3-617 3-620 3-621* 3-621 3-627 3-628* 3-628
                                                                                  3-630 3-631 3-634* 3-634 3-637 3-637 3-639
j                               002270 automatic       fixed bin(21,0)          dcl 3-102 in procedure "ted_vtab_" set ref 3-436*
                                                                                  3-438 3-441 3-441 3-442 3-483* 3-486 3-487* 3-487
                                                                                  3-499* 3-521* 3-525 3-531* 3-537 3-538 3-539*
                                                                                  3-539 3-550 3-1204* 3-1205 3-1225* 3-1226 3-1246*
                                                                                  3-1247 3-1268* 3-1269
j                               000102 automatic       fixed bin(21,0)          dcl 508 in procedure "scanner" set ref 279* 282 283
                                                                                  284* 294*
j                               000124 automatic       fixed bin(21,0)          dcl 694 in procedure "STRING_TYPE" set ref 655* 656
                                                                                  663 663* 663 665 680* 681 688
jaf                             002117 automatic       fixed bin(21,0)          dcl 2-271 set ref 2-213* 2-215
jb                                     based           bit(36)                  unaligned dcl 3-522 ref 3-525
k                      1020            based           varying char(32)         array level 2 in structure "val" dcl 62 in procedure
                                                                                  "tedeval_" set ref 3-195 3-195 3-195 3-195* 3-245*
                                                                                  3-349 3-351
k                               000101 automatic       fixed bin(21,0)          dcl 508 in procedure "scanner" set ref 269* 276 283*
                                                                                  284 286 286 287 288 425* 431 453* 460* 461* 488*
                                                                                  489 491 491* 491 494 496 502*
kind                    234            based           char(1)                  level 3 packed unaligned dcl 7-67 set ref 3-786
klb                             016443 constant        fixed bin(17,0)          initial dcl 83 ref 3-193 612
kub                                    constant        fixed bin(17,0)          initial dcl 83 ref 3-193 612
l                         6            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        52            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                                      based           structure                array level 2 in structure "buf_des" unaligned
                                                                                  dcl 7-11 in procedure "tedeval_"
l                               002174 automatic       fixed bin(21,0)          dcl 729 in procedure "tedeval_" set ref 134* 135*
l                         4            based           structure                level 3 in structure "sv" unaligned dcl 8-4
                                                                                  in procedure "tedeval_"
l                        74            based           structure                array level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        22            based           structure                array level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        66            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        12            based           structure                level 3 in structure "sv" unaligned dcl 8-4
                                                                                  in procedure "tedeval_"
l                                      internal static structure                level 2 in structure "tedcommon_$no_data" unaligned
                                                                                  dcl 5-8 in procedure "tedeval_"
l                        16            based           structure                level 4 in structure "dbase" unaligned dcl 6-31
                                                                                  in procedure "tedeval_"
l                        44            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                                      based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        14            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l                        60            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
l_del                           002120 automatic       fixed bin(17,0)          dcl 2-273 set ref 2-161* 2-178* 2-178 2-182* 2-193
la_ct                           002106 automatic       fixed bin(17,0)          dcl 2-260 set ref 2-8* 2-60 2-64* 2-64 2-144* 2-144
la_get                          002107 automatic       fixed bin(17,0)          dcl 2-261 set ref 2-7* 2-30 2-44 2-53 2-89* 2-124*
                                                                                  2-141 2-143* 2-143
la_need                         002110 automatic       fixed bin(17,0)          dcl 2-262 set ref 2-30 2-32 2-35* 2-35 2-43* 2-52*
                                                                                  2-60 2-117 2-156*
la_put                          002111 automatic       fixed bin(17,0)          dcl 2-263 set ref 2-7* 2-62 2-63* 2-63 235 237 238
                                                                                  239 240 241 275 276 287 356 373 380 474 475 496
                                                                                  668 691
la_use                          002112 automatic       fixed bin(22,0)          dcl 2-264 set ref 2-30* 2-44* 2-53* 2-66
lastk_ovflo                     000264 stack reference condition                dcl 2-34 ref 2-32
lbound                                                 builtin function         dcl 722 ref 134 2-30 2-32 2-63 2-143
le                       23            based           fixed bin(21,0)          array level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-413* 3-1032* 3-1295*
le                        1            based           fixed bin(21,0)          level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-422 3-423 3-444* 3-1084*
                                                                                  3-1299*
le                        4            based           fixed bin(21,0)          level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-423 3-426 3-432 3-437 3-442
                                                                                  3-444* 3-1082 3-1084*
le                       26            based           fixed bin(21,0)          array level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-405 3-1052*
len                       2            based           fixed bin(21,0)          level 2 dcl 56 set ref 364 364 370 370 370* 3-83*
                                                                                  3-86 3-121 3-218 3-218 3-218 3-218 3-272 3-282*
                                                                                  3-286 3-288 3-289* 3-292 3-441 3-442 3-466 3-563
                                                                                  3-623 3-632 3-637 3-685 3-738 3-740 3-847 3-848
                                                                                  3-900* 3-902 3-904 3-907 3-907 3-908 3-1324
leng                            002575 automatic       fixed bin(21,0)          dcl 3-1287 set ref 3-1294* 3-1295* 3-1297* 3-1299*
length                                                 builtin function         dcl 722 ref 353 356 426 3-186 3-195 3-195 3-200
                                                                                  3-200 3-218 3-218 3-307 3-307 3-351 3-360 3-464
                                                                                  3-476 3-483 3-494 3-531 3-561 3-800 3-808 3-1322
                                                                                  651 654 676 679
level                           002122 automatic       fixed bin(21,0)          dcl 582 set ref 138* 2-96 2-97 2-99 244 249* 249 250
                                                                                  251 252 253 562 568 570 571 572 573 575* 575 576
                                                                                  577 577 579
lgnc                            002175 automatic       fixed bin(21,0)          dcl 730 set ref 2-97 251* 571 577* 3-142* 3-153*
                                                                                  3-161* 3-168* 3-175* 3-183*
link                                   based           pointer                  level 2 dcl 56 set ref 3-84* 3-120
ln                        1(18) 000030 external static fixed bin(17,0)          array level 3 packed unaligned dcl 4-4 ref 2-294
                                                                                  2-300
lnl                             002176 automatic       fixed bin(21,0)          dcl 731 set ref 139*
loc                      13            based           fixed bin(21,0)          level 2 in structure "sr" dcl 47 in procedure
                                                                                  "tedeval_" set ref 3-87* 3-350* 3-359* 3-374*
                                                                                  3-388* 3-399* 3-404* 3-413* 3-422* 3-423* 3-428
                                                                                  3-432 3-435 3-436 3-444* 3-448 3-456* 3-697*
                                                                                  3-714* 3-720* 3-751* 3-787* 3-799* 3-807* 3-815*
loc                      13     000344 automatic       fixed bin(21,0)          array level 2 in structure "ls" dcl 2-234
                                                                                  in procedure "tedeval_" set ref 2-197* 241* 3-139
                                                                                  3-139 3-149 3-245 3-253 3-292 3-474 3-475 3-697
                                                                                  3-714 3-720 3-739* 3-856* 3-1334 3-1353
loc                      13            based           fixed bin(21,0)          level 2 in structure "sx" dcl 3-844 in procedure
                                                                                  "ted_vtab_" set ref 3-847
loc                      13            based           fixed bin(21,0)          level 2 in structure "s1" dcl 45 in procedure
                                                                                  "tedeval_" ref 3-181 3-637 3-654 3-657 3-662 3-871
                                                                                  3-873 3-902 3-1132 3-1143 3-1154 3-1166 3-1171
                                                                                  3-1183 3-1192 3-1202 3-1202 3-1223 3-1223 3-1244
                                                                                  3-1244 3-1266 3-1266
loc                      13            based           fixed bin(21,0)          level 2 in structure "s2" dcl 46 in procedure
                                                                                  "tedeval_" ref 3-652 3-654 3-848 3-871 3-873 3-904
                                                                                  3-1132 3-1143 3-1154 3-1166 3-1171 3-1183 3-1192
loc0                      2     002124 automatic       fixed bin(21,0)          array level 2 dcl 583 set ref 2-97* 2-103 2-103 251
                                                                                  571* 577*
loc1                      3     002124 automatic       fixed bin(21,0)          array level 2 dcl 583 set ref 2-94 2-96* 2-103 252
                                                                                  564 572* 577*
loc2                      4     002124 automatic       fixed bin(21,0)          array level 2 dcl 583 set ref 253 573* 579*
ls                              000344 automatic       structure                array level 1 unaligned dcl 2-234 set ref 134 134
                                                                                  2-30 2-32 2-63 2-137 2-141* 2-141 2-143 3-179
                                                                                  3-238* 3-238 3-246* 3-246 3-254* 3-254 3-276*
                                                                                  3-276 3-293* 3-293 3-346 3-355 3-366 3-395 3-411
                                                                                  3-420 3-454 3-462 3-473 3-476 3-579 3-580 3-588
                                                                                  3-589 3-650 3-651 3-669 3-680 3-692 3-707 3-745
                                                                                  3-756 3-765 3-774 3-783 3-796 3-804 3-812 3-824
                                                                                  3-825 3-832 3-833 3-840 3-867 3-868 3-897 3-898
                                                                                  3-971* 3-971 3-977* 3-977 3-984* 3-984 3-997*
                                                                                  3-997 3-1100* 3-1100 3-1130 3-1131 3-1141 3-1142
                                                                                  3-1152 3-1153 3-1164 3-1165 3-1181 3-1182 3-1190
                                                                                  3-1191 3-1199 3-1200 3-1220 3-1221 3-1241 3-1242
                                                                                  3-1263 3-1264 3-1320
lsbe                            002540 automatic       char(4)                  unaligned dcl 3-1028 set ref 3-393* 3-409* 3-418*
                                                                                  3-444* 3-1030* 3-1038* 3-1048* 3-1058* 3-1066*
                                                                                  3-1075* 3-1084*
lst                             001570 automatic       fixed bin(21,0)          dcl 2-251 set ref 2-6* 2-59 2-137 2-140* 2-140 2-141
                                                                                  2-193* 2-193 2-197* 2-197 2-197 2-197 2-197 2-197
                                                                                  2-197 2-197 2-197 3-138 3-139 3-139 3-139 3-139
                                                                                  3-139 3-147* 3-149 3-149 3-149 3-179 3-234 3-236*
                                                                                  3-237 3-237 3-238 3-238 3-242 3-244* 3-245 3-245
                                                                                  3-245 3-245 3-246 3-246 3-250 3-252* 3-253 3-253
                                                                                  3-253 3-253 3-254 3-254 3-258* 3-260 3-263 3-265
                                                                                  3-266 3-266 3-275 3-276 3-276 3-279 3-292 3-292
                                                                                  3-293 3-293 3-299 3-302 3-302 3-303 3-320 3-329
                                                                                  3-338 3-339 3-346 3-348 3-355 3-357 3-364 3-366
                                                                                  3-395 3-411 3-420 3-454 3-462 3-470 3-472 3-473
                                                                                  3-474 3-474 3-474 3-475 3-475 3-475 3-476 3-575
                                                                                  3-578 3-579 3-580 3-581 3-586 3-587 3-588 3-589
                                                                                  3-590 3-591 3-646 3-648 3-649 3-650 3-651 3-669
                                                                                  3-680 3-692 3-694 3-695 3-696 3-697 3-698 3-699
                                                                                  3-707 3-709 3-710 3-712 3-713 3-714 3-715 3-718
                                                                                  3-719 3-720 3-721 3-726 3-733 3-734 3-738 3-739
                                                                                  3-740 3-745 3-756 3-765 3-774 3-783 3-796 3-804
                                                                                  3-812 3-821* 3-823 3-824 3-825 3-829* 3-831 3-832
                                                                                  3-833 3-840 3-854 3-856 3-856 3-856 3-856 3-862
                                                                                  3-862 3-864* 3-865 3-866 3-867 3-868 3-884 3-884
                                                                                  3-886 3-887 3-894* 3-895 3-896 3-897 3-898 3-909
                                                                                  3-909 3-911 3-912 3-918 3-922* 3-924 3-925 3-926
                                                                                  3-926 3-926 3-930* 3-932 3-933 3-934 3-934 3-934
                                                                                  3-941* 3-943 3-944 3-945 3-945 3-945 3-949* 3-951
                                                                                  3-952 3-953 3-953 3-953 3-957* 3-959 3-960 3-961
                                                                                  3-961 3-961 3-969* 3-971 3-971 3-975* 3-977 3-977
                                                                                  3-978 3-978 3-984 3-984 3-989 3-989 3-991 3-995
                                                                                  3-997 3-997 3-1001 3-1008 3-1010 3-1011 3-1015
                                                                                  3-1017 3-1022 3-1024 3-1032 3-1034 3-1040 3-1042
                                                                                  3-1044 3-1050 3-1052 3-1054 3-1060 3-1062 3-1070
                                                                                  3-1071 3-1079 3-1080 3-1082 3-1082 3-1084 3-1090
                                                                                  3-1095 3-1100 3-1100 3-1110* 3-1112 3-1113 3-1113
                                                                                  3-1113 3-1113 3-1115 3-1115 3-1115 3-1116 3-1120
                                                                                  3-1122 3-1122 3-1123 3-1127 3-1129 3-1130 3-1131
                                                                                  3-1132 3-1135 3-1138 3-1140 3-1141 3-1142 3-1143
                                                                                  3-1145 3-1149 3-1151 3-1152 3-1153 3-1154 3-1157
                                                                                  3-1161 3-1163 3-1164 3-1165 3-1166 3-1171 3-1174
                                                                                  3-1178 3-1180 3-1181 3-1182 3-1183 3-1184 3-1187
                                                                                  3-1189 3-1190 3-1191 3-1192 3-1194 3-1197 3-1199
                                                                                  3-1200 3-1207 3-1208 3-1212 3-1213 3-1218 3-1220
                                                                                  3-1221 3-1228 3-1229 3-1233 3-1234 3-1239 3-1241
                                                                                  3-1242 3-1250 3-1251 3-1255 3-1256 3-1261 3-1263
                                                                                  3-1264 3-1272 3-1273 3-1277 3-1278 3-1299 3-1301
lstk_ovflo                      000300 stack reference condition                dcl 2-139 ref 2-137
ltrim                                                  builtin function         dcl 722 ref 3-1319
lval_ptr                        000116 automatic       pointer                  dcl 61 set ref 99* 100 103* 104 105 106 115 357 358
                                                                                  363 377 3-83 3-84 3-85 3-118 3-119 3-120 3-190
                                                                                  3-190 3-195 3-195 3-195 3-195 3-200 3-200 3-200
                                                                                  3-200 3-205 3-206 3-217 3-221 3-237 3-245 3-253
                                                                                  3-271 3-272 3-282 3-285 3-288 3-289 3-322 3-323
                                                                                  3-332 3-333 3-340 3-341 3-349 3-351 3-358 3-360
                                                                                  3-737 3-900 3-989
mask                     10            based           bit(36)                  level 2 in structure "s2" packed unaligned dcl 46
                                                                                  in procedure "tedeval_" ref 3-1205 3-1226 3-1247
                                                                                  3-1269
mask                     10     000344 automatic       bit(36)                  array level 2 in structure "ls" packed unaligned
                                                                                  dcl 2-234 in procedure "tedeval_" set ref 474*
                                                                                  496* 3-884 3-909 3-918*
max                                                    builtin function         dcl 722 ref 3-601 3-617 3-808 3-862 3-1115
maxl                    253            based           fixed bin(21,0)          level 2 dcl 7-67 ref 3-441 3-442
mc                              002271 automatic       char(1)                  unaligned dcl 3-103 set ref 3-495* 3-496 3-503 3-503
                                                                                  3-506 3-507* 3-509 3-512* 3-515 3-532* 3-535 3-535
                                                                                  3-541 3-544* 3-548 3-548 3-556
min                                                    builtin function         dcl 722 ref 2-287 3-616 3-620 3-621 3-637 3-1113
mod                                                    builtin function         dcl 2-224 ref 2-30 2-63 2-143 3-961
msg                                    parameter       varying char(168)        dcl 27 set ref 25 119* 2-93* 2-98* 2-98 2-100* 2-100
                                                                                  2-103* 2-103 2-106* 2-106 2-148* 2-152* 299* 565*
                                                                                  3-224* 3-311* 3-317* 3-384* 3-605* 3-675* 3-730*
                                                                                  3-1341* 3-1342* 3-1342 3-1343* 3-1343 3-1384*
                                                                                  3-1388* 3-1390* 3-1391* 3-1391 600* 614* 628* 658*
                                                                                  659* 659 660* 660 683* 684* 684 685* 685
name                      1            based           char(16)                 level 2 in structure "avar" packed unaligned dcl 76
                                                                                  in procedure "tedeval_" set ref 364* 366 3-210*
                                                                                  3-212* 3-218* 3-327 3-335*
name                    235            based           char(16)                 level 2 in structure "b" packed unaligned dcl 7-67
                                                                                  in procedure "tedeval_" set ref 3-747 3-750
nc                              002177 automatic       fixed bin(21,0)          dcl 732 set ref 2-19 2-96 235 242 252* 256 257 258*
                                                                                  258 259 259 262 263 269 271 272* 272 272* 273* 276
                                                                                  279 283 286 288* 288 289 290 293* 293 294 304* 304
                                                                                  304* 312 312 320* 320 324* 324 333* 333 346* 346
                                                                                  350* 350 353* 353 384* 384 388* 388 389* 389 390*
                                                                                  390 391* 391 394* 394 396* 396 396* 399 399 401*
                                                                                  401 407* 407 408* 408 412* 412 426 430* 437* 437
                                                                                  438* 438 442* 442 443* 443 444* 444 445* 445 449*
                                                                                  449 450* 450 451* 451 452* 452 457* 457 458* 458
                                                                                  469* 469 475 475 476* 476 488 493* 493 572 577*
                                                                                  3-142 3-153 3-161 3-168 3-175 3-183 642 643 645*
                                                                                  645 670* 670
next                                   based           bit(18)                  level 2 dcl 76 set ref 376 3-209 3-326 3-340*
next_avar                       002304 automatic       bit(18)                  unaligned dcl 3-321 set ref 3-205* 3-206 3-206
                                                                                  3-209* 3-221 3-322* 3-323 3-323 3-326* 3-332
next_state                      002113 automatic       fixed bin(17,0)          dcl 2-265 set ref 2-71* 2-79* 2-114 2-132
nextab                          000120 automatic       bit(18)                  unaligned dcl 71 set ref 357* 358 358 376* 377
nibble                          002515 automatic       fixed bin(21,0)          dcl 3-481 set ref 3-518* 3-520* 3-524 3-525
no_freeing                1(04) 000236 automatic       bit(1)                   level 3 packed unaligned dcl 122 set ref 112*
ns_num                          000233 automatic       fixed bin(17,0)          dcl 83 set ref 271* 273* 273 275 649* 651* 665 668
                                                                                  674* 676* 688 691
ns_string                       000132 automatic       varying char(256)        dcl 83 set ref 281* 286* 286 292* 292 3-158* 3-165*
                                                                                  3-172* 3-181* 3-186 3-187 3-302* 3-307 3-307 3-314
                                                                                  3-314 3-327 3-335 3-464 3-466 3-474* 3-476 3-494
                                                                                  3-495 3-538* 3-551* 3-556* 3-559 3-559* 3-561
                                                                                  3-563 3-1334* 3-1336 3-1338 3-1338 3-1342 3-1347
                                                                                  3-1351* 3-1353* 3-1353 3-1355* 3-1355 3-1356 640
                                                                                  651 654 659 676 679 684
null                                                   builtin function         dcl 722 ref 100 105 135 361 380 3-118 3-299 3-368
                                                                                  3-396 3-728 3-1008 3-1040 3-1050 3-1073 3-1384
num                      12            based           fixed bin(21,0)          level 2 in structure "sr" dcl 47 in procedure
                                                                                  "tedeval_" set ref 3-88* 3-351* 3-360* 3-375*
                                                                                  3-389* 3-400* 3-405* 3-414* 3-425* 3-426* 3-430
                                                                                  3-432 3-437 3-444* 3-448* 3-448 3-457* 3-610*
                                                                                  3-624* 3-632 3-633* 3-633 3-637 3-639* 3-639
                                                                                  3-682* 3-685 3-687* 3-687 3-698* 3-702* 3-715*
                                                                                  3-721* 3-752* 3-789* 3-791* 3-800* 3-808* 3-816*
num                      12     000344 automatic       fixed bin(21,0)          array level 2 in structure "ls" dcl 2-234
                                                                                  in procedure "tedeval_" set ref 2-197* 240* 275*
                                                                                  3-139* 3-149 3-237* 3-237 3-245* 3-245 3-253*
                                                                                  3-253 3-275 3-279 3-348 3-357 3-364 3-474 3-475
                                                                                  3-581 3-590 3-591 3-698 3-699 3-710 3-715 3-721
                                                                                  3-734* 3-740* 3-856 3-856* 3-884* 3-886* 3-909*
                                                                                  3-911* 3-926* 3-926 3-926 3-934* 3-934 3-934
                                                                                  3-945* 3-945 3-945 3-953* 3-953 3-953 3-961* 3-961
                                                                                  3-961 3-978* 3-978 3-989* 3-989* 3-1008* 3-1010*
                                                                                  3-1015* 3-1022* 3-1032* 3-1034* 3-1040* 3-1042*
                                                                                  3-1044* 3-1050* 3-1052* 3-1054* 3-1060* 3-1062*
                                                                                  3-1070* 3-1079 3-1080 3-1082* 3-1082 3-1084*
                                                                                  3-1090* 3-1095* 3-1113 3-1113* 3-1113 3-1113
                                                                                  3-1115* 3-1115 3-1115 3-1122* 3-1122 3-1132*
                                                                                  3-1143* 3-1154* 3-1166* 3-1171* 3-1183* 3-1192*
                                                                                  3-1207* 3-1212* 3-1228* 3-1233* 3-1250* 3-1255*
                                                                                  3-1272* 3-1277* 3-1299* 3-1317 3-1328 3-1328*
                                                                                  3-1334 3-1347* 3-1353 3-1356* 3-1358* 3-1366 668*
                                                                                  691*
num                      12            based           fixed bin(21,0)          level 2 in structure "s1" dcl 45 in procedure
                                                                                  "tedeval_" ref 3-181 3-582 3-594 3-601 3-603 3-629
                                                                                  3-637 3-654 3-658 3-667 3-847 3-871 3-873 3-878
                                                                                  3-880 3-899 3-902 3-902 3-903 3-1132 3-1143 3-1154
                                                                                  3-1166 3-1171 3-1183 3-1192 3-1202 3-1223 3-1244
                                                                                  3-1266
num                      12            based           fixed bin(21,0)          level 2 in structure "s2" dcl 46 in procedure
                                                                                  "tedeval_" ref 3-653 3-654 3-665 3-666 3-671 3-683
                                                                                  3-843 3-848 3-848 3-871 3-873 3-878 3-880 3-899
                                                                                  3-904 3-904 3-905 3-1132 3-1143 3-1154 3-1166
                                                                                  3-1166 3-1171 3-1183 3-1192
num                       6            based           fixed bin(35,0)          level 2 in structure "avar" dcl 76 in procedure
                                                                                  "tedeval_" set ref 3-210* 3-212 3-275* 3-734
num                      12            based           fixed bin(21,0)          level 2 in structure "sx" dcl 3-844 in procedure
                                                                                  "ted_vtab_" set ref 3-843 3-847 3-848
oct                                    based           bit(3)                   array unaligned dcl 694 set ref 688*
octv                            000237 constant        bit(3)                   initial array unaligned dcl 694 ref 688
old                     116            based           structure                level 2 unaligned dcl 7-67
owner                     2     000236 automatic       char(32)                 level 2 packed unaligned dcl 122 set ref 113*
p_del                           002121 automatic       fixed bin(17,0)          dcl 2-273 set ref 2-160* 2-177* 2-177 2-182* 2-184
                                                                                  2-192
parse_stack                     001735 automatic       fixed bin(17,0)          array dcl 2-254 set ref 2-54 2-58* 2-70* 2-185*
                                                                                  2-190* 2-205 2-213
pl                       26            based           fixed bin(21,0)          array level 3 dcl 8-4 ref 3-389
pn                       23            based           fixed bin(21,0)          level 2 dcl 8-4 ref 3-379 3-381 3-1010
pointer                                                builtin function         dcl 722 ref 358 363 377 3-206 3-217 3-221 3-271
                                                                                  3-285 3-323 3-332 3-737
pp                       24            based           pointer                  array level 3 dcl 8-4 ref 3-387
present                 252            based           bit(1)                   array level 2 packed unaligned dcl 7-67 ref 3-1386
ps_top                          002114 automatic       fixed bin(17,0)          dcl 2-267 set ref 2-6* 2-54 2-57* 2-57 2-58 2-59
                                                                                  2-69* 2-69 2-70 2-184 2-184 2-190 2-192* 2-192
                                                                                  2-205 2-213
pstk_ovflo                      000272 stack reference condition                dcl 2-56 ref 2-54
pt                        6            based           pointer                  level 2 in structure "sr" dcl 47 in procedure
                                                                                  "tedeval_" set ref 3-86* 3-349* 3-358* 3-373*
                                                                                  3-387* 3-398* 3-403* 3-412* 3-421* 3-455* 3-695*
                                                                                  3-712* 3-718* 3-750* 3-761* 3-770* 3-779* 3-786*
                                                                                  3-798* 3-806* 3-814*
pt                        1     000030 external static fixed bin(17,0)          array level 3 in structure "ted_eval_t_$TL" packed
                                                                                  unaligned dcl 4-4 in procedure "tedeval_" ref
                                                                                  2-294 2-300
pt                        6            based           pointer                  level 2 in structure "sx" dcl 3-844 in procedure
                                                                                  "ted_vtab_" set ref 3-847
pt                              002124 automatic       pointer                  array level 2 in structure "input" dcl 583
                                                                                  in procedure "tedeval_" set ref 2-103 250 570*
                                                                                  576*
pt                        6     000344 automatic       pointer                  array level 2 in structure "ls" dcl 2-234
                                                                                  in procedure "tedeval_" set ref 135* 2-197* 373*
                                                                                  380* 3-139 3-139 3-149 3-245 3-253 3-263 3-292
                                                                                  3-299 3-329* 3-339* 3-474 3-475 3-695 3-712 3-718
                                                                                  3-726 3-738* 3-856* 3-1334 3-1353
pt                        6            based           pointer                  level 2 in structure "s2" dcl 46 in procedure
                                                                                  "tedeval_" ref 3-652 3-654 3-672 3-684 3-848 3-871
                                                                                  3-873 3-904 3-1132 3-1143 3-1154 3-1166 3-1171
                                                                                  3-1183 3-1192
pt                        6            based           pointer                  level 2 in structure "s1" dcl 45 in procedure
                                                                                  "tedeval_" ref 3-181 3-637 3-654 3-657 3-662 3-871
                                                                                  3-873 3-902 3-1132 3-1143 3-1154 3-1166 3-1171
                                                                                  3-1183 3-1192 3-1204 3-1225 3-1246 3-1268
pv                       24            based           structure                array level 2 unaligned dcl 8-4
r                         3            based           structure                level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
r                        25            based           structure                array level 3 in structure "b" unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
re                        2            based           fixed bin(21,0)          level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-423 3-426 3-432 3-436 3-444*
                                                                                  3-1080 3-1082 3-1084*
re                        5            based           fixed bin(21,0)          level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-425 3-426 3-444* 3-1070
                                                                                  3-1084* 3-1294
re                       27            based           fixed bin(21,0)          array level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-414 3-1060* 3-1297*
re                       24            based           fixed bin(21,0)          array level 4 in structure "b" dcl 7-67 in procedure
                                                                                  "tedeval_" set ref 3-404* 3-1042*
rel                                                    builtin function         dcl 722 ref 3-283 3-290 3-341
relmask                         000442 constant        bit(36)                  initial array unaligned dcl 3-916 ref 3-918
result                                 parameter       varying char(500)        dcl 27 set ref 25 142* 3-149*
ret_val                         000100 automatic       fixed bin(17,0)          dcl 156 set ref 257* 264 314 320* 325* 341* 341 343
                                                                                  346* 350*
reverse                                                builtin function         dcl 722 ref 3-1143 3-1166 3-1171 3-1171 3-1192
rn                              000125 automatic       fixed bin(21,0)          dcl 694 set ref 648* 665 666* 666 673* 688 689* 689
rule_number                            parameter       fixed bin(21,0)          dcl 3-1398 ref 3-78 3-79 3-140
rulen                           002115 automatic       fixed bin(21,0)          dcl 2-269 set ref 2-162* 2-164 2-164* 2-170*
s1                                     based           structure                level 1 unaligned dcl 45 ref 3-842
s1_ptr                          000100 automatic       pointer                  dcl 48 set ref 3-179* 3-181 3-181 3-181 3-579* 3-582
                                                                                  3-588* 3-594 3-601 3-603 3-629 3-637 3-637 3-637
                                                                                  3-650* 3-654 3-654 3-654 3-657 3-657 3-658 3-662
                                                                                  3-662 3-667 3-824* 3-832* 3-842 3-847 3-867* 3-871
                                                                                  3-871 3-871 3-873 3-873 3-873 3-878 3-880 3-897*
                                                                                  3-899 3-902 3-902 3-902 3-902 3-903 3-1130* 3-1132
                                                                                  3-1132 3-1132 3-1141* 3-1143 3-1143 3-1143 3-1152*
                                                                                  3-1154 3-1154 3-1154 3-1164* 3-1166 3-1166 3-1166
                                                                                  3-1171 3-1171 3-1171 3-1181* 3-1183 3-1183 3-1183
                                                                                  3-1190* 3-1192 3-1192 3-1192 3-1199* 3-1202 3-1202
                                                                                  3-1202 3-1204 3-1220* 3-1223 3-1223 3-1223 3-1225
                                                                                  3-1241* 3-1244 3-1244 3-1244 3-1246 3-1263* 3-1266
                                                                                  3-1266 3-1266 3-1268
s2                                     based           structure                level 1 unaligned dcl 46
s2_ptr                          000102 automatic       pointer                  dcl 48 set ref 3-651* 3-652 3-652 3-653 3-654 3-654
                                                                                  3-654 3-665 3-666 3-669* 3-671 3-672 3-683 3-684
                                                                                  3-825* 3-833* 3-843 3-848 3-848 3-848 3-848 3-868*
                                                                                  3-871 3-871 3-871 3-873 3-873 3-873 3-878 3-880
                                                                                  3-898* 3-899 3-904 3-904 3-904 3-904 3-905 3-1131*
                                                                                  3-1132 3-1132 3-1132 3-1142* 3-1143 3-1143 3-1143
                                                                                  3-1153* 3-1154 3-1154 3-1154 3-1165* 3-1166 3-1166
                                                                                  3-1166 3-1166 3-1171 3-1171 3-1171 3-1182* 3-1183
                                                                                  3-1183 3-1183 3-1191* 3-1192 3-1192 3-1192 3-1200*
                                                                                  3-1205 3-1221* 3-1226 3-1242* 3-1247 3-1264*
                                                                                  3-1269
search                                                 builtin function         dcl 722 ref 3-1132 3-1143
seg_des                                based           structure                level 1 unaligned dcl 6-20
set                             000242 constant        bit(9)                   initial array unaligned dcl 3-1403 ref 3-1205 3-1226
                                                                                  3-1247 3-1269
sign                            002507 automatic       char(1)                  unaligned dcl 3-479 set ref 3-485* 3-489* 3-511
                                                                                  3-559
size                     13     000236 automatic       fixed bin(18,0)          level 2 dcl 122 set ref 114*
sn                      126            based           fixed bin(17,0)          level 3 dcl 7-67 set ref 102* 3-1032 3-1042 3-1052
                                                                                  3-1060
sp                      124            based           pointer                  level 3 dcl 7-67 set ref 99 102* 103 3-403 3-412
                                                                                  3-421 3-441 3-442
sr                                     based           structure                level 1 unaligned dcl 47 set ref 3-476*
sr_ptr                          000104 automatic       pointer                  dcl 48 set ref 3-86 3-87 3-88 3-89 3-346* 3-349
                                                                                  3-350 3-351 3-355* 3-358 3-359 3-360 3-366* 3-373
                                                                                  3-374 3-375 3-387 3-388 3-389 3-395* 3-398 3-399
                                                                                  3-400 3-403 3-404 3-405 3-411* 3-412 3-413 3-414
                                                                                  3-420* 3-421 3-422 3-423 3-425 3-426 3-428 3-430
                                                                                  3-432 3-432 3-435 3-436 3-437 3-444 3-444 3-448
                                                                                  3-448 3-448 3-454* 3-455 3-456 3-457 3-462* 3-473*
                                                                                  3-476 3-580* 3-589* 3-610 3-624 3-632 3-633 3-633
                                                                                  3-637 3-639 3-639 3-680* 3-682 3-685 3-687 3-687
                                                                                  3-692* 3-695 3-696 3-697 3-698 3-701 3-702 3-707*
                                                                                  3-712 3-713 3-714 3-715 3-718 3-719 3-720 3-721
                                                                                  3-745* 3-750 3-751 3-752 3-756* 3-761 3-765* 3-770
                                                                                  3-774* 3-779 3-783* 3-786 3-787 3-789 3-791 3-796*
                                                                                  3-798 3-799 3-800 3-804* 3-806 3-807 3-808 3-812*
                                                                                  3-814 3-815 3-816 3-824* 3-832* 3-849 3-1320*
state                     0(09) 000306 automatic       picture(4)               level 2 packed unaligned dcl 2-226 set ref 2-24*
stk_info                754            based           structure                level 2 unaligned dcl 6-31
str                                    parameter       char(3)                  unaligned dcl 3-1382 ref 3-1375 3-1379 3-1391
string                                                 builtin function         dcl 722 set ref 2-23* 2-90 2-90 2-129 2-129 2-170
                                                                                  2-170
substr                                                 builtin function         dcl 722 set ref 145 2-103 2-287 2-294 2-300 262 263
                                                                                  283 286 475 496* 3-149 3-181 3-187 3-245 3-253
                                                                                  3-292 3-302 3-314 3-441* 3-441 3-442* 3-442 3-474
                                                                                  3-475 3-484 3-486 3-495 3-525 3-526 3-538* 3-538
                                                                                  3-551* 3-556* 3-559 3-559* 3-623* 3-632* 3-637*
                                                                                  3-637 3-654 3-654 3-672 3-684 3-685* 3-685 3-847*
                                                                                  3-847 3-848* 3-848 3-871 3-871 3-873 3-873 3-902*
                                                                                  3-902 3-904* 3-904 3-1132 3-1132 3-1143 3-1143
                                                                                  3-1154 3-1154 3-1166 3-1166 3-1171 3-1171 3-1183
                                                                                  3-1183 3-1192 3-1192 3-1204 3-1225 3-1246 3-1268
                                                                                  3-1334 3-1338 3-1338 3-1353 643 651 655 676 680
sv                                     based           structure                level 1 unaligned dcl 8-4
sv_p                            002204 automatic       pointer                  dcl 8-3 set ref 3-367* 3-368 3-379 3-381 3-387 3-389
                                                                                  3-1006* 3-1008 3-1010
sws                     234(09)        based           structure                level 3 in structure "b" packed unaligned dcl 7-67
                                                                                  in procedure "tedeval_"
sws                       4     000042 external static structure                level 2 in structure "tedcommon_$etc" unaligned
                                                                                  dcl 5-11 in procedure "tedeval_"
sx                                     based           structure                level 1 unaligned dcl 3-844 set ref 3-842*
sx_ptr                          002532 automatic       pointer                  dcl 3-845 set ref 3-840* 3-842 3-843 3-847 3-847
                                                                                  3-847 3-848
symbol                    4     000344 automatic       fixed bin(21,0)          array level 2 dcl 2-234 set ref 2-62* 2-66 2-197*
                                                                                  238*
symlen                    2     000344 automatic       fixed bin(21,0)          array level 2 dcl 2-234 set ref 2-197* 2-282 2-287
                                                                                  237* 276* 287* 356* 475* 3-302
symptr                          000344 automatic       pointer                  array level 2 dcl 2-234 set ref 2-197* 2-287 235*
                                                                                  3-302
sys_info$max_seg_size           000020 external static fixed bin(17,0)          dcl 124 ref 114
t                               002116 automatic       fixed bin(21,0)          dcl 2-270 set ref 2-184* 2-185*
te                              002172 automatic       fixed bin(24,0)          dcl 709 set ref 145 2-103 242 253* 259 262 263 272
                                                                                  279 283 286 289 294 304 396 399 475 475 573 579*
                                                                                  3-149 3-181 3-245 3-253 3-292 3-302 3-474 3-475
                                                                                  3-637 3-654 3-654 3-672 3-684 3-685 3-847 3-848
                                                                                  3-871 3-871 3-873 3-873 3-902 3-904 3-1132 3-1132
                                                                                  3-1143 3-1143 3-1154 3-1154 3-1166 3-1166 3-1171
                                                                                  3-1171 3-1183 3-1183 3-1192 3-1192 3-1204 3-1225
                                                                                  3-1246 3-1268 3-1334 3-1353 642 643
ted_eval_t_$DPDA                000034 external static structure                level 1 unaligned dcl 4-13
ted_eval_t_$TC                  000032 external static structure                level 1 unaligned dcl 4-9
ted_eval_t_$TL                  000030 external static structure                level 1 unaligned dcl 4-4
tedcommon_$etc                  000042 external static structure                level 1 unaligned dcl 5-11
tedcount_lines_                 000046 constant        entry                    external dcl 748 ref 3-1299
tedget_segment_                 000044 constant        entry                    external dcl 738 ref 102
tedname                 276            based           varying char(32)         level 2 dcl 6-31 ref 113
tedsort_$compare                000050 constant        entry                    external dcl 3-906 ref 3-907
tedwhere_                       000016 constant        entry                    external dcl 93 ref 3-838
temp                                   based           pointer                  level 2 in structure "val" dcl 62 in procedure
                                                                                  "tedeval_" set ref 105* 3-84 3-85* 3-118 3-119
                                                                                  3-120*
temp                            002226 automatic       varying char(100)        dcl 2-278 in procedure "geterm" set ref 2-281*
                                                                                  2-286* 2-286 2-287* 2-287 2-289* 2-289 2-290
                                                                                  2-292* 2-294* 2-295 2-298* 2-300* 2-301* 2-301
test_symbol                     002103 automatic       fixed bin(17,0)          dcl 2-257 set ref 2-66* 2-67 2-77 2-89* 2-118*
                                                                                  2-124* 246*
text                      3            based           char                     level 2 packed unaligned dcl 56 set ref 364* 370 370
                                                                                  3-86 3-218 3-218 3-218* 3-292* 3-441* 3-442*
                                                                                  3-466* 3-563* 3-623* 3-632* 3-637* 3-685* 3-738
                                                                                  3-847* 3-848* 3-902* 3-904* 3-907 3-907 3-1324*
ti                              002514 automatic       fixed bin(21,0)          dcl 3-481 set ref 3-435* 3-441 3-524* 3-525*
top                     756            based           pointer                  level 3 dcl 6-31 ref 3-367 3-1006
tp                              002302 automatic       pointer                  dcl 3-113 set ref 3-119* 3-120 3-121
tsb                             002305 automatic       fixed bin(21,0)          dcl 3-431 set ref 3-428* 3-444* 3-1079* 3-1084*
tse                             002306 automatic       fixed bin(21,0)          dcl 3-431 set ref 3-430* 3-444*
txt_r                     7            based           bit(18)                  level 2 packed unaligned dcl 76 set ref 361 363
                                                                                  3-217 3-269 3-271 3-273* 3-280 3-283* 3-285 3-290*
                                                                                  3-337* 3-737
typ                                    parameter       fixed bin(21,0)          dcl 3-1307 ref 3-1305 3-1310
type                     11     000344 automatic       fixed bin(17,0)          array level 2 in structure "ls" dcl 2-234
                                                                                  in procedure "tedeval_" set ref 2-197* 2-197 239*
                                                                                  3-260* 3-265 3-266 3-266 3-303* 3-320* 3-338 3-696
                                                                                  3-713 3-719 3-733* 3-862 3-862 3-866* 3-887*
                                                                                  3-896* 3-912* 3-925* 3-933* 3-944* 3-952* 3-960*
                                                                                  3-991* 3-1001* 3-1011* 3-1017* 3-1024* 3-1071*
                                                                                  3-1116* 3-1123* 3-1135* 3-1145* 3-1157* 3-1174*
                                                                                  3-1184* 3-1194* 3-1208* 3-1213* 3-1229* 3-1234*
                                                                                  3-1251* 3-1256* 3-1273* 3-1278* 3-1301* 3-1310
                                                                                  3-1325* 3-1331* 3-1348* 3-1359* 3-1362*
type                      1(27) 000306 automatic       char(6)                  level 2 in structure "db_data" packed unaligned
                                                                                  dcl 2-226 in procedure "tedeval_" set ref 2-41*
                                                                                  2-49* 2-88* 2-116* 2-117* 2-117 2-168*
type                      5            based           fixed bin(17,0)          level 2 in structure "avar" dcl 76 in procedure
                                                                                  "tedeval_" set ref 364 368 3-210 3-212 3-215
                                                                                  3-265* 3-338* 3-733 3-734
type                     11            based           fixed bin(17,0)          level 2 in structure "sr" dcl 47 in procedure
                                                                                  "tedeval_" set ref 3-89* 3-696* 3-701* 3-713*
                                                                                  3-719* 3-849*
unary                           000124 automatic       bit(1)                   unaligned dcl 74 set ref 144* 312* 336 340*
units                           002511 automatic       bit(1)                   unaligned dcl 3-480 set ref 3-491* 3-498 3-503 3-541
                                                                                  3-546*
unspec                                                 builtin function         dcl 722 set ref 3-1204 3-1225 3-1246 3-1268 651*
                                                                                  676*
v1                        1     000034 external static fixed bin(17,0)          array level 3 packed unaligned dcl 4-13 ref 2-25
                                                                                  2-77 2-160 2-162 2-190 2-209 2-215
v2                        1(18) 000034 external static fixed bin(17,0)          array level 3 packed unaligned dcl 4-13 ref 2-28
                                                                                  2-38 2-46 2-75 2-79 2-161 2-163 2-211 2-214 2-217
                                                                                  2-221
val                                    based           structure                level 1 unaligned dcl 62 in procedure "tedeval_"
val                                    parameter       fixed bin(21,0)          dcl 3-1381 in procedure "valid$match" ref 3-1375
                                                                                  3-1379 3-1394
val_mad                         000474 constant        fixed bin(8,0)           initial array unaligned dcl 509 ref 257 272
verify                                                 builtin function         dcl 722 ref 262 3-314 3-1183 3-1192 3-1336 3-1338
version                         000236 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 122 in procedure
                                                                                  "tedeval_" set ref 107*
version                   2            based           fixed bin(17,0)          level 2 in structure "val" dcl 62 in procedure
                                                                                  "tedeval_" set ref 104*
z_sup                           002512 automatic       bit(1)                   unaligned dcl 3-480 set ref 3-492* 3-497* 3-550
zero_on_alloc             1(01) 000236 automatic       bit(1)                   level 3 packed unaligned dcl 122 set ref 109*
zero_on_free              1(02) 000236 automatic       bit(1)                   level 3 packed unaligned dcl 122 set ref 110*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
COM                                    internal static fixed bin(24,0)          initial dcl 6-3
DPDAp                                  automatic       pointer                  dcl 4-17
NL                                     internal static char(1)                  initial unaligned dcl 3-1291
NORMAL                                 internal static fixed bin(24,0)          initial dcl 6-3
RESTART                                internal static fixed bin(24,0)          initial dcl 6-3
SAFE                                   internal static fixed bin(24,0)          initial dcl 6-3
all_des                                internal static fixed bin(17,0)          initial dcl 7-61
area_infop                             automatic       pointer                  dcl 1-5
b_c                                    based           char(1)                  array unaligned dcl 7-58
bits                                   based           bit(9)                   array unaligned dcl 3-1402
call_stk                               based           structure                level 1 unaligned dcl 8-21
dbase_vers_3                           internal static fixed bin(17,0)          initial dcl 6-30
i                                      automatic       fixed bin(21,0)          dcl 3-1289
ii                                     automatic       fixed bin(21,0)          dcl 3-1290
lc                                     automatic       fixed bin(21,0)          dcl 3-1288
live_des                               internal static fixed bin(17,0)          initial dcl 7-61
nil_sym                                automatic       fixed bin(17,0)          dcl 2-266
pstr                                   based           char(256)                unaligned dcl 8-19
rc_close                               internal static fixed bin(24,0)          initial dcl 6-8
rc_fail                                internal static fixed bin(24,0)          initial dcl 6-9
rc_keyerr                              internal static fixed bin(24,0)          initial dcl 6-11
rc_nop                                 internal static fixed bin(24,0)          initial dcl 6-10
recov_msg                              automatic       varying char(150)        dcl 2-268
reloc_first                            internal static fixed bin(17,0)          initial dcl 7-61
reloc_last                             internal static fixed bin(17,0)          initial dcl 7-61
rl_b                                   automatic       fixed bin(21,0)          dcl 6-14
rl_c                                   based           char(1)                  array unaligned dcl 6-17
rl_i                                   defined         fixed bin(21,0)          dcl 6-15
rl_l                                   defined         fixed bin(21,0)          dcl 6-16
rl_s                                   based           char                     unaligned dcl 6-18
tedcommon_$id                          external static structure                level 1 unaligned dcl 5-5
tedcommon_$no_data                     external static structure                level 1 unaligned dcl 5-8
tedcommon_$no_seg                      external static structure                level 1 unaligned dcl 5-9

NAMES DECLARED BY EXPLICIT CONTEXT.
CASE                            000000 constant        label                    array(0:10) dcl 2-28 set ref 2-25
LS                              000013 constant        label                    array(0:40) dcl 266 ref 264 326
MORE                            003661 constant        label                    dcl 235 ref 254 268 371 378
NEXT                            002142 constant        label                    dcl 2-11 ref 2-146 2-207 2-218 2-222
STRING_TYPE                     015173 constant        entry                    internal dcl 636 ref 289 296
alloc                           013777 constant        entry                    internal dcl 3-81 ref 3-439 3-465 3-562 3-609 3-681
                                                                                  3-846 3-1323
alpha                           004553 constant        label                    dcl 353 set ref 404 409 413 428 434 439 446 462 466
                                                                                  470 472 503
check_offset                    012451 constant        label                    dcl 3-1071 ref 3-1035 3-1045 3-1055 3-1063
check_split                     007323 constant        label                    dcl 3-428 ref 3-406 3-415
ckK                             015152 constant        entry                    internal dcl 623 ref 3-253 3-358
cka                             015110 constant        entry                    internal dcl 595 ref 3-237 3-989
ckk                             015131 constant        entry                    internal dcl 609 ref 3-245 3-349
concatenate                     011342 constant        label                    dcl 3-840 ref 3-826
dbf                             003401 constant        entry                    external dcl 758
dbn                             003367 constant        entry                    external dcl 757
done_parse                      002144 constant        label                    dcl 2-14
dump_ls                         003411 constant        entry                    internal dcl 2-196 ref 2-142 2-194
err_ret                         002616 constant        label                    dcl 2-107 ref 300 566 3-1344 601 615 629 661 686
err_text                        002511 constant        label                    dcl 2-94 ref 2-150 2-154 3-225 3-312 3-318 3-385
                                                                                  3-606 3-676 3-731 3-1392
error                           002432 constant        label                    dcl 2-85 ref 247 266 385 489
finish                          002144 constant        label                    dcl 2-14 ref 3-123
fn                              000221 constant        label                    array(0:8) dcl 3-1311 ref 3-1310
get_rest                        003477 constant        label                    dcl 2-282 ref 2-302
geterm                          003474 constant        entry                    internal dcl 2-275 ref 2-118
getermc                         003611 constant        entry                    internal dcl 2-296 ref 2-89 2-124
got_symbol                      002622 constant        label                    dcl 2-111 ref 2-73 2-80
kexp_path                       011161 constant        label                    dcl 3-787 ref 3-762 3-771 3-780
kexp_return                     011406 constant        label                    dcl 3-849 ref 3-352 3-361 3-376 3-390 3-401 3-449
                                                                                  3-458 3-467 3-565 3-641 3-689 3-704 3-753 3-792
                                                                                  3-801 3-809 3-817
make                            014444 constant        entry                    internal dcl 3-1305 ref 3-138 3-147 3-234 3-236
                                                                                  3-242 3-244 3-250 3-252 3-258 3-470 3-472 3-575
                                                                                  3-578 3-586 3-587 3-646 3-648 3-649 3-694 3-709
                                                                                  3-821 3-823 3-829 3-831 3-854 3-864 3-865 3-894
                                                                                  3-895 3-922 3-924 3-930 3-932 3-941 3-943 3-949
                                                                                  3-951 3-957 3-959 3-969 3-975 3-995 3-1110 3-1112
                                                                                  3-1120 3-1127 3-1129 3-1138 3-1140 3-1149 3-1151
                                                                                  3-1161 3-1163 3-1178 3-1180 3-1187 3-1189 3-1197
                                                                                  3-1218 3-1239 3-1261
maybe_null_str                  007122 constant        label                    dcl 3-370 ref 3-379
ns_alt                          005774 constant        entry                    internal dcl 556 ref 140 370 3-856
read_look                       002332 constant        label                    dcl 2-60 set ref 2-36 2-45
rule                            000064 constant        label                    array(2:94) dcl 3-96 ref 3-79
scanner                         003652 constant        entry                    internal dcl 154 ref 2-62
set_string                      014525 constant        label                    dcl 3-1320 ref 3-1370
setup_avar                      006774 constant        label                    dcl 3-333 ref 3-304
ted_vtab_                       006066 constant        entry                    internal dcl 3-78 ref 2-164
tedeval_                        001717 constant        entry                    external dcl 25
test_for_paren                  005241 constant        label                    dcl 426 ref 454 460 461 502
typ                             000232 constant        label                    array(0:4) dcl 644 set ref 643
unary_check                     004317 constant        label                    dcl 304 ref 321 347 351 384 402
valid                           015030 constant        entry                    internal dcl 3-1379 ref 3-404 3-413 3-1032 3-1042
                                                                                  3-1052 3-1060 3-1295 3-1297
valid$match                     015025 constant        entry                    internal dcl 3-1375
vdump                           014031 constant        entry                    internal dcl 3-185 ref 3-160 3-167 3-174 3-182

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16724       16776   16505       16734
Length     17414   16505        52         402     216           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tedeval_                           2026 external procedure  is an external procedure.  
dump_ls                                 internal procedure  shares stack frame of external procedure tedeval_.  
geterm                                  internal procedure  shares stack frame of external procedure tedeval_.  
scanner                             107 internal procedure  calls itself recursively.  
ted_vtab_                               internal procedure  shares stack frame of external procedure tedeval_.  
alloc                                   internal procedure  shares stack frame of external procedure tedeval_.  
vdump                                   internal procedure  shares stack frame of external procedure tedeval_.  
begin block on line 3-570               begin block         shares stack frame of external procedure tedeval_.  
begin block on line 3-1285              begin block         shares stack frame of external procedure tedeval_.  
make                                    internal procedure  shares stack frame of external procedure tedeval_.  
valid$match                             internal procedure  shares stack frame of external procedure tedeval_.  
cka                                     internal procedure  shares stack frame of external procedure tedeval_.  
ckk                                     internal procedure  shares stack frame of external procedure tedeval_.  
ckK                                     internal procedure  shares stack frame of external procedure tedeval_.  
STRING_TYPE                             internal procedure  shares stack frame of internal procedure scanner.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 db_sw                       tedeval_
000011 NL                          ted_vtab_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
scanner                  000100 ret_val                     scanner
                         000101 k                           scanner
                         000102 j                           scanner
                         000116 hold_string                 STRING_TYPE
                         000123 i                           STRING_TYPE
                         000124 j                           STRING_TYPE
                         000125 rn                          STRING_TYPE
tedeval_                 000100 s1_ptr                      tedeval_
                         000102 s2_ptr                      tedeval_
                         000104 sr_ptr                      tedeval_
                         000106 ex_sw                       tedeval_
                         000107 ch2                         tedeval_
                         000110 ind                         tedeval_
                         000112 cat_p                       tedeval_
                         000114 cat_l                       tedeval_
                         000115 ii                          tedeval_
                         000116 lval_ptr                    tedeval_
                         000120 nextab                      tedeval_
                         000121 avar_len                    tedeval_
                         000122 avar_ptr                    tedeval_
                         000124 unary                       tedeval_
                         000125 char16                      tedeval_
                         000132 ns_string                   tedeval_
                         000233 ns_num                      tedeval_
                         000234 conc_sw                     tedeval_
                         000236 ai                          tedeval_
                         000262 iti                         tedeval_
                         000306 db_data                     tedeval_
                         000344 ls                          tedeval_
                         001570 lst                         tedeval_
                         001571 cur_lex_top                 tedeval_
                         001735 parse_stack                 tedeval_
                         002101 altn                        tedeval_
                         002102 current_state               tedeval_
                         002103 test_symbol                 tedeval_
                         002104 current_table               tedeval_
                         002105 i                           tedeval_
                         002106 la_ct                       tedeval_
                         002107 la_get                      tedeval_
                         002110 la_need                     tedeval_
                         002111 la_put                      tedeval_
                         002112 la_use                      tedeval_
                         002113 next_state                  tedeval_
                         002114 ps_top                      tedeval_
                         002115 rulen                       tedeval_
                         002116 t                           tedeval_
                         002117 jaf                         tedeval_
                         002120 l_del                       tedeval_
                         002121 p_del                       tedeval_
                         002122 level                       tedeval_
                         002124 input                       tedeval_
                         002170 IP                          tedeval_
                         002172 te                          tedeval_
                         002173 fc                          tedeval_
                         002174 l                           tedeval_
                         002175 lgnc                        tedeval_
                         002176 lnl                         tedeval_
                         002177 nc                          tedeval_
                         002200 dbase_p                     tedeval_
                         002202 bp                          tedeval_
                         002204 sv_p                        tedeval_
                         002226 temp                        geterm
                         002266 comp                        ted_vtab_
                         002267 i                           ted_vtab_
                         002270 j                           ted_vtab_
                         002271 mc                          ted_vtab_
                         002272 cv                          ted_vtab_
                         002302 tp                          ted_vtab_
                         002304 next_avar                   ted_vtab_
                         002305 tsb                         ted_vtab_
                         002306 tse                         ted_vtab_
                         002307 ascii                       ted_vtab_
                         002507 sign                        ted_vtab_
                         002510 fill                        ted_vtab_
                         002511 units                       ted_vtab_
                         002512 z_sup                       ted_vtab_
                         002513 hexd                        ted_vtab_
                         002514 ti                          ted_vtab_
                         002515 nibble                      ted_vtab_
                         002516 XXloc                       ted_vtab_
                         002526 XXnum                       ted_vtab_
                         002532 sx_ptr                      ted_vtab_
                         002534 R                           ted_vtab_
                         002540 lsbe                        ted_vtab_
                         002541 ii                          ted_vtab_
                         002572 i                           begin block on line 3-570
                         002573 ifr                         begin block on line 3-570
                         002574 ito                         begin block on line 3-570
                         002575 leng                        begin block on line 3-1285
                         002604 fb35                        make

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
bs_to_fx2           tra_ext             bound_check_signal  mod_fx1             signal              shorten_stack
ext_entry           int_entry           reverse_cs          set_cs_eis          set_bs_eis          index_cs_eis
verify_eis          search_eis          any_to_any_tr       alloc_based         free_based          index_reverse_cs
verify_reverse_cs   search_reverse_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  ioa_                          ioa_$ioa_switch               ioa_$ioa_switch_nnl
ioa_$nnl                      iox_$put_chars                tedcount_lines_               tedget_segment_
tedsort_$compare              tedwhere_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output              sys_info$max_seg_size         ted_eval_t_$DPDA              ted_eval_t_$TC
ted_eval_t_$TL                tedcommon_$etc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 001710        96 001724        97 001727        98 001732        99 001734       100 001736       102 001742
    103 001754       104 001757       105 001761       106 001763       107 001764       108 001766       109 001770
    110 001772       111 001774       112 001776       113 002000       114 002005       115 002011       116 002013
    117 002026       119 002031       120 002037       128 002040       129 002043       134 002045       135 002053
    136 002057       137 002061       138 002062       139 002064       140 002065       141 002102       142 002103
    143 002106       144 002107       145 002110       147 002114       148 002116       149 002132    2    5 002133
 2    6 002135    2    7 002137    2    8 002141    2   11 002142    2   14 002144    2   18 002170    2   19 002172
 2   20 002175    2   22 002176    2   23 002177    2   24 002202    2   25 002211    2   28 002232    2   30 002240
 2   32 002251    2   35 002257    2   36 002260    2   38 002261    2   41 002267    2   43 002272    2   44 002274
 2   45 002276    2   46 002277    2   49 002305    2   51 002310    2   52 002312    2   53 002314    2   54 002316
 2   57 002324    2   58 002325    2   59 002330    2   60 002332    2   62 002335    2   63 002345    2   64 002354
 2   65 002355    2   66 002356    2   67 002362    2   69 002367    2   70 002370    2   71 002372    2   72 002374
 2   73 002376    2   75 002377    2   77 002415    2   79 002422    2   80 002427    2   82 002430    2   85 002432
 2   88 002436    2   89 002441    2   90 002447    2   93 002502    2   94 002511    2   96 002513    2   97 002520
 2   98 002522    2   99 002533    2  100 002541    2  103 002557    2  105 002603    2  106 002605    2  107 002616
 2  109 002621    2  111 002622    2  114 002626    2  116 002630    2  117 002633    2  118 002642    2  122 002651
 2  124 002652    2  129 002660    2  132 002713    2  133 002715    2  134 002716    2  135 002720    2  137 002721
 2  140 002727    2  141 002730    2  142 002742    2  143 002747    2  144 002756    2  146 002760    2  148 002761
 2  150 002770    2  152 002771    2  154 003000    2  156 003001    2  160 003003    2  161 003011    2  162 003017
 2  163 003022    2  164 003030    2  166 003034    2  168 003040    2  169 003043    2  170 003046    2  173 003110
 2  175 003112    2  177 003134    2  178 003136    2  180 003137    2  182 003143    2  184 003172    2  185 003203
 2  187 003227    2  188 003232    2  190 003252    2  192 003264    2  193 003266    2  194 003270    2  202 003274
 2  204 003276    2  205 003277    2  206 003302    2  207 003304    2  209 003305    2  211 003313    2  213 003321
 2  214 003324    2  215 003341    2  217 003346    2  218 003353    2  220 003354    2  221 003356    2  222 003365
    757 003366       757 003374       757 003377       758 003400       758 003406       758 003410    2  196 003411
 2  197 003412    2  201 003473    2  275 003474    2  281 003476    2  282 003477    2  286 003507    2  287 003516
 2  289 003537    2  290 003546    2  292 003555    2  294 003565    2  295 003602    2  296 003611    2  298 003613
 2  300 003624    2  301 003641    2  302 003650       154 003651       235 003661       237 003675       238 003676
    239 003677       240 003700       241 003701       242 003702       244 003706       246 003710       247 003711
    249 003714       250 003716       251 003722       252 003725       253 003727       254 003731       256 003732
    257 003733       258 003750       259 003751       261 003761       262 003763       263 004002       264 004012
    266 004021       268 004032       269 004033       271 004036       272 004047       273 004077       274 004116
    275 004120       276 004125       277 004130       279 004142       281 004146       282 004147       283 004152
    284 004166       286 004172       287 004207       288 004214       289 004215       290 004234       292 004240
    293 004247       294 004250       295 004254       296 004255       298 004271       299 004272       300 004302
    302 004305       304 004317       311 004335       312 004337       314 004352       316 004364       317 004376
    319 004410       320 004413       320 004414       321 004416       323 004417       324 004424       324 004425
    325 004437       326 004441       329 004442       330 004454       332 004466       333 004471       333 004472
    334 004504       336 004516       340 004520       341 004521       343 004523       345 004535       346 004540
    346 004541       347 004543       349 004544       350 004547       350 004550       351 004552       353 004553
    356 004560       357 004565       358 004570       361 004577       363 004607       364 004612       366 004652
    368 004657       370 004662       371 004703       373 004704       374 004707       376 004721       377 004724
    378 004730       380 004735       381 004742       383 004754       384 004757       384 004760       385 004761
    387 004764       388 004771       388 004772       389 005004       389 005011       389 005012       390 005024
    390 005031       390 005032       391 005044       391 005051       391 005052       392 005064       393 005066
    394 005073       394 005074       396 005106       398 005123       399 005125       401 005134       402 005135
    404 005136       406 005137       407 005144       407 005145       408 005157       408 005164       408 005165
    409 005177       411 005200       412 005205       412 005206       413 005220       421 005221       423 005230
    425 005236       426 005241       428 005246       430 005253       431 005254       433 005266       434 005270
    436 005271       437 005276       437 005277       438 005311       438 005316       438 005317       439 005331
    441 005332       442 005337       442 005340       443 005352       443 005357       443 005360       444 005372
    444 005377       444 005400       445 005412       445 005417       445 005420       446 005432       448 005433
    449 005440       449 005441       450 005453       450 005460       450 005461       451 005473       451 005500
    451 005501       452 005513       452 005520       452 005521       453 005533       454 005535       456 005536
    457 005543       457 005544       458 005556       458 005563       458 005564       460 005576       460 005603
    460 005605       461 005606       461 005613       461 005615       462 005616       464 005617       466 005636
    468 005637       469 005644       469 005645       470 005657       472 005660       474 005663       475 005664
    476 005700       477 005701       488 005702       489 005716       491 005722       493 005727       494 005731
    496 005746       497 005760       501 005761       502 005767       502 005771       503 005772       556 005773
    562 006002       564 006006       565 006011       566 006017       568 006022       570 006024       571 006027
    572 006032       573 006034       575 006036       576 006037       577 006046       579 006054       580 006060
 3   78 006066    3   79 006070    3   96 006072    3   98 006074    3  107 006075    3  110 006076    3  118 006077
 3  119 006104    3  120 006107    3  121 006111    3  122 006117    3  123 006120    3  131 006121    3  138 006122
 3  139 006127    3  140 006155    3  142 006203    3  143 006205    3  147 006206    3  149 006210    3  150 006227
 3  153 006230    3  155 006232    3  158 006233    3  160 006237    3  161 006240    3  162 006242    3  165 006243
 3  167 006247    3  168 006250    3  169 006252    3  172 006253    3  174 006257    3  175 006260    3  176 006262
 3  179 006263    3  181 006267    3  182 006301    3  183 006302    3  184 006304    3  234 006305    3  236 006312
 3  237 006314    3  238 006334    3  239 006343    3  242 006344    3  244 006351    3  245 006353    3  246 006406
 3  247 006415    3  250 006416    3  252 006423    3  253 006425    3  254 006460    3  255 006467    3  258 006470
 3  260 006472    3  263 006477    3  265 006503    3  266 006506    3  269 006513    3  271 006516    3  272 006521
 3  273 006527    3  275 006532    3  276 006535    3  277 006542    3  279 006543    3  280 006546    3  282 006552
 3  283 006565    3  284 006570    3  285 006571    3  286 006574    3  288 006577    3  289 006604    3  290 006617
 3  292 006622    3  293 006637    3  294 006644    3  299 006645    3  302 006655    3  303 006667    3  304 006671
 3  307 006672    3  311 006677    3  312 006706    3  314 006707    3  317 006726    3  318 006735    3  320 006736
 3  322 006743    3  323 006746    3  326 006754    3  327 006756    3  329 006764    3  330 006767    3  332 006770
 3  333 006774    3  335 007002    3  337 007006    3  338 007010    3  339 007015    3  340 007016    3  341 007021
 3  342 007023    3  346 007024    3  348 007030    3  349 007032    3  350 007044    3  351 007046    3  352 007053
 3  355 007054    3  357 007060    3  358 007062    3  359 007074    3  360 007076    3  361 007103    3  364 007104
 3  366 007111    3  367 007113    3  368 007116    3  370 007122    3  373 007124    3  374 007132    3  375 007134
 3  376 007135    3  378 007136    3  379 007137    3  381 007141    3  384 007146    3  385 007155    3  387 007156
 3  388 007162    3  389 007165    3  390 007167    3  393 007170    3  395 007172    3  396 007176    3  398 007203
 3  399 007206    3  400 007210    3  401 007212    3  403 007213    3  404 007216    3  405 007233    3  406 007237
 3  409 007240    3  411 007242    3  412 007246    3  413 007251    3  414 007266    3  415 007272    3  418 007273
 3  420 007275    3  421 007301    3  422 007304    3  423 007307    3  425 007314    3  426 007316    3  428 007323
 3  430 007326    3  432 007330    3  435 007337    3  436 007341    3  437 007345    3  438 007351    3  439 007353
 3  441 007354    3  442 007364    3  444 007374    3  448 007457    3  449 007464    3  452 007465    3  454 007470
 3  455 007474    3  456 007476    3  457 007500    3  458 007502    3  462 007503    3  464 007507    3  465 007511
 3  466 007512    3  467 007520    3  470 007521    3  472 007526    3  473 007533    3  474 007537    3  475 007552
 3  476 007564    3  483 007574    3  484 007576    3  485 007602    3  486 007604    3  487 007615    3  488 007617
 3  489 007620    3  491 007622    3  492 007624    3  493 007625    3  494 007627    3  495 007635    3  496 007641
 3  497 007644    3  498 007646    3  499 007650    3  503 007656    3  506 007665    3  507 007666    3  508 007670
 3  509 007671    3  511 007673    3  512 007675    3  513 007677    3  515 007700    3  516 007711    3  518 007712
 3  520 007717    3  521 007721    3  523 007734    3  524 007735    3  525 007754    3  526 007764    3  528 010003
 3  529 010006    3  531 010017    3  532 010021    3  535 010023    3  537 010030    3  538 010032    3  539 010036
 3  540 010040    3  541 010041    3  544 010045    3  546 010047    3  548 010050    3  550 010055    3  551 010062
 3  552 010066    3  556 010073    3  558 010102    3  559 010105    3  561 010113    3  562 010115    3  563 010116
 3  565 010124    3  575 010125    3  576 010132    3  578 010136    3  579 010143    3  580 010147    3  581 010151
 3  582 010154    3  584 010161    3  586 010162    3  587 010167    3  588 010174    3  589 010200    3  590 010202
 3  591 010205    3  592 010207    3  594 010213    3  596 010220    3  598 010223    3  601 010226    3  603 010236
 3  605 010242    3  606 010251    3  608 010252    3  609 010257    3  610 010260    3  611 010262    3  613 010264
 3  614 010266    3  616 010270    3  617 010276    3  618 010304    3  620 010305    3  621 010312    3  623 010317
 3  624 010324    3  625 010326    3  627 010330    3  628 010332    3  629 010334    3  630 010341    3  631 010343
 3  632 010345    3  633 010353    3  634 010354    3  637 010356    3  639 010405    3  641 010410    3  646 010411
 3  648 010416    3  649 010423    3  650 010430    3  651 010434    3  652 010436    3  653 010444    3  654 010447
 3  655 010465    3  657 010466    3  658 010476    3  659 010500    3  660 010502    3  662 010503    3  663 010510
 3  664 010512    3  665 010517    3  666 010521    3  667 010523    3  669 010527    3  670 010532    3  671 010533
 3  672 010543    3  673 010556    3  675 010557    3  676 010566    3  678 010567    3  679 010571    3  680 010573
 3  681 010577    3  682 010600    3  683 010602    3  684 010613    3  685 010626    3  687 010640    3  688 010641
 3  689 010643    3  692 010644    3  694 010650    3  695 010655    3  696 010662    3  697 010665    3  698 010667
 3  699 010673    3  701 010677    3  702 010701    3  704 010702    3  707 010703    3  709 010707    3  710 010714
 3  712 010721    3  713 010725    3  714 010727    3  715 010731    3  716 010735    3  718 010736    3  719 010742
 3  720 010744    3  721 010746    3  723 010752    3  726 010753    3  728 010757    3  730 010764    3  731 010773
 3  733 010774    3  734 010777    3  737 011005    3  738 011012    3  739 011014    3  740 011016    3  742 011023
 3  745 011024    3  747 011030    3  748 011041    3  750 011045    3  751 011047    3  752 011051    3  753 011053
 3  756 011054    3  758 011060    3  759 011071    3  761 011075    3  762 011077    3  765 011100    3  767 011104
 3  768 011115    3  770 011121    3  771 011123    3  774 011124    3  776 011130    3  777 011141    3  779 011145
 3  780 011147    3  783 011150    3  785 011154    3  786 011156    3  787 011161    3  789 011163    3  791 011172
 3  792 011173    3  796 011174    3  798 011200    3  799 011205    3  800 011207    3  801 011212    3  804 011213
 3  806 011217    3  807 011224    3  808 011226    3  809 011235    3  812 011236    3  814 011242    3  815 011247
 3  816 011251    3  817 011253    3  821 011254    3  823 011256    3  824 011263    3  825 011271    3  826 011273
 3  829 011274    3  831 011276    3  832 011303    3  833 011311    3  834 011313    3  836 011315    3  837 011317
 3  838 011333    3  840 011342    3  842 011346    3  843 011352    3  846 011356    3  847 011357    3  848 011375
 3  849 011406    3  851 011411    3  854 011412    3  856 011417    3  858 011437    3  862 011440    3  864 011450
 3  865 011452    3  866 011457    3  867 011464    3  868 011466    3  869 011470    3  871 011474    3  873 011521
 3  875 011530    3  876 011534    3  878 011535    3  880 011545    3  882 011553    3  884 011557    3  886 011566
 3  887 011567    3  888 011574    3  894 011575    3  895 011577    3  896 011604    3  897 011611    3  898 011613
 3  899 011615    3  900 011620    3  901 011633    3  902 011635    3  903 011647    3  904 011652    3  905 011664
 3  907 011666    3  908 011705    3  909 011714    3  911 011727    3  912 011730    3  913 011735    3  918 011736
 3  919 011743    3  922 011744    3  924 011746    3  925 011753    3  926 011760    3  927 011762    3  930 011763
 3  932 011765    3  933 011772    3  934 011777    3  935 012001    3  941 012002    3  943 012004    3  944 012011
 3  945 012016    3  946 012021    3  949 012022    3  951 012024    3  952 012031    3  953 012036    3  954 012041
 3  957 012042    3  959 012044    3  960 012051    3  961 012056    3  962 012062    3  969 012063    3  971 012065
 3  972 012074    3  975 012075    3  977 012077    3  978 012106    3  979 012111    3  984 012112    3  986 012121
 3  989 012122    3  991 012144    3  992 012151    3  995 012152    3  997 012157    3  998 012166    3 1001 012167
 3 1003 012174    3 1006 012175    3 1008 012200    3 1010 012210    3 1011 012215    3 1012 012222    3 1015 012223
 3 1017 012231    3 1018 012236    3 1022 012237    3 1024 012245    3 1025 012252    3 1030 012253    3 1032 012255
 3 1034 012277    3 1035 012302    3 1038 012303    3 1040 012305    3 1042 012320    3 1044 012342    3 1045 012345
 3 1048 012346    3 1050 012350    3 1052 012363    3 1054 012405    3 1055 012410    3 1058 012411    3 1060 012413
 3 1062 012435    3 1063 012440    3 1066 012441    3 1070 012443    3 1071 012451    3 1073 012456    3 1075 012464
 3 1077 012523    3 1079 012524    3 1080 012526    3 1082 012531    3 1084 012537    3 1087 012616    3 1090 012617
 3 1092 012624    3 1095 012625    3 1097 012632    3 1100 012633    3 1104 012642    3 1110 012643    3 1112 012645
 3 1113 012652    3 1115 012667    3 1116 012675    3 1117 012702    3 1120 012703    3 1122 012710    3 1123 012715
 3 1124 012722    3 1127 012723    3 1129 012730    3 1130 012735    3 1131 012741    3 1132 012743    3 1135 012762
 3 1136 012767    3 1138 012770    3 1140 012775    3 1141 013002    3 1142 013006    3 1143 013010    3 1145 013027
 3 1146 013034    3 1149 013035    3 1151 013042    3 1152 013047    3 1153 013053    3 1154 013055    3 1157 013075
 3 1158 013102    3 1161 013103    3 1163 013110    3 1164 013115    3 1165 013121    3 1166 013123    3 1171 013154
 3 1174 013175    3 1175 013202    3 1178 013203    3 1180 013210    3 1181 013215    3 1182 013221    3 1183 013223
 3 1184 013242    3 1185 013247    3 1187 013250    3 1189 013255    3 1190 013262    3 1191 013266    3 1192 013270
 3 1194 013307    3 1195 013314    3 1197 013315    3 1199 013322    3 1200 013326    3 1201 013330    3 1202 013331
 3 1203 013343    3 1204 013344    3 1205 013355    3 1207 013365    3 1208 013372    3 1209 013377    3 1211 013400
 3 1212 013402    3 1213 013405    3 1214 013412    3 1218 013413    3 1220 013420    3 1221 013424    3 1222 013426
 3 1223 013427    3 1224 013437    3 1225 013440    3 1226 013451    3 1228 013461    3 1229 013466    3 1230 013473
 3 1232 013474    3 1233 013477    3 1234 013502    3 1235 013507    3 1239 013510    3 1241 013515    3 1242 013521
 3 1243 013523    3 1244 013524    3 1245 013535    3 1246 013536    3 1247 013547    3 1250 013560    3 1251 013565
 3 1252 013572    3 1254 013573    3 1255 013575    3 1256 013600    3 1257 013605    3 1261 013606    3 1263 013613
 3 1264 013617    3 1265 013621    3 1266 013622    3 1267 013633    3 1268 013634    3 1269 013645    3 1272 013656
 3 1273 013663    3 1274 013670    3 1276 013671    3 1277 013674    3 1278 013677    3 1279 013704    3 1294 013705
 3 1295 013710    3 1297 013730    3 1299 013751    3 1301 013771    3 1303 013776    3   81 013777    3   83 014000
 3   84 014013    3   85 014016    3   86 014017    3   87 014022    3   88 014024    3   89 014026    3   91 014030
 3  185 014031    3  186 014032    3  187 014041    3  188 014045    3  190 014057    3  192 014110    3  193 014113
 3  195 014125    3  197 014170    3  198 014173    3  200 014205    3  202 014250    3  203 014253    3  205 014255
 3  206 014260    3  209 014266    3  210 014270    3  212 014317    3  215 014354    3  217 014356    3  218 014363
 3  221 014423    3  222 014430    3  224 014431    3  225 014440    3  227 014441    3  228 014443    3 1305 014444
 3 1310 014446    3 1311 014470    3 1317 014471    3 1319 014475    3 1320 014525    3 1322 014532    3 1323 014534
 3 1324 014535    3 1325 014543    3 1326 014551    3 1328 014552    3 1331 014562    3 1332 014567    3 1334 014570
 3 1336 014605    3 1338 014621    3 1341 014646    3 1342 014655    3 1343 014667    3 1344 014676    3 1347 014677
 3 1348 014714    3 1349 014722    3 1351 014723    3 1353 014727    3 1355 014746    3 1356 014755    3 1358 014767
 3 1359 014771    3 1360 014777    3 1362 015000    3 1364 015005    3 1366 015006    3 1369 015020    3 1370 015024
 3 1375 015025    3 1379 015027    3 1384 015032    3 1386 015046    3 1388 015052    3 1390 015063    3 1391 015071
 3 1392 015104    3 1394 015105       595 015110       598 015112       600 015117       601 015126       603 015127
    609 015131       612 015133       614 015140       615 015147       617 015150       623 015152       626 015154
    628 015161       629 015170       631 015171       636 015173       640 015175       642 015202       643 015210
    644 015222       645 015225       648 015226       649 015230       651 015231       654 015242       655 015247
    656 015260       658 015262       659 015272       660 015304       661 015313       663 015316       665 015322
    666 015333       667 015335       668 015340       669 015346       670 015352       673 015353       674 015355
    676 015356       679 015367       680 015375       681 015406       683 015410       684 015420       685 015432
    686 015441       688 015444       689 015455       690 015457       691 015462       692 015470


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
