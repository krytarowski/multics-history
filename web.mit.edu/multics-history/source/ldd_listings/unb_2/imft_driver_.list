	COMPILATION LISTING OF SEGMENT imft_driver_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1325.6 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* Inter-Multics File Transfer Daemon */
       10 
       11 /* Created:  October 1980 by G. Palter using hasp_ws_sim_driver_ as a base */
       12 /* Modified: 24 September 1981 by G. Palter to perform synchronization and automatically start processing requests */
       13 /* Modified: April 1982 by G. Palter to complete initial implementation */
       14 /* Modified: July 1982 by G. Palter to accept "indirect=<pathname>" keyword and implement true AIM support */
       15 /* Modified: February 1983 by Robert Coren to accept "-io_description" as alternative to "-input_description" and
       16*   "-output_description", and to process "version" keyword */
       17 /* Modified: March 1983 by Robert Coren to set up for 2 minor devices for output driver (for remote requests)
       18*   and to make "yes_no_p" tell whether it was yes or no */
       19 /* Modified: 28 April 1983 by G. Palter to make the indirect keyword accept archive component pathnames */
       20 /* Modified: August 1983 by Robert Coren to handle minimum access class */
       21 /* Modified: 1984-09-17 by E. Swenson to remove call to pnt_manager_$test. */
       22 /* Modified: February 23, 1985 by C. Marker to use version 5 message segments */
       23 
       24 /****^  HISTORY COMMENTS:
       25*  1) change(87-11-15,Oke), approve(88-08-01,MCR7948), audit(88-10-11,Farley),
       26*     install(88-10-14,MR12.2-1165):
       27*     a. Permit use as an in-dial/out-dial daemon using a data protocol to
       28*        establish the connection.
       29*     b. Numerous minor bug fixes and cleanups, such as releasing attribute
       30*        storage which was allocated.
       31*     c. Add line_speed command for a driver.  Permit receiver to be out-dial
       32*        and transmitter as in-dial.  Reduce instances of having to reinitialize
       33*        due to line detachment by resectioning code and permitting line
       34*        reattachment and synchronization.
       35*  2) change(88-06-20,Beattie), approve(88-08-01,MCR7948),
       36*     audit(88-10-11,Farley), install(88-10-14,MR12.2-1165):
       37*     a. Internal date time routine replaced with date_time_$format calls.
       38*     b. Add support for min_time_est_msg keyword.
       39*     c. Prevent driver from initializing if execution ring less than 4.
       40*  3) change(88-08-20,Brunelle), approve(88-08-19,MCR7911),
       41*     audit(88-10-26,Wallman), install(88-10-28,MR12.2-1199):
       42*     Upgrade to version 5 iod tables.
       43*                                                   END HISTORY COMMENTS */
       44 
       45 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       46 
       47 imft_driver_:
       48      procedure ();
       49 
       50 	return;					/* not an entry */
       51 
       52 /* Initialize the driver */
       53 
       54 init:
       55      entry (P_stat_p);
       56 
       57 /****
       58*      Extended object access checks get more complicated when the driver is
       59*      executing in a ring lower than 4.  This restriction is not seen as a
       60*      problem since it is expected that sites are running their daemons in a
       61*      ring 4 process.  This prevents mailboxes, PNTs, DM files, etc, from being
       62*      handled by an IMFT connection.
       63**/
       64 
       65 	my_ring = get_ring_ ();
       66 	if my_ring < 4 then do;
       67 	     call iodd_msg_ (ERROR, MASTER, error_table_$fatal_error, IMFT_DRIVER_,
       68 		"The IMFT driver must be executing in a ring not less than 4.");
       69 	     return;
       70 	end;
       71 
       72 	system_area_ptr = get_system_free_area_ ();
       73 
       74 	stat_p = P_stat_p;
       75 	static_pause_time = 10;			/* need to set the default somewhere */
       76 
       77 	text_strings_ptr = iodd_static.text_strings_ptr;	/* get ptr to i/o daemon table text area */
       78 
       79 	if iodd_static.attach_type ^= ATTACH_TYPE_TTY then do;
       80 						/* this driver expects a tty channel */
       81 
       82 BAD_LINE_STATEMENT:
       83 	     call iodd_msg_ (ERROR, MASTER, error_table_$fatal_error, IMFT_DRIVER_,
       84 		"The IMFT driver must be defined with a ""line: *;"" statement.");
       85 	     return;				/* quit now */
       86 	end;
       87 
       88 	if iodd_static.attach_name ^= "*" then go to BAD_LINE_STATEMENT;
       89 
       90 	if iodd_static.slave.active then do;		/* no slave device allowed */
       91 	     call iodd_msg_ (ERROR, MASTER, error_table_$fatal_error, IMFT_DRIVER_,
       92 		"The IMFT driver does not accept slave terminals.");
       93 	     return;
       94 	end;
       95 
       96 	iodd_static.dev_io_stream, iodd_static.dev_in_stream = "Undefined_stream!";
       97 						/* not used by this driver */
       98 
       99 	ds_ptr = iodd_static.driver_ptr;		/* preset by iodd_ */
      100 	ds_ptr -> driver_status.dev_out_iocbp, ds_ptr -> driver_status.dev_in_iocbp = null ();
      101 	ds_ptr -> driver_status.dev_out_stream, ds_ptr -> driver_status.dev_in_stream = "null_stream";
      102 	ds_ptr -> driver_status.dev_ctl_ptr = null ();
      103 
      104 	ds_ptr -> driver_status.bit_rate_est,		/* no output rate defined yet */
      105 	     ds_ptr -> driver_status.defer_time_limit = 0;/* make operator specify */
      106 
      107 	saved_test_entry = iodd_static.test_entry;	/* will restore before returning to iodd_ */
      108 	major_args_ptr = null ();			/* for cleanup handler */
      109 	send_logout_record = "1"b;			/* tell the other side about ordinary logouts */
      110 	dma.dial_channel = 0;
      111 
      112 /* Establish initial condition of aim_attributes_ptr to ensure allocated
      113*   storage is freed. */
      114 
      115 	static.local_system.aim_attributes_ptr = null ();
      116 	static.foreign_system.aim_attributes_ptr = null ();
      117 	static.dial_service = ""b;			/* not a dial protocol */
      118 
      119 	on condition (daemon_logout), condition (daemon_new_device), condition (no_coord)
      120 	     begin;
      121 	     if send_logout_record then do;		/* don't tell other side if they told us */
      122 		local_icri.record_type = IMFT_LOGOUT;
      123 		local_icri.version = ICRI_VERSION_1;
      124 		local_icri.timeout = 15;		/* ... doesn't really have to get through */
      125 		local_icri.record_ptr = null ();	/* ... no associated data */
      126 		local_icri.record_lth, local_icri.record_max_lth = 0;
      127 		if static.input_driver then		/* ... be sure to issue proper type of control order */
      128 		     if ds_ptr -> driver_status.dev_in_iocbp ^= null () then
      129 			call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_reply_record",
      130 			     addr (local_icri), ignore_code);
      131 		     else ;			/* ... no connection to the remote system yet */
      132 		else if ds_ptr -> driver_status.dev_out_iocbp ^= null () then do;
      133 		     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "write_command_record",
      134 			addr (local_icri), ignore_code);
      135 		     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "runout", null (), ignore_code);
      136 		end;				/* ... make sure the record gets through before the hangup */
      137 	     end;
      138 	     iodd_static.test_entry = saved_test_entry;
      139 	     if (major_args_ptr ^= null ())
      140 		& (major_args_ptr
      141 		^= add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1)) then
      142 		call terminate_file_ (major_args_ptr, 0, TERM_FILE_TERM, ignore_code);
      143 	     call drop_device ();
      144 	end;
      145 
      146 	on condition (daemon_slave_logout) go to LOGOUT_SLAVE;
      147 
      148 	on condition (cleanup)
      149 	     begin;
      150 	     iodd_static.test_entry = saved_test_entry;
      151 	     if (major_args_ptr ^= null ())
      152 		& (major_args_ptr
      153 		^= add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1)) then
      154 		call terminate_file_ (major_args_ptr, 0, TERM_FILE_TERM, ignore_code);
      155 	     call detach_device ();
      156 	     call free_aim_attributes_storage;
      157 	     iodd_static.attach_name = "*";
      158 	end;
      159 
      160 	on condition (imft_remote_logout_)
      161 	     begin;
      162 	     send_logout_record = "0"b;		/* they told us so we shouldn't tell them ... */
      163 	     call iodd_msg_ (NORMAL, MASTER, 0, IMFT_DRIVER_,
      164 		"^a's ^[output^;input^] driver disconnected; local driver will ^[wait for reconnection^;logout^].",
      165 		static.foreign_system.name, static.input_driver, static.automatic_operation);
      166 	     if static.automatic_operation then do;
      167 		if static.dial_service then do;
      168 		     call drop_device;
      169 		     call attach_and_init_line;	/* restablish link */
      170 		end;
      171 		go to RESYNCHRONIZE_DRIVER;
      172 	     end;
      173 	     else signal condition (daemon_logout);	/* ... will never return (we hope) */
      174 	end;
      175 
      176 	on condition (imft_resynchronize_driver_)
      177 	     begin;
      178 	     call iodd_msg_ (LOG, MASTER, 0, "", "^a requested resynchronization.", static.foreign_system.name);
      179 	     if static.input_driver then do;		/* must get the SYNC1 command retransmitted */
      180 		local_icri.version = ICRI_VERSION_1;
      181 		local_icri.timeout = 15;		/* don't have to wait for this to finish */
      182 		local_icri.record_type = IMFT_RESYNCHRONIZE;
      183 		local_icri.record_ptr = null ();
      184 		local_icri.record_lth, local_icri.record_max_lth = 0;
      185 		if ds_ptr -> driver_status.dev_in_iocbp ^= null () then
      186 		     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_reply_record", addr (local_icri),
      187 			code);
      188 	     end;
      189 	     go to RESYNCHRONIZE_DRIVER;
      190 	end;
      191 
      192 	on condition (imft_debug_)
      193 	     begin;				/* lets a programmer see what's wrong */
      194 	     call iodd_msg_ (NORMAL, MASTER, 0, IMFT_DRIVER_,
      195 		"Driver detected a condition which requires programmer intervention.");
      196 	     call iodd_quit_handler_$command_level ();
      197 	end;
      198 
      199 	on condition (re_init)
      200 	     begin;				/* driver is reinitializing */
      201 	     if static.input_driver then do;		/* make the output driver aware that we're restarting */
      202 		local_icri.version = ICRI_VERSION_1;
      203 		local_icri.timeout = 15;		/* don't have to wait for this to finish */
      204 		local_icri.record_type = IMFT_RESYNCHRONIZE;
      205 		local_icri.record_ptr = null ();
      206 		local_icri.record_lth, local_icri.record_max_lth = 0;
      207 		if ds_ptr -> driver_status.dev_in_iocbp ^= null () then
      208 		     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_reply_record", addr (local_icri),
      209 			code);
      210 	     end;
      211 	     call continue_to_signal_ (ignore_code);	/* let iodd_ start us over */
      212 	end;
      213 
      214 
      215 /* Parse the args statement which defines what this driver will be doing and how to get to the remote system */
      216 
      217 	major_args_ptr = add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1);
      218 						/* use args statement value by default */
      219 	major_args_lth = iodd_static.major_args.total_chars;
      220 
      221 	if major_args_lth = 0 then do;
      222 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "The IMFT driver requires an ""args:"" statement.");
      223 	     go to RETURN_FROM_INIT;
      224 	end;
      225 
      226 	major_args_path = iodd_parse_$args ("indirect=", major_args);
      227 						/* check for the arguments being in a file */
      228 	if major_args_path ^= "" then do;
      229 	     call expand_pathname_$component (major_args_path, major_args_dirname, major_args_ename,
      230 		major_args_component, code);
      231 	     if code ^= 0 then do;
      232 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "^a", major_args_path);
      233 		go to RETURN_FROM_INIT;
      234 	     end;
      235 	     call initiate_file_$component (major_args_dirname, major_args_ename, major_args_component, R_ACCESS,
      236 		major_args_ptr, major_args_bc, code);
      237 	     if code ^= 0 then do;
      238 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "^a",
      239 		     pathname_$component (major_args_dirname, major_args_ename, major_args_component));
      240 		go to RETURN_FROM_INIT;
      241 	     end;
      242 	     major_args_lth = divide ((major_args_bc + 8), 9, 21, 0);
      243 	     major_args_lth = length (rtrim (major_args, WHITESPACE));
      244 	     if major_args_lth = 0 then do;
      245 		call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "Arguments file ^a is empty.",
      246 		     pathname_$component (major_args_dirname, major_args_ename, major_args_component));
      247 		go to RETURN_FROM_INIT;
      248 	     end;
      249 	end;
      250 
      251 	keyword_value = iodd_parse_$args ("function=", major_args);
      252 	if (keyword_value = "") | (keyword_value = "file_transfer") then
      253 	     static.function = FILE_TRANSFER;
      254 	else do;
      255 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "Unsupported function.  ""^a""", keyword_value);
      256 	     go to RETURN_FROM_INIT;
      257 	end;
      258 
      259 	keyword_value = iodd_parse_$args ("direction=", major_args);
      260 	if keyword_value = "" then do;		/* this is required */
      261 	     call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_, "Direction must be supplied.");
      262 	     go to RETURN_FROM_INIT;
      263 	end;
      264 	else if keyword_value = "input" then static.input_driver = "1"b;
      265 	else if keyword_value = "output" then static.input_driver = "0"b;
      266 	else do;
      267 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "Unsupported direction.  ""^a""", keyword_value);
      268 	     go to RETURN_FROM_INIT;
      269 	end;
      270 
      271 	static.validate_system_id = "1"b;
      272 	keyword_value = iodd_parse_$args ("validate_system_id=", major_args);
      273 	if keyword_value ^= "" then static.validate_system_id = yes_no_p ("validate_system_id", keyword_value);
      274 
      275 	static.local_system.name = iodd_parse_$args ("local_system=", major_args);
      276 
      277 	if static.validate_system_id = "0"b then
      278 	     static.local_system.password = "";
      279 	else do;
      280 	     if static.local_system.name ^= "" then do;
      281 		call imft_pnt_interface_$get_system_password (static.local_system.name, static.local_system.password,
      282 		     code);
      283 		if code ^= 0 then do;
      284 		     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "local_system= ^a", static.local_system.name);
      285 		     go to RETURN_FROM_INIT;
      286 		end;
      287 	     end;
      288 	     else do;
      289 		call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_,
      290 		     "Local system name must be supplied.");
      291 		go to RETURN_FROM_INIT;
      292 	     end;
      293 	end;
      294 
      295 	static.foreign_system.name = iodd_parse_$args ("foreign_system=", major_args);
      296 
      297 	if static.validate_system_id = "0"b then
      298 	     static.foreign_system.password = "";
      299 	else do;
      300 	     if static.foreign_system.name ^= "" then do;
      301 		call imft_pnt_interface_$get_system_password (static.foreign_system.name,
      302 		     static.foreign_system.password, code);
      303 		if code ^= 0 then do;
      304 		     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "foreign_system= ^a",
      305 			static.foreign_system.name);
      306 		     go to RETURN_FROM_INIT;
      307 		end;
      308 	     end;
      309 	     else do;
      310 		call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_,
      311 		     "Foreign system name must be supplied.");
      312 		go to RETURN_FROM_INIT;
      313 	     end;
      314 	end;
      315 
      316 	keyword_value = iodd_parse_$args ("version=", major_args);
      317 	if keyword_value = "" | keyword_value = CURRENT_IMFT_VERSION then do;
      318 	     static.old_version = "0"b;
      319 	     static.foreign_system.imft_version = CURRENT_IMFT_VERSION;
      320 	end;
      321 	else if keyword_value = "3.0" then do;
      322 	     static.old_version = "0"b;
      323 	     static.foreign_system.imft_version = "3.0";
      324 	end;
      325 	else if keyword_value = "2.0" then do;
      326 	     static.old_version = "1"b;
      327 	     static.foreign_system.imft_version = "2.0";
      328 	end;
      329 	else do;
      330 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "Invalid version keyword: ""^a""", keyword_value);
      331 	     go to RETURN_FROM_INIT;
      332 	end;
      333 
      334 	if static.old_version then
      335 	     static.local_system.imft_version = "2.0";
      336 	else static.local_system.imft_version = CURRENT_IMFT_VERSION;
      337 
      338 	foreign_system_version = convert (foreign_system_version, static.foreign_system.imft_version);
      339 
      340 /* Determine if this is an in_dial connection, and out_dial connection, or
      341*   a normal IO connection. */
      342 
      343 	static.in_dial_qualifier, static.out_dial_text = "";
      344 	static.idle_line_drop = "0"b;
      345 
      346 	static.in_dial_qualifier = iodd_parse_$args ("in_dial=", major_args);
      347 	if static.in_dial_qualifier ^= "" then do;
      348 	     static.single_switch = "1"b;		/* stop errors */
      349 	     static.dial_service = "1"b;
      350 	end;
      351 	else do;
      352 	     static.out_dial_text = iodd_parse_$args ("out_dial=", major_args);
      353 	     if static.out_dial_text ^= "" then do;
      354 
      355 /* We must dial-out to the distant system, then recognize a connection
      356*   protocol to the dial-in channel when we get there.
      357*
      358*   First form the dial-out io description as for a normal dial-out */
      359 
      360 		static.dial_service = "1"b;
      361 		static.input_attach_description = iodd_parse_$args ("io_description=", major_args);
      362 		if static.input_attach_description = "" then
      363 		     static.input_attach_description = iodd_parse_$args ("iods=", major_args);
      364 		static.single_switch = (static.input_attach_description ^= "");
      365 		static.trigger_text = iodd_parse_$args ("trigger_text=", major_args);
      366 		if static.trigger_text = "" then do;
      367 		     call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_,
      368 			"The trigger_text string must be non-null.");
      369 		     go to RETURN_FROM_INIT;
      370 		end;
      371 	     end;
      372 	end;
      373 
      374 /* Capture dial protocol control information. */
      375 
      376 	if static.dial_service then do;
      377 	     keyword_value = iodd_parse_$args ("debug_connect=", major_args);
      378 	     if keyword_value = "" then
      379 		static.debug_connect = "0"b;
      380 	     else static.debug_connect = yes_no_p ("debug_connect", keyword_value);
      381 
      382 	     keyword_value = iodd_parse_$args ("idle_line_drop=", major_args);
      383 	     if keyword_value ^= "" then do;
      384 		if static.input_driver then do;
      385 		     call iodd_msg_ (ERROR, MASTER, error_table_$inconsistent, IMFT_DRIVER_,
      386 			"idle_line_drop keyword is not valid for an input driver.");
      387 		     go to RETURN_FROM_INIT;
      388 		end;
      389 		static.idle_line_drop = yes_no_p ("idle_line_drop", keyword_value);
      390 
      391 		keyword_value = iodd_parse_$args ("idle_delay_count=", major_args);
      392 		if keyword_value = "" then
      393 		     static.idle_delay_count = 2;	/* wait 2 idles */
      394 		else do;
      395 		     static.idle_delay_count = cv_dec_check_ (keyword_value, code);
      396 		     if code ^= 0 | static.idle_delay_count < 0 | static.idle_delay_count > 1000 then do;
      397 			call iodd_msg_ (ERROR, MASTER, error_table_$bad_conversion, "",
      398 			     "Value of idle_delay_count must be a number between 0 and 1000; not ""^a""",
      399 			     keyword_value);
      400 			go to RETURN_FROM_INIT;
      401 		     end;
      402 		end;
      403 		static.idle_delay = 0;
      404 	     end;
      405 
      406 	     keyword_value = iodd_parse_$args ("sleep_time=", major_args);
      407 	     if keyword_value = "" then
      408 		static.sleep_time = 5;		/* minutes */
      409 	     else do;
      410 		static.sleep_time = cv_dec_check_ (keyword_value, code);
      411 
      412 		if code ^= 0 | static.sleep_time < 1 | static.sleep_time > 60 then do;
      413 		     call iodd_msg_ (ERROR, MASTER, error_table_$bad_conversion, "",
      414 			"Value of sleep_time must be between 1 and 60 minutes; not ""^a""", keyword_value);
      415 		     go to RETURN_FROM_INIT;
      416 		end;
      417 	     end;
      418 	end;
      419 
      420 /* Normal connection by just doing the attachment to slave lines. */
      421 
      422 	else do;
      423 	     static.input_attach_description = iodd_parse_$args ("io_description=", major_args);
      424 	     if static.input_attach_description = "" then
      425 		static.input_attach_description = iodd_parse_$args ("iods=", major_args);
      426 	     static.single_switch = (static.input_attach_description ^= "");
      427 	end;
      428 
      429 	if ^static.single_switch then do;
      430 	     static.input_attach_description = iodd_parse_$args ("input_description=", major_args);
      431 	     if static.input_attach_description = "" then
      432 		static.input_attach_description = iodd_parse_$args ("ids=", major_args);
      433 	     if static.input_attach_description = "" then do;
      434 
      435 		call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_, "Input attach description.");
      436 		go to RETURN_FROM_INIT;
      437 	     end;
      438 
      439 	     static.output_attach_description = iodd_parse_$args ("output_description=", major_args);
      440 	     if static.output_attach_description = "" then
      441 		static.output_attach_description = iodd_parse_$args ("ods=", major_args);
      442 	     if static.output_attach_description = "" then do;
      443 		call iodd_msg_ (ERROR, MASTER, error_table_$noarg, IMFT_DRIVER_, "Output attach description.");
      444 		go to RETURN_FROM_INIT;
      445 	     end;
      446 	end;
      447 
      448 	else do;
      449 	     if static.old_version then do;		/* can't use -io_description in pre10.2 connection" */
      450 		call iodd_msg_ (ERROR, MASTER, error_table_$inconsistent, IMFT_DRIVER_,
      451 		     "version=2.0 and io_description");
      452 		go to RETURN_FROM_INIT;
      453 	     end;
      454 
      455 	     temp_attach_description = iodd_parse_$args ("input_description=", major_args);
      456 	     if temp_attach_description = "" then temp_attach_description = iodd_parse_$args ("ids=", major_args);
      457 	     if temp_attach_description ^= "" then do;
      458 		call iodd_msg_ (ERROR, MASTER, error_table_$inconsistent, IMFT_DRIVER_,
      459 		     "input_description and io_description");
      460 		go to RETURN_FROM_INIT;
      461 	     end;
      462 	     temp_attach_description = iodd_parse_$args ("output_description=", major_args);
      463 	     if temp_attach_description = "" then temp_attach_description = iodd_parse_$args ("ods=", major_args);
      464 	     if temp_attach_description ^= "" then do;
      465 		call iodd_msg_ (ERROR, MASTER, error_table_$inconsistent, IMFT_DRIVER_,
      466 		     "output_description and io_description");
      467 		go to RETURN_FROM_INIT;
      468 	     end;
      469 	end;
      470 
      471 	local_explicit_ceiling_given = "0"b;		/* use ceiling the two systems agree upon */
      472 	max_access_class_string = iodd_parse_$args ("max_access_class=", major_args);
      473 	if max_access_class_string ^= "" then do;	/* explicit ceiling for data transfer */
      474 	     local_explicit_ceiling_given = "1"b;
      475 	     call convert_authorization_$from_string (local_explicit_ceiling, max_access_class_string, code);
      476 	     if code ^= 0 then do;
      477 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "^a", max_access_class_string);
      478 		go to RETURN_FROM_INIT;
      479 	     end;
      480 	end;
      481 
      482 	if ^static.old_version then do;
      483 	     local_explicit_floor_given = "0"b;		/* use floor the two systems agree upon */
      484 	     min_access_class_string = iodd_parse_$args ("min_access_class=", major_args);
      485 	     if min_access_class_string ^= "" then do;	/* explicit floor for data transfer */
      486 		local_explicit_floor_given = "1"b;
      487 		call convert_authorization_$from_string (local_explicit_floor, min_access_class_string, code);
      488 		if code ^= 0 then do;
      489 		     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "^a", min_access_class_string);
      490 		     go to RETURN_FROM_INIT;
      491 		end;
      492 	     end;
      493 
      494 	     if local_explicit_ceiling_given & local_explicit_floor_given then
      495 		if ^aim_check_$greater_or_equal (local_explicit_ceiling, local_explicit_floor) then do;
      496 		     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      497 			"max_access_class (""^a"") is not greater than or equal to min_access_class (""^a"")",
      498 			max_access_class_string, min_access_class_string);
      499 		     go to RETURN_FROM_INIT;
      500 		end;
      501 	end;
      502 
      503 	keyword_value = iodd_parse_$args ("mode=", major_args);
      504 	if (keyword_value = "") | (keyword_value = "manual") then do;
      505 	     static.automatic_operation = "0"b;		/* manual mode: operator intervention required */
      506 	     static.auto_receive, static.auto_go = "0"b;	/* whichever is appropriate defaults to no */
      507 	end;
      508 	else if (keyword_value = "automatic") | (keyword_value = "auto") then do;
      509 	     static.automatic_operation = "1"b;		/* automatic mode: keep running without intervention */
      510 	     static.auto_receive, static.auto_go = "1"b;	/* whichever is appropriate defaults to yes */
      511 	end;
      512 	else do;
      513 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "Unsupported operational mode.  ""^a""", keyword_value);
      514 	     go to RETURN_FROM_INIT;
      515 	end;
      516 
      517 	keyword_value = iodd_parse_$args ("allow_remote_request=", major_args);
      518 	if keyword_value ^= "" then do;
      519 	     if ^static.input_driver then do;
      520 		call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      521 		     "The ""allow_remote_request"" keyword may not be specified for an output driver.");
      522 		go to RETURN_FROM_INIT;
      523 	     end;
      524 
      525 	     if yes_no_p ("allow_remote_request", keyword_value) then do;
      526 						/* said we could accept remote requests */
      527 		if static.old_version		/* not with an old other end, we can't */
      528 		then do;
      529 		     call iodd_msg_ (ERROR, MASTER, error_table_$inconsistent, IMFT_DRIVER_,
      530 			"Remote requests cannot be allowed if version=2.0.");
      531 		     go to RETURN_FROM_INIT;
      532 		end;
      533 
      534 		static.remote_request_allowed = "1"b;
      535 
      536 		keyword_value = iodd_parse_$args ("explicit_access=", major_args);
      537 		if keyword_value = ""		/* this one defaults to "yes" */
      538 		     then
      539 		     static.explicit_access_required = "1"b;
      540 		else static.explicit_access_required = yes_no_p ("explicit_access", keyword_value);
      541 	     end;
      542 
      543 	     else static.remote_request_allowed = "0"b;
      544 	end;
      545 
      546 	else static.remote_request_allowed = "0"b;
      547 
      548 	keyword_value = iodd_parse_$args ("auto_receive=", major_args);
      549 	if keyword_value ^= "" then
      550 	     if static.input_driver then		/* only valid for input drivers */
      551 		static.auto_receive = yes_no_p ("auto_receive", keyword_value);
      552 	     else do;
      553 		call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      554 		     "The ""auto_receive"" keyword may not be specified for an output driver.");
      555 		go to RETURN_FROM_INIT;
      556 	     end;
      557 
      558 	keyword_value = iodd_parse_$args ("auto_go=", major_args);
      559 	if keyword_value ^= "" then
      560 	     if ^static.input_driver then		/* only valid for output drivers */
      561 		static.auto_go = yes_no_p ("auto_go", keyword_value);
      562 	     else do;
      563 		call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      564 		     "The ""auto_go"" keyword may not be specified for an input driver.");
      565 		go to RETURN_FROM_INIT;
      566 	     end;
      567 
      568 	keyword_value = iodd_parse_$args ("min_time_est_msg=", major_args);
      569 	if keyword_value = "" then
      570 	     static.min_time_to_log = 60;		/* seconds */
      571 	else do;
      572 	     static.min_time_to_log = cv_dec_check_ (keyword_value, code);
      573 
      574 	     if code ^= 0 | static.min_time_to_log < 30 | static.min_time_to_log > 3600 then do;
      575 		call iodd_msg_ (ERROR, MASTER, error_table_$bad_conversion, IMFT_DRIVER_,
      576 		     "Value of min_time_est_msg must be a number between 30 and 3600 seconds, not ""^a""",
      577 		     keyword_value);
      578 		go to RETURN_FROM_INIT;
      579 	     end;
      580 	end;
      581 
      582 	static.debug_mode, static.copy_data = "0"b;	/* defaults to not debugging, of course */
      583 	if iodd_static.test_entry then do;		/* recognize debug_mode when running in test mode */
      584 	     keyword_value = iodd_parse_$args ("debug_mode=", major_args);
      585 	     if keyword_value ^= "" then static.debug_mode = yes_no_p ("debug_mode", keyword_value);
      586 
      587 	     keyword_value = iodd_parse_$args ("copy_data=", major_args);
      588 	     if keyword_value ^= "" then static.copy_data = yes_no_p ("copy_data", keyword_value);
      589 
      590 	end;
      591 
      592 	iodd_static.test_entry = static.debug_mode;	/* if not in debug_mode, disable all debugging facilities
      593*						   and allow the driver to run a "real" service */
      594 
      595 /* Function specific args statement processing goes here */
      596 
      597 	on condition (linkage_error)
      598 	     begin;
      599 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      600 		"Driver process lacks access to the system_privilege_ gate.");
      601 	     go to RETURN_FROM_INIT;
      602 	end;
      603 
      604 	test_initiate_entry = system_privilege_$initiate; /* check that we can get appropriate privileges */
      605 
      606 	revert condition (linkage_error);
      607 
      608 	call attach_and_init_line;
      609 
      610 	if ^static.input_driver then on condition (daemon_idle) call check_for_resync_request ();
      611 
      612 /* Synchronize operations with the remote system: control will also arrive
      613*   here whenever the remote system requests explicit resynchronization */
      614 
      615 RESYNCHRONIZE_DRIVER:				/* Ensure that we are properly attached. */
      616 	if ds_ptr -> driver_status.dev_in_iocbp = null () then call attach_and_init_line;
      617 
      618 	iodd_static.master_hold = "1"b;		/* wait for commands from the master console by default */
      619 	iodd_static.slave_hold = "0"b;		/* actually, there is no slave terminal, but ... */
      620 
      621 	call resynch_and_validate;
      622 
      623 	if static.input_driver then			/* input device ... */
      624 	     if static.auto_receive then do;		/* ... start receiving immediately */
      625 		on condition (quit) call iodd_quit_handler_ ();
      626 		on condition (resume) go to PREPARE_TO_CALL_IODD_LISTEN_;
      627 		call iodd_msg_ (NORMAL, MASTER, 0, "", "Waiting for ^[files/subtrees^] from ^a.", static.function,
      628 		     static.foreign_system.name);
      629 		if static.function = FILE_TRANSFER then
      630 		     call imft_receive_object_ (addr (static), addr (static_fis_info), code);
      631 		if code ^= 0 then do;		/* error has already been reported */
      632 		     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      633 			"Fatal error during ""receive"" command; driver will re-initialize.");
      634 		     call detach_device ();		/* just in case */
      635 		     signal condition (re_init);
      636 		end;
      637 PREPARE_TO_CALL_IODD_LISTEN_:				/* release command from a quit will arrive here */
      638 		revert condition (quit), condition (resume);
      639 	     end;
      640 	     else ;				/* go directly to the command loop */
      641 
      642 	else do;					/* output device ... */
      643 	     if static.auto_go then do;		/* ... start processing immediately if requested */
      644 		do i = 1 to iodd_static.assigned_devices;
      645 		     devp = driver_ptr_list.stat_segp (i);
      646 		     call iodd_command_processor_ (MASTER, LISTEN_COMMAND_LEVEL,
      647 			"restart_q " || devp -> driver_status.device_id, ignore_code);
      648 		end;
      649 		iodd_static.master_hold = "0"b;
      650 	     end;
      651 	end;
      652 
      653 	call iodd_listen_ (stat_p);			/* start the driver operating */
      654 
      655 
      656 /* Control arrives here iff initialization fails */
      657 
      658 RETURN_FROM_INIT:
      659 	iodd_static.test_entry = saved_test_entry;
      660 	if (major_args_ptr ^= null ())
      661 	     & (major_args_ptr ^= add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1))
      662 	     then
      663 	     call terminate_file_ (major_args_ptr, 0, TERM_FILE_TERM, ignore_code);
      664 	call drop_device ();
      665 	call free_aim_attributes_storage;
      666 	return;
      667 
      668 
      669 /* Control arrives here if a logout is received from the slave (this won't happen, but...) */
      670 
      671 LOGOUT_SLAVE:
      672 	iodd_static.re_init_in_progress = "1"b;		/* re-initialize the driver */
      673 	iodd_static.slave.log_msg = "1"b;		/* send to log and slave */
      674 	call iodd_msg_ (LOG, BOTH, 0, "", "Logout for ^a ^a ^[input^;output^] driver at ^a.",
      675 	     static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver,
      676 	     date_time_$format ("date_time", clock (), "", ""));
      677 	call iox_$control (iodd_static.slave_out, "runout", null (), ignore_code);
      678 	call drop_device ();
      679 	call iodd_msg_ (NORMAL, MASTER, 0, "", "Driver starting re-initialization...");
      680 	go to iodd_static.re_init_label;		/* this will do everything */
      681 
      682 /* Entry to attach the line and initialize driver_status information. */
      683 
      684 attach_and_init_line:
      685      proc;
      686 	if static.input_driver then do;
      687 
      688 /* An input driver: requests are not processed from the coordinator; this driver is controlled by the remote system's
      689*   output driver */
      690 
      691 	     if iodd_static.assigned_devices > 1 then do; /* only one device per input driver */
      692 		call iodd_msg_ (ERROR, MASTER, error_table_$fatal_error, IMFT_DRIVER_,
      693 		     "The IMFT driver only supports one minor device for an input driver.");
      694 		return;
      695 	     end;
      696 
      697 	     call validate_request_type (ds_ptr);
      698 	     ds_ptr -> driver_status.attached = "0"b;	/* do not accept anything from coordinator */
      699 
      700 	     call iodd_msg_ (NORMAL, MASTER, 0, "", "^/Initializing ^a ^a input driver...", static.foreign_system.name,
      701 		FUNCTION_NAMES (static.function));
      702 
      703 	     call attach_line ();
      704 
      705 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "read_status", addr (trsi), code);
      706 	     if code ^= 0 then do;
      707 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Can not determine when input is available.");
      708 		go to RETURN_FROM_INIT;
      709 	     end;
      710 
      711 	     static_fis_info.version = FIS_INFO_VERSION_1;
      712 	     static_fis_info.n_iocbs, static_fis_info.n_channels = 2;
      713 	     static_fis_info.iocbs (1) = iodd_static.master_in;
      714 	     static_fis_info.event_channels (1) = iodd_static.chan_list_ptr -> event_channel_list.channels (1);
      715 	     static_fis_info.iocbs (2) = ds_ptr -> driver_status.dev_in_iocbp;
      716 	     static_fis_info.event_channels (2) = trsi.event_channel;
      717 	end;
      718 
      719 
      720 	else do;
      721 
      722 /* Transmitting to foreign Multics system: process requests from the coordinator */
      723 
      724 	     list_ptr = iodd_static.driver_list_ptr;
      725 	     do i = 1 to iodd_static.assigned_devices;	/* check request types for minor device(s) */
      726 						/* doesn't return if an error occurs */
      727 		call validate_request_type (driver_ptr_list.stat_segp (i));
      728 	     end;
      729 
      730 	     call iodd_msg_ (NORMAL, MASTER, 0, "", "^/Initializing ^a ^a output driver...", static.foreign_system.name,
      731 		FUNCTION_NAMES (static.function));
      732 
      733 	     if static.function = FILE_TRANSFER then do;	/* expect use of enter_imft_request */
      734 		ds_ptr -> driver_status.generic_type = FT_GENERIC_TYPE;
      735 		ds_ptr -> driver_status.message_type = FT_MESSAGE_TYPE;
      736 	     end;
      737 
      738 	     if ds_ptr -> driver_status.rqti_ptr ^= null () then
      739 		call iodd_msg_ (NORMAL, MASTER, 0, IMFT_DRIVER_, "This driver cannot decode an RQTI segment.");
      740 
      741 	     call attach_line ();
      742 
      743 	     ds_ptr -> driver_status.attached = "1"b;
      744 
      745 	     ds_ptr -> driver_status.elem_size = 9;
      746 
      747 	     ds_ptr -> driver_status.ready = "1"b;	/* mark as ready to save an operator command */
      748 
      749 	     local_terminal_info.version = terminal_info_version;
      750 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "terminal_info", addr (local_terminal_info),
      751 		code);
      752 	     if code = 0 then
      753 		ds_ptr -> driver_status.bit_rate_est = divide (local_terminal_info.baud_rate * 2, 3, 35, 0);
      754 	     else ds_ptr -> driver_status.bit_rate_est = INITIAL_IMFT_RATE;
      755 
      756 	     if iodd_static.assigned_devices = 2 then do; /* copy necessary stuff to second minor device's */
      757 		devp = driver_ptr_list.stat_segp (2);	/* status structure */
      758 		devp -> driver_status.attached = "1"b;
      759 		devp -> driver_status.ready = "1"b;
      760 		devp -> driver_status.dev_out_iocbp = ds_ptr -> driver_status.dev_out_iocbp;
      761 		devp -> driver_status.dev_in_iocbp = ds_ptr -> driver_status.dev_in_iocbp;
      762 		devp -> driver_status.dev_out_stream = ds_ptr -> driver_status.dev_out_stream;
      763 		devp -> driver_status.dev_in_stream = ds_ptr -> driver_status.dev_in_stream;
      764 		devp -> driver_status.elem_size = ds_ptr -> driver_status.elem_size;
      765 		devp -> driver_status.message_type = ds_ptr -> driver_status.message_type;
      766 		devp -> driver_status.bit_rate_est = ds_ptr -> driver_status.bit_rate_est;
      767 		devp -> driver_status.generic_type = ds_ptr -> driver_status.generic_type;
      768 		devp -> driver_status.dev_ctl_ptr = null ();
      769 		devp -> driver_status.defer_time_limit = 0;
      770 	     end;
      771 	end;
      772      end attach_and_init_line;
      773 
      774 /* Procedure to validate the IMFT synchronization and aim levels. */
      775 
      776 resynch_and_validate:
      777      proc;
      778 	if static.input_driver then do;		/* the actual code is fairly complex ... */
      779 	     call synchronize_input_driver ();
      780 	     call establish_input_access_ceiling ();
      781 	end;
      782 
      783 	else do;					/* ... so it's not shown here */
      784 	     call synchronize_output_driver ();
      785 	     call establish_output_access_ceiling ();
      786 	end;
      787 
      788 
      789 /* Synchronization completed: start things running ... */
      790 
      791 	call convert_authorization_$to_string_short (static.local_system.access_ceiling, max_access_class_string, code);
      792 	if code ^= 0 then do;			/* can't convert it: use octal representation */
      793 	     call convert_aim_attributes_ (static.local_system.access_ceiling, max_access_class_octal);
      794 	     max_access_class_string = max_access_class_octal;
      795 	end;
      796 
      797 	if ^static.old_version then do;
      798 	     call convert_authorization_$to_string_short (static.local_system.access_floor, min_access_class_string,
      799 		code);
      800 	     if code ^= 0 then do;			/* can't convert it: use octal representation */
      801 		call convert_aim_attributes_ (static.local_system.access_floor, min_access_class_octal);
      802 		min_access_class_string = min_access_class_octal;
      803 	     end;
      804 	end;
      805 	else min_access_class_string = "";
      806 
      807 	call iodd_msg_ (NORMAL, MASTER, 0, "",
      808 	     "^a ^a ^[input^;output^] driver (version ^a) ready at ^a^/^[^3xusing channel ^a for input^[/^s^;, channel ^a for ^]output, and^/^3x^;^s^s^s^3xusing ^]^[^a^;^ssystem_low^]:^[^a^;^ssystem_low^] as the allowable range of access classes for data transfer.",
      809 	     static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver,
      810 	     static.local_system.imft_version, date_time_$format ("date_time", clock (), "", ""), have_channel_names,
      811 	     local_gcn.input_channel, static.single_switch, local_gcn.output_channel, (min_access_class_string ^= ""),
      812 	     min_access_class_string, (max_access_class_string ^= ""), max_access_class_string);
      813      end resynch_and_validate;
      814 
      815 /* Process request:  Invoked by iodd_listen_ when a request has been received
      816*   from the coordinator for transmission to the remote system.  Validate the
      817*   request format and then pass it off to the appropriate module */
      818 
      819 request:
      820      entry ();
      821 
      822 dcl  driver_ptr ptr static;
      823 
      824 	driver_ptr = iodd_static.driver_ptr;
      825 	if driver_ptr -> driver_status.dev_out_iocbp = null () then do;
      826 	     call iodd_msg_ (NORMAL, MASTER, 0, "", "Driver waking up to start re-initialization...");
      827 	     call attach_and_init_line;		/* restablish link */
      828 	     call resynch_and_validate;
      829 	end;
      830 
      831 	static.idle_delay = 0;			/* reset counter */
      832 	rd_ptr = addr (driver_ptr -> driver_status.descriptor);
      833 						/* ... the request descriptor ... */
      834 
      835 	p = addr (driver_ptr -> driver_status.message);	/* ... and the request itself */
      836 
      837 	if p -> queue_msg_hdr.hdr_version ^= queue_msg_hdr_version_1 then do;
      838 	     call iodd_msg_ (LOG, MASTER, 0, "", "Invalid message header.  Cannot read request ^d (queue ^d).",
      839 		rd_ptr -> request_descriptor.seq_id, rd_ptr -> request_descriptor.q);
      840 	     rd_ptr -> request_descriptor.keep_in_queue = "1"b;
      841 	     rd_ptr -> request_descriptor.dont_delete = "1"b;
      842 	     rd_ptr -> request_descriptor.finished = "1"b;
      843 	     return;				/* leave in queue for possible upgrade later ... */
      844 	end;					/* ... and give it back to the coordinator */
      845 
      846 	if p -> queue_msg_hdr.message_type ^= driver_ptr -> driver_status.message_type then do;
      847 	     call iodd_msg_ (LOG, MASTER, 0, "",
      848 		"Incorrect message type.^/Request ^d (queue ^d) for ^a (entry ^a) not processed.",
      849 		rd_ptr -> request_descriptor.seq_id, rd_ptr -> request_descriptor.q,
      850 		rd_ptr -> request_descriptor.sender_id, p -> queue_msg_hdr.ename);
      851 	     rd_ptr -> request_descriptor.cancelled = "1"b;
      852 	     rd_ptr -> request_descriptor.dont_delete = "1"b;
      853 	     rd_ptr -> request_descriptor.finished = "1"b;
      854 	     return;				/* give up: it won't ever work ... */
      855 	end;					/* ... but don't get rid of the object */
      856 
      857 	if static.function = FILE_TRANSFER then
      858 	     if p -> ft_request.version ^= FT_REQUEST_VERSION_1 then do;
      859 		call iodd_msg_ (LOG, MASTER, 0, "",
      860 		     "Wrong message version found.^/Request ^d (queue ^d) for ^a (entry ^a) not processed.",
      861 		     rd_ptr -> request_descriptor.seq_id, rd_ptr -> request_descriptor.q,
      862 		     rd_ptr -> request_descriptor.sender_id, p -> queue_msg_hdr.ename);
      863 		rd_ptr -> request_descriptor.keep_in_queue = "1"b;
      864 		rd_ptr -> request_descriptor.dont_delete = "1"b;
      865 		rd_ptr -> request_descriptor.finished = "1"b;
      866 		return;				/* leave it around to be upgraded later */
      867 	     end;
      868 	     else ;				/* request is proper version */
      869 
      870 
      871 /* Format is OK: do the request */
      872 
      873 	iodd_static.quit_during_request = "0"b;
      874 
      875 	on condition (cleanup)
      876 	     call iox_$control (driver_ptr -> driver_status.dev_out_iocbp, "runout", null (), ignore_code);
      877 
      878 	if static.function = FILE_TRANSFER then
      879 	     call imft_transmit_object_ (driver_ptr -> driver_status.dev_out_iocbp, stat_p, addr (static), code);
      880 
      881 	if code ^= 0 then do;			/* error has already been reported */
      882 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      883 		"Fatal error during processing of the request; driver will re-initialize.");
      884 	     signal condition (re_init);
      885 	end;
      886 
      887 	call iox_$control (driver_ptr -> driver_status.dev_out_iocbp, "runout", null (), ignore_code);
      888 
      889 	if static_pause_time > 1 then call timer_manager_$sleep (static_pause_time, RELATIVE_SECONDS);
      890 
      891 	return;
      892 
      893 /* Process a driver command */
      894 
      895 command:
      896      entry (P_source, P_state, P_arglist_ptr, P_code);
      897 
      898 	source = P_source;
      899 	arglist_ptr = P_arglist_ptr;			/* structure containing command arguments */
      900 
      901 	saved_code = P_code;			/* save input code in case command is unknown */
      902 
      903 	P_code, code = 0;				/* claim to handle it */
      904 
      905 /* Process the command if recognized */
      906 
      907 	if (arglist.command = "help") then do;
      908 	     call iodd_msg_ (NORMAL, source, 0, "", "^/** Commands for the IMFT driver **^/");
      909 	     if static.input_driver then		/* an input driver */
      910 		call iodd_msg_ (NORMAL, source, 0, "", "receive");
      911 	     else do;
      912 		call iodd_msg_ (NORMAL, source, 0, "", "pause_time [<seconds_to_delay_between_requests>]");
      913 		call iodd_msg_ (NORMAL, source, 0, "", "line_speed");
      914 	     end;
      915 	end;
      916 
      917 	else if (arglist.command = "pause_time") | (arglist.command = "pausetime") then do;
      918 	     if static.input_driver then do;		/* only for output drivers */
      919 		call iodd_msg_ (NORMAL, source, 0, "", "Invalid command for an input driver.");
      920 		go to COMMAND_ERROR;
      921 	     end;
      922 	     if (arglist.n_tokens > 1) then do;		/* a specific time is given */
      923 		value = cv_dec_check_ ((arglist.arguments (1)), code);
      924 		if (code ^= 0) then do;
      925 BAD_PAUSE_TIME_SPECIFICATION:
      926 		     call iodd_msg_ (NORMAL, source, error_table_$bad_conversion, "",
      927 			"Pause time specification must be a number between 0 and 30 seconds; not ""^a"".",
      928 			arglist.arguments (1));
      929 		     go to COMMAND_ERROR;
      930 		end;
      931 		if (value < 0) | (value > 30) then go to BAD_PAUSE_TIME_SPECIFICATION;
      932 		static_pause_time = value;		/* good value */
      933 	     end;
      934 	     else static_pause_time = 10;		/* reset to default value */
      935 	end;
      936 
      937 	else if (arglist.command = "receive") then do;
      938 	     if ^static.input_driver then do;		/* only valid for input drivers */
      939 		call iodd_msg_ (NORMAL, source, 0, "", "Invalid command for an output driver.");
      940 		go to COMMAND_ERROR;
      941 	     end;
      942 
      943 /* Ensure that we are properly attached. */
      944 
      945 	     if ds_ptr -> driver_status.dev_in_iocbp = null () then do;
      946 		call attach_and_init_line;		/* restablish link */
      947 		call resynch_and_validate;
      948 	     end;
      949 
      950 	     call iodd_msg_ (NORMAL, MASTER, 0, "", "Waiting for ^[files/subtrees^] from ^a.", static.function,
      951 		static.foreign_system.name);
      952 	     if static.function = FILE_TRANSFER then
      953 		call imft_receive_object_ (addr (static), addr (static_fis_info), code);
      954 	     if code ^= 0 then do;			/* error has already been reported */
      955 		call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
      956 		     "Fatal error during ""receive"" command; driver will re-initialize.");
      957 		signal condition (re_init);
      958 	     end;
      959 	end;
      960 
      961 	else if (arglist.command = "line_speed") | (arglist.command = "linespeed") then do;
      962 	     if static.input_driver then do;		/* only for output drivers */
      963 		call iodd_msg_ (NORMAL, source, 0, "", "Invalid command for an input driver.");
      964 		go to COMMAND_ERROR;
      965 	     end;
      966 	     call iodd_msg_ (NORMAL, source, 0, "", "line_speed = ^i Baud.", ds_ptr -> driver_status.bit_rate_est);
      967 	end;
      968 
      969 	else code = saved_code;			/* unknown request: let caller handle it */
      970 
      971 	P_code = code;				/* pass back any defined errors */
      972 	return;
      973 
      974 COMMAND_ERROR:
      975 	P_code = error_table_$action_not_performed;	/* cause a resetread */
      976 	return;
      977 
      978 /* Handler for unexpected conditions during request processing */
      979 
      980 default_handler:
      981      entry (P_condition_info_ptr);
      982 
      983 	condition_info_ptr = P_condition_info_ptr;
      984 
      985 	condition = condition_info.condition_name;
      986 
      987 	if iodd_static.request_in_progress then		/* will abort the request */
      988 	     if static.function = FILE_TRANSFER then call imft_transmit_object_$abort_running_request (condition);
      989 
      990 	return;					/* should not get here */
      991 
      992 /* Synchronize an input driver: Wait for a SYNC1 command from the remote system.  When it arrives, validate the
      993*   ID/password in the command against the foreign ID/password specified locally.  If they match, send a SYNC1 reply
      994*   containing our ID/password to the remote system and wait for a SYNC2 command; otherwise, send a SYNC1 reply explaining
      995*   the problem and abort.  When the SYNC2 command arrives, send a SYNC2 reply if the command indicates that
      996*   synchronization suceeded; otherwise, abort */
      997 
      998 synchronize_input_driver:
      999      procedure ();
     1000 
     1001 	call read_sync_command (IMFT_SYNC1);
     1002 
     1003 	sync_record_ptr = addr (input_buffer);
     1004 	if static.foreign_system.name ^= sync_record.my_userid then do;
     1005 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_ids, IMFT_DRIVER_,
     1006 		"ID specified on local system is ^a; ID specified on remote system is ^a.",
     1007 		static.foreign_system.name, sync_record.my_userid);
     1008 	     call write_sync_reply (IMFT_SYNC1, "", "", imft_et_$non_matching_ids, static.foreign_system.name);
     1009 	     go to RETURN_FROM_INIT;
     1010 	end;
     1011 
     1012 	if static.foreign_system.password ^= sync_record.my_password then do;
     1013 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_passwords, IMFT_DRIVER_,
     1014 		"Validating foreign system ID.  ""^a""", sync_record.my_userid);
     1015 	     call write_sync_reply (IMFT_SYNC1, "", "", imft_et_$non_matching_passwords, "");
     1016 	     go to RETURN_FROM_INIT;
     1017 	end;
     1018 
     1019 	if local_icri.record_lth ^= 4 * currentsize (sync_record) then do;
     1020 						/* remote driver is pre 4.0 */
     1021 	     if foreign_system_version >= 4.0 then do;
     1022 		call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_versions, IMFT_DRIVER_,
     1023 		     "Remote system appears to be pre 4.0 but was specified to be ^a on local system.",
     1024 		     static.foreign_system.imft_version);
     1025 		call write_sync_reply (IMFT_SYNC1, "", "", imft_et_$non_matching_versions, "");
     1026 		go to RETURN_FROM_INIT;
     1027 	     end;
     1028 	end;
     1029 
     1030 	else if static.foreign_system.imft_version ^= sync_record.imft_version then do;
     1031 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_versions, IMFT_DRIVER_,
     1032 		"Remote system claims to be ""^a"" but specified locally to be ""^a"".", sync_record.imft_version,
     1033 		static.foreign_system.imft_version);
     1034 	     call write_sync_reply (IMFT_SYNC1, "", "", imft_et_$non_matching_versions, "");
     1035 	     go to RETURN_FROM_INIT;
     1036 	end;
     1037 
     1038 /* Here iff the ID/password in the SYNC1 command were acceptable */
     1039 
     1040 	call write_sync_reply (IMFT_SYNC1, static.local_system.name, static.local_system.password, 0, "");
     1041 
     1042 	call read_sync_command (IMFT_SYNC2);
     1043 
     1044 	sync_record_ptr = addr (input_buffer);
     1045 	if sync_record.code = 0 then			/* remote system accepted our ID/password */
     1046 	     call write_sync_reply (IMFT_SYNC2, "", "", 0, "");
     1047 
     1048 	else do;					/* remote output driver didn't like our ID/password */
     1049 	     code = imft_convert_status_code_$decode (sync_record.code);
     1050 	     if code = imft_et_$non_matching_ids then
     1051 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_,
     1052 		     "ID specified on local system is ^a; ID specified on remote system is ^a.",
     1053 		     static.local_system.name, sync_record.correct_userid);
     1054 	     else call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Validating local system ID.  ""^a""",
     1055 		     static.local_system.name);
     1056 	     go to RETURN_FROM_INIT;
     1057 	end;
     1058 
     1059 	return;					/* here iff synchronized OK */
     1060 
     1061 /* Internal to synchronize_input_driver: attempts to transmit a SYNC reply */
     1062 
     1063 write_sync_reply:
     1064 	procedure (p_sync_type, p_my_userid, p_my_password, p_code, p_correct_userid);
     1065 
     1066 dcl  p_sync_type fixed binary (7) unaligned unsigned parameter;
     1067 dcl  (p_my_userid, p_correct_userid) character (*) parameter;
     1068 dcl  p_my_password character (8) aligned parameter;
     1069 dcl  p_code fixed binary (35) parameter;
     1070 
     1071 dcl  code fixed binary (35);
     1072 
     1073 	     sync_record_ptr = addr (output_buffer);	/* need a place to put it */
     1074 	     sync_record.my_userid = p_my_userid;
     1075 	     sync_record.my_password = p_my_password;
     1076 	     sync_record.code = imft_convert_status_code_$encode (p_code);
     1077 	     sync_record.correct_userid = p_correct_userid;
     1078 	     sync_record.imft_version = CURRENT_IMFT_VERSION;
     1079 
     1080 	     local_icri.version = ICRI_VERSION_1;
     1081 	     local_icri.timeout = FIVE_MINUTES;		/* give the other side a chance to respond */
     1082 	     local_icri.record_type = p_sync_type;
     1083 	     local_icri.record_ptr = sync_record_ptr;
     1084 	     local_icri.record_lth = 4 * currentsize (sync_record);
     1085 
     1086 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_reply_record", addr (local_icri), code);
     1087 
     1088 	     if code ^= 0 then do;			/* any I/O errors are fatal */
     1089 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to synchronize with ^a.",
     1090 		     static.foreign_system.name);
     1091 		go to RETURN_FROM_INIT;
     1092 	     end;
     1093 
     1094 	     return;				/* success */
     1095 
     1096 	end write_sync_reply;
     1097 
     1098 
     1099 
     1100 /* Internal to synchronize_input_driver: attempts to read a SYNC command */
     1101 
     1102 read_sync_command:
     1103 	procedure (p_sync_type);
     1104 
     1105 dcl  p_sync_type fixed binary (7) unaligned unsigned parameter;
     1106 
     1107 	     local_icri.version = ICRI_VERSION_1;
     1108 	     if static.automatic_operation & (p_sync_type = IMFT_SYNC1) then
     1109 		local_icri.timeout = 0;		/* wait forever for start of synchronization sequence */
     1110 	     else local_icri.timeout = FIVE_MINUTES;
     1111 	     local_icri.record_ptr = addr (input_buffer);
     1112 	     local_icri.record_max_lth = length (input_buffer);
     1113 
     1114 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "read_command_record", addr (local_icri), code);
     1115 
     1116 	     if code = 0 then			/* got something ... */
     1117 		if local_icri.record_type = p_sync_type then
     1118 		     return;			/* ... got the right type of command */
     1119 
     1120 		else do;				/* ... anything else causes us to try over again */
     1121 		     call write_sync_reply (IMFT_RESYNCHRONIZE, "", "", 0, "");
     1122 		     go to RESYNCHRONIZE_DRIVER;
     1123 		end;
     1124 
     1125 	     else do;				/* some more serious error */
     1126 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to synchronize with ^a.",
     1127 		     static.foreign_system.name);
     1128 		go to RETURN_FROM_INIT;
     1129 	     end;
     1130 
     1131 	end read_sync_command;
     1132 
     1133      end synchronize_input_driver;
     1134 
     1135 /* Establish the AIM access class ceiling for an input driver: Wait for the AIM1 command giving the source system's AIM
     1136*   attributes definition and then transmit an AIM1 reply consisting of our attributes.  Wait for the AIM2 command which
     1137*   contains the source system's computed access ceiling and explicit ceiling (if any); verify that they match the local
     1138*   values and that the local explicit ceiling is less than or equal to the computed ceiling.  If all goes well, send an
     1139*   AIM2 reply with a zero code; otherwise, send a non-zero reply code and abort */
     1140 
     1141 establish_input_access_ceiling:
     1142      procedure ();
     1143 
     1144 dcl  1 local_aim2_record aligned like aim2_record;
     1145 
     1146 
     1147 	call read_aim_command (IMFT_AIM1);		/* aborts if we can't get it */
     1148 
     1149 	if addr (input_buffer) -> aim_attributes.version ^= AIM_ATTRIBUTES_VERSION_1 then do;
     1150 	     call iodd_msg_ (ERROR, MASTER, error_table_$unimplemented_version, IMFT_DRIVER_,
     1151 		"Can not understand AIM definition from ^a.", static.foreign_system.name);
     1152 	     go to RETURN_FROM_INIT;			/* ... other side will timeout */
     1153 	end;
     1154 
     1155 	call free_aim_attributes_storage;
     1156 
     1157 	allocate aim_attributes in (system_area) set (static.foreign_system.aim_attributes_ptr);
     1158 	static.foreign_system.aim_attributes_ptr -> aim_attributes = addr (input_buffer) -> aim_attributes;
     1159 
     1160 	call get_system_aim_attributes_ (get_system_free_area_ (), AIM_ATTRIBUTES_VERSION_1,
     1161 	     static.local_system.aim_attributes_ptr, code);
     1162 	if code ^= 0 then do;			/* shouldn't get this but... */
     1163 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to get local AIM definition.");
     1164 	     go to RETURN_FROM_INIT;			/* ... other side will timeout */
     1165 	end;
     1166 
     1167 	call write_aim_reply (IMFT_AIM1, static.local_system.aim_attributes_ptr,
     1168 	     (4 * currentsize (static.local_system.aim_attributes_ptr -> aim_attributes)));
     1169 
     1170 
     1171 /* Have exchanged AIM definitions: wait for AIM2 command and validate other system's computed ceiling and explicit ceiling
     1172*   against our own */
     1173 
     1174 	call read_aim_command (IMFT_AIM2);
     1175 
     1176 	if static.old_version then do;		/* we read old, shorter form of AIM2 record */
     1177 	     aim2_record_ptr = addr (local_aim2_record);
     1178 	     aim2_record = addr (input_buffer) -> v2_aim2_record, by name;
     1179 	end;
     1180 
     1181 	else aim2_record_ptr = addr (input_buffer);
     1182 
     1183 	if aim2_record.code ^= 0 then do;		/* remote system couldn't compute definition */
     1184 	     code = imft_convert_status_code_$decode (aim2_record.code);
     1185 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1186 		static.foreign_system.name);
     1187 	     go to RETURN_FROM_INIT;
     1188 	end;
     1189 
     1190 	call compute_common_aim_ceiling_ (static.local_system.aim_attributes_ptr, static.local_system.access_ceiling,
     1191 	     static.foreign_system.aim_attributes_ptr, static.foreign_system.access_ceiling, code);
     1192 	if code ^= 0 then do;
     1193 CANT_ESTABLISH_CEILING:
     1194 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1195 		static.foreign_system.name);
     1196 	     call write_aim2_reply (code);		/* let remote system know we lost */
     1197 	     go to RETURN_FROM_INIT;
     1198 	end;
     1199 
     1200 	if ^aim_check_$equal (aim2_record.computed_ceiling, static.foreign_system.access_ceiling) then do;
     1201 	     call iodd_msg_ (ERROR, MASTER, imft_et_$computed_ceiling_mismatch, IMFT_DRIVER_,
     1202 		"Attempting to establish access ceiling with ^a.", static.foreign_system.name);
     1203 	     call write_aim2_reply (imft_et_$computed_ceiling_mismatch);
     1204 	     go to RETURN_FROM_INIT;
     1205 	end;
     1206 
     1207 	if local_explicit_ceiling_given | aim2_record.explicit_ceiling_given then do;
     1208 	     if ^local_explicit_ceiling_given then local_explicit_ceiling = static.local_system.access_ceiling;
     1209 
     1210 	     if aim2_record.explicit_ceiling_given then do;
     1211 		call translate_aim_attributes_ (static.foreign_system.aim_attributes_ptr,
     1212 		     aim2_record.explicit_ceiling, static.local_system.aim_attributes_ptr, foreign_explicit_ceiling,
     1213 		     code);
     1214 		if code ^= 0 then go to CANT_ESTABLISH_CEILING;
     1215 	     end;
     1216 	     else foreign_explicit_ceiling = static.local_system.access_ceiling;
     1217 
     1218 	     if aim_check_$greater_or_equal (local_explicit_ceiling, foreign_explicit_ceiling)
     1219 						/* other side wants lower ceiling than we had specified */
     1220 		then
     1221 		static.local_system.access_ceiling = foreign_explicit_ceiling;
     1222 
     1223 	     else if aim_check_$greater (foreign_explicit_ceiling, local_explicit_ceiling) then do;
     1224 		static.local_system.access_ceiling = local_explicit_ceiling;
     1225 						/* our ceiling controls */
     1226 		call translate_aim_attributes_ (static.local_system.aim_attributes_ptr,
     1227 		     static.local_system.access_ceiling, static.foreign_system.aim_attributes_ptr,
     1228 		     static.foreign_system.access_ceiling, code);
     1229 						/* so we have to translate it for the other system */
     1230 		if code ^= 0 then go to CANT_ESTABLISH_CEILING;
     1231 	     end;
     1232 
     1233 	     else do;				/* neither one is >= the other, so they must be isolated */
     1234 		call iodd_msg_ (ERROR, MASTER, imft_et_$explicit_ceiling_mismatch, IMFT_DRIVER_,
     1235 		     "Attempting to establish access ceiling with ^a.", static.foreign_system.name);
     1236 		call write_aim2_reply (imft_et_$explicit_ceiling_mismatch);
     1237 		go to RETURN_FROM_INIT;
     1238 	     end;
     1239 	end;
     1240 
     1241 	if ^static.old_version then do;
     1242 	     if local_explicit_floor_given | aim2_record.explicit_floor_given then do;
     1243 		if ^local_explicit_floor_given then local_explicit_floor = ""b;
     1244 
     1245 		if aim2_record.explicit_floor_given then do;
     1246 		     call translate_aim_attributes_ (static.foreign_system.aim_attributes_ptr,
     1247 			aim2_record.explicit_floor, static.local_system.aim_attributes_ptr, foreign_explicit_floor,
     1248 			code);
     1249 		     if code ^= 0 then go to CANT_ESTABLISH_CEILING;
     1250 		end;
     1251 		else foreign_explicit_floor = ""b;
     1252 
     1253 		if aim_check_$greater_or_equal (foreign_explicit_floor, local_explicit_floor)
     1254 						/* other side wants higher floor than we had specified */
     1255 		     then
     1256 		     static.local_system.access_floor = foreign_explicit_floor;
     1257 
     1258 		else if aim_check_$greater (local_explicit_floor, foreign_explicit_floor) then do;
     1259 		     static.local_system.access_floor = local_explicit_floor;
     1260 						/* our floor controls */
     1261 		     call translate_aim_attributes_ (static.local_system.aim_attributes_ptr,
     1262 			static.local_system.access_floor, static.foreign_system.aim_attributes_ptr,
     1263 			static.foreign_system.access_floor, code);
     1264 						/* so we have to translate it for the other system */
     1265 		     if code ^= 0 then go to CANT_ESTABLISH_CEILING;
     1266 		end;
     1267 
     1268 		else do;				/* neither one is >= the other, so they must be isolated */
     1269 		     call iodd_msg_ (ERROR, MASTER, imft_et_$explicit_floor_mismatch, IMFT_DRIVER_,
     1270 			"Attempting to establish access floor with ^a.", static.foreign_system.name);
     1271 		     call write_aim2_reply (imft_et_$explicit_floor_mismatch);
     1272 		     go to RETURN_FROM_INIT;
     1273 		end;
     1274 	     end;
     1275 	     else static.local_system.access_floor, static.foreign_system.access_floor = ""b;
     1276 						/* no explicit floors, use system low for both */
     1277 
     1278 	     if ^aim_check_$greater_or_equal (static.local_system.access_ceiling, static.local_system.access_floor)
     1279 						/* make sure the resulting range is non-null */
     1280 	     then do;
     1281 		call convert_authorization_$to_string_short (static.local_system.access_ceiling,
     1282 		     max_access_class_string, code);
     1283 		if code ^= 0 then do;
     1284 		     call convert_aim_attributes_ (static.local_system.access_ceiling, max_access_class_octal);
     1285 		     max_access_class_string = max_access_class_octal;
     1286 		end;
     1287 
     1288 		call convert_authorization_$to_string_short (static.local_system.access_floor,
     1289 		     min_access_class_string, code);
     1290 		if code ^= 0 then do;
     1291 		     call convert_aim_attributes_ (static.local_system.access_floor, min_access_class_octal);
     1292 		     min_access_class_string = min_access_class_octal;
     1293 		end;
     1294 
     1295 		call iodd_msg_ (ERROR, MASTER, error_table_$ai_outside_common_range, IMFT_DRIVER_,
     1296 		     "Computed access ceiling (^[^a^;^ssystem_low^]) is not greater than or equal to computed access floor (^[^a^;^ssystem_low^]).",
     1297 		     (max_access_class_string ^= ""), max_access_class_string, (min_access_class_string ^= ""),
     1298 		     min_access_class_string);
     1299 		call write_aim2_reply (error_table_$ai_outside_common_range);
     1300 		go to RETURN_FROM_INIT;
     1301 	     end;
     1302 	end;
     1303 
     1304 	if ^aim_check_$greater_or_equal (get_authorization_ (), static.local_system.access_ceiling) then do;
     1305 	     call convert_authorization_$to_string_short (static.local_system.access_ceiling, max_access_class_string,
     1306 		code);
     1307 	     if code ^= 0 then do;
     1308 		call convert_aim_attributes_ (static.local_system.access_ceiling, max_access_class_octal);
     1309 		max_access_class_string = max_access_class_octal;
     1310 	     end;
     1311 	     call iodd_msg_ (ERROR, MASTER, imft_et_$process_authorization_too_low, IMFT_DRIVER_,
     1312 		"Minimum process authorization must be ^[^a^;^ssystem_low^].", (max_access_class_string ^= ""),
     1313 		max_access_class_string);
     1314 	     call write_aim2_reply (imft_et_$process_authorization_too_low);
     1315 	     go to RETURN_FROM_INIT;
     1316 	end;
     1317 
     1318 
     1319 /* Here iff AIM ceiling is computed and OK */
     1320 
     1321 	call write_aim2_reply (NO_ERROR);
     1322 
     1323 	return;
     1324 
     1325 /* Internal to establish_input_access_ceiling: attempts to transmit an AIM reply */
     1326 
     1327 write_aim_reply:
     1328 	procedure (p_aim_type, p_record_ptr, p_record_lth);
     1329 
     1330 dcl  p_aim_type fixed binary (7) unaligned unsigned parameter;
     1331 dcl  p_record_ptr pointer parameter;
     1332 dcl  p_record_lth fixed binary (21) parameter;
     1333 dcl  code fixed binary (35);
     1334 
     1335 	     local_icri.version = ICRI_VERSION_1;
     1336 	     local_icri.timeout = FIVE_MINUTES;		/* give the other side a chance */
     1337 	     local_icri.record_type = p_aim_type;
     1338 	     local_icri.record_ptr = p_record_ptr;
     1339 	     local_icri.record_lth = p_record_lth;
     1340 
     1341 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_reply_record", addr (local_icri), code);
     1342 
     1343 	     if code ^= 0 then do;			/* any I/O error is fatal */
     1344 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1345 		     static.foreign_system.name);
     1346 		go to RETURN_FROM_INIT;
     1347 	     end;
     1348 
     1349 	     return;
     1350 
     1351 	end write_aim_reply;
     1352 
     1353 
     1354 
     1355 /*  Internal to establish_input_access_ceiling: attempts to transmit an AIM2 reply */
     1356 
     1357 write_aim2_reply:
     1358 	procedure (p_code);
     1359 
     1360 dcl  p_code fixed binary (35) parameter;
     1361 
     1362 	     aim2_record_ptr = addr (output_buffer);	/* need a place to put it */
     1363 	     aim2_record.code = imft_convert_status_code_$encode (p_code);
     1364 
     1365 	     if static.old_version then
     1366 		call write_aim_reply (IMFT_AIM2, aim2_record_ptr, (4 * currentsize (v2_aim2_record)));
     1367 
     1368 	     else do;
     1369 		if aim2_record.code = 0 then do;
     1370 		     aim2_record.computed_ceiling = static.local_system.access_ceiling;
     1371 		     aim2_record.computed_floor = static.local_system.access_floor;
     1372 		end;
     1373 		call write_aim_reply (IMFT_AIM2, aim2_record_ptr, (4 * currentsize (aim2_record)));
     1374 	     end;
     1375 
     1376 	     return;
     1377 
     1378 	end write_aim2_reply;
     1379 
     1380 /* Internal to establish_input_access_ceiling: attempts to read an AIM command */
     1381 
     1382 read_aim_command:
     1383 	procedure (p_aim_type);
     1384 
     1385 dcl  p_aim_type fixed binary (7) unaligned unsigned parameter;
     1386 
     1387 	     local_icri.version = ICRI_VERSION_1;
     1388 	     local_icri.timeout = FIVE_MINUTES;		/* must be able to read it */
     1389 	     local_icri.record_ptr = addr (input_buffer);
     1390 	     local_icri.record_max_lth = length (input_buffer);
     1391 
     1392 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "read_command_record", addr (local_icri), code);
     1393 
     1394 	     if code = 0 then			/* got something ... */
     1395 		if local_icri.record_type = p_aim_type then
     1396 		     return;			/* ... got the right type of command */
     1397 
     1398 		else do;				/* ... anything else causes us to try over again */
     1399 		     call write_aim_reply (IMFT_RESYNCHRONIZE, null (), 0);
     1400 		     go to RESYNCHRONIZE_DRIVER;
     1401 		end;
     1402 
     1403 	     else do;				/* some more serious error */
     1404 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1405 		     static.foreign_system.name);
     1406 		go to RETURN_FROM_INIT;
     1407 	     end;
     1408 
     1409 	end read_aim_command;
     1410 
     1411      end establish_input_access_ceiling;
     1412 
     1413 /* Synchronize an output driver: Write a SYNC1 command to the remote input driver with the our system ID and password and
     1414*   wait for a SYNC1 response.  On receiving the SYNC1 response, check if the remote system validated that ID/password
     1415*   combination and, if it did, validate the password/ID it sent us against the foreign system ID/password.  If the remote
     1416*   input driver's ID/password match, send a SYNC2 command indicating that synchronization is completed; otherwise, send a
     1417*   SYNC2 command explaining the synchronization failure */
     1418 
     1419 synchronize_output_driver:
     1420      procedure ();
     1421 
     1422 	call write_sync_command (IMFT_SYNC1, static.local_system.name, static.local_system.password, 0, "");
     1423 						/* doesn't return on fatal errors */
     1424 
     1425 	call read_sync_reply (IMFT_SYNC1);
     1426 
     1427 	sync_record_ptr = addr (input_buffer);
     1428 	if sync_record.code ^= 0 then do;		/* remote input driver didn't like our ID/password */
     1429 	     code = imft_convert_status_code_$decode (sync_record.code);
     1430 	     if code = imft_et_$non_matching_ids then
     1431 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_,
     1432 		     "ID specified on local system is ^a; ID specified on remote system is ^a.",
     1433 		     static.local_system.name, sync_record.correct_userid);
     1434 	     else call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Validating local system ID.  ""^a""",
     1435 		     static.local_system.name);
     1436 	     go to RETURN_FROM_INIT;
     1437 	end;
     1438 
     1439 	if static.foreign_system.name ^= sync_record.my_userid then do;
     1440 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_ids, IMFT_DRIVER_,
     1441 		"ID specified on local system is ^a; ID specified on remote system is ^a.",
     1442 		static.foreign_system.name, sync_record.my_userid);
     1443 	     call write_sync_command (IMFT_SYNC2, "", "", imft_et_$non_matching_ids, static.foreign_system.name);
     1444 	     go to RETURN_FROM_INIT;
     1445 	end;
     1446 
     1447 	if static.foreign_system.password ^= sync_record.my_password then do;
     1448 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_passwords, IMFT_DRIVER_,
     1449 		"Validating foreign system ID.  ""^a""", sync_record.my_userid);
     1450 	     call write_sync_command (IMFT_SYNC2, "", "", imft_et_$non_matching_passwords, "");
     1451 	     go to RETURN_FROM_INIT;
     1452 	end;
     1453 
     1454 
     1455 	if local_icri.record_lth ^= 4 * currentsize (sync_record) then do;
     1456 						/* remote driver is pre 4.0 */
     1457 	     if foreign_system_version >= 4.0 then do;
     1458 		call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_versions, IMFT_DRIVER_,
     1459 		     "Remote system appears to be pre 4.0 but was specified to be ^a on local system.",
     1460 		     static.foreign_system.imft_version);
     1461 		call write_sync_command (IMFT_SYNC2, "", "", imft_et_$non_matching_versions, "");
     1462 		go to RETURN_FROM_INIT;
     1463 	     end;
     1464 	end;
     1465 
     1466 	else if static.foreign_system.imft_version ^= sync_record.imft_version then do;
     1467 	     call iodd_msg_ (ERROR, MASTER, imft_et_$non_matching_versions, IMFT_DRIVER_,
     1468 		"Remote system claims to be ""^a"" but specified locally to be ""^a"".", sync_record.imft_version,
     1469 		static.foreign_system.imft_version);
     1470 	     call write_sync_command (IMFT_SYNC2, "", "", imft_et_$non_matching_versions, "");
     1471 	     go to RETURN_FROM_INIT;
     1472 	end;
     1473 
     1474 /* success */
     1475 	call write_sync_command (IMFT_SYNC2, "", "", 0, "");
     1476 	call read_sync_reply (IMFT_SYNC2);
     1477 	if sync_record.code ^= 0 then do;
     1478 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Completing synchronization sequence.");
     1479 	     go to RETURN_FROM_INIT;
     1480 	end;
     1481 
     1482 	return;					/* here iff synchronized OK */
     1483 
     1484 /* Internal to syncrhonize_output_driver: attempts to transmit a SYNC command */
     1485 
     1486 write_sync_command:
     1487 	procedure (p_sync_type, p_my_userid, p_my_password, p_code, p_correct_userid);
     1488 
     1489 dcl  p_sync_type fixed binary (7) unaligned unsigned parameter;
     1490 dcl  (p_my_userid, p_correct_userid) character (*) parameter;
     1491 dcl  p_my_password character (8) aligned parameter;
     1492 dcl  p_code fixed binary (35) parameter;
     1493 
     1494 dcl  code fixed binary (35);
     1495 
     1496 	     sync_record_ptr = addr (output_buffer);	/* need a place to put it */
     1497 	     sync_record.my_userid = p_my_userid;
     1498 	     sync_record.my_password = p_my_password;
     1499 	     sync_record.code = imft_convert_status_code_$encode (p_code);
     1500 	     sync_record.correct_userid = p_correct_userid;
     1501 	     sync_record.imft_version = CURRENT_IMFT_VERSION;
     1502 
     1503 	     local_icri.version = ICRI_VERSION_1;
     1504 	     local_icri.timeout = FIVE_MINUTES;		/* give the other side a chance to respond */
     1505 	     local_icri.record_type = p_sync_type;
     1506 	     local_icri.record_ptr = sync_record_ptr;
     1507 	     local_icri.record_lth = 4 * currentsize (sync_record);
     1508 
     1509 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "write_command_record", addr (local_icri), code);
     1510 
     1511 	     if code = 0 then return;			/* success */
     1512 
     1513 	     else if code = imft_et_$reply_pending then	/* there's a reply to be checked out first ... */
     1514 						/* ... must be other side asking us to start over */
     1515 		call read_sync_reply (IMFT_RESYNCHRONIZE);
     1516 
     1517 	     else do;				/* some more serious error */
     1518 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to synchronize with ^a.",
     1519 		     static.foreign_system.name);
     1520 		go to RETURN_FROM_INIT;
     1521 	     end;
     1522 
     1523 	end write_sync_command;
     1524 
     1525 
     1526 
     1527 /* Internal to synchronize_output_driver: attempts to read a SYNC reply */
     1528 
     1529 read_sync_reply:
     1530 	procedure (p_sync_type);
     1531 
     1532 dcl  p_sync_type fixed binary (7) unaligned unsigned parameter;
     1533 
     1534 	     local_icri.version = ICRI_VERSION_1;
     1535 	     if static.automatic_operation & (p_sync_type = IMFT_SYNC1) then
     1536 		local_icri.timeout = 0;		/* wait forever for start of synchronization sequence */
     1537 	     else local_icri.timeout = FIVE_MINUTES;
     1538 	     local_icri.record_ptr = addr (input_buffer);
     1539 	     local_icri.record_max_lth = length (input_buffer);
     1540 
     1541 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "read_reply_record", addr (local_icri), code);
     1542 
     1543 	     if code = 0 then			/* got something ... */
     1544 		if local_icri.record_type = IMFT_RESYNCHRONIZE then go to RESYNCHRONIZE_DRIVER;
     1545 						/* ... remote system wants us to start over */
     1546 
     1547 		else if (p_sync_type = 0) | (local_icri.record_type = p_sync_type) then return;
     1548 						/* ... got the right type of reply or will take any reply */
     1549 
     1550 		else do;				/* ... anything else is residue from a now dead driver */
     1551 		     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
     1552 			"Unexpected reply code ^d from ^a; driver will attempt to resyncrhonize.",
     1553 			local_icri.record_type, static.foreign_system.name);
     1554 		     go to RESYNCHRONIZE_DRIVER;
     1555 		end;
     1556 
     1557 	     else do;				/* some more serious error */
     1558 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to synchronize with ^a.",
     1559 		     static.foreign_system.name);
     1560 		go to RETURN_FROM_INIT;
     1561 	     end;
     1562 
     1563 	end read_sync_reply;
     1564 
     1565      end synchronize_output_driver;
     1566 
     1567 /* Establish the AIM access class ceiling for an output driver: Send an AIM1 command giving our system's AIM attributes
     1568*   definition and wait for the remote system to send an AIM1 reply with its AIM definition.  When we have both
     1569*   definitions, compute the common access ceiling (if possible), validate our explicit ceiling (if any) which must be less
     1570*   than the computed ceiling and, if all is OK, send an AIM2 command.  When the AIM2 response is received, check for the
     1571*   remote system requesting termination */
     1572 
     1573 establish_output_access_ceiling:
     1574      procedure ();
     1575 
     1576 /* We will allocate storage for attributes, ensure any old stuff is freed. */
     1577 
     1578 	call free_aim_attributes_storage;
     1579 
     1580 	call get_system_aim_attributes_ (get_system_free_area_ (), AIM_ATTRIBUTES_VERSION_1,
     1581 	     static.local_system.aim_attributes_ptr, code);
     1582 	if code ^= 0 then do;			/* shouldn't get this but... */
     1583 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to get local AIM definition.");
     1584 	     go to RETURN_FROM_INIT;			/* ... other side will timeout */
     1585 	end;
     1586 
     1587 	call write_aim_command (IMFT_AIM1, static.local_system.aim_attributes_ptr,
     1588 	     (4 * currentsize (static.local_system.aim_attributes_ptr -> aim_attributes)));
     1589 
     1590 	call read_aim_reply (IMFT_AIM1);		/* aborts if we can't get it */
     1591 
     1592 	if addr (input_buffer) -> aim_attributes.version ^= AIM_ATTRIBUTES_VERSION_1 then do;
     1593 	     call iodd_msg_ (ERROR, MASTER, error_table_$unimplemented_version, IMFT_DRIVER_,
     1594 		"Can not understand AIM definition from ^a.", static.foreign_system.name);
     1595 	     go to RETURN_FROM_INIT;			/* ... other side will timeout */
     1596 	end;
     1597 
     1598 	allocate aim_attributes in (system_area) set (static.foreign_system.aim_attributes_ptr);
     1599 	static.foreign_system.aim_attributes_ptr -> aim_attributes = addr (input_buffer) -> aim_attributes;
     1600 
     1601 
     1602 /* Have exchanged AIM definitions: compute common access class ceiling, validate our explicit ceiling (if any), and send
     1603*   the AIM2 command */
     1604 
     1605 	call compute_common_aim_ceiling_ (static.local_system.aim_attributes_ptr, static.local_system.access_ceiling,
     1606 	     static.foreign_system.aim_attributes_ptr, static.foreign_system.access_ceiling, code);
     1607 	if code ^= 0 then do;
     1608 CANT_ESTABLISH_CEILING:
     1609 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1610 		static.foreign_system.name);
     1611 	     call write_aim2_command (code);		/* let remote system know we lost */
     1612 	     go to RETURN_FROM_INIT;
     1613 	end;
     1614 
     1615 	if local_explicit_ceiling_given then		/* check explicit ceiling */
     1616 	     if aim_check_$greater_or_equal (static.local_system.access_ceiling, local_explicit_ceiling) then do;
     1617 		call translate_aim_attributes_ (static.local_system.aim_attributes_ptr, local_explicit_ceiling,
     1618 		     static.foreign_system.aim_attributes_ptr, foreign_explicit_ceiling, code);
     1619 		if code ^= 0 then go to CANT_ESTABLISH_CEILING;
     1620 		if ^aim_check_$greater_or_equal (get_authorization_ (), local_explicit_ceiling) then do;
     1621 		     call convert_authorization_$to_string_short (local_explicit_ceiling, max_access_class_string,
     1622 			code);
     1623 		     if code ^= 0 then do;
     1624 			call convert_aim_attributes_ (local_explicit_ceiling, max_access_class_octal);
     1625 			max_access_class_string = max_access_class_octal;
     1626 		     end;
     1627 		     call iodd_msg_ (ERROR, MASTER, imft_et_$process_authorization_too_low, IMFT_DRIVER_,
     1628 			"Minimum process authorization must be ^[^a^;^ssystem_low^].",
     1629 			(max_access_class_string ^= ""), max_access_class_string);
     1630 		     call write_aim2_command (imft_et_$process_authorization_too_low);
     1631 		     go to RETURN_FROM_INIT;
     1632 		end;
     1633 	     end;
     1634 
     1635 	     else do;				/* explicit ceiling is out of range */
     1636 		call iodd_msg_ (ERROR, MASTER, error_table_$ai_outside_common_range, IMFT_DRIVER_,
     1637 		     "Attempting to establish access ceiling with ^a.", static.foreign_system.name);
     1638 		call write_aim2_command (error_table_$ai_outside_common_range);
     1639 		go to RETURN_FROM_INIT;
     1640 	     end;
     1641 
     1642 	else do;					/* not changing the ceiling: check driver's authoriztion */
     1643 	     if ^aim_check_$greater_or_equal (get_authorization_ (), static.local_system.access_ceiling) then do;
     1644 		call convert_authorization_$to_string_short (static.local_system.access_ceiling,
     1645 		     max_access_class_string, code);
     1646 		if code ^= 0 then do;
     1647 		     call convert_aim_attributes_ (static.local_system.access_ceiling, max_access_class_octal);
     1648 		     max_access_class_string = max_access_class_octal;
     1649 		end;
     1650 		call iodd_msg_ (ERROR, MASTER, imft_et_$process_authorization_too_low, IMFT_DRIVER_,
     1651 		     "Minimum process authorization must be ^[^a^;^ssystem_low^].", (max_access_class_string ^= ""),
     1652 		     max_access_class_string);
     1653 		call write_aim2_command (imft_et_$process_authorization_too_low);
     1654 		go to RETURN_FROM_INIT;
     1655 	     end;
     1656 	end;
     1657 
     1658 	if ^static.old_version then do;
     1659 	     if local_explicit_floor_given then do;
     1660 		if ^aim_check_$greater_or_equal (static.local_system.access_ceiling, local_explicit_floor) then do;
     1661 						/* floor is not below common ceiling, we can't run */
     1662 		     call iodd_msg_ (ERROR, MASTER, error_table_$ai_outside_common_range,
     1663 			"Common access ceiling is not greater than or equal to minimum access class.");
     1664 
     1665 		     call write_aim2_command (error_table_$ai_outside_common_range);
     1666 		     go to RETURN_FROM_INIT;
     1667 		end;
     1668 
     1669 		static.local_system.access_floor = local_explicit_floor;
     1670 	     end;
     1671 
     1672 	     else static.local_system.access_floor = ""b; /* use system_low */
     1673 	end;
     1674 
     1675 	call write_aim2_command (NO_ERROR);		/* we're happy */
     1676 
     1677 /* Wait for AIM2 reply and abort if foreign system requests it */
     1678 
     1679 	call read_aim_reply (IMFT_AIM2);
     1680 
     1681 	aim2_record_ptr = addr (input_buffer);
     1682 
     1683 	if aim2_record.code ^= 0 then do;		/* remote system couldn't compute definition */
     1684 	     code = imft_convert_status_code_$decode (aim2_record.code);
     1685 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1686 		static.foreign_system.name);
     1687 	     go to RETURN_FROM_INIT;
     1688 	end;
     1689 
     1690 	if static.old_version then
     1691 	     if local_explicit_ceiling_given then do;	/* OK: now set the true ceilings */
     1692 		static.local_system.access_ceiling = local_explicit_ceiling;
     1693 		static.foreign_system.access_ceiling = foreign_explicit_ceiling;
     1694 	     end;
     1695 	     else ;
     1696 
     1697 	else do;					/* real agreed-on ceiling and floor are in AIM2 reply record */
     1698 	     call translate_aim_attributes_ (static.foreign_system.aim_attributes_ptr, aim2_record.computed_ceiling,
     1699 		static.local_system.aim_attributes_ptr, static.local_system.access_ceiling, code);
     1700 	     if code ^= 0 then do;
     1701 		call iodd_msg_ (ERROR, MASTER, code, "Translating final access ceiling.");
     1702 		go to RETURN_FROM_INIT;		/* no way to tell other system */
     1703 	     end;
     1704 
     1705 	     static.foreign_system.access_ceiling = aim2_record.computed_ceiling;
     1706 
     1707 	     call translate_aim_attributes_ (static.foreign_system.aim_attributes_ptr, aim2_record.computed_floor,
     1708 		static.local_system.aim_attributes_ptr, static.local_system.access_floor, code);
     1709 	     if code ^= 0 then do;
     1710 		call iodd_msg_ (ERROR, MASTER, code, "Translating final access floor.");
     1711 		go to RETURN_FROM_INIT;		/* no way to tell other system */
     1712 	     end;
     1713 
     1714 	     static.foreign_system.access_floor = aim2_record.computed_floor;
     1715 	end;
     1716 
     1717 	return;
     1718 
     1719 /* Internal to establish_output_access_ceiling: attempts to transmit an AIM command */
     1720 
     1721 write_aim_command:
     1722 	procedure (p_aim_type, p_record_ptr, p_record_lth);
     1723 
     1724 dcl  p_aim_type fixed binary (7) unaligned unsigned parameter;
     1725 dcl  p_record_ptr pointer parameter;
     1726 dcl  p_record_lth fixed binary (21) parameter;
     1727 dcl  code fixed binary (35);
     1728 
     1729 	     local_icri.version = ICRI_VERSION_1;
     1730 	     local_icri.timeout = FIVE_MINUTES;		/* give the other side a chance */
     1731 	     local_icri.record_type = p_aim_type;
     1732 	     local_icri.record_ptr = p_record_ptr;
     1733 	     local_icri.record_lth = p_record_lth;
     1734 
     1735 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "write_command_record", addr (local_icri), code);
     1736 
     1737 	     if code = 0 then return;			/* success */
     1738 
     1739 	     else if code = imft_et_$reply_pending then	/* there's a reply to be checked out first ... */
     1740 						/* ... must be other side asking us to start over */
     1741 		call read_aim_reply (IMFT_RESYNCHRONIZE);
     1742 
     1743 	     else do;				/* some more serious error */
     1744 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1745 		     static.foreign_system.name);
     1746 		go to RETURN_FROM_INIT;
     1747 	     end;
     1748 
     1749 	     return;
     1750 
     1751 	end write_aim_command;
     1752 
     1753 
     1754 
     1755 /*  Internal to establish_output_access_ceiling: attempts to transmit an AIM2 command */
     1756 
     1757 write_aim2_command:
     1758 	procedure (p_code);
     1759 
     1760 dcl  p_code fixed binary (35) parameter;
     1761 dcl  record_size fixed binary (21);
     1762 
     1763 	     aim2_record_ptr = addr (output_buffer);	/* need a place to put it */
     1764 	     aim2_record.code = imft_convert_status_code_$encode (p_code);
     1765 
     1766 	     if static.old_version then do;
     1767 		v2_aim2_record.computed_ceiling = static.local_system.access_ceiling;
     1768 		v2_aim2_record.explicit_ceiling_given = local_explicit_ceiling_given;
     1769 		v2_aim2_record.explicit_ceiling = local_explicit_ceiling;
     1770 		record_size = 4 * currentsize (v2_aim2_record);
     1771 	     end;
     1772 
     1773 	     else do;
     1774 		aim2_record.computed_ceiling = static.local_system.access_ceiling;
     1775 		aim2_record.explicit_ceiling_given = local_explicit_ceiling_given;
     1776 		aim2_record.explicit_ceiling = local_explicit_ceiling;
     1777 		aim2_record.computed_floor = static.local_system.access_floor;
     1778 		aim2_record.explicit_floor_given = local_explicit_floor_given;
     1779 		aim2_record.explicit_floor = local_explicit_floor;
     1780 
     1781 		record_size = 4 * currentsize (aim2_record);
     1782 	     end;
     1783 
     1784 	     call write_aim_command (IMFT_AIM2, aim2_record_ptr, record_size);
     1785 
     1786 	     return;
     1787 
     1788 	end write_aim2_command;
     1789 
     1790 /* Internal to establish_output_access_ceiling: attempts to read an AIM reply */
     1791 
     1792 read_aim_reply:
     1793 	procedure (p_aim_type);
     1794 
     1795 dcl  p_aim_type fixed binary (7) unaligned unsigned parameter;
     1796 
     1797 	     local_icri.version = ICRI_VERSION_1;
     1798 	     local_icri.timeout = FIVE_MINUTES;		/* must be able to read it */
     1799 	     local_icri.record_ptr = addr (input_buffer);
     1800 	     local_icri.record_max_lth = length (input_buffer);
     1801 
     1802 	     call iox_$control (ds_ptr -> driver_status.dev_in_iocbp, "read_reply_record", addr (local_icri), code);
     1803 
     1804 	     if code = 0 then			/* got something ... */
     1805 		if local_icri.record_type = IMFT_RESYNCHRONIZE then go to RESYNCHRONIZE_DRIVER;
     1806 						/* ... remote system wants us to start over */
     1807 
     1808 		else if local_icri.record_type = p_aim_type then return;
     1809 						/* ... got the right type of reply */
     1810 
     1811 		else do;				/* ... anything else is residue from a now dead driver */
     1812 		     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
     1813 			"Unexpected reply code ^d from ^a; driver will atempt to resynchronize.",
     1814 			local_icri.record_type, static.foreign_system.name);
     1815 		     go to RESYNCHRONIZE_DRIVER;
     1816 		end;
     1817 
     1818 	     else do;				/* some more serious error */
     1819 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_, "Attempting to establish access ceiling with ^a.",
     1820 		     static.foreign_system.name);
     1821 		go to RETURN_FROM_INIT;
     1822 	     end;
     1823 
     1824 	end read_aim_reply;
     1825 
     1826      end establish_output_access_ceiling;
     1827 
     1828 /* Check for remote input driver termination:  This procedure is called every
     1829*   iodd_static.wakeup_time seconds while an output driver is idle.  It checks
     1830*   to see if the remote system has sent a reply requesting resynchronization
     1831*   or logout of the local output driver */
     1832 
     1833 check_for_resync_request:
     1834      procedure ();
     1835 
     1836 /* If we are a dial sender, and we are supposed to drop the line to
     1837*   conserve network costs when the driver goes idle, then drop it here
     1838*   and signal the dial receiver that we are going away for a while.
     1839*
     1840*   We will pick up and reconnect the line in the request processing when
     1841*   we see that the iocbp is null. */
     1842 
     1843 	if static.idle_line_drop = "1"b then do;
     1844 
     1845 /* Determine if we are to idle the line yet.  Each time the coord sends us
     1846*   a daemon idle, we increment this counter.  When we have seen enough then
     1847*   we will idle the line.  The prevents rapid line drops and raises. */
     1848 
     1849 	     static.idle_delay = static.idle_delay + 1;
     1850 	     if static.idle_delay <= static.idle_delay_count then goto delay_idle_down;
     1851 						/* wait a bit */
     1852 
     1853 	     if ds_ptr -> driver_status.dev_out_iocbp = null then goto idled;
     1854 
     1855 	     iodd_static.re_init_in_progress = "1"b;	/* re-initialize the driver */
     1856 	     iodd_static.slave.log_msg = "1"b;		/* send to log and slave */
     1857 	     call iodd_msg_ (LOG, BOTH, 0, "", "^a ^a ^[input^;output^] driver going to sleep at ^a.",
     1858 		static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver,
     1859 		date_time_$format ("date_time", clock (), "", ""));
     1860 	     local_icri.record_type = IMFT_LOGOUT;
     1861 	     local_icri.version = ICRI_VERSION_1;
     1862 	     local_icri.timeout = 15;			/* ... doesn't really have to get through */
     1863 	     local_icri.record_ptr = null ();		/* ... no associated data */
     1864 	     local_icri.record_lth, local_icri.record_max_lth = 0;
     1865 
     1866 	     if ds_ptr -> driver_status.dev_out_iocbp ^= null () then do;
     1867 		call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "write_command_record", addr (local_icri),
     1868 		     ignore_code);
     1869 	     end;
     1870 
     1871 	     call iox_$control (iodd_static.slave_out, "runout", null (), ignore_code);
     1872 	     call drop_device ();
     1873 
     1874 idled:
     1875 	     call continue_to_signal_ (ignore_code);
     1876 	     return;
     1877 	end;
     1878 
     1879 delay_idle_down:
     1880 	call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "read_status", addr (trsi), code);
     1881 	if code ^= 0 then do;
     1882 COULD_NOT_RAISE_REMOTE:
     1883 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_,
     1884 		"Fatal error while checking status of remote input driver; driver will re-initialize.");
     1885 	     signal condition (re_init);
     1886 	end;
     1887 
     1888 	if trsi.input_pending then do;		/* see what's going on */
     1889 	     local_icri.version = ICRI_VERSION_1;
     1890 	     local_icri.timeout = FIVE_MINUTES;		/* in case the remote input driver is sick */
     1891 	     local_icri.record_ptr = addr (input_buffer); /* need to put is someplace */
     1892 	     local_icri.record_max_lth = length (input_buffer);
     1893 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "read_reply_record", addr (local_icri), code);
     1894 	     if code ^= 0 then go to COULD_NOT_RAISE_REMOTE;
     1895 
     1896 	     if local_icri.record_type = IMFT_RESYNCHRONIZE then signal condition (imft_resynchronize_driver_);
     1897 
     1898 	     else if local_icri.record_type = IMFT_LOGOUT then signal condition (imft_remote_logout_);
     1899 
     1900 	     else do;				/* some unexpected event */
     1901 		call iodd_msg_ (NORMAL, MASTER, 0, IMFT_DRIVER_,
     1902 		     "Unexpected reply code ^d from ^a; driver will re-initialize.", local_icri.record_type,
     1903 		     static.foreign_system.name);
     1904 		signal condition (re_init);
     1905 	     end;
     1906 	end;
     1907 
     1908 	call continue_to_signal_ (ignore_code);
     1909 
     1910 	return;
     1911 
     1912      end check_for_resync_request;
     1913 
     1914 /* Free allocated storage if it exists. */
     1915 
     1916 free_aim_attributes_storage:
     1917      proc;
     1918 
     1919 /* aim attributes occupy allocated storage.  We need to free it prior to
     1920*   allocating new stuff.  Otherwise we end up cluttering area.linker. */
     1921 
     1922 	if static.foreign_system.aim_attributes_ptr ^= null () then
     1923 	     free static.foreign_system.aim_attributes_ptr -> aim_attributes;
     1924 	static.foreign_system.aim_attributes_ptr = null ();
     1925 
     1926 	if static.local_system.aim_attributes_ptr ^= null () then
     1927 	     free static.local_system.aim_attributes_ptr -> aim_attributes;
     1928 	static.local_system.aim_attributes_ptr = null ();
     1929 
     1930      end free_aim_attributes_storage;
     1931 
     1932 /* Drop the device and hang it up */
     1933 
     1934 drop_device:
     1935      procedure ();
     1936 
     1937 dcl  send_hangup bit (1) aligned;
     1938 dcl  iocb_ptr ptr;
     1939 
     1940 	send_hangup = "1"b;
     1941 	go to DROP_DEVICE_COMMON;
     1942 
     1943 
     1944 /* Drop the device only */
     1945 
     1946 detach_device:
     1947      entry ();
     1948 
     1949 	if static.dial_service then
     1950 	     send_hangup = "1"b;
     1951 	else send_hangup = "0"b;
     1952 
     1953 DROP_DEVICE_COMMON:
     1954 	iodd_static.attach_name = "*";
     1955 	ds_ptr -> driver_status.attached = "0"b;
     1956 	iocb_ptr = ds_ptr -> driver_status.dev_out_iocbp;
     1957 	ds_ptr -> driver_status.dev_out_iocbp, ds_ptr -> driver_status.dev_in_iocbp = null ();
     1958 
     1959 /* Kill any possible associated minor device. */
     1960 
     1961 	if iodd_static.assigned_devices = 2 then do;	/* copy necessary stuff to second minor */
     1962 						/* device's status structure */
     1963 	     devp = iodd_static.driver_list_ptr -> driver_ptr_list.stat_segp (2);
     1964 	     devp -> driver_status.attached = "0"b;
     1965 	     devp -> driver_status.ready = "0"b;
     1966 	     devp -> driver_status.dev_out_iocbp = ds_ptr -> driver_status.dev_out_iocbp;
     1967 	     devp -> driver_status.dev_in_iocbp = ds_ptr -> driver_status.dev_in_iocbp;
     1968 	end;
     1969 
     1970 	iodd_static.attach_name = "*";
     1971 
     1972 	call close_and_detach (iocb_ptr, send_hangup);
     1973 
     1974 /* If we were an in-dial then we have to drop the dial service and
     1975*   kill the event channel too. */
     1976 
     1977 	if static.in_dial_qualifier ^= "" & dma.dial_channel ^= 0 then do;
     1978 	     call ipc_$decl_ev_wait_chn (dma.dial_channel, code);
     1979 	     call dial_manager_$shutoff_dials (addr (dma), code);
     1980 	     call ipc_$drain_chn (dma.dial_channel, code);
     1981 	     call ipc_$delete_ev_chn (dma.dial_channel, code);
     1982 	     dma.dial_channel = 0;
     1983 	end;
     1984 
     1985 	call continue_to_signal_ (ignore_code);		/* in case this is called from a handler */
     1986 
     1987 	return;
     1988 
     1989      end drop_device;
     1990 
     1991 /* Close and detach the line to the remote system */
     1992 
     1993 close_and_detach:
     1994      procedure (P_iocb_ptr, P_send_hangup);
     1995 
     1996 dcl  P_iocb_ptr pointer parameter;
     1997 dcl  P_send_hangup bit (1) aligned;
     1998 
     1999 	if P_iocb_ptr = null () then return;		/* may be used before anything's attached */
     2000 
     2001 	if P_send_hangup then do;			/* caller requested a hangup of the line */
     2002 	     if static.in_dial_qualifier ^= "" then	/* ignore hangups */
     2003 		call ipc_$decl_ev_call_chn (dma.dial_channel, nulle, null (), 1, code);
     2004 	     else do;
     2005 		hangup_info.entry = nulle;		/* ... prevent the hangup from causing a reinit */
     2006 		hangup_info.data_ptr = null ();
     2007 		hangup_info.priority = 20;
     2008 		call iox_$control (P_iocb_ptr, "hangup_proc", addr (hangup_info), ignore_code);
     2009 	     end;
     2010 
     2011 /* Wait for any line runout to arrive at the target before dropping the line */
     2012 
     2013 	     call timer_manager_$sleep (FIVE_SECONDS, RELATIVE_SECONDS);
     2014 	     call iox_$control (P_iocb_ptr, "hangup", null (), ignore_code);
     2015 	end;
     2016 
     2017 	call iox_$close (P_iocb_ptr, ignore_code);
     2018 
     2019 	call iox_$detach_iocb (P_iocb_ptr, ignore_code);
     2020 	call iox_$destroy_iocb (P_iocb_ptr, ignore_code);
     2021 	return;
     2022      end close_and_detach;
     2023 
     2024 /* May be invoked when a hangup occurs */
     2025 
     2026 nulle:
     2027      procedure ();
     2028 
     2029 	return;
     2030 
     2031      end nulle;
     2032 
     2033 /* Attach the line to the remote system */
     2034 
     2035 attach_line:
     2036      procedure ();
     2037 
     2038 dcl  attach_description character (512) varying;
     2039 dcl  character_line character (local_icri.record_lth) unaligned based (local_icri.record_ptr);
     2040 dcl  code fixed bin (35);
     2041 dcl  error_message char (64);
     2042 dcl  io_module char (32);
     2043 dcl  no_dialed fixed bin;
     2044 dcl  open_mode fixed binary;
     2045 dcl  previous_attach_code fixed bin (35);
     2046 dcl  prev_proto_error bit (1);
     2047 dcl  sleep_time fixed bin (71);
     2048 dcl  which_channel char (32);





     2049 
     2050 /* Attach a line with the target system.
     2051*
     2052*   Two forms of attachment are possible:
     2053*
     2054*   1. argument described attachment.
     2055*   This attachment takes the attach description from the iod_tables
     2056*   or the args file.  It describes the io module and the line information.
     2057*
     2058*   2. in-dial described attachment.
     2059*   This attachment takes the attach description from the dial_manager
     2060*   information returned when a dial-up for the dial-name occurs.
     2061*   This permits attach_line to determine the io module and line information.
     2062*
     2063*   Attachment can be a simple line attachment, or can include a protocol
     2064*   data handshake.
     2065*
     2066*   Error processing is such that only the first occurance of a particular error
     2067*   is noted in the log, and then error retrying occurs.  This holds for
     2068*   line attachment, opening and protocol handshake.  If a line error occurs,
     2069*   the device is dropped and a re-attachment, opening and handshake is done.
     2070*   This ensures a clean line attachment.  */
     2071 
     2072 
     2073 /* If line was previously attached we will drop the device here and try
     2074*   again. */
     2075 
     2076 	if ds_ptr -> driver_status.dev_out_iocbp ^= null () then call drop_device;
     2077 						/* Ensure we are clean */
     2078 	previous_attach_code = 0;
     2079 	prev_proto_error = "0"b;			/* no handshake error outstanding */
     2080 
     2081 retry_attach:
     2082 	sleep_time = FIVE_MINUTES;			/* default wait */
     2083 
     2084 /* If we are an in_dial, then setup the dial channel and wait for a
     2085*   connection.  When a connection has occurred, we determine the
     2086*   io module name, etc., and continue as if a suitable args input
     2087*   had been given to us. */
     2088 
     2089 	on cleanup call drop_device;			/* we drop unattached */
     2090 
     2091 	if static.in_dial_qualifier ^= "" then do;
     2092 	     call ipc_$create_ev_chn (dma.dial_channel, code);
     2093 	     if code ^= 0 then do;
     2094 		error_message = "couldn't create an event channel";
     2095 		goto IN_DIAL_ERROR;
     2096 	     end;
     2097 
     2098 	     dma.version = 1;
     2099 	     dma.dial_qualifier = rtrim (static.in_dial_qualifier);
     2100 
     2101 	     call dial_manager_$allow_dials (addr (dma), code);
     2102 
     2103 	     if code ^= 0 then do;
     2104 		error_message = "error from dial_manager_$allow_dials call";
     2105 
     2106 IN_DIAL_ERROR:
     2107 		call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_,
     2108 		     "Creating dial channel ^a for ^[input^;output^] driver to ^a ^a: ^a.", static.in_dial_qualifier,
     2109 		     static.input_driver, static.foreign_system.name, FUNCTION_NAMES (static.function), error_message)
     2110 		     ;
     2111 		goto RETURN_FROM_INIT;
     2112 	     end;
     2113 
     2114 	     event_wait_channel.channel_id = dma.dial_channel;
     2115 	     call ipc_$block (addr (event_wait_channel), addr (ev_wait_info), code);
     2116 
     2117 /* We now have a connection.  Determine information about it, and formulate
     2118*   the correct value for static.input_attach_description from the io_module
     2119*   name and the line name.  */
     2120 
     2121 	     call convert_dial_message_$return_io_module (ev_wait_info.message, which_channel, io_module, no_dialed,
     2122 		status_flags, code);
     2123 	     if code ^= 0 then do;
     2124 		error_message = "couldn't convert the dial message";
     2125 		goto IN_DIAL_ERROR;
     2126 	     end;
     2127 
     2128 	     if ^status_flags.dialed_up then do;
     2129 		error_message = "have a connection but channel is not dialed up";
     2130 		goto IN_DIAL_ERROR;
     2131 	     end;
     2132 
     2133 	     static.input_attach_description = rtrim (io_module) || " " || rtrim (which_channel);
     2134 	     call iodd_msg_ (NORMAL, MASTER, 0, "", "Dial Channel ^a connected from ^a.",
     2135 		static.input_attach_description, static.foreign_system.name);
     2136 	end;
     2137 
     2138 /* Complete connection by attaching the line.  We have to determine the
     2139*   information and connect a dial-out channel. */
     2140 
     2141 	if static.old_version then
     2142 	     attach_description = "old_imft_io_ -direction ";
     2143 	else attach_description = "imft_io_ -direction ";
     2144 
     2145 	if static.input_driver then do;
     2146 	     attach_description = attach_description || " input ";
     2147 	     open_mode = Stream_input;
     2148 	end;
     2149 	else do;
     2150 	     attach_description = attach_description || " output ";
     2151 	     open_mode = Stream_output;
     2152 	end;
     2153 
     2154 	if static.single_switch then do;
     2155 	     attach_description = attach_description || " -io_description ";
     2156 	     attach_description = attach_description || requote_string_ (rtrim (static.input_attach_description));
     2157 	end;
     2158 
     2159 	else do;
     2160 	     attach_description = attach_description || " -input_description ";
     2161 	     attach_description = attach_description || requote_string_ (rtrim (static.input_attach_description));
     2162 
     2163 	     attach_description = attach_description || " -output_description ";
     2164 	     attach_description = attach_description || requote_string_ (rtrim (static.output_attach_description));
     2165 	end;
     2166 
     2167 	if static.debug_mode then attach_description = attach_description || " -debug";
     2168 	if static.copy_data then attach_description = attach_description || " -copy_data";
     2169 
     2170 	ds_ptr -> driver_status.dev_out_stream = get_switch_name ();
     2171 
     2172 	call iox_$attach_ioname ((ds_ptr -> driver_status.dev_out_stream), ds_ptr -> driver_status.dev_out_iocbp,
     2173 	     (attach_description), code);
     2174 	ds_ptr -> driver_status.dev_in_iocbp = ds_ptr -> driver_status.dev_out_iocbp;
     2175 
     2176 	if code ^= 0 then go to ACTION_ERROR;
     2177 
     2178 
     2179 	call iox_$open (ds_ptr -> driver_status.dev_out_iocbp, open_mode, "0"b, code);
     2180 	if code ^= 0 then
     2181 	     go to ACTION_ERROR;
     2182 	else previous_attach_code = 0;
     2183 
     2184 /* Start the line going if we have attached an in-dial line. */
     2185 
     2186 	if static.in_dial_qualifier ^= "" then
     2187 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "start", null (), code);
     2188 
     2189 	if static.out_dial_text = "" then call set_hangup_proc ();
     2190 						/* enable handling of hangups */
     2191 
     2192 	call get_data_channel_names ();		/* determine names of channels forming the connection */
     2193 
     2194 /* Connection Protocol handshake. */
     2195 
     2196 	if static.in_dial_qualifier ^= "" then call put_chars ("IMFT TRANSPORT ESTABLISHED
     2197 ");
     2198 	if static.out_dial_text = "" then return;	/* normal connection */
     2199 
     2200 /* Handle connection protocol necessary for line attachment to a remote system.
     2201*
     2202*   This consists of waiting for the trigger_text, then emitting the dial_text
     2203*   and completing the protocol. */
     2204 
     2205 	call ipc_$decl_ev_call_chn (dma.dial_channel,	/* ignore hangups */
     2206 	     protocol_hangup, stat_p, 1, code);
     2207 
     2208 	call wait_for_trigger (rtrim (static.trigger_text));
     2209 
     2210 /* emit the dial text, and validate the dial connection */
     2211 
     2212 	call put_chars (rtrim (static.out_dial_text) || NL);
     2213 	call get_line ();
     2214 	if index (character_line, " dialed to ") = 0 then do;
     2215 hangup_protocol:
     2216 	     if ^prev_proto_error then
     2217 		call iodd_msg_ (NORMAL, MASTER, 0, IMFT_DRIVER_,
     2218 		     "Protocol error - received ""^a""^/driver will retry every ^i minute^[s^;^].", character_line,
     2219 		     static.sleep_time, static.sleep_time > 1);
     2220 
     2221 	     sleep_time = static.sleep_time * ONE_MINUTE;
     2222 	     prev_proto_error = "1"b;
     2223 	     goto ACTION_RETRY;
     2224 	end;
     2225 	call wait_for_trigger ("IMFT TRANSPORT ESTABLISHED
     2226 ");
     2227 	call set_hangup_proc;
     2228 
     2229 	return;
     2230 
     2231 /* Action errors are processed here for line errors, such as attach and open.
     2232*   If error codes are the same as before then no message is emitted and a
     2233*   silent retry is performed after a 5 minute wait. */
     2234 
     2235 ACTION_ERROR:
     2236 	if ^static.automatic_operation | code ^= previous_attach_code then
     2237 	     call iodd_msg_ (ERROR, MASTER, code, IMFT_DRIVER_,
     2238 		"Attaching line for ^a ^a ^[input^;output^] driver^/^-attach description: ^a",
     2239 		static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver, attach_description)
     2240 		;
     2241 	prev_proto_error = "0"b;			/* no prev error */
     2242 
     2243 /* Entry here is from the protocol error.  We want to handle the normal
     2244*   automatic_operation actions and retry the attach and handshake again. */
     2245 
     2246 ACTION_RETRY:
     2247 	if static.automatic_operation			/* keep trying every 5 minutes, so operator */
     2248 						/* doesn't have to do anything */
     2249 	then do;
     2250 	     previous_attach_code = code;
     2251 	     call drop_device;
     2252 	     call timer_manager_$sleep (sleep_time, RELATIVE_SECONDS);
     2253 	     goto retry_attach;
     2254 	end;
     2255 
     2256 	else go to RETURN_FROM_INIT;			/* NO RETRY */
     2257 
     2258 /* dummy procedure to handle line hangup during protocol handshaking. */
     2259 
     2260 protocol_hangup:
     2261 	proc;
     2262 	     goto hangup_protocol;
     2263 	end protocol_hangup;
     2264 
     2265 /* Internal to attach_line: put and get characters at the transport level. */
     2266 
     2267 put_chars:
     2268 	procedure (characters);
     2269 
     2270 dcl  characters character (*) parameter;
     2271 
     2272 	     local_icri.version = ICRI_VERSION_1;
     2273 	     local_icri.timeout = FIVE_MINUTES;
     2274 	     local_icri.record_ptr = addr (characters);
     2275 	     local_icri.record_lth = length (characters);
     2276 	     local_icri.record_max_lth = length (characters);
     2277 
     2278 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "put_transport_chars", addr (local_icri), code);
     2279 	     if code ^= 0 then goto hangup_protocol;
     2280 	     if static.debug_connect then call iodd_msg_ (NORMAL, MASTER, 0, "", "S-""^a""", rtrim (characters, "
     2281 "));
     2282 	     return;
     2283 	end;
     2284 
     2285 get_line:
     2286 	procedure ();
     2287 
     2288 	     local_icri.version = ICRI_VERSION_1;
     2289 	     local_icri.timeout = FIVE_MINUTES;
     2290 	     local_icri.record_ptr = addr (character_buffer);
     2291 	     local_icri.record_lth = 0;
     2292 	     local_icri.record_max_lth = length (character_buffer);
     2293 
     2294 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "get_transport_line", addr (local_icri), code);
     2295 	     if code ^= 0 then goto hangup_protocol;
     2296 	     if static.debug_connect then call iodd_msg_ (NORMAL, MASTER, 0, "", "R-""^a""", rtrim (character_line, "
     2297 "));
     2298 	     return;
     2299 	end;
     2300 
     2301 /* Wait for a protocol triggering string to be received. */
     2302 
     2303 wait_for_trigger:
     2304 	proc (string);
     2305 
     2306 dcl  string char (*);
     2307 
     2308 	     do trigger_loop_count = 1 to MAX_TRIGGER_LOOP_COUNT;
     2309 		call get_line;
     2310 		if index (character_line, string) ^= 0 then return;
     2311 						/* got it! */
     2312 	     end;					/* didn't get satisfactory response from other end */
     2313 	     call iodd_msg_ (ERROR, MASTER, error_table_$fatal_error, IMFT_DRIVER_,
     2314 		"Dial-out protocol retry limit reached, attaching line for ^a ^a ^[input^;output^] driver^/^-attach description: ^a",
     2315 		static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver, attach_description)
     2316 		;
     2317 	     go to hangup_protocol;
     2318 
     2319 	end wait_for_trigger;
     2320 
     2321 /* Internal to attach_line: determine the name for the I/O switch */
     2322 
     2323 get_switch_name:
     2324 	procedure () returns (character (32));
     2325 
     2326 	     attachment_count = attachment_count + 1;
     2327 
     2328 	     if attachment_count > 999 then		/* avoid conversion errors */
     2329 		attachment_count = 1;
     2330 
     2331 	     if static.input_driver then
     2332 		return ("input." || ltrim (convert (attachment_count_pic, attachment_count)));
     2333 	     else return ("output." || ltrim (convert (attachment_count_pic, attachment_count)));
     2334 
     2335 	end get_switch_name;
     2336 
     2337 
     2338 
     2339 /* Internal to attach_line: set the device hangup procedure for the line */
     2340 
     2341 set_hangup_proc:
     2342 	procedure ();
     2343 
     2344 	     if static.in_dial_qualifier ^= "" then
     2345 		call ipc_$decl_ev_call_chn (dma.dial_channel, iodd_hangup_, stat_p, 1, code);
     2346 	     else do;
     2347 		hangup_info.entry = iodd_hangup_;
     2348 		hangup_info.data_ptr = stat_p;
     2349 		hangup_info.priority = 1;
     2350 		call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "hangup_proc", addr (hangup_info), code);
     2351 	     end;
     2352 
     2353 	     if code ^= 0 then
     2354 		call iodd_msg_ (NORMAL, MASTER, code, IMFT_DRIVER_,
     2355 		     "Warning: Could not establish handler for disconnection from ^a.", static.foreign_system.name);
     2356 
     2357 	     return;
     2358 
     2359 	end set_hangup_proc;
     2360 
     2361 /* Internal to attach_line: determine the names of the channels connected
     2362*   used for data transmission.  These are used in various messages to notify
     2363*   logs as to the lines attached for input and output.
     2364*
     2365*   We fill in the iodd_static.attach_name variable to enable the status
     2366*   request response to indicate what line is currently attached.  Cleanup
     2367*   code is necessary to restore the "*" string to this variable outside the
     2368*   driver and any time the line is unattached. */
     2369 
     2370 get_data_channel_names:
     2371 	procedure ();
     2372 
     2373 	     have_channel_names = "0"b;		/* assume failure */
     2374 
     2375 	     local_gcn.version = GET_CHANNEL_NAMES_VERSION_1;
     2376 
     2377 	     call iox_$control (ds_ptr -> driver_status.dev_out_iocbp, "get_channel_names", addr (local_gcn), code);
     2378 
     2379 	     if code = 0 then do;
     2380 		have_channel_names = "1"b;
     2381 		if static.input_driver then
     2382 		     iodd_static.attach_name = local_gcn.input_channel;
     2383 		else iodd_static.attach_name = local_gcn.output_channel;
     2384 	     end;
     2385 
     2386 	     else if code ^= imft_et_$cant_get_channel_names then
     2387 		call iodd_msg_ (NORMAL, MASTER, code, IMFT_DRIVER_,
     2388 		     "Warning: Could not determine channel names for ^a ^a ^[input^;output^] driver.",
     2389 		     static.foreign_system.name, FUNCTION_NAMES (static.function), static.input_driver);
     2390 
     2391 	     return;
     2392 
     2393 	end get_data_channel_names;
     2394 
     2395      end attach_line;
     2396 
     2397 /* Make sure request type name is valid in form and corresponds to foreign system name */
     2398 
     2399 validate_request_type:
     2400      procedure (devp);
     2401 
     2402 dcl  devp pointer parameter;
     2403 dcl  req_type_site character (32);
     2404 
     2405 	if substr (devp -> driver_status.req_type_label, 1, 3) = "To_" then
     2406 	     req_type_site = substr (before (devp -> driver_status.req_type_label, "."), 4);
     2407 	else if substr (devp -> driver_status.req_type_label, 1, 5) = "From_" then
     2408 	     req_type_site = substr (before (devp -> driver_status.req_type_label, "."), 6);
     2409 	else do;
     2410 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_, "request type ""^a"" is not in correct format.",
     2411 		devp -> driver_status.req_type_label);
     2412 	     go to RETURN_FROM_INIT;
     2413 	end;
     2414 
     2415 	if req_type_site ^= static.foreign_system.name then do;
     2416 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
     2417 		"Request type (^a) does not correspond to foreign system (^a).", devp -> driver_status.req_type_label,
     2418 		static.foreign_system.name);
     2419 	     go to RETURN_FROM_INIT;
     2420 	end;
     2421      end validate_request_type;
     2422 
     2423 /* Validates that a value is either "yes" or "no" and returns true or false accordingly */
     2424 
     2425 yes_no_p:
     2426      procedure (P_keyword, P_value) returns (bit (1) aligned);
     2427 
     2428 dcl  (P_keyword, P_value) character (*) parameter;
     2429 
     2430 	if P_value = "y" then P_value = "yes";
     2431 	if P_value = "n" then P_value = "no";
     2432 
     2433 	if (P_value ^= "yes") & (P_value ^= "no") then do;
     2434 	     call iodd_msg_ (ERROR, MASTER, 0, IMFT_DRIVER_,
     2435 		"The value of the ""^a"" keyword must be ""yes"" or ""no""; not ""^a"".", P_keyword, P_value);
     2436 	     go to RETURN_FROM_INIT;
     2437 	end;
     2438 
     2439 	return (P_value = "yes");
     2440 
     2441      end yes_no_p;
     2442 
     2443 /* Parameters */
     2444 
     2445 dcl  P_stat_p pointer parameter;			/* init: -> iodd_static for this driver */
     2446 
     2447 dcl  P_source fixed binary parameter;			/* command: source of the command (master/slave) */
     2448 dcl  P_state fixed binary parameter;			/* command: current state of driver (normal/quit/request) */
     2449 dcl  P_arglist_ptr pointer parameter;			/* command: -> structure defining command and arguments */
     2450 dcl  P_code fixed binary (35) parameter;		/* command: status code */
     2451 
     2452 dcl  P_condition_info_ptr pointer parameter;		/* default_handler: -> description of the condition */
     2453 
     2454 
     2455 /* Remaining declarations */
     2456 
     2457 dcl  major_args character (major_args_lth) unaligned based (major_args_ptr);
     2458 dcl  major_args_lth fixed binary (21);
     2459 dcl  major_args_ptr pointer;
     2460 
     2461 dcl  major_args_path character (204) static;		/* need room for archive component */
     2462 dcl  major_args_dirname character (168) static;
     2463 dcl  (major_args_ename, major_args_component) character (32) static;
     2464 dcl  major_args_bc fixed binary (24) static;
     2465 
     2466 dcl  system_area area based (system_area_ptr);
     2467 dcl  system_area_ptr pointer static;
     2468 
     2469 dcl  1 arglist aligned based (arglist_ptr),		/* structure defining a command and it's arguments */
     2470        2 max_tokens fixed binary,			/* # of tokens allocated */
     2471        2 n_tokens fixed binary,			/* # of tokens in command line */
     2472        2 command character (64) varying,
     2473        2 arguments (arglist.n_tokens - 1) character (64) varying;
     2474 dcl  arglist_ptr pointer;
     2475 
     2476 dcl  1 local_terminal_info aligned like terminal_info automatic;
     2477 
     2478 dcl  1 trsi aligned like tty_read_status_info;
     2479 
     2480 dcl  1 event_channel_list aligned based,		/* list of event channels associated with driver */
     2481        2 n_channels fixed binary,
     2482        2 channels (12) fixed binary (71);
     2483 
     2484 dcl  1 hangup_info aligned,				/* for "hangup_proc" control order */
     2485        2 entry entry () variable,
     2486        2 data_ptr pointer,
     2487        2 priority fixed binary;
     2488 
     2489 dcl  1 local_icri aligned like icri static;		/* for synchronization */
     2490 
     2491 dcl  1 local_gcn aligned like get_channel_names static;	/* to get input/output channel names */
     2492 dcl  have_channel_names bit (1) aligned static;
     2493 
     2494 dcl  1 dma like dial_manager_arg static;
     2495 dcl  1 ev_wait_info static like event_wait_info;
     2496 
     2497 dcl  1 status_flags aligned static,
     2498        (
     2499        2 dialed_up bit (1),
     2500        2 hung_up bit (1),
     2501        2 control bit (1),
     2502        2 pad bit (33)
     2503        ) unal;
     2504 
     2505 dcl  ds_ptr pointer static;				/* -> driver_status for this driver */
     2506 dcl  devp pointer static;				/* -> driver_status for a minor device */
     2507 dcl  rd_ptr pointer static;				/* -> request_descriptor of current request */
     2508 dcl  p pointer;
     2509 dcl  i fixed binary;
     2510 
     2511 dcl  max_access_class_string character (256) static;
     2512 dcl  max_access_class_octal character (32) aligned static;
     2513 dcl  min_access_class_string character (256) static;
     2514 dcl  min_access_class_octal character (32) aligned static;
     2515 dcl  (local_explicit_ceiling, foreign_explicit_ceiling) bit (72) aligned static;
     2516 dcl  (local_explicit_floor, foreign_explicit_floor) bit (72) aligned static;
     2517 dcl  (local_explicit_ceiling_given, local_explicit_floor_given) bit (1) aligned static;
     2518 dcl  foreign_system_version float binary static;
     2519 
     2520 dcl  keyword_value character (32) static;
     2521 
     2522 dcl  (code, ignore_code, saved_code) fixed binary (35) static;
     2523 dcl  my_ring fixed binary (3);
     2524 
     2525 dcl  test_initiate_entry entry () variable;
     2526 
     2527 dcl  character_buffer character (256) static;		/* for transport connection protocol */
     2528 dcl  temp_attach_description character (256) static;
     2529 dcl  trigger_loop_count fixed bin static;
     2530 dcl  source fixed binary static;			/* source of the command being processed */
     2531 dcl  value fixed binary (35) static;
     2532 
     2533 dcl  condition character (32) static;
     2534 
     2535 dcl  (input_buffer, output_buffer) character (2048) static; /* for reading/writing commands/replies */
     2536 dcl  (saved_test_entry, send_logout_record) bit (1) aligned static;
     2537 
     2538 dcl  1 static aligned like imft_driver_info static;	/* complete description of this driver */
     2539 dcl  1 static_fis_info aligned like fis_info static;	/* used by imft_find_input_switch_ */
     2540 dcl  static_pause_time fixed binary (71) static;		/* # of seconds to pause between requests */
     2541 
     2542 dcl  attachment_count fixed binary static initial (0);
     2543 dcl  attachment_count_pic picture "999" static;
     2544 
     2545 dcl  IMFT_DRIVER_ character (32) static options (constant) initial ("imft_driver_");
     2546 dcl  CURRENT_IMFT_VERSION character (3) static options (constant) initial ("4.0");
     2547 
     2548 dcl  FIVE_MINUTES fixed binary static options (constant) initial (300);
     2549 dcl  FIVE_SECONDS fixed binary (71) static options (constant) initial (5);
     2550 dcl  MAX_TRIGGER_LOOP_COUNT fixed binary static options (constant) initial (20);
     2551 dcl  NO_ERROR fixed binary (35) static options (constant) initial (0);
     2552 dcl  ONE_MINUTE fixed binary static options (constant) initial (60);
     2553 
     2554 dcl  NL character (1) static options (constant) initial ("
     2555 ");
     2556 dcl  WHITESPACE character (5) static options (constant) initial (" 	
     2557 ");						/* SP HT NL VT FF */
     2558 
     2559 dcl  INITIAL_IMFT_RATE fixed binary static options (constant) initial (4800);
     2560 
     2561 dcl  LISTEN_COMMAND_LEVEL fixed binary static options (constant) initial (1);
     2562 						/* command entered from iodd_listen_ with a ready device */
     2563 
     2564 dcl  (
     2565      error_table_$ai_outside_common_range,
     2566      error_table_$action_not_performed,
     2567      error_table_$bad_conversion,
     2568      error_table_$fatal_error,
     2569      error_table_$inconsistent,
     2570      error_table_$noarg,
     2571      error_table_$unimplemented_version
     2572      ) fixed binary (35) external;
     2573 
     2574 dcl  (
     2575      imft_et_$cant_get_channel_names,
     2576      imft_et_$computed_ceiling_mismatch,
     2577      imft_et_$explicit_ceiling_mismatch,
     2578      imft_et_$explicit_floor_mismatch,
     2579      imft_et_$non_matching_ids,
     2580      imft_et_$non_matching_passwords,
     2581      imft_et_$non_matching_versions,
     2582      imft_et_$process_authorization_too_low,
     2583      imft_et_$reply_pending
     2584      ) fixed binary (35) external;
     2585 
     2586 dcl  add_char_offset_ entry (ptr, fixed bin (21)) returns (ptr) reducible;
     2587 dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
     2588 dcl  aim_check_$greater entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
     2589 dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
     2590 dcl  compute_common_aim_ceiling_ entry (pointer, bit (72) aligned, pointer, bit (72) aligned, fixed binary (35));
     2591 dcl  continue_to_signal_ entry (fixed binary (35));
     2592 dcl  convert_aim_attributes_ entry (bit (72) aligned, character (32) aligned);
     2593 dcl  convert_authorization_$from_string entry (bit (72) aligned, character (*), fixed binary (35));
     2594 dcl  convert_authorization_$to_string_short entry (bit (72) aligned, character (*), fixed binary (35));
     2595 dcl  convert_dial_message_$return_io_module
     2596 	entry (fixed bin (71), char (*), char (*), fixed bin, 1 aligned, 2 bit (1) unal, 2 bit (1) unal, 2 bit (1) unal,
     2597 	2 bit (33) unal, fixed bin (35));
     2598 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
     2599 dcl  dial_manager_$allow_dials entry (ptr, fixed bin (35));
     2600 dcl  dial_manager_$shutoff_dials entry (ptr, fixed bin (35));
     2601 dcl  expand_pathname_$component entry (character (*), character (*), character (*), character (*), fixed binary (35));
     2602 dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
     2603 dcl  get_authorization_ entry () returns (bit (72) aligned);
     2604 dcl  get_ring_ entry () returns (fixed bin (3));
     2605 dcl  get_system_aim_attributes_ entry (pointer, character (8), pointer, fixed binary (35));
     2606 dcl  get_system_free_area_ entry () returns (pointer);
     2607 dcl  imft_convert_status_code_$decode entry (fixed binary (35)) returns (fixed binary (35));
     2608 dcl  imft_convert_status_code_$encode entry (fixed binary (35)) returns (fixed binary (35));
     2609 dcl  imft_pnt_interface_$get_system_password entry (character (*), character (8) aligned, fixed binary (35));
     2610 dcl  imft_receive_object_ entry (pointer, pointer, fixed binary (35));
     2611 dcl  imft_transmit_object_ entry (pointer, pointer, pointer, fixed binary (35));
     2612 dcl  imft_transmit_object_$abort_running_request entry (character (*));
     2613 dcl  initiate_file_$component
     2614 	entry (character (*), character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35));
     2615 dcl  iodd_command_processor_ entry (fixed binary, fixed binary, character (*), fixed binary (35));
     2616 dcl  iodd_hangup_ entry (ptr);
     2617 dcl  iodd_listen_ entry (pointer);
     2618 dcl  iodd_msg_ entry () options (variable);
     2619 dcl  iodd_parse_$args entry (char (*) var, char (*)) returns (char (256) var);
     2620 dcl  iodd_quit_handler_ entry ();
     2621 dcl  iodd_quit_handler_$command_level entry ();
     2622 dcl  iox_$attach_ioname entry (character (*), pointer, character (*), fixed binary (35));
     2623 dcl  iox_$close entry (pointer, fixed binary (35));
     2624 dcl  iox_$control entry (pointer, character (*), pointer, fixed binary (35));
     2625 dcl  iox_$detach_iocb entry (pointer, fixed binary (35));
     2626 dcl  iox_$destroy_iocb entry (ptr, fixed bin (35));
     2627 dcl  iox_$open entry (pointer, fixed binary, bit (1) aligned, fixed binary (35));
     2628 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
     2629 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
     2630 dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
     2631 dcl  ipc_$decl_ev_wait_chn entry (fixed bin (71), fixed bin (35));
     2632 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
     2633 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
     2634 dcl  pathname_$component entry (character (*), character (*), character (*)) returns (character (194));
     2635 dcl  requote_string_ entry (character (*)) returns (character (*));
     2636 dcl  system_privilege_$initiate entry ();
     2637 dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
     2638 dcl  timer_manager_$sleep entry (fixed binary (71), bit (2));
     2639 dcl  translate_aim_attributes_ entry (pointer, bit (72) aligned, pointer, bit (72) aligned, fixed binary (35));
     2640 
     2641 dcl  (cleanup, daemon_idle, daemon_logout, daemon_new_device, daemon_slave_logout, linkage_error, imft_debug_,
     2642      imft_remote_logout_, imft_resynchronize_driver_, no_coord, quit, re_init, resume) condition;
     2643 
     2644 dcl  (addr, before, clock, convert, currentsize, divide, index, length, ltrim, null, rtrim, substr) builtin;
     2645 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     2646 
     2647 
  2     1 /* BEGIN INCLUDE FILE ... aim_attributes.incl.pl1 */
  2     2 /* Created:  July 1982 by G. Palter */
  2     3 
  2     4 /* Definition of the AIM attributes on a Multics system */
  2     5 
  2     6 dcl  1 aim_attributes aligned based (aim_attributes_ptr),
  2     7        2 version character (8) unaligned,
  2     8        2 access_class_ceiling bit (72),			/* maximum access class allowed on the system */
  2     9        2 levels (0 : 7),				/* the sensitivity levels */
  2    10          3 long_name character (32) unaligned,
  2    11          3 short_name character (8) unaligned,
  2    12        2 categories (18),				/* the access categories */
  2    13          3 long_name character (32) unaligned,
  2    14          3 short_name character (8) unaligned;
  2    15 
  2    16 dcl  aim_attributes_ptr pointer;
  2    17 
  2    18 dcl  AIM_ATTRIBUTES_VERSION_1 character (8) static options (constant) initial ("aima_001");
  2    19 
  2    20 /* END INCLUDE FILE ... aim_attributes.incl.pl1 */
     2648 
     2649 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     2650 
     2651 
  4     1 /* BEGIN INCLUDE FILE ... dial_manager_arg.incl.pl1 */
  4     2 
  4     3 /* Modified by E. N. Kittlitz 11/80 to add reservation string, move dial-out
  4     4*   destination from dial_qualifier, add dial_message.
  4     5*   Modified by Robert Coren 4/83 to add required access class stuff.
  4     6*   Modified 1984-08-27 BIM for V4, privileged_operation.
  4     7**/
  4     8 
  4     9 
  4    10 dcl  dial_manager_arg_version_2 fixed bin internal static initial (2) options (constant);
  4    11 dcl  dial_manager_arg_version_3 fixed bin internal static initial (3) options (constant);
  4    12 dcl  dial_manager_arg_version_4 fixed bin internal static initial (4) options (constant);
  4    13 
  4    14 dcl 1 dial_manager_arg based aligned,
  4    15     2 version fixed bin,				/* = 4 */
  4    16     2 dial_qualifier char (22),			/* identify different processes with same process group id */
  4    17     2 dial_channel fixed bin (71),			/* event wait channel */
  4    18     2 channel_name char (32),				/* channel name for privileged attach */
  4    19 						/* limit of version 1 structure */
  4    20     2 dial_out_destination char (32),			/* dial-out destination (e.g. phone_no) */
  4    21     2 reservation_string char (256),			/* reservation string */
  4    22     2 dial_message fixed bin (71),			/* OUTPUT: A.S. message received by dial_manager_ */
  4    23 						/* limit of version 2 structure */
  4    24     2 access_class bit (72),				/* access class to be associated with the attachment */
  4    25     2 flags aligned,
  4    26      3 access_class_required bit (1) unaligned,		/* indicates whether to enforce access_class */
  4    27      3 privileged_operation bit (1) unaligned,		/* for accept_dials, accepts dials from */
  4    28 						/* system_low:access_class */
  4    29 						/* no effect on other operations yet. */
  4    30      3 mbz bit (34) unaligned;			/* must be zero */
  4    31 
  4    32 /* END INCLUDE FILE ... dial_manager_arg.incl.pl1 */
     2652 
     2653 
  5     1 /* BEGIN INCLUDE FILE ... driver_ptr_list.incl.pl1   */
  5     2 
  5     3 /* This is a list of pointers to the driver status segments used by this process */
  5     4 
  5     5 
  5     6 
  5     7 dcl list_ptr pointer;		/* should be set to iodd_static.driver_list_ptr */
  5     8 
  5     9 dcl 1 driver_ptr_list based(list_ptr),
  5    10        2 number fixed bin,		/* number of pointer entries */
  5    11        2 list_pad fixed bin,		/* pad to even word boundry */
  5    12        2 stat_seg(0 refer(driver_ptr_list.number)),
  5    13           3 stat_segp ptr;		/* pointer to driver status seg(i) */
  5    14 
  5    15 
  5    16 /* END INCLUDE FILE ... driver_ptr_list.incl.pl1  */
     2654 
     2655 
  6     1 /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  6     7*     Ancient History
  6     8*     Coded by Robert S. Coren August 1973
  6     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  6    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  6    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  6    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  6    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  6    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  6    16*     to denote accounting ^= nothing.
  6    17*                                                   END HISTORY COMMENTS */
  6    18 
  6    19 
  6    20 /* status data for a logical device driver */
  6    21 
  6    22 /* format: style4 */
  6    23 
  6    24 dcl  driver_status_ptr ptr;
  6    25 dcl  1 driver_status aligned based (driver_status_ptr),
  6    26        2 req_type_label char (32),			/* string to describe the request type */
  6    27        2 dev_name_label char (32),			/* string to describe the device */
  6    28        2 device_id char (32),				/* minor device name used by this logical driver */
  6    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  6    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  6    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  6    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  6    33        2 request_pending bit (36),			/* locking word for communication with coord */
  6    34 						/* 0 = ready for a request  */
  6    35 						/* driver pid = don't bug me */
  6    36 						/* coord  pid = got a request */
  6    37        2 status_flags,
  6    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  6    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  6    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  6    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  6    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  6    43          3 pad bit (31) unal,
  6    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  6    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  6    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  6    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  6    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  6    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  6    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  6    51 						/* for this logical driver */
  6    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  6    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  6    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  6    55        2 dev_out_stream char (32),			/* output stream for minor device */
  6    56        2 dev_in_stream char (32),			/* input stream for minor device */
  6    57        2 elem_size fixed bin,				/* element size for the stream */
  6    58        2 message_type fixed bin,			/* expected format of user request */
  6    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  6    60        2 forms_validation_ptr ptr,			/* forms validation data */
  6    61        2 dev_ptr1 ptr,				/* another one */
  6    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  6    63        2 dev_fb2 fixed bin,				/* and another */
  6    64        2 dev_fb3 fixed bin,				/* and another */
  6    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  6    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  6    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  6    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  6    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  6    70        2 generic_type char (32),			/* generic type of this minor device */
  6    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  6    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  6    73        2 desc_pad (13) fixed bin,
  6    74        2 message fixed bin;				/* place-holder for copy of request message */
  6    75 
  6    76 
  6    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     2656 
     2657 
  7     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
  7     2 
  7     3 /* ipc_$block wait list with one channel
  7     4*
  7     5*   Written 9-May-79 by M. N. Davidoff.
  7     6**/
  7     7 
  7     8      declare 1 event_wait_channel   aligned,
  7     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
  7    10 	     2 pad	      bit (36),
  7    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
  7    12 
  7    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
     2658 
  8     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
  8     2 
  8     3 /* T. Casey, May 1978 */
  8     4 
  8     5 dcl  event_wait_info_ptr ptr;
  8     6 
  8     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
  8     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  8     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  8    10     2 sender bit (36),				/* process id of sender */
  8    11     2 origin,
  8    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  8    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  8    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
  8    15 
  8    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
     2659 
     2660 
  9     1 /* BEGIN INCLUDE FILE ... _imft_cri.incl.pl1 */
  9     2 /* Created:  April 1982 by G. Palter */
  9     3 
  9     4 /* Data structure used by read/write_command/reply_record and get_abort_info control orders */
  9     5 
  9     6 dcl  1 icri aligned based (icri_ptr),
  9     7        2 version character (8),
  9     8        2 timeout fixed binary (35),			/* # of seconds to wait for read/write to complete */
  9     9        2 pad bit (36),
  9    10        2 record_info,
  9    11          3 record_ptr pointer,			/* -> record to write or buffer where it will be read */
  9    12          3 record_type fixed binary,			/* type of record read/written */
  9    13          3 record_max_lth fixed binary (21),		/* size of buffer when reading records */
  9    14          3 record_lth fixed binary (21);		/* length of record read/written in characters */
  9    15 
  9    16 dcl  icri_ptr pointer;
  9    17 
  9    18 dcl  ICRI_VERSION_1 character (8) static options (constant) initial ("cri_1.00");
  9    19 
  9    20 /* END INCLUDE FILE ... _imft_cri.incl.pl1 */
     2661 
     2662 
 10     1 /* BEGIN INCLUDE FILE ... _imft_driver_info.incl.pl1 */
 10     2 
 10     3 /* Created:  April 1982 by G. Palter */
 10     4 /* Modified: July 1982 by G. Palter for true AIM support */
 10     5 /* Modified: February 1983 by Robert Coren to add single_switch and old_version flags */
 10     6 /* Modified: August 1983 by Robert Coren to add access_floor */
 10     7 
 10     8 /* format: style4 */
 10     9 
 10    10 
 10    11 /****^  HISTORY COMMENTS:
 10    12*  1) change(87-11-15,Oke), approve(88-08-01,MCR7948), audit(88-10-14,Farley),
 10    13*     install(88-10-14,MR12.2-1165):
 10    14*     Added variables to support in-dial and out-dial driver configurations.
 10    15*  2) change(88-07-12,Beattie), approve(88-08-01,MCR7948),
 10    16*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
 10    17*     Add imft_version to local and foreign system structures.
 10    18*                                                   END HISTORY COMMENTS */
 10    19 
 10    20 
 10    21 /* Description of an IMFT driver process */
 10    22 
 10    23 dcl  1 imft_driver_info aligned based (imft_driver_info_ptr),
 10    24        2 function fixed binary,			/* type of driver (file transfer) */
 10    25        2 flags,
 10    26          3 input_driver bit (1) unaligned,		/* ON => this driver is receiving input */
 10    27          3 debug_mode bit (1) unaligned,		/* ON => someone is debugging the driver in test mode */
 10    28          3 automatic_operation bit (1) unaligned,		/* ON => running without operator intervention */
 10    29          3 auto_go bit (1) unaligned,			/* ON => start processing output requests immediately */
 10    30          3 auto_receive bit (1) unaligned,		/* ON => start receiving input requests immediately */
 10    31          3 single_switch bit (1) unaligned,		/* ON => same switch for input and output */
 10    32          3 old_version bit (1) unaligned,		/* ON => foreign system uses old (HASP-only) software */
 10    33          3 copy_data bit (1) unaligned,			/* ON => imft_io_ will copy all data records to vfiles */
 10    34          3 remote_request_allowed bit (1) unaligned,	/* ON => foreign system is allowed to request transfers */
 10    35          3 explicit_access_required bit (1) unaligned,	/* ON => remote request requires explicit ACL term for driver */
 10    36          3 idle_line_drop bit (1) unaligned,		/* ON => drop when idle and dialup when something to do */
 10    37          3 validate_system_id bit (1) unaligned,		/* ON => validate foreign system ident/pass in PNT */
 10    38          3 debug_connect bit (1) unaligned,		/* ON => display data during connection phase in master log */
 10    39          3 dial_service bit (1) unaligned,		/* ON => connect only when there are requests to transfer */
 10    40          3 pad bit (22) unaligned,
 10    41        2 sleep_time fixed bin,			/* connect retry wait */
 10    42        2 idle_delay_count fixed bin,			/* number of idles til line drop */
 10    43        2 idle_delay fixed bin,			/* the idle counter */
 10    44        2 min_time_to_log fixed bin (35),		/* transfer must take at least this time to put est time in log */
 10    45        2 io_info,					/* data required to connect to the remote system */
 10    46          3 input_attach_description character (256) unaligned,
 10    47          3 output_attach_description character (256) unaligned,
 10    48          3 in_dial_qualifier character (256) unaligned,
 10    49          3 out_dial_text character (256) unaligned,
 10    50          3 trigger_text character (256) unaligned,
 10    51        2 local_system,				/* our system's description ... */
 10    52          3 name character (32) unaligned,		/* ... system name */
 10    53          3 password character (8) aligned,		/* ... card input password */
 10    54          3 imft_version character (8),			/* ... version of driver software */
 10    55          3 access_ceiling bit (72),			/* ... maximum AIM level permitted for transfer */
 10    56          3 access_floor bit (72),			/* ... minimum AIM level permitted for transfer */
 10    57          3 aim_attributes_ptr pointer,			/* ... -> definition of AIM attributes on system */
 10    58        2 foreign_system,				/* descirption of foreign system (see above) */
 10    59          3 name character (32) unaligned,
 10    60          3 password character (8) aligned,
 10    61          3 imft_version character (8),
 10    62          3 access_ceiling bit (72),
 10    63          3 access_floor bit (72),
 10    64          3 aim_attributes_ptr pointer;
 10    65 
 10    66 dcl  imft_driver_info_ptr pointer;
 10    67 
 10    68 
 10    69 /* Presently available types of IMFT driver (with short descriptions) */
 10    70 
 10    71 dcl  FILE_TRANSFER initial (1)			/* file transfer driver */
 10    72 	fixed binary static options (constant);
 10    73 
 10    74 dcl  FUNCTION_NAMES (1) character (32) static options (constant) initial (
 10    75 	"file transfer");
 10    76 
 10    77 /* END INCLUDE FILE ... _imft_driver_info.incl.pl1 */
     2663 
     2664 
 11     1 /* BEGIN INCLUDE FILE ... _imft_fis_info.incl.pl1 */
 11     2 /* Created:  April 1982 by G. Palter */
 11     3 
 11     4 /* Describes the I/O switches on which input is expected: no more than 10 switches may be specified (due to PL/I
 11     5*   restrictions on static storage) */
 11     6 
 11     7 dcl  1 fis_info aligned based (fis_info_ptr),
 11     8        2 version character (8),
 11     9        2 n_iocbs fixed binary,			/* # of I/O switches */
 11    10        2 iocbs (10) pointer,				/* -> the I/O switches */
 11    11        2 wait_list,					/* ipc_$block input structure */
 11    12          3 n_channels fixed binary,			/* # of IPC channels */
 11    13          3 pad bit (36),
 11    14          3 event_channels (10) fixed binary (71);		/* the channels */
 11    15 
 11    16 dcl  fis_info_ptr pointer;
 11    17 
 11    18 dcl  FIS_INFO_VERSION_1 character (8) static options (constant) initial ("fis_1.00");
 11    19 
 11    20 /* END INCLUDE FILE ... _imft_fis_info.incl.pl1 */
     2665 
     2666 
 12     1 /* BEGIN INCLUDE FILE ... _imft_ft_request.incl.pl1 */
 12     2 
 12     3 /* Created:  April 1982 by G. Palter */
 12     4 /* Modified: March 1983 by Robert Coren, for requests for remote transfer */
 12     5 
 12     6 
 12     7 /****^  HISTORY COMMENTS:
 12     8*  1) change(88-06-22,Beattie), approve(88-08-01,MCR7948),
 12     9*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
 12    10*     Add flags to support extend, update and delete operations.
 12    11*                                                   END HISTORY COMMENTS */
 12    12 
 12    13 
 12    14 /* IMFT file transfer request definition */
 12    15 
 12    16 dcl 1 ft_request aligned based (ft_request_ptr),
 12    17       2 header like queue_msg_hdr,
 12    18       2 request,					/* see _imft_ft_commands.incl.pl1 */
 12    19         3 version character (8),
 12    20         3 foreign_user character (32) unaligned,		/* Person.Project at other Multics for reload access check */
 12    21         3 foreign_dirname character (168) unaligned,	/* where to put the branch on the other system */
 12    22         3 foreign_ename character (32) unaligned,		/* ... */
 12    23         3 flags,
 12    24 	4 foreign_user_given bit (1) unaligned,		/* ON => forreign_user different from local user */
 12    25 	4 foreign_path_given bit (1) unaligned,		/* ON => foreign pathname different from local */
 12    26 	4 directory_creation_mode bit (2) unaligned,	/* controls whether directories are replaced/merged */
 12    27 	4 remote_transfer bit (1) unaligned,		/* ON => request for transfer from foreign system */
 12    28 	4 include_files bit (1) unaligned,		/* ON => match files when interpreting starname */
 12    29 	4 include_subtrees bit (1) unaligned,		/* ON => match subtrees when interpreting starname */
 12    30 	4 chase_control bit (2) unaligned,		/* controls chasing of links when submitting remote request */
 12    31 	4 delete bit (1) unaligned,			/* delete source object after good transfer */
 12    32 	4 extend bit (1) unaligned,			/* place this data at end of current segment */
 12    33 	4 update bit (1) unaligned,			/* replace contents of current segment with this data */
 12    34 	4 pad bit (24) unaligned;
 12    35 
 12    36 dcl  ft_request_ptr pointer;
 12    37 
 12    38 dcl  FT_REQUEST_VERSION_1 character (8) static options (constant) initial ("ftr_1.00");
 12    39 
 12    40 dcl  FT_GENERIC_TYPE character (32) static options (constant) initial ("imft");
 12    41 dcl  FT_MESSAGE_TYPE fixed binary static options (constant) initial (5);
 12    42 
 12    43 dcl (REPLACE_DIRECTORIES	initial ("10"b),		/* replace entry on target if namedup and source is a dir */
 12    44      MERGE_DIRECTORIES	initial ("11"b))		/* merge target and source dirs; replace if target not dir */
 12    45 	bit (2) aligned static options (constant);
 12    46 
 12    47 dcl (DEFAULT_CHASE		initial ("00"b),		/* chase non-starnames; don't chase starnames */
 12    48      NEVER_CHASE		initial ("01"b),		/* never chase any links */
 12    49      ALWAYS_CHASE		initial ("10"b))		/* always chase links */
 12    50 	bit (2) aligned static options (constant);
 12    51 
 12    52 /* END INCLUDE FILE ... _imft_ft_request.incl.pl1 */
     2667 
     2668 
 13     1 /* ***********************************************************
 13     2*   *                                                         *
 13     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
 13     4*   *                                                         *
 13     5*   *********************************************************** */
 13     6 /* BEGIN INCLUDE FILE ... _imft_get_channel_names.incl.pl1 */
 13     7 /* Created:  July 1982 by G. Palter */
 13     8 
 13     9 /* Data structure used by imft_io_ to return names of channels used for data transmission */
 13    10 
 13    11 dcl  1 get_channel_names aligned based (get_channel_names_ptr),
 13    12        2 version character (8),
 13    13        2 input_channel character (32) unaligned,
 13    14        2 output_channel character (32) unaligned;
 13    15 
 13    16 dcl  get_channel_names_ptr pointer;
 13    17 
 13    18 dcl  GET_CHANNEL_NAMES_VERSION_1 character (8) static options (constant) initial ("igcn_001");
 13    19 
 13    20 /* END INCLUDE FILE ... _imft_get_channel_names.incl.pl1 */
     2669 
     2670 
 14     1 /* BEGIN INCLUDE FILE ... _imft_std_commands.incl.pl1 */
 14     2 
 14     3 /* Created:  April 1982 by G. Palter */
 14     4 /* Modified: July 1982 by G. Palter to add true AIM support */
 14     5 /* Modified: March 1983 by Robert Coren to add local_io_error abort code */
 14     6 /* Modified: August 1983 by Robert Coren to add access_floor to AIM2 record */
 14     7 
 14     8 
 14     9 /****^  HISTORY COMMENTS:
 14    10*  1) change(88-08-12,Beattie), approve(88-08-01,MCR7948),
 14    11*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
 14    12*     Add imft_version to sync_record structure to inform other driver of this
 14    13*     driver's version of the IMFT software.
 14    14*                                                   END HISTORY COMMENTS */
 14    15 
 14    16 
 14    17 /* Standard command and reply control records used by IMFT drivers */
 14    18 
 14    19 
 14    20 /* Standard command/reply types */
 14    21 
 14    22 dcl (IMFT_DATA		initial (0),		/* data record */
 14    23      IMFT_SYNC1		initial (1),		/* first half of synchronization sequence */
 14    24      IMFT_SYNC2		initial (2),		/* second half of synchronization sequence */
 14    25      IMFT_ABORT		initial (3),		/* abort the current operation */
 14    26      IMFT_LOGOUT		initial (4),		/* one side requests that the other logout */
 14    27      IMFT_RESYNCHRONIZE	initial (5),		/* reply requesting resynchronization */
 14    28      IMFT_AIM1		initial (6),		/* first half of establsihing AIM ceiling */
 14    29      IMFT_AIM2		initial (7))		/* second half of establishing AIM ceiling */
 14    30 	fixed binary (7) unaligned unsigned static options (constant);
 14    31 
 14    32 
 14    33 /* Synchronization control record: sent as the SYNC1 command and reply and as the SYNC2 command; the SYNC2 reply is a
 14    34*   zero-length record which is only sent if the SYNC2 command indicates success */
 14    35 
 14    36 dcl  1 sync_record aligned based (sync_record_ptr),
 14    37        2 my_userid character (32),			/* Person_id of system sending this record */
 14    38        2 my_password character (8),			/* scrambled card input passowrd */
 14    39        2 code fixed binary (35),			/* non-zero code => validation failed; break the connection */
 14    40        2 correct_userid character (32),			/* Person_id that was expected if incorrect */
 14    41        2 imft_version character (8);			/* version of IMFT being used by driver */
 14    42 
 14    43 dcl  sync_record_ptr pointer;
 14    44 
 14    45 
 14    46 /* Abort command record */
 14    47 
 14    48 dcl  1 abort_command aligned based (abort_command_ptr),
 14    49        2 reason fixed binary,				/* reason to abort this operation */
 14    50        2 code fixed binary (35);			/* real error code for an I/O error */
 14    51 
 14    52 dcl  abort_command_ptr pointer;
 14    53 
 14    54 dcl (IMFT_ABORT_IO_ERROR	initial (1),		/* I/O error */
 14    55      IMFT_ABORT_ABORTED	initial (2),		/* random fault */
 14    56      IMFT_ABORT_DEFERRED	initial (3),		/* operator deferred request */
 14    57      IMFT_ABORT_CANCELLED	initial (4),		/* operator cancelled request */
 14    58      IMFT_ABORT_SAVED	initial (5),		/* operator saved the request silently */
 14    59      IMFT_ABORT_RESTARTED	initial (6),		/* operator restarted the request */
 14    60      IMFT_ABORT_LOCAL_IO_ERROR initial (7))		/* I/O error on local system */
 14    61 	fixed binary static options (constant);
 14    62 
 14    63 
 14    64 /* AIM ceiling control records: the AIM1 command and reply are the aim_attributes structures defining the attributes on
 14    65*   the system; the AIM2 command/reply record follows */
 14    66 
 14    67 dcl  1 aim2_record aligned based (aim2_record_ptr),
 14    68        2 code fixed binary (35),			/* non-zero => AIM ceiling can not be established */
 14    69        2 computed_ceiling bit (72),			/* ceiling computed by other system (before translation) */
 14    70        2 computed_floor bit (72),			/* floor computed by other system (before translation) */
 14    71        2 flags unaligned,
 14    72          3 explicit_ceiling_given bit (1),		/* ON => an explicit access ceiling follows */
 14    73          3 explicit_floor_given bit (1),		/* ON => an explicit access floor follows */
 14    74          3 pad bit (34),
 14    75        2 explicit_ceiling bit (72),			/* the explicitly requested ceiling (before translation) */
 14    76        2 explicit_floor bit (72);			/* the explicitly requested floor (before translation) */
 14    77 
 14    78 /* The following version of the structure is used for pre-version 3.0 IMFT */
 14    79 
 14    80 dcl  1 v2_aim2_record aligned based (aim2_record_ptr),
 14    81        2 code fixed binary (35),			/* non-zero => AIM ceiling can not be established */
 14    82        2 computed_ceiling bit (72),			/* ceiling computed by other system (before translation) */
 14    83        2 explicit_ceiling_given bit (1),		/* ON => an explicit access ceiling follows */
 14    84        2 explicit_ceiling bit (72);			/* the explicitly requested ceiling (before translation) */
 14    85 
 14    86 dcl  aim2_record_ptr pointer;
 14    87 
 14    88 /* END INCLUDE FILE ... _imft_std_commands.incl.pl1 */
     2671 
     2672 
 15     1 /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
 15     2 
 15     3 
 15     4 /****^  HISTORY COMMENTS:
 15     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
 15     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 15     7*     Created.
 15     8*                                                   END HISTORY COMMENTS */
 15     9 
 15    10 /* This file contains constants used by the I/O Daemon software in various tables */
 15    11 
 15    12 /* format: style4 */
 15    13 
 15    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
 15    15 dcl  (ATTACH_TYPE_IOM init (1),
 15    16      ATTACH_TYPE_TTY init (2),
 15    17      ATTACH_TYPE_DIAL init (3),
 15    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
 15    19 
 15    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
 15    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
 15    22      CTL_ATTACH_TYPE_DIAL init (2),
 15    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
 15    24 
 15    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
 15    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
 15    27      PAPER_TYPE_SINGLE init (1),
 15    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
 15    29 
 15    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
     2673 
     2674 
 16     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
 16     2 
 16     3 
 16     4 
 16     5 /****^  HISTORY COMMENTS:
 16     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
 16     7*     Ancient History
 16     8*     Created by J. Stern, 1/20/75
 16     9*     Modified by J. C. Whitmore April 1978 for enhancements
 16    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
 16    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
 16    12*     q_group_tab
 16    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
 16    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 16    15*     Change version number to reflect changes in q_group_tab and
 16    16*     iod_device_tab for laser printer support.  Added font tables.
 16    17*                                                   END HISTORY COMMENTS */
 16    18 
 16    19 
 16    20 /* format: style4 */
 16    21 
 16    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
 16    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
 16    24        2 version char (8),				/* version of this structure */
 16    25        2 date_time_compiled fixed bin (71),
 16    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
 16    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
 16    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
 16    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
 16    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
 16    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
 16    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
 16    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
 16    34        2 text_strings_offset fixed bin (18),
 16    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
 16    36 
 16    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
 16    38 dcl  text_strings_ptr ptr;
 16    39 dcl  1 text_strings aligned based (text_strings_ptr),
 16    40        2 length fixed bin,
 16    41        2 chars char (1 refer (text_strings.length)) unaligned;
 16    42 
 16    43 /* this defines text offsets used to locate i/o daemon tables strings in
 16    44*   the text_strings structure */
 16    45 dcl  1 text_offset based,
 16    46        2 first_char fixed bin (18) unsigned unaligned,
 16    47        2 total_chars fixed bin (18) unsigned unaligned;
 16    48 
 16    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
 16    50 
 16    51 
 16    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     2675 
     2676 
 17     1 /* BEGIN INCLUDE FILE ... iodd_msg_constants.incl.pl1 */
 17     2 /* Created:  April 1982 by G. Palter */
 17     3 
 17     4 /* Types of messages which may be written by iodd_msg_ */
 17     5 
 17     6 dcl (LOG			initial (0),		/* log the message */
 17     7      NORMAL		initial (1),		/* normal message */
 17     8      ERROR		initial (2))		/* an error message */
 17     9 	fixed binary static options (constant);
 17    10 
 17    11 
 17    12 /* Where the message is to be written */
 17    13 
 17    14 dcl (BOTH			initial (0),		/* write message to master and slave */
 17    15      MASTER		initial (1),		/* write message to master only */
 17    16      SLAVE		initial (2))		/* write message to slave only */
 17    17 	fixed binary static options (constant);
 17    18 
 17    19 /* END INCLUDE FILE ... iodd_msg_constants.incl.pl1 */
     2677 
     2678 
 18     1 /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
 18     2 
 18     3 
 18     4 /****^  HISTORY COMMENTS:
 18     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
 18     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
 18     7*     Add support for logout_on_hangup option.
 18     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
 18     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 18    10*     Add head/tail_sheet entry variables and paper_type variable.
 18    11*                                                   END HISTORY COMMENTS */
 18    12 
 18    13 /* format: style4 */
 18    14 
 18    15 dcl  stat_p int static ptr;
 18    16 
 18    17 dcl  1 iodd_static based (stat_p) aligned,
 18    18 
 18    19 /*    The first part is set only once for a device driver */
 18    20 
 18    21        2 ithp ptr,					/* pointer to iod tables header */
 18    22        2 ltp ptr,					/* pointer to line table */
 18    23        2 idtp ptr,					/* pointer to device tab */
 18    24        2 mdtp ptr,					/* pointer to minor device table */
 18    25        2 qgtp ptr,					/* pointer to q_group table */
 18    26        2 dev_class_ptr ptr,				/* pointer to device class table */
 18    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
 18    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
 18    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
 18    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
 18    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
 18    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
 18    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
 18    34        2 no_coord_label label,			/* where to go for a no_coord condition */
 18    35        2 log_stream char (32),			/* stream name used for log output */
 18    36        2 master_input char (32),			/* master console input stream for commands */
 18    37        2 master_output char (32),			/* master console output stream for messages */
 18    38        2 master_out ptr,				/* master output iocbp */
 18    39        2 master_in ptr,				/* master input iocbp */
 18    40        2 log_iocbp ptr,				/* log output iocbp */
 18    41        2 error_io ptr,				/* error i/o iocbp */
 18    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
 18    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
 18    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
 18    45        2 device_dim char (32),			/* dim which drives the major device */
 18    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
 18    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
 18    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
 18    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
 18    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
 18    51        2 major_device char (32),			/* name of the major device */
 18    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
 18    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
 18    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
 18    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
 18    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
 18    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
 18    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
 18    59 
 18    60 /*    driver module entrypoints are defined by the following entry variables */
 18    61 
 18    62        2 driver_init entry variable options (variable),
 18    63        2 driver_request entry variable options (variable),
 18    64        2 driver_command entry variable options (variable),
 18    65        2 driver_default_handler entry variable options (variable),
 18    66 
 18    67 /*    entrypoints for head/tail_sheet_ entries */
 18    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
 18    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
 18    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
 18    71 
 18    72        2 paper_type fixed bin,			/* type of paper being used */
 18    73 						/* 1 = single sheet */
 18    74 						/* 2 = continuous forms */
 18    75 
 18    76 /*   The remainder of the data may be dynamic during the device driver's existence */
 18    77 
 18    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
 18    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
 18    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
 18    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
 18    82        2 current_devices fixed bin,			/* number of devices currently active in process */
 18    83        2 output_device char (32),			/* name of minor device currently in use */
 18    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
 18    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
 18    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
 18    87        2 segptr ptr,				/* ptr to current user segment being processed */
 18    88        2 flags,					/* control flags */
 18    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
 18    90          3 test_entry bit (1) unal,			/* driver test entry was called */
 18    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
 18    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
 18    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
 18    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
 18    95          3 master_hold bit (1) unal,			/* master_hold at command level */
 18    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
 18    97          3 step bit (1) unal,				/* run in step mode */
 18    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
 18    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
 18   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
 18   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
 18   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
 18   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
 18   104          3 pad bit (21) unal,				/* unused space */
 18   105        2 slave,					/* slave control device data (ctl term or remote reader) */
 18   106          3 slave_input char (32),			/* slave input stream name */
 18   107          3 slave_output char (32),			/* slave output stream name */
 18   108          3 slave_pad fixed bin,			/* allocation breakage */
 18   109          3 slave_in ptr,				/* slave input iocbp */
 18   110          3 slave_out ptr,				/* slave output iocbp */
 18   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
 18   112          3 active bit (1) unal,			/* on if there is a slave */
 18   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
 18   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
 18   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
 18   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
 18   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
 18   118          3 priv2 bit (1) unal,
 18   119          3 priv3 bit (1) unal,
 18   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
 18   121          3 slave_bit_pad bit (27) unal,			/* unused space */
 18   122        2 ctl_term,					/* control terminal data */
 18   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
 18   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
 18   125          3 ctl_pad fixed bin,				/* allocation breakage */
 18   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
 18   127          3 ctl_input char (32),			/* ctl input stream name */
 18   128          3 ctl_output char (32),			/* ctl output stream name */
 18   129          3 ctl_io char (32),				/* ctl i/o stream name */
 18   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
 18   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
 18   132          3 ctl_device char (32),			/* ctl terminal device name */
 18   133          3 form_type char (16),			/* format type if printing forms */
 18   134          3 attached bit (1) unal,			/* ctl term attached to process */
 18   135          3 forms bit (1) unal,			/* on if printing forms */
 18   136          3 pad bit (34) unal,
 18   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
 18   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
 18   139 
 18   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
     2679 
     2680 
 19     1 /* Begin include file ..... iox_modes.incl.pl1 */
 19     2 
 19     3 /* Written by C. D. Tavares, 03/17/75 */
 19     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 19     5 
 19     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 19     7     ("stream_input", "stream_output", "stream_input_output",
 19     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 19     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 19    10      "direct_input", "direct_output", "direct_update");
 19    11 
 19    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 19    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 19    14 
 19    15 dcl (Stream_input initial (1),
 19    16      Stream_output initial (2),
 19    17      Stream_input_output initial (3),
 19    18      Sequential_input initial (4),
 19    19      Sequential_output initial (5),
 19    20      Sequential_input_output initial (6),
 19    21      Sequential_update initial (7),
 19    22      Keyed_sequential_input initial (8),
 19    23      Keyed_sequential_output initial (9),
 19    24      Keyed_sequential_update initial (10),
 19    25      Direct_input initial (11),
 19    26      Direct_output initial (12),
 19    27      Direct_update initial (13)) fixed bin int static options (constant);
 19    28 
 19    29 /* End include file ..... iox_modes.incl.pl1 */
     2681 
     2682 
 20     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
 20     2 /* format: style3,idind30 */
 20     3 
 20     4 /* structure returned when message is read from a message segment */
 20     5 
 20     6 
 20     7 dcl	mseg_message_info_ptr	pointer;
 20     8 
 20     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
 20    10 	  2 version		char (8) aligned,
 20    11 	  2 message_code		fixed bin,
 20    12 	  2 control_flags		unaligned,
 20    13 	    3 own			bit (1),
 20    14 	    3 delete		bit (1),
 20    15 	    3 pad			bit (34),
 20    16 	  2 ms_ptr		ptr,		/* pointer to message */
 20    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
 20    18 	  2 ms_id			bit (72),		/* unique ID of message */
 20    19 						/* input in some cases */
 20    20 	  2 ms_access_class		bit (72),		/* message access class */
 20    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
 20    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
 20    23 	  2 sender_level		fixed bin,	/* validation level of sender */
 20    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
 20    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
 20    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
 20    27 
 20    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
 20    29 
 20    30 declare	(
 20    31 	MSEG_READ_FIRST		init (1),
 20    32 	MSEG_READ_LAST		init (2),
 20    33 	MSEG_READ_SPECIFIED		init (3),
 20    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
 20    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
 20    36 	fixed bin int static options (constant);
 20    37 
 20    38 declare  (MSEG_READ_OWN		init ("1"b),
 20    39 	MSEG_READ_DELETE		init ("01"b)
 20    40 	)			bit (36) aligned internal static options (constant);
 20    41 
 20    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     2683 
     2684 
 21     1 /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 21     2 
 21     3 /* This is the message header used for standard system queue messages, namely:
 21     4*   IO daemon requests, absentee requests, retrieval requests.
 21     5**/
 21     6 
 21     7 /* Written by Jerry Whitmore, Spring 1978.
 21     8*   Modified by T. Casey, November 1978, to add values for state.
 21     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 21    10**/
 21    11 
 21    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 21    13     2 msg_time fixed bin (71),			/* date and time of request */
 21    14     2 hdr_version fixed bin,				/* version of this declaration */
 21    15     2 dirname char (168),				/* directory name */
 21    16     2 ename char (32),				/* entry name of file requested */
 21    17     2 message_type fixed bin,				/* message format descriptor   */
 21    18 						/* 0 = absentee request        */
 21    19 						/* 1 = print request           */
 21    20 						/* 2 = punch request           */
 21    21 						/* 3 = tape request            */
 21    22 						/* 4 = retrieval request       */
 21    23     2 bit_flags,
 21    24       3 delete_sw bit (1) unal,			/* delete file when done */
 21    25       3 notify bit (1) unal,				/* user wants to be notified */
 21    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 21    27       3 padding bit (33) unal,
 21    28     2 state fixed bin,				/* stage of processing after being queued:
 21    29*						   0 = initial unprocessed state, 1 = deferred,
 21    30*						   2 = in state transition, 3 = eligible, 4 = running,
 21    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 21    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 21    33     2 std_length fixed bin,				/* length of std msg for this type */
 21    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 21    35     2 hdr_pad (3) fixed bin;
 21    36 
 21    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 21    38 
 21    39 /* Values for queue_msg_hdr.state */
 21    40 
 21    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 21    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 21    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 21    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 21    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 21    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 21    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 21    48 
 21    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     2685 
     2686 
 22     1 /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 22     2 
 22     3 /* Descriptor associated with an I/O daemon request */
 22     4 /* Coded August 1973 by Robert S. Coren */
 22     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 22     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 22     7 
 22     8 dcl  1 request_descriptor based aligned,
 22     9 	2 mseg_message_info_copy like mseg_message_info,
 22    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 22    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 22    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 22    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 22    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 22    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 22    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 22    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 22    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 22    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 22    20 	2 driver_data bit(252),	/* driver maintained data */
 22    21 	2 flags,
 22    22 	   (3 continued,		/* unfinished by one driver and given to another */
 22    23 	    3 finished,
 22    24 	    3 restarted,
 22    25 	    3 cancelled,
 22    26 	    3 dont_delete,
 22    27 	    3 saved,		/* not to be freed */
 22    28 	    3 keep_in_queue,	/* keep request in queue */
 22    29 	    3 series_restart,	/* this request is part of restarted series */
 22    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 22    31 	    3 pad bit(27) unal,
 22    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 22    33 
 22    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     2687 
     2688 
 23     1 /* BEGIN INCLUDE FILE ... set_term_type_info.incl.pl1 */
 23     2 /* Created 7/18/77 by Robert Coren */
 23     3 /* Defines info structure for set_term_type order */
 23     4 
 23     5 dcl  stti_version_1 fixed bin int static options (constant) init (1);
 23     6 dcl  sttip ptr;
 23     7 
 23     8 dcl 1 set_term_type_info aligned based (sttip),
 23     9     2 version fixed bin,
 23    10     2 name char (32) unal,
 23    11     2 flags unal,
 23    12       3 send_initial_string bit (1),
 23    13       3 set_modes bit (1),
 23    14       3 ignore_line_type bit (1),
 23    15       3 mbz bit (33);
 23    16 
 23    17 /* END INCLUDE FILE ... set_term_type_info.incl.pl1 */
     2689 
 24     1 /*  BEGIN INCLUDE FiLE ... terminal_info.incl.pl1 */
 24     2 
 24     3 /* Created 5/25/77 by J. Stern */
 24     4 
 24     5 
 24     6 dcl 1 terminal_info aligned based (terminal_info_ptr),	/* info structure for terminal_info order */
 24     7       2 version fixed bin,				/* version number of this sturcture */
 24     8       2 id char (4) unaligned,			/* terminal id from answerback */
 24     9       2 term_type char (32) unaligned,			/* terminal type name */
 24    10       2 line_type fixed bin,				/* line type number */
 24    11       2 baud_rate fixed bin,
 24    12       2 reserved (4) fixed bin;			/* reserved for future use */
 24    13 
 24    14 
 24    15 dcl  terminal_info_ptr ptr;
 24    16 dcl  terminal_info_version fixed bin int static options (constant) init (1); /* current version */
 24    17 
 24    18 
 24    19 /* END INCLUDE FILE ... terminal_info.incl.pl1 */
     2690 
     2691 
 25     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
 25     2 /* format: style2,^inddcls,idind32 */
 25     3 
 25     4 declare 1 terminate_file_switches	based,
 25     5 	2 truncate		bit (1) unaligned,
 25     6 	2 set_bc			bit (1) unaligned,
 25     7 	2 terminate		bit (1) unaligned,
 25     8 	2 force_write		bit (1) unaligned,
 25     9 	2 delete			bit (1) unaligned;
 25    10 
 25    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
 25    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
 25    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
 25    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
 25    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
 25    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
 25    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
 25    18 
 25    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     2692 
     2693 
 26     1 /* BEGIN INCLUDE FILE timer_manager_constants.incl.pl1 */
 26     2 
 26     3 /****^  HISTORY COMMENTS:
 26     4*  1) change(85-03-05,Sibert), approve(87-05-25,MCR7678),
 26     5*     audit(87-04-02,GDixon), install(87-08-04,MR12.1-1056):
 26     6*     Initially written.
 26     7*                                                   END HISTORY COMMENTS */
 26     8 
 26     9 /* Values for the flags arguments in timer_manager_ calls */
 26    10 
 26    11 dcl ABSOLUTE_MICROSECONDS bit (2) int static options (constant) init ("00"b);
 26    12 dcl ABSOLUTE_SECONDS bit (2) int static options (constant) init ("01"b);
 26    13 dcl RELATIVE_MICROSECONDS bit (2) int static options (constant) init ("10"b);
 26    14 dcl RELATIVE_SECONDS bit (2) int static options (constant) init ("11"b);
 26    15 
 26    16 /* END INCLUDE FILE timer_manager_constants.incl.pl1 */
     2694 
     2695 
 27     1 /* BEGIN INCLUDE FILE ... tty_read_status_info.incl.pl1
 27     2*
 27     3*   control structure for the read_status and write_status orders to tty_
 27     4*
 27     5*   Modified 2/1/83 by Olin Sibert to add tty_write_status_info structure in
 27     6*     support of lap_simplex_ MPX.
 27     7**/
 27     8 
 27     9 
 27    10 /****^  HISTORY COMMENTS:
 27    11*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
 27    12*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
 27    13*     Prepared for installation.
 27    14*                                                   END HISTORY COMMENTS */
 27    15 
 27    16 
 27    17      dcl	   1 tty_read_status_info aligned based (tty_read_status_info_ptr),
 27    18 	     2 event_channel      fixed bin (71),
 27    19 	     2 input_pending      bit (1);
 27    20 
 27    21      dcl	   tty_read_status_info_ptr ptr;
 27    22 
 27    23      dcl	   1 tty_write_status_info aligned based (tty_write_status_info_ptr),
 27    24 	     2 event_channel      fixed bin (71),
 27    25 	     2 output_pending     bit (1);
 27    26 
 27    27      dcl	   tty_write_status_info_ptr ptr;
 27    28 
 27    29 /* END INCLUDE FILE ... tty_read_status_info.incl.pl1 */
     2696 
     2697 
     2698      end imft_driver_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1257.4  imft_driver_.pl1                  >special_ldd>install>MR12.2-1199>imft_driver_.pl1
2646         1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
2648         2    09/03/82  1045.1  aim_attributes.incl.pl1           >ldd>include>aim_attributes.incl.pl1
2650         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
2652         4    09/13/84  0921.5  dial_manager_arg.incl.pl1         >ldd>include>dial_manager_arg.incl.pl1
2654         5    08/29/75  1310.5  driver_ptr_list.incl.pl1          >ldd>include>driver_ptr_list.incl.pl1
2656         6    10/28/88  1226.9  driver_status.incl.pl1            >special_ldd>install>MR12.2-1199>driver_status.incl.pl1
2658         7    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
2659         8    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
2661         9    05/28/82  1334.9  _imft_cri.incl.pl1                >ldd>include>_imft_cri.incl.pl1
2663        10    10/18/88  1204.1  _imft_driver_info.incl.pl1        >ldd>include>_imft_driver_info.incl.pl1
2665        11    05/28/82  1334.9  _imft_fis_info.incl.pl1           >ldd>include>_imft_fis_info.incl.pl1
2667        12    10/18/88  1204.1  _imft_ft_request.incl.pl1         >ldd>include>_imft_ft_request.incl.pl1
2669        13    09/30/82  2011.0  _imft_get_channel_names.incl.pl1  >ldd>include>_imft_get_channel_names.incl.pl1
2671        14    10/18/88  1204.1  _imft_std_commands.incl.pl1       >ldd>include>_imft_std_commands.incl.pl1
2673        15    10/28/88  1227.9  iod_constants.incl.pl1            >special_ldd>install>MR12.2-1199>iod_constants.incl.pl1
2675        16    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
2677        17    05/28/82  1334.9  iodd_msg_constants.incl.pl1       >ldd>include>iodd_msg_constants.incl.pl1
2679        18    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
2681        19    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2683        20    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
2685        21    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
2687        22    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
2689        23    09/01/77  1359.3  set_term_type_info.incl.pl1       >ldd>include>set_term_type_info.incl.pl1
2690        24    06/29/77  1624.0  terminal_info.incl.pl1            >ldd>include>terminal_info.incl.pl1
2692        25    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
2694        26    08/06/87  0913.5  timer_manager_constants.incl.pl1  >ldd>include>timer_manager_constants.incl.pl1
2696        27    08/11/88  2015.0  tty_read_status_info.incl.pl1     >ldd>include>tty_read_status_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AIM_ATTRIBUTES_VERSION_1        000040 constant        char(8)                  initial packed unaligned dcl 2-18 set ref 1149 1160*
                                                                                  1580* 1592
ATTACH_TYPE_TTY                        constant        fixed bin(17,0)          initial dcl 15-15 ref 79
BOTH                            000044 constant        fixed bin(17,0)          initial dcl 17-14 set ref 674* 1857*
CURRENT_IMFT_VERSION            000046 constant        char(3)                  initial packed unaligned dcl 2546 ref 317 319 336
                                                                                  1078 1501
ERROR                           000241 constant        fixed bin(17,0)          initial dcl 17-6 set ref 67* 82* 91* 222* 232* 238*
                                                                                  245* 255* 261* 267* 284* 289* 304* 310* 330* 367*
                                                                                  385* 397* 413* 435* 443* 450* 458* 465* 477* 489*
                                                                                  496* 513* 520* 529* 553* 563* 575* 599* 632* 692*
                                                                                  707* 882* 955* 1005* 1013* 1022* 1031* 1050* 1054*
                                                                                  1089* 1126* 1150* 1163* 1185* 1193* 1201* 1234*
                                                                                  1269* 1295* 1311* 1344* 1404* 1430* 1434* 1440*
                                                                                  1448* 1458* 1467* 1478* 1518* 1551* 1558* 1583*
                                                                                  1593* 1608* 1627* 1636* 1650* 1662* 1685* 1701*
                                                                                  1710* 1744* 1812* 1819* 1882* 2106* 2235* 2313*
                                                                                  2410* 2416* 2434*
FILE_TRANSFER                          constant        fixed bin(17,0)          initial dcl 10-71 ref 252 629 733 857 878 952 987
FIS_INFO_VERSION_1              000024 constant        char(8)                  initial packed unaligned dcl 11-18 ref 711
FIVE_MINUTES                           constant        fixed bin(17,0)          initial dcl 2548 ref 1081 1110 1336 1388 1504 1537
                                                                                  1730 1798 1890 2081 2273 2289
FIVE_SECONDS                    000044 constant        fixed bin(71,0)          initial dcl 2549 set ref 2013*
FT_GENERIC_TYPE                 000012 constant        char(32)                 initial packed unaligned dcl 12-40 ref 734
FT_MESSAGE_TYPE                        constant        fixed bin(17,0)          initial dcl 12-41 ref 735
FT_REQUEST_VERSION_1            000022 constant        char(8)                  initial packed unaligned dcl 12-38 ref 857
FUNCTION_NAMES                  000026 constant        char(32)                 initial array packed unaligned dcl 10-74 set ref
                                                                                  674* 700* 730* 807* 1857* 2106* 2235* 2313* 2386*
GET_CHANNEL_NAMES_VERSION_1     000010 constant        char(8)                  initial packed unaligned dcl 13-18 ref 2375
ICRI_VERSION_1                  000036 constant        char(8)                  initial packed unaligned dcl 9-18 ref 123 180 202
                                                                                  1080 1107 1335 1387 1503 1534 1729 1797 1861 1889
                                                                                  2272 2288
IMFT_AIM1                       000003 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 set ref
                                                                                  1147* 1167* 1587* 1590*
IMFT_AIM2                       000002 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 set ref
                                                                                  1174* 1365* 1373* 1679* 1784*
IMFT_DRIVER_                    000047 constant        char(32)                 initial packed unaligned dcl 2545 set ref 67* 82*
                                                                                  91* 163* 194* 222* 232* 238* 245* 255* 261* 267*
                                                                                  284* 289* 304* 310* 330* 367* 385* 435* 443* 450*
                                                                                  458* 465* 477* 489* 496* 513* 520* 529* 553* 563*
                                                                                  575* 599* 632* 692* 707* 738* 882* 955* 1005*
                                                                                  1013* 1022* 1031* 1050* 1054* 1089* 1126* 1150*
                                                                                  1163* 1185* 1193* 1201* 1234* 1269* 1295* 1311*
                                                                                  1344* 1404* 1430* 1434* 1440* 1448* 1458* 1467*
                                                                                  1478* 1518* 1551* 1558* 1583* 1593* 1608* 1627*
                                                                                  1636* 1650* 1685* 1744* 1812* 1819* 1882* 1901*
                                                                                  2106* 2215* 2235* 2313* 2353* 2386* 2410* 2416*
                                                                                  2434*
IMFT_LOGOUT                            constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 ref 122
                                                                                  1860 1898
IMFT_RESYNCHRONIZE              000004 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 set ref
                                                                                  182 204 1121* 1399* 1513* 1543 1739* 1804 1896
IMFT_SYNC1                      000006 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 set ref
                                                                                  1001* 1008* 1015* 1025* 1034* 1040* 1108 1422*
                                                                                  1425* 1535
IMFT_SYNC2                      000005 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22 set ref
                                                                                  1042* 1045* 1443* 1450* 1461* 1470* 1475* 1476*
INITIAL_IMFT_RATE                      constant        fixed bin(17,0)          initial dcl 2559 ref 754
LISTEN_COMMAND_LEVEL            000243 constant        fixed bin(17,0)          initial dcl 2561 set ref 646*
LOG                             000044 constant        fixed bin(17,0)          initial dcl 17-6 set ref 178* 674* 838* 847* 859*
                                                                                  1857*
MASTER                          000243 constant        fixed bin(17,0)          initial dcl 17-14 set ref 67* 82* 91* 163* 178* 194*
                                                                                  222* 232* 238* 245* 255* 261* 267* 284* 289* 304*
                                                                                  310* 330* 367* 385* 397* 413* 435* 443* 450* 458*
                                                                                  465* 477* 489* 496* 513* 520* 529* 553* 563* 575*
                                                                                  599* 627* 632* 646* 679* 692* 700* 707* 730* 738*
                                                                                  807* 826* 838* 847* 859* 882* 950* 955* 1005*
                                                                                  1013* 1022* 1031* 1050* 1054* 1089* 1126* 1150*
                                                                                  1163* 1185* 1193* 1201* 1234* 1269* 1295* 1311*
                                                                                  1344* 1404* 1430* 1434* 1440* 1448* 1458* 1467*
                                                                                  1478* 1518* 1551* 1558* 1583* 1593* 1608* 1627*
                                                                                  1636* 1650* 1662* 1685* 1701* 1710* 1744* 1812*
                                                                                  1819* 1882* 1901* 2106* 2134* 2215* 2235* 2280*
                                                                                  2296* 2313* 2353* 2386* 2410* 2416* 2434*
MAX_TRIGGER_LOOP_COUNT                 constant        fixed bin(17,0)          initial dcl 2550 ref 2308
NL                              031373 constant        char(1)                  initial packed unaligned dcl 2554 ref 2212
NORMAL                          000243 constant        fixed bin(17,0)          initial dcl 17-6 set ref 163* 194* 627* 679* 700*
                                                                                  730* 738* 807* 826* 908* 909* 912* 913* 919* 925*
                                                                                  939* 950* 963* 966* 1901* 2134* 2215* 2280* 2296*
                                                                                  2353* 2386*
NO_ERROR                               constant        fixed bin(35,0)          initial dcl 2551 set ref 1321* 1675*
ONE_MINUTE                             constant        fixed bin(17,0)          initial dcl 2552 ref 2221
P_arglist_ptr                          parameter       pointer                  dcl 2449 ref 895 899
P_code                                 parameter       fixed bin(35,0)          dcl 2450 set ref 895 901 903* 971* 974*
P_condition_info_ptr                   parameter       pointer                  dcl 2452 ref 980 983
P_iocb_ptr                             parameter       pointer                  dcl 1996 set ref 1993 1999 2008* 2014* 2017* 2019*
                                                                                  2020*
P_keyword                              parameter       char                     packed unaligned dcl 2428 set ref 2425 2434*
P_send_hangup                          parameter       bit(1)                   dcl 1997 ref 1993 2001
P_source                               parameter       fixed bin(17,0)          dcl 2447 ref 895 898
P_stat_p                               parameter       pointer                  dcl 2445 ref 54 74
P_state                                parameter       fixed bin(17,0)          dcl 2448 ref 895
P_value                                parameter       char                     packed unaligned dcl 2428 set ref 2425 2430 2430*
                                                                                  2431 2431* 2433 2433 2434* 2439
RELATIVE_SECONDS                000000 constant        bit(2)                   initial packed unaligned dcl 26-14 set ref 889*
                                                                                  2013* 2252*
R_ACCESS                        000226 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 235*
Stream_input                           constant        fixed bin(17,0)          initial dcl 19-15 ref 2147
Stream_output                          constant        fixed bin(17,0)          initial dcl 19-15 ref 2151
TERM_FILE_TERM                  000001 constant        bit(3)                   initial packed unaligned dcl 25-14 set ref 139* 151*
                                                                                  660*
WHITESPACE                      000042 constant        char(5)                  initial packed unaligned dcl 2556 ref 243
access_ceiling          544     003070 internal static bit(72)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 1190* 1200* 1226* 1605*
                                                                                  1693* 1705*
access_ceiling          522     003070 internal static bit(72)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 791* 793* 1190* 1208 1216
                                                                                  1218* 1224* 1226* 1278* 1281* 1284* 1304* 1305*
                                                                                  1308* 1370 1605* 1615* 1643* 1644* 1647* 1660*
                                                                                  1692* 1698* 1767 1774
access_floor            524     003070 internal static bit(72)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 798* 801* 1253* 1259* 1261*
                                                                                  1275* 1278* 1288* 1291* 1371 1669* 1672* 1707*
                                                                                  1777
access_floor            546     003070 internal static bit(72)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 1261* 1275* 1714*
active                  342            based           bit(1)                   level 3 packed packed unaligned dcl 18-17 ref 90
add_char_offset_                003766 constant        entry                    external dcl 2586 ref 139 151 217 660
addr                                                   builtin function         dcl 2644 ref 127 127 133 133 139 139 151 151 185 185
                                                                                  207 207 217 217 629 629 629 629 660 660 705 705
                                                                                  750 750 832 835 878 878 952 952 952 952 1003 1044
                                                                                  1073 1086 1086 1111 1114 1114 1149 1158 1177 1178
                                                                                  1181 1341 1341 1362 1389 1392 1392 1427 1496 1509
                                                                                  1509 1538 1541 1541 1592 1599 1681 1735 1735 1763
                                                                                  1799 1802 1802 1867 1867 1879 1879 1891 1893 1893
                                                                                  1979 1979 2008 2008 2101 2101 2115 2115 2115 2115
                                                                                  2274 2278 2278 2290 2294 2294 2350 2350 2377 2377
aim2_record                            based           structure                level 1 dcl 14-67 set ref 1178* 1373 1781
aim2_record_ptr                 000302 automatic       pointer                  dcl 14-86 set ref 1177* 1178 1181* 1183 1184 1200
                                                                                  1207 1210 1211 1242 1245 1246 1362* 1363 1365*
                                                                                  1365 1369 1370 1371 1373* 1373 1681* 1683 1684
                                                                                  1698 1705 1707 1714 1763* 1764 1767 1768 1769 1770
                                                                                  1774 1775 1776 1777 1778 1779 1781 1784*
aim_attributes                         based           structure                level 1 dcl 2-6 set ref 1157 1158* 1158 1167 1587
                                                                                  1598 1599* 1599 1922 1926
aim_attributes_ptr      550     003070 internal static pointer                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 116* 1157* 1158 1190* 1211*
                                                                                  1226* 1246* 1261* 1598* 1599 1605* 1617* 1698*
                                                                                  1707* 1922 1922 1924*
aim_attributes_ptr      526     003070 internal static pointer                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 115* 1160* 1167* 1167 1190*
                                                                                  1211* 1226* 1246* 1261* 1580* 1587* 1587 1605*
                                                                                  1617* 1698* 1707* 1926 1926 1928*
aim_check_$equal                003770 constant        entry                    external dcl 2587 ref 1200
aim_check_$greater              003772 constant        entry                    external dcl 2588 ref 1223 1258
aim_check_$greater_or_equal     003774 constant        entry                    external dcl 2589 ref 494 1218 1253 1278 1304 1615
                                                                                  1620 1643 1660
arglist                                based           structure                level 1 dcl 2469
arglist_ptr                     000104 automatic       pointer                  dcl 2474 set ref 899* 907 917 917 922 923 925 937
                                                                                  961 961
arguments                23            based           varying char(64)         array level 2 dcl 2469 set ref 923 925*
assigned_devices        265            based           fixed bin(17,0)          level 2 dcl 18-17 ref 644 691 725 756 1961
attach_description              000100 automatic       varying char(512)        dcl 2038 set ref 2141* 2143* 2146* 2146 2150* 2150
                                                                                  2155* 2155 2156* 2156 2160* 2160 2161* 2161 2163*
                                                                                  2163 2164* 2164 2167* 2167 2168* 2168 2172 2235*
                                                                                  2313*
attach_name             136            based           char(32)                 level 2 dcl 18-17 set ref 88 157* 1953* 1970* 2381*
                                                                                  2383*
attach_type             146            based           fixed bin(17,0)          level 2 dcl 18-17 ref 79
attached                 47            based           bit(1)                   level 3 packed packed unaligned dcl 6-25 set ref
                                                                                  698* 743* 758* 1955* 1964*
attachment_count                003722 internal static fixed bin(17,0)          initial dcl 2542 set ref 2326* 2326 2328 2328* 2331
                                                                                  2333
attachment_count_pic                   internal static picture(3)               packed unaligned dcl 2543 ref 2331 2333
auto_go                   1(03) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  506* 510* 559* 643
auto_receive              1(04) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  506* 510* 549* 623
automatic_operation       1(02) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  163* 166 505* 509* 1108 1535 2235 2246
baud_rate                13     000106 automatic       fixed bin(17,0)          level 2 dcl 2476 set ref 752
before                                                 builtin function         dcl 2644 ref 2405 2407
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 6-25 set ref 104* 752* 754* 766* 766
                                                                                  966*
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 22-8 set ref
                                                                                  851*
chan_list_ptr            20            based           pointer                  level 2 dcl 18-17 ref 714
channel_id                2     000274 automatic       fixed bin(71,0)          array level 2 dcl 7-8 set ref 2114*
channels                  2            based           fixed bin(71,0)          array level 2 dcl 2480 ref 714
character_buffer                000652 internal static char(256)                packed unaligned dcl 2527 set ref 2290 2292
character_line                         based           char                     packed unaligned dcl 2039 set ref 2214 2215* 2296
                                                                                  2296 2310
characters                             parameter       char                     packed unaligned dcl 2270 set ref 2267 2274 2275
                                                                                  2276 2280 2280
chars                     1            based           char                     level 2 packed packed unaligned dcl 16-39 set ref
                                                                                  139 139 151 151 217 217 660 660
cleanup                         000152 stack reference condition                dcl 2641 ref 148 875 2089
clock                                                  builtin function         dcl 2644 ref 674 674 807 807 1857 1857
code                            000332 automatic       fixed bin(35,0)          dcl 1071 in procedure "write_sync_reply" set ref
                                                                                  1086* 1088 1089*
code                            000446 automatic       fixed bin(35,0)          dcl 1727 in procedure "write_aim_command" set ref
                                                                                  1735* 1737 1739 1744*
code                     12            based           fixed bin(35,0)          level 2 in structure "sync_record" dcl 14-36
                                                                                  in procedure "imft_driver_" set ref 1045 1049*
                                                                                  1076* 1428 1429* 1477 1499*
code                            000370 automatic       fixed bin(35,0)          dcl 1333 in procedure "write_aim_reply" set ref
                                                                                  1341* 1343 1344*
code                            000422 automatic       fixed bin(35,0)          dcl 1494 in procedure "write_sync_command" set ref
                                                                                  1509* 1511 1513 1518*
code                            000301 automatic       fixed bin(35,0)          dcl 2040 in procedure "attach_line" set ref 2092*
                                                                                  2093 2101* 2103 2106* 2115* 2121* 2123 2172* 2176
                                                                                  2179* 2180 2186* 2205* 2235 2235* 2250 2278* 2279
                                                                                  2294* 2295 2344* 2350* 2353 2353* 2377* 2379 2386
                                                                                  2386*
code                                   based           fixed bin(35,0)          level 2 in structure "aim2_record" dcl 14-67
                                                                                  in procedure "imft_driver_" set ref 1183 1184*
                                                                                  1363* 1369 1683 1684* 1764*
code                            000350 automatic       fixed bin(35,0)          level 2 in structure "local_aim2_record" dcl 1144
                                                                                  in procedure "establish_input_access_ceiling" set
                                                                                  ref 1160* 1162 1163* 1184* 1185* 1190* 1192 1193*
                                                                                  1196* 1211* 1214 1226* 1230 1246* 1249 1261* 1265
                                                                                  1281* 1283 1288* 1290 1305* 1307 1392* 1394 1404*
code                            000647 internal static fixed bin(35,0)          dcl 2522 in procedure "imft_driver_" set ref 185*
                                                                                  207* 229* 231 232* 235* 237 238* 281* 283 284*
                                                                                  301* 303 304* 395* 396 410* 412 475* 476 477* 487*
                                                                                  488 489* 572* 574 629* 631 705* 706 707* 750* 752
                                                                                  791* 792 798* 800 878* 881 903* 923* 924 952* 954
                                                                                  969* 971 1049* 1050 1050* 1054* 1114* 1116 1126*
                                                                                  1429* 1430 1430* 1434* 1478* 1541* 1543 1558*
                                                                                  1580* 1582 1583* 1605* 1607 1608* 1611* 1617* 1619
                                                                                  1621* 1623 1644* 1646 1684* 1685* 1698* 1700 1701*
                                                                                  1707* 1709 1710* 1802* 1804 1819* 1879* 1881 1882*
                                                                                  1893* 1894 1978* 1979* 1980* 1981* 2002*
command                   2            based           varying char(64)         level 2 dcl 2469 ref 907 917 917 937 961 961
compute_common_aim_ceiling_     003776 constant        entry                    external dcl 2590 ref 1190 1605
computed_ceiling          1            based           bit(72)                  level 2 in structure "v2_aim2_record" dcl 14-80
                                                                                  in procedure "imft_driver_" set ref 1767*
computed_ceiling          1            based           bit(72)                  level 2 in structure "aim2_record" dcl 14-67
                                                                                  in procedure "imft_driver_" set ref 1200* 1370*
                                                                                  1698* 1705 1774*
computed_floor            3            based           bit(72)                  level 2 dcl 14-67 set ref 1371* 1707* 1714 1777*
condition                       001055 internal static char(32)                 packed unaligned dcl 2533 set ref 985* 987*
condition_info                         based           structure                level 1 dcl 3-14
condition_info_ptr              000270 automatic       pointer                  dcl 3-10 set ref 983* 985
condition_name            3            based           varying char(32)         level 2 dcl 3-14 ref 985
continue_to_signal_             004000 constant        entry                    external dcl 2591 ref 211 1874 1908 1985
convert                                                builtin function         dcl 2644 ref 338 2331 2333
convert_aim_attributes_         004002 constant        entry                    external dcl 2592 ref 793 801 1284 1291 1308 1624
                                                                                  1647
convert_authorization_$from_string
                                004004 constant        entry                    external dcl 2593 ref 475 487
convert_authorization_$to_string_short
                                004006 constant        entry                    external dcl 2594 ref 791 798 1281 1288 1305 1621
                                                                                  1644
convert_dial_message_$return_io_module
                                004010 constant        entry                    external dcl 2595 ref 2121
copy_data                 1(07) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  582* 588* 2168
correct_userid           13            based           char(32)                 level 2 dcl 14-36 set ref 1050* 1077* 1430* 1500*
currentsize                                            builtin function         dcl 2644 ref 1019 1084 1167 1365 1373 1455 1507 1587
                                                                                  1770 1781
cv_dec_check_                   004012 constant        entry                    external dcl 2598 ref 395 410 572 923
daemon_idle                     000160 stack reference condition                dcl 2641 ref 610
daemon_logout                   000166 stack reference condition                dcl 2641 ref 119 173
daemon_new_device               000174 stack reference condition                dcl 2641 ref 119
daemon_slave_logout             000202 stack reference condition                dcl 2641 ref 146
data_ptr                  4     000132 automatic       pointer                  level 2 dcl 2484 set ref 2006* 2348*
date_time_$format               004022 constant        entry                    external dcl 2602 ref 674 807 1857
debug_connect             1(12) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  378* 380* 2280 2296
debug_mode                1(01) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  582* 585* 592 2167
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 6-25 set ref 104* 769*
descriptor              146            based           structure                level 2 dcl 6-25 set ref 832
dev_ctl_ptr             130            based           pointer                  level 2 dcl 6-25 set ref 102* 768*
dev_in_iocbp             70            based           pointer                  level 2 dcl 6-25 set ref 100* 127 127* 185 185* 207
                                                                                  207* 615 705* 715 761* 761 945 1086* 1341* 1392*
                                                                                  1735* 1802* 1957* 1967* 1967 2174*
dev_in_stream           102            based           char(32)                 level 2 in structure "driver_status" dcl 6-25
                                                                                  in procedure "imft_driver_" set ref 101* 763* 763
dev_in_stream           106            based           char(32)                 level 2 in structure "iodd_static" dcl 18-17
                                                                                  in procedure "imft_driver_" set ref 96*
dev_io_stream            76            based           char(32)                 level 2 dcl 18-17 set ref 96*
dev_out_iocbp            66            based           pointer                  level 2 dcl 6-25 set ref 100* 132 133* 135* 750*
                                                                                  760* 760 825 875* 878* 887* 1114* 1509* 1541* 1853
                                                                                  1866 1867* 1879* 1893* 1956 1957* 1966* 1966 2076
                                                                                  2172* 2174 2179* 2186* 2278* 2294* 2350* 2377*
dev_out_stream           72            based           char(32)                 level 2 dcl 6-25 set ref 101* 762* 762 2170* 2172
device_id                20            based           char(32)                 level 2 dcl 6-25 ref 646
devp                            000400 internal static pointer                  dcl 2506 in procedure "imft_driver_" set ref 645*
                                                                                  646 757* 758 759 760 761 762 763 764 765 766 767
                                                                                  768 769 1963* 1964 1965 1966 1967
devp                                   parameter       pointer                  dcl 2402 in procedure "validate_request_type" ref
                                                                                  2399 2405 2405 2407 2407 2410 2416
dial_channel             10     000226 internal static fixed bin(71,0)          level 2 dcl 2494 set ref 110* 1977 1978* 1980* 1981*
                                                                                  1982* 2002* 2092* 2114 2205* 2344*
dial_manager_$allow_dials       004014 constant        entry                    external dcl 2599 ref 2101
dial_manager_$shutoff_dials     004016 constant        entry                    external dcl 2600 ref 1979
dial_manager_arg                       based           structure                level 1 dcl 4-14
dial_qualifier            1     000226 internal static char(22)                 level 2 packed packed unaligned dcl 2494 set ref
                                                                                  2099*
dial_service              1(13) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  117* 167 349* 360* 376 1949
dialed_up                       000375 internal static bit(1)                   level 2 packed packed unaligned dcl 2497 set ref
                                                                                  2128
divide                                                 builtin function         dcl 2644 ref 242 752
dma                             000226 internal static structure                level 1 unaligned dcl 2494 set ref 1979 1979 2101
                                                                                  2101
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 22-8 set ref
                                                                                  841* 852* 864*
driver_list_ptr          16            based           pointer                  level 2 dcl 18-17 ref 724 1963
driver_ptr              304            based           pointer                  level 2 in structure "iodd_static" dcl 18-17
                                                                                  in procedure "imft_driver_" ref 99 824
driver_ptr                      000010 internal static pointer                  dcl 822 in procedure "imft_driver_" set ref 824* 825
                                                                                  832 835 846 875 878 887
driver_ptr_list                        based           structure                level 1 unaligned dcl 5-9
driver_status                          based           structure                level 1 dcl 6-25
ds_ptr                          000376 internal static pointer                  dcl 2505 set ref 99* 100 100 101 101 102 104 104 127
                                                                                  127 132 133 135 185 185 207 207 615 697* 698 705
                                                                                  715 734 735 738 743 745 747 750 752 754 760 761
                                                                                  762 763 764 765 766 767 945 966 1086 1114 1341
                                                                                  1392 1509 1541 1735 1802 1853 1866 1867 1879 1893
                                                                                  1955 1956 1957 1957 1966 1967 2076 2170 2172 2172
                                                                                  2174 2174 2179 2186 2278 2294 2350 2377
elem_size               112            based           fixed bin(17,0)          level 2 dcl 6-25 set ref 745* 764* 764
ename                    55            based           char(32)                 level 2 dcl 21-12 set ref 847* 859*
entry                           000132 automatic       entry variable           level 2 dcl 2484 set ref 2005* 2347*
error_message                   000302 automatic       char(64)                 packed unaligned dcl 2041 set ref 2094* 2104* 2106*
                                                                                  2124* 2129*
error_table_$action_not_performed
                                003730 external static fixed bin(35,0)          dcl 2564 ref 974
error_table_$ai_outside_common_range
                                003726 external static fixed bin(35,0)          dcl 2564 set ref 1295* 1299* 1636* 1638* 1662* 1665*
error_table_$bad_conversion     003732 external static fixed bin(35,0)          dcl 2564 set ref 397* 413* 575* 925*
error_table_$fatal_error        003734 external static fixed bin(35,0)          dcl 2564 set ref 67* 82* 91* 692* 2313*
error_table_$inconsistent       003736 external static fixed bin(35,0)          dcl 2564 set ref 385* 450* 458* 465* 529*
error_table_$noarg              003740 external static fixed bin(35,0)          dcl 2564 set ref 261* 289* 310* 367* 435* 443*
error_table_$unimplemented_version
                                003742 external static fixed bin(35,0)          dcl 2564 set ref 1150* 1593*
ev_wait_info                    000366 internal static structure                level 1 unaligned dcl 2495 set ref 2115 2115
event_channel                   000126 automatic       fixed bin(71,0)          level 2 dcl 2478 set ref 716
event_channel_list                     based           structure                level 1 dcl 2480
event_channels           32     003642 internal static fixed bin(71,0)          array level 3 dcl 2539 set ref 714* 716*
event_wait_channel              000274 automatic       structure                level 1 dcl 7-8 set ref 2115 2115
event_wait_info                        based           structure                level 1 dcl 8-7
expand_pathname_$component      004020 constant        entry                    external dcl 2601 ref 229
explicit_access_required
                          1(09) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  537* 540*
explicit_ceiling          4            based           bit(72)                  level 2 in structure "v2_aim2_record" dcl 14-80
                                                                                  in procedure "imft_driver_" set ref 1769*
explicit_ceiling          6            based           bit(72)                  level 2 in structure "aim2_record" dcl 14-67
                                                                                  in procedure "imft_driver_" set ref 1211* 1776*
explicit_ceiling_given
                          5            based           bit(1)                   level 3 in structure "aim2_record" packed packed
                                                                                  unaligned dcl 14-67 in procedure "imft_driver_"
                                                                                  set ref 1207 1210 1775*
explicit_ceiling_given
                          3            based           bit(1)                   level 2 in structure "v2_aim2_record" dcl 14-80
                                                                                  in procedure "imft_driver_" set ref 1768*
explicit_floor           10            based           bit(72)                  level 2 dcl 14-67 set ref 1246* 1779*
explicit_floor_given      5(01)        based           bit(1)                   level 3 packed packed unaligned dcl 14-67 set ref
                                                                                  1242 1245 1778*
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 22-8 set ref
                                                                                  842* 853* 865*
first_char              164            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 18-17
                                                                                  ref 139 151 217 660
fis_info                               based           structure                level 1 dcl 11-7
flags                     1     003070 internal static structure                level 2 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_"
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 18-17
                                                                                  in procedure "imft_driver_"
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 22-8
                                                                                  in procedure "imft_driver_"
flags                     5            based           structure                level 2 in structure "aim2_record" packed packed
                                                                                  unaligned dcl 14-67 in procedure "imft_driver_"
foreign_explicit_ceiling        000626 internal static bit(72)                  dcl 2515 set ref 1211* 1216* 1218* 1218 1223* 1617*
                                                                                  1693
foreign_explicit_floor          000632 internal static bit(72)                  dcl 2516 set ref 1246* 1251* 1253* 1253 1258*
foreign_system          530     003070 internal static structure                level 2 dcl 2538
foreign_system_version          000636 internal static float bin(27)            dcl 2518 set ref 338* 338 1021 1457
ft_request                             based           structure                level 1 dcl 12-16
function                        003070 internal static fixed bin(17,0)          level 2 dcl 2538 set ref 252* 627* 629 674 700 730
                                                                                  733 807 857 878 950* 952 987 1857 2106 2235 2313
                                                                                  2386
generic_type            134            based           char(32)                 level 2 dcl 6-25 set ref 734* 767* 767
get_authorization_              004024 constant        entry                    external dcl 2603 ref 1304 1304 1620 1620 1643 1643
get_channel_names                      based           structure                level 1 dcl 13-11
get_ring_                       004026 constant        entry                    external dcl 2604 ref 65
get_system_aim_attributes_      004030 constant        entry                    external dcl 2605 ref 1160 1580
get_system_free_area_           004032 constant        entry                    external dcl 2606 ref 72 1160 1160 1580 1580
hangup_info                     000132 automatic       structure                level 1 dcl 2484 set ref 2008 2008 2350 2350
have_channel_names              000225 internal static bit(1)                   dcl 2492 set ref 807* 2373* 2380*
hdr_version               2            based           fixed bin(17,0)          level 2 dcl 21-12 ref 837
i                               000144 automatic       fixed bin(17,0)          dcl 2509 set ref 644* 645* 725* 727*
icri                                   based           structure                level 1 dcl 9-6
idle_delay                4     003070 internal static fixed bin(17,0)          level 2 dcl 2538 set ref 403* 831* 1849* 1849 1850
idle_delay_count          3     003070 internal static fixed bin(17,0)          level 2 dcl 2538 set ref 392* 395* 396 396 1850
idle_line_drop            1(10) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  344* 389* 1843
ignore_code                     000650 internal static fixed bin(35,0)          dcl 2522 set ref 127* 133* 135* 139* 151* 211* 646*
                                                                                  660* 677* 875* 887* 1867* 1871* 1874* 1908* 1985*
                                                                                  2008* 2014* 2017* 2019* 2020*
imft_convert_status_code_$decode
                                004034 constant        entry                    external dcl 2607 ref 1049 1184 1429 1684
imft_convert_status_code_$encode
                                004036 constant        entry                    external dcl 2608 ref 1076 1363 1499 1764
imft_debug_                     000216 stack reference condition                dcl 2641 ref 192
imft_driver_info                       based           structure                level 1 dcl 10-23
imft_et_$cant_get_channel_names 003744 external static fixed bin(35,0)          dcl 2574 ref 2386
imft_et_$computed_ceiling_mismatch
                                003746 external static fixed bin(35,0)          dcl 2574 set ref 1201* 1203*
imft_et_$explicit_ceiling_mismatch
                                003750 external static fixed bin(35,0)          dcl 2574 set ref 1234* 1236*
imft_et_$explicit_floor_mismatch
                                003752 external static fixed bin(35,0)          dcl 2574 set ref 1269* 1271*
imft_et_$non_matching_ids       003754 external static fixed bin(35,0)          dcl 2574 set ref 1005* 1008* 1050 1430 1440* 1443*
imft_et_$non_matching_passwords 003756 external static fixed bin(35,0)          dcl 2574 set ref 1013* 1015* 1448* 1450*
imft_et_$non_matching_versions  003760 external static fixed bin(35,0)          dcl 2574 set ref 1022* 1025* 1031* 1034* 1458* 1461*
                                                                                  1467* 1470*
imft_et_$process_authorization_too_low
                                003762 external static fixed bin(35,0)          dcl 2574 set ref 1311* 1314* 1627* 1630* 1650* 1653*
imft_et_$reply_pending          003764 external static fixed bin(35,0)          dcl 2574 ref 1513 1739
imft_pnt_interface_$get_system_password
                                004040 constant        entry                    external dcl 2609 ref 281 301
imft_receive_object_            004042 constant        entry                    external dcl 2610 ref 629 952
imft_remote_logout_             000224 stack reference condition                dcl 2641 ref 160 1898
imft_resynchronize_driver_      000232 stack reference condition                dcl 2641 ref 176 1896
imft_transmit_object_           004044 constant        entry                    external dcl 2611 ref 878
imft_transmit_object_$abort_running_request
                                004046 constant        entry                    external dcl 2612 ref 987
imft_version             23            based           char(8)                  level 2 in structure "sync_record" dcl 14-36
                                                                                  in procedure "imft_driver_" set ref 1030 1031*
                                                                                  1078* 1466 1467* 1501*
imft_version            520     003070 internal static char(8)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 334* 336* 807*
imft_version            542     003070 internal static char(8)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 319* 323* 327* 338 1022*
                                                                                  1030 1031* 1458* 1466 1467*
in_dial_qualifier       206     003070 internal static char(256)                level 3 packed packed unaligned dcl 2538 set ref
                                                                                  343* 346* 347 1977 2002 2091 2099 2106* 2186 2196
                                                                                  2344
index                                                  builtin function         dcl 2644 ref 2214 2310
initiate_file_$component        004050 constant        entry                    external dcl 2613 ref 235
input_attach_description
                          6     003070 internal static char(256)                level 3 packed packed unaligned dcl 2538 set ref
                                                                                  361* 362 362* 364 423* 424 424* 426 430* 431 431*
                                                                                  433 2133* 2134* 2156 2156 2161 2161
input_buffer                    001065 internal static char(2048)               packed unaligned dcl 2535 set ref 1003 1044 1111
                                                                                  1112 1149 1158 1178 1181 1389 1390 1427 1538 1539
                                                                                  1592 1599 1681 1799 1800 1891 1892
input_channel             2     000203 internal static char(32)                 level 2 packed packed unaligned dcl 2491 set ref
                                                                                  807* 2381
input_driver              1     003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref 127
                                                                                  163* 179 201 264* 265* 384 519 549 559 610 623
                                                                                  674* 686 778 807* 909 918 938 962 1857* 2106* 2145
                                                                                  2235* 2313* 2331 2381 2386*
input_pending             2     000126 automatic       bit(1)                   level 2 dcl 2478 set ref 1888
io_info                   6     003070 internal static structure                level 2 dcl 2538
io_module                       000322 automatic       char(32)                 packed unaligned dcl 2042 set ref 2121* 2133
iocb_ptr                        000102 automatic       pointer                  dcl 1938 set ref 1956* 1972*
iocbs                     4     003642 internal static pointer                  array level 2 dcl 2539 set ref 713* 715*
iodd_command_processor_         004052 constant        entry                    external dcl 2615 ref 646
iodd_hangup_                    004054 constant        entry                    external dcl 2616 ref 2344 2344 2347
iodd_listen_                    004056 constant        entry                    external dcl 2617 ref 653
iodd_msg_                       004060 constant        entry                    external dcl 2618 ref 67 82 91 163 178 194 222 232
                                                                                  238 245 255 261 267 284 289 304 310 330 367 385
                                                                                  397 413 435 443 450 458 465 477 489 496 513 520
                                                                                  529 553 563 575 599 627 632 674 679 692 700 707
                                                                                  730 738 807 826 838 847 859 882 908 909 912 913
                                                                                  919 925 939 950 955 963 966 1005 1013 1022 1031
                                                                                  1050 1054 1089 1126 1150 1163 1185 1193 1201 1234
                                                                                  1269 1295 1311 1344 1404 1430 1434 1440 1448 1458
                                                                                  1467 1478 1518 1551 1558 1583 1593 1608 1627 1636
                                                                                  1650 1662 1685 1701 1710 1744 1812 1819 1857 1882
                                                                                  1901 2106 2134 2215 2235 2280 2296 2313 2353 2386
                                                                                  2410 2416 2434
iodd_parse_$args                004062 constant        entry                    external dcl 2619 ref 226 251 259 272 275 295 316
                                                                                  346 352 361 362 365 377 382 391 406 423 424 430
                                                                                  431 439 440 455 456 462 463 472 484 503 517 536
                                                                                  548 558 568 584 587
iodd_quit_handler_              004064 constant        entry                    external dcl 2620 ref 625
iodd_quit_handler_$command_level
                                004066 constant        entry                    external dcl 2621 ref 196
iodd_static                            based           structure                level 1 dcl 18-17
iox_$attach_ioname              004070 constant        entry                    external dcl 2622 ref 2172
iox_$close                      004072 constant        entry                    external dcl 2623 ref 2017
iox_$control                    004074 constant        entry                    external dcl 2624 ref 127 133 135 185 207 677 705
                                                                                  750 875 887 1086 1114 1341 1392 1509 1541 1735
                                                                                  1802 1867 1871 1879 1893 2008 2014 2186 2278 2294
                                                                                  2350 2377
iox_$destroy_iocb               004100 constant        entry                    external dcl 2626 ref 2020
iox_$detach_iocb                004076 constant        entry                    external dcl 2625 ref 2019
iox_$open                       004102 constant        entry                    external dcl 2627 ref 2179
ipc_$block                      004104 constant        entry                    external dcl 2628 ref 2115
ipc_$create_ev_chn              004106 constant        entry                    external dcl 2629 ref 2092
ipc_$decl_ev_call_chn           004110 constant        entry                    external dcl 2630 ref 2002 2205 2344
ipc_$decl_ev_wait_chn           004112 constant        entry                    external dcl 2631 ref 1978
ipc_$delete_ev_chn              004114 constant        entry                    external dcl 2632 ref 1981
ipc_$drain_chn                  004116 constant        entry                    external dcl 2633 ref 1980
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 22-8 set ref
                                                                                  840* 863*
keyword_value                   000637 internal static char(32)                 packed unaligned dcl 2520 set ref 251* 252 252 255*
                                                                                  259* 260 264 265 267* 272* 273 273* 316* 317 317
                                                                                  321 325 330* 377* 378 380* 382* 383 389* 391* 392
                                                                                  395* 397* 406* 407 410* 413* 503* 504 504 508 508
                                                                                  513* 517* 518 525* 536* 537 540* 548* 549 549*
                                                                                  558* 559 559* 568* 569 572* 575* 584* 585 585*
                                                                                  587* 588 588*
length                                                 builtin function         dcl 2644 in procedure "imft_driver_" ref 243 1112
                                                                                  1390 1539 1800 1892 2275 2276 2292
length                                 based           fixed bin(17,0)          level 2 in structure "text_strings" dcl 16-39
                                                                                  in procedure "imft_driver_" ref 139 139 151 151
                                                                                  217 217 660 660
linkage_error                   000210 stack reference condition                dcl 2641 ref 597 606
list_ptr                        000272 automatic       pointer                  dcl 5-7 set ref 645 724* 727 757
local_aim2_record               000350 automatic       structure                level 1 dcl 1144 set ref 1177
local_explicit_ceiling          000624 internal static bit(72)                  dcl 2515 set ref 475* 494* 1208* 1218* 1223* 1224
                                                                                  1615* 1617* 1620* 1621* 1624* 1692 1769 1776
local_explicit_ceiling_given    000634 internal static bit(1)                   dcl 2517 set ref 471* 474* 494 1207 1208 1615 1690
                                                                                  1768 1775
local_explicit_floor            000630 internal static bit(72)                  dcl 2516 set ref 487* 494* 1243* 1253* 1258* 1259
                                                                                  1660* 1669 1779
local_explicit_floor_given      000635 internal static bit(1)                   dcl 2517 set ref 483* 486* 494 1242 1243 1659 1778
local_gcn                       000203 internal static structure                level 1 dcl 2491 set ref 2377 2377
local_icri                      000172 internal static structure                level 1 dcl 2489 set ref 127 127 133 133 185 185 207
                                                                                  207 1086 1086 1114 1114 1341 1341 1392 1392 1509
                                                                                  1509 1541 1541 1735 1735 1802 1802 1867 1867 1893
                                                                                  1893 2278 2278 2294 2294
local_system            506     003070 internal static structure                level 2 dcl 2538
local_terminal_info             000106 automatic       structure                level 1 dcl 2476 set ref 750 750
log_msg                 342(04)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  673* 1856*
ltrim                                                  builtin function         dcl 2644 ref 2331 2333
major_args                             based           char                     packed unaligned dcl 2457 in procedure
                                                                                  "imft_driver_" set ref 226* 243 251* 259* 272*
                                                                                  275* 295* 316* 346* 352* 361* 362* 365* 377* 382*
                                                                                  391* 406* 423* 424* 430* 431* 439* 440* 455* 456*
                                                                                  462* 463* 472* 484* 503* 517* 536* 548* 558* 568*
                                                                                  584* 587*
major_args              164            based           structure                level 2 in structure "iodd_static" packed packed
                                                                                  unaligned dcl 18-17 in procedure "imft_driver_"
major_args_bc                   000167 internal static fixed bin(24,0)          dcl 2464 set ref 235* 242
major_args_component            000157 internal static char(32)                 packed unaligned dcl 2463 set ref 229* 235* 238*
                                                                                  238* 245* 245*
major_args_dirname              000075 internal static char(168)                packed unaligned dcl 2462 set ref 229* 235* 238*
                                                                                  238* 245* 245*
major_args_ename                000147 internal static char(32)                 packed unaligned dcl 2463 set ref 229* 235* 238*
                                                                                  238* 245* 245*
major_args_lth                  000100 automatic       fixed bin(21,0)          dcl 2458 set ref 219* 221 226 226 242* 243* 243 244
                                                                                  251 251 259 259 272 272 275 275 295 295 316 316
                                                                                  346 346 352 352 361 361 362 362 365 365 377 377
                                                                                  382 382 391 391 406 406 423 423 424 424 430 430
                                                                                  431 431 439 439 440 440 455 455 456 456 462 462
                                                                                  463 463 472 472 484 484 503 503 517 517 536 536
                                                                                  548 548 558 558 568 568 584 584 587 587
major_args_path                 000012 internal static char(204)                packed unaligned dcl 2461 set ref 226* 228 229* 232*
major_args_ptr                  000102 automatic       pointer                  dcl 2459 set ref 108* 139 139 139* 151 151 151* 217*
                                                                                  226 235* 243 251 259 272 275 295 316 346 352 361
                                                                                  362 365 377 382 391 406 423 424 430 431 439 440
                                                                                  455 456 462 463 472 484 503 517 536 548 558 568
                                                                                  584 587 660 660 660*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  618* 649*
master_in                70            based           pointer                  level 2 dcl 18-17 ref 713
max_access_class_octal          000504 internal static char(32)                 dcl 2512 set ref 793* 794 1284* 1285 1308* 1309
                                                                                  1624* 1625 1647* 1648
max_access_class_string         000404 internal static char(256)                packed unaligned dcl 2511 set ref 472* 473 475* 477*
                                                                                  496* 791* 794* 807 807* 1281* 1285* 1295 1295*
                                                                                  1305* 1309* 1311 1311* 1621* 1625* 1627 1627*
                                                                                  1644* 1648* 1650 1650*
message                 240            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 6-25
                                                                                  in procedure "imft_driver_" set ref 835
message                   2     000366 internal static fixed bin(71,0)          level 2 in structure "ev_wait_info" dcl 2495
                                                                                  in procedure "imft_driver_" set ref 2121*
message_type            113            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 6-25
                                                                                  in procedure "imft_driver_" set ref 735* 765* 765
                                                                                  846
message_type             65            based           fixed bin(17,0)          level 2 in structure "queue_msg_hdr" dcl 21-12
                                                                                  in procedure "imft_driver_" ref 846
min_access_class_octal          000614 internal static char(32)                 dcl 2514 set ref 801* 802 1291* 1292
min_access_class_string         000514 internal static char(256)                packed unaligned dcl 2513 set ref 484* 485 487* 489*
                                                                                  496* 798* 802* 805* 807 807* 1288* 1292* 1295
                                                                                  1295*
min_time_to_log           5     003070 internal static fixed bin(35,0)          level 2 dcl 2538 set ref 569* 572* 574 574
mseg_message_info                      based           structure                level 1 dcl 20-9
mseg_message_info_copy                 based           structure                level 2 dcl 22-8
my_password              10            based           char(8)                  level 2 dcl 14-36 set ref 1012 1075* 1447 1498*
my_ring                         000145 automatic       fixed bin(3,0)           dcl 2523 set ref 65* 66
my_userid                              based           char(32)                 level 2 dcl 14-36 set ref 1004 1005* 1013* 1074*
                                                                                  1439 1440* 1448* 1497*
n_channels                      000274 automatic       fixed bin(17,0)          initial level 2 in structure "event_wait_channel"
                                                                                  dcl 7-8 in procedure "imft_driver_" set ref 7-8*
n_channels               30     003642 internal static fixed bin(17,0)          level 3 in structure "static_fis_info" dcl 2539
                                                                                  in procedure "imft_driver_" set ref 712*
n_iocbs                   2     003642 internal static fixed bin(17,0)          level 2 dcl 2539 set ref 712*
n_tokens                  1            based           fixed bin(17,0)          level 2 dcl 2469 ref 922
name                    530     003070 internal static char(32)                 level 3 in structure "static" packed packed
                                                                                  unaligned dcl 2538 in procedure "imft_driver_" set
                                                                                  ref 163* 178* 295* 300 301* 304* 627* 674* 700*
                                                                                  730* 807* 950* 1004 1005* 1008* 1089* 1126* 1150*
                                                                                  1185* 1193* 1201* 1234* 1269* 1344* 1404* 1439
                                                                                  1440* 1443* 1518* 1551* 1558* 1593* 1608* 1636*
                                                                                  1685* 1744* 1812* 1819* 1857* 1901* 2106* 2134*
                                                                                  2235* 2313* 2353* 2386* 2415 2416*
name                    506     003070 internal static char(32)                 level 3 in structure "static" packed packed
                                                                                  unaligned dcl 2538 in procedure "imft_driver_" set
                                                                                  ref 275* 280 281* 284* 1040* 1050* 1054* 1422*
                                                                                  1430* 1434*
no_coord                        000240 stack reference condition                dcl 2641 ref 119
no_dialed                       000332 automatic       fixed bin(17,0)          dcl 2043 set ref 2121*
null                                                   builtin function         dcl 2644 ref 100 102 108 115 116 125 127 132 135 135
                                                                                  139 151 183 185 205 207 615 660 677 677 738 768
                                                                                  825 875 875 887 887 945 1399 1399 1853 1863 1866
                                                                                  1871 1871 1922 1924 1926 1928 1957 1999 2002 2002
                                                                                  2006 2014 2014 2076 2186 2186
old_version               1(06) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  318* 322* 326* 334 449 482 527 797 1176 1241 1365
                                                                                  1658 1690 1766 2141
open_mode                       000333 automatic       fixed bin(17,0)          dcl 2044 set ref 2147* 2151* 2179*
out_dial_text           306     003070 internal static char(256)                level 3 packed packed unaligned dcl 2538 set ref
                                                                                  343* 352* 353 2189 2198 2212
output_attach_description
                        106     003070 internal static char(256)                level 3 packed packed unaligned dcl 2538 set ref
                                                                                  439* 440 440* 442 2164 2164
output_buffer                   002065 internal static char(2048)               packed unaligned dcl 2535 set ref 1073 1362 1496
                                                                                  1763
output_channel           12     000203 internal static char(32)                 level 2 packed packed unaligned dcl 2491 set ref
                                                                                  807* 2383
p                               000142 automatic       pointer                  dcl 2508 set ref 835* 837 846 847 857 859
p_aim_type                             parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1330 in procedure
                                                                                  "write_aim_reply" ref 1327 1337
p_aim_type                             parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1795 in procedure
                                                                                  "read_aim_reply" ref 1792 1808
p_aim_type                             parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1724 in procedure
                                                                                  "write_aim_command" ref 1721 1731
p_aim_type                             parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1385 in procedure
                                                                                  "read_aim_command" ref 1382 1394
p_code                                 parameter       fixed bin(35,0)          dcl 1069 in procedure "write_sync_reply" set ref
                                                                                  1063 1076*
p_code                                 parameter       fixed bin(35,0)          dcl 1492 in procedure "write_sync_command" set ref
                                                                                  1486 1499*
p_code                                 parameter       fixed bin(35,0)          dcl 1360 in procedure "write_aim2_reply" set ref
                                                                                  1357 1363*
p_code                                 parameter       fixed bin(35,0)          dcl 1760 in procedure "write_aim2_command" set ref
                                                                                  1757 1764*
p_correct_userid                       parameter       char                     packed unaligned dcl 1490 in procedure
                                                                                  "write_sync_command" ref 1486 1500
p_correct_userid                       parameter       char                     packed unaligned dcl 1067 in procedure
                                                                                  "write_sync_reply" ref 1063 1077
p_my_password                          parameter       char(8)                  dcl 1491 in procedure "write_sync_command" ref 1486
                                                                                  1498
p_my_password                          parameter       char(8)                  dcl 1068 in procedure "write_sync_reply" ref 1063
                                                                                  1075
p_my_userid                            parameter       char                     packed unaligned dcl 1067 in procedure
                                                                                  "write_sync_reply" ref 1063 1074
p_my_userid                            parameter       char                     packed unaligned dcl 1490 in procedure
                                                                                  "write_sync_command" ref 1486 1497
p_record_lth                           parameter       fixed bin(21,0)          dcl 1726 in procedure "write_aim_command" ref 1721
                                                                                  1733
p_record_lth                           parameter       fixed bin(21,0)          dcl 1332 in procedure "write_aim_reply" ref 1327
                                                                                  1339
p_record_ptr                           parameter       pointer                  dcl 1725 in procedure "write_aim_command" ref 1721
                                                                                  1732
p_record_ptr                           parameter       pointer                  dcl 1331 in procedure "write_aim_reply" ref 1327
                                                                                  1338
p_sync_type                            parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1105 in procedure
                                                                                  "read_sync_command" ref 1102 1108 1116
p_sync_type                            parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1532 in procedure
                                                                                  "read_sync_reply" ref 1529 1535 1547 1547
p_sync_type                            parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1066 in procedure
                                                                                  "write_sync_reply" ref 1063 1082
p_sync_type                            parameter       fixed bin(7,0)           packed unsigned unaligned dcl 1489 in procedure
                                                                                  "write_sync_command" ref 1486 1505
password                516     003070 internal static char(8)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 277* 281* 1040* 1422*
password                540     003070 internal static char(8)                  level 3 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 297* 301* 1012 1447
pathname_$component             004120 constant        entry                    external dcl 2634 ref 238 238 245 245
prev_proto_error                000335 automatic       bit(1)                   packed unaligned dcl 2046 set ref 2079* 2215 2222*
                                                                                  2241*
previous_attach_code            000334 automatic       fixed bin(35,0)          dcl 2045 set ref 2078* 2182* 2235 2250*
priority                  6     000132 automatic       fixed bin(17,0)          level 2 dcl 2484 set ref 2007* 2349*
q                        33            based           fixed bin(17,0)          level 2 dcl 22-8 set ref 838* 847* 859*
queue_msg_hdr                          based           structure                level 1 dcl 21-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 21-37 ref 837
quit                            000246 stack reference condition                dcl 2641 ref 625 637
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  873*
rd_ptr                          000402 internal static pointer                  dcl 2507 set ref 832* 838 838 840 841 842 847 847
                                                                                  847 851 852 853 859 859 859 863 864 865
re_init                         000254 stack reference condition                dcl 2641 ref 199 635 884 957 1885 1904
re_init_in_progress     310(11)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  671* 1855*
re_init_label            26            based           label variable           level 2 dcl 18-17 ref 680
ready                    47(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-25 set ref
                                                                                  747* 759* 1965*
record_info               4     000172 internal static structure                level 2 dcl 2489
record_lth               10     000172 internal static fixed bin(21,0)          level 3 dcl 2489 set ref 126* 184* 206* 1019 1084*
                                                                                  1339* 1455 1507* 1733* 1864* 2214 2215 2215 2275*
                                                                                  2291* 2296 2296 2310
record_max_lth            7     000172 internal static fixed bin(21,0)          level 3 dcl 2489 set ref 126* 184* 206* 1112* 1390*
                                                                                  1539* 1800* 1864* 1892* 2276* 2292*
record_ptr                4     000172 internal static pointer                  level 3 dcl 2489 set ref 125* 183* 205* 1083* 1111*
                                                                                  1338* 1389* 1506* 1538* 1732* 1799* 1863* 1891*
                                                                                  2214 2215 2274* 2290* 2296 2296 2310
record_size                     000456 automatic       fixed bin(21,0)          dcl 1761 set ref 1770* 1781* 1784*
record_type               6     000172 internal static fixed bin(17,0)          level 3 dcl 2489 set ref 122* 182* 204* 1082* 1116
                                                                                  1337* 1394 1505* 1543 1547 1551* 1731* 1804 1808
                                                                                  1812* 1860* 1896 1898 1901*
remote_request_allowed
                          1(08) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  534* 543* 546*
req_type_label                         based           char(32)                 level 2 dcl 6-25 set ref 2405 2405 2407 2407 2410*
                                                                                  2416*
req_type_site                   000110 automatic       char(32)                 packed unaligned dcl 2403 set ref 2405* 2407* 2415
request                  76            based           structure                level 2 dcl 12-16
request_descriptor                     based           structure                level 1 dcl 22-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 ref 987
requote_string_                 004122 constant        entry                    external dcl 2635 ref 2156 2161 2164
resume                          000262 stack reference condition                dcl 2641 ref 626 637
rqti_ptr                 64            based           pointer                  level 2 dcl 6-25 ref 738
rtrim                                                  builtin function         dcl 2644 ref 243 2099 2133 2133 2156 2156 2161 2161
                                                                                  2164 2164 2208 2208 2212 2280 2280 2296 2296
saved_code                      000651 internal static fixed bin(35,0)          dcl 2522 set ref 901* 969
saved_test_entry                003065 internal static bit(1)                   dcl 2536 set ref 107* 138 150 658
send_hangup                     000100 automatic       bit(1)                   dcl 1937 set ref 1940* 1949* 1951* 1972*
send_logout_record              003066 internal static bit(1)                   dcl 2536 set ref 109* 121 162*
sender_id                13            based           char(32)                 level 3 packed packed unaligned dcl 22-8 set ref
                                                                                  847* 859*
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 22-8 set ref 838* 847* 859*
single_switch             1(05) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  348* 364* 426* 429 807* 2154
slave                   312            based           structure                level 2 dcl 18-17
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  619*
slave_out               336            based           pointer                  level 3 dcl 18-17 set ref 677* 1871*
sleep_time                2     003070 internal static fixed bin(17,0)          level 2 in structure "static" dcl 2538 in procedure
                                                                                  "imft_driver_" set ref 407* 410* 412 412 2215*
                                                                                  2215 2221
sleep_time                      000336 automatic       fixed bin(71,0)          dcl 2047 in procedure "attach_line" set ref 2081*
                                                                                  2221* 2252*
source                          001053 internal static fixed bin(17,0)          dcl 2530 set ref 898* 908* 909* 912* 913* 919* 925*
                                                                                  939* 963* 966*
stat_p                          003724 internal static pointer                  dcl 18-15 set ref 74* 77 79 88 90 96 96 99 107 138
                                                                                  139 150 151 157 217 219 583 592 618 619 644 649
                                                                                  653* 658 660 671 673 677 680 691 713 714 724 725
                                                                                  756 824 873 878* 987 1855 1856 1871 1953 1961 1963
                                                                                  1970 2205* 2344* 2348 2381 2383
stat_seg                  2            based           structure                array level 2 unaligned dcl 5-9
stat_segp                 2            based           pointer                  array level 3 dcl 5-9 set ref 645 727* 757 1963
static                          003070 internal static structure                level 1 dcl 2538 set ref 629 629 878 878 952 952
static_fis_info                 003642 internal static structure                level 1 dcl 2539 set ref 629 629 952 952
static_pause_time               003720 internal static fixed bin(71,0)          dcl 2540 set ref 75* 889 889* 932* 934*
status_flags             47            based           structure                level 2 in structure "driver_status" dcl 6-25
                                                                                  in procedure "imft_driver_"
status_flags                    000375 internal static structure                level 1 dcl 2497 in procedure "imft_driver_" set ref
                                                                                  2121*
string                                 parameter       char                     packed unaligned dcl 2306 ref 2303 2310
substr                                                 builtin function         dcl 2644 ref 2405 2405 2407 2407
sync_record                            based           structure                level 1 dcl 14-36 set ref 1019 1084 1455 1507
sync_record_ptr                 000300 automatic       pointer                  dcl 14-43 set ref 1003* 1004 1005 1012 1013 1019
                                                                                  1030 1031 1044* 1045 1049 1050 1073* 1074 1075
                                                                                  1076 1077 1078 1083 1084 1427* 1428 1429 1430 1439
                                                                                  1440 1447 1448 1455 1466 1467 1477 1496* 1497 1498
                                                                                  1499 1500 1501 1506 1507
system_area                            based           area(1024)               dcl 2466 ref 1157 1598
system_area_ptr                 000170 internal static pointer                  dcl 2467 set ref 72* 1157 1598
system_privilege_$initiate      004124 constant        entry                    external dcl 2636 ref 604
temp_attach_description         000752 internal static char(256)                packed unaligned dcl 2528 set ref 455* 456 456* 457
                                                                                  462* 463 463* 464
terminal_info                          based           structure                level 1 dcl 24-6
terminal_info_version                  constant        fixed bin(17,0)          initial dcl 24-16 ref 749
terminate_file_                 004126 constant        entry                    external dcl 2637 ref 139 151 660
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  107 138* 150* 583 592* 658*
test_initiate_entry             000146 automatic       entry variable           dcl 2525 set ref 604*
text_offset                            based           structure                level 1 packed packed unaligned dcl 16-45
text_strings                           based           structure                level 1 dcl 16-39
text_strings_ptr                000304 automatic       pointer                  dcl 16-38 in procedure "imft_driver_" set ref 77*
                                                                                  139 139 151 151 217 217 660 660
text_strings_ptr         14            based           pointer                  level 2 in structure "iodd_static" dcl 18-17
                                                                                  in procedure "imft_driver_" ref 77
timeout                   2     000172 internal static fixed bin(35,0)          level 2 dcl 2489 set ref 124* 181* 203* 1081* 1108*
                                                                                  1110* 1336* 1388* 1504* 1535* 1537* 1730* 1798*
                                                                                  1862* 1890* 2273* 2289*
timer_manager_$sleep            004130 constant        entry                    external dcl 2638 ref 889 2013 2252
total_chars             164(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 18-17
                                                                                  ref 219
translate_aim_attributes_       004132 constant        entry                    external dcl 2639 ref 1211 1226 1246 1261 1617 1698
                                                                                  1707
trigger_loop_count              001052 internal static fixed bin(17,0)          dcl 2529 set ref 2308*
trigger_text            406     003070 internal static char(256)                level 3 packed packed unaligned dcl 2538 set ref
                                                                                  365* 366 2208 2208
trsi                            000126 automatic       structure                level 1 dcl 2478 set ref 705 705 1879 1879
tty_read_status_info                   based           structure                level 1 dcl 27-17
v2_aim2_record                         based           structure                level 1 dcl 14-80 set ref 1178 1365 1770
validate_system_id        1(11) 003070 internal static bit(1)                   level 3 packed packed unaligned dcl 2538 set ref
                                                                                  271* 273* 277 297
value                           001054 internal static fixed bin(35,0)          dcl 2531 set ref 923* 931 931 932
version                  76            based           char(8)                  level 3 in structure "ft_request" dcl 12-16
                                                                                  in procedure "imft_driver_" ref 857
version                         003642 internal static char(8)                  level 2 in structure "static_fis_info" dcl 2539
                                                                                  in procedure "imft_driver_" set ref 711*
version                         000172 internal static char(8)                  level 2 in structure "local_icri" dcl 2489
                                                                                  in procedure "imft_driver_" set ref 123* 180* 202*
                                                                                  1080* 1107* 1335* 1387* 1503* 1534* 1729* 1797*
                                                                                  1861* 1889* 2272* 2288*
version                         000106 automatic       fixed bin(17,0)          level 2 in structure "local_terminal_info" dcl 2476
                                                                                  in procedure "imft_driver_" set ref 749*
version                                based           char(8)                  level 2 in structure "aim_attributes" packed packed
                                                                                  unaligned dcl 2-6 in procedure "imft_driver_" set
                                                                                  ref 1149 1592
version                         000226 internal static fixed bin(17,0)          level 2 in structure "dma" dcl 2494 in procedure
                                                                                  "imft_driver_" set ref 2098*
version                         000203 internal static char(8)                  level 2 in structure "local_gcn" dcl 2491
                                                                                  in procedure "imft_driver_" set ref 2375*
wait_list                30     003642 internal static structure                level 2 dcl 2539
which_channel                   000340 automatic       char(32)                 packed unaligned dcl 2048 set ref 2121* 2133

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_MICROSECONDS                  internal static bit(2)                   initial packed unaligned dcl 26-11
ABSOLUTE_SECONDS                       internal static bit(2)                   initial packed unaligned dcl 26-12
ALWAYS_CHASE                           internal static bit(2)                   initial dcl 12-47
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 15-15
ATTACH_TYPE_IOM                        internal static fixed bin(17,0)          initial dcl 15-15
ATTACH_TYPE_VARIABLE_LINE              internal static fixed bin(17,0)          initial dcl 15-15
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
CTL_ATTACH_TYPE_DIAL                   internal static fixed bin(17,0)          initial dcl 15-21
CTL_ATTACH_TYPE_MC                     internal static fixed bin(17,0)          initial dcl 15-21
CTL_ATTACH_TYPE_TTY                    internal static fixed bin(17,0)          initial dcl 15-21
DEFAULT_CHASE                          internal static bit(2)                   initial dcl 12-47
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 19-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 19-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 19-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
IMFT_ABORT                             internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22
IMFT_ABORT_ABORTED                     internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_CANCELLED                   internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_DEFERRED                    internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_IO_ERROR                    internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_LOCAL_IO_ERROR              internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_RESTARTED                   internal static fixed bin(17,0)          initial dcl 14-54
IMFT_ABORT_SAVED                       internal static fixed bin(17,0)          initial dcl 14-54
IMFT_DATA                              internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 14-22
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 16-49
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 19-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 19-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 19-15
MERGE_DIRECTORIES                      internal static bit(2)                   initial dcl 12-43
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 20-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 20-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 20-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 20-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 20-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 20-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 20-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 20-30
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NEVER_CHASE                            internal static bit(2)                   initial dcl 12-47
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PAPER_TYPE_CONTINUOUS                  internal static fixed bin(17,0)          initial dcl 15-26
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 15-26
PAPER_TYPE_SINGLE                      internal static fixed bin(17,0)          initial dcl 15-26
RELATIVE_MICROSECONDS                  internal static bit(2)                   initial packed unaligned dcl 26-13
REPLACE_DIRECTORIES                    internal static bit(2)                   initial dcl 12-43
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SLAVE                                  internal static fixed bin(17,0)          initial dcl 17-14
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 21-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 21-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 21-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 21-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 21-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 21-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 21-41
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 19-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 19-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 19-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 19-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 19-15
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 25-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 25-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 25-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 25-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 25-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 25-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
abort_command                          based           structure                level 1 dcl 14-48
abort_command_ptr                      automatic       pointer                  dcl 14-52
aim_attributes_ptr                     automatic       pointer                  dcl 2-16
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
dial_manager_arg_version_2             internal static fixed bin(17,0)          initial dcl 4-10
dial_manager_arg_version_3             internal static fixed bin(17,0)          initial dcl 4-11
dial_manager_arg_version_4             internal static fixed bin(17,0)          initial dcl 4-12
driver_status_ptr                      automatic       pointer                  dcl 6-24
event_wait_info_ptr                    automatic       pointer                  dcl 8-5
fis_info_ptr                           automatic       pointer                  dcl 11-16
ft_request_ptr                         automatic       pointer                  dcl 12-36
get_channel_names_ptr                  automatic       pointer                  dcl 13-16
icri_ptr                               automatic       pointer                  dcl 9-16
imft_driver_info_ptr                   automatic       pointer                  dcl 10-66
iod_tables_hdr                         based           structure                level 1 dcl 16-23
iox_modes                              internal static char(24)                 initial array dcl 19-6
ithp                                   automatic       pointer                  dcl 16-22
mseg_message_info_ptr                  automatic       pointer                  dcl 20-7
set_term_type_info                     based           structure                level 1 dcl 23-8
short_iox_modes                        internal static char(4)                  initial array dcl 19-12
stti_version_1                         internal static fixed bin(17,0)          initial dcl 23-5
sttip                                  automatic       pointer                  dcl 23-6
terminal_info_ptr                      automatic       pointer                  dcl 24-15
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 25-4
tty_read_status_info_ptr               automatic       pointer                  dcl 27-21
tty_write_status_info                  based           structure                level 1 dcl 27-23
tty_write_status_info_ptr              automatic       pointer                  dcl 27-27

NAMES DECLARED BY EXPLICIT CONTEXT.
ACTION_ERROR                    027033 constant        label                    dcl 2235 ref 2176 2180
ACTION_RETRY                    027115 constant        label                    dcl 2246 ref 2223
BAD_LINE_STATEMENT              003431 constant        label                    dcl 82 ref 88
BAD_PAUSE_TIME_SPECIFICATION    014304 constant        label                    dcl 925 ref 931
CANT_ESTABLISH_CEILING          022572 constant        label                    dcl 1608 in procedure
                                                                                  "establish_output_access_ceiling" ref 1619
CANT_ESTABLISH_CEILING          017503 constant        label                    dcl 1193 in procedure
                                                                                  "establish_input_access_ceiling" ref 1214 1230
                                                                                  1249 1265
COMMAND_ERROR                   014707 constant        label                    dcl 974 ref 920 929 940 964
COULD_NOT_RAISE_REMOTE          024525 constant        label                    dcl 1882 ref 1894
DROP_DEVICE_COMMON              025011 constant        label                    dcl 1953 ref 1941
IN_DIAL_ERROR                   025515 constant        label                    dcl 2106 ref 2095 2125 2130
LOGOUT_SLAVE                    013005 constant        label                    dcl 671 set ref 146
PREPARE_TO_CALL_IODD_LISTEN_    012615 constant        label                    dcl 637 ref 626
RESYNCHRONIZE_DRIVER            012373 constant        label                    dcl 615 ref 171 189 1122 1400 1543 1554 1804 1815
RETURN_FROM_INIT                012706 constant        label                    dcl 658 ref 223 233 240 247 256 262 268 285 291 306
                                                                                  312 331 369 387 400 415 436 444 452 460 467 478
                                                                                  490 499 514 522 531 555 565 578 601 708 1009 1016
                                                                                  1026 1035 1056 1091 1128 1152 1164 1187 1197 1204
                                                                                  1237 1272 1300 1315 1346 1406 1436 1444 1451 1462
                                                                                  1471 1479 1520 1560 1584 1595 1612 1631 1639 1654
                                                                                  1666 1687 1702 1711 1746 1821 2111 2246 2412 2419
                                                                                  2436
attach_and_init_line            014756 constant        entry                    internal dcl 684 ref 169 608 615 827 946
attach_line                     025366 constant        entry                    internal dcl 2035 ref 703 741
check_for_resync_request        024202 constant        entry                    internal dcl 1833 ref 610
close_and_detach                025142 constant        entry                    internal dcl 1993 ref 1972
command                         013763 constant        entry                    external dcl 895
default_handler                 014716 constant        entry                    external dcl 980
delay_idle_down                 024466 constant        label                    dcl 1879 ref 1850
detach_device                   024774 constant        entry                    internal dcl 1946 ref 155 634
drop_device                     024763 constant        entry                    internal dcl 1934 ref 143 168 664 678 1872 2076 2089
                                                                                  2251
establish_input_access_ceiling  017204 constant        entry                    internal dcl 1141 ref 780
establish_output_access_ceiling 022367 constant        entry                    internal dcl 1573 ref 785
free_aim_attributes_storage     024733 constant        entry                    internal dcl 1916 ref 156 665 1155 1578
get_data_channel_names          030114 constant        entry                    internal dcl 2370 ref 2192
get_line                        027334 constant        entry                    internal dcl 2285 ref 2213 2309
get_switch_name                 027627 constant        entry                    internal dcl 2323 ref 2170
hangup_protocol                 026725 constant        label                    dcl 2215 ref 2262 2279 2295 2317
idled                           024456 constant        label                    dcl 1874 ref 1853
imft_driver_                    003320 constant        entry                    external dcl 47
init                            003332 constant        entry                    external dcl 54
nulle                           025357 constant        entry                    internal dcl 2026 ref 2002 2002 2005
protocol_hangup                 027146 constant        entry                    internal dcl 2260 ref 2205 2205
put_chars                       027157 constant        entry                    internal dcl 2267 ref 2196 2212
read_aim_command                020773 constant        entry                    internal dcl 1382 ref 1147 1174
read_aim_reply                  024011 constant        entry                    internal dcl 1792 ref 1590 1679 1739
read_sync_command               017035 constant        entry                    internal dcl 1102 ref 1001 1042
read_sync_reply                 022154 constant        entry                    internal dcl 1529 ref 1425 1476 1513
request                         013226 constant        entry                    external dcl 819
resynch_and_validate            015536 constant        entry                    internal dcl 776 ref 621 828 947
retry_attach                    025407 constant        label                    dcl 2081 ref 2253
set_hangup_proc                 027755 constant        entry                    internal dcl 2341 ref 2189 2227
synchronize_input_driver        016047 constant        entry                    internal dcl 998 ref 779
synchronize_output_driver       021122 constant        entry                    internal dcl 1419 ref 784
validate_request_type           030250 constant        entry                    internal dcl 2399 ref 697 727
wait_for_trigger                027504 constant        entry                    internal dcl 2303 ref 2208 2225
write_aim2_command              023721 constant        entry                    internal dcl 1757 ref 1611 1630 1638 1653 1665 1675
write_aim2_reply                020727 constant        entry                    internal dcl 1357 ref 1196 1203 1236 1271 1299 1314
                                                                                  1321
write_aim_command               023572 constant        entry                    internal dcl 1721 ref 1587 1784
write_aim_reply                 020611 constant        entry                    internal dcl 1327 ref 1167 1365 1373 1399
write_sync_command              021751 constant        entry                    internal dcl 1486 ref 1422 1443 1450 1461 1470 1475
write_sync_reply                016643 constant        entry                    internal dcl 1063 ref 1008 1015 1025 1034 1040 1045
                                                                                  1121
yes_no_p                        030430 constant        entry                    internal dcl 2425 ref 273 380 389 525 540 549 559
                                                                                  585 588

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     32766       37122   31401       32776
Length     41312   31401      4134        2153    1365        3716

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
imft_driver_                       1728 external procedure  is an external procedure.  
on unit on line 119                  92 on unit               
on unit on line 146                  64 on unit               
on unit on line 148                  96 on unit               
on unit on line 160                 130 on unit               
on unit on line 176                 102 on unit               
on unit on line 192                 106 on unit               
on unit on line 199                  90 on unit               
on unit on line 597                 104 on unit               
on unit on line 610                 238 on unit               
on unit on line 625                  64 on unit               
on unit on line 626                  64 on unit               
attach_and_init_line                224 internal procedure  is called by several nonquick procedures.  
resynch_and_validate                    internal procedure  shares stack frame of external procedure imft_driver_.  
on unit on line 875                  86 on unit               
synchronize_input_driver                internal procedure  shares stack frame of external procedure imft_driver_.  
write_sync_reply                        internal procedure  shares stack frame of external procedure imft_driver_.  
read_sync_command                       internal procedure  shares stack frame of external procedure imft_driver_.  
establish_input_access_ceiling
                                        internal procedure  shares stack frame of external procedure imft_driver_.  
write_aim_reply                         internal procedure  shares stack frame of external procedure imft_driver_.  
write_aim2_reply                        internal procedure  shares stack frame of external procedure imft_driver_.  
read_aim_command                        internal procedure  shares stack frame of external procedure imft_driver_.  
synchronize_output_driver               internal procedure  shares stack frame of external procedure imft_driver_.  
write_sync_command                      internal procedure  shares stack frame of external procedure imft_driver_.  
read_sync_reply                         internal procedure  shares stack frame of external procedure imft_driver_.  
establish_output_access_ceiling
                                        internal procedure  shares stack frame of external procedure imft_driver_.  
write_aim_command                       internal procedure  shares stack frame of external procedure imft_driver_.  
write_aim2_command                      internal procedure  shares stack frame of external procedure imft_driver_.  
read_aim_reply                          internal procedure  shares stack frame of external procedure imft_driver_.  
check_for_resync_request                internal procedure  shares stack frame of on unit on line 610.  
free_aim_attributes_storage          64 internal procedure  is called by several nonquick procedures.  
drop_device                         122 internal procedure  is called by several nonquick procedures.  
close_and_detach                        internal procedure  shares stack frame of internal procedure drop_device.  
nulle                                64 internal procedure  is assigned to an entry variable.  
attach_line                         512 internal procedure  enables or reverts conditions.  
on unit on line 2089                 64 on unit               
protocol_hangup                      64 internal procedure  is assigned to an entry variable.  
put_chars                           122 internal procedure  is called during a stack extension.  
get_line                            122 internal procedure  is called by several nonquick procedures.  
wait_for_trigger                    134 internal procedure  is called during a stack extension.  
get_switch_name                         internal procedure  shares stack frame of internal procedure attach_line.  
set_hangup_proc                         internal procedure  shares stack frame of internal procedure attach_line.  
get_data_channel_names                  internal procedure  shares stack frame of internal procedure attach_line.  
validate_request_type                   internal procedure  shares stack frame of internal procedure attach_and_init_line.  
yes_no_p                                internal procedure  shares stack frame of external procedure imft_driver_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 driver_ptr                  imft_driver_
000012 major_args_path             imft_driver_
000075 major_args_dirname          imft_driver_
000147 major_args_ename            imft_driver_
000157 major_args_component        imft_driver_
000167 major_args_bc               imft_driver_
000170 system_area_ptr             imft_driver_
000172 local_icri                  imft_driver_
000203 local_gcn                   imft_driver_
000225 have_channel_names          imft_driver_
000226 dma                         imft_driver_
000366 ev_wait_info                imft_driver_
000375 status_flags                imft_driver_
000376 ds_ptr                      imft_driver_
000400 devp                        imft_driver_
000402 rd_ptr                      imft_driver_
000404 max_access_class_string     imft_driver_
000504 max_access_class_octal      imft_driver_
000514 min_access_class_string     imft_driver_
000614 min_access_class_octal      imft_driver_
000624 local_explicit_ceiling      imft_driver_
000626 foreign_explicit_ceiling    imft_driver_
000630 local_explicit_floor        imft_driver_
000632 foreign_explicit_floor      imft_driver_
000634 local_explicit_ceiling_given
                                   imft_driver_
000635 local_explicit_floor_given  imft_driver_
000636 foreign_system_version      imft_driver_
000637 keyword_value               imft_driver_
000647 code                        imft_driver_
000650 ignore_code                 imft_driver_
000651 saved_code                  imft_driver_
000652 character_buffer            imft_driver_
000752 temp_attach_description     imft_driver_
001052 trigger_loop_count          imft_driver_
001053 source                      imft_driver_
001054 value                       imft_driver_
001055 condition                   imft_driver_
001065 input_buffer                imft_driver_
002065 output_buffer               imft_driver_
003065 saved_test_entry            imft_driver_
003066 send_logout_record          imft_driver_
003070 static                      imft_driver_
003642 static_fis_info             imft_driver_
003720 static_pause_time           imft_driver_
003722 attachment_count            imft_driver_
003724 stat_p                      imft_driver_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
attach_and_init_line     000110 req_type_site               validate_request_type
attach_line              000100 attach_description          attach_line
                         000301 code                        attach_line
                         000302 error_message               attach_line
                         000322 io_module                   attach_line
                         000332 no_dialed                   attach_line
                         000333 open_mode                   attach_line
                         000334 previous_attach_code        attach_line
                         000335 prev_proto_error            attach_line
                         000336 sleep_time                  attach_line
                         000340 which_channel               attach_line
drop_device              000100 send_hangup                 drop_device
                         000102 iocb_ptr                    drop_device
imft_driver_             000100 major_args_lth              imft_driver_
                         000102 major_args_ptr              imft_driver_
                         000104 arglist_ptr                 imft_driver_
                         000106 local_terminal_info         imft_driver_
                         000126 trsi                        imft_driver_
                         000132 hangup_info                 imft_driver_
                         000142 p                           imft_driver_
                         000144 i                           imft_driver_
                         000145 my_ring                     imft_driver_
                         000146 test_initiate_entry         imft_driver_
                         000270 condition_info_ptr          imft_driver_
                         000272 list_ptr                    imft_driver_
                         000274 event_wait_channel          imft_driver_
                         000300 sync_record_ptr             imft_driver_
                         000302 aim2_record_ptr             imft_driver_
                         000304 text_strings_ptr            imft_driver_
                         000332 code                        write_sync_reply
                         000350 local_aim2_record           establish_input_access_ceiling
                         000370 code                        write_aim_reply
                         000422 code                        write_sync_command
                         000446 code                        write_aim_command
                         000456 record_size                 write_aim2_command

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other      return_mac          move_label_var
make_label_var      tra_ext_1           tra_ext_2           signal_op           enable_op           shorten_stack
ext_entry           int_entry           int_entry_desc      set_chars_eis       index_chars_eis     any_to_any_round_
op_alloc_           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              aim_check_$equal              aim_check_$greater            aim_check_$greater_or_equal
compute_common_aim_ceiling_   continue_to_signal_           convert_aim_attributes_
convert_authorization_$from_string                          convert_authorization_$to_string_short
convert_dial_message_$return_io_module                      cv_dec_check_                 date_time_$format
dial_manager_$allow_dials     dial_manager_$shutoff_dials   expand_pathname_$component    get_authorization_
get_ring_                     get_system_aim_attributes_    get_system_free_area_
imft_convert_status_code_$decode                            imft_convert_status_code_$encode
imft_pnt_interface_$get_system_password                     imft_receive_object_          imft_transmit_object_
imft_transmit_object_$abort_running_request                 initiate_file_$component      iodd_command_processor_
iodd_hangup_                  iodd_listen_                  iodd_msg_                     iodd_parse_$args
iodd_quit_handler_            iodd_quit_handler_$command_level                            iox_$attach_ioname
iox_$close                    iox_$control                  iox_$destroy_iocb             iox_$detach_iocb
iox_$open                     ipc_$block                    ipc_$create_ev_chn            ipc_$decl_ev_call_chn
ipc_$decl_ev_wait_chn         ipc_$delete_ev_chn            ipc_$drain_chn                pathname_$component
requote_string_               system_privilege_$initiate    terminate_file_               timer_manager_$sleep
translate_aim_attributes_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$ai_outside_common_range
error_table_$bad_conversion   error_table_$fatal_error      error_table_$inconsistent     error_table_$noarg
error_table_$unimplemented_version                          imft_et_$cant_get_channel_names
imft_et_$computed_ceiling_mismatch                          imft_et_$explicit_ceiling_mismatch
imft_et_$explicit_floor_mismatch                            imft_et_$non_matching_ids
imft_et_$non_matching_passwords                             imft_et_$non_matching_versions
imft_et_$process_authorization_too_low                      imft_et_$reply_pending




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7    8 003313        47 003317        50 003326        54 003327        65 003340        66 003347        67 003352
     69 003405        72 003406        74 003415        75 003422        77 003424        79 003426        82 003431
     85 003464        88 003465        90 003471        91 003474        93 003526        96 003527        99 003535
    100 003537       101 003543       102 003552       104 003554       107 003557       108 003564       109 003566
    110 003570       115 003572       116 003574       117 003575       119 003577       121 003613       122 003615
    123 003620       124 003622       125 003624       126 003626       127 003630       131 003670       132 003671
    133 003676       135 003731       138 003762       139 003771       143 004052       144 004057       119 004060
    146 004072       148 004111       150 004125       151 004133       155 004214       156 004221       157 004226
    158 004233       160 004234       162 004250       163 004251       166 004320       167 004324       168 004327
    169 004334       171 004341       173 004344       174 004347       176 004350       178 004364       179 004423
    180 004427       181 004431       182 004433       183 004436       184 004440       185 004442       189 004476
    192 004501       194 004515       196 004550       197 004555       199 004556       201 004572       202 004575
    203 004577       204 004601       205 004604       206 004606       207 004610       211 004644       212 004653
    217 004654       219 004677       221 004704       222 004705       223 004740       226 004741       228 004775
    229 005001       231 005030       232 005033       233 005070       235 005071       237 005130       238 005133
    240 005214       242 005215       243 005221       244 005233       245 005235       247 005320       251 005321
    252 005356       255 005371       256 005427       259 005430       260 005465       261 005471       262 005523
    264 005524       265 005533       267 005542       268 005600       271 005601       272 005603       273 005640
    275 005676       277 005733       280 005741       281 005745       283 005765       284 005770       285 006030
    287 006031       289 006032       291 006064       295 006065       297 006123       300 006131       301 006135
    303 006155       304 006160       306 006220       308 006221       310 006222       312 006254       316 006255
    317 006313       318 006323       319 006325       320 006331       321 006332       322 006336       323 006340
    324 006342       325 006343       326 006347       327 006351       328 006353       330 006354       331 006412
    334 006413       336 006421       338 006425       343 006435       344 006444       346 006446       347 006503
    348 006507       349 006511       350 006513       352 006514       353 006551       360 006555       361 006557
    362 006614       364 006655       365 006665       366 006722       367 006726       369 006760       376 006761
    377 006764       378 007021       380 007030       382 007065       383 007122       384 007126       385 007131
    387 007163       389 007164       391 007221       392 007256       395 007265       396 007307       397 007315
    400 007353       403 007354       406 007355       407 007412       410 007421       412 007443       413 007452
    415 007510       418 007511       423 007512       424 007547       426 007610       429 007620       430 007624
    431 007661       433 007721       435 007725       436 007757       439 007760       440 010015       442 010055
    443 010061       444 010113       446 010114       449 010115       450 010120       452 010152       455 010153
    456 010210       457 010250       458 010254       460 010306       462 010307       463 010344       464 010404
    465 010410       467 010442       471 010443       472 010445       473 010502       474 010506       475 010510
    476 010530       477 010533       478 010570       482 010571       483 010574       484 010575       485 010632
    486 010636       487 010640       488 010660       489 010663       490 010720       494 010721       496 010742
    499 011005       503 011006       504 011044       505 011054       506 011056       507 011062       508 011063
    509 011073       510 011075       511 011101       513 011102       514 011140       517 011141       518 011176
    519 011202       520 011205       522 011240       525 011241       527 011267       529 011273       531 011325
    534 011326       536 011330       537 011365       540 011374       541 011431       543 011432       544 011435
    546 011436       548 011440       549 011475       553 011541       555 011574       558 011575       559 011632
    563 011673       565 011726       568 011727       569 011764       572 011773       574 012012       575 012022
    578 012057       582 012060       583 012064       584 012070       585 012125       587 012164       588 012221
    592 012260       597 012265       599 012301       601 012334       604 012337       606 012344       608 012345
    610 012351       615 012373       618 012405       619 012411       621 012413       623 012414       625 012423
    626 012444       627 012463       629 012526       631 012550       632 012553       634 012606       635 012612
    637 012615       640 012617       643 012620       644 012623       645 012633       646 012640       648 012671
    649 012673       653 012677       658 012706       660 012715       664 012774       665 013000       666 013004
    671 013005       673 013011       674 013013       677 013130       678 013161       679 013165       680 013221
    819 013225       824 013234       825 013240       826 013244       827 013277       828 013303       831 013304
    832 013306       835 013311       837 013314       838 013317       840 013361       841 013365       842 013367
    843 013371       846 013372       847 013376       851 013450       852 013454       853 013456       854 013460
    857 013461       859 013470       863 013542       864 013546       865 013550       866 013552       873 013553
    875 013556       878 013623       881 013646       882 013651       884 013704       887 013707       889 013740
    891 013755       895 013756       898 013771       899 013775       901 014000       903 014002       907 014004
    908 014011       909 014044       912 014103       913 014136       915 014174       917 014175       918 014207
    919 014212       920 014245       922 014246       923 014251       924 014300       925 014304       929 014346
    931 014347       932 014353       933 014356       934 014357       935 014361       937 014362       938 014367
    939 014372       940 014425       945 014426       946 014433       947 014437       950 014440       952 014503
    954 014525       955 014530       957 014563       959 014566       961 014567       962 014601       963 014604
    964 014637       966 014640       967 014700       969 014701       971 014702       972 014706       974 014707
    976 014713       980 014714       983 014724       985 014730       987 014735       990 014754       684 014755
    686 014763       691 014766       692 014772       694 015024       697 015025       698 015033       700 015037
    703 015104       705 015111       706 015146       707 015151       708 015203       711 015206       712 015210
    713 015213       714 015216       715 015222       716 015225       717 015230       724 015231       725 015235
    727 015246       728 015255       730 015260       733 015326       734 015332       735 015336       738 015340
    741 015400       743 015405       745 015411       747 015413       749 015415       750 015420       752 015453
    754 015465       756 015470       757 015474       758 015500       759 015502       760 015504       761 015507
    762 015512       763 015516       764 015521       765 015523       766 015525       767 015527       768 015532
    769 015534       772 015535       776 015536       778 015537       779 015543       780 015544       781 015545
    784 015546       785 015547       791 015550       792 015571       793 015574       794 015604       797 015610
    798 015613       800 015633       801 015636       802 015646       804 015652       805 015653       807 015656
    813 016046       998 016047      1001 016050      1003 016052      1004 016055      1005 016061      1008 016122
   1009 016155      1012 016156      1013 016163      1015 016221      1016 016253      1019 016254      1021 016257
   1022 016262      1025 016320      1026 016352      1028 016353      1030 016354      1031 016361      1034 016422
   1035 016454      1040 016455      1042 016507      1044 016511      1045 016514      1049 016525      1050 016535
   1054 016604      1056 016641      1059 016642      1063 016643      1073 016661      1074 016664      1075 016672
   1076 016677      1077 016707      1078 016716      1080 016723      1081 016726      1082 016730      1083 016737
   1084 016740      1086 016742      1088 016773      1089 016775      1091 017033      1094 017034      1102 017035
   1107 017037      1108 017042      1110 017062      1111 017064      1112 017066      1114 017070      1116 017121
   1121 017136      1122 017144      1126 017145      1128 017202      1131 017203      1141 017204      1147 017205
   1149 017207      1150 017214      1152 017251      1155 017252      1157 017256      1158 017265      1160 017270
   1162 017313      1163 017315      1164 017350      1167 017351      1174 017366      1176 017370      1177 017374
   1178 017376      1179 017407      1181 017410      1183 017412      1184 017414      1185 017424      1187 017462
   1190 017463      1192 017501      1193 017503      1196 017541      1197 017543      1200 017544      1201 017563
   1203 017621      1204 017630      1207 017631      1208 017641      1210 017646      1211 017650      1214 017666
   1215 017670      1216 017671      1218 017673      1223 017715      1224 017733      1226 017736      1230 017754
   1231 017756      1234 017757      1236 020015      1237 020024      1241 020025      1242 020031      1243 020041
   1245 020045      1246 020047      1249 020065      1250 020067      1251 020070      1253 020072      1258 020114
   1259 020132      1261 020135      1265 020153      1266 020155      1269 020156      1271 020214      1272 020223
   1274 020224      1275 020225      1278 020230      1281 020246      1283 020267      1284 020271      1285 020302
   1288 020306      1290 020327      1291 020331      1292 020342      1295 020346      1299 020431      1300 020440
   1304 020441      1305 020466      1307 020507      1308 020511      1309 020522      1311 020526      1314 020576
   1315 020605      1321 020606      1323 020610      1327 020611      1335 020613      1336 020616      1337 020620
   1338 020627      1339 020632      1341 020634      1343 020665      1344 020667      1346 020725      1349 020726
   1357 020727      1362 020731      1363 020734      1365 020744      1369 020755      1370 020757      1371 020763
   1373 020766      1376 020772      1382 020773      1387 020775      1388 021000      1389 021002      1390 021004
   1392 021006      1394 021037      1399 021054      1400 021061      1404 021062      1406 021120      1409 021121
   1419 021122      1422 021123      1425 021155      1427 021157      1428 021162      1429 021164      1430 021174
   1434 021243      1436 021300      1439 021301      1440 021305      1443 021346      1444 021401      1447 021402
   1448 021407      1450 021445      1451 021477      1455 021500      1457 021503      1458 021506      1461 021544
   1462 021576      1464 021577      1466 021600      1467 021605      1470 021646      1471 021700      1475 021701
   1476 021707      1477 021711      1478 021714      1479 021747      1482 021750      1486 021751      1496 021767
   1497 021772      1498 022000      1499 022005      1500 022015      1501 022024      1503 022031      1504 022034
   1505 022036      1506 022045      1507 022046      1509 022050      1511 022104      1513 022107      1518 022115
   1520 022152      1523 022153      1529 022154      1534 022156      1535 022161      1537 022201      1538 022203
   1539 022205      1541 022207      1543 022243      1547 022252      1551 022266      1554 022327      1558 022330
   1560 022365      1563 022366      1573 022367      1578 022370      1580 022374      1582 022420      1583 022423
   1584 022455      1587 022456      1590 022472      1592 022474      1593 022501      1595 022536      1598 022537
   1599 022546      1605 022551      1607 022567      1608 022572      1611 022630      1612 022637      1615 022640
   1617 022657      1619 022676      1620 022701      1621 022725      1623 022746      1624 022751      1625 022761
   1627 022765      1630 023034      1631 023043      1633 023044      1636 023045      1638 023103      1639 023112
   1640 023113      1643 023114      1644 023140      1646 023161      1647 023164      1648 023174      1650 023200
   1653 023247      1654 023256      1658 023257      1659 023263      1660 023265      1662 023302      1665 023331
   1666 023340      1669 023341      1670 023344      1672 023345      1675 023347      1679 023351      1681 023353
   1683 023356      1684 023360      1685 023370      1687 023426      1690 023427      1692 023434      1693 023436
   1695 023440      1698 023441      1700 023457      1701 023462      1702 023510      1705 023511      1707 023515
   1709 023533      1710 023536      1711 023564      1714 023565      1717 023571      1721 023572      1729 023574
   1730 023577      1731 023601      1732 023610      1733 023613      1735 023615      1737 023651      1739 023654
   1744 023662      1746 023717      1749 023720      1757 023721      1763 023723      1764 023726      1766 023736
   1767 023742      1768 023746      1769 023750      1770 023753      1771 023755      1774 023756      1775 023762
   1776 023766      1777 023771      1778 023774      1779 024001      1781 024004      1784 024006      1786 024010
   1792 024011      1797 024013      1798 024016      1799 024020      1800 024022      1802 024024      1804 024060
   1808 024067      1812 024101      1815 024142      1819 024143      1821 024200      1824 024201      1833 024202
   1843 024203      1849 024211      1850 024212      1853 024215      1855 024222      1856 024225      1857 024227
   1860 024345      1861 024351      1862 024353      1863 024355      1864 024357      1866 024361      1867 024365
   1871 024420      1872 024451      1874 024456      1876 024465      1879 024466      1881 024522      1882 024525
   1885 024560      1888 024563      1889 024566      1890 024571      1891 024573      1892 024575      1893 024577
   1894 024633      1896 024636      1898 024646      1901 024656      1904 024717      1908 024722      1910 024731
   1916 024732      1922 024740      1924 024746      1926 024751      1928 024756      1930 024761      1934 024762
   1940 024770      1941 024772      1946 024773      1949 025001      1951 025010      1953 025011      1955 025015
   1956 025020      1957 025022      1961 025026      1963 025032      1964 025035      1965 025036      1966 025040
   1967 025043      1970 025046      1972 025052      1977 025054      1978 025063      1979 025073      1980 025106
   1981 025117      1982 025130      1985 025133      1987 025141      1993 025142      1999 025144      2001 025151
   2002 025154      2005 025211      2006 025217      2007 025221      2008 025223      2013 025255      2014 025266
   2017 025317      2019 025331      2020 025343      2021 025355      2026 025356      2029 025364      2035 025365
   2076 025373      2078 025405      2079 025406      2081 025407      2089 025412      2091 025434      2092 025441
   2093 025451      2094 025453      2095 025456      2098 025457      2099 025462      2101 025476      2103 025510
   2104 025512      2106 025515      2111 025575      2114 025600      2115 025615      2121 025633      2123 025667
   2124 025671      2125 025674      2128 025675      2129 025701      2130 025704      2133 025705      2134 025757
   2141 026023      2143 026035      2145 026042      2146 026045      2147 026057      2148 026061      2150 026062
   2151 026074      2154 026076      2155 026101      2156 026113      2157 026167      2160 026171      2161 026203
   2163 026257      2164 026272      2165 026347      2167 026350      2168 026366      2170 026403      2172 026412
   2174 026451      2176 026457      2179 026461      2180 026500      2182 026502      2186 026503      2189 026540
   2192 026546      2196 026547      2198 026567      2205 026574      2208 026617      2212 026650      2213 026710
   2214 026715      2215 026725      2221 027005      2222 027013      2223 027015      2225 027016      2227 027031
   2229 027032      2235 027033      2241 027114      2246 027115      2250 027124      2251 027126      2252 027133
   2253 027144      2260 027145      2262 027153      2267 027156      2272 027172      2273 027174      2274 027176
   2275 027201      2276 027203      2278 027204      2279 027236      2280 027244      2282 027331      2285 027333
   2288 027341      2289 027343      2290 027345      2291 027347      2292 027350      2294 027352      2295 027407
   2296 027415      2298 027501      2303 027503      2308 027517      2309 027530      2310 027535      2312 027546
   2313 027550      2317 027624      2323 027627      2326 027631      2328 027633      2331 027640      2333 027710
   2341 027755      2344 027756      2347 030010      2348 030015      2349 030017      2350 030021      2353 030053
   2357 030113      2370 030114      2373 030115      2375 030117      2377 030122      2379 030153      2380 030155
   2381 030160      2383 030170      2384 030174      2386 030175      2391 030247      2399 030250      2405 030252
   2407 030272      2410 030312      2412 030352      2415 030355      2416 030362      2419 030424      2421 030427
   2425 030430      2430 030446      2431 030457      2433 030466      2434 030476      2436 030543      2439 030544


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
