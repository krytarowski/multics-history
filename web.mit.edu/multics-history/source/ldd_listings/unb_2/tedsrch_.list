	COMPILATION LISTING OF SEGMENT tedsrch_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/18/84  0925.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
       12 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
       13 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
       14 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       15 
       16 /*							       */
       17 /*    _|_              |                       |			       */
       18 /*     |      _      _ |   ___     _      _    | _		       */
       19 /*     |     / \    / \|  /  _   |/ \    / \   |/ \		       */
       20 /*     |    (__/   (   |  \_/ \  |      (      |   |		       */
       21 /*     \_    \_/    \_/|   ___/  |       \_/   |   |		       */
       22 /*                                                    -----		       */
       23 /*							       */
       24 
       25 /* ted utility procedure to search addressed portion of buffer with	       */
       26 /*  specified regular expression				       */
       27 
       28 tedsrch_:				/* dummy entry		       */
       29    proc ();
       30    return;
       31 
       32 /* UPDATE HISTORY (finally)					       */
       33 /* EL#   date	TR	comments				       */
       34 /* --- 84-??-??          implement an output switch for debugging	       */
       35 /* 146 84-10-10 phx17390 /^..*a/ loops when "a" is first char of buffer      */
       36 /*              phx17429 global-if "/^..*X/ P" loops on lines like "X"       */
       37 /*              phx17531 /^...*>/ also loops when line begins with ">"       */
       38 /* 150 84-10-12 phx17701 interprets "/ * /" incorrectly.		       */
       39 
       40 /**** input string, which is expression				       */
       41 dcl in_p		ptr;		/* -> expression		       */
       42 dcl in_l		fixed bin (21);	/*   length thereof		       */
       43 dcl in_s		char (in_l) based (in_p); /* expression as a string      */
       44 dcl in_c		(in_l) char (1) based (in_p);	  /* expression as chars   */
       45 
       46 /**** data refering to the string being searched			       */
       47 dcl file_str	char (part.right_loc) based (b.cur.sp);
       48 dcl file_char	(part.right_loc) char (1) based (b.cur.sp);
       49 /**** A buffer consists of an upper part and a lower part, either of which   */
       50 /****  may be empty. The next 4 variables describe the part being worked in. */
       51 dcl 1 part,
       52       2 min_left	fixed bin (21),	/* lowest location to consider       */
       53       2 left_loc	fixed bin (21),	/* location (in buffer) of left end  */
       54       2 cur_loc	fixed bin (21),	/* current place		       */
       55       2 right_loc	fixed bin (21),	/* right end		       */
       56       2 left_size	fixed bin (21),	/* how much of the left part is left */
       57       2 this	fixed bin;	/* which part of file are we in      */
       58 
       59 dcl (ami_sw, ame_sw)bit (1);
       60 dcl first_char_matched fixed bin (21);
       61 dcl last_char_matched fixed bin (21);
       62 dcl (lb, ub)	fixed bin (21);	 /* lower/upper bounds	       */
       63 dcl (i, ii, j, l, sl, type) fixed bin (21);
       64 dcl rep_no	fixed bin;
       65 dcl mct		fixed bin;
       66 dcl concealsw	bit (1);
       67 dcl ch		char (1);
       68 dcl ch1		char (1);
       69 dcl NL		char (1) int static options (constant) init ("
       70 ");
       71 
       72 dcl re_p		ptr;
       73 dcl 1 re		based (re_p),	/* copy of compiled regexp	       */
       74       2 maxl	fixed bin,	/* max length of compiled expr       */
       75       2 len	fixed bin,	/* length of this compiled expr      */
       76       2 sws,
       77         3 flag	bit (18) unal,
       78         3 NL_sw	bit (1) unal,	/* was literal NL given in expr      */
       79         3 strmode	bit (1) unal,	/* was compiled in string mode       */
       80         3 fill	bit (16) unal,
       81       2 parts	char (re.len);	/* actual compiled expression	       */
       82 dcl FLAG		bit (18) unal int static options (constant)
       83 		init ("252525"b3);
       84 
       85 dcl (rep_p, lrep_p) ptr;		/* -> part/last part	       */
       86    
       87 dcl 1 rep		based (rep_p),	/* regexp part- string	       */
       88       2 typ	fixed bin (8)unal,	/* what kind of entry	       */
       89       2 lbd	fixed bin (8)unal,	/* min occurances to find	       */
       90       2 ubd	fixed bin (8)unal,	/* max occurances (0 -> infinity)    */
       91       2 len	fixed bin (8)unal,	/* length of string which follows    */
       92       2 str	char (rep.len),	/*  literal data if needed	       */
       93       2 next	char (1);		/* where next part is based	       */
       94 
       95 
       96 dcl ioa_		entry options (variable);
       97 dcl (ioa_$ioa_switch,
       98      ioa_$ioa_switch_nnl) entry options (variable);
       99 dcl (
      100      addr, fixed, index, length, min, null, string, substr, unspec, verify
      101      )		builtin; 
      102 /**** <<<<----- dcl_tedsrch_.incl.pl1 tedsrch_$init_exp		       */
      103 init_exp:				/* initialize an expression area     */
      104     entry (acreg_p, ain_l);
      105 /*dcl (							       */
      106 /*  acreg_p	ptr,		/* -> compiled expression area  [IN] */
      107 /*  ain_l		fixed bin (21)	/*   length of area in words	       */
      108 /*  )		parm;		/* ----->>>>		       */
      109 
      110       re_p = acreg_p;
      111       re.maxl = (ain_l - 3) * 4;
      112       re.len = 0;
      113       string (re.sws) = ""b;
      114       return;




      115 /**** <<<<----- dcl_tedsrch_.incl.pl1 tedsrch_$compile		       */
      116 compile:				/* compile a regular expression      */
      117    entry (ain_p, ain_l, acreg_p, astrmode, alitmode, msg, acode);
      118 dcl (
      119     ain_p		ptr,		/* -> regular expression to search   */
      120     ain_l		fixed bin (21),	/*   length thereof		       */
      121     acreg_p	ptr,		/* -> compiled expression area  [IN] */
      122     astrmode	bit (1)aligned,	/* 0- line mode     1- string mode   */
      123     alitmode	bit (1)aligned,	/* 0- reg expr      1- literal expr  */
      124     msg		char (168) var,	/* error message		 [OUT] */
      125     acode		fixed bin (35)	/* error status code	 [OUT] */
      126     )		parm;		/* ----->>>>		       */
      127 
      128       re_p = acreg_p;
      129       acode = 0;
      130       in_p = ain_p;
      131       in_l = ain_l;
      132 
      133       re.len = 0;			/* no regular expression	       */
      134       re.flag = FLAG;
      135       rep_p = addr (re.parts);
      136       lrep_p = null();
      137       rep.len = 0;
      138       call start_sub_expression (STR_1);


      139 
      140       if alitmode			/* the whole expr is used as-is      */
      141       then do;
      142          i = 1;			/* since the hole might be in the    */
      143 				/*  middle of the area to be	       */
      144 				/*  searched, all searchs will be    */
      145 				/*  broken following NLs.	       */
      146 get_more:
      147          ii = index (substr (in_s, i), NL);
      148          if (ii = 0)
      149          then ii = in_l - i + 1;
      150          rep.len = ii;
      151          rep.str = substr (in_s, i, rep.len);
      152          if (ii = 0)
      153          then goto all_done;
      154          call start_sub_expression (STR);
      155          goto get_more;
      156       end;
      157 
      158       concealsw = ""b;		/* init concealment switch	       */
      159       re.strmode = astrmode;		/* save current line/string mode     */
      160       re.NL_sw = "1"b;		/* assume literal NL	       */
      161       do i = 1 to in_l;		/* pre-process and copy regexp       */
      162          ch = in_c (i);		/* pick up a char from expression    */
      163          if concealsw
      164          then do;
      165 	  concealsw = ""b;		/* reset concealment switch	       */
      166 	  goto tstar;		/* process char as normal char       */
      167          end;


      168          if (ch = "^") & (i = 1)	/* if "^" 1st char in the regexp     */
      169          then do;
      170 	  ch = NL;		/* replace with NL if so	       */
      171 	  rep.typ = I_STR;		/* TYPE:	/^string   /	       */
      172 	  goto move_ch;		/* place new-line in sub-expression  */
      173          end;			/*  in place of "^"		       */
      174          if (ch = "$") & (i = in_l)	/* check for "$", as last char */
      175          then do;
      176 	  ch = NL;		/* replace with NL if so	       */
      177 	  re.NL_sw = ""b;
      178          end;


      179          if (ch = "\")
      180          then do;
      181 	  ch1 = in_c (i + 1);
      182 	  unspec (ch1) = unspec (ch1) | "000100000"b;   /* make lowercase  */
      183 	  if (ch1 = "c")		/* "\c"			       */
      184 	  then do;
      185 	     i = i + 1;
      186 	     concealsw = "1"b;
      187 	     goto skip;
      188 	  end;
      189 	  if (ch1 = "x")
      190 	  then if (in_c (i + 2) = "[")
      191 	  then do;		/* expression extention	       */
      192 	     i = i + 3;
      193 	     call extention;
      194 	     goto skip;
      195 	  end;
      196          end;


      197          if (ch = ".")		/* special regexp ctl char	       */
      198          then do;
      199 	  if (i < in_l)
      200 	  then if (in_c (i + 1) = "*")
      201 	  then do;		/*  ".*"			       */
      202 	     i = i + 1;		/* yes, skip over it	       */
      203 	     call start_sub_expression (DOTSTAR);
      204 	     lb, ub = 0;
      205 	     goto skip;		/* skip to end of loop	       */
      206 	  end;
      207 	  if (rep.typ = DOTSTAR) & (rep.len = 0)  /* ".*."	       */
      208 	  then next_type = DOTSTAR;
      209 	  else next_type = STR;
      210 dcl next_type	fixed bin;
      211 	  call start_sub_expression (DOT);
      212 	  rep.len = 1;
      213 	  rep.str = ".";
      214 	  lb = verify (substr (in_s, i), ".")-1;
      215 	  if (lb < 0)
      216 	  then lb = in_l - i + 1;
      217 	  ub = lb;
      218 	  i = i + ub - 1;
      219 	  call start_sub_expression (next_type);
      220 	  goto skip;		/* skip to end of loop	       */
      221          end;
      222          if (ch = "*")
      223          then do;
      224 	  if (lrep_p = null ())
      225 	  then do;
      226 no_star_char:
      227 	     msg = "R??) No char for * to apply to.";
      228 	     goto err_exit;
      229 	  end;
      230 	  if (lrep_p -> rep.typ = STAR)
      231 	  | (lrep_p -> rep.typ = NOT_CHAR)
      232 	  | (lrep_p -> rep.typ = DOTSTAR)
      233 	  then goto no_star_char;
      234 	  if (lrep_p -> rep.typ = DOT)
      235 	  then do;
      236 	     rep_p = lrep_p;
      237 	     rep.typ = DOTSTAR;
      238 	     rep.lbd = rep.lbd - 1;
      239 	     rep.ubd = 0;
      240 	     rep.len = 0;
      241 	     goto skip;
      242 	  end;
      243 	  if (lrep_p -> rep.typ = I_STR) & (lrep_p -> rep.len = 1)
      244 	  then goto no_star_char;
      245 	  if (lrep_p -> rep.len = 1)
      246 	  then do;
      247 	     lrep_p -> rep.typ = STAR;
      248 	     goto skip;
      249 	  end;
      250 /**** Whats left at this point is STR_1, I_STR or STR with more than 1 char  */
      251 	  rep_p = lrep_p;
      252 	  ch = substr (rep.str, rep.len, 1);
      253 	  rep.len = rep.len - 1;
      254 	  call start_sub_expression (STAR);
      255 	  rep.len = 1;
      256 	  rep.str = ch;
      257 	  call start_sub_expression (STR);
      258 	  goto skip;
      259          end;
      260 tstar:
      261          if (i < in_l)
      262          then if (in_c (i + 1) = "*")
      263 	    then do;		/* check for char followed by "*"    */
      264 	       i = i + 1;		/*  skip over it		       */
      265 	       call start_sub_expression (STAR);
      266 	       lb, ub = 0;		/* ub=0 --> no-limit	       */
      267 	       rep.len = 1;
      268 	       rep.str = ch;
      269 	       do ii = (i + 1) to in_l /* pick up following ch's	       */
      270 		while (in_c (ii) = ch);
      271 		if (ii < in_l)
      272 		then if (in_c (ii + 1) = "*")
      273 		then goto skp2;
      274 		i = i + 1;	/* skip over ch		       */
      275 		rep.lbd = rep.lbd + 1; /* raise minimum		       */
      276 		lb = lb + 1;				/* #150*/
      277 	       end;
      278 skp2:
      279 	       call start_sub_expression (STR);
      280 	       goto skip;		/* skip to end of loop	       */
      281 	    end;
      282 	    if (rep.typ = DOT)
      283 	    then call start_sub_expression (STR);
      284 move_ch:
      285 	    rep.len = rep.len + 1;	/* normal char not followed by "*",  */
      286 	    substr (rep.str, rep.len, 1) = ch;
      287 	    if (ch = NL)		/* Due to the gap, NLs may require   */
      288 	    then do;		/* ..special handling.	       */
      289 	       if (rep.len = 1) & (rep.typ = I_STR)
      290 	       then;		/* Not if its from "/^"	       */
      291 	       else if re.NL_sw	/* ..or from "$/"		       */
      292 	       then call start_sub_expression (STR);
      293 				/* break the string at this point    */
      294 	    end;
      295 skip:
      296       end;
      297       if (rep.len = 0) & (rep.typ = DOTSTAR)	/* TYPE:	/   .* <nil> /   */
      298       then do;
      299          rep.typ = DOTSTARnil;
      300          rep.len = 1;
      301          rep.str = NL;
      302          re.NL_sw = ""b;
      303       end;
      304 all_done:
      305       call start_sub_expression (MATCH);
      306       re.len = re.len + 4;
      307       if db_srch
      308       then call dump_entry (re.len);
      309       return;
      310 /**** <<<<----- dcl_tedsrch_.incl.pl1 tedsrch_$search		       */
      311 search:				/* search for expression	       */
      312    entry (acreg_p, abp, asi, ase, ami, ame, ame2, msg, acode);
      313 dcl (
      314 /****acreg_p	ptr,		/* -> compiled expression	       */
      315     abp		ptr,		/* -> buffer ctl block for file      */
      316     asi		fixed bin (21),	/* beginning of string to search     */
      317     ase		fixed bin (21),	/* end of string to search	       */
      318     ami		fixed bin (21),	/* beginning of match	       */
      319     ame		fixed bin (21),	/* end of match		       */
      320     ame2		fixed bin (21)	/* end of string used for match      */
      321 /****msg		char (168)var,	/* error message return	 [OUT] */
      322 /****acode	fixed bin (35)	/* error status code	 [OUT] */
      323     )		parm;		/* ----->>>>		       */
      324 
      325 dcl BOL		bit (1);		/* tells if ^x... type	       */
      326       re_p = acreg_p;
      327       bp = abp;
      328       if (re.len = 0) | (re.flag ^= FLAG)
      329       then do;
      330          msg = "E/u) // undefined.";
      331          goto err_exit;
      332       end;





      333       BOL = ""b;
      334       part.min_left = asi;		/* Set low-water-mark.	       */
      335 				/* We will never search below this.  */


      336 
      337 /*		  : : : SEARCH FOR EXPRESSION : : :		       */
      338 
      339       if ""b then do;
      340 really_retry:
      341          if db_srch & lg_srch
      342          then call ioa_$ioa_switch (db_output, "<RE-TRY>");
      343       end;
      344       part.this = 0;
      345       call check_bounds;		/* setup, check for empty buffer     */
      346       if (part.cur_loc > part.right_loc)
      347       then call check_bounds;		/* search fails on empty buffer area */
      348       if ""b then do;
      349 retry:
      350          if db_srch & lg_srch
      351          then call ioa_$ioa_switch (db_output, "<re-try>");
      352 /**** from location 1 */
      353          if (first_char_matched = 0)	/* restart regexp search	       */
      354          then part.cur_loc = part.cur_loc + part.left_size;
      355 /****    then part.cur_loc = part.cur_loc + 1;   changed 82-11-29	       */
      356          else part.cur_loc = first_char_matched + 1;
      357          if (part.cur_loc > part.right_loc)
      358          then call check_bounds;	/* starting at next line in buffer   */
      359 				/*  area			       */
      360 
      361       end;
      362       rep_p = addr (re.parts);
      363       rep_no = 1;
      364       first_char_matched, last_char_matched = 0; /*  nothing found yet       */
      365       ami_sw, ame_sw = ""b;
      366       if db_srch & lg_srch
      367       then call ioa_$ioa_switch (db_output, "^i|^i<^i<^i",
      368          part.min_left, part.left_loc, part.cur_loc, part.right_loc);
      369 search:
      370       type = rep.typ;		/* get sub-expression type code      */
      371       lb = rep.lbd;
      372       ub = rep.ubd;
      373       sl = rep.len;			/* get length of literal char string */
      374 
      375       if db_srch
      376       then do;
      377          if (rep_no = 1)
      378          then call ioa_$ioa_switch (db_output, "    #  typ,min,max,len");
      379          call ioa_$ioa_switch_nnl (db_output,
      380 	  "l^i,cur^i,r^i^19.1t ^i:^i^40.1t",
      381 	  part.left_loc, part.cur_loc, part.right_loc,
      382 	  first_char_matched, last_char_matched);
      383          call dump_entry (rep_no);
      384       end;
      385       if (type > max_type)
      386       then do;
      387 invalid_type:
      388          call ioa_ ("tedsrch_: Invalid type ^i", type);
      389          goto err_exit;
      390       end;
      391       mct = 0;
      392       part.left_size = part.right_loc - part.cur_loc + 1;
      393 dcl max_type	fixed bin defined Ematch;
      394       goto srch (type); 



      395 dcl STR_1		fixed bin int static init (0) options (constant);
      396 srch (00): /**** "/string-----/"	match 1st normal string	       */
      397 again_1:
      398       if (part.left_size >= rep.len)	/* enough left for string to fit?    */
      399       then j = index (substr (file_str, part.cur_loc), rep.str);
      400       else j = 0;
      401       if (j = 0)			/* if no match, maybe search failed  */
      402       then do;
      403          call check_bounds;		/* if we come back,		       */
      404          goto again_1;		/*  there is still more to search    */
      405       end;
      406       type = STR;			/* if more needed, must be HERE      */
      407       goto srch_end_4; 



      408 dcl I_STR		fixed bin int static init (1) options (constant);
      409 srch (01): /**** "/^string----/"	match 1st initial string	       */
      410       BOL = "1"b;
      411 again_2:
      412       if (part.cur_loc = part.left_loc)   /* check for start of line     */
      413       then do;
      414 dcl kr char (1);
      415          if (part.left_loc = b.b_.l.le) /* if at beginning of lower part     */
      416 	  | (b.b_.l.re < b.b_.l.le)	/* or if no lower part at all	       */
      417          then kr = NL;		/* ..make believe a NL is before it  */
      418          else kr = b_c (b.b_.l.re);	/* otherwise take last char of lower */
      419       end;
      420       else if (part.cur_loc > part.left_loc)
      421       then kr = file_char (part.cur_loc-1);   /* take char just in front     */
      422       else do;
      423          signal condition (Error);dcl Error condition;
      424       end;
      425       if (kr ^= NL)
      426       then do;			/* skip remainder of partial line    */
      427 find_NL_1:
      428          l = index (substr (file_str, part.cur_loc), NL);
      429          if (l = 0)			/* COULD A LINE END UP SPLIT?	       */
      430          then do;			/* ...not supposed to (I think)      */
      431 	  if (part.this = 1)
      432 	  then do;
      433 	     call check_bounds;
      434 	     goto find_NL_1;
      435 	  end;
      436 	  call fail;		/* no next line to search	       */
      437          end;
      438          part.cur_loc = part.cur_loc + l; /* point to next line     */
      439          if (part.cur_loc > part.right_loc)
      440          then call check_bounds;	/* check for last line	       */
      441       end;
      442 
      443 /**** try initial string on 1st line				       */
      444       if (part.left_size < sl-1)	/* gotta be enough chars left	       */
      445       then do;			/* if not, regexp search failed..    */
      446          call check_bounds;		/* ..unless there is still more data */
      447          goto again_2;
      448       end;
      449       if (substr (file_str, part.cur_loc, sl-1)	  /* don't use the leading */
      450          = substr (rep.str, 2, sl-1))   /* NL for this one		       */
      451       then do;
      452          j = 1;
      453       end;
      454       else do;			/* string compare failed on 1st line */
      455          ii = 0;			/* search remainder of buffer area   */
      456          j = index (substr (file_str, part.cur_loc), rep.str);
      457          if (j = 0)			/* no match, regexp search failed..  */
      458          then do;
      459 	  call check_bounds;	/* ..unless there is still more data */
      460 	  goto again_2;
      461          end;
      462          j = j + 1;
      463       end;
      464       sl = sl - 1;			/* don't include the initial NL      */
      465       goto srch_end_4; 



      466 dcl DOTSTAR	fixed bin int static init (2) options (constant);
      467 dcl DOTSTARnil	fixed bin int static init (8) options (constant);
      468 srch (02): /****  "/---.*string/"	match next string		       */
      469 srch (08): /****  "|.*|"		match "rest"		       */
      470 				/* find end of line containing       */
      471 				/*  string found so far	       */
      472 /**** STRING MODE .*XXX WILL NOT HACK SPANNING THE GAP		       */
      473       if ^re.strmode
      474       then do;
      475          j = index (substr (file_str, part.cur_loc), NL); /* look for NL     */
      476          if (j > 0)			/* if none found		       */
      477          then part.left_size = j;       /* ..take all that's left	       */
      478       end;
      479       if (rep.typ = DOTSTARnil)	/* this ended in .*		       */
      480       then sl = part.left_size;	/* so take all there is left	       */
      481       else sl
      482          = index (substr (file_str, part.cur_loc, part.left_size), rep.str);
      483 				/* search rest of ? for string       */
      484       if (sl <= lb)			/* not found		   #146*/
      485 /*    if (sl = 0)			/* not found		   #146*/
      486       then do;
      487 /**** location 1 */
      488          goto retry;		/* .. restart regexp search	       */
      489       end;
      490 /*    if (sl <= lb)			/* not enough "dots" available?      */
      491 /*    then goto re/try;					       */
      492       mct = ub;			/* found what we need	       */
      493       if (rep.typ = DOTSTAR)
      494       then sl = sl + rep.len - 1;	/* the total length is the length    */
      495 				/*  skipped over plus the length of  */
      496 				/*  the string searched for.	       */
      497       goto srch_end_3; 



      498 dcl STR		fixed bin int static init (3) options (constant);
      499 srch (03): /****  "/---string---/"	match next literal string	       */
      500 				/* attempt to match string in place  */
      501       if (part.left_size < sl)	/* enough chars left?	       */
      502       then goto keep_trying;
      503       if (substr (file_str, part.cur_loc, sl) ^= rep.str)
      504       then goto keep_trying;
      505       goto srch_end_2; 



      506 dcl STAR		fixed bin int static init (4) options (constant);
      507 srch (04): /****  "/----x*----/"	match any occurences of a char       */
      508       ch = rep.str;			/* get the "x" from "x*"	       */
      509       if (first_char_matched > 0)	/* if match already started,	       */
      510       then do;			/* ..no special action needed.       */
      511 x_star:
      512          do sl = part.cur_loc to part.right_loc
      513 	  while (file_char (sl) = ch);
      514          end;
      515          sl = sl - min (part.right_loc, part.cur_loc);
      516          if (sl < lb)		/* is minimum amount present?	       */
      517          then goto retry;					/* #150*/
      518          mct = min (ub, sl);		/* take up to max		   #150*/
      519          goto srch_end_3;
      520       end;
      521 /**** since haven't figured out how to optimize any of the initial cases,    */
      522 /****  just keep doing what has always been done.			       */
      523       goto x_star;
      524 star_x:				/* haven't figured out how to do     */
      525 				/*  / *str/ yet		       */
      526 				/*  /\[3:7" "]str/ either	       */
      527 				/*  /   *str/ is mostly here	       */
      528 
      529 /*				/* initial matching		      * /
      530*      if ^re.strmode
      531*      then do;
      532*         j = index (substr (file_str, part.cur_loc), NL); /* look for NL    * /
      533*         if (j > 0)			/* if none found		      * /
      534*         then part.left_size = j;       /* ..take all that's left	      * /
      535*      end;
      536*      if (lb > 0)			/* do we need at least one?	      * /
      537*      then do;			/* see if one is out there	      * /
      538*         sl = index (substr (file_str, part.cur_loc, part.left_size), ch);
      539*         if (sl = 0)		/* not found, no use looking in this* /
      540*         then do;			/* ..area any more		      * /
      541*	  part.cur_loc = part.cur_loc + part.left_size;
      542*	  if (part.cur_loc > part.right_loc)
      543*	  then call check_bounds;	/* starting at next line in buffer  * /
      544*				/*  area			      * /
      545*	  goto re#try;		/* .. restart regexp search	      * /
      546*         end;
      547*         part.cur_loc = part.cur_loc + sl - 1;
      548*         goto x_star;
      549*      end;
      550*				/* min is zero		      * /
      551*      trp = rep_p;			/* lets go look at what's next      * /
      552*      rep_p = addr (rep.next);
      553*      if (rep.typ = STR)
      554*      then do;
      555*         sl = index (substr (file_str, part.cur_loc, part.left_size), rep.str);
      556*         if (sl = 0)		/* not found, no use looking in this* /
      557*         then do;			/* ..area any more		      * /
      558*	  part.cur_loc = part.cur_loc + part.left_size;
      559*try_again:
      560*	  if (part.cur_loc > part.right_loc)
      561*	  then call check_bounds;	/* starting at next line in buffer  * /
      562*				/*  area			      * /
      563*	  goto re#try;		/* .. restart regexp search	      * /
      564*         end;
      565*         sl = sl - 1;
      566*         if (sl < lb)		/* did we even pass over enough     * /
      567*         then do;			/* ..characters?		      * /
      568*	  part.cur_loc = part.cur_loc + sl; /* ..No		      * /
      569*	  goto try_again;
      570*         end;
      571*         
      572*         part.cur_loc = part.cur_loc + sl - 1;
      573*         goto x_star;
      574*      end;
      575*      if (part.left_size < sl)	/* enough chars left?	      * /
      576*      then goto keep_trying;
      577*      goto srch_end_2;*/



      578 dcl DOT		fixed bin int static init (5) options (constant);
      579 srch (05): /****  "/---\x[n.]---/"	match specific number of any char    */
      580 /****	       "/---.---/" "/---.....---/"			       */
      581       if (part.left_size < lb)	/* is that enough?		       */
      582       then do;
      583          call fail;			/* HANDLE split & stringmode */
      584       end;
      585       if (ub = 0)
      586       then ub = part.left_size;
      587       sl = min (part.left_size, ub);
      588       if ^re.strmode		/* in linemode "." may not match     */
      589       then do;			/* ..a NL			       */
      590          j = index (substr (file_str, part.cur_loc, sl), NL) -1;
      591          if (j >= 0)
      592          then sl = j;
      593          if (sl < lb)
      594          then goto really_retry;
      595       end;
      596       mct = ub;
      597       goto srch_end_3; 



      598 dcl NOT_CHAR	fixed bin int static init (6) options (constant);
      599 srch (06): /****  "/---\x[^"c"]---/"	match absence of a char	       */
      600       if (substr (file_str, part.cur_loc, 1) = rep.str)
      601       then goto keep_trying;
      602       goto srch_end_2; 



      603 dcl XX		fixed bin int static init (7) options (constant);
      604 srch (07): /****  "/^\x[^"c"]---/"	match absence of a char initially    */
      605       if XX=XX then
      606       goto invalid_type;



      607 dcl Bmatch	fixed bin int static init (9) options (constant);
      608 srch (09): /****  "/---\x[<]---/"	begin the match here	       */
      609       ami = part.cur_loc;
      610       ami_sw = "1"b;
      611       goto srch_end_0;



      612 dcl Ematch	fixed bin int static init (10) options (constant);
      613 srch (10): /****  "/---\x[>]---/"	end the match here		       */
      614       ame = last_char_matched;
      615       ame_sw = "1"b;
      616       goto srch_end_0;



      617 srch_end_4:
      618       part.cur_loc = part.cur_loc + j - 1;
      619 srch_end_3:
      620       if (first_char_matched = 0)
      621       then do;
      622          first_char_matched = part.cur_loc;
      623          part.min_left = first_char_matched + 1;  /* not go below here again */
      624       end;
      625 srch_end_2:
      626       last_char_matched = part.cur_loc + sl - 1;
      627       part.cur_loc = last_char_matched + 1;
      628 srch_end_0: 
      629       mct = mct + 1;
      630       if db_srch & lg_srch
      631       then do;
      632 dcl lgl		fixed bin (21);
      633          lgl = last_char_matched - first_char_matched + 1;
      634          call ioa_$ioa_switch (db_output,
      635 	  "^i,^i,^i ^i:^i ""^va""", lb, mct, ub,
      636 	  first_char_matched, last_char_matched, lgl,
      637 	  substr (file_str, first_char_matched, lgl));
      638       end;
      639       if (mct < lb)
      640       then goto srch (type);
      641       if ""b
      642       then do;
      643 keep_trying:
      644          if (mct < lb)
      645          then goto really_retry;
      646          ub = mct;			/* Got here because min have been    */
      647 				/*  found, max have not. Must make   */
      648 				/*  it be a success.	       */
      649       end;
      650       if (mct < ub)
      651       then goto srch (type);
      652       rep_p = addr (rep.next);	/* move to next sub-expression       */
      653       rep_no = rep_no + 1;
      654       if (rep.typ ^= MATCH)
      655       then do;
      656          if (part.cur_loc > part.right_loc)
      657          then do;			/* search until specified buffer     */
      658 	  call check_bounds;	/*  area exhausted		       */
      659          end;
      660          goto search;
      661       end;
      662 dcl MATCH		fixed bin int static options (constant) init (-1);
      663 				/* end of expr, match succeeds       */
      664       ame2 = last_char_matched;
      665       if ^re.strmode		/* if line mode		       */
      666          & ^re.NL_sw		/*  and "$" was used	       */
      667          & (last_char_matched >= first_char_matched) /* and not null string  */
      668       then if (file_char (last_char_matched) = NL) /* last char NL, don't    */
      669 	 then last_char_matched = last_char_matched - 1;	 /* inc in match */
      670       if db_srch
      671       then call ioa_$ioa_switch (db_output,
      672          "^-[^d:^d ^d:^d] ^d^[(^d:^d)^;:^2s^]^d",
      673          b.b_.l.le, b.b_.l.re, b.b_.r.le, b.b_.r.re,
      674          first_char_matched, ami_sw|ame_sw, ami, ame, last_char_matched);
      675       if ^ami_sw
      676       then ami = first_char_matched;
      677       if ^ame_sw
      678       then ame = last_char_matched;
      679       if BOL & (ame = ame2)		/* make sure s/^...// doesn't wipe   */
      680       then ame2 = ame2 + 1;		/* ..whole line		       */
      681       acode = 0;			/* tell caller match found	       */
      682 
      683 exit:
      684       return;
      685 err_exit:
      686       acode = 2;
      687       return;
      688 
      689 fail: proc;			/* made a proc so I can find out     */
      690 				/*  where a fail came from.	       */
      691       acode = 1;			/* here if regexp search failed      */
      692       if db_srch
      693       then call ioa_$ioa_switch (db_output,
      694          "^-[^d:^d ^d:^d] X:X",
      695          b.b_.l.le, b.b_.l.re,
      696          b.b_.r.le, b.b_.r.re);
      697       goto exit;
      698    end fail;



      699 start_sub_expression: proc (new_type);
      700 
      701 dcl new_type	fixed bin;
      702 
      703       if (rep.len ^= 0)		/* if sub-expression outstanding     */
      704       then do;
      705          rep.lbd = lb;
      706          rep.ubd = ub;
      707          re.len = re.len + rep.len + 4;
      708          if db_srch
      709          then call dump_entry (re.len);
      710          lrep_p = rep_p;
      711          rep_p = addr (rep.next);
      712       end;
      713       rep.len = 0;
      714       lb, ub = 1;
      715       rep.typ = new_type;
      716 
      717    end start_sub_expression;
      718 extention: proc;			/* data inside \x[  ]	       */
      719 
      720 /* ========================================================================= 
      721*		   extention definition & wishlist
      722*    tedread_ptr_ converts these obsolete forms into the described form:
      723*	\[n]x    => \x[n"x"]
      724*	\[n].    => \x[n.]
      725*	\[n]\c.  => \x[n"."]
      726*
      727*   metalanguage used:
      728*	1) comments are inside {}'s.
      729*	2) <form...> means any number of <form>'s
      730*	3) <[min]>   means an optional <min> }
      731*   ========================================================================= 
      732*
      733*extention ::= \[ <form...> ]
      734*
      735*<form>	::= <[min]> <[max]> <element>
      736*	  | <element> *	{a* => 0:a}
      737*
      738*<min>	::= <digits>	{min # wanted, default: 1}
      739*<max>	::= : <digits>	{max # wanted, default: min}
      740*            | :		{infinite # OK}
      741*
      742*<element>	::= " <char...> "	{match a string}
      743*	  |   <set>	{test for char being a member of a set}
      744*	  | ^ <set>	{test for char NOT in a set (NYA)}
      745*
      746*<set>	::= <simple>	{use a simple set}
      747*	  | s( <simple'...> ){build a compound set (NYA) }
      748*
      749*<simple'>	::= " <char...> "	{each char is added to the set}
      750*	  |   <simple>	{each implied char is added to the set}
      751*	  | ^ <simple>	{each implied char is removed from the set}
      752*	  | ^ " <char> "	{the char is removed from the set}
      753*
      754*<simple>	::= .		{everything but NL (unless string mode)}
      755*	  | p		{printable		NYA}
      756*	  | w		{whitespace(SP HT FF VT)	NYA}
      757*	  | u		{uppercase		NYA}
      758*	  | l		{lowercase		NYA}
      759*	  | a		{upper+lower+"_"		NYA}
      760*	  | x		{hex degit		NYA}
      761*	  | d		{decimal digit		NYA}
      762*	  | o		{octal digit		NYA}
      763*	  | b		{binary digit		NYA}
      764*	  | 
      765*   ========================================================================= */
      766 
      767 dcl (llb, lub)	fixed bin;	/* local lower/upper bounds	       */
      768 dcl beg_num	fixed bin;
      769 dcl not_sw	bit (1);
      770 
      771 loop:
      772       i = i + verify (substr (in_s, i), " ") - 1;
      773       if (in_c (i) = "]")
      774       then do;
      775          call start_sub_expression (STR);
      776          return;
      777       end;
      778       call start_sub_expression (MATCH);/* flush pending expression	       */
      779       llb, lub = -2;		/* set "empty"		       */
      780 /**** lower bound number					       */
      781       beg_num = i;
      782       ii = verify (substr (in_s, i), "0123456789") - 1;
      783       if (ii > 0)
      784       then do;
      785          llb, lub = fixed (substr (in_s, i, ii));
      786          if (lub = 0)
      787          then lub = -1;		/* set "zero-seen"		       */
      788          i = i+ii;
      789          i = i + verify (substr (in_s, i), " ") - 1;
      790       end;
      791 /**** upper bound number					       */
      792       if (in_c (i) = ":")
      793       then do;
      794          i = i + 1;
      795          if (llb = -2)
      796          then llb = 1;
      797          lub = 0;			/* init to infinity		       */
      798          i = i + verify (substr (in_s, i), " ") - 1;
      799          ii = verify (substr (in_s, i), "0123456789") - 1;
      800          if (ii > 0)
      801          then do;
      802 	  lub = fixed (substr (in_s, i, ii));
      803 	  i = i + ii;
      804 	  i = i + verify (substr (in_s, i), " ") - 1;
      805          end;
      806       end;
      807 /**** active term						       */
      808       ch = in_c (i);
      809       if (ch = "^")
      810       then do;
      811          i = i + 1;
      812          i = i + verify (substr (in_s, i), " ") - 1;
      813          ch = in_c (i);
      814          not_sw = "1"b;
      815       end;
      816       else not_sw = ""b;
      817       if (ch = ".")
      818       then do;
      819          if not_sw
      820          then do;
      821 	  msg = "Rnd) ""^."" is meaningless";
      822 x_exit:
      823 	  msg = msg || " in \x[]. """;
      824 	  msg = msg || substr (in_s, 1, i);
      825 	  msg = msg || """";
      826 	  goto err_exit;
      827          end;
      828          if (lub ^= -1)
      829          then do;
      830 	  call start_sub_expression (DOT);
      831 	  rep.len = 1;
      832 	  rep.str = ".";
      833          end;
      834          i = i + 1;
      835          i = i + verify (substr (in_s, i), " ") - 1;
      836       end;
      837       else if (ch = """")
      838       then do;
      839          if (re.len = 0)
      840          then next_type = STR_1;	/* first match		       */
      841          else next_type = STR;	/* continuing match		       */
      842          call start_sub_expression (next_type);
      843 more_str:
      844          i = i + 1;
      845          ii = index (substr (in_s, i), """") - 1;
      846          j = rep.len;
      847          rep.len = rep.len + ii;
      848          substr (rep.str, j+1, ii) = substr (in_s, i, ii);
      849          i = i + ii + 1;
      850          if (in_c (i) = """")
      851          then do;
      852 	  rep.len = rep.len + 1;
      853 	  substr (rep.str, rep.len, 1) = """";
      854 	  goto more_str;
      855          end;
      856          if not_sw
      857          then do;
      858 	  if (rep.len ^= 1)
      859 	  then do;
      860 	     msg = "Rnc) ""^"" cannot apply to multi-char string";
      861 	     goto x_exit;
      862 	  end;
      863 	  rep.typ = NOT_CHAR;
      864          end;
      865       end;
      866       else if (ch = "<")
      867       then do;
      868          if (lrep_p ^= null())	/* ignore if first, that's what      */
      869          then do;			/* ..you get anyway		       */
      870 	  call start_sub_expression (Bmatch);
      871 	  call no_min_max ("<");
      872 	  i = i + 1;
      873 	  rep.len = 1;
      874 	  rep.str = "<";
      875          end;
      876       end;
      877       else if (ch = ">")
      878       then do;
      879          call start_sub_expression (Ematch);
      880          call no_min_max (">");
      881          i = i + 1;
      882          rep.len = 1;
      883          rep.str = ">";
      884       end;
      885       else do;
      886          msg = "Ruc) Unknown char";
      887          goto x_exit;
      888       end;
      889 /**** "*" operator, cannot exist with [nn][:nn]			       */
      890       i = i + verify (substr (in_s, i), " ") - 1;
      891       if (in_c (i) = "*")
      892       then do;
      893          call no_min_max ("*");
      894          if (rep.typ = DOT)
      895          then do;
      896 	  msg = "Rds) "".*"" not allowed";
      897 	  goto x_exit;
      898          end;
      899          else llb, lub = 0;		/* set 0:infinity		       */
      900          i = i + 1;
      901       end;
      902 /**** set default bounds if needed				       */
      903       if (llb = -1)
      904       then llb = 1;
      905       if (lub = -1)
      906       then lub = llb;		/* llb > lub is ERROR	       */
      907       lb = llb;			/* llb/lub perhaps not needed	       */
      908       ub = lub;
      909       goto loop;
      910 
      911 no_min_max: proc (chr);
      912 dcl chr char (1);
      913          if (llb ^= -1) | (lub ^= -1)
      914          then do;
      915 	  msg = "Rcs) ""nn:nn values incompatable with """;
      916 	  msg = msg || chr;
      917 	  msg = msg || """. ";
      918 	  goto x_exit;
      919          end;
      920       end no_min_max;
      921    end extention;
      922 dis_exp: entry (acreg_p);		/* redisplay compiled expression     */
      923 
      924 
      925 
      926       re_p = acreg_p;
      927 
      928       call ioa_$ioa_switch (db_output,
      929          "^[^14p^;^s^].   #RE len=(^i)^i^[ NL_sw^;^]^[ strmode^;^]
      930 ^[^14x^]    #  typ,min,max,len", db_gv, re_p, re.maxl, re.len, NL_sw, strmode,
      931          db_gv);
      932 
      933       if (re.len = 0) | (re.flag ^= FLAG)
      934       then return;
      935       rep_no = 1;
      936       rep_p = addr (re.parts);
      937 more:
      938       call dump_entry (rep_no);
      939       if (rep.typ ^= MATCH)
      940       then do;
      941          rep_p = addr (rep.next);
      942          rep_no = rep_no + 1;
      943          goto more;
      944       end;
      945       return;
      946 check_bounds: proc;
      947 /**** In these 3 cases, the As represent the address range.		       */
      948 /**** Case 0:     (empty)					       */
      949 /**** Case 1: xxAAAxxx...xxxxx	not split			       */
      950 /**** Case 2: xxxxxAAA...Axxxx	split			       */
      951 /**** Case 3: xxxxxxxx...xAAAx	not split			       */
      952 
      953 /**** part.this = 2 does not mean you are processing in the upper part. It   */
      954 /**** means that you are either in the right of a split range or the range   */
      955 /**** is not split at all.					       */
      956 
      957       if (part.this = 0)
      958       then do;			/* nowhere yet		       */
      959          if (b.cur.sn = 0)		/* buffer is empty?		       */
      960          then call fail;
      961          if (part.min_left = b.b_.l.re + 1) /* if just above lower,	       */
      962          then do;			/* ..switch to upper	       */
      963 	  if (b.b_.r.re < b.b_.r.le)	/* ..unless upper is empty.	       */
      964 	  then call fail;
      965 	  part.min_left = b.b_.r.le;
      966          end;
      967          part.cur_loc = part.min_left;	/* start by assuming string is       */
      968          part.this = 2;		/* ..not split		       */
      969          part.right_loc = ase;
      970 
      971          if (part.min_left <= b.b_.l.re) /* string start in lower part?      */
      972          then do;			/* --YES			       */
      973 	  part.left_loc = b.b_.l.le;	/* set left end to lower part	       */
      974 	  if (ase > b.b_.l.re)	/* string extend out of lower part?  */
      975 	  then do;		/* --YES			       */
      976 	     part.right_loc = b.b_.l.re; /* set right end to end of lower  */
      977 	     part.this = 1;		/* indicate there's another to go    */
      978 	  end;
      979          end;
      980          else do;
      981 	  part.left_loc = b.b_.r.le;
      982          end;
      983          part.min_left = part.min_left + 1;  /* prevent loop on re-try       */
      984       end;
      985       else if (part.this = 1)		/* have been operating in 1st part   */
      986          & (b.b_.r.le <= b.b_.r.re)	/* & upper part isn't empty	       */
      987       then do;
      988          part.left_loc,
      989 	  part.cur_loc = b.b_.r.le;	/* continue in the 2nd part	       */
      990          part.right_loc = ase;
      991          part.left_size = part.right_loc - part.cur_loc + 1;
      992          part.this = 2;
      993          return;
      994       end;
      995       else			/* have been operating in 2nd part   */
      996          call fail;			/*   nowhere to go from here	       */
      997       if db_srch
      998       then call ioa_$ioa_switch (db_output,
      999          "min=^i(^i)l^i,cur^i,r^i", part.min_left, part.this,
     1000          part.left_loc, part.cur_loc, part.right_loc);
     1001       return;
     1002 
     1003    end check_bounds; 
     1004 
     1005 dump_entry: proc (num);
     1006 
     1007 dcl num		fixed bin;
     1008 
     1009 dcl (i, ndx)	fixed bin;
     1010 dcl ch		char (1);
     1011 dcl result	char (256)var;
     1012 /* format: off */
     1013 dcl mark		(-2:17) char (8) int static options (constant) init (
     1014 /* -1 */		"!/",	"",
     1015 /*  0 */		"/",	"!",
     1016 /*  1 */		"/^", 	"!",
     1017 /*  2 */		"!.*",	"!",
     1018 /*  3 */		"!",	"!",
     1019 /*  4 */		"!",	"*!",
     1020 /*  5 */		"!.!",	"",
     1021 /*  6 */		"!NOT""",	"""",
     1022 /*  7 */		"!/^NOT""","""",
     1023 /*  8 */		"!.*<NIL>","!");
     1024 /* format: on */
     1025 
     1026          ndx = rep.typ * 2;
     1027          call ioa_$ioa_switch_nnl (db_output,
     1028 	  "^[^14p^;^s^]    #^2i^2i ^3i,^3i,^3i ^a", db_gv,
     1029 	  rep_p, num, rep.typ, rep.lbd, rep.ubd, rep.len, mark (ndx));
     1030          ndx = ndx + 1;
     1031          if (mark (ndx) ^= "")
     1032          then do;
     1033 	  result = "";
     1034 	  do i = 1 to rep.len;
     1035 	     if (length (result) > 250)
     1036 	     then do;
     1037 	        call ioa_$ioa_switch_nnl (db_output,
     1038 		 "^va", length (result), result);
     1039 	        result = "";
     1040 	     end;
     1041 	     ch = substr (rep.str, i, 1);
     1042 	     if (ch = NL)
     1043 	     then result = result || "\NL";
     1044 	     else if (ch = "	")
     1045 	     then result = result || "\HT";
     1046 	     else if (ch = "\")
     1047 	     then result = result || "\\";
     1048 	     else result = result || ch;
     1049 	  end;
     1050 	  call ioa_$ioa_switch_nnl (db_output,
     1051 	     "^va", length (result), result);
     1052          end;
     1053          call ioa_$ioa_switch (db_output,
     1054 	  mark (ndx));
     1055 
     1056 end dump_entry;
     1057 	  
     1058 
     1059 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
     1060 
  1     1 /* BEGIN INCLUDE FILE ..... tedcommon_.incl.pl1 ..... 02/15/82 J Falksen */
  1     2 
  1     3 /*		         ted common data area			       */
  1     4 
  1     5 dcl 1 tedcommon_$id ext static,
  1     6       2 ted_vers char(12)var;		/*  version.revision	       */
  1     7 
  1     8 dcl 1 tedcommon_$no_data	like buf_des ext static;
  1     9 dcl 1 tedcommon_$no_seg	like seg_des ext static;
  1    10 
  1    11 dcl 1 tedcommon_$etc ext static,
  1    12       2 com_blank   bit(1)aligned,
  1    13       2 com1_blank  bit(1)aligned,
  1    14       2 caps	bit(1)aligned,
  1    15       2 reset_read	bit(1)aligned,
  1    16       2 sws,
  1    17         3 (db_ted, lg_ted)	bit(1)aligned,
  1    18         3 (db_addr, lg_addr)	bit(1)aligned,
  1    19         3 (db_eval, lg_eval)	bit(1)aligned,
  1    20         3 (db_sort, lg_sort)	bit(1)aligned,
  1    21         3 (db_gv, lg_gv)	bit(1)aligned,
  1    22         3 (db_util, lg_util)	bit(1)aligned,
  1    23         3 (db_srch, lg_srch)	bit(1)aligned,
  1    24         3 (db_glob, lg_glob)	bit(1)aligned,
  1    25         3 (db_trac, lg_sp4)	bit(1)aligned,
  1    26         3 (db_Ed, lg_sp3)	bit(1)aligned,
  1    27         3 (db_sp2, lg_sp2)	bit(1)aligned,
  1    28         3 (db_sp1, lg_sp1)	bit(1)aligned,
  1    29         3 (db_catch, lg_catch)bit(1)aligned,
  1    30       2 db_output ptr;
  1    31 
  1    32 /* END INCLUDE FILE ..... tedcommon_.incl.pl1 ..... */
     1061 
  2     1 /* BEGIN INCLUDE FILE ..... tedbcb.incl.pl1 ..... 01/29/82 J Falksen	       */
  2     2 
  2     3 /* UPDATE HISTORY (finally)					       */
  2     4 /* EL#   date	TR	comments				       */
  2     5 /* --- 84-10-19 -------- add sws.INPUT				       */
  2     6 /* --- 84-10-29 -------- add sws.invoking			       */
  2     7 
  2     8 /* if the structure of buf_des changes, tedcommon_.alm and		       */
  2     9 /*  tedcommon.incl.pl1 must be appropriately changed		       */
  2    10 
  2    11 dcl 1 buf_des	(all_des) based (bp),  /* buffer part descriptor	       */
  2    12       2 l,			/* left end (LHE) data (see Note 1)  */
  2    13         3 ln	fixed bin (21),	/*  line number		       */
  2    14         3 le	fixed bin (21),	/*  left  end (LE) offset	       */
  2    15         3 re	fixed bin (21),	/*  right end (RE) offset	       */
  2    16       2 r		like buf_des.l;	/* right end (RHE) data	       */
  2    17 
  2    18 /* Note1:	buf_des describes 2 slightly different things, buffer parts and    */
  2    19 /* 	addresses. These are the circumstances:			       */
  2    20 /*							       */
  2    21 /*							       */
  2    22 /*		|...............<buffer>..........................|      */
  2    23 /*	  b.cur.sp|	|..........<window>...........|	|      */
  2    24 /*	Buffer:	xxxxxxxxxxwwwwwwwwwwwww...<hole>...wwwwwwxxxxxxxxxx      */
  2    25 /*			|	  |	     |	|	|      */
  2    26 /*	           b.b_.l.le|  b.b_.l.re|   b.b_.r.le|	|     maxl|      */
  2    27 /*		    	   b.b_.l.ln|	 b.b_.r.le|    maxln|      */
  2    28 /*					 b.b_.r.ln|	       */
  2    29 /*    b.b_.l.ln (if known) tells the # of lines in left part of window       */
  2    30 /*    b.b_.r.ln (if known) tells the # of lines the whole window	       */
  2    31 /*    b.maxln   (if known) tells the # of lines in the whole buffer	       */
  2    32 /*	Either left or right part may be null. A ^read file	       */
  2    33 /*	is in the right part. A file is always read at the	       */
  2    34 /*	upper end of the hole. This will usually minimize the	       */
  2    35 /*	amount of data movement during subsequent editing		       */
  2    36 /*	operations.					       */
  2    37 /*							       */
  2    38 /* Data movement which occurs within a request, for example substitute, can  */
  2    39 /*  cause an offset to temporarily point into the hole. This will clear up   */
  2    40 /*  before the operation is complete.				       */
  2    41 
  2    42 /*						N	       */
  2    43 /*	Address:	....xxxxxxxxxxsssss -- sssssssxxxxxxxxxxL....	       */
  2    44 /*		    |	    |	         |	|	       */
  2    45 /*		l.le|	l.re|	     r.le|      r.re|	       */
  2    46 /*			l.ln|		      r.ln|	       */
  2    47 /*	l.re is the beginning of the string addressed.		       */
  2    48 /*	l.le is the beginning of line containing location l.re	       */
  2    49 /*		Thus l.ln is related to both l.re and l.le	       */
  2    50 /*	r.re is the end of the string addressed.		       */
  2    51 /*	r.le is the end of line containing location r.re		       */
  2    52 /*		Thus r.ln is related to both r.re and r.le	       */
  2    53 /*	(l.le and r.le relate to the same line when 1 line is addressed)   */
  2    54 /* In line mode each request starts with     l.re=l.le   &   r.re=r.le       */
  2    55 /* In string mode a global request forces these conditions.		       */
  2    56 
  2    57 /*** b_c/b_s reference the string which represents the buffer data.	       */
  2    58 dcl b_c		(b.maxl) char (1) based (b.cur.sp);
  2    59 dcl b_s		char (b.maxl) based (b.cur.sp);
  2    60 
  2    61 dcl (live_des	init (8),
  2    62     all_des	init (13),
  2    63     reloc_first	init (2),		/* where to begin minus 1	       */
  2    64     reloc_last	init (8)		/* where to stop		       */
  2    65     )		fixed bin int static options (constant);
  2    66 dcl bp		ptr;
  2    67 dcl 1 b		based (bp),	/* ted buffer control block	       */
  2    68       2 b_	like buf_des,	/* defines buffer limits	       */
  2    69       2 newb	like buf_des,	/* pending buffer values	       */
  2    70       2 ex	like buf_des,	/* execution limits		       */
  2    71       2 a_	(0:2) like buf_des, /* address data		       */
  2    72 				/*  (0)  "cur location"	       */
  2    73 				/*  (1)  1st addr result	       */
  2    74 				/*  (2)  2nd addr result	       */
  2    75       2 cd	like buf_des,	/* copy destination		       */
  2    76       2 gb	like buf_des,	/* info for global processing	       */
  2    77       2 newa	like buf_des,	/* pending address values	       */
  2    78 				/*    ----limit of relocation----    */
  2    79 /* these are not relocated because they define the relocation data	       */
  2    80       2 rel_temp	like buf_des,	/* hold during relocation	       */
  2    81       2 temp	(0:2) like buf_des,	/* hold during [.]addr processing    */
  2    82       2 old,			/* where string used to be	       */
  2    83         3 (le,re)	fixed bin (21),	/*   ends of range		       */
  2    84       2 new	like b.old,	/* where string has gone to	       */
  2    85       2 test	like b.old,	/* allowable relocatable range       */
  2    86 				/* (may be 1 or 2 larger than b.old) */
  2    87       2 cur	like seg_des,	/* CURRENT buffer area info	       */
  2    88 				/*    (see note 2)		       */
  2    89       2 pend	like seg_des,	/* PENDING buffer area info	       */
  2    90       2 file_d,			/* file related data	       */
  2    91         3 dtcm	bit(36),		/* when read seg was modified	       */
  2    92         3 uid	bit(36),		/* unique ID of segment	       */
  2    93         3 dname	char(168),	/* directory of file	       */
  2    94         3 ename	char(32),		/* entry of file		       */
  2    95         3 cname	char(32),		/* component of file	       */
  2    96         3 kind	char(1)unal,	/* kind of component	       */
  2    97 				/* " "-none, ":"-archive	       */
  2    98 				/*  "|"-superfile		       */
  2    99         3 sws	unal,
  2   100           4 file_sw	        bit(1),	/* 1-file associated	       */
  2   101           4 trust_sw        bit(1),	/* 1-file name trustable	       */
  2   102           4 mod_sw	        bit(1),	/* 1-buffer has been modified	       */
  2   103           4 terminate       bit(1),	/* 1-dp points to file, terminate    */
  2   104           4 get_bit_count   bit(1),	/* 1-get_bit_count before using this */
  2   105 			/*  buffer, it may have been modified by       */
  2   106 			/*  externally via [ted$buffer xx] usage       */
  2   107           4 force_name      bit(1),	/* 1-name has been forced	       */
  2   108           4 no_io	        bit(1),	/* 1-no r w ^b allowed	       */
  2   109 				/*  (external string edit)	       */
  2   110           4 not_pasted      bit(1),	/* 1-data was moved into buffer but  */
  2   111 				/*  has not been read anywhere       */
  2   112           4 initiate        bit(1),	/* 1-must initiate on restart	       */
  2   113 				/*  (b% and b!)		       */
  2   114           4 ck_ptr_sw       bit(1),	/* 1-if segment is external, must    */
  2   115 				/*  check pointer before ref	       */
  2   116           4 pseudo	        bit (1),	/* 1-^read or read-only buffer       */
  2   117           4 INPUT	        bit (1),	/* 1-active INPUT mode on buffer     */
  2   118           4 invoking        bit (1),	/* 1-buffer being invoked	       */
  2   119           4 fill	        bit (14),
  2   120       2 name	char(16),		/* buffer name		       */
  2   121       2 fill	char(27),
  2   122       2 stackl	bit (18)aligned,	/* offset of list of stacked data    */
  2   123       2 stack_o	bit (18)aligned,	/* offset of data being relocated    */
  2   124       2 present	(0:2) bit(1),	/* 1 if addr present	       */
  2   125       2 tw_sw	      bit(1),	/* 1-typewriter buffer	       */
  2   126       2 bs,			/* Old-style escapes in this buffer  */
  2   127         3 (c,b,r,f)       bit(1),	/* 1-\031,\030,\036,\034 found       */
  2   128       2 noref	      bit(1),	/* 1-not ref'ed, don't list	       */
  2   129       2 maxl	fixed bin(21),	/* max buffer length in this AST     */
  2   130       2 maxln	fixed bin(21),	/* number of lines in buffer	       */
  2   131       2 state_r	fixed bin(21),	/* what state is request in	       */
  2   132       2 (N1,N2,N3)	fixed bin(21),	/* values kept for -safe_ty	       */
  2   133       2 state_b	fixed bin(21);	/* what state is buffer change in    */
  2   134 
  2   135 /* Note2:	sn=0	means empty because the database segment will never      */
  2   136 /*		contain a buffer holder			       */
  2   137 /* 	sn=-1 (&^b.terminate) means read-only data, if modification is     */
  2   138 /* 		done, a copy will be made.			       */
  2   139 /* 	sn=-1 (& b.terminate) means ^read file, if modification is done    */
  2   140 /* 		the file is read first			       */
  2   141 /* 	sn>0	means a buffer holder segment			       */
  2   142 
  2   143 /* END INCLUDE FILE ..... tedbcb.incl.pl1 ..... */
     1062 
  3     1 /* BEGIN INCLUDE FILE ..... tedbase.incl.pl1 ..... 02/09/82 J Falksen       */
  3     2 
  3     3 dcl NORMAL	fixed bin (24) int static init (0),
  3     4     SAFE		fixed bin (24) int static init (1),
  3     5     COM		fixed bin (24) int static init (2),
  3     6     RESTART	fixed bin (24) int static init (3);
  3     7 
  3     8 dcl rc_close	fixed bin (24) int static init (100);
  3     9 dcl rc_fail	fixed bin (24) int static init (10);
  3    10 dcl rc_nop	fixed bin (24) int static init (2);
  3    11 dcl rc_keyerr	fixed bin (24) int static init (1);
  3    12 
  3    13 /*** the request line as both string and character		       */
  3    14 dcl rl_b		fixed bin (21);	/* where current req begins	       */
  3    15 dcl rl_i		fixed bin (21) defined (dbase.rl.l.le);
  3    16 dcl rl_l		fixed bin (21) defined (dbase.rl.l.re);
  3    17 dcl rl_c		(rl_l) char (1) based (dbase.rl.sp);
  3    18 dcl rl_s		char (rl_l) based (dbase.rl.sp);
  3    19 
  3    20 dcl 1 seg_des	based,		/* segment descriptor	       */
  3    21       2 sp	ptr,		/* -> segment		       */
  3    22       2 sn	fixed bin,	/* sequence # in dbase	       */
  3    23       2 pn	fixed bin,	/* part #, if in pool	       */
  3    24       2 ast	fixed bin,	/* size of aste		       */
  3    25       2 mbz	fixed bin;	/* --reserved		       */
  3    26 
  3    27       
  3    28 
  3    29 dcl dbase_p	ptr;
  3    30 dcl dbase_vers_3	fixed bin int static init (3);
  3    31 dcl 1 dbase	based (dbase_p),
  3    32       2 version	fixed bin,
  3    33       2 recurs	fixed bin,	/* recursion level at which active   */
  3    34       2 bwd	ptr,		/* links active db's together	       */
  3    35       2 cba_p	ptr,		/* contains addr (cb (1))	       */
  3    36       2 eval_p	ptr,		/* contains cb (2).sp	       */
  3    37       2 rl,			/* describes the request buffer      */
  3    38         3 part1	like seg_des,	/* ..its segment		       */
  3    39         3 part2	like buf_des,	/* ..its limits		       */
  3    40       2 seg_p	(-1:72) ptr,	/* list of segment pointers	       */
  3    41 				/* seg_p(-1)is a temp for restart    */
  3    42 				/* seg_p(0) is the database	       */
  3    43 				/* seg_p(1) is the 1K/4K pool	       */
  3    44 				/* seg_p(2) is reserved for 16K pool */
  3    45 				/* seg_p(3) is reserved for call_stk */
  3    46       2 inuse_seg	bit (72) aligned,	/* which segments (1:72) are in use  */
  3    47 				/* seg_p(0) is ALWAYS in use	       */
  3    48       2 inuse_1K	bit (16) aligned,	/* which 1K buffers are in use       */
  3    49       2 inuse_4K	bit (12) aligned,	/* which 4K buffers are in use       */
  3    50       2 inuse_16K	bit (4) aligned,	/* which 16K buffers are in use      */
  3    51       2 reset	label,		/* where to go on a reset condition  */
  3    52       2 time	fixed bin (71),	/* time request id is based on       */
  3    53       2 seg_ct	fixed bin,	/* how many segments in use	       */
  3    54 				/* seg_p (0)--database	       */
  3    55 				/* seg_p (1)--4K pool (64K total)    */
  3    56 				/* seg_p (2)--16K pool (64K total)   */
  3    57       2 argct	fixed bin,	/* how many args to ted	       */
  3    58       2 S_count	fixed bin,	/* # matches on last substitute      */
  3    59       2 not_read_ct fixed bin,	/* how many "not-read" files	       */
  3    60       2 at_break	fixed bin,	/* 1-break pending, 2-break entered  */
  3    61       2 bufnum	fixed bin,	/* how many buffer control blocks    */
  3    62       2 lock        bit (36),		/* to find if active (set LAST!)     */
  3    63       2 cb_c_r	bit (18) aligned,	/* offset of current buffer	       */
  3    64       2 cb_w_r	bit (18) aligned,	/* offset of buffer being worked on  */
  3    65       2 sws,
  3    66         3 flow_sw	bit (1) unal,	/* -label specified		       */
  3    67         3 break_sw	bit (1) unal,	/* -break specified		       */
  3    68         3 edit_sw	bit (1) unal,	/* -trace_edit specified	       */
  3    69         3 input_sw	bit (1) unal,	/* -trace_input		       */
  3    70         3 old_style bit (1) unal,	/* 1-old-style escapes allowed       */
  3    71         3 remote_sw bit (1) unal,	/* 1-not in home_dir	       */
  3    72         3 read_sw   bit (1) unal,	/* 1-always read files	       */
  3    73         3 lit_sw    bit (1) unal,	/* 1-expressions are literal	       */
  3    74         3 fill	bit (28) unal,
  3    75       2 tedname	char (32) var,	/* name under which ted_ was called  */
  3    76       2 comment     char (256)var,	/* user ident of environment	       */
  3    77       2 err_msg	char (168)var,
  3    78       2 regexp	char (500),	/* holds the remembered regular expr */
  3    79 				/*  is placed here to get word       */
  3    80 				/*  alignment		       */
  3    81       2 dir_db	char (168),	/* where work segments live	       */
  3    82       2 person      char (22),	/* who started		       */
  3    83       2 project     char (9),		/* ...this environment	       */
  3    84       2 nulreq	char (2),		/* what is null request (p|P|!p)     */
  3    85       2 err_go	char (16),	/* label to go to on error	       */
  3    86       2 rq_id       char (19),	/* request id for this	       */
  3    87       2 stk_info,
  3    88         3 curp	ptr,		/* pointer to current buffer	       */
  3    89         3 top	ptr,		/* pointer to top of stack	       */
  3    90         3 level	fixed bin (21),	/* recursion depth		       */
  3    91         3 next	fixed bin (21);
  3    92       /* next space available in stack     */
  3    93       
  3    94 
  3    95 /* END INCLUDE FILE ..... tedbase.incl.pl1 .....			       */
     1063 
     1064 
     1065    end tedsrch_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/18/84  0907.8  tedsrch_.pl1                      >spec>online>7008>tedsrch_.pl1
1061         1    12/18/84  0904.9  tedcommon_.incl.pl1               >spec>online>7008>tedcommon_.incl.pl1
1062         2    12/18/84  0906.0  tedbcb.incl.pl1                   >spec>online>7008>tedbcb.incl.pl1
1063         3    11/23/82  1324.7  tedbase.incl.pl1                  >ldd>include>tedbase.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BOL                             000141 automatic       bit(1)                   unaligned dcl 325 set ref 333* 409* 679
Bmatch                                 constant        fixed bin(17,0)          initial dcl 607 set ref 870*
DOT                                    constant        fixed bin(17,0)          initial dcl 524 set ref 211* 234 282 830* 894
DOTSTAR                                constant        fixed bin(17,0)          initial dcl 466 set ref 203* 207 207 230 237 297 493
DOTSTARnil                             constant        fixed bin(17,0)          initial dcl 467 ref 299 479
Ematch                          000063 constant        fixed bin(17,0)          initial dcl 612 set ref 385 385 879*
Error                           000144 stack reference condition                dcl 423 ref 423
FLAG                                   constant        bit(18)                  initial unaligned dcl 82 ref 134 328 933
I_STR                                  constant        fixed bin(17,0)          initial dcl 408 ref 171 243 289
MATCH                           000114 constant        fixed bin(17,0)          initial dcl 662 set ref 304* 654 778* 939
NL                              005346 constant        char(1)                  initial unaligned dcl 69 ref 146 170 176 287 301 415
                                                                                  425 427 475 590 665 1042
NL_sw                     2(18)        based           bit(1)                   level 3 packed unaligned dcl 73 set ref 160* 177*
                                                                                  291 302* 665 928*
NOT_CHAR                               constant        fixed bin(17,0)          initial dcl 598 ref 230 863
STAR                                   constant        fixed bin(17,0)          initial dcl 506 set ref 230 247 254* 265*
STR                                    constant        fixed bin(17,0)          initial dcl 498 set ref 154* 209 257* 278* 282* 291*
                                                                                  406 775* 841
STR_1                                  constant        fixed bin(17,0)          initial dcl 395 set ref 138* 839
XX                                     constant        fixed bin(17,0)          initial dcl 603 ref 604 604
abp                                    parameter       pointer                  dcl 313 ref 311 327
acode                                  parameter       fixed bin(35,0)          dcl 118 set ref 116 129* 311 681* 685* 691*
acreg_p                                parameter       pointer                  dcl 118 ref 103 110 116 128 311 326 922 926
addr                                                   builtin function         dcl 99 ref 135 362 652 711 936 941
ain_l                                  parameter       fixed bin(21,0)          dcl 118 ref 103 111 116 131
ain_p                                  parameter       pointer                  dcl 118 ref 116 130
alitmode                               parameter       bit(1)                   dcl 118 ref 116 140
ame                                    parameter       fixed bin(21,0)          dcl 313 set ref 311 613* 670* 677* 679
ame2                                   parameter       fixed bin(21,0)          dcl 313 set ref 311 664* 679 679* 679
ame_sw                          000112 automatic       bit(1)                   unaligned dcl 59 set ref 365* 615* 670 677
ami                                    parameter       fixed bin(21,0)          dcl 313 set ref 311 608* 670* 675*
ami_sw                          000111 automatic       bit(1)                   unaligned dcl 59 set ref 365* 610* 670 675
ase                                    parameter       fixed bin(21,0)          dcl 313 ref 311 969 974 990
asi                                    parameter       fixed bin(21,0)          dcl 313 ref 311 334
astrmode                               parameter       bit(1)                   dcl 118 ref 116 159
b                                      based           structure                level 1 unaligned dcl 2-67
b_                                     based           structure                level 2 unaligned dcl 2-67
b_c                                    based           char(1)                  array unaligned dcl 2-58 ref 418
beg_num                         000214 automatic       fixed bin(17,0)          dcl 768 set ref 781*
bp                              000154 automatic       pointer                  dcl 2-66 set ref 327* 396 415 415 415 418 418 420
                                                                                  427 449 456 475 481 503 511 590 599 634 634 665
                                                                                  670 670 670 670 692 692 692 692 959 961 963 963
                                                                                  965 971 973 974 976 981 985 985 988
buf_des                                based           structure                array level 1 unaligned dcl 2-11
ch                              000130 automatic       char(1)                  unaligned dcl 67 in procedure "tedsrch_" set ref
                                                                                  162* 168 170* 174 176* 179 197 222 252* 256 268
                                                                                  269 286 287 507* 511 808* 809 813* 817 837 866 877
ch                              000242 automatic       char(1)                  unaligned dcl 1010 in procedure "dump_entry" set ref
                                                                                  1041* 1042 1044 1046 1048
ch1                             000131 automatic       char(1)                  unaligned dcl 68 set ref 181* 182* 182 183 189
chr                                    parameter       char(1)                  unaligned dcl 912 ref 911 916
concealsw                       000127 automatic       bit(1)                   unaligned dcl 66 set ref 158* 163 165* 186*
cur                     124            based           structure                level 2 unaligned dcl 2-67
cur_loc                   2     000103 automatic       fixed bin(21,0)          level 2 dcl 51 set ref 346 353* 353 356* 357 366*
                                                                                  379* 392 396 411 420 420 427 438* 438 439 449 456
                                                                                  475 481 503 511 515 590 599 608 617* 617 622 625
                                                                                  627* 656 967* 988* 991 997*
db_gv                    14     000016 external static bit(1)                   level 3 dcl 1-11 set ref 928* 928* 1027*
db_output                36     000016 external static pointer                  level 2 dcl 1-11 set ref 340* 349* 366* 377* 379*
                                                                                  634* 670* 692* 928* 997* 1027* 1037* 1050* 1053*
db_srch                  20     000016 external static bit(1)                   level 3 dcl 1-11 ref 307 340 349 366 375 630 670 692
                                                                                  708 997
file_char                              based           char(1)                  array unaligned dcl 48 ref 420 511 665
file_str                               based           char                     unaligned dcl 47 ref 396 427 449 456 475 481 503 590
                                                                                  599 634 634
first_char_matched              000113 automatic       fixed bin(21,0)          dcl 60 set ref 353 356 364* 379* 509 619 622* 623
                                                                                  633 634* 634 634 665 670* 675
fixed                                                  builtin function         dcl 99 ref 785 802
flag                      2            based           bit(18)                  level 3 packed unaligned dcl 73 set ref 134* 328 933
i                               000117 automatic       fixed bin(21,0)          dcl 63 in procedure "tedsrch_" set ref 142* 146 148
                                                                                  151 161* 162 168 174 181 185* 185 189 192* 192 199
                                                                                  199 202* 202 214 215 218* 218 260 260 264* 264 269
                                                                                  274* 274* 771* 771 771 773 781 782 785 788* 788
                                                                                  789* 789 789 792 794* 794 798* 798 798 799 802
                                                                                  803* 803 804* 804 804 808 811* 811 812* 812 812
                                                                                  813 824 834* 834 835* 835 835 843* 843 845 848
                                                                                  849* 849 850 872* 872 881* 881 890* 890 890 891
                                                                                  900* 900
i                               000240 automatic       fixed bin(17,0)          dcl 1009 in procedure "dump_entry" set ref 1034*
                                                                                  1041*
ii                              000120 automatic       fixed bin(21,0)          dcl 63 set ref 146* 148 148* 150 152 269* 269* 271
                                                                                  271* 455* 782* 783 785 788 799* 800 802 803 845*
                                                                                  847 848 848 849
in_c                                   based           char(1)                  array unaligned dcl 44 ref 162 181 189 199 260 269
                                                                                  271 773 792 808 813 850 891
in_l                            000102 automatic       fixed bin(21,0)          dcl 42 set ref 131* 146 148 151 161 174 199 214 215
                                                                                  260 269 271 771 782 785 789 798 799 802 804 812
                                                                                  824 835 845 848 890
in_p                            000100 automatic       pointer                  dcl 41 set ref 130* 146 151 162 181 189 199 214 260
                                                                                  269 271 771 773 782 785 789 792 798 799 802 804
                                                                                  808 812 813 824 835 845 848 850 890 891
in_s                                   based           char                     unaligned dcl 43 ref 146 151 214 771 782 785 789 798
                                                                                  799 802 804 812 824 835 845 848 890
index                                                  builtin function         dcl 99 ref 146 396 427 456 475 481 590 845
ioa_                            000010 constant        entry                    external dcl 96 ref 387
ioa_$ioa_switch                 000012 constant        entry                    external dcl 97 ref 340 349 366 377 634 670 692 928
                                                                                  997 1053
ioa_$ioa_switch_nnl             000014 constant        entry                    external dcl 97 ref 379 1027 1037 1050
j                               000121 automatic       fixed bin(21,0)          dcl 63 set ref 396* 400* 401 452* 456* 457 462* 462
                                                                                  475* 476 476 590* 591 591 617 846* 848
kr                              000142 automatic       char(1)                  unaligned dcl 414 set ref 415* 418* 420* 425
l                                      based           structure                array level 2 in structure "buf_des" unaligned
                                                                                  dcl 2-11 in procedure "tedsrch_"
l                         6            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                        52            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                                      internal static structure                level 2 in structure "tedcommon_$no_data" unaligned
                                                                                  dcl 1-8 in procedure "tedsrch_"
l                        44            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                        74            based           structure                array level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                        16            based           structure                level 4 in structure "dbase" unaligned dcl 3-31
                                                                                  in procedure "tedsrch_"
l                        22            based           structure                array level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                               000122 automatic       fixed bin(21,0)          dcl 63 in procedure "tedsrch_" set ref 427* 429 438
l                        60            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                        66            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                                      based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
l                        14            based           structure                level 3 in structure "b" unaligned dcl 2-67
                                                                                  in procedure "tedsrch_"
last_char_matched               000114 automatic       fixed bin(21,0)          dcl 61 set ref 364* 379* 613 625* 627 633 634* 664
                                                                                  665 665 665* 665 670* 677
lb                              000115 automatic       fixed bin(21,0)          dcl 62 set ref 204* 214* 215 215* 217 266* 276* 276
                                                                                  371* 484 516 579 593 634* 639 643 705 714* 907*
lbd                       0(09)        based           fixed bin(8,0)           level 2 packed unaligned dcl 87 set ref 238* 238
                                                                                  275* 275 371 705* 1027*
le                        1            based           fixed bin(21,0)          level 4 in structure "b" dcl 2-67 in procedure
                                                                                  "tedsrch_" set ref 415 415 670* 692* 973
le                        4            based           fixed bin(21,0)          level 4 in structure "b" dcl 2-67 in procedure
                                                                                  "tedsrch_" set ref 670* 692* 963 965 981 985 988
left_loc                  1     000103 automatic       fixed bin(21,0)          level 2 dcl 51 set ref 366* 379* 411 415 420 973*
                                                                                  981* 988* 997*
left_size                 4     000103 automatic       fixed bin(21,0)          level 2 dcl 51 set ref 353 392* 396 444 476* 479 481
                                                                                  499 579 585 587 991*
len                       0(27)        based           fixed bin(8,0)           level 2 in structure "rep" packed unaligned dcl 87
                                                                                  in procedure "tedsrch_" set ref 137* 150* 151 151
                                                                                  207 212* 213 240* 243 245 252 252 253* 253 255*
                                                                                  256 267* 268 284* 284 286 286 289 297 300* 301 373
                                                                                  396 396 449 456 481 493 503 507 599 652 703 707
                                                                                  711 713* 831* 832 846 847* 847 848 852* 852 853
                                                                                  853 858 873* 874 882* 883 941 1027* 1034 1041
len                       1            based           fixed bin(17,0)          level 2 in structure "re" dcl 73 in procedure
                                                                                  "tedsrch_" set ref 112* 133* 135 306* 306 307* 328
                                                                                  362 707* 707 708* 839 928* 933 936
length                                                 builtin function         dcl 99 ref 1035 1037 1037 1050 1050
lg_srch                  21     000016 external static bit(1)                   level 3 dcl 1-11 ref 340 349 366 630
lgl                             000152 automatic       fixed bin(21,0)          dcl 632 set ref 633* 634* 634 634
llb                             000212 automatic       fixed bin(17,0)          dcl 767 set ref 779* 785* 795 795* 899* 903 903* 905
                                                                                  907 913
lrep_p                          000136 automatic       pointer                  dcl 85 set ref 136* 224 230 230 230 234 236 243 243
                                                                                  245 247 251 710* 868
lub                             000213 automatic       fixed bin(17,0)          dcl 767 set ref 779* 785* 786 786* 797* 802* 828
                                                                                  899* 905 905* 908 913
mark                            000013 constant        char(8)                  initial array unaligned dcl 1013 set ref 1027* 1031
                                                                                  1053*
max_type                               defined         fixed bin(17,0)          dcl 393 ref 385
maxl                                   based           fixed bin(17,0)          level 2 dcl 73 set ref 111* 928*
mct                             000126 automatic       fixed bin(17,0)          dcl 65 set ref 391* 492* 518* 596* 628* 628 634* 639
                                                                                  643 646 650
min                                                    builtin function         dcl 99 ref 515 518 587
min_left                        000103 automatic       fixed bin(21,0)          level 2 dcl 51 set ref 334* 366* 623* 961 965* 967
                                                                                  971 983* 983 997*
msg                                    parameter       varying char(168)        dcl 118 set ref 116 226* 311 330* 821* 822* 822 824*
                                                                                  824 825* 825 860* 886* 896* 915* 916* 916 917* 917
ndx                             000241 automatic       fixed bin(17,0)          dcl 1009 set ref 1026* 1027 1030* 1030 1031 1053
new_type                               parameter       fixed bin(17,0)          dcl 701 ref 699 715
next                                   based           char(1)                  level 2 packed unaligned dcl 87 set ref 652 711 941
next_type                       000140 automatic       fixed bin(17,0)          dcl 210 set ref 207* 209* 219* 839* 841* 842*
not_sw                          000215 automatic       bit(1)                   unaligned dcl 769 set ref 814* 816* 819 856
null                                                   builtin function         dcl 99 ref 136 224 868
num                                    parameter       fixed bin(17,0)          dcl 1007 set ref 1005 1027*
old                     116            based           structure                level 2 unaligned dcl 2-67
part                            000103 automatic       structure                level 1 unaligned dcl 51
parts                     3            based           char                     level 2 packed unaligned dcl 73 set ref 135 362 936
r                         3            based           structure                level 3 unaligned dcl 2-67
re                                     based           structure                level 1 unaligned dcl 73 in procedure "tedsrch_"
re                        2            based           fixed bin(21,0)          level 4 in structure "b" dcl 2-67 in procedure
                                                                                  "tedsrch_" set ref 415 418 670* 692* 961 971 974
                                                                                  976
re                        5            based           fixed bin(21,0)          level 4 in structure "b" dcl 2-67 in procedure
                                                                                  "tedsrch_" set ref 670* 692* 963 985
re_p                            000132 automatic       pointer                  dcl 72 set ref 110* 111 112 113 128* 133 134 135 135
                                                                                  159 160 177 291 302 306 306 307 326* 328 328 362
                                                                                  362 468 588 665 665 707 707 708 839 926* 928* 928
                                                                                  928 928 928 933 933 936 936
rep                                    based           structure                level 1 packed unaligned dcl 87
rep_no                          000125 automatic       fixed bin(17,0)          dcl 64 set ref 363* 377 383* 653* 653 935* 937* 942*
                                                                                  942
rep_p                           000134 automatic       pointer                  dcl 85 set ref 135* 137 150 151 151 151 171 207 207
                                                                                  212 213 213 236* 237 238 238 239 240 251* 252 252
                                                                                  252 253 253 255 256 256 267 268 268 275 275 282
                                                                                  284 284 286 286 286 289 289 297 297 299 300 301
                                                                                  301 362* 369 371 372 373 396 396 396 449 449 456
                                                                                  456 479 481 481 493 493 503 503 507 507 599 599
                                                                                  652* 652 652 654 703 705 706 707 710 711* 711 711
                                                                                  713 715 831 832 832 846 847 847 848 848 852 852
                                                                                  853 853 853 858 863 873 874 874 882 883 883 894
                                                                                  936* 939 941* 941 941 1026 1027* 1027 1027 1027
                                                                                  1027 1034 1041 1041
result                          000243 automatic       varying char(256)        dcl 1011 set ref 1033* 1035 1037 1037 1037* 1039*
                                                                                  1042* 1042 1044* 1044 1046* 1046 1048* 1048 1050
                                                                                  1050 1050*
right_loc                 3     000103 automatic       fixed bin(21,0)          level 2 dcl 51 set ref 346 357 366* 379* 392 396 427
                                                                                  439 449 456 475 481 503 511 515 590 599 634 634
                                                                                  656 969* 976* 990* 991 997*
seg_des                                based           structure                level 1 unaligned dcl 3-20
sl                              000123 automatic       fixed bin(21,0)          dcl 63 set ref 373* 444 449 449 464* 464 479* 481*
                                                                                  484 493* 493 499 503 511* 511* 515* 515 516 518
                                                                                  587* 590 591* 593 625
sn                      126            based           fixed bin(17,0)          level 3 dcl 2-67 ref 959
sp                      124            based           pointer                  level 3 dcl 2-67 ref 396 418 420 427 449 456 475 481
                                                                                  503 511 590 599 634 634 665
str                       1            based           char                     level 2 packed unaligned dcl 87 set ref 151* 213*
                                                                                  252 256* 268* 286* 301* 396 449 456 481 503 507
                                                                                  599 832* 848* 853* 874* 883* 1041
string                                                 builtin function         dcl 99 set ref 113*
strmode                   2(19)        based           bit(1)                   level 3 packed unaligned dcl 73 set ref 159* 468 588
                                                                                  665 928*
substr                                                 builtin function         dcl 99 set ref 146 151 214 252 286* 396 427 449 449
                                                                                  456 475 481 503 590 599 634 634 771 782 785 789
                                                                                  798 799 802 804 812 824 835 845 848* 848 853* 890
                                                                                  1041
sws                       2            based           structure                level 2 in structure "re" packed unaligned dcl 73
                                                                                  in procedure "tedsrch_" set ref 113*
sws                       4     000016 external static structure                level 2 in structure "tedcommon_$etc" unaligned
                                                                                  dcl 1-11 in procedure "tedsrch_"
tedcommon_$etc                  000016 external static structure                level 1 unaligned dcl 1-11
this                      5     000103 automatic       fixed bin(17,0)          level 2 dcl 51 set ref 344* 431 957 968* 977* 985
                                                                                  992* 997*
typ                                    based           fixed bin(8,0)           level 2 packed unaligned dcl 87 set ref 171* 207 230
                                                                                  230 230 234 237* 243 247* 282 289 297 299* 369 479
                                                                                  493 654 715* 863* 894 939 1026 1027*
type                            000124 automatic       fixed bin(21,0)          dcl 63 set ref 369* 385 387* 394 406* 639 650
ub                              000116 automatic       fixed bin(21,0)          dcl 62 set ref 204* 217* 218 266* 372* 492 518 585
                                                                                  585* 587 596 634* 646* 650 706 714* 908*
ubd                       0(18)        based           fixed bin(8,0)           level 2 packed unaligned dcl 87 set ref 239* 372
                                                                                  706* 1027*
unspec                                                 builtin function         dcl 99 set ref 182* 182
verify                                                 builtin function         dcl 99 ref 214 771 782 789 798 799 804 812 835 890

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
COM                                    internal static fixed bin(24,0)          initial dcl 3-3
NORMAL                                 internal static fixed bin(24,0)          initial dcl 3-3
RESTART                                internal static fixed bin(24,0)          initial dcl 3-3
SAFE                                   internal static fixed bin(24,0)          initial dcl 3-3
all_des                                internal static fixed bin(17,0)          initial dcl 2-61
b_s                                    based           char                     unaligned dcl 2-59
dbase                                  based           structure                level 1 unaligned dcl 3-31
dbase_p                                automatic       pointer                  dcl 3-29
dbase_vers_3                           internal static fixed bin(17,0)          initial dcl 3-30
live_des                               internal static fixed bin(17,0)          initial dcl 2-61
rc_close                               internal static fixed bin(24,0)          initial dcl 3-8
rc_fail                                internal static fixed bin(24,0)          initial dcl 3-9
rc_keyerr                              internal static fixed bin(24,0)          initial dcl 3-11
rc_nop                                 internal static fixed bin(24,0)          initial dcl 3-10
reloc_first                            internal static fixed bin(17,0)          initial dcl 2-61
reloc_last                             internal static fixed bin(17,0)          initial dcl 2-61
rl_b                                   automatic       fixed bin(21,0)          dcl 3-14
rl_c                                   based           char(1)                  array unaligned dcl 3-17
rl_i                                   defined         fixed bin(21,0)          dcl 3-15
rl_l                                   defined         fixed bin(21,0)          dcl 3-16
rl_s                                   based           char                     unaligned dcl 3-18
tedcommon_$id                          external static structure                level 1 unaligned dcl 1-5
tedcommon_$no_data                     external static structure                level 1 unaligned dcl 1-8
tedcommon_$no_seg                      external static structure                level 1 unaligned dcl 1-9

NAMES DECLARED BY EXPLICIT CONTEXT.
again_1                         002011 constant        label                    dcl 396 ref 404
again_2                         002057 constant        label                    dcl 411 ref 447 460
all_done                        001371 constant        label                    dcl 304 ref 152
check_bounds                    004402 constant        entry                    internal dcl 946 ref 345 346 357 403 433 439 446 459
                                                                                  658
compile                         000417 constant        entry                    external dcl 116
dis_exp                         003061 constant        entry                    external dcl 922
dump_entry                      004544 constant        entry                    internal dcl 1005 ref 307 383 708 937
err_exit                        003053 constant        label                    dcl 685 ref 228 331 389 826
exit                            003052 constant        label                    dcl 683 ref 697
extention                       003362 constant        entry                    internal dcl 718 ref 193
fail                            003211 constant        entry                    internal dcl 689 ref 436 583 959 963 995
find_NL_1                       002120 constant        label                    dcl 427 ref 434
get_more                        000467 constant        label                    dcl 146 ref 155
init_exp                        000366 constant        entry                    external dcl 103
invalid_type                    001761 constant        label                    dcl 387 ref 604
keep_trying                     002665 constant        label                    dcl 643 ref 499 503 599
loop                            003363 constant        label                    dcl 771 ref 909
more                            003164 constant        label                    dcl 937 ref 943
more_str                        004030 constant        label                    dcl 843 ref 854
move_ch                         001257 constant        label                    dcl 284 ref 172
no_min_max                      004340 constant        entry                    internal dcl 911 ref 871 880 893
no_star_char                    001000 constant        label                    dcl 226 ref 230 243
really_retry                    001465 constant        label                    dcl 340 ref 593 643
retry                           001521 constant        label                    dcl 349 ref 488 516
search                          001634 constant        label                    dcl 369 in procedure "tedsrch_" ref 660
search                          001420 constant        entry                    external dcl 311
skip                            001326 constant        label                    dcl 295 ref 187 194 205 220 241 248 258 280
skp2                            001242 constant        label                    dcl 278 ref 271
srch                            000000 constant        label                    array(0:10) dcl 396 ref 394 639 650
srch_end_0                      002562 constant        label                    dcl 628 ref 611 616
srch_end_2                      002554 constant        label                    dcl 625 ref 505 602
srch_end_3                      002546 constant        label                    dcl 619 ref 497 519 597
srch_end_4                      002542 constant        label                    dcl 617 ref 407 465
star_x                          002441 constant        label                    dcl 524
start_sub_expression            003261 constant        entry                    internal dcl 699 ref 138 154 203 211 219 254 257 265
                                                                                  278 282 291 304 775 778 830 842 870 879
tedsrch_                        000354 constant        entry                    external dcl 28
tstar                           001146 constant        label                    dcl 260 ref 166
x_exit                          003710 constant        label                    dcl 822 ref 861 887 897 918
x_star                          002401 constant        label                    dcl 511 ref 523

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5464        5504    5362        5474
Length      5754    5362        20         234     102           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tedsrch_                            703 external procedure  is an external procedure.  
fail                                    internal procedure  shares stack frame of external procedure tedsrch_.  
start_sub_expression                    internal procedure  shares stack frame of external procedure tedsrch_.  
extention                               internal procedure  shares stack frame of external procedure tedsrch_.  
no_min_max                              internal procedure  shares stack frame of external procedure tedsrch_.  
check_bounds                            internal procedure  shares stack frame of external procedure tedsrch_.  
dump_entry                              internal procedure  shares stack frame of external procedure tedsrch_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tedsrch_                 000100 in_p                        tedsrch_
                         000102 in_l                        tedsrch_
                         000103 part                        tedsrch_
                         000111 ami_sw                      tedsrch_
                         000112 ame_sw                      tedsrch_
                         000113 first_char_matched          tedsrch_
                         000114 last_char_matched           tedsrch_
                         000115 lb                          tedsrch_
                         000116 ub                          tedsrch_
                         000117 i                           tedsrch_
                         000120 ii                          tedsrch_
                         000121 j                           tedsrch_
                         000122 l                           tedsrch_
                         000123 sl                          tedsrch_
                         000124 type                        tedsrch_
                         000125 rep_no                      tedsrch_
                         000126 mct                         tedsrch_
                         000127 concealsw                   tedsrch_
                         000130 ch                          tedsrch_
                         000131 ch1                         tedsrch_
                         000132 re_p                        tedsrch_
                         000134 rep_p                       tedsrch_
                         000136 lrep_p                      tedsrch_
                         000140 next_type                   tedsrch_
                         000141 BOL                         tedsrch_
                         000142 kr                          tedsrch_
                         000152 lgl                         tedsrch_
                         000154 bp                          tedsrch_
                         000212 llb                         extention
                         000213 lub                         extention
                         000214 beg_num                     extention
                         000215 not_sw                      extention
                         000240 i                           dump_entry
                         000241 ndx                         dump_entry
                         000242 ch                          dump_entry
                         000243 result                      dump_entry

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   return              signal              shorten_stack       ext_entry
set_cs_eis          index_cs_eis        any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          ioa_$ioa_switch               ioa_$ioa_switch_nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
tedcommon_$etc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000353        30 000361       103 000362       110 000376       111 000401       112 000406       113 000407
    114 000410       116 000411       128 000433       129 000436       130 000437       131 000443       133 000445
    134 000446       135 000450       136 000452       137 000454       138 000457       140 000461       142 000465
    146 000467       148 000507       150 000514       151 000522       152 000533       154 000535       155 000537
    158 000540       159 000541       160 000547       161 000551       162 000561       163 000566       165 000570
    166 000571       168 000572       170 000577       171 000601       172 000607       174 000610       176 000614
    177 000616       179 000621       181 000624       182 000630       183 000632       185 000636       186 000637
    187 000641       189 000642       192 000651       193 000653       194 000654       197 000655       199 000660
    202 000667       203 000670       204 000672       205 000674       207 000675       209 000716       211 000720
    212 000722       213 000726       214 000736       215 000756       217 000763       218 000764       219 000767
    220 000771       222 000772       224 000774       226 001000       228 001006       230 001007       234 001023
    236 001026       237 001027       238 001035       239 001050       240 001053       241 001056       243 001057
    245 001073       247 001076       248 001103       251 001104       252 001105       253 001117       254 001125
    255 001127       256 001133       257 001143       258 001145       260 001146       264 001155       265 001156
    266 001160       267 001162       268 001166       269 001176       271 001214       274 001222       275 001223
    276 001237       277 001240       278 001242       280 001244       282 001245       284 001257       286 001273
    287 001303       289 001306       291 001320       295 001326       297 001330       299 001346       300 001353
    301 001356       302 001366       304 001371       306 001373       307 001376       309 001410       311 001411
    326 001434       327 001437       328 001443       330 001451       331 001457       333 001460       334 001461
    339 001463       340 001465       344 001511       345 001512       346 001513       348 001517       349 001521
    353 001545       356 001552       357 001554       362 001560       363 001563       364 001565       365 001567
    366 001571       369 001634       371 001643       372 001651       373 001657       375 001665       377 001671
    379 001713       383 001754       385 001756       387 001761       389 002001       391 002002       392 002003
    394 002007       396 002011       400 002045       401 002046       403 002050       404 002051       406 002052
    407 002054       409 002055       411 002057       415 002062       418 002074       419 002101       420 002102
    423 002112       425 002115       427 002120       429 002141       431 002142       433 002145       434 002146
    436 002147       438 002150       439 002152       444 002156       446 002163       447 002164       449 002165
    452 002175       453 002177       455 002200       456 002201       457 002225       459 002226       460 002227
    462 002230       464 002231       465 002233       468 002234       475 002240       476 002261       479 002263
    481 002277       484 002321       488 002323       492 002324       493 002326       497 002341       499 002342
    503 002345       505 002364       507 002365       509 002377       511 002401       514 002417       515 002421
    516 002430       518 002433       519 002437       523 002440       579 002441       583 002444       585 002445
    587 002451       588 002455       590 002461       591 002475       593 002477       596 002502       597 002504
    599 002505       602 002522       604 002523       608 002526       610 002531       611 002533       613 002534
    615 002537       616 002541       617 002542       619 002546       622 002550       623 002552       625 002554
    627 002560       628 002562       630 002563       633 002571       634 002575       638 002655       639 002656
    641 002663       643 002665       646 002670       650 002671       652 002675       653 002706       654 002707
    656 002716       658 002721       660 002722       664 002723       665 002726       670 002744       675 003030
    677 003035       679 003042       681 003051       683 003052       685 003053       687 003055       922 003056
    926 003071       928 003074       933 003151       935 003160       936 003162       937 003164       939 003166
    941 003176       942 003206       943 003207       945 003210       689 003211       691 003212       692 003214
    697 003260       699 003261       703 003263       705 003272       706 003300       707 003306       708 003317
    710 003331       711 003333       713 003343       714 003347       715 003352       717 003361       718 003362
    771 003363       773 003406       775 003412       776 003414       778 003415       779 003417       781 003422
    782 003424       783 003443       785 003444       786 003463       788 003467       789 003471       792 003514
    794 003521       795 003522       797 003527       798 003530       799 003552       800 003570       802 003571
    803 003605       804 003607       808 003632       809 003637       811 003642       812 003643       813 003665
    814 003671       815 003673       816 003674       817 003675       819 003700       821 003702       822 003710
    824 003723       825 003736       826 003745       828 003746       830 003751       831 003753       832 003757
    834 003767       835 003770       836 004013       837 004014       839 004016       841 004024       842 004026
    843 004030       845 004031       846 004050       847 004057       848 004065       849 004076       850 004102
    852 004115       853 004123       854 004133       856 004134       858 004136       860 004140       861 004146
    863 004147       865 004154       866 004155       868 004157       870 004163       871 004165       872 004171
    873 004172       874 004176       876 004206       877 004207       879 004211       880 004213       881 004217
    882 004220       883 004224       884 004234       886 004235       887 004243       890 004244       891 004267
    893 004273       894 004277       896 004307       897 004315       899 004316       900 004320       903 004321
    905 004326       907 004333       908 004335       909 004337       911 004340       913 004342       915 004350
    916 004356       917 004366       918 004400       920 004401       946 004402       957 004403       959 004405
    961 004411       963 004416       965 004422       967 004425       968 004427       969 004431       971 004434
    973 004437       974 004441       976 004444       977 004446       979 004450       981 004451       983 004453
    984 004454       985 004455       988 004463       990 004465       991 004470       992 004473       993 004475
    995 004476       997 004477      1001 004543      1005 004544      1026 004546      1027 004556      1030 004643
   1031 004644      1033 004655      1034 004656      1035 004673      1037 004676      1039 004726      1041 004727
   1042 004735      1044 004753      1046 004770      1048 005005      1049 005014      1050 005016      1053 005046
   1056 005066


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
