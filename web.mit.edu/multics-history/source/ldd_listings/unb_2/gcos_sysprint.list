	COMPILATION LISTING OF SEGMENT gcos_sysprint
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1119.75_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 gcos_sysprint: gsp: proc;
       12 
       13 
       14 /* 
       15*
       16*     GSP  will  translate  a  sysout  or print file, produced by the gcos
       17*     environment simulator, from BCD to ASCII, and either print it on the
       18*     user's  terminal,  or  write  it  into  a  file  (whose  pathname is
       19*     supplied) for later dprinting.
       20*    
       21*    	USAGE:  gcos_sysprint input_path {output_path} {-lower_case}
       22*    
       23*      1) input_path  is  the  pathname  of a sysout or print file.  If it
       24*    		contains  the  special records that are placed in the
       25*    		output file by the simulator, it will be treated as a
       26*    		sysout file, and:
       27*    
       28*    			a) The  execution  report  will  be located
       29*    			   within the file and printed first
       30*
       31*					and
       32*
       33*    			b) The  records  for  each activity will be
       34*    			   grouped  by report code, and printed for
       35*    			   each activity.
       36*    
       37*    		Otherwise,  the file will be treated as a print file,
       38*    		and  its records will be converted and printed in the
       39*    		order in which they appear in the input file, with no
       40*    		grouping or reordering of any kind.
       41*    
       42*      2) output_path  is  the optional pathname of an output file.  If it
       43*    		is  not  supplied,  lines  will  be  printed  on  the
       44*    		terminal  as they are converted.  If the file already
       45*    		exists, it will be replaced with no warning.
       46*    
       47*      3) -lower_case (-lc) is an optional control argument whose use will
       48*    		cause  BCD  alphabetic characters to be translated to
       49*    		lower  case  ASCII,  instead  of the default of upper
       50*    		case.
       51*    
       52*     Translation  is  performed  by  gcos_sys_xlate_ (or its entry point,
       53*     gcos_sys_xlate_lc_,  if  -lower_case is given), which will recognize
       54*     ASCII  media  codes  (those  >=  5),  and  copy the ASCII characters
       55*     without  translation,  allowing mixed upper and lower case output to
       56*     be produced from ASCII input records.
       57*    
       58**/
       59 
       60 /* *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*     HISTORY     *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* */
       61 
       62 
       63 /*
       64*
       65*   Author: Dick Snyder	1971
       66*
       67*   Change: Tom Casey	Sep73, Dec73, Mar74, Aug74
       68*
       69*   Change: Dave Ward	01/13/81
       70*
       71*   Change: Dave Ward	01/20/81 potential bug indexing pdstring.
       72*
       73*   Change: Dave Ward	02/17/81 write_line proc.  Delete initial form feed.
       74*
       75*   Change: Scott C. Akers     09/24/81	Rewrite  the whole thing from scratch,
       76*				using iox_ instead of ios_, increasing
       77*				the  modularity  of  the  program, and
       78*				chopping    out   oodles   of   GOTOs.
       79*				Eliminate sorting of report codes.
       80*				Ignore -temp_dir ctl_arg.
       81*
       82*  Change: Ron Barstad         10/07/82  Increased size of outbuf to accomidate
       83*                                        possible conversion of bcd control
       84*                                        sequences into more than 1 ascii char 
       85**/
       86 
       87 /*
       88*
       89*			 D__e_t_a_i_l_s
       90*
       91*     GSP  processes  two kinds of files: regular GCOS ASCII files, and
       92*     files   which  contain  BCD  print_line  images  (variable-length
       93*     records).
       94*
       95*     When  GSP  is  first  called, it checks the file to see if it's a
       96*     vanilla-flavored  GCOS file, or a SYSOUT file.  It then calls one
       97*     of  two  routines,  if  the file fits one of these categories, or
       98*     prints an error messages and quits if the file is inconsistent or
       99*     nonconforming.
      100*     
      101*     The  first (and simplest) routine is "process_simple_file", which
      102*     converts GCOS ASCII files to Multics ASCII in a form suitable for
      103*     printing.  It simply reads a block from the input file, and ships
      104*     it off to write_line for conversion and printing.
      105*
      106*     The  second  is  "process_sysout_file",  which searches the input
      107*     file  for the execution report, and prints it first.  If there is
      108*     no  execution  report,  a warning is printed.  Once the execution
      109*     report  (if  it  exists)  has  been  processed, we search for the
      110*     individual  activities  which make up the rest of the file.  They
      111*     are  already  ordered  within the file, but the reports within an
      112*     activity  are  not  grouped  neatly  together.   Instead,  it  is
      113*     possible  that  some  records for report 74 will be followed by a
      114*     few  records  for report 00, and then some more stuff for 74.  It
      115*     is  the  responsibility  of  GSP  to collect all the records with
      116*     matching report codes before we can process the next report.
      117*
      118*     Each  activity  has  an  offset  relative to the beginning of the
      119*     input  file.   The  offset  (in 320-word blocks) is placed in the
      120*     acty_table  entry  corresponding  to  the  ordinal  number of the
      121*     activity.
      122*
      123*     In  order  to  find  all  the  records which belong to a specific
      124*     report,   we   have   two   routines,  "find_next_rept_code"  and
      125*     "find_current_report_code",  which scan each activity looking for
      126*     report  codes.   As  each report code is encountered, an entry is
      127*     made  for  it  in the "encountered" table.  Once all records in a
      128*     given  report  are printed, an entry for that report code is made
      129*     in  the "done" table.  This insures that the report code will not
      130*     be considered again within this activity.
      131*
      132*		       << continued >>
      133*
      134**/
      135 
      136 /*
      137*
      138*     The  actual  output  mechanism  is  fairly  straightforward,  but
      139*     tedious.   Once a block is read in, it is scanned for occurrences
      140*     of  the  current  report  code.   Each  record which contains the
      141*     current  report code is placed in an output block, and its length
      142*     is  added  to  the  SIZE  field  of the output block control word
      143*     (BCW).   When  the  input block is exhausted, the output block is
      144*     shipped off to write_line for conversion and printing.
      145*
      146*     There  were  other  possible  methods for accomplishing the task.
      147*     The  original  method  was  to  gather up all the records for one
      148*     report,  and  put them in a separate file.  Then, the next report
      149*     was  gathered  up  and  put  away.   This continued until all the
      150*     records had been picked up and put somewhere else.  This entailed
      151*     the  opening  of  up  to  65 or 70 files for a large, complicated
      152*     activity.   The  process  directory was often not large enough to
      153*     hold  all these, and a special directory had to be specified as a
      154*     workspace.   It  was  also  necessary  to move all that data back
      155*     together  again  to  assemble  the  final  report.  This was very
      156*     costly.
      157*
      158*     Another  method  made  use of a linked list to keep track of each
      159*     record  in  the  file.  This, too, entails some overhead, and the
      160*     list could (potentially) be too large to fit in a single segment,
      161*     and  would  overflow the process_directory.  The big advantage of
      162*     this  method  is that it does not require shuffling large amounts
      163*     of  data from file to file except for the final output stage.  It
      164*     does,  however,  necessitate  the  maintenance  of  a  segment or
      165*     segments  (each  255  pages  long)  to hold the list, so there is
      166*     still the potential need to specify a directory for workspace.
      167*
      168*     The  method  I  finally chose involves a bit more data-shuffling,
      169*     but  requires  no  more  than  two  files  to  be open during the
      170*     invocation  of  the command.  These are, naturally, the input and
      171*     (possibly)  output files.  If the output is to be directed to the
      172*     user's  terminal, only the input file is opened.  This completely
      173*     eliminates  the  need  for  a  workspace  directory  of any kind,
      174*     because  data  is moved from the input file as needed, converted,
      175*     and  placed  in  the  output  file.   No  extra files are needed,
      176*     regardless of the size of the input or output files.
      177*						
      178*     Upon  looking  over  the declarations, you will notice that there
      179*     are  some  moderately  kinky uses of based structures.  Please be
      180*     careful  when  modifying  the  code,  since  pointers are fragile
      181*     creatures.   It  is  not  at all uncommon to change a pointer and
      182*     discover that your I/O control block has magically disappeared.
      183*
      184*			<< END >>
      185*
      186**/
      187 
      188 	on   condition (cleanup)			/* Set up handlers. */
      189 	     goto abnormal_exit;
      190 
      191  	call cu_$arg_count (nargs);
      192  	if   nargs = 0
      193  	then do;
      194  	     call com_err_ (error_table_$noarg,		/* No arguments. */
      195  			ENTRY_NAME,
      196  			USAGE);
      197 	     goto quick_exit;
      198  	     end;
      199 	call init_routine;				/* Initialize before reading args. */
      200 	call cu_$arg_list_ptr (arglistp);		/* Get a pointer to the args */
      201 	call process_args;				/* Process the args */
      202 	if   code ^= 0
      203 	then goto abnormal_exit;			/* Bail out if error. */
      204 
      205 	call check_file;				/* See if file is sysout or vanilla flavored. */
      206 
      207 	if   code ^= 0
      208 	then do ;
      209 	     call com_err_ (code, ENTRY_NAME, "^/^a",real_path);
      210 	     goto abnormal_exit;
      211 	     end;
      212 
      213 	if   sysout_sw
      214 	then call process_sysout_file;
      215 	else call process_simple_file;
      216 
      217 	if   code = 0
      218 	then goto normal_exit;
      219 	else goto abnormal_exit;
      220 
      221 
      222 normal_exit:	;				/* If all goes well */
      223 
      224 abnormal_exit:	;				/* When all doesn't go well */
      225 
      226  	call fixup_before_dying;			/* Don't leave loose ends dangling */
      227 
      228 quick_exit:	;				/* Bail out if no args specified */
      229 
      230  	return;
      231 
      232 attach_stream: proc (stream_name, iocb_ptr,		/* attaches all I/O streams */
      233 		 pathname, mode);
      234 
      235 dcl  stream_name	char(*)		parm;		/* INPUT */
      236 dcl  iocb_ptr 	pointer		parm;		/* INPUT */
      237 dcl  pathname	char(168)		parm;		/* INPUT */
      238 dcl  mode		char(2)		parm;		/* INPUT */
      239 dcl  attach_descr	char(200);
      240 dcl  open_mode	fixed bin;
      241 
      242 dcl (stream_io	init (3),
      243      stream_in	init (1)
      244 
      245     )		fixed bin internal static options (constant);
      246 
      247 
      248  	attach_descr = "vfile_ " || pathname;		/* Build the attach description */
      249  	call iox_$attach_name (stream_name,
      250  			   iocb_ptr,
      251  			   attach_descr,
      252  			   (null),
      253  			   code);
      254 
      255  	if code = 0				/* Don't mess with this unless */
      256 	 | code = error_table_$noentry		/* the attachment went O.K. */
      257 
      258  	then do;
      259 	     code = 0;
      260 
      261  	     if mode = "r"
      262  	     then open_mode = stream_in;
      263  	     else open_mode = stream_io;
      264 
      265  	     call iox_$open (iocb_ptr, open_mode, ("0"b), code);
      266 
      267  	     end;
      268 
      269  	return;
      270 
      271 end attach_stream;
      272 
      273 build_block: proc;					/* Build a block for output */
      274 
      275 	BCW.BSN = BCW.BSN + 1;			/* Set this so write_line knows there's
      276*						   a valid block. */
      277 	RECORD_PTR = addr (BLOCK.DATA);
      278 	block_ptr = addr (BCW.data);			/* Set up pointer to output block. */
      279 	BCW.block_size = 0;				/* Start with empty output block. */
      280 	rec_count = 0;
      281 	do   while (rec_count < BLOCK.SIZE);		/* Move all records whose report code
      282*						   matches the current one. */
      283 	     if   RCW.REPORT_CODE = current_rept_code
      284 	     then do;
      285 		out_record = in_record;
      286 		BCW.block_size = BCW.block_size + RCW.LENG + 1;
      287 		block_ptr = addrel (block_ptr, RCW.LENG + 1);
      288 		end;
      289 
      290 	     rec_count = rec_count + RCW.LENG + 1;
      291 	     RECORD_PTR = addrel (RECORD_PTR, RCW.LENG + 1);
      292 	     end;
      293 
      294 	return;
      295 
      296 end build_block;
      297 
      298 check_file: proc;					/* See if file is sysout or simple file.
      299*						   If it's sysout, then set sysout_sw.
      300*						   If it's not a legal GCOS file,
      301*						   return a non-zero error code. */
      302 
      303 	call rewind_file (in_ptr);
      304 	if code = 0
      305 	then do;
      306 	     call read_stream (in_ptr, buffp, 16, dummy);
      307 	     if code = 0
      308 	     then do;
      309 		if BCW.BSN ^= 1
      310 		then code = error_table_$bad_file;
      311 		else do;
      312 		     if first_record.rec1 = "rec1"
      313 		     then sysout_sw = "1"b;
      314 		     else sysout_sw = "0"b;
      315 		     end;
      316 		end;
      317 	     end;
      318 
      319 	else code = 0;
      320 
      321 	return;
      322 
      323 end check_file;
      324 
      325 detach_stream: proc (iocb_ptr);			/* Detach an I/O stream */
      326 
      327 dcl  iocb_ptr	pointer		parm;		/* INPUT */
      328 
      329 	if iocb_ptr ^= null
      330 	then do;
      331 	     call iox_$close (iocb_ptr, code);
      332 	     call iox_$detach_iocb (iocb_ptr, code);
      333 	     call iox_$destroy_iocb (iocb_ptr, code);
      334 	     end;
      335 
      336  	return;
      337 
      338 end detach_stream;
      339 
      340 expand_path: proc (n, in_path, dir_name, e_name)returns (bit (1));
      341 
      342 /*
      343*Expand in_path into dir_name and e_name and combine the two into real_path.
      344**/
      345 
      346 dcl  dir_name	char(*)		parm;		/* OUTPUT */
      347 dcl  e_name	char(*)		parm;		/* OUTPUT */
      348 dcl  n		fixed bin		parm;		/* INPUT */
      349 dcl  in_path	char(*)		parm;		/* INPUT */
      350 
      351  	call expand_pathname_ (in_path, dir_name, e_name, code);
      352 
      353  	if code = 0
      354  	then do;
      355  	     real_path = rtrim (dir_name) || ">" || rtrim (e_name);
      356  	     return ("0"b);
      357  	     end;
      358  	else do;
      359  	     call com_err_ (code, ENTRY_NAME, "^/""^a""^[ (arg ^i)^;^s^]", in_path, n>0, n);
      360  	     return ("1"b);
      361  	     end;
      362 
      363 end expand_path;
      364 
      365 find_activities: proc;				/* Find activities in a sysout file */
      366 
      367 	call rewind_file (in_ptr);
      368 	if code = 0
      369 	then do;
      370 	     acty_table (1) = 0;			/* First activity */
      371 	     acty_index = 2;
      372 	     acty_count, acty_offset = 0;
      373 	     unspec (buffer) = "0"b;
      374 	     more_actys = "1"b;
      375 	     do   while (more_actys);			/* Pick up all the activity offsets. */
      376 		acty_table (acty_index) = 0;
      377 		acty_offset = 0;
      378 		do   while (acty_offset = 0);
      379 		     call read_stream (in_ptr,	/* Grab a block */
      380 				   buffp,
      381 				   (sysout_chunk.chars),
      382 				   dummy);
      383 		     if code ^= 0
      384 		      | eofsw			/* We should NEVER have an EOF.
      385*						/* We'll know we're done when
      386*						/* we see the "start ex rpt" string. */
      387 		     then do;
      388 			if code = 0
      389 			then code = error_table_$end_of_info;
      390 			call com_err_ (code,
      391 				     ENTRY_NAME,
      392 				     "^/Error while reading input file.");
      393 			end;
      394 		     else do;
      395 			acty_offset = index (buffer, "start ex rpt");
      396 			if acty_offset = 0
      397 			then do;
      398 			     acty_offset = index (buffer, "end activity");
      399 			     if acty_offset > (4 * BCW.block_size)
      400 			     then acty_offset = 0;
      401 			     acty_table (acty_index) = acty_table (acty_index) + sysout_chunk.blocks;
      402 			     end;
      403 			else do;
      404 			     more_actys = "0"b;
      405 			     end;
      406 			end;
      407 		     end;
      408 
      409 		acty_index = acty_index + 1;
      410 
      411      		end;
      412 
      413 	     acty_count = acty_index - 3;
      414 
      415 	     end;
      416 
      417 	return;
      418 
      419 end find_activities;
      420 
      421 find_current_rept_code: proc;
      422 
      423 /*
      424*       Scan the block for the current report code (current_rept_code),
      425*       and set "found" true if we find it.  Otherwise, leave it false.
      426*       As  we're doing this, we also make entries in the "encountered"
      427*       table, so we know what report codes are left to be checked.
      428**/
      429 
      430 	rec_count = 0;
      431 	found = "0"b;
      432 	RECORD_PTR = addr (BLOCK.DATA);
      433 
      434 	do   while (rec_count < BLOCK.SIZE);
      435 
      436 	     encountered (RCW.REPORT_CODE) = "1"b;
      437 	     if   RCW.REPORT_CODE = current_rept_code
      438 	        & ^done (current_rept_code)
      439 	     then found = "1"b;
      440 	     rec_count = rec_count + RCW.LENG + 1;
      441 	     RECORD_PTR = addrel (RECORD_PTR, RCW.LENG+1);
      442 	     end;
      443 
      444 	return;
      445 
      446 end find_current_rept_code;
      447 
      448 find_next_rept_code: proc;				/* Scan the block for the next report code.
      449*						   Note: This routine cannot be merged with
      450*						   find_current_rept code because it is not
      451*						   always called. */
      452 
      453 	rec_count = 0;
      454 	RECORD_PTR = addr (BLOCK.DATA);
      455 	current_rept_code = 62;			/* Gotta pretend we've already got a dead one. */
      456 
      457 	do   while (rec_count < BLOCK.SIZE & done (current_rept_code));
      458 	     encountered (RCW.REPORT_CODE) = "1"b;
      459 	     current_rept_code = RCW.REPORT_CODE;
      460 	     rec_count = rec_count + RCW.LENG + 1;
      461 	     RECORD_PTR = addrel (RECORD_PTR, RCW.LENG+1);
      462 	     end;
      463 
      464 	if ^done (current_rept_code)			/* If we find a winner */
      465 	then call make_rept_code_banner;		/* then print the banner. */
      466 
      467 	return;
      468 
      469 end find_next_rept_code;
      470 
      471 fixup_before_dying: proc;				/* clean up for both normal and abnormal terminations */
      472 
      473  	call detach_stream (in_ptr);
      474 	call detach_stream (out_ptr);
      475 
      476  	return;
      477 
      478 end fixup_before_dying;
      479 
      480 init_routine: proc;					/* Perform initialization stuff */
      481 
      482 
      483  	in_dir, in_ent, out_dir, out_ent = " ";
      484  	out_stream = "user_output";
      485 	in_ptr, out_ptr = null;
      486 	sysout_sw = "0"b;
      487  	buffp = addr (buffer);
      488  	outbufp = addr (outbuf);
      489 	recbuffp = addrel (buffp, 1);
      490 	recordp = addrel (buffp,2);
      491 	output_record_count = 0;
      492 	acty_table = 0;
      493 
      494 	do   ptr_index = 0 to (chunk_size.blocks - 1);
      495 	     buff_ptr(ptr_index) = addrel (buffp, (320*ptr_index));
      496 	     end;
      497 
      498 	return;
      499 
      500 end init_routine;
      501 
      502 make_rept_code_banner: proc;				/* Prints report code headers on
      503*						   terminal or output file. */
      504 
      505 	if   out_ptr = null
      506 	then call ioa_$ioa_switch (iox_$user_output,
      507 			  "^2/   SNUMB# ^5a, Activity # ^2d, REPORT CODE = ^2o^2/",
      508 			  snumb,
      509 			  acty_index,
      510 			  current_rept_code);
      511 
      512 	else call ioa_$ioa_switch (out_ptr,
      513 			  "^|   SNUMB# ^5a, Activity # ^2d, REPORT CODE = ^2o^2/",
      514 			  snumb,
      515 			  acty_index,
      516 			  current_rept_code);
      517 
      518 	return;
      519 
      520 end make_rept_code_banner;
      521 
      522 more_reports_in_acty: proc returns (bit (1));		/* Returns true if there are more reports
      523*						   in the current activity, and
      524*						   returns false otherwise. */
      525 
      526 	match = "0"b;
      527 	do   test_index = 0 to 63 while (^match);
      528 	     match = (encountered (test_index) & ^done (test_index));
      529 	     end;
      530 
      531 	return (match);
      532 
      533 dcl  match	bit(1);
      534 dcl  test_index	fixed bin;
      535 
      536 end more_reports_in_acty;
      537 
      538 position_file: proc (file_ptr, file_position);		/* Sets the file pointer to the indicated word */
      539 
      540 dcl  file_ptr	ptr		parm;		/* INPUT */
      541 dcl  file_position	fixed bin (21)	parm;		/* INPUT */
      542 
      543 	call iox_$position (file_ptr, (2), (4 * file_position), code);
      544 
      545 	return;
      546 
      547 end position_file;
      548 
      549 process_args: proc;					/* Argument processing.
      550*						   If an error occurs, it is reported here, so
      551*						   the caller doesn't have to do anything but die. */
      552 
      553 	do   argno = 1 to nargs;
      554 
      555  	     call cu_$arg_ptr_rel	(argno, argp, argl,
      556 				code, arglistp);
      557 
      558  	     if code ^= 0
      559  	     then do;
      560 		call com_err_ (code, ENTRY_NAME, "^/Arg ^i.", argno);
      561 		goto exit_p_a;
      562 		end;
      563 
      564  	     if argno = 1
      565  	     then do;				/* First arg must be input file. */
      566  		in_stream = "gcos_sysprint_input_";
      567  		if expand_path (argno, arg, in_dir, in_ent)
      568  		then do;
      569 		     code = error_table_$badopt;
      570 		     call com_err_ (code, ENTRY_NAME,
      571 				"^/Arg #^i (^a)",
      572 				argno, arg);
      573 		     goto exit_p_a;
      574 		     end;
      575 
      576  		call attach_stream (in_stream, in_ptr, real_path, "r");
      577  		if code ^= 0
      578  		then do;
      579  		     call com_err_ (code, ENTRY_NAME,
      580 				"^/Cannot attach input stream ^a:^/^a",
      581 				in_stream, real_path);
      582  		     goto exit_p_a;
      583  		     end;
      584 
      585 		end;				/* END OF ARG 1 PROCESSING */
      586 
      587  /* 	Get possible second argument - name of file to write output into	 */
      588 
      589  	     else
      590  	     if argno = 2
      591 	     then do;
      592  		if substr (arg, 1, 1) = "-"
      593 		then do;				/* must be control arg */
      594 		     call process_ctl_arg;
      595 		     if code ^= 0
      596 		     then do;
      597 			call com_err_ (code, ENTRY_NAME,
      598 				     "^/Arg #^i (^a)",
      599 				     argno, arg);
      600 			goto exit_p_a;
      601 			end;
      602 		     end;
      603 
      604 		else do;
      605 		     filesw = "1"b;			/* it must be a file name */
      606 		     out_stream = "GSP_output_";	/* write output file thru this stream */				
      607 
      608 		     if expand_path (argno, arg, out_dir, out_ent)
      609 		     then do;
      610 			call com_err_ (code, ENTRY_NAME,
      611 				     "^/Arg #^i (^a)",
      612 				     argno, arg);
      613 			goto exit_p_a;
      614 			end;
      615 
      616 		     call attach_stream (out_stream,	/* attach output name */
      617 				     out_ptr,
      618 				     real_path,
      619 				     "rw");
      620 
      621 		     if code ^= 0
      622 		     then do;
      623 			call com_err_ (code, ENTRY_NAME,
      624 				     "^/Cannot attach output stream ^a:^/^a",
      625 				     out_stream, real_path);
      626 			goto exit_p_a;
      627 			end;
      628 		     end;
      629 		end;				/* END OF ARG 2 PROCESSING */
      630 
      631  	     else if temp_sw
      632 		then temp_sw = "0"b;		/* if previous arg was -temp_dir, this is the path */
      633 
      634  	     else do;
      635 		call process_ctl_arg;
      636 		if code ^= 0
      637 		then do;
      638 		     call com_err_ (code, ENTRY_NAME, arg);
      639 		     goto exit_p_a;
      640 		     end;
      641 		end;
      642 	     end;
      643 
      644 exit_p_a:	;
      645 
      646 	return;
      647 
      648 end process_args;
      649 
      650 process_ctl_arg: proc;				/* Parse the control arguments */
      651 
      652 	code = 0;
      653 	if arg = "-lc" | arg = "-lower_case"
      654 	then lc_switch = "1"b;
      655 
      656      else if arg = "-td" | arg = "-temp_dir"
      657 	then temp_sw = "1"b;			/* path of temp_dir will be next arg */
      658 
      659      else code = error_table_$badopt;
      660 
      661 	return;
      662 
      663 end process_ctl_arg;
      664 
      665 process_ex_rept: proc;				/* Process the execution report */
      666 
      667 	acty_index = 0;				/* For write_line, if error */
      668 	call rewind_file (in_ptr);
      669 	if   code = 0
      670 	then call read_stream (in_ptr, buffp, 28, dummy);	/* Get info for execution report */
      671 	if code = 0
      672 	then do;
      673 	     snumb = first_record.jobs_snumb;		/* Pick up SNUMB and EX REPT offset */
      674 	     if   first_record.er_offset = 0
      675 	     then do;
      676 		call com_err_ (0, ENTRY_NAME,
      677 			     "WARNING: Incomplete sysout file - execution report missing");
      678 		end;
      679 	     else do;
      680 
      681 		call position_file (in_ptr, (first_record.er_offset));
      682 		if code ^= 0
      683 		then do;
      684 		     call com_err_ (code, ENTRY_NAME,
      685 				"Attempting to position input file");
      686 		     end;
      687 		else do;
      688 		     call read_stream (	in_ptr,
      689 				     buffp,
      690 				     (chunk_size.chars),
      691 				     dummy);
      692 
      693 		     do   while (^eofsw & code = 0);
      694 
      695 			do   ptr_index = 0 to (output_block_count - 1) while (code = 0);
      696 			     buffp = buff_ptr (ptr_index);
      697 			     call write_line;
      698 			     end;
      699 
      700 			if code = 0
      701 			then do;
      702 			     buffp = addr (buffer);
      703 
      704 			     call read_stream (  in_ptr,
      705 					     buffp,
      706 					     (chunk_size.chars),
      707 					     dummy);
      708 			     end;
      709 			end;
      710 		     end;
      711 		end;
      712 	     end;
      713 
      714 	return;
      715 
      716 end process_ex_rept;
      717 
      718 process_rept_codes: proc;				/* Collect and print report codes within an activity. */
      719 
      720 						/* Determine the absolute file position
      721*						   for this activity. */
      722 	acty_offset = acty_offset + (320 * acty_table (acty_index));
      723 
      724 	done, encountered = "0"b;			/* Reset the "done" flags for this activity. */
      725 	current_rept_code = 62;			/* Force a guaranteed non-kosher
      726*						   report code (76 octal). */
      727 	encountered (62) = "1"b;			/* Gotta fake out the "more report" finder. */
      728        
      729 	do   while (code = 0 & more_reports_in_acty ());
      730 
      731 	     done (62) = "1"b;			/* So we don't keep looking for this rept code */
      732 	     call position_file (in_ptr, (acty_offset));
      733 
      734 	     do   rept_index = 1 to acty_table (acty_index+1) while (code = 0);
      735 
      736 		call read_stream (  in_ptr,
      737 				addr (BLOCK),
      738 				1280,
      739 				dummy);
      740 
      741 		if code = 0
      742 		then do;
      743 		     if   done (current_rept_code)
      744 		     then call find_next_rept_code;	/* Find the next report code */
      745 		     if ^done (current_rept_code)
      746 		     then do;
      747 			call find_current_rept_code;	/* Scan block for current report code. */
      748 			if   found		/* If we find it */
      749 			then do;
      750 			     call build_block;	/* Build the output block. */
      751 			     call write_line;	/* Write block to output stream. */
      752 			     end;
      753 			end;
      754 		     end;
      755 		end;
      756 
      757 	     done (current_rept_code) = "1"b;		/* Mark this report code as "used up". */
      758 
      759 	     end;
      760 
      761 	return;
      762 
      763 end process_rept_codes;
      764 
      765 process_simple_file: proc;				/* Process a regular GCOS file */
      766 
      767 	call rewind_file (in_ptr);			/* Rewind the input file */
      768 	call read_stream (in_ptr,			/* Pick up the first 3 blocks. */
      769 		        buffp,
      770 		        (chunk_size.chars),
      771 		        dummy);
      772 
      773 	if code ^= 0
      774 	 | eofsw
      775 	then call com_err_ (code, ENTRY_NAME, "^/Error while reading ^a", in_stream);
      776 	else do   while (^eofsw);
      777 
      778 		do   ptr_index = 0 to (output_block_count - 1);
      779 		     buffp = buff_ptr (ptr_index);
      780 		     call write_line;
      781 		     end;
      782 
      783 		buffp = addr (buffer);
      784 
      785 		call read_stream (in_ptr,
      786 			        buffp,
      787 			        (chunk_size.chars),
      788 			        dummy);
      789 
      790 		end;
      791 
      792  
      793 	return;
      794 
      795 end process_simple_file;
      796 
      797 process_sysout_file: proc;				/* Process a SYSOUT file */
      798 
      799 	call process_ex_rept;			/* Do the execution summary first. */
      800 	if code = 0				/* Bail out if it blows up. */
      801 	then do;
      802 	     call find_activities;			/* Locate all the activities in this file. */
      803 	     call rewind_file (in_ptr);
      804 	     acty_offset = 0;			/* Reset the activity offset,
      805*						   because we use it in the
      806*						   report-code processor to 
      807*						   determine our absolute
      808*						   file position. */
      809 
      810 	     do   acty_index = 1 to acty_count;
      811 		BCW.BSN = 0;			/* Reset before each activity. */
      812 		call process_rept_codes;
      813 		end;
      814 	     end;
      815 
      816 	return;
      817 
      818 end process_sysout_file;
      819 
      820 read_stream: proc (iocb_ptr, buffer_ptr, how_many, qty_got);
      821 
      822 /*
      823*
      824*   Read  from  the  indicated  stream  and place the data in the
      825*   buffer pointed to by buffer_ptr.  If fewer than the requested
      826*   number  of characters are read, we set a flag, and return the
      827*   EOF  indication  the  next time around.  If the read comes up
      828*   short for any reason other than error_table_$short_record, we
      829*   return an error.
      830*
      831**/
      832 
      833 dcl (iocb_ptr, buffer_ptr)	ptr		parm;	/* INPUT, INPUT */
      834 dcl (how_many, qty_got)	fixed bin (21)	parm;	/* INPUT, OUTPUT */
      835 
      836 dcl  short_switch		bit (1) internal static init ("0"b);
      837 
      838 	if short_switch
      839 	then do;
      840 	     eofsw = "1"b;
      841 	     short_switch = "0"b;
      842 	     end;
      843 
      844 	else do;
      845 	     eofsw = "0"b;
      846 	     call iox_$get_chars  (   iocb_ptr,
      847 				buffer_ptr,
      848 				how_many,
      849 				qty_got,
      850 				code);
      851 
      852 	     if code ^= 0
      853 	     then if code = error_table_$end_of_info
      854 		then do;
      855 		     eofsw = "1"b;
      856 		     code = 0;
      857 		     end;
      858 
      859 		else if code = error_table_$short_record
      860 						/* Short blocks are O.K. We'll get
      861*						   an EOF next time 'round. */
      862 		     then do;
      863 			code = 0;
      864 			short_switch = "1"b;
      865 			end;
      866 
      867 		end;
      868 
      869 	output_block_count = ceil (divide (qty_got, (4*320), 17));
      870 
      871 	return;
      872 
      873 end read_stream;
      874 
      875 rewind_file: proc (iocb_ptr);				/* Rewind the specified file */
      876 
      877 dcl  iocb_ptr	ptr	parm;			/* INPUT */
      878 
      879 	call iox_$position (iocb_ptr, (-1), 0, code);
      880 	if code ^= 0
      881 	then call com_err_ (code, ENTRY_NAME,
      882 			"^/Could not rewind file.");
      883 
      884 	return;
      885 
      886 end rewind_file;
      887 
      888 write_line: proc;					/* Write the next output line. */
      889 
      890 	if   BCW.BSN ^= 0
      891 	   & BCW.block_size ^= 0
      892 	then do;
      893 
      894  	     if lc_switch				/* if -lowercase control argument given */
      895 	     then call gcos_sys_xlate_lc_ (buffp,	/* translate buffer from BCD to lowercase ASCII */
      896 				     outbufp,
      897 				     conv_count);
      898  	     else call gcos_sys_xlate_ (buffp,		/* translate buffer from BCD to uppercase ASCII */
      899 				  outbufp,
      900 				  conv_count);
      901 
      902  	     output_record_count = output_record_count + 1;
      903 	     j = conv_count;
      904  	     if output_record_count = 1
      905  	      & char1 = "014"b3
      906 
      907 	     then call write_stream (out_ptr, addr (out1(2)), (j-1));
      908  	     else call write_stream (out_ptr, outbufp, (j));
      909 
      910  	     if code ^= 0
      911 	     then do;
      912 		call com_err_ (code,
      913 			     ENTRY_NAME,
      914 			     "^/Error attempting to write Activity # ^2d."
      915 			  || "^/Block # ^6o (octal), ^6d (decimal)^/",
      916 			     
      917 			     acty_index,
      918 			     BCW.BSN,
      919 			     BCW.BSN);
      920 		end;
      921 
      922 	     end;
      923 
      924 	return;
      925 
      926 end write_line;
      927 
      928 write_stream: proc (iocb_ptr, buffer_ptr, qty_sent);	/* Write on the specified output stream */
      929 
      930 dcl  stream_ptr ptr;
      931 
      932 dcl (iocb_ptr ptr,					/* INPUT */
      933      buffer_ptr ptr,				/* INPUT */
      934      qty_sent fixed bin (21)		) parm;		/* INPUT */
      935 
      936 	if iocb_ptr = null				/* See if terminal I/O */
      937 	then stream_ptr = iox_$user_output;
      938 	else stream_ptr = iocb_ptr;
      939 
      940 	call iox_$put_chars (stream_ptr, buffer_ptr, qty_sent, code);
      941 
      942 	return;
      943 
      944 end write_stream;
      945 
      946  /*	Variables for gcos_sysprint:		*/
      947 
      948  /*   IDENTIFIER		ATTRIBUTES	*/
      949 
      950 dcl  acty_table		(1:64) fixed bin (35);
      951 dcl (acty_index,
      952      acty_count,
      953      acty_offset)		fixed bin;
      954 dcl (addr,
      955      addrel)		builtin;
      956 dcl  arg			char (argl) based (argp);
      957 dcl  argl			fixed bin (21);
      958 dcl  argno		fixed bin;
      959 dcl  argp			pointer;
      960 dcl  arglistp		pointer;
      961 dcl  block_ptr		pointer;
      962 dcl  buffer		char (chunk_size.chars);
      963 dcl  buffp		pointer;
      964 dcl  buff_ptr		(0:chunk_size.blocks) pointer;
      965 dcl  ceil			builtin;
      966 dcl  char1                    bit(9) unaligned based (outbufp);
      967 dcl  1 chunk_size 		internal static aligned options (constant),
      968       2 blocks		fixed bin init (3),
      969       2 words		fixed bin init (960),
      970       2 chars		fixed bin init (3840);
      971 dcl  cleanup		condition;
      972 dcl  code			fixed bin(35);
      973 dcl  com_err_		entry() options(variable);
      974 dcl  conv_count		fixed bin;
      975 dcl  cu_$arg_count		ext entry (fixed bin);
      976 dcl  cu_$arg_ptr_rel	ext entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
      977 dcl  cu_$arg_list_ptr	ext entry (ptr);
      978 dcl  divide		builtin;
      979 dcl  done			(0:63) bit (1);
      980 dcl  encountered		(0:63) bit (1);
      981 dcl  ENTRY_NAME		char(19) int static options (constant)
      982 			init ("gcos_sysprint(10.0)");
      983 dcl  eofsw		bit (1);
      984 dcl (error_table_$badopt,
      985      error_table_$bad_file,
      986      error_table_$end_of_info,
      987      error_table_$noarg,
      988      error_table_$noentry,
      989      error_table_$short_record
      990 
      991     )			ext fixed bin (35);
      992 
      993 dcl  expand_pathname_	entry (char(*), char(*), char(*), fixed bin(35));
      994 dcl  filesw		bit (1) init ("0"b);
      995 dcl  file_index		fixed bin init (-1)		/* current file index used */;
      996 dcl  found		bit (1);
      997 dcl  gcos_sys_xlate_	ext entry (pointer, pointer, fixed bin);
      998 dcl  gcos_sys_xlate_lc_	ext entry (pointer, pointer, fixed bin);
      999 dcl  index		builtin;
     1000 dcl  in_dir		char(168);
     1001 dcl  in_ent		char(32);
     1002 dcl  in_ptr		pointer;
     1003 dcl  in_record		char (4*(RCW.LENG+1)) based (RECORD_PTR);
     1004 dcl  in_stream		char(32);
     1005 dcl (ioa_$ioa_switch entry() options(variable),
     1006      iox_$position entry (ptr, fixed bin, fixed bin(21), fixed bin(35)),
     1007      iox_$get_chars entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
     1008      iox_$put_chars entry (ptr, ptr, fixed bin(21), fixed bin(35)),
     1009      iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
     1010      iox_$close entry (ptr, fixed bin(35)),
     1011      iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35)),
     1012      iox_$detach_iocb entry (ptr, fixed bin(35)),
     1013      iox_$destroy_iocb entry (ptr, fixed bin(35)),
     1014      iox_$user_output pointer static
     1015     )		external;
     1016 
     1017 dcl  j			fixed bin(21);
     1018 dcl  lc_switch		bit (1) aligned init ("0"b)	/* "1"b => "-lower_case was given" */;
     1019 dcl  more_actys		bit (1);
     1020 dcl  nargs		fixed bin;
     1021 dcl  null			builtin;
     1022 dcl  current_rept_code	fixed bin (6) unsigned unaligned;
     1023 dcl  out1			(2) char(1) unaligned based (outbufp);
     1024 dcl  outbuf		char (2100);
     1025 dcl  outbufp		pointer;
     1026 dcl  output_block_count	fixed bin;
     1027 dcl  output_record_count	fixed bin;
     1028 dcl  out_dir		char(168);
     1029 dcl  out_ent		char(32);
     1030 dcl  out_ptr		pointer;
     1031 dcl  out_record		char (4*(RCW.LENG+1)) based (block_ptr);
     1032 dcl  out_stream		char(32);
     1033 dcl  ptr_index		fixed bin;
     1034 dcl  rec_count		fixed bin (35);
     1035 dcl  recbuffp		ptr;
     1036 dcl  recordp		pointer;
     1037 dcl  rept_index		fixed bin (35);
     1038 dcl  rtrim		builtin;
     1039 dcl  snumb		char (5) init ("");
     1040 dcl  substr		builtin;
     1041 dcl  1 sysout_chunk		internal static options (constant),
     1042       2 blocks		fixed bin (21) init (1),
     1043       2 words		fixed bin (21) init (320),
     1044       2 chars		fixed bin (21) init (1280);
     1045 dcl  sysout_sw		bit (1) aligned		/* "1"b => "this is a sysout file" */;
     1046 dcl  temp_sw		bit (1) aligned init ("0"b)	/* on when path of temp dir expected */;
     1047 dcl  real_path		char (168);
     1048 
     1049 dcl  unspec		builtin;
     1050 dcl  USAGE		char(78)static int options(constant) init(
     1051  "^/USAGE: gcos_sysprint input_path {output_path} {-lower_case}"
     1052  );
     1053 
     1054 dcl 1 first_record aligned based (recordp),		/* overlay for very first record of a sysout file */
     1055      2 newline_word bit (36),				/* contains BCD newline, for benefit of gcos_sys_xlate_ */
     1056      2 rec1 char (4),				/* must = "rec1" before we believe the rest of this stuff */
     1057      2 er_offset fixed bin aligned,			/* offset to seek to, to read execution report */
     1058      2 jobs_snumb char (5)				/* snumb of this job, for heading lines */;
     1059 
     1060 dcl 1 BCW aligned based (buffp),
     1061      2 BSN	fixed bin (18) unsigned	unaligned,
     1062      2 filler_1	bit	(9)		unaligned,
     1063      2 block_size	fixed bin	(9)  unsigned	unaligned,
     1064      2 data	char	(1276)		unaligned;
     1065 
     1066 dcl  dummy		fixed bin (21);
     1067 
  1     1 /* BEGIN INCLUDE FILE gcos_block_overlay.incl.pl1   (Akers SCUdmp)  11/23/81 2115.2 sca Mon */
  1     2 
  1     3 dcl    RECORD_PTR		pointer;
  1     4 
  1     5 
  1     6 dcl 1  BLOCK					aligned,
  1     7 
  1     8      2 BSN		fixed bin (18)	unsigned	unaligned,
  1     9      2 SIZE		fixed bin (18)	unsigned	unaligned,
  1    10      2 DATA		char (1276)		unaligned;
  1    11 
  1    12 
  1    13 
  1    14 dcl 1  RCW		based (RECORD_PTR)		aligned,
  1    15 
  1    16      2 LENG		fixed bin (18)	unsigned	unaligned,
  1    17      2 LAST_CHARS_USED	fixed bin (2)	unsigned	unaligned,
  1    18      2 EOF_MARKER		bit (4) 			unaligned,
  1    19      2 FILLER		bit (2)			unaligned,
  1    20      2 MEDIA_CODE		fixed bin (4)	unsigned unaligned,
  1    21      2 REPORT_CODE		fixed bin(6)	unsigned unaligned;
  1    22 
  1    23 
  1    24 /*   END INCLUDE FILE gcos_block_overlay.incl.pl1 */
     1068 
     1069 end gcos_sysprint;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1119.7  gcos_sysprint.pl1                 >udd>sm>ds>w>ml>gcos_sysprint.pl1
1068         1    03/27/82  0524.8  gcos_block_overlay.incl.pl1       >ldd>incl>gcos_block_overlay.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BCW                                    based           structure                level 1 dcl 1060
BLOCK                           001546 automatic       structure                level 1 dcl 1-6 set ref 736 736
BSN                                    based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1060
                                                                                  set ref 275* 275 309 811* 890 912* 912*
DATA                      1     001546 automatic       char(1276)               level 2 packed packed unaligned dcl 1-6 set ref 277
                                                                                  432 454
ENTRY_NAME                      000032 constant        char(19)                 initial packed unaligned dcl 981 set ref 194* 209*
                                                                                  359* 390* 560* 570* 579* 597* 610* 623* 638* 676*
                                                                                  684* 773* 880* 912*
LENG                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-14
                                                                                  ref 285 285 286 287 290 291 440 441 460 461
RCW                                    based           structure                level 1 dcl 1-14
RECORD_PTR                      001544 automatic       pointer                  dcl 1-3 set ref 277* 283 285 285 285 286 287 290
                                                                                  291* 291 291 432* 436 437 440 441* 441 441 454*
                                                                                  458 459 460 461* 461 461
REPORT_CODE               0(30)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 1-14
                                                                                  ref 283 436 437 458 459
SIZE                      0(18) 001546 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-6 set
                                                                                  ref 281 434 457
USAGE                           000006 constant        char(78)                 initial packed unaligned dcl 1050 set ref 194*
acty_count                      000201 automatic       fixed bin(17,0)          dcl 951 set ref 372* 413* 810
acty_index                      000200 automatic       fixed bin(17,0)          dcl 951 set ref 371* 376 401 401 409* 409 413 505*
                                                                                  512* 667* 722 734 810* 912*
acty_offset                     000202 automatic       fixed bin(17,0)          dcl 951 set ref 372* 377* 378 395* 396 398* 399 399*
                                                                                  722* 722 732 804*
acty_table                      000100 automatic       fixed bin(35,0)          array dcl 950 set ref 370* 376* 401* 401 492* 722
                                                                                  734
addr                                                   builtin function         dcl 954 ref 277 278 432 454 487 488 702 736 736 783
                                                                                  904 904
addrel                                                 builtin function         dcl 954 ref 287 291 441 461 489 490 495
arg                                    based           char                     packed unaligned dcl 956 set ref 567* 570* 592 597*
                                                                                  608* 610* 638* 653 653 656 656
argl                            000203 automatic       fixed bin(21,0)          dcl 957 set ref 555* 567 567 570 570 592 597 597 608
                                                                                  608 610 610 638 638 653 653 656 656
arglistp                        000210 automatic       pointer                  dcl 960 set ref 200* 555*
argno                           000204 automatic       fixed bin(17,0)          dcl 958 set ref 553* 555* 560* 564 567* 570* 589
                                                                                  597* 608* 610*
argp                            000206 automatic       pointer                  dcl 959 set ref 555* 567 570 592 597 608 610 638 653
                                                                                  653 656 656
attach_descr                    002264 automatic       char(200)                packed unaligned dcl 239 set ref 248* 249*
block_ptr                       000212 automatic       pointer                  dcl 961 set ref 278* 285 287* 287
block_size                0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 1060
                                                                                  set ref 279* 286* 286 399 890
blocks                          000000 constant        fixed bin(17,0)          initial level 2 in structure "chunk_size" dcl 967
                                                                                  in procedure "gsp" ref 494 964
blocks                          000003 constant        fixed bin(21,0)          initial level 2 in structure "sysout_chunk" dcl 1041
                                                                                  in procedure "gsp" ref 401
buff_ptr                        000216 automatic       pointer                  array dcl 964 set ref 495* 696 779
buffer                          000214 automatic       char                     packed unaligned dcl 962 set ref 373* 395 398 487
                                                                                  702 783
buffer_ptr                             parameter       pointer                  dcl 833 in procedure "read_stream" set ref 820 846*
buffer_ptr                             parameter       pointer                  dcl 932 in procedure "write_stream" set ref 928 940*
buffp                           000214 automatic       pointer                  dcl 963 set ref 275 275 278 279 286 286 306* 309
                                                                                  379* 399 487* 489 490 495 669* 688* 696* 702* 704*
                                                                                  768* 779* 783* 785* 811 890 890 894* 898* 912 912
ceil                                                   builtin function         dcl 965 ref 869
char1                                  based           bit(9)                   packed unaligned dcl 966 ref 904
chars                     2     000003 constant        fixed bin(21,0)          initial level 2 in structure "sysout_chunk" dcl 1041
                                                                                  in procedure "gsp" ref 379
chars                     2     000000 constant        fixed bin(17,0)          initial level 2 in structure "chunk_size" dcl 967
                                                                                  in procedure "gsp" ref 688 704 768 785 962
chunk_size                      000000 constant        structure                level 1 dcl 967
cleanup                         000216 stack reference condition                dcl 971 ref 188
code                            000224 automatic       fixed bin(35,0)          dcl 972 set ref 202 207 209* 217 249* 255 255 259*
                                                                                  265* 304 307 309* 319* 331* 332* 333* 351* 353
                                                                                  359* 368 383 388 388* 390* 543* 555* 558 560* 569*
                                                                                  570* 577 579* 595 597* 610* 621 623* 636 638* 652*
                                                                                  659* 669 671 682 684* 693 695 700 729 734 741 773
                                                                                  773* 800 846* 852 852 856* 859 863* 879* 880 880*
                                                                                  910 912* 940*
com_err_                        000012 constant        entry                    external dcl 973 ref 194 209 359 390 560 570 579 597
                                                                                  610 623 638 676 684 773 880 912
conv_count                      000225 automatic       fixed bin(17,0)          dcl 974 set ref 894* 898* 903
cu_$arg_count                   000014 constant        entry                    external dcl 975 ref 191
cu_$arg_list_ptr                000020 constant        entry                    external dcl 977 ref 200
cu_$arg_ptr_rel                 000016 constant        entry                    external dcl 976 ref 555
current_rept_code               000336 automatic       fixed bin(6,0)           packed unsigned unaligned dcl 1022 set ref 283 437
                                                                                  437 455* 457 459* 464 505* 512* 725* 743 745 757
data                      1            based           char(1276)               level 2 packed packed unaligned dcl 1060 set ref 278
dir_name                               parameter       char                     packed unaligned dcl 346 set ref 340 351* 355
divide                                                 builtin function         dcl 978 ref 869
done                            000226 automatic       bit(1)                   array packed unaligned dcl 979 set ref 437 457 464
                                                                                  528 724* 731* 743 745 757*
dummy                           001542 automatic       fixed bin(21,0)          dcl 1066 set ref 306* 379* 669* 688* 704* 736* 768*
                                                                                  785*
e_name                                 parameter       char                     packed unaligned dcl 347 set ref 340 351* 355
encountered                     000230 automatic       bit(1)                   array packed unaligned dcl 980 set ref 436* 458* 528
                                                                                  724* 727*
eofsw                           000232 automatic       bit(1)                   packed unaligned dcl 983 set ref 383 693 773 776
                                                                                  840* 845* 855*
er_offset                 2            based           fixed bin(17,0)          level 2 dcl 1054 ref 674 681
error_table_$bad_file           000024 external static fixed bin(35,0)          dcl 984 ref 309
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 984 ref 569 659
error_table_$end_of_info        000026 external static fixed bin(35,0)          dcl 984 ref 388 852
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 984 set ref 194*
error_table_$noentry            000032 external static fixed bin(35,0)          dcl 984 ref 255
error_table_$short_record       000034 external static fixed bin(35,0)          dcl 984 ref 859
expand_pathname_                000036 constant        entry                    external dcl 993 ref 351
file_index                      000234 automatic       fixed bin(17,0)          initial dcl 995 set ref 995*
file_position                          parameter       fixed bin(21,0)          dcl 541 ref 538 543
file_ptr                               parameter       pointer                  dcl 540 set ref 538 543*
filesw                          000233 automatic       bit(1)                   initial packed unaligned dcl 994 set ref 605* 994*
first_record                           based           structure                level 1 dcl 1054
found                           000235 automatic       bit(1)                   packed unaligned dcl 996 set ref 431* 437* 748
gcos_sys_xlate_                 000040 constant        entry                    external dcl 997 ref 898
gcos_sys_xlate_lc_              000042 constant        entry                    external dcl 998 ref 894
how_many                               parameter       fixed bin(21,0)          dcl 834 set ref 820 846*
in_dir                          000236 automatic       char(168)                packed unaligned dcl 1000 set ref 483* 567*
in_ent                          000310 automatic       char(32)                 packed unaligned dcl 1001 set ref 483* 567*
in_path                                parameter       char                     packed unaligned dcl 349 set ref 340 351* 359*
in_ptr                          000320 automatic       pointer                  dcl 1002 set ref 303* 306* 367* 379* 473* 485* 576*
                                                                                  668* 669* 681* 688* 704* 732* 736* 767* 768* 785*
                                                                                  803*
in_record                              based           char                     packed unaligned dcl 1003 ref 285
in_stream                       000322 automatic       char(32)                 packed unaligned dcl 1004 set ref 566* 576* 579*
                                                                                  773*
index                                                  builtin function         dcl 999 ref 395 398
ioa_$ioa_switch                 000044 constant        entry                    external dcl 1005 ref 505 512
iocb_ptr                               parameter       pointer                  dcl 327 in procedure "detach_stream" set ref 325 329
                                                                                  331* 332* 333*
iocb_ptr                               parameter       pointer                  dcl 833 in procedure "read_stream" set ref 820 846*
iocb_ptr                               parameter       pointer                  dcl 932 in procedure "write_stream" ref 928 936 938
iocb_ptr                               parameter       pointer                  dcl 877 in procedure "rewind_file" set ref 875 879*
iocb_ptr                               parameter       pointer                  dcl 236 in procedure "attach_stream" set ref 232
                                                                                  249* 265*
iox_$attach_name                000060 constant        entry                    external dcl 1005 ref 249
iox_$close                      000056 constant        entry                    external dcl 1005 ref 331
iox_$destroy_iocb               000064 constant        entry                    external dcl 1005 ref 333
iox_$detach_iocb                000062 constant        entry                    external dcl 1005 ref 332
iox_$get_chars                  000050 constant        entry                    external dcl 1005 ref 846
iox_$open                       000054 constant        entry                    external dcl 1005 ref 265
iox_$position                   000046 constant        entry                    external dcl 1005 ref 543 879
iox_$put_chars                  000052 constant        entry                    external dcl 1005 ref 940
iox_$user_output                000066 external static pointer                  dcl 1005 set ref 505* 936
j                               000332 automatic       fixed bin(21,0)          dcl 1017 set ref 903* 904 908
jobs_snumb                3            based           char(5)                  level 2 dcl 1054 ref 673
lc_switch                       000333 automatic       bit(1)                   initial dcl 1018 set ref 653* 894 1018*
match                           002454 automatic       bit(1)                   packed unaligned dcl 533 set ref 526* 527 528* 531
mode                                   parameter       char(2)                  packed unaligned dcl 238 ref 232 261
more_actys                      000334 automatic       bit(1)                   packed unaligned dcl 1019 set ref 374* 375 404*
n                                      parameter       fixed bin(17,0)          dcl 348 set ref 340 359 359*
nargs                           000335 automatic       fixed bin(17,0)          dcl 1020 set ref 191* 192 553
null                                                   builtin function         dcl 1021 ref 249 329 485 505 936
open_mode                       002346 automatic       fixed bin(17,0)          dcl 240 set ref 261* 263* 265*
out1                                   based           char(1)                  array packed unaligned dcl 1023 set ref 904 904
out_dir                         001360 automatic       char(168)                packed unaligned dcl 1028 set ref 483* 608*
out_ent                         001432 automatic       char(32)                 packed unaligned dcl 1029 set ref 483* 608*
out_ptr                         001442 automatic       pointer                  dcl 1030 set ref 474* 485* 505 512* 616* 904* 908*
out_record                             based           char                     packed unaligned dcl 1031 set ref 285*
out_stream                      001444 automatic       char(32)                 packed unaligned dcl 1032 set ref 484* 606* 616*
                                                                                  623*
outbuf                          000337 automatic       char(2100)               packed unaligned dcl 1024 set ref 488
outbufp                         001354 automatic       pointer                  dcl 1025 set ref 488* 894* 898* 904 904 904 908*
output_block_count              001356 automatic       fixed bin(17,0)          dcl 1026 set ref 695 778 869*
output_record_count             001357 automatic       fixed bin(17,0)          dcl 1027 set ref 491* 902* 902 904
pathname                               parameter       char(168)                packed unaligned dcl 237 ref 232 248
ptr_index                       001454 automatic       fixed bin(17,0)          dcl 1033 set ref 494* 495 495* 695* 696* 778* 779*
qty_got                                parameter       fixed bin(21,0)          dcl 834 set ref 820 846* 869
qty_sent                               parameter       fixed bin(21,0)          dcl 932 set ref 928 940*
real_path                       001470 automatic       char(168)                packed unaligned dcl 1047 set ref 209* 355* 576*
                                                                                  579* 616* 623*
rec1                      1            based           char(4)                  level 2 dcl 1054 ref 312
rec_count                       001455 automatic       fixed bin(35,0)          dcl 1034 set ref 280* 281 290* 290 430* 434 440* 440
                                                                                  453* 457 460* 460
recbuffp                        001456 automatic       pointer                  dcl 1035 set ref 489*
recordp                         001460 automatic       pointer                  dcl 1036 set ref 312 490* 673 674 681
rept_index                      001462 automatic       fixed bin(35,0)          dcl 1037 set ref 734*
rtrim                                                  builtin function         dcl 1038 ref 355 355
short_switch                    000010 internal static bit(1)                   initial packed unaligned dcl 836 set ref 838 841*
                                                                                  864*
snumb                           001464 automatic       char(5)                  initial packed unaligned dcl 1039 set ref 505* 512*
                                                                                  673* 1039*
stream_in                              constant        fixed bin(17,0)          initial dcl 242 ref 261
stream_io                              constant        fixed bin(17,0)          initial dcl 242 ref 263
stream_name                            parameter       char                     packed unaligned dcl 235 set ref 232 249*
stream_ptr                      002572 automatic       pointer                  dcl 930 set ref 936* 938* 940*
substr                                                 builtin function         dcl 1040 ref 592
sysout_chunk                    000003 constant        structure                level 1 unaligned dcl 1041
sysout_sw                       001466 automatic       bit(1)                   dcl 1045 set ref 213 312* 314* 486*
temp_sw                         001467 automatic       bit(1)                   initial dcl 1046 set ref 631 631* 656* 1046*
test_index                      002455 automatic       fixed bin(17,0)          dcl 534 set ref 527* 528 528*
unspec                                                 builtin function         dcl 1049 set ref 373*

NAMES DECLARED BY EXPLICIT CONTEXT.
abnormal_exit                   000545 constant        label                    dcl 224 ref 188 202 210 219
attach_stream                   000551 constant        entry                    internal dcl 232 ref 576 616
build_block                     000674 constant        entry                    internal dcl 273 ref 750
check_file                      000772 constant        entry                    internal dcl 298 ref 205
detach_stream                   001030 constant        entry                    internal dcl 325 ref 473 474
exit_p_a                        002610 constant        label                    dcl 644 ref 561 573 582 600 613 626 639
expand_path                     001074 constant        entry                    internal dcl 340 ref 567 608
find_activities                 001313 constant        entry                    internal dcl 365 ref 802
find_current_rept_code          001453 constant        entry                    internal dcl 421 ref 747
find_next_rept_code             001524 constant        entry                    internal dcl 448 ref 743
fixup_before_dying              001576 constant        entry                    internal dcl 471 ref 226
gcos_sysprint                   000406 constant        entry                    external dcl 11
gsp                             000376 constant        entry                    external dcl 11
init_routine                    001604 constant        entry                    internal dcl 480 ref 199
make_rept_code_banner           001675 constant        entry                    internal dcl 502 ref 464
more_reports_in_acty            001774 constant        entry                    internal dcl 522 ref 729
normal_exit                     000544 constant        label                    dcl 222 ref 217
position_file                   002031 constant        entry                    internal dcl 538 ref 681 732
process_args                    002056 constant        entry                    internal dcl 549 ref 201
process_ctl_arg                 002612 constant        entry                    internal dcl 650 ref 594 635
process_ex_rept                 002650 constant        entry                    internal dcl 665 ref 799
process_rept_codes              003017 constant        entry                    internal dcl 718 ref 812
process_simple_file             003155 constant        entry                    internal dcl 765 ref 215
process_sysout_file             003254 constant        entry                    internal dcl 797 ref 213
quick_exit                      000547 constant        label                    dcl 228 ref 197
read_stream                     003302 constant        entry                    internal dcl 820 ref 306 379 669 688 704 736 768 785
rewind_file                     003356 constant        entry                    internal dcl 875 ref 303 367 668 767 803
write_line                      003432 constant        entry                    internal dcl 888 ref 697 751 780
write_stream                    003565 constant        entry                    internal dcl 928 ref 904 908

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4324        4414    4036        4334
Length      4660    4036        70         230     265           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gsp                                1836 external procedure  is an external procedure.  
on unit on line 188                  64 on unit               
attach_stream                           internal procedure  shares stack frame of external procedure gsp.  
build_block                             internal procedure  shares stack frame of external procedure gsp.  
check_file                              internal procedure  shares stack frame of external procedure gsp.  
detach_stream                           internal procedure  shares stack frame of external procedure gsp.  
expand_path                             internal procedure  shares stack frame of external procedure gsp.  
find_activities                         internal procedure  shares stack frame of external procedure gsp.  
find_current_rept_code                  internal procedure  shares stack frame of external procedure gsp.  
find_next_rept_code                     internal procedure  shares stack frame of external procedure gsp.  
fixup_before_dying                      internal procedure  shares stack frame of external procedure gsp.  
init_routine                            internal procedure  shares stack frame of external procedure gsp.  
make_rept_code_banner                   internal procedure  shares stack frame of external procedure gsp.  
more_reports_in_acty                    internal procedure  shares stack frame of external procedure gsp.  
position_file                           internal procedure  shares stack frame of external procedure gsp.  
process_args                            internal procedure  shares stack frame of external procedure gsp.  
process_ctl_arg                         internal procedure  shares stack frame of external procedure gsp.  
process_ex_rept                         internal procedure  shares stack frame of external procedure gsp.  
process_rept_codes                      internal procedure  shares stack frame of external procedure gsp.  
process_simple_file                     internal procedure  shares stack frame of external procedure gsp.  
process_sysout_file                     internal procedure  shares stack frame of external procedure gsp.  
read_stream                             internal procedure  shares stack frame of external procedure gsp.  
rewind_file                             internal procedure  shares stack frame of external procedure gsp.  
write_line                              internal procedure  shares stack frame of external procedure gsp.  
write_stream                            internal procedure  shares stack frame of external procedure gsp.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 short_switch                read_stream

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
gsp                      000100 acty_table                  gsp
                         000200 acty_index                  gsp
                         000201 acty_count                  gsp
                         000202 acty_offset                 gsp
                         000203 argl                        gsp
                         000204 argno                       gsp
                         000206 argp                        gsp
                         000210 arglistp                    gsp
                         000212 block_ptr                   gsp
                         000214 buffer                      gsp
                         000214 buffp                       gsp
                         000216 buff_ptr                    gsp
                         000224 code                        gsp
                         000225 conv_count                  gsp
                         000226 done                        gsp
                         000230 encountered                 gsp
                         000232 eofsw                       gsp
                         000233 filesw                      gsp
                         000234 file_index                  gsp
                         000235 found                       gsp
                         000236 in_dir                      gsp
                         000310 in_ent                      gsp
                         000320 in_ptr                      gsp
                         000322 in_stream                   gsp
                         000332 j                           gsp
                         000333 lc_switch                   gsp
                         000334 more_actys                  gsp
                         000335 nargs                       gsp
                         000336 current_rept_code           gsp
                         000337 outbuf                      gsp
                         001354 outbufp                     gsp
                         001356 output_block_count          gsp
                         001357 output_record_count         gsp
                         001360 out_dir                     gsp
                         001432 out_ent                     gsp
                         001442 out_ptr                     gsp
                         001444 out_stream                  gsp
                         001454 ptr_index                   gsp
                         001455 rec_count                   gsp
                         001456 recbuffp                    gsp
                         001460 recordp                     gsp
                         001462 rept_index                  gsp
                         001464 snumb                       gsp
                         001466 sysout_sw                   gsp
                         001467 temp_sw                     gsp
                         001470 real_path                   gsp
                         001542 dummy                       gsp
                         001544 RECORD_PTR                  gsp
                         001546 BLOCK                       gsp
                         002264 attach_descr                attach_stream
                         002346 open_mode                   attach_stream
                         002454 match                       more_reports_in_acty
                         002455 test_index                  more_reports_in_acty
                         002572 stream_ptr                  write_stream

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
return_mac          tra_ext_1           alloc_auto_adj      enable_op           shorten_stack       ext_entry
int_entry           set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel
expand_pathname_              gcos_sys_xlate_               gcos_sys_xlate_lc_            ioa_$ioa_switch
iox_$attach_name              iox_$close                    iox_$destroy_iocb             iox_$detach_iocb
iox_$get_chars                iox_$open                     iox_$position                 iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_file         error_table_$badopt           error_table_$end_of_info      error_table_$noarg
error_table_$noentry          error_table_$short_record     iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    962 000346       964 000355       994 000364       995 000365      1018 000367      1039 000370      1046 000372
     11 000375       188 000414       191 000433       192 000442       194 000444       197 000465       199 000466
    200 000467       201 000476       202 000477       205 000501       207 000502       209 000504       210 000533
    213 000534       215 000540       217 000541       219 000543       222 000544       224 000545       226 000546
    228 000547       230 000550       232 000551       248 000562       249 000577       255 000633       259 000640
    261 000641       263 000652       265 000654       269 000673       273 000674       275 000675       277 000703
    278 000705       279 000710       280 000713       281 000714       283 000720       285 000727       286 000742
    287 000750       290 000753       291 000763       292 000770       294 000771       298 000772       303 000773
    304 000775       306 000777       307 001003       309 001005       312 001015       314 001024       317 001025
    319 001026       321 001027       325 001030       329 001032       331 001036       332 001047       333 001061
    336 001073       340 001074       351 001117       353 001146       355 001150       356 001227       359 001235
    360 001305       365 001313       367 001314       368 001316       370 001320       371 001321       372 001323
    373 001325       374 001333       375 001335       376 001340       377 001342       378 001343       379 001346
    383 001352       388 001356       390 001363       393 001407       395 001410       396 001417       398 001420
    399 001427       401 001435       402 001442       404 001443       407 001444       409 001445       411 001446
    413 001447       417 001452       421 001453       430 001454       431 001455       432 001456       434 001460
    436 001464       437 001471       440 001505       441 001515       442 001522       444 001523       448 001524
    453 001525       454 001526       455 001530       457 001532       458 001545       459 001552       460 001554
    461 001564       462 001571       464 001572       467 001575       471 001576       473 001577       474 001601
    476 001603       480 001604       483 001605       484 001621       485 001624       486 001627       487 001630
    488 001632       489 001634       490 001637       491 001642       492 001643       494 001654       495 001663
    496 001672       498 001674       502 001675       505 001676       512 001737       518 001773       522 001774
    526 001776       527 001777       528 002005       529 002021       531 002023       538 002031       543 002033
    545 002055       549 002056       553 002057       555 002067       558 002106       560 002110       561 002142
    564 002143       566 002146       567 002151       569 002207       570 002212       573 002253       576 002254
    577 002261       579 002263       582 002317       585 002320       589 002321       592 002323       594 002330
    595 002331       597 002333       600 002375       602 002376       605 002377       606 002401       608 002404
    610 002442       613 002504       616 002505       621 002512       623 002514       626 002550       629 002551
    631 002552       635 002556       636 002557       638 002561       639 002605       642 002606       644 002610
    646 002611       650 002612       652 002613       653 002614       656 002631       659 002644       661 002647
    665 002650       667 002651       668 002652       669 002654       671 002662       673 002664       674 002671
    676 002673       678 002720       681 002721       682 002724       684 002726       686 002752       688 002753
    693 002757       695 002764       696 002775       697 003002       698 003003       700 003005       702 003007
    704 003011       709 003015       714 003016       718 003017       722 003020       724 003025       725 003052
    727 003054       729 003056       731 003067       732 003071       734 003075       736 003107       741 003115
    743 003117       745 003126       747 003134       748 003135       750 003137       751 003140       755 003141
    757 003146       759 003153       761 003154       765 003155       767 003156       768 003160       773 003164
    776 003224       778 003226       779 003235       780 003241       781 003242       783 003244       785 003246
    790 003252       793 003253       797 003254       799 003255       800 003256       802 003260       803 003261
    804 003263       810 003264       811 003273       812 003276       813 003277       816 003301       820 003302
    838 003304       840 003307       841 003311       842 003312       845 003313       846 003314       852 003333
    855 003340       856 003342       857 003343       859 003344       863 003346       864 003347       869 003351
    871 003355       875 003356       879 003360       880 003400       884 003431       888 003432       890 003433
    894 003441       898 003457       902 003472       903 003473       904 003475       908 003517       910 003523
    912 003525       924 003564       928 003565       936 003567       938 003600       940 003603       942 003621


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
