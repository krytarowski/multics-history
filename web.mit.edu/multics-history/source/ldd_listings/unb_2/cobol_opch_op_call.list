	COMPILATION LISTING OF SEGMENT cobol_opch_op_call
	Compiled by: Multics PL/I Compiler, Release 31b, of April 24, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 05/24/89  0942.5 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
       17*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
       18*     MCR8060 cobol_opch_op_call.pl1 Added Trace statements.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 /* Modified on 10/19/84 by FCH, [4.3-1], BUG563(phx18381), new cobol_addr_tokens.incl.pl1 */
       23 /* Modified on 08/15/83 by FCH, [5.2 ...], trace added */
       24 /* Renamed on 01/17/77 by ORN from cobol_opch_operator_call to cobol_opch_op_call */
       25 /* Modified since Version 2.0 */
       26 
       27 /*{*/
       28 /* format: style3 */
       29 cobol_opch_op_call:
       30      proc (sf_ptr, rf_ptr);
       31 
       32 /*
       33*This procedure generates code that "calls" the overpunch
       34*conversion "cobol operator".  The "call" to the overpunch conversion
       35*operator is effected by a tsp3 instruction.  Data is passed
       36*to the conversion routine in hardware registers, and not in a
       37*parameter list.  The data is passed as follows:
       38*
       39*1. pr1 points to the target of the conversion.
       40*
       41*2. pr2 points to the source of the conversion.
       42*
       43*3. pr5 points to a block of work space, at the top of the
       44*stack.  This work space must be aligned on a double word
       45*boundary.
       46*
       47*4. Q register contains the scale and precision of the source of
       48*conversion.
       49*
       50*	a. bits 0-17 of the Q register contains the scale.
       51*	Scale is obtained from data_name.places_right of a
       52*	data name token.
       53*
       54*	b. Bits 18-36 of the Q contain precision.
       55*	Precision is obtained from data_name.item_length of a
       56*	data name token.
       57*
       58*5. A register contains the scale and precision of the target
       59*of conversion.  Bits 0-17 contain the scale,
       60*bits 18-36 contain the precision.  Scale and precision are obtained
       61*as for the source of conversion.
       62*
       63*6. X7 contains a code that identifies the data type of the
       64*source of conversion.  This code is defined in the following
       65*table:
       66*
       67*	x7 contents	| type of source
       68*	__________________________________________
       69*	     1		| overpunch,leading sign
       70*	     2		| overpunch, trailing sign
       71*	     3		| unpacked decimal, trailing sign
       72*
       73*7. X6 contains a code that identifies the data type of the
       74*target of conversion.  This code is the same as that described
       75*above for X7.
       76*
       77*8. pr3 is used to store the location to which the cobol
       78*overpunch conversion operator is to reutrn.
       79*
       80**/
       81 
       82 /*  DECLARATION OF THE PARAMETERS  */
       83 
       84 dcl	sf_ptr		ptr;
       85 
       86 dcl	rf_ptr		ptr;
       87 
       88 /*  DESCRIPTION OF THE PARAMETERS>  */
       89 
       90 /*
       91*PARAMETER		DESCRIPTION
       92*
       93*sf_ptr		Pointer to a data name token that describes
       94*		the source of the conversion.  This token
       95*		will ALWAYS describe  an unpacked
       96*		decimal trailing sign data item, or an
       97*		overpunch sign data item.
       98*
       99*rf_ptr		Pointer to a data name token that describes
      100*		the target of the conversion.  This token
      101*		describes the same type of data items as
      102*		sf_ptr.  (see above).  (input)
      103*
      104**/
      105 
      106 /*  DECLARATION OF EXXTERNAL ENTRIES  */
      107 
      108 dcl	cobol_register$load ext entry (ptr);
      109 dcl	cobol_pointer_register$get
      110 			ext entry (ptr);
      111 dcl	cobol_set_pr	ext entry (ptr, ptr);
      112 dcl	cobol_alloc$stack	ext entry (fixed bin, fixed bin, fixed bin);
      113 dcl	cobol_emit	ext entry (ptr, ptr, fixed bin);
      114 dcl	cobol_pool	ext entry (char (*), fixed bin, fixed bin (24));
      115 dcl	cobol_make_link$type_4
      116 			ext entry (fixed bin, char (*));
      117 dcl	cobol_addr	ext entry (ptr, ptr, ptr);
      118 dcl	cobol_reset_r$after_operator
      119 			ext entry;
      120 dcl	cobol_reg_manager$before_op
      121 			entry (fixed bin);
      122 
      123 /*}*/
      124 
      125 /*  DECLARATIONS OF INTERNAL STATIC DATA  */
      126 
      127 dcl	ldx7_inst		bit (36) int static init ("000000000000000000010010111000000011"b);
      128 						/* ldx7  0,du  */
      129 
      130 dcl	ldx6_inst		bit (36) int static init ("000000000000000000010010110000000011"b);
      131 						/*  ldx6 0,du  */
      132 
      133 dcl	ldq_inst		bit (36) int static init ("000000000000000000010011110000000000"b);
      134 						/*  LDQ 0  */
      135 
      136 dcl	lda_inst		bit (36) int static init ("000000000000000000010011101000000000"b);
      137 						/*  LDA 0  */
      138 
      139 dcl	tsp3_inst		bit (36) int static init ("000000000000000111010111011001000000"b);
      140 						/* tsp3 pr0|7 */
      141 
      142 dcl	epp5_inst		bit (36) int static init ("000000000000000000011111001101000000"b);
      143 						/*  epp5  */
      144 						/*  DECLARATION OF INTERNAL DATA  */
      145 
      146 dcl	1 reg_load_struc,
      147 	  2 what_reg	fixed bin,
      148 	  2 reg_no	bit (4),
      149 	  2 lock		fixed bin,
      150 	  2 already_there	fixed bin,
      151 	  2 contains	fixed bin,
      152 	  2 wk_ptr	ptr,
      153 	  2 literal	bit (36);
      154 
      155 dcl	1 pointer_reg_struc,
      156 	  2 what_pointer	fixed bin,
      157 	  2 pointer_no	bit (3),
      158 	  2 lock		fixed bin,
      159 	  2 switch	fixed bin,
      160 	  2 segno		fixed bin,
      161 	  2 offset	fixed bin (24),
      162 	  2 reset		fixed bin;
      163 
      164 
      165 	/***.....	dcl cobol_gen_driver_$Tr_Beg entry(char(*));/**/
      166 	/***.....	dcl cobol_gen_driver_$Tr_End entry(char(*));/**/
      167 
      168 	/***.....	dcl Trace_Bit bit(1) static external;/**/
      169 	/***.....	dcl Trace_Lev fixed bin static external;/**/
      170 	/***.....	dcl Trace_Line char(36) static external;/**/
      171 	/***.....	dcl ioa_ entry options(variable); /**/
      172 	/***..... dcl MY_NAME char (18) int static init ("COBOL_OPCH_OP_CALL");/**/
      173 
      174 
      175 dcl	precision_constant_ptr
      176 			ptr;
      177 
      178 dcl	1 precision	aligned,
      179 	  2 scale		fixed bin (17) unaligned,
      180 	  2 precision	fixed bin (17) unaligned;
      181 dcl	precision_offset	fixed bin (24);
      182 dcl	precision_char_constant
      183 			char (4) based (precision_constant_ptr);
      184 
      185 dcl	input_buffer	(1:10) ptr;
      186 dcl	reloc_buffer	(1:10) bit (5);
      187 dcl	inst_buffer	(1:10) ptr;
      188 
      189 dcl	linkoff		fixed bin;
      190 
      191 dcl	ret_offset	fixed bin;
      192 dcl	tcode		fixed bin;
      193 
      194 dcl	inst_word		(1:2) bit (36) init ("0"b, "0"b);
      195 
      196 
      197 
      198 dcl	1 treloc_buffer	(1:2) aligned,
      199 	  2 reloc1	bit (5) aligned,
      200 	  2 reloc2	bit (5) aligned;
      201 
      202 dcl	dn_ptr		ptr;
      203 
      204 
      205 /**************************************************/
      206 start:	/***.....	if Trace_Bit then call cobol_gen_driver_$Tr_Beg(MY_NAME);/**/
      207 						/*  Store all locked registers, before generating any code to call the overpunch operator.  */
      208 	call cobol_reg_manager$before_op (0);
      209 
      210 	pointer_reg_struc.lock = 1;
      211 	pointer_reg_struc.switch = 0;
      212 
      213 /*  Load the pointer registers  */
      214 
      215 /*  Load pr2 to point to the source of conversion.  */
      216 
      217 	pointer_reg_struc.what_pointer = 2;
      218 	call cobol_set_pr (addr (pointer_reg_struc), sf_ptr);
      219 
      220 /*  Load pr1 to point to the target.  */
      221 
      222 	pointer_reg_struc.what_pointer = 1;
      223 	call cobol_set_pr (addr (pointer_reg_struc), rf_ptr);
      224 
      225 
      226 /*  Allocate some work space on an even word boundary   */
      227 	call cobol_alloc$stack (40, 2, ret_offset);
      228 
      229 
      230 /*  First, must get and lock the index registers needed to pass data to the operator.  */
      231 	reg_load_struc.lock = 1;			/*  lock it  */
      232 	reg_load_struc.contains = 0;
      233 
      234 /*  Get x6  */
      235 	reg_load_struc.what_reg = 16;			/*  x6  */
      236 	call cobol_register$load (addr (reg_load_struc));
      237 
      238 /*  Get x7  */
      239 	reg_load_struc.what_reg = 17;
      240 	call cobol_register$load (addr (reg_load_struc));
      241 
      242 /*  Load x7 with a code that identifies the source type  */
      243 	if sf_ptr -> data_name.sign_type = "010"b	/*  leading, not separate  */
      244 	then tcode = 1;
      245 	else if sf_ptr -> data_name.sign_type = "001"b	/*  trailing, not separate  */
      246 	then tcode = 2;
      247 	else if (sf_ptr -> data_name.item_signed & sf_ptr -> data_name.sign_separate = "0"b)
      248 	then tcode = 2;				/*  Default is trailing overpunch.  */
      249 	else tcode = 3;				/*  ASSUME unpacked decimal, trailing sign  */
      250 
      251 	inst_ptr = addr (ldx7_inst);
      252 	inst_struc_basic.wd_offset = bit (fixed (tcode, 15));
      253 	call cobol_emit (inst_ptr, null (), 1);
      254 
      255 /*  Load x6 with a code that identifies the target of conversion.  */
      256 
      257 	if rf_ptr -> data_name.sign_type = "010"b	/*  leading, not separate  */
      258 	then tcode = 1;
      259 	else if rf_ptr -> data_name.sign_type = "001"b	/*  trailing, not separate  */
      260 	then tcode = 2;
      261 	else if (rf_ptr -> data_name.item_signed & rf_ptr -> data_name.sign_separate = "0"b)
      262 	then tcode = 2;				/*  Default is trailing overpunch.  */
      263 	else tcode = 3;				/*  ASSUME unpacked, decimal, trailing sign  */
      264 
      265 	inst_ptr = addr (ldx6_inst);
      266 	inst_struc_basic.wd_offset = bit (fixed (tcode, 15));
      267 	call cobol_emit (inst_ptr, null (), 1);
      268 
      269 /*  Generate code to load the Q register with the scale and precision
      270*	of the source of conversion.  */
      271 /*  First, get and lock the A and Q registers.  */
      272 	reg_load_struc.what_reg = 3;			/*  A and Q  */
      273 	call cobol_register$load (addr (reg_load_struc));
      274 
      275 
      276 	precision_constant_ptr = addr (precision.scale);
      277 	precision.scale = sf_ptr -> data_name.places_right;
      278 
      279 	precision.precision = sf_ptr -> data_name.item_length;
      280 
      281 /*  Pool the constant that contains scale and precision.  */
      282 	call cobol_pool (precision_char_constant, 0,	/*word boundary, return char offset */
      283 	     precision_offset);
      284 
      285 	input_ptr = addr (input_buffer (1));
      286 	reloc_ptr = addr (reloc_buffer (1));
      287 	inst_ptr = addr (ldq_inst);
      288 
      289 /*  Set up the input structure to the addressability utility.  */
      290 	input_struc_basic.type = 1;
      291 	input_struc_basic.operand_no = 0;
      292 	input_struc_basic.lock = 0;
      293 	input_struc_basic.segno = 3000;		/*  constant section.  */
      294 	input_struc_basic.char_offset = precision_offset;
      295 	input_struc_basic.send_receive = 0;
      296 
      297 /*  Get the address of the pooled constant.  */
      298 	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      299 
      300 /*  Emit the LDQ instruction  */
      301 	call cobol_emit (inst_ptr, null (), 1);
      302 
      303 /*  Generate code to load the A register with the scale and precision of the target.  */
      304 
      305 	precision.scale = rf_ptr -> data_name.places_right;
      306 	precision.precision = rf_ptr -> data_name.item_length;
      307 
      308 /*  Pool the constant  */
      309 	call cobol_pool (precision_char_constant, 0, precision_offset);
      310 
      311 	input_struc_basic.char_offset = precision_offset;
      312 
      313 /*  Get the address of the constant to be loaded into the A register.  */
      314 	inst_ptr = addr (lda_inst);
      315 	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      316 
      317 /*  Emit the LDA instruction  */
      318 	call cobol_emit (inst_ptr, null (), 1);		/*  Emit code to load pr5 with the address of the work space.  */
      319 
      320 	substr (epp5_inst, 1, 3) = "110"b;		/* pr6 = stack  */
      321 	substr (epp5_inst, 4, 15) = bit (fixed (ret_offset, 15), 15);
      322 	call cobol_emit (addr (epp5_inst), null (), 1);
      323 
      324 /*  NOTE  pr3 and pr5 are used here, even though they are always supposed to point at cobol data.
      325*	However, these pointer registers are needed here to communicate with the cobol operator, and are loaded
      326*	to values other than pointers to cobol data immediately prior to calling the overpunch operator, so
      327*	no addressability to cobol data is lost.  Immediately upon returning from the operator, pointer
      328*	registers 3,4, and 5 are reloaded to their expected values.  */
      329 
      330 
      331 /*  Emit an instruction to transfer to the cobol overpunch operator  */
      332 	call cobol_emit (addr (tsp3_inst), null (), 1);
      333 
      334 /*  Reset all registers after the call to the cobol operator  */
      335 	call cobol_reset_r$after_operator;
      336 
      337 	/***.....	if Trace_Bit then call cobol_gen_driver_$Tr_End(MY_NAME);/**/
      338 
      339 
      340 
      341 /**************************************************/
      342 /*	INCLUDE FILES USED BY THIS PROCEDURE	*/
      343 /**************************************************/
      344 
      345 
      346 /*****	Declaration for builtin function	*****/
      347 
      348 dcl	(substr, mod, binary, fixed, addr, addrel, rel, length, string, unspec, null, index)
      349 			builtin;
      350 
      351 /*****	End of declaration for builtin function	*****/
      352 
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... cobol_type9.incl.pl1 */
  1     3 /* Last modified on 11/19/76 by ORN */
  1     4 
  1     5 /*
  1     6*A type 9 data name token is entered into the name table by the data
  1     7*division syntax phase for each data name described in the data division.
  1     8*The replacement phase subsequently replaces type 8 user word references
  1     9*to data names in the procedure division minpral file with the corresponding
  1    10*type 9 tokens from the name table.
  1    11**/
  1    12 
  1    13 /* dcl dn_ptr ptr; */
  1    14 
  1    15 /* BEGIN DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    16 dcl 1 data_name based (dn_ptr),
  2     1 
  2     2 /* begin include file ... cobol_TYPE9.incl.pl1 */
  2     3 /* Last modified on 06/19/77 by ORN */
  2     4 /* Last modified on 12/28/76 by FCH */
  2     5 
  2     6 		/* header */
  2     7 		2 size fixed bin,
  2     8 		2 line fixed bin,
  2     9 		2 column fixed bin,
  2    10 		2 type fixed bin,
  2    11 		/* body */
  2    12 		2 string_ptr ptr,
  2    13 		2 prev_rec ptr,
  2    14 		2 searched bit (1),
  2    15 		2 duplicate bit (1),
  2    16 		2 saved bit (1),
  2    17 		2 debug_ind bit (1),
  2    18 		2 filler2 bit (3),
  2    19 		2 used_as_sub bit (1),
  2    20 		2 def_line fixed bin,
  2    21 		2 level fixed bin,
  2    22 		2 linkage fixed bin,
  2    23 		2 file_num fixed bin,
  2    24 		2 size_rtn fixed bin,
  2    25 		2 item_length fixed bin(24),
  2    26 		2 places_left fixed bin,
  2    27 		2 places_right fixed bin,
  2    28 		/* description */
  2    29 		2 file_section bit (1),
  2    30 		2 working_storage bit (1),
  2    31 		2 constant_section bit (1),
  2    32 		2 linkage_section bit (1),
  2    33 		2 communication_section bit (1),
  2    34 		2 report_section bit (1),
  2    35 		2 level_77 bit (1),
  2    36 		2 level_01 bit (1),
  2    37 		2 non_elementary bit (1),
  2    38 		2 elementary bit (1),
  2    39 		2 filler_item bit (1),
  2    40 		2 s_of_rdf bit (1),
  2    41 		2 o_of_rdf bit (1),
  2    42 		2 bin_18 bit (1),
  2    43 		2 bin_36 bit (1),
  2    44 		2 pic_has_l bit (1),
  2    45 		2 pic_is_do bit (1),
  2    46 		2 numeric bit (1),
  2    47 		2 numeric_edited bit (1),
  2    48 		2 alphanum bit (1),
  2    49 		2 alphanum_edited bit (1),
  2    50 		2 alphabetic bit (1),
  2    51 		2 alphabetic_edited bit (1),
  2    52 		2 pic_has_p bit (1),
  2    53 		2 pic_has_ast bit (1),
  2    54 		2 item_signed bit(1),
  2    55 		2 sign_separate bit (1),
  2    56 		2 display bit (1),
  2    57 		2 comp bit (1),
  2    58 		2 ascii_packed_dec_h bit (1),	/* as of 8/16/76  this field used for comp8. */
  2    59 		2 ascii_packed_dec bit (1),
  2    60 		2 ebcdic_packed_dec bit (1),
  2    61 		2 bin_16 bit (1),
  2    62 		2 bin_32 bit (1),
  2    63 		2 usage_index bit (1),
  2    64 		2 just_right bit (1),
  2    65 		2 compare_argument bit (1),
  2    66 		2 sync bit (1),
  2    67 		2 temporary bit (1),
  2    68 		2 bwz bit (1),
  2    69 		2 variable_length bit (1),
  2    70 		2 subscripted bit (1),
  2    71 		2 occurs_do bit (1),
  2    72 		2 key_a bit (1),
  2    73 		2 key_d bit (1),
  2    74 		2 indexed_by bit (1),
  2    75 		2 value_numeric bit (1),
  2    76 		2 value_non_numeric bit (1),
  2    77 		2 value_signed bit (1),
  2    78 		2 sign_type bit (3),
  2    79 		2 pic_integer bit (1),
  2    80 		2 ast_when_zero bit (1),
  2    81 		2 label_record bit (1),
  2    82 		2 sign_clause_occurred bit (1),
  2    83 		2 okey_dn bit (1),
  2    84 		2 subject_of_keyis bit (1),
  2    85 		2 exp_redefining bit (1),
  2    86 		2 sync_in_rec bit (1),
  2    87 		2 rounded bit (1),
  2    88 		2 ad_bit bit (1),
  2    89 		2 debug_all bit (1),
  2    90 		2 overlap bit (1),
  2    91 		2 sum_counter bit (1),
  2    92 		2 exp_occurs bit (1),
  2    93 		2 linage_counter bit (1),
  2    94 		2 rnm_01 bit (1),
  2    95 		2 aligned bit (1),
  2    96 		2 not_user_writable bit (1),
  2    97 		2 database_key bit (1),
  2    98 		2 database_data_item bit (1),
  2    99 		2 seg_num fixed bin,
  2   100 		2 offset fixed bin(24),
  2   101 		2 initial_ptr fixed bin,
  2   102 		2 edit_ptr fixed bin,
  2   103 		2 occurs_ptr fixed bin,
  2   104 		2 do_rec char(5),
  2   105 		2 bitt bit (1),
  2   106 		2 byte bit (1),
  2   107 		2 half_word bit (1),
  2   108 		2 word bit (1),
  2   109 		2 double_word bit (1),
  2   110 		2 half_byte bit (1),
  2   111 		2 filler5 bit (1),
  2   112 		2 bit_offset bit (4),
  2   113 		2 son_cnt bit (16),
  2   114 		2 max_red_size fixed bin(24),
  2   115 		2 name_size fixed bin,
  2   116 		2 name char(0 refer(data_name.name_size));	
  2   117 
  2   118 
  2   119 
  2   120 /* end include file ... cobol_TYPE9.incl.pl1 */
  2   121 
  1    17 
  1    18 /* END DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    19 
  1    20 /* END INCLUDE FILE ... cobol_type9.incl.pl1 */
  1    21 
      353 
  3     1 
  3     2 /* BEGIN INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8058),
  3     7*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
  3     8*     MCR8058 cobol_addr_tokens.incl.pl1 Change array extents to refer to
  3     9*     constants rather than variables.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /* Last modified on 10/1/74 by tg */
  3    14 
  3    15 
  3    16 /* parameter list */
  3    17 
  3    18      dcl	   (input_ptr, inst_ptr, reloc_ptr) ptr;
  3    19 
  3    20 
  3    21 /* input_struc_basic is used for type 1 addressing */
  3    22 
  3    23      dcl	   1 input_struc_basic    based (input_ptr),
  3    24 	     2 type	      fixed bin,
  3    25 	     2 operand_no	      fixed bin,
  3    26 	     2 lock	      fixed bin,
  3    27 	     2 segno	      fixed bin,
  3    28 	     2 char_offset	      fixed bin (24),
  3    29 	     2 send_receive	      fixed bin;
  3    30 
  3    31 
  3    32      dcl	   1 input_struc	      based (input_ptr),
  3    33 	     2 type	      fixed bin,
  3    34 	     2 operand_no	      fixed bin,
  3    35 	     2 lock	      fixed bin,
  3    36 	     2 operand	      (0 refer (input_struc.operand_no)),
  3    37 	       3 token_ptr	      ptr,
  3    38 	       3 send_receive     fixed bin,
  3    39 	       3 ic_mod	      fixed bin,
  3    40 	       3 size_sw	      fixed bin;
  3    41 
  3    42 /* reloc_struc is used for all types of addressing * all types */
  3    43 
  3    44      dcl	   1 reloc_struc	      (input_struc.operand_no + 1) based (reloc_ptr),
  3    45 	     2 left_wd	      bit (5) aligned,
  3    46 	     2 right_wd	      bit (5) aligned;
  3    47 
  3    48 /* Instruction format for 1 word instruction */
  3    49 
  3    50 
  3    51      dcl	   1 inst_struc_basic     based (inst_ptr) aligned,
  3    52 	     2 y		      unaligned,
  3    53 	       3 pr	      bit (3) unaligned,
  3    54 	       3 wd_offset	      bit (15) unaligned,
  3    55 	     2 fill1_op	      bit (10) unaligned,
  3    56 	     2 zero1	      bit (1) unaligned,
  3    57 	     2 pr_spec	      bit (1) unaligned,
  3    58 	     2 tm		      bit (2) unaligned,
  3    59 	     2 td		      bit (4) unaligned;
  3    60 
  3    61 
  3    62 /* The detailed definitions of the fields in this structure
  3    63*   can be found in the GMAP manual section 8 */
  3    64 /* EIS instruction format for 2_4 word instructions */
  3    65 
  3    66      dcl	   1 inst_struc	      based (inst_ptr) aligned,
  3    67 	     2 inst	      unaligned,
  3    68 	       3 zero1	      bit (2) unaligned,
  3    69 	       3 mf3	      unaligned,
  3    70 	         4 pr_spec	      bit (1) unaligned,
  3    71 	         4 reg_or_length  bit (1) unaligned,
  3    72 	         4 zero2	      bit (1) unaligned,
  3    73 	         4 reg_mod	      bit (4) unaligned,
  3    74 	       3 zero3	      bit (2) unaligned,
  3    75 	       3 mf2	      unaligned,
  3    76 	         4 pr_spec	      bit (1) unaligned,
  3    77 	         4 reg_or_length  bit (1) unaligned,
  3    78 	         4 zero4	      bit (1) unaligned,
  3    79 	         4 reg_mod	      bit (4) unaligned,
  3    80 	       3 fill1_op	      bit (10) unaligned,
  3    81 	       3 zero5	      bit (1) unaligned,
  3    82 	       3 mf1	      unaligned,
  3    83 	         4 pr_spec	      bit (1) unaligned,
  3    84 	         4 reg_or_length  bit (1) unaligned,
  3    85 	         4 zero6	      bit (1) unaligned,
  3    86 	         4 reg_mod	      bit (4) unaligned,
  3    87 	     2 desc_ext	      unaligned,
  3    88 	       3 desc	      (512) unaligned,
  3    89 	         4 desc_od	      bit (36) unaligned;
  3    90 
  3    91 /* The detailed definitions of the fields in this structure
  3    92*   can be found in the GMAP manual section 8.
  3    93*   The desc_ext is the descriptor extension of this eis
  3    94*   instruction. The number of descriptors associated with
  3    95*   this instruction is equavalent to the operand number.
  3    96*   Depending on operand data type, the descriptor
  3    97*   can be alphanumeric or numeric.  The structures of the
  3    98*   alphanumeric and the numeric descriptors are defined
  3    99*   below. */
  3   100 
  3   101 /* alphanumeric descriptor format */
  3   102 
  3   103      dcl	   1 desc_an	      based (desc_an_ptr) unaligned,
  3   104 	     2 desc_f	      (512) unaligned,
  3   105 	       3 y	      unaligned,
  3   106 	         4 pr	      bit (3) unaligned,
  3   107 	         4 wd_offset      bit (15) unaligned,
  3   108 	       3 char_n	      bit (3) unaligned,
  3   109 	       3 zero1	      bit (1) unaligned,
  3   110 	       3 ta	      bit (2),
  3   111 	       3 n	      bit (12) unaligned;
  3   112 
  3   113 
  3   114 /* The detailed definitions of the fields in this structure can
  3   115*   be found in the GMAP manual section 8. */
  3   116 /* numeric descriptor format */
  3   117 
  3   118      dcl	   desc_nn_ptr	      ptr;
  3   119      dcl	   desc_an_ptr	      ptr;
  3   120 
  3   121 
  3   122      dcl	   1 desc_nn	      based (desc_nn_ptr) unaligned,
  3   123 	     2 desc_f	      (512) unaligned,
  3   124 	       3 y	      unaligned,
  3   125 	         4 pr	      bit (3) unaligned,
  3   126 	         4 wd_offset      bit (15) unaligned,
  3   127 	       3 digit_n	      bit (3) unaligned,
  3   128 	       3 tn	      bit (1) unaligned,
  3   129 	       3 sign_type	      bit (2) unaligned,
  3   130 	       3 scal	      bit (6) unaligned,
  3   131 	       3 n	      bit (6) unaligned;
  3   132 
  3   133 
  3   134 /* The detailed definitions of fields in this structure can
  3   135*   be found in the GMAP manual section 8. */
  3   136 /* END INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  3   137 
      354 
      355 
      356      end cobol_opch_op_call;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/24/89  0830.4  cobol_opch_op_call.pl1            >spec>install>MR12.3-1048>cobol_opch_op_call.pl1
353          1    03/27/82  0439.9  cobol_type9.incl.pl1              >ldd>include>cobol_type9.incl.pl1
1-17         2    11/11/82  1712.7  cobol_TYPE9.incl.pl1              >ldd>include>cobol_TYPE9.incl.pl1
354          3    05/24/89  0811.7  cobol_addr_tokens.incl.pl1        >spec>install>MR12.3-1048>cobol_addr_tokens.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 348 ref 218 218 223 223 236 236 240 240 251 265
                                                                                  273 273 276 285 286 287 314 322 322 332 332
char_offset               4            based           fixed bin(24,0)          level 2 dcl 3-23 set ref 294* 311*
cobol_addr                      000030 constant        entry                    external dcl 117 ref 298 315
cobol_alloc$stack               000022 constant        entry                    external dcl 112 ref 227
cobol_emit                      000024 constant        entry                    external dcl 113 ref 253 267 301 318 322 332
cobol_pool                      000026 constant        entry                    external dcl 114 ref 282 309
cobol_reg_manager$before_op     000034 constant        entry                    external dcl 120 ref 206
cobol_register$load             000016 constant        entry                    external dcl 108 ref 236 240 273
cobol_reset_r$after_operator    000032 constant        entry                    external dcl 118 ref 335
cobol_set_pr                    000020 constant        entry                    external dcl 111 ref 218 223
contains                  4     000100 automatic       fixed bin(17,0)          level 2 dcl 146 set ref 232*
data_name                              based           structure                level 1 unaligned dcl 1-16
epp5_inst                       000015 internal static bit(36)                  initial packed unaligned dcl 142 set ref 320* 321*
                                                                                  322 322
fixed                                                  builtin function         dcl 348 ref 252 266 321
input_buffer                    000124 automatic       pointer                  array dcl 185 set ref 285
input_ptr                       000156 automatic       pointer                  dcl 3-18 set ref 285* 290 291 292 293 294 295 298*
                                                                                  311 315*
input_struc_basic                      based           structure                level 1 unaligned dcl 3-23
inst_ptr                        000160 automatic       pointer                  dcl 3-18 set ref 251* 252 253* 265* 266 267* 287*
                                                                                  298* 301* 314* 315* 318*
inst_struc_basic                       based           structure                level 1 dcl 3-51
inst_word                       000154 automatic       bit(36)                  initial array packed unaligned dcl 194 set ref 194*
                                                                                  194*
item_length              16            based           fixed bin(24,0)          level 2 dcl 1-16 ref 279 306
item_signed              21(25)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 ref 247 261
lda_inst                        000013 internal static bit(36)                  initial packed unaligned dcl 136 set ref 314
ldq_inst                        000012 internal static bit(36)                  initial packed unaligned dcl 133 set ref 287
ldx6_inst                       000011 internal static bit(36)                  initial packed unaligned dcl 130 set ref 265
ldx7_inst                       000010 internal static bit(36)                  initial packed unaligned dcl 127 set ref 251
lock                      2            based           fixed bin(17,0)          level 2 in structure "input_struc_basic" dcl 3-23
                                                                                  in procedure "cobol_opch_op_call" set ref 292*
lock                      2     000100 automatic       fixed bin(17,0)          level 2 in structure "reg_load_struc" dcl 146
                                                                                  in procedure "cobol_opch_op_call" set ref 231*
lock                      2     000111 automatic       fixed bin(17,0)          level 2 in structure "pointer_reg_struc" dcl 155
                                                                                  in procedure "cobol_opch_op_call" set ref 210*
null                                                   builtin function         dcl 348 ref 253 253 267 267 301 301 318 318 322 322
                                                                                  332 332
operand_no                1            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 291*
places_right             20            based           fixed bin(17,0)          level 2 dcl 1-16 ref 277 305
pointer_reg_struc               000111 automatic       structure                level 1 unaligned dcl 155 set ref 218 218 223 223
precision                 0(18) 000122 automatic       fixed bin(17,0)          level 2 in structure "precision" packed packed
                                                                                  unaligned dcl 178 in procedure
                                                                                  "cobol_opch_op_call" set ref 279* 306*
precision                       000122 automatic       structure                level 1 dcl 178 in procedure "cobol_opch_op_call"
precision_char_constant                based           char(4)                  packed unaligned dcl 182 set ref 282* 309*
precision_constant_ptr          000120 automatic       pointer                  dcl 175 set ref 276* 282 309
precision_offset                000123 automatic       fixed bin(24,0)          dcl 181 set ref 282* 294 309* 311
reg_load_struc                  000100 automatic       structure                level 1 unaligned dcl 146 set ref 236 236 240 240
                                                                                  273 273
reloc_buffer                    000150 automatic       bit(5)                   array packed unaligned dcl 186 set ref 286
reloc_ptr                       000162 automatic       pointer                  dcl 3-18 set ref 286* 298* 315*
ret_offset                      000152 automatic       fixed bin(17,0)          dcl 191 set ref 227* 321
rf_ptr                                 parameter       pointer                  dcl 86 set ref 29 223* 257 259 261 261 305 306
scale                           000122 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 178 set ref 276
                                                                                  277* 305*
segno                     3            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 293*
send_receive              5            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 295*
sf_ptr                                 parameter       pointer                  dcl 84 set ref 29 218* 243 245 247 247 277 279
sign_separate            21(26)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 ref 247 261
sign_type                22(13)        based           bit(3)                   level 2 packed packed unaligned dcl 1-16 ref 243 245
                                                                                  257 259
substr                                                 builtin function         dcl 348 set ref 320* 321*
switch                    3     000111 automatic       fixed bin(17,0)          level 2 dcl 155 set ref 211*
tcode                           000153 automatic       fixed bin(17,0)          dcl 192 set ref 243* 245* 247* 249* 252 257* 259*
                                                                                  261* 263* 266
tsp3_inst                       000014 internal static bit(36)                  initial packed unaligned dcl 139 set ref 332 332
type                                   based           fixed bin(17,0)          level 2 dcl 3-23 set ref 290*
wd_offset                 0(03)        based           bit(15)                  level 3 packed packed unaligned dcl 3-51 set ref
                                                                                  252* 266*
what_pointer                    000111 automatic       fixed bin(17,0)          level 2 dcl 155 set ref 217* 222*
what_reg                        000100 automatic       fixed bin(17,0)          level 2 dcl 146 set ref 235* 239* 272*
y                                      based           structure                level 2 packed packed unaligned dcl 3-51

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addrel                                                 builtin function         dcl 348
binary                                                 builtin function         dcl 348
cobol_make_link$type_4          000000 constant        entry                    external dcl 115
cobol_pointer_register$get      000000 constant        entry                    external dcl 109
desc_an                                based           structure                level 1 packed packed unaligned dcl 3-103
desc_an_ptr                            automatic       pointer                  dcl 3-119
desc_nn                                based           structure                level 1 packed packed unaligned dcl 3-122
desc_nn_ptr                            automatic       pointer                  dcl 3-118
dn_ptr                                 automatic       pointer                  dcl 202
index                                                  builtin function         dcl 348
input_struc                            based           structure                level 1 unaligned dcl 3-32
inst_buffer                            automatic       pointer                  array dcl 187
inst_struc                             based           structure                level 1 dcl 3-66
length                                                 builtin function         dcl 348
linkoff                                automatic       fixed bin(17,0)          dcl 189
mod                                                    builtin function         dcl 348
rel                                                    builtin function         dcl 348
reloc_struc                            based           structure                array level 1 unaligned dcl 3-44
string                                                 builtin function         dcl 348
treloc_buffer                          automatic       structure                array level 1 dcl 198
unspec                                                 builtin function         dcl 348

NAMES DECLARED BY EXPLICIT CONTEXT.
cobol_opch_op_call              000012 constant        entry                    external dcl 29
start                           000026 constant        label                    dcl 206

NAME DECLARED BY CONTEXT OR IMPLICATION.
bit                                                    builtin function         ref 252 266 321

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       742        1000     613         752
Length      1246     613        36         231     126           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cobol_opch_op_call                  156 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ldx7_inst                   cobol_opch_op_call
000011 ldx6_inst                   cobol_opch_op_call
000012 ldq_inst                    cobol_opch_op_call
000013 lda_inst                    cobol_opch_op_call
000014 tsp3_inst                   cobol_opch_op_call
000015 epp5_inst                   cobol_opch_op_call

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cobol_opch_op_call       000100 reg_load_struc              cobol_opch_op_call
                         000111 pointer_reg_struc           cobol_opch_op_call
                         000120 precision_constant_ptr      cobol_opch_op_call
                         000122 precision                   cobol_opch_op_call
                         000123 precision_offset            cobol_opch_op_call
                         000124 input_buffer                cobol_opch_op_call
                         000150 reloc_buffer                cobol_opch_op_call
                         000152 ret_offset                  cobol_opch_op_call
                         000153 tcode                       cobol_opch_op_call
                         000154 inst_word                   cobol_opch_op_call
                         000156 input_ptr                   cobol_opch_op_call
                         000160 inst_ptr                    cobol_opch_op_call
                         000162 reloc_ptr                   cobol_opch_op_call

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cobol_addr                    cobol_alloc$stack             cobol_emit                    cobol_pool
cobol_reg_manager$before_op   cobol_register$load           cobol_reset_r$after_operator  cobol_set_pr

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 000006       194 000017       206 000026       210 000035       211 000037       217 000040       218 000042
    222 000056       223 000060       227 000074       231 000113       232 000115       235 000116       236 000120
    239 000131       240 000133       243 000144       245 000160       247 000165       249 000176       251 000200
    252 000203       253 000213       257 000231       259 000245       261 000252       263 000263       265 000265
    266 000270       267 000300       272 000316       273 000320       276 000331       277 000333       279 000341
    282 000343       285 000365       286 000367       287 000371       290 000374       291 000376       292 000377
    293 000400       294 000402       295 000404       298 000405       301 000417       305 000436       306 000444
    309 000446       311 000470       314 000473       315 000476       318 000510       320 000527       321 000534
    322 000544       332 000564       335 000605       356 000612


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
