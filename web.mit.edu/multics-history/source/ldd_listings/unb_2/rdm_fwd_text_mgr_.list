	COMPILATION LISTING OF SEGMENT rdm_fwd_text_mgr_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/01/84  1411.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* format: style2,ifthenstmt,ifthendo,ifthen,^indnoniterdo,indcomtxt,^inditerdo,idind22 */
        8 
        9 rdm_fwd_text_mgr_:
       10      proc ();
       11 
       12 /* entrypoints for manipulating the text of a read_mail forwarding
       13*   comment */
       14 
       15 /* Written 7 October 1983 by B. Margolin */
       16 
       17 	/*** Common Parameters ***/
       18 
       19 	dcl     P_rfi_ptr		pointer parameter;
       20 	dcl     P_fatal_error	bit (1) aligned parameter;
       21 						/* set ON => an unrecoverable error occured */
       22 
       23 	/*** terminal_input Parameters ***/
       24 
       25 	dcl     P_input_terminator_type
       26 				fixed binary parameter;
       27 						/* set to type of termination (normal/request-loop/qedx) */
       28 	dcl     P_edit_requests_ptr	pointer parameter;	/* set -> editor requests input by user (if any) */
       29 	dcl     P_edit_requests_lth	fixed binary (21) parameter;
       30 						/* set to length of the editor requests */
       31 
       32 
       33 	/*** file_input Parameters ***/
       34 
       35 	dcl     P_input_file_ptr	ptr parameter;	/* -> user-specified input file */
       36 	dcl     P_input_file_len	fixed bin (21) parameter;
       37 						/* length of input file */
       38 
       39 	/*** fill_text Parameters ***/
       40 
       41 	dcl     P_fill_width	fixed binary parameter;
       42 						/* width to use for formatting the text */
       43 
       44 	/*** Automatic ***/
       45 
       46 	dcl     code		fixed bin (35);
       47 	dcl     edit_requests_lth	fixed bin (21);
       48 	dcl     edit_requests_ptr	ptr;
       49 	dcl     fdoc_buffer_ptr	ptr;
       50 	dcl     fdoc_text_lth	fixed bin (21);
       51 	dcl     idx		fixed bin (21);
       52 	dcl     input_line_lth	fixed bin (21);
       53 	dcl     last_character_of_sequence
       54 				fixed bin (21);
       55 	dcl     1 local_fdo		aligned like format_document_options;
       56 	dcl     original_buffer_ptr	ptr;
       57 	dcl     original_text_lth	fixed bin (21);
       58 	dcl     rfi_ptr		ptr;
       59 	dcl     terminator_type	fixed bin;
       60 	dcl     the_character	char (1);
       61 
       62 	/*** Based ***/
       63 
       64 	dcl     edit_requests	char (edit_requests_lth) based (edit_requests_ptr);
       65 	dcl     fdoc_buffer		char (4 * sys_info$max_seg_size) based (fdoc_buffer_ptr);
       66 	dcl     original_buffer	char (4 * sys_info$max_seg_size) based (original_buffer_ptr);
       67 	dcl     original_text	char (original_text_lth) based (original_buffer_ptr);
       68 	dcl     rdm_fwd_area	area based (rfi.area_ptr);
       69 	dcl     1 rfi		aligned like rdm_forward_invocation based (rfi_ptr);
       70 
       71 	/*** Entries ***/
       72 
       73 	dcl     cu_$arg_list_ptr	entry () returns (ptr);
       74 	dcl     cu_$cl		entry (bit (36) aligned);
       75 	dcl     cu_$generate_call	entry (entry, ptr);
       76 	dcl     format_document_$string
       77 				entry (char (*), char (*), fixed bin (21), ptr, fixed bin (35));
       78 	dcl     ioa_		entry () options (variable);
       79 	dcl     ioa_$ioa_switch	entry () options (variable);
       80 	dcl     iox_$get_line	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
       81 	dcl     ssu_$get_temp_segment entry (ptr, char (*), ptr);
       82 	dcl     ssu_$print_message	entry () options (variable);
       83 	dcl     ssu_$release_temp_segment
       84 				entry (ptr, ptr);
       85 
       86 	/*** Static ***/
       87 
       88 	dcl     error_table_$recoverable_error
       89 				fixed bin (35) ext static;
       90 	dcl     (
       91 	        iox_$error_output,
       92 	        iox_$user_input
       93 	        )			ptr ext static;
       94 	dcl     sys_info$max_seg_size fixed bin (35) ext static;
       95 
       96 	/*** Misc ***/
       97 
       98 	dcl     (cleanup, program_interrupt)
       99 				condition;
      100 
  1     1 /*	BEGIN INCLUDE FILE   format_document_options.incl.pl1	     
  1     2*
  1     3*     Modified 82.10.18 by Paul W. Benjamin to add dont_compress_sw and upgrade
  1     4*			to version_2.
  1     5*     Modified 83.02.15 by PWB to add break_word_sw and max_line_length_sw.
  1     6*     Modified 83.03.01 by PWB to add dont_break_indented_lines_sw.
  1     7*     Modified 83.03.03 by PWB to add sub_err_sw.
  1     8*     Modified 83.06.07 by PWB to add dont_fill_sw.
  1     9*     Modified 83.06.09 by PWB to add hyphenation_sw and syllable_size.
  1    10**/
  1    11 
  1    12 dcl 1 format_document_options aligned based (format_document_options_ptr),
  1    13       2 version_number        fixed bin,		/* input */
  1    14                                                             /* must be format_document_version_2 */
  1    15       2 indentation           fixed bin,		/* input */
  1    16 						/* all lines must be indented by this value */
  1    17       2 line_length           fixed bin,		/* input */
  1    18 						/* initial line length */
  1    19       2 switches,
  1    20         3 pgno_sw             bit (1) unal,		/* input */
  1    21 						/* end each page with a centered page number */
  1    22         3 adj_sw              bit (1) unal,		/* input */
  1    23 						/* adjust mode initially on */
  1    24                                                             /* only meaningful if dont_fill_sw = "0"b */
  1    25         3 galley_sw           bit (1) unal,		/* input */
  1    26 						/* galley mode -- no page breaks */
  1    27         3 error_sw            bit (1) unal,		/* input */
  1    28 						/* report all errors on error_output */
  1    29         3 literal_sw          bit (1) unal,		/* input */
  1    30 						/* "1"b - interpret all lines as text */
  1    31 						/* "0"b - lines that start with "." are controls */
  1    32         3 file_sw             bit (1) unal,		/* output */
  1    33 						/* has meaning for non-zero storage system status codes */
  1    34 						/* "1"b code refers to output file */
  1    35 						/* "0"b code refers to input file */
  1    36         3 dont_compress_sw    bit (1) unal,		/* input */
  1    37 						/* "1"b - don't compress white space */
  1    38 						/* "0"b - compress white space when filling */
  1    39         3 break_word_sw      bit (1) unal,		/* input */
  1    40 						/* "1"b - break a word rather than exceed line_length */
  1    41 						/* "0"b - write an overlength line if no spaces found */
  1    42         3 max_line_length_sw  bit (1) unal,		/* input */
  1    43 						/* "1"b - line_length cannot be exceeded */
  1    44 						/* "0"b - line_length can be exceeded (by .pdw controls) */
  1    45         3 dont_break_indented_lines_sw			/* input */
  1    46 			bit (1) unal,		/* don't break a line that begins with whitespace */
  1    47 						/* when it is the last line, or the next line is */
  1    48 						/* null or the next line begins with whitespace */
  1    49         3 sub_err_sw	bit (1) unal,		/* input */
  1    50 						/* quietly call sub_err_ with diagnostic errors */
  1    51         3 dont_fill_sw        bit (1) unal,                 /* input */
  1    52                                                             /* "1"b - fill mode off initially */
  1    53                                                             /* "0"b - fill mode on initially */
  1    54         3 hyphenation_sw      bit (1) unal,
  1    55         3 mbz                 bit (23) unal,		/* input */
  1    56 						/* MUST be zero */
  1    57       2 syllable_size
  1    58 			fixed bin;		/* input */
  1    59 						/* smallest portion of word */
  1    60 						/* to be left by hyphenation */
  1    61 
  1    62 dcl  format_document_options_ptr ptr;
  1    63 dcl  format_document_version_2 fixed bin int static options (constant) init (2);
  1    64 dcl  format_document_version_1 fixed bin int static options (constant) init (1);
  1    65 	
  1    66 /*	END INCLUDE FILE   format_document_options.incl.pl1	     */
      101 
      102 
  2     1 /*  START OF:	rdm_forward_invocation.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* Structure used internally by the read_mail forward sub-request-loop */
  2     4 
  2     5 /* Written: 07 Oct 1983 by B. Margolin */
  2     6 
  2     7 dcl 1 rdm_forward_invocation		aligned based (rdm_forward_invocation_ptr),
  2     8       2 type			char (8),
  2     9       2 sci_ptr			ptr,
  2    10       2 rfso_ptr			ptr,		/* -> rdm_forward_subsystem_options */
  2    11       2 rdm_invocation_ptr		ptr,		/* for the read_mail that created this forwarding invocation */
  2    12       2 area_ptr			ptr,
  2    13       2 text_buffer,
  2    14         3 buffer_ptr		ptr,
  2    15         3 buffer_used		fixed bin (21),
  2    16       2 flags,
  2    17         3 debug_mode		bit (1) unaligned,
  2    18         3 fill			bit (1) unaligned,
  2    19         3 enter_request_loop		bit (1) unaligned,
  2    20         3 auto_write		bit (1) unaligned,
  2    21         3 pad			bit (31) unaligned,
  2    22       2 fill_width			fixed bin,
  2    23       2 temp_seg_ptr		ptr,
  2    24       2 abort_code			fixed bin (35);
  2    25 
  2    26 dcl rdm_forward_invocation_ptr	ptr;
  2    27 dcl RDM_FORWARD_INVOCATION		char (8) int static options (constant) init ("rdmfwdin");
  2    28 
  2    29 /*  END OF:	rdm_forward_invocation.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      103 
      104 
  3     1 /* BEGIN INCLUDE FILE ... rdm_fwd_text_mgr_const.incl.pl1 */
  3     2 /* Created: 7 October 1983 by B. Margolin
  3     3*   (copied from sdm_text_mgr_constants.incl.pl1) */
  3     4 
  3     5 /* Constants used by rdm_fwd_text_mgr_ to communicate the type of input terminator read from the terminal */
  3     6 
  3     7 dcl (NORMAL_TERMINATION	initial (1),		/* '.': transmit the message */
  3     8      ENTER_REQUEST_LOOP	initial (2),		/* '\fq': enter request loop */
  3     9      ENTER_EDITOR		initial (3))		/* '\f...': enter editor */
  3    10 	fixed binary static options (constant);
  3    11 
  3    12 /* END INCLUDE FILE ... rdm_fwd_text_mgr_const.incl.pl1 */
      105 
      106 
      107 /*^ Reads the text of the message from the terminal: the possible terminators for the text are:
      108*	'.'	end of input
      109*	'\fq'	end of input, enter request loop, and
      110*	'\f...'	end of input, enter editor with given requests (if any) */
      111 
      112 terminal_input:
      113      entry (P_rfi_ptr, P_input_terminator_type, P_edit_requests_ptr, P_edit_requests_lth, P_fatal_error);
      114 
      115 	rfi_ptr = P_rfi_ptr;
      116 
      117 	original_text_lth = 0;			/* nothing read yet */
      118 	edit_requests_lth = 0;			/* no editor requests yet */
      119 
      120 	on condition (program_interrupt)
      121 	     begin;				/* stop reading if the user asks us ... */
      122 		terminator_type = ENTER_REQUEST_LOOP;
      123 		go to END_OF_INPUT;
      124 	     end;
      125 
      126 	call ioa_ ("Comment:");
      127 
      128 
      129 	/*** Message reading loop ... ***/
      130 
      131 	terminator_type = 0;			/* really need do until ... */
      132 	input_line_lth = 0;
      133 	original_buffer_ptr = rfi.temp_seg_ptr;
      134 
      135 	do while (terminator_type = 0);
      136 	     original_text_lth = original_text_lth + input_line_lth;
      137 
      138 	     begin;
      139 
      140 		dcl     rest_of_original_buffer
      141 					character (length (original_buffer) - original_text_lth)
      142 					unaligned defined (original_buffer) position (original_text_lth + 1);
      143 
      144 		call iox_$get_line (iox_$user_input, addr (rest_of_original_buffer), length (rest_of_original_buffer),
      145 		     input_line_lth, code);
      146 		if code ^= 0 then			/* ... all errors fatal when an entire segment available */
      147 		     call abort_terminal_input (rfi.sci_ptr, code, "Reading the message text.");
      148 
      149 
      150 		/*** ... Search for terminators ***/
      151 
      152 		begin;
      153 
      154 		     dcl	   input_line	     character (input_line_lth) unaligned
      155 					     defined (original_buffer) position (original_text_lth + 1);
      156 
      157 		     if input_line_lth = 2 then
      158 			if substr (input_line, 1, 1) = "." then
      159 			     terminator_type = NORMAL_TERMINATION;
      160 			else ;
      161 
      162 		     else do;			/* look for escape (\) sequences */
      163 			idx = index (input_line, "\");
      164 			do while (idx ^= 0);	/* ... while there are \'s in line */
      165 			     original_text_lth = original_text_lth + idx - 1;
      166 						/* ... include everything before the \ in the text */
      167 			     input_line_lth = input_line_lth - idx + 1;
      168 			     begin;
      169 				dcl     input_line		character (input_line_lth) unaligned
      170 							defined (original_buffer)
      171 							position (original_text_lth + 1);
      172 				if input_line_lth >= 2 then do;
      173 						/* ... stuff after \ on line */
      174 				     the_character = substr (input_line, 2, 1);
      175 				     if the_character = "f" then do;
      176 					/*** \f...: terminates input and maybe enters the editor */
      177 					if input_line_lth >= 3 then
      178 					     if substr (input_line, 3, 1) = "q" then do;
      179 						/* ... special case \fq to go straight to request loop */
      180 						last_character_of_sequence = 3;
      181 						go to PROCESS_ENTER_REQUEST_LOOP_ESCAPE;
      182 					     end;
      183 					terminator_type = ENTER_EDITOR;
      184 					if input_line_lth >= 4 then do;
      185 						/* ... if anything after \f and before NL */
      186 					     edit_requests_lth = input_line_lth - 3;
      187 					     allocate edit_requests in (rdm_fwd_area) set (edit_requests_ptr);
      188 					     edit_requests = substr (input_line, 3, edit_requests_lth);
      189 					end;
      190 				     end;
      191 				     else if the_character = "q" then do;
      192 					/*** \q or \fq: enter request loop */
      193 					last_character_of_sequence = 2;
      194 PROCESS_ENTER_REQUEST_LOOP_ESCAPE:
      195 					terminator_type = ENTER_REQUEST_LOOP;
      196 					if input_line_lth >= (last_character_of_sequence + 2) then
      197 					     call ssu_$print_message (rfi.sci_ptr, code,
      198 						"Text after ""^a"" ignored.",
      199 						substr (input_line, 1, last_character_of_sequence));
      200 				     end;
      201 				     else if the_character = "c" then do;
      202 					/*** \c: escape the next character */
      203 					substr (input_line, 1, input_line_lth - 2) = substr (input_line, 3);
      204 					original_text_lth = original_text_lth + 1;
      205 					input_line_lth = input_line_lth - 3;
      206 				     end;
      207 				     else do;
      208 					/*** unknown: take it literally */
      209 					original_text_lth = original_text_lth + 1;
      210 					input_line_lth = input_line_lth - 1;
      211 				     end;
      212 				end;
      213 			     end;
      214 			     begin;
      215 				dcl     input_line		character (input_line_lth) unaligned
      216 							defined (original_buffer)
      217 							position (original_text_lth + 1);
      218 				if terminator_type = 0 then
      219 				     idx = index (input_line, "\");
      220 				else idx = 0;
      221 			     end;
      222 			end;
      223 		     end;
      224 		end;
      225 	     end;
      226 	end;
      227 
      228 	/*** We have the comment text now ***/
      229 
      230 END_OF_INPUT:
      231 	rfi.buffer_ptr = original_buffer_ptr;
      232 	rfi.buffer_used = original_text_lth;
      233 	P_input_terminator_type = terminator_type;	/* tell the caller what to do next */
      234 
      235 	if edit_requests_lth ^= 0 then		/* there are some editing requests */
      236 	     P_edit_requests_ptr = edit_requests_ptr;
      237 	else P_edit_requests_ptr = null ();
      238 	P_edit_requests_lth = edit_requests_lth;
      239 
      240 	P_fatal_error = "0"b;			/* success */
      241 
      242 RETURN_FROM_TERMINAL_INPUT:
      243 	return;
      244 
      245 /* Reads the text of the message from the specified segment */
      246 
      247 file_input:
      248      entry (P_rfi_ptr, P_input_file_ptr, P_input_file_len, P_fatal_error);
      249 
      250 	rfi_ptr = P_rfi_ptr;
      251 
      252 	rfi.buffer_ptr = P_input_file_ptr;
      253 	rfi.buffer_used = P_input_file_len;
      254 
      255 	P_fatal_error = "0"b;			/* success */
      256 
      257 	return;
      258 
      259 /* Reformats the message body text using format_document_ with fill-on and align-left modes */
      260 
      261 fill_text:
      262      entry (P_rfi_ptr, P_fill_width, P_fatal_error);
      263 
      264 	rfi_ptr = P_rfi_ptr;
      265 
      266 	fdoc_buffer_ptr = null ();			/* for cleanup handler */
      267 
      268 	on condition (cleanup) call release_fill_buffer ();
      269 
      270 	call ssu_$get_temp_segment (rfi.sci_ptr, "fdoc-text", fdoc_buffer_ptr);
      271 	if fdoc_buffer_ptr = null () then call abort_fill_text ();
      272 
      273 	original_buffer_ptr = rfi.buffer_ptr;
      274 	original_text_lth = rfi.buffer_used;
      275 
      276 	/*** Setup format_document_ options */
      277 	local_fdo.version_number = format_document_version_2;
      278 	local_fdo.indentation = 0;
      279 	local_fdo.line_length = P_fill_width;		/* ... let caller control the width */
      280 	string (local_fdo.switches) = ""b;
      281 	local_fdo.galley_sw = "1"b;			/* ... don't insert page breaks */
      282 	local_fdo.literal_sw = "1"b;			/* ... don't recognize controls in the text */
      283 	local_fdo.dont_compress_sw = "1"b;		/* ... don't compress whitespace */
      284 	local_fdo.dont_break_indented_lines_sw = "1"b;	/* ... don't break lines which are indented */
      285 	local_fdo.syllable_size = 0;
      286 
      287 	call format_document_$string (original_text, fdoc_buffer, fdoc_text_lth, addr (local_fdo), code);
      288 	if code = error_table_$recoverable_error then code = 0;
      289 	if code ^= 0 then call abort_fill_text (rfi.sci_ptr, code, "Attempting to reformat the message text.");
      290 
      291 	/*** Swap temp-seg ptrs ***/
      292 	rfi.buffer_ptr = fdoc_buffer_ptr;
      293 	fdoc_buffer_ptr = rfi.sci_ptr;		/* for release_fill_buffer */
      294 	rfi.temp_seg_ptr = rfi.buffer_ptr;
      295 
      296 	rfi.buffer_used = fdoc_text_lth;
      297 
      298 	P_fatal_error = "0"b;			/* success */
      299 
      300 RETURN_FROM_FILL_TEXT:
      301 	call release_fill_buffer ();
      302 	return;
      303 
      304 /* Releases the buffer used by the fill operation */
      305 
      306 release_fill_buffer:
      307      procedure ();
      308 
      309 	if fdoc_buffer_ptr ^= null () then call ssu_$release_temp_segment (rfi.sci_ptr, fdoc_buffer_ptr);
      310 
      311 	return;
      312 
      313      end release_fill_buffer;
      314 
      315 
      316 
      317 /* Prints an error message and aborts execution of the current text manager operation */
      318 
      319 abort_fill_text:
      320      procedure () options (variable);
      321 
      322 	call error (RETURN_FROM_FILL_TEXT, cu_$arg_list_ptr ());
      323 
      324 abort_terminal_input:
      325      entry () options (variable);
      326 
      327 	call error (RETURN_FROM_TERMINAL_INPUT, cu_$arg_list_ptr ());
      328 
      329 
      330 error:
      331      proc (P_return_label, P_alp);
      332 
      333 	dcl     P_alp		ptr parameter;	/* arg list ptr */
      334 	dcl     P_return_label	label variable parameter;
      335 
      336 	call cu_$generate_call (ssu_$print_message, P_alp);
      337 
      338 	if rfi.debug_mode then do;			/* simulate the actions of ssu_$abort_line */
      339 	     call ioa_$ioa_switch (iox_$error_output, "ssu_error_: Debug mode set; calling cu_$cl.");
      340 	     call cu_$cl (""b);
      341 	end;
      342 
      343 	call fatal_error (P_return_label);
      344 
      345      end error;
      346 
      347      end abort_fill_text;
      348 
      349 fatal_error:
      350      proc (P_return_label);
      351 
      352 	dcl     P_return_label	label variable parameter;
      353 
      354 	P_fatal_error = "1"b;			/* informs caller that we've already printed the message */
      355 
      356 	go to P_return_label;
      357 
      358      end fatal_error;
      359 
      360      end rdm_fwd_text_mgr_;
      361 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/01/84  1304.2  rdm_fwd_text_mgr_.pl1             >special_ldd>online>6675-11/01/84>rdm_fwd_text_mgr_.pl1
101          1    11/01/84  1301.3  format_document_options.incl.pl1  >special_ldd>online>6675-11/01/84>format_document_options.incl.pl1
103          2    10/27/83  2104.3  rdm_fwd_invocation.incl.pl1       >ldd>include>rdm_fwd_invocation.incl.pl1
105          3    10/27/83  2104.3  rdm_fwd_text_mgr_const.incl.pl1   >ldd>include>rdm_fwd_text_mgr_const.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ENTER_EDITOR                           constant        fixed bin(17,0)          initial dcl 3-7 ref 183
ENTER_REQUEST_LOOP                     constant        fixed bin(17,0)          initial dcl 3-7 ref 122 194
NORMAL_TERMINATION                     constant        fixed bin(17,0)          initial dcl 3-7 ref 157
P_alp                                  parameter       pointer                  dcl 333 set ref 330 336*
P_edit_requests_lth                    parameter       fixed bin(21,0)          dcl 29 set ref 112 238*
P_edit_requests_ptr                    parameter       pointer                  dcl 28 set ref 112 235* 237*
P_fatal_error                          parameter       bit(1)                   dcl 20 set ref 112 240* 247 255* 261 298* 354*
P_fill_width                           parameter       fixed bin(17,0)          dcl 41 ref 261 279
P_input_file_len                       parameter       fixed bin(21,0)          dcl 36 ref 247 253
P_input_file_ptr                       parameter       pointer                  dcl 35 ref 247 252
P_input_terminator_type                parameter       fixed bin(17,0)          dcl 25 set ref 112 233*
P_return_label                         parameter       label variable           dcl 352 in procedure "fatal_error" ref 349 356
P_return_label                         parameter       label variable           dcl 334 in procedure "error" set ref 330 343*
P_rfi_ptr                              parameter       pointer                  dcl 19 ref 112 115 247 250 261 264
area_ptr                 10            based           pointer                  level 2 dcl 69 ref 187
buffer_ptr               12            based           pointer                  level 3 dcl 69 set ref 230* 252* 273 292* 294
buffer_used              14            based           fixed bin(21,0)          level 3 dcl 69 set ref 232* 253* 274 296*
cleanup                         000130 stack reference condition                dcl 98 ref 268
code                            000100 automatic       fixed bin(35,0)          dcl 46 set ref 144* 146 146* 196* 287* 288 288* 289
                                                                                  289*
cu_$arg_list_ptr                000010 constant        entry                    external dcl 73 ref 322 322 327 327
cu_$cl                          000012 constant        entry                    external dcl 74 ref 340
cu_$generate_call               000014 constant        entry                    external dcl 75 ref 336
debug_mode               15            based           bit(1)                   level 3 packed unaligned dcl 69 ref 338
dont_break_indented_lines_sw
                          3(09) 000112 automatic       bit(1)                   level 3 packed unaligned dcl 55 set ref 284*
dont_compress_sw          3(06) 000112 automatic       bit(1)                   level 3 packed unaligned dcl 55 set ref 283*
edit_requests                          based           char                     unaligned dcl 64 set ref 187 188*
edit_requests_lth               000101 automatic       fixed bin(21,0)          dcl 47 set ref 118* 186* 187 187 188 188 235 238
edit_requests_ptr               000102 automatic       pointer                  dcl 48 set ref 187* 188 235
error_table_$recoverable_error  000034 external static fixed bin(35,0)          dcl 88 ref 288
fdoc_buffer                            based           char                     unaligned dcl 65 set ref 287*
fdoc_buffer_ptr                 000104 automatic       pointer                  dcl 49 set ref 266* 270* 271 287 292 293* 309 309*
fdoc_text_lth                   000106 automatic       fixed bin(21,0)          dcl 50 set ref 287* 296
flags                    15            based           structure                level 2 dcl 69
format_document_$string         000016 constant        entry                    external dcl 76 ref 287
format_document_options                based           structure                level 1 dcl 1-12
format_document_version_2              constant        fixed bin(17,0)          initial dcl 1-63 ref 277
galley_sw                 3(02) 000112 automatic       bit(1)                   level 3 packed unaligned dcl 55 set ref 281*
idx                             000107 automatic       fixed bin(21,0)          dcl 51 set ref 163* 164 165 167 218* 220*
indentation               1     000112 automatic       fixed bin(17,0)          level 2 dcl 55 set ref 278*
input_line                             defined         char                     unaligned dcl 215 in begin block on line 214 ref 218
input_line                             defined         char                     unaligned dcl 169 in begin block on line 168 set ref
                                                                                  174 177 188 196 196 203* 203
input_line                             defined         char                     unaligned dcl 154 in begin block on line 152 ref 157
                                                                                  163
input_line_lth                  000110 automatic       fixed bin(21,0)          dcl 52 set ref 132* 136 144* 154 157 167* 167 169
                                                                                  172 177 184 186 196 203 205* 205 210* 210 215
ioa_                            000020 constant        entry                    external dcl 78 ref 126
ioa_$ioa_switch                 000022 constant        entry                    external dcl 79 ref 339
iox_$error_output               000036 external static pointer                  dcl 90 set ref 339*
iox_$get_line                   000024 constant        entry                    external dcl 80 ref 144
iox_$user_input                 000040 external static pointer                  dcl 90 set ref 144*
last_character_of_sequence      000111 automatic       fixed bin(21,0)          dcl 53 set ref 180* 193* 196 196 196
line_length               2     000112 automatic       fixed bin(17,0)          level 2 dcl 55 set ref 279*
literal_sw                3(04) 000112 automatic       bit(1)                   level 3 packed unaligned dcl 55 set ref 282*
local_fdo                       000112 automatic       structure                level 1 dcl 55 set ref 287 287
original_buffer                        based           char                     unaligned dcl 66 ref 140 144 144 144 144 144 144 144
                                                                                  144 157 157 163 163 174 174 177 177 188 188 196
                                                                                  196 196 196 203 203 203 203 218 218
original_buffer_ptr             000120 automatic       pointer                  dcl 56 set ref 133* 140 144 144 144 144 157 163 174
                                                                                  177 188 196 196 203 203 218 230 273* 287
original_text                          based           char                     unaligned dcl 67 set ref 287*
original_text_lth               000122 automatic       fixed bin(21,0)          dcl 57 set ref 117* 136* 136 140 144 144 144 144 157
                                                                                  163 165* 165 174 177 188 196 196 203 203 204* 204
                                                                                  209* 209 218 232 274* 287 287
program_interrupt               000136 stack reference condition                dcl 98 ref 120
rdm_forward_invocation                 based           structure                level 1 dcl 2-7
rdm_fwd_area                           based           area(1024)               dcl 68 ref 187
rest_of_original_buffer                defined         char                     unaligned dcl 140 set ref 144 144 144 144
rfi                                    based           structure                level 1 dcl 69
rfi_ptr                         000124 automatic       pointer                  dcl 58 set ref 115* 133 146 187 196 230 232 250* 252
                                                                                  253 264* 270 273 274 289 292 293 294 294 296 309
                                                                                  338
sci_ptr                   2            based           pointer                  level 2 dcl 69 set ref 146* 196* 270* 289* 293 309*
ssu_$get_temp_segment           000026 constant        entry                    external dcl 81 ref 270
ssu_$print_message              000030 constant        entry                    external dcl 82 ref 196 336 336
ssu_$release_temp_segment       000032 constant        entry                    external dcl 83 ref 309
switches                  3     000112 automatic       structure                level 2 dcl 55 set ref 280*
syllable_size             4     000112 automatic       fixed bin(17,0)          level 2 dcl 55 set ref 285*
sys_info$max_seg_size           000042 external static fixed bin(35,0)          dcl 94 ref 140 144 144 144 144 157 163 174 177 188
                                                                                  196 196 203 203 218 287 287
temp_seg_ptr             20            based           pointer                  level 2 dcl 69 set ref 133 294*
terminator_type                 000126 automatic       fixed bin(17,0)          dcl 59 set ref 122* 131* 135 157* 183* 194* 218 233
text_buffer              12            based           structure                level 2 dcl 69
the_character                   000127 automatic       char(1)                  unaligned dcl 60 set ref 174* 175 191 201
version_number                  000112 automatic       fixed bin(17,0)          level 2 dcl 55 set ref 277*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RDM_FORWARD_INVOCATION                 internal static char(8)                  initial unaligned dcl 2-27
format_document_options_ptr            automatic       pointer                  dcl 1-62
format_document_version_1              internal static fixed bin(17,0)          initial dcl 1-64
rdm_forward_invocation_ptr             automatic       pointer                  dcl 2-26

NAMES DECLARED BY EXPLICIT CONTEXT.
END_OF_INPUT                    000552 constant        label                    dcl 230 ref 123
PROCESS_ENTER_REQUEST_LOOP_ESCAPE
                                000416 constant        label                    dcl 194 ref 181
RETURN_FROM_FILL_TEXT           001063 constant        label                    dcl 300 ref 322 322
RETURN_FROM_TERMINAL_INPUT      000574 constant        label                    dcl 242 ref 327 327
abort_fill_text                 001116 constant        entry                    internal dcl 319 ref 271 289
abort_terminal_input            001142 constant        entry                    internal dcl 324 ref 146
error                           001166 constant        entry                    internal dcl 330 ref 322 327
fatal_error                     001254 constant        entry                    internal dcl 349 ref 343
file_input                      000602 constant        entry                    external dcl 247
fill_text                       000631 constant        entry                    external dcl 261
rdm_fwd_text_mgr_               000077 constant        entry                    external dcl 9
release_fill_buffer             001071 constant        entry                    internal dcl 306 ref 268 300
terminal_input                  000112 constant        entry                    external dcl 112

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 144 144 287 287
index                                                  builtin function         ref 163 218
length                                                 builtin function         ref 140 144 144
null                                                   builtin function         ref 237 266 271 309
string                                                 builtin function         ref 280
substr                                                 builtin function         set ref 157 174 177 188 196 196 203* 203

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1572        1636    1276        1602
Length      2140    1276        44         265     274           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rdm_fwd_text_mgr_                   214 external procedure  is an external procedure.  
on unit on line 120                  64 on unit               
begin block on line 138                 begin block         shares stack frame of external procedure rdm_fwd_text_mgr_.  
begin block on line 152                 begin block         shares stack frame of external procedure rdm_fwd_text_mgr_.  
begin block on line 168                 begin block         shares stack frame of external procedure rdm_fwd_text_mgr_.  
begin block on line 214                 begin block         shares stack frame of external procedure rdm_fwd_text_mgr_.  
on unit on line 268                  64 on unit               
release_fill_buffer                  70 internal procedure  is called by several nonquick procedures.  
abort_fill_text                     118 internal procedure  is declared options(variable).  
error                                   internal procedure  shares stack frame of internal procedure abort_fill_text.  
fatal_error                             internal procedure  shares stack frame of internal procedure abort_fill_text.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rdm_fwd_text_mgr_        000100 code                        rdm_fwd_text_mgr_
                         000101 edit_requests_lth           rdm_fwd_text_mgr_
                         000102 edit_requests_ptr           rdm_fwd_text_mgr_
                         000104 fdoc_buffer_ptr             rdm_fwd_text_mgr_
                         000106 fdoc_text_lth               rdm_fwd_text_mgr_
                         000107 idx                         rdm_fwd_text_mgr_
                         000110 input_line_lth              rdm_fwd_text_mgr_
                         000111 last_character_of_sequence  rdm_fwd_text_mgr_
                         000112 local_fdo                   rdm_fwd_text_mgr_
                         000120 original_buffer_ptr         rdm_fwd_text_mgr_
                         000122 original_text_lth           rdm_fwd_text_mgr_
                         000124 rfi_ptr                     rdm_fwd_text_mgr_
                         000126 terminator_type             rdm_fwd_text_mgr_
                         000127 the_character               rdm_fwd_text_mgr_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other
return              move_label_var      make_label_var      tra_ext             tra_label_var       enable
shorten_stack       ext_entry           int_entry           alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cu_$cl                        cu_$generate_call             format_document_$string
ioa_                          ioa_$ioa_switch               iox_$get_line                 ssu_$get_temp_segment
ssu_$print_message            ssu_$release_temp_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$recoverable_error                              iox_$error_output             iox_$user_input
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000076       112 000104       115 000122       117 000126       118 000127       120 000130       122 000144
    123 000147       126 000152       131 000165       132 000166       133 000167       135 000172       136 000174
    140 000176       144 000204       146 000227       154 000255       157 000257       160 000274       163 000275
    164 000314       165 000316       167 000321       169 000325       172 000327       174 000331       175 000342
    177 000346       180 000356       181 000360       183 000361       184 000363       186 000366       187 000370
    188 000400       190 000411       191 000412       193 000414       194 000416       196 000420       200 000467
    201 000471       203 000473       204 000514       205 000515       206 000517       209 000520       210 000521
    215 000523       218 000525       220 000547       222 000550       226 000551       230 000552       232 000555
    233 000557       235 000562       237 000567       238 000571       240 000573       242 000574       247 000575
    250 000612       252 000616       253 000621       255 000623       257 000624       261 000625       264 000641
    266 000645       268 000647       270 000671       271 000716       273 000726       274 000731       277 000734
    278 000736       279 000737       280 000742       281 000743       282 000745       283 000747       284 000751
    285 000753       287 000754       288 001016       289 001023       292 001051       293 001054       294 001056
    296 001060       298 001062       300 001063       302 001067       306 001070       309 001076       311 001114
    319 001115       322 001123       324 001140       327 001147       347 001165       330 001166       336 001170
    338 001206       339 001213       340 001233       343 001244       345 001253       349 001254       354 001256
    356 001261


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
