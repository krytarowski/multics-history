	COMPILATION LISTING OF SEGMENT imft_cir_mir_commands_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/14/88  1214.5 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* Cancels and moves Inter-Multics File Transfer (IMFT) requests */
        9 
       10 /* Created:  May 1982 by G. Palter */
       11 /* Modified: 16 July 1982 by G. Palter to make the commands recognize "-a" as the synonym of "-all" */
       12 /* Modified: March 1983 by Robert Coren to recognize "-source" */
       13 /* Modified: July 1984 by C. Marker to search all queues by default. */
       14  /* Modified: 1984-10-11 BIM for mseg_message_info */
       15 
       16 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       17 
       18 
       19 imft_cir_mir_commands_:
       20      procedure ();
       21 
       22 
       23 dcl  system_area area based (system_area_ptr);
       24 dcl  system_area_ptr pointer;
       25 
       26 dcl  1 local_sb aligned like status_branch;
       27 dcl  1 local_mmi aligned like mseg_message_info;
       28 
       29 dcl  1 message_ids (n_requests_selected) aligned based (message_ids_ptr),
       30        2 id bit (72),
       31        2 queue fixed binary,
       32        2 pad bit (36);
       33 dcl  message_ids_ptr pointer;
       34 dcl  (n_requests_selected, n_requests_moved, n_previous_requests, message_idx) fixed binary;
       35 
       36 dcl  argument character (argument_lth) unaligned based (argument_ptr);
       37 dcl  id_qualifier character (id_qualifier_lth) unaligned based (id_qualifier_ptr);
       38 dcl  (the_argument_list, argument_ptr, id_qualifier_ptr) pointer;
       39 dcl  (argument_lth, id_qualifier_lth) fixed binary (21);
       40 dcl  (n_arguments, id_qualifier_idx, argument_idx) fixed binary;
       41 
       42 dcl  function fixed binary (1);			/* whether to cancel or move requests */
       43 dcl  command_name character (32);
       44 
       45 dcl  1 n_identifiers aligned,
       46        2 path fixed binary,				/* # of pathname identifiers */
       47        2 entry fixed binary,				/* # of -entry STR identifiers */
       48        2 id fixed binary;				/* # of request ID identifiers */
       49 
       50 dcl  (request_type, target_request_type) character (24);
       51 dcl  (foreign_system, target_foreign_system) character (24);
       52 dcl  (
       53      queue_indeces (4),
       54      target_queue_index
       55      ) fixed binary;
       56 dcl  (queue, target_queue, default_queue, max_queues, target_max_queues, queue_idx) fixed binary;
       57 dcl  (remote, target_remote) bit (1) aligned;
       58 dcl  (generic_type, queue_string) character (32);
       59 dcl  (opened_a_queue, all_queues) bit (1) aligned;
       60 
       61 dcl  user_selection fixed binary (2);
       62 dcl  long bit (1) aligned;
       63 
       64 dcl  (user_id, person_id, project_id) character (32);
       65 dcl  (match_any_person, match_any_project) bit (1) aligned;
       66 
       67 dcl  a_dirname character (168);
       68 dcl  an_ename character (32);
       69 
       70 dcl  request_id_nonvarying character (19);
       71 dcl  request_id character (19) varying;
       72 
       73 dcl  add_entry entry () options (variable) variable;	/* just used to check access */
       74 
       75 dcl  access_required bit (36) aligned;
       76 
       77 dcl  answer character (16) varying;
       78 
       79 dcl  code fixed binary (35);
       80 
       81 /* format: off */
       82 dcl (CANCEL	initial (0b),			/* cancel requests */
       83      MOVE		initial (1b))			/* move requests */
       84 	fixed binary (1) static options (constant);
       85 
       86 dcl (USER		initial (01b),			/* -own */
       87      SUBSET	initial (10b),			/* -user STR: doesn't match any user */
       88      ALL		initial (11b),			/* -user STR: matches everyone */
       89 
       90      NONE		initial (00b),			/* not a request_identifier control argument */
       91      PATH		initial (01b),			/* pathname */
       92      ENTRY	initial (10b),			/* -entry STR */
       93      ID		initial (11b),			/* -id STR */
       94 
       95      MATCH_ONE	initial (00b),			/* this identifier matches exactly one request */
       96      MATCH_SUBSET	initial (01b),			/* this identifier matches some but not all requests */
       97      MATCH_ALL	initial (10b))			/* this identifier matches all requests */
       98 	fixed binary (2) static options (constant);
       99 
      100 dcl (A_EXTENDED_ACCESS	initial ("400000000000"b3),
      101      O_EXTENDED_ACCESS	initial ("040000000000"b3),
      102      RD_EXTENDED_ACCESS	initial ("300000000000"b3))
      103 	bit (36) aligned static options (constant);
      104 /* format: on */
      105 
      106 dcl  CHASE fixed binary (1) static options (constant) initial (1);
      107 
      108 
      109 dcl  CANCEL_IMFT_REQUEST character (32) static options (constant) initial ("cancel_imft_request");
      110 dcl  MOVE_IMFT_REQUEST character (32) static options (constant) initial ("move_imft_request");
      111 
      112 dcl  imft_data_$queue_dirname character (168) external;
      113 
      114 /* format: off */
      115 dcl (error_table_$bad_segment, error_table_$badopt, error_table_$id_not_found, error_table_$inconsistent,
      116      error_table_$moderr, error_table_$no_message, error_table_$no_s_permission, error_table_$noarg)
      117 	fixed binary (35) external;
      118 /* format: on */
      119 
      120 dcl  check_star_name_$entry entry (character (*), fixed binary (35));
      121 dcl  com_err_ entry () options (variable);
      122 dcl  com_err_$suppress_name entry () options (variable);
      123 dcl  command_query_ entry () options (variable);
      124 dcl  cu_$arg_count entry (fixed binary, fixed binary (35));
      125 dcl  cu_$arg_list_ptr entry () returns (pointer);
      126 dcl  cu_$arg_ptr_rel entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
      127 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
      128 dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
      129 dcl  get_system_free_area_ entry () returns (pointer);
      130 dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
      131 dcl  hcs_$status_long entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
      132 dcl  imft_default_rqt_ entry () returns (char (*));
      133 dcl  ioa_ entry () options (variable);
      134 dcl  iod_info_$generic_type entry (character (*), character (32), fixed binary (35));
      135 dcl  iod_info_$queue_data entry (character (*), fixed binary, fixed binary, fixed binary (35));
      136 dcl  match_request_id_ entry (fixed binary (71), character (*)) returns (bit (1) aligned);
      137 dcl  match_star_name_ entry (character (*), character (*), fixed binary (35));
      138 dcl  message_segment_$add_index entry (fixed binary, pointer, fixed binary (24), bit (72) aligned, fixed binary (35));
      139 dcl  message_segment_$close entry (fixed binary, fixed binary (35));
      140 dcl  message_segment_$delete_index entry (fixed binary, bit (72) aligned, fixed binary (35));
      141 dcl  message_segment_$get_message_count_index entry (fixed binary, fixed binary, fixed binary (35));
      142 dcl  message_segment_$get_mode_index entry (fixed binary, bit (36) aligned, fixed binary (35));
      143 dcl  message_segment_$read_message_index entry (fixed binary, pointer, pointer, fixed binary (35));
      144 dcl  message_segment_$open entry (character (*), character (*), fixed binary, fixed binary (35));
      145 dcl  pathname_ entry (character (*), character (*)) returns (character (168));
      146 dcl  queue_admin_$add_index entry (fixed binary, pointer, bit (72) aligned, fixed binary (35));
      147 dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
      148 dcl  request_id_ entry (fixed binary (71)) returns (character (19));
      149 
      150 dcl  (cleanup, linkage_error) condition;
      151 
      152 dcl  (addr, after, before, convert, currentsize, index, length, null, rtrim, substr, verify) builtin;
      153 
      154 /**/
      155 
      156 /* Cancels IMFT requests */
      157 
      158 cancel_imft_request:
      159 cir:
      160      entry () options (variable);
      161 
      162 	function = CANCEL;
      163 	command_name = CANCEL_IMFT_REQUEST;
      164 	go to BEGIN_PROCESSING;
      165 
      166 
      167 /* Moves IMFT requests between queues and even between destinations */
      168 
      169 move_imft_request:
      170 mir:
      171      entry () options (variable);
      172 
      173 	function = MOVE;
      174 	command_name = MOVE_IMFT_REQUEST;
      175 	go to BEGIN_PROCESSING;
      176 
      177 
      178 BEGIN_PROCESSING:
      179 	call cu_$arg_count (n_arguments, code);
      180 	if code ^= 0 then do;
      181 	     call com_err_ (code, command_name);
      182 	     return;
      183 	end;
      184 
      185 	if n_arguments = 0 then do;
      186 PRINT_USAGE_MESSAGE:
      187 	     call com_err_$suppress_name (0, command_name, "Usage:  ^a request_identifiers -control_args", command_name)
      188 		;
      189 	     return;
      190 	end;
      191 
      192 	the_argument_list = cu_$arg_list_ptr ();
      193 
      194 
      195 /* Establish defaults */
      196 
      197 	n_identifiers = 0;				/* no path, entry, or ID identifiers */
      198 
      199 	request_type = imft_default_rqt_ ();		/* gets real name of default request type */
      200 	target_request_type = "";			/* for move: default is to same request type */
      201 	foreign_system = after (request_type, "To_");
      202 	if foreign_system = "" then foreign_system = request_type;
      203 						/* name apparently not of standard form */
      204 	target_foreign_system = foreign_system;		/* reasonable default */
      205 	remote, target_remote = "0"b;
      206 	queue = -1;				/* search all queues by default. */
      207 	target_queue = 0;				/* use default queue */
      208 
      209 	user_selection = USER;			/* default is -own */
      210 	long = "1"b;				/* default is -long */
      211 
      212 	unspec (local_mmi) = ""b;
      213 	local_mmi.version = MSEG_MESSAGE_INFO_V1;
      214 
      215 MAIN_CIR_MIR_BLOCK:
      216 	begin;
      217 
      218 dcl  identifier_types (n_arguments) fixed binary (2);	/* type of identifier indicated by this argument */
      219 dcl  star_types (n_arguments) fixed binary (2);		/* type of starname for path and entry identifiers */
      220 dcl  dir_uids (n_arguments) bit (36) aligned;		/* UIDs of directory part of pathname identifiers */
      221 
      222 	     identifier_types (*) = NONE;
      223 	     star_types (*) = MATCH_ONE;
      224 	     dir_uids (*) = ""b;
      225 	     id_qualifier_idx = 0;			/* index of first -id STR */
      226 
      227 
      228 /* Scan the argument list, verify the syntax of all request_identifiers, process all control arguments, and apply other
      229*   appropriate defaults */
      230 
      231 	     do argument_idx = 1 to n_arguments;
      232 
      233 		call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
      234 		if code ^= 0 then do;
      235 		     call com_err_ (code, command_name, "Accessing argument #^d.", argument_idx);
      236 		     return;
      237 		end;
      238 
      239 		if index (argument, "-") = 1 then	/* a control argument */
      240 		     if (argument = "-destination") | (argument = "-ds") then do;
      241 			remote = "0"b;
      242 			go to FOREIGN_SYSTEM;
      243 		     end;
      244 
      245 		     else if (argument = "-source") | (argument = "-sc") then do;
      246 			remote = "1"b;
      247 FOREIGN_SYSTEM:
      248 			call get_next_argument ("A system name", foreign_system);
      249 			if remote then
      250 			     request_type = "From_" || foreign_system;
      251 			else request_type = "To_" || foreign_system;
      252 
      253 			call iod_info_$generic_type (request_type, generic_type, code);
      254 			if code ^= 0 then do;	/* couldn't lookup the specified destination */
      255 INVALID_DESTINATION_SPECIFICATION:
      256 			     if code = error_table_$id_not_found then
      257 				call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
      258 				     remote, foreign_system);
      259 			     else call com_err_ (code, command_name, "-^[source^;destination^] ""^a""", remote,
      260 				     foreign_system);
      261 			     return;
      262 			end;
      263 			if generic_type ^= FT_GENERIC_TYPE then do;
      264 			     call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""", remote,
      265 				foreign_system);
      266 			     return;
      267 			end;
      268 		     end;
      269 
      270 		     else if (argument = "-queue") | (argument = "-q") then do;
      271 			call get_next_argument ("A number", queue_string);
      272 			queue = cv_dec_check_ (queue_string, code);
      273 			if code ^= 0 then do;
      274 INVALID_QUEUE_SPECIFICATION:
      275 			     call com_err_ (0, command_name,
      276 				"The queue must be a number between 1 and 4; not ""^a"".", queue_string);
      277 			     return;
      278 			end;
      279 			if (queue < 1) | (queue > 4) then go to INVALID_QUEUE_SPECIFICATION;
      280 		     end;				/* will check if queue is OK for destination later */
      281 
      282 		     else if (argument = "-all") | (argument = "-a") then queue = -1;
      283 						/* special indicator to match all queues */
      284 
      285 		     else if (argument = "-long") | (argument = "-lg") then long = "1"b;
      286 		     else if (argument = "-brief") | (argument = "-bf") then long = "0"b;
      287 
      288 		     else if argument = "-own" then user_selection = USER;
      289 		     else if argument = "-user" then do;
      290 			call get_next_argument ("A user ID", user_id);
      291 			if after (after (user_id, "."), ".") ^= "" then do;
      292 			     call com_err_ (0, command_name, "Invalid syntax for user ID.  ""^a""", user_id);
      293 			     return;
      294 			end;
      295 			match_any_person = (before (user_id, ".") = "") | (before (user_id, ".") = "*");
      296 			match_any_project = (after (user_id, ".") = "") | (after (user_id, ".") = "*");
      297 			if match_any_person & match_any_project then
      298 			     user_selection = ALL;
      299 			else do;			/* matches a subset of all users */
      300 			     user_selection = SUBSET;
      301 			     person_id = before (user_id, ".");
      302 			     if person_id = "" then person_id = "*";
      303 			     project_id = after (user_id, ".");
      304 			     if project_id = "" then project_id = "*";
      305 			     user_id = rtrim (person_id) || "." || project_id;
      306 			end;
      307 		     end;
      308 
      309 		     else if (function = MOVE) & ((argument = "-to_destination") | (argument = "-tods")) then do;
      310 			target_remote = "0"b;
      311 			go to TARGET_FOREIGN_SYSTEM;
      312 		     end;
      313 
      314 		     else if (function = MOVE) & ((argument = "-to_source") | (argument = "-tosc")) then do;
      315 			target_remote = "1"b;
      316 TARGET_FOREIGN_SYSTEM:
      317 			call get_next_argument ("A system name", target_foreign_system);
      318 			if target_remote then
      319 			     target_request_type = "From_" || target_foreign_system;
      320 			else target_request_type = "To_" || target_foreign_system;
      321 
      322 			call iod_info_$generic_type (target_request_type, generic_type, code);
      323 			if code ^= 0 then do;	/* couldn't lookup the specified destination */
      324 INVALID_TARGET_DESTINATION_SPECIFICATION:
      325 			     if code = error_table_$id_not_found then
      326 				call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
      327 				     target_remote, target_foreign_system);
      328 			     else call com_err_ (code, command_name, "-^[source^;destination^] ""^a""",
      329 				     target_remote, target_foreign_system);
      330 			     return;
      331 			end;
      332 			if generic_type ^= FT_GENERIC_TYPE then do;
      333 			     call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
      334 				target_remote, target_foreign_system);
      335 			     return;
      336 			end;
      337 		     end;
      338 
      339 		     else if (function = MOVE) & ((argument = "-to_queue") | (argument = "-tq")) then do;
      340 			call get_next_argument ("A number", queue_string);
      341 			target_queue = cv_dec_check_ (queue_string, code);
      342 			if code ^= 0 then do;
      343 INVALID_TARGET_QUEUE_SPECIFICATION:
      344 			     call com_err_ (0, command_name,
      345 				"The target queue must be a number between 1 and 4; not ""^a"".", queue_string);
      346 			     return;
      347 			end;
      348 			if (target_queue < 1) | (target_queue > 4) then go to INVALID_TARGET_QUEUE_SPECIFICATION;
      349 		     end;				/* will check if queue is OK for destination later */
      350 
      351 		     else if (argument = "-entry") | (argument = "-et") then do;
      352 			call get_next_argument ("A starname", an_ename);
      353 			call check_star_name_$entry (an_ename, code);
      354 			if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
      355 			     call com_err_ (code, command_name, "^a", an_ename);
      356 			     return;
      357 			end;
      358 			n_identifiers.entry = n_identifiers.entry + 1;
      359 			identifier_types (argument_idx) = ENTRY;
      360 			star_types (argument_idx) = code;
      361 		     end;
      362 
      363 		     else if argument = "-id" then do;
      364 			call get_next_argument ("A request ID match strin", request_id_nonvarying);
      365 			request_id = rtrim (request_id_nonvarying);
      366 			if verify (request_id, "0123456789.") ^= 0 then do;
      367 INVALID_REQUEST_ID:
      368 			     call com_err_ (0, command_name,
      369 				"Improper syntax for a request ID match string.  ""^a""", request_id);
      370 			     return;
      371 			end;
      372 			if after (after (request_id, "."), ".") ^= "" then go to INVALID_REQUEST_ID;
      373 			if length (before (request_id, ".")) > length ("YYMMDDHHMMSS") then
      374 			     go to INVALID_REQUEST_ID;
      375 			if length (after (request_id, ".")) > length ("FFFFFF") then go to INVALID_REQUEST_ID;
      376 			n_identifiers.id = n_identifiers.id + 1;
      377 			identifier_types (argument_idx) = ID;
      378 			star_types (argument_idx) = MATCH_SUBSET;
      379 			if id_qualifier_idx = 0 then id_qualifier_idx = argument_idx;
      380 		     end;				/* record index of first -id STR */
      381 
      382 		     else do;
      383 			call com_err_ (error_table_$badopt, command_name, """^a""", argument);
      384 			return;
      385 		     end;
      386 
      387 		else do;				/* a pathname identifier */
      388 		     call expand_pathname_ (argument, a_dirname, an_ename, code);
      389 		     if code ^= 0 then do;
      390 			call com_err_ (code, command_name, "^a", argument);
      391 			return;
      392 		     end;
      393 		     call check_star_name_$entry (an_ename, code);
      394 		     if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
      395 			call com_err_ (code, command_name, "^a", pathname_ (a_dirname, an_ename));
      396 			return;
      397 		     end;
      398 		     n_identifiers.path = n_identifiers.path + 1;
      399 		     identifier_types (argument_idx) = PATH;
      400 		     star_types (argument_idx) = code;
      401 		     call hcs_$status_long (a_dirname, "", CHASE, addr (local_sb), null (), code);
      402 		     if (code = 0) | (code = error_table_$no_s_permission) then
      403 			dir_uids (argument_idx) = local_sb.uid;
      404 		end;				/* get the UID now: will need it later */
      405 	     end;
      406 
      407 	     if (n_identifiers.path + n_identifiers.entry + n_identifiers.id) = 0 then go to PRINT_USAGE_MESSAGE;
      408 
      409 	     if ((n_identifiers.path + n_identifiers.entry) > 0) & (n_identifiers.id > 1) then do;
      410 		call com_err_ (error_table_$inconsistent, command_name,
      411 		     "More than one ""-id"" control argument with path/entry identifiers.");
      412 		return;
      413 	     end;
      414 
      415 	     call iod_info_$queue_data (request_type, default_queue, max_queues, code);
      416 	     if code ^= 0 then go to INVALID_DESTINATION_SPECIFICATION;
      417 	     if queue = 0 then queue = default_queue;	/* supply default if needed */
      418 	     if queue > max_queues then do;
      419 		call com_err_ (0, command_name, "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.",
      420 		     remote, request_type, max_queues, (max_queues ^= 1), queue);
      421 		return;
      422 	     end;
      423 
      424 	     if function = MOVE then do;		/* apply defaults for -to_destination and -to_queue */
      425 		if (remote & ^target_remote) | (^remote & target_remote) then do;
      426 		     call com_err_ (error_table_$inconsistent, command_name,
      427 			"Cannot move a request ^[from^;to^] a destination queue ^[to^;from^] a source queue.",
      428 			target_remote, target_remote);
      429 		     return;
      430 		end;
      431 
      432 		if target_request_type = "" then target_request_type = request_type;
      433 		call iod_info_$queue_data (target_request_type, default_queue, target_max_queues, code);
      434 		if code ^= 0 then go to INVALID_TARGET_DESTINATION_SPECIFICATION;
      435 		if target_queue = 0 then target_queue = default_queue;
      436 		if target_queue > target_max_queues then do;
      437 		     call com_err_ (0, command_name, "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.",
      438 			target_remote, target_request_type, target_max_queues, (target_max_queues ^= 1), target_queue);
      439 		     return;
      440 		end;
      441 		if (target_request_type = request_type) & (target_queue = queue) then do;
      442 		     call com_err_ (0, command_name,
      443 			"^a queue ^d was specified as the source and target for moving requests.", request_type,
      444 			queue);
      445 		     return;
      446 		end;
      447 	     end;
      448 
      449 /**/
      450 
      451 /* Fetch the next argument */
      452 
      453 get_next_argument:
      454      procedure (p_arg_description, p_argument);
      455 
      456 dcl  p_arg_description character (*) parameter;
      457 dcl  p_argument character (*) parameter;
      458 dcl  control_argument character (32);
      459 
      460 	control_argument = argument;			/* save control arg's name for error messages */
      461 
      462 	if argument_idx = n_arguments then do;		/* there is no next argument */
      463 	     call com_err_ (error_table_$noarg, command_name, "^a must follow ""^a"".", p_arg_description,
      464 		control_argument);
      465 	     go to ABORT_ARGUMENT_PARSE;
      466 	end;
      467 
      468 	argument_idx = argument_idx + 1;
      469 
      470 	call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
      471 	if code ^= 0 then do;
      472 	     call com_err_ (code, command_name, "Accessing argument #^d.", argument_idx);
      473 	     go to ABORT_ARGUMENT_PARSE;
      474 	end;
      475 
      476 	if argument_lth > length (p_argument) then do;	/* it's too long */
      477 	     call com_err_ (0, command_name, "Value after ""^a"" may not be longer than ^d characters.  ""^a""",
      478 		control_argument, length (p_argument), argument);
      479 	     go to ABORT_ARGUMENT_PARSE;
      480 	end;
      481 
      482 	p_argument = argument;			/* it's OK */
      483 
      484 	return;
      485 
      486      end get_next_argument;
      487 
      488 /**/
      489 
      490 /* Argument parsing completed: open the appropriate queues and determine if the user has sufficient access */
      491 
      492 	     system_area_ptr = get_system_free_area_ ();
      493 
      494 	     queue_indeces (*), target_queue_index = 0;	/* for cleanup handler */
      495 	     message_ids_ptr, ft_request_ptr = null ();
      496 
      497 	     on condition (cleanup) call cleanup_handler ();
      498 
      499 	     if user_selection = USER then do;
      500 		access_required = O_EXTENDED_ACCESS;
      501 		local_mmi.own = "1"b;
      502 	     end;
      503 	     else 				/* user wants to manipulate someone else's requests */
      504 		access_required = RD_EXTENDED_ACCESS;
      505 
      506 
      507 	     on condition (linkage_error)
      508 		begin;				/* in case the user doesn't have access to queue_admin_ */
      509 		     call com_err_ (0, command_name, "You do not have permission to move other users' requests.");
      510 		     go to RETURN_FROM_CIR_MIR_COMMANDS;
      511 		end;
      512 
      513 	     if function = MOVE then			/* moving requests ... */
      514 		if user_selection = USER then		/* ... only moving our own requests */
      515 		     add_entry = message_segment_$add_index;
      516 		else add_entry = queue_admin_$add_index;/* ... moving others' requests: need to preserve user ID */
      517 
      518 	     if queue = -1 then do;			/* want to examine all the queues */
      519 		all_queues = "1"b;			/* need to remember this option later */
      520 		opened_a_queue = "0"b;
      521 		do queue_idx = 1 to max_queues;
      522 		     if (function = MOVE) & (request_type = target_request_type) & (queue = target_queue) then
      523 			;			/* won't be moving things out of this queue */
      524 		     else call open_single_queue (request_type, queue_idx, queue_indeces (queue_idx), access_required,
      525 			     "0"b, (0));
      526 		     if queue_indeces (queue_idx) ^= 0 then opened_a_queue = "1"b;
      527 		end;
      528 		if ^opened_a_queue then go to RETURN_FROM_CIR_MIR_COMMANDS;
      529 	     end;
      530 
      531 	     else do;				/* just one queue please */
      532 		call open_single_queue (request_type, queue, queue_indeces (queue), access_required, "0"b, (0));
      533 		if queue_indeces (queue) = 0 then go to RETURN_FROM_CIR_MIR_COMMANDS;
      534 	     end;					/* couldn't open it: nothing we can do */
      535 
      536 	     if function = MOVE then do;		/* open the target queue */
      537 		call open_single_queue (target_request_type, target_queue, target_queue_index, A_EXTENDED_ACCESS,
      538 		     "1"b, n_previous_requests);
      539 		if target_queue_index = 0 then go to RETURN_FROM_CIR_MIR_COMMANDS;
      540 	     end;
      541 
      542 /**/
      543 
      544 /* Opens a single queue's message segment, validates access, and returns the number of messages therein if desired */
      545 
      546 open_single_queue:
      547      procedure (p_request_type, p_queue, p_queue_index, p_access_required, p_get_message_count, p_message_count);
      548 
      549 dcl  p_request_type character (24) parameter;
      550 dcl  (p_queue, p_queue_index, p_message_count) fixed binary parameter;
      551 dcl  p_access_required bit (36) aligned parameter;
      552 dcl  p_get_message_count bit (1) aligned parameter;
      553 
      554 dcl  queue_ename character (32);
      555 dcl  queue_picture picture "9";
      556 dcl  queue_mode bit (36) aligned;
      557 
      558 	queue_ename = rtrim (p_request_type) || "_" || convert (queue_picture, p_queue) || ".ms";
      559 
      560 	call message_segment_$open (imft_data_$queue_dirname, queue_ename, p_queue_index, code);
      561 	if code ^= 0 then do;
      562 	     call com_err_ (code, command_name, "Opening ^a.", pathname_ (imft_data_$queue_dirname, queue_ename));
      563 	     go to RETURN_FROM_CIR_MIR_COMMANDS;
      564 	end;
      565 
      566 	call message_segment_$get_mode_index (p_queue_index, queue_mode, code);
      567 	if code ^= 0 then do;
      568 	     call com_err_ (code, command_name, "Determining access to ^a.",
      569 		pathname_ (imft_data_$queue_dirname, queue_ename));
      570 	     go to RETURN_FROM_CIR_MIR_COMMANDS;
      571 	end;
      572 
      573 	if (queue_mode & p_access_required) ^= p_access_required then do;
      574 	     call com_err_ (error_table_$moderr, command_name,
      575 		"You do not have ""^[a^s^;^[o^;rd^]^]"" access to ^a queue ^d.",
      576 		(p_access_required = A_EXTENDED_ACCESS), (p_access_required = O_EXTENDED_ACCESS), p_request_type,
      577 		p_queue);
      578 	     call message_segment_$close (p_queue_index, (0));
      579 	     p_queue_index = 0;			/* caller will decide whether or not to punt */
      580 	end;
      581 
      582 	if p_get_message_count then do;
      583 	     call message_segment_$get_message_count_index (p_queue_index, p_message_count, code);
      584 	     if code ^= 0 then p_message_count = -1;	/* let caller know we couldn't tell */
      585 	end;
      586 
      587 	return;
      588 
      589      end open_single_queue;
      590 
      591 /**/
      592 
      593 /* Process the requests identifiers:  For each identifier, construct a list of matching messages.  If the identifier is
      594*   not a starname or if it is a starname path/entry identifier and there is also a request ID qualifier, refuse to cancel
      595*   or move any requests if more than one match is found.  Otherwise, perform the cancel or moves as desired */
      596 
      597 	     call get_temp_segment_ (command_name, message_ids_ptr, code);
      598 	     if code ^= 0 then do;
      599 		call com_err_ (code, command_name, "Getting a temporary segment.");
      600 		go to RETURN_FROM_CIR_MIR_COMMANDS;
      601 	     end;
      602 
      603 	     n_requests_moved = 0;			/* haven't moved anything yet */
      604 
      605 	     if ((n_identifiers.path + n_identifiers.entry) > 0) & (n_identifiers.id = 1) then
      606 		call cu_$arg_ptr_rel (id_qualifier_idx, id_qualifier_ptr, id_qualifier_lth, (0), the_argument_list);
      607 	     else do;				/* no -id STR qualifier present: avoid faults */
      608 		id_qualifier_ptr = addr (command_name);
      609 		id_qualifier_lth = 0;
      610 	     end;
      611 
      612 	     query_info.version = query_info_version_5;
      613 	     query_info.yes_or_no_sw, query_info.suppress_name_sw = "1"b;
      614 
      615 	     do argument_idx = 1 to n_arguments;
      616 
      617 		if identifier_types (argument_idx) ^= NONE then do;
      618 
      619 		     if (id_qualifier = "") | (identifier_types (argument_idx) ^= ID) then do;
      620 						/* don't bother if this is the -id STR qualifier */
      621 
      622 			call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, (0), the_argument_list);
      623 
      624 			if identifier_types (argument_idx) = PATH then
      625 			     call expand_pathname_ (argument, a_dirname, an_ename, (0));
      626 
      627 			if star_types (argument_idx) = MATCH_ALL then do;
      628 			     call command_query_ (addr (query_info), answer, command_name,
      629 				"Do you want to ^[cancel^;move^] all ^[your ^]requests^[ for ^a^;^s^]^[ from directory ^a^;^s^] in ^[all ^;^]^a queue^[ ^d^;s^]?"
      630 				, (function = CANCEL), (user_selection = USER), (user_selection = SUBSET),
      631 				user_id, (identifier_types (argument_idx) = PATH), a_dirname, all_queues,
      632 				request_type, (queue ^= -1), queue);
      633 			     if answer = "no" then go to PROCESS_NEXT_IDENTIFIER;
      634 			end;
      635 
      636 			n_requests_selected = 0;
      637 
      638 			do queue_idx = 1 to max_queues;
      639 			     if queue_indeces (queue_idx) ^= 0 then call scan_single_queue (queue_idx);
      640 			end;
      641 
      642 			if n_requests_selected = 0 then do;
      643 			     if long then		/* nothing found that matches */
      644 				call com_err_ (0, command_name,
      645 				     "No matching requests found in ^a queue^[s^s^; ^d^] for ^[^a^s^s^;^s^[-entry^;-id^] ^a^]^[ -id ^a^]."
      646 				     , request_type, all_queues, queue, (identifier_types (argument_idx) = PATH),
      647 				     pathname_ (a_dirname, an_ename), (identifier_types (argument_idx) = ENTRY),
      648 				     argument, (id_qualifier ^= ""), id_qualifier);
      649 			     go to PROCESS_NEXT_IDENTIFIER;
      650 			end;
      651 
      652 			if ((star_types (argument_idx) = MATCH_ONE) | (id_qualifier ^= ""))
      653 						/* non-starname or a qualified starname ... */
      654 			     & (n_requests_selected > 1) then do;
      655 						/* ... should only match one request */
      656 			     call com_err_ (0, command_name,
      657 				"^d matching requests found in ^a queue^[s^s^; ^d^] for ^[^a^s^s^;^s^[-entry^;-id^] ^a^]^[ -id ^a^;^s^]; no requests will be ^[cancelled^;moved^]."
      658 				, n_requests_selected, request_type, all_queues, queue,
      659 				(identifier_types (argument_idx) = PATH), pathname_ (a_dirname, an_ename),
      660 				(identifier_types (argument_idx) = ENTRY), argument, (id_qualifier ^= ""),
      661 				id_qualifier, (function = CANCEL));
      662 			     go to PROCESS_NEXT_IDENTIFIER;
      663 			end;
      664 
      665 			do message_idx = 1 to n_requests_selected;
      666 			     if function = CANCEL then
      667 				call cancel_single_request ();
      668 			     else call move_single_request ();
      669 			end;
      670 		     end;
      671 		end;
      672 
      673 PROCESS_NEXT_IDENTIFIER:
      674 	     end;
      675 
      676 	     if (function = MOVE) & (n_requests_moved > 0) & long then
      677 		call ioa_ ("^d request^[s^] moved^[; ^d already in^;to^s^] ^a queue ^d.", n_requests_moved,
      678 		     (n_requests_moved > 1), (n_previous_requests ^= -1), n_previous_requests, target_request_type,
      679 		     target_queue);
      680 
      681 /**/
      682 
      683 /* Scan a single queue for matching requests and record their message IDs */
      684 
      685 scan_single_queue:
      686      procedure (p_queue);
      687 
      688 dcl  p_queue fixed binary parameter;
      689 
      690 dcl  user_id character (30);
      691 dcl  previous_message_id bit (72) aligned;
      692 dcl  request_uid bit (36) aligned;
      693 dcl  retry_read bit (1) aligned;
      694 
      695 	retry_read = "0"b;				/* this isn't a retry */
      696 
      697 RETRY_FIRST_READ:
      698 	local_mmi.message_code = MSEG_READ_FIRST;
      699 	call message_segment_$read_message_index (queue_indeces (p_queue), system_area_ptr, addr (local_mmi), code);
      700 	if ^retry_read then
      701 	     if code = error_table_$bad_segment then do;
      702 		retry_read = "1"b;			/* queue might have been salvaged: try again */
      703 		go to RETRY_FIRST_READ;
      704 	     end;
      705 
      706 
      707 	do while (code = 0);			/* while we've got a message */
      708 
      709 	     previous_message_id = local_mmi.ms_id;	/* needed to read the next message */
      710 
      711 	     ft_request_ptr = local_mmi.ms_ptr;
      712 	     user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));
      713 
      714 	     if (ft_request.hdr_version ^= queue_msg_hdr_version_1) | (ft_request.version ^= FT_REQUEST_VERSION_1)
      715 	     then do;				/* unrecognized message format */
      716 		if user_selection = SUBSET then do;	/* ... check if it's from the right user anyway */
      717 		     if person_id ^= "*" then
      718 			if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
      719 		     if project_id ^= "*" then
      720 			if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
      721 		end;
      722 		if (identifier_types (argument_idx) ^= ENTRY) | (star_types (argument_idx) ^= MATCH_ALL) then
      723 		     go to SKIP_THIS_MESSAGE;		/* ... not cancelling/moving any request in the queue */
      724 		go to ADD_THIS_MESSAGE;		/* get here iff it's OK as far as we can tell */
      725 	     end;
      726 
      727 	     if user_selection = SUBSET then do;	/* check if it's from the correct user */
      728 		if person_id ^= "*" then
      729 		     if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
      730 		if project_id ^= "*" then
      731 		     if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
      732 	     end;
      733 
      734 	     if identifier_types (argument_idx) = PATH then do;
      735 		call match_star_name_ ((ft_request.ename), an_ename, code);
      736 		if code ^= 0 then go to SKIP_THIS_MESSAGE;
      737 		call hcs_$status_long ((ft_request.dirname), "", CHASE, addr (local_sb), null (), code);
      738 		if (code = 0) | (code = error_table_$no_s_permission) then
      739 		     request_uid = local_sb.uid;	/* need UID of directory to test for a match */
      740 		else request_uid = ""b;
      741 		if (request_uid ^= ""b) & (dir_uids (argument_idx) ^= ""b) then
      742 		     if request_uid = dir_uids (argument_idx) then
      743 			;			/* directory UIDs match: this is still a candidate */
      744 		     else go to SKIP_THIS_MESSAGE;
      745 		else if (request_uid = ""b) & (dir_uids (argument_idx) = ""b) then
      746 		     if ft_request.dirname = a_dirname then
      747 			;			/* directory pathnames match */
      748 		     else go to SKIP_THIS_MESSAGE;
      749 		else go to SKIP_THIS_MESSAGE;		/* could get one dir UID but not the other: can't match */
      750 	     end;
      751 
      752 	     else if identifier_types (argument_idx) = ENTRY then do;
      753 		call match_star_name_ ((ft_request.ename), argument, code);
      754 		if code ^= 0 then go to SKIP_THIS_MESSAGE;
      755 	     end;					/* entry names only need to match */
      756 
      757 	     else do;				/* must be a request ID match string */
      758 		if ^match_request_id_ (ft_request.msg_time, argument) then go to SKIP_THIS_MESSAGE;
      759 	     end;
      760 
      761 	     if ((identifier_types (argument_idx) = PATH) | (identifier_types (argument_idx) = ENTRY))
      762 		& (id_qualifier ^= "") then do;	/* further qualified by a request ID match string */
      763 		if ^match_request_id_ (ft_request.msg_time, id_qualifier) then go to SKIP_THIS_MESSAGE;
      764 	     end;
      765 
      766 ADD_THIS_MESSAGE:					/* here iff it matches */
      767 	     n_requests_selected = n_requests_selected + 1;
      768 	     message_ids.id (n_requests_selected) = local_mmi.ms_id;
      769 	     message_ids.queue (n_requests_selected) = p_queue;
      770 
      771 SKIP_THIS_MESSAGE:
      772 	     free ft_request in (system_area);		/* done with this request for now */
      773 	     ft_request_ptr = null ();
      774 
      775 	     retry_read = "0"b;			/* first attempt to read the next message */
      776 
      777 RETRY_READ_NEXT_MESSAGE:
      778 	     local_mmi.message_code = MSEG_READ_AFTER_SPECIFIED;
      779 	     local_mmi.ms_id = previous_message_id;
      780 	     call message_segment_$read_message_index (queue_indeces (p_queue), system_area_ptr, addr (local_mmi), code);
      781 	     if ^retry_read then
      782 		if code = error_table_$bad_segment then do;
      783 		     retry_read = "1"b;		/* message segment may have been salvaged */
      784 		     go to RETRY_READ_NEXT_MESSAGE;
      785 		end;
      786 	end;
      787 
      788 	if (code ^= 0) & (code ^= error_table_$no_message) then do;
      789 	     call com_err_ (code, command_name, "Reading from ^a queue ^d.", request_type, p_queue);
      790 	     call message_segment_$close (queue_indeces (p_queue), (0));
      791 	     queue_indeces (p_queue) = 0;		/* fatal error while reading: drop this queue */
      792 	end;
      793 
      794 	return;
      795 
      796      end scan_single_queue;
      797 
      798 /**/
      799 
      800 /* Cancel a single IMFT request unless it is already running */
      801 
      802 cancel_single_request:
      803      procedure ();
      804 
      805 dcl  user_id character (30);
      806 dcl  message_id bit (72) aligned;
      807 dcl  queue fixed binary;
      808 dcl  (retry_operation, supported_version) bit (1) aligned;
      809 
      810 	queue = message_ids.queue (message_idx);	/* make local copies for future reference */
      811 	message_id = message_ids.id (message_idx);
      812 
      813 	retry_operation = "0"b;
      814 READ_THE_MESSAGE:
      815 	local_mmi.message_code = MSEG_READ_SPECIFIED;
      816 	local_mmi.ms_id = message_id;
      817 	call message_segment_$read_message_index (queue_indeces (queue), system_area_ptr, addr (local_mmi), code);
      818 	if ^retry_operation then
      819 	     if code = error_table_$bad_segment then do;
      820 		retry_operation = "1"b;		/* message segment has been salvaged */
      821 		go to READ_THE_MESSAGE;
      822 	     end;
      823 
      824 	if code ^= 0 then do;			/* couldn't get the message: OK if someone else deleted it */
      825 	     if code ^= error_table_$no_message then
      826 		call com_err_ (code, command_name, "Attempting to read message ^24.3b from ^a queue ^d.", message_id,
      827 		     request_type, queue);
      828 	     return;
      829 	end;
      830 
      831 	ft_request_ptr = local_mmi.ms_ptr;
      832 	user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));
      833 
      834 	if (ft_request.hdr_version = queue_msg_hdr_version_1) & (ft_request.version = FT_REQUEST_VERSION_1) then do;
      835 	     supported_version = "1"b;		/* understand this request: check if it's running */
      836 	     if ft_request.state = STATE_RUNNING then do;
      837 		call com_err_ (0, command_name,
      838 		     "IMFT request ^a^[ for ^a^;^s^] is already running and will not be cancelled.", ft_request.ename,
      839 		     (user_selection ^= USER), user_id);
      840 		go to RETURN_FROM_CANCEL_SINGLE_REQUEST;
      841 	     end;
      842 	end;
      843 	else supported_version = "0"b;		/* controls the message that's printed */
      844 
      845 	retry_operation = "0"b;			/* now to try to delete (cancel) the message */
      846 RETRY_DELETE_MESSAGE:
      847 	call message_segment_$delete_index (queue_indeces (queue), message_id, code);
      848 	if ^retry_operation then
      849 	     if code = error_table_$bad_segment then do;
      850 		retry_operation = "1"b;		/* message segment was salvaged: try again */
      851 		go to RETRY_DELETE_MESSAGE;
      852 	     end;
      853 
      854 	if (code ^= 0) & (code ^= error_table_$no_message) then do;
      855 	     call com_err_ (code, command_name,
      856 		"Unable to cancel IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] from ^a queue ^d.",
      857 		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
      858 		queue);
      859 	     go to RETURN_FROM_CANCEL_SINGLE_REQUEST;
      860 	end;
      861 
      862 	if long & ((star_types (argument_idx) ^= MATCH_ONE) | all_queues) then
      863 	     call ioa_ ("IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] cancelled^[ from queue ^d^].",
      864 		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, all_queues, queue)
      865 		;
      866 
      867 RETURN_FROM_CANCEL_SINGLE_REQUEST:
      868 	free ft_request in (system_area);
      869 	ft_request_ptr = null ();
      870 
      871 	return;
      872 
      873      end cancel_single_request;
      874 
      875 /**/
      876 
      877 /* Move a single IMFT request to the target queue unless it is already running */
      878 
      879 move_single_request:
      880      procedure ();
      881 
      882 dcl  user_id character (30);
      883 dcl  request_id character (8);
      884 dcl  message_id bit (72) aligned;
      885 dcl  queue fixed binary;
      886 dcl  (retry_operation, supported_version) bit (1) aligned;
      887 
      888 	queue = message_ids.queue (message_idx);	/* make local copies for future reference */
      889 	message_id = message_ids.id (message_idx);
      890 
      891 	retry_operation = "0"b;
      892 READ_THE_MESSAGE:
      893 	local_mmi.message_code = MSEG_READ_SPECIFIED;
      894 	local_mmi.ms_id = message_id;
      895 	call message_segment_$read_message_index (queue_indeces (queue), system_area_ptr, addr (local_mmi), code);
      896 	if ^retry_operation then
      897 	     if code = error_table_$bad_segment then do;
      898 		retry_operation = "1"b;		/* message segment has been salvaged */
      899 		go to READ_THE_MESSAGE;
      900 	     end;
      901 
      902 	if code ^= 0 then do;			/* couldn't get the message: OK if someone else deleted it */
      903 	     if code ^= error_table_$no_message then
      904 		call com_err_ (code, command_name, "Attempting to read message ^24.3b from ^a queue ^d.", message_id,
      905 		     request_type, queue);
      906 	     return;
      907 	end;
      908 
      909 	ft_request_ptr = local_mmi.ms_ptr;
      910 	user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));
      911 
      912 	if (ft_request.hdr_version = queue_msg_hdr_version_1) & (ft_request.version = FT_REQUEST_VERSION_1) then do;
      913 	     supported_version = "1"b;		/* understand this request: check if it's running */
      914 	     if ft_request.state = STATE_RUNNING then do;
      915 		call com_err_ (0, command_name,
      916 		     "IMFT request ^a^[ for ^a^;^s^] is already running and will not be moved.", ft_request.ename,
      917 		     (user_selection ^= USER), user_id);
      918 		go to RETURN_FROM_MOVE_SINGLE_REQUEST;
      919 	     end;
      920 	end;
      921 	else supported_version = "0"b;		/* controls the message that's printed */
      922 
      923 	ft_request.state = STATE_UNPROCESSED;
      924 
      925 	if user_selection = USER then
      926 	     call message_segment_$add_index (target_queue_index, ft_request_ptr, (36 * currentsize (ft_request)),
      927 		((72)"0"b), code);
      928 	else call queue_admin_$add_index (target_queue_index, addr (local_mmi), ((72)"0"b), code);
      929 
      930 	if code ^= 0 then do;			/* couldn't move the request (sigh) */
      931 	     call com_err_ (code, command_name,
      932 		"Unable to move IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] from ^a queue ^d to ^[^a ^;^s]queue ^d."
      933 		, supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
      934 		queue, (request_type ^= target_request_type), target_request_type, target_queue);
      935 	     go to RETURN_FROM_MOVE_SINGLE_REQUEST;
      936 	end;
      937 
      938 	n_requests_moved = n_requests_moved + 1;	/* it now counts as being moved */
      939 
      940 	if long then do;
      941 	     request_id = substr ((request_id_ (ft_request.msg_time)), 7, 8);
      942 	     call ioa_ ("IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] moved from ^a queue ^d; ID: ^a.",
      943 		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
      944 		queue, request_id);
      945 	end;					/* target destination/queue are given in summary message */
      946 
      947 	retry_operation = "0"b;			/* now to try to delete the original copy */
      948 RETRY_DELETE_MESSAGE:
      949 	call message_segment_$delete_index (queue_indeces (queue), message_id, code);
      950 	if ^retry_operation then
      951 	     if code = error_table_$bad_segment then do;
      952 		retry_operation = "1"b;		/* message segment was salvaged: try again */
      953 		go to RETRY_DELETE_MESSAGE;
      954 	     end;
      955 
      956 	if (code ^= 0) & (code ^= error_table_$no_message) then
      957 	     call com_err_ (code, command_name,
      958 		"IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] added to ^a queue ^d but could not be deleted from ^a queue ^d."
      959 		, supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id,
      960 		target_request_type, target_queue, request_type, queue);
      961 
      962 RETURN_FROM_MOVE_SINGLE_REQUEST:
      963 	free ft_request in (system_area);
      964 	ft_request_ptr = null ();
      965 
      966 	return;
      967 
      968      end move_single_request;
      969 
      970 	end MAIN_CIR_MIR_BLOCK;
      971 
      972 /**/
      973 
      974 RETURN_FROM_CIR_MIR_COMMANDS:
      975 	call cleanup_handler ();
      976 
      977 ABORT_ARGUMENT_PARSE:
      978 	return;
      979 
      980 
      981 /* Cleanup after an invocation of cancel_imft_request or move_imft_request */
      982 
      983 cleanup_handler:
      984      procedure ();
      985 
      986 	if ft_request_ptr ^= null () then do;
      987 	     free ft_request in (system_area);
      988 	     ft_request_ptr = null ();
      989 	end;
      990 
      991 	if message_ids_ptr ^= null () then do;
      992 	     call release_temp_segment_ (command_name, message_ids_ptr, (0));
      993 	     message_ids_ptr = null ();
      994 	end;
      995 
      996 	do queue_idx = 1 to max_queues;
      997 	     if queue_indeces (queue_idx) ^= 0 then do;
      998 		call message_segment_$close (queue_indeces (queue_idx), (0));
      999 		queue_indeces (queue_idx) = 0;
     1000 	     end;
     1001 	end;
     1002 
     1003 	if target_queue_index ^= 0 then do;
     1004 	     call message_segment_$close (target_queue_index, (0));
     1005 	     target_queue_index = 0;
     1006 	end;
     1007 
     1008 	return;
     1009 
     1010      end cleanup_handler;
     1011 
     1012 /**/
     1013 
  1     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  1     2 /* format: style3,idind30 */
  1     3 
  1     4 /* structure returned when message is read from a message segment */
  1     5 
  1     6 
  1     7 dcl	mseg_message_info_ptr	pointer;
  1     8 
  1     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  1    10 	  2 version		char (8) aligned,
  1    11 	  2 message_code		fixed bin,
  1    12 	  2 control_flags		unaligned,
  1    13 	    3 own			bit (1),
  1    14 	    3 delete		bit (1),
  1    15 	    3 pad			bit (34),
  1    16 	  2 ms_ptr		ptr,		/* pointer to message */
  1    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  1    18 	  2 ms_id			bit (72),		/* unique ID of message */
  1    19 						/* input in some cases */
  1    20 	  2 ms_access_class		bit (72),		/* message access class */
  1    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  1    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  1    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  1    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  1    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  1    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  1    27 
  1    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  1    29 
  1    30 declare	(
  1    31 	MSEG_READ_FIRST		init (1),
  1    32 	MSEG_READ_LAST		init (2),
  1    33 	MSEG_READ_SPECIFIED		init (3),
  1    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  1    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  1    36 	fixed bin int static options (constant);
  1    37 
  1    38 declare  (MSEG_READ_OWN		init ("1"b),
  1    39 	MSEG_READ_DELETE		init ("01"b)
  1    40 	)			bit (36) aligned internal static options (constant);
  1    41 
  1    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     1014 
     1015 
  2     1 /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  2     2 
  2     3 /* This is the message header used for standard system queue messages, namely:
  2     4*   IO daemon requests, absentee requests, retrieval requests.
  2     5**/
  2     6 
  2     7 /* Written by Jerry Whitmore, Spring 1978.
  2     8*   Modified by T. Casey, November 1978, to add values for state.
  2     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  2    10**/
  2    11 
  2    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  2    13     2 msg_time fixed bin (71),			/* date and time of request */
  2    14     2 hdr_version fixed bin,				/* version of this declaration */
  2    15     2 dirname char (168),				/* directory name */
  2    16     2 ename char (32),				/* entry name of file requested */
  2    17     2 message_type fixed bin,				/* message format descriptor   */
  2    18 						/* 0 = absentee request        */
  2    19 						/* 1 = print request           */
  2    20 						/* 2 = punch request           */
  2    21 						/* 3 = tape request            */
  2    22 						/* 4 = retrieval request       */
  2    23     2 bit_flags,
  2    24       3 delete_sw bit (1) unal,			/* delete file when done */
  2    25       3 notify bit (1) unal,				/* user wants to be notified */
  2    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  2    27       3 padding bit (33) unal,
  2    28     2 state fixed bin,				/* stage of processing after being queued:
  2    29*						   0 = initial unprocessed state, 1 = deferred,
  2    30*						   2 = in state transition, 3 = eligible, 4 = running,
  2    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  2    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  2    33     2 std_length fixed bin,				/* length of std msg for this type */
  2    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  2    35     2 hdr_pad (3) fixed bin;
  2    36 
  2    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  2    38 
  2    39 /* Values for queue_msg_hdr.state */
  2    40 
  2    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  2    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  2    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  2    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  2    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  2    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  2    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  2    48 
  2    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     1016 
     1017 
  3     1 /* BEGIN INCLUDE FILE ... _imft_ft_request.incl.pl1 */
  3     2 
  3     3 /* Created:  April 1982 by G. Palter */
  3     4 /* Modified: March 1983 by Robert Coren, for requests for remote transfer */
  3     5 
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(88-06-22,Beattie), approve(88-08-01,MCR7948),
  3     9*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
  3    10*     Add flags to support extend, update and delete operations.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /* IMFT file transfer request definition */
  3    15 
  3    16 dcl 1 ft_request aligned based (ft_request_ptr),
  3    17       2 header like queue_msg_hdr,
  3    18       2 request,					/* see _imft_ft_commands.incl.pl1 */
  3    19         3 version character (8),
  3    20         3 foreign_user character (32) unaligned,		/* Person.Project at other Multics for reload access check */
  3    21         3 foreign_dirname character (168) unaligned,	/* where to put the branch on the other system */
  3    22         3 foreign_ename character (32) unaligned,		/* ... */
  3    23         3 flags,
  3    24 	4 foreign_user_given bit (1) unaligned,		/* ON => forreign_user different from local user */
  3    25 	4 foreign_path_given bit (1) unaligned,		/* ON => foreign pathname different from local */
  3    26 	4 directory_creation_mode bit (2) unaligned,	/* controls whether directories are replaced/merged */
  3    27 	4 remote_transfer bit (1) unaligned,		/* ON => request for transfer from foreign system */
  3    28 	4 include_files bit (1) unaligned,		/* ON => match files when interpreting starname */
  3    29 	4 include_subtrees bit (1) unaligned,		/* ON => match subtrees when interpreting starname */
  3    30 	4 chase_control bit (2) unaligned,		/* controls chasing of links when submitting remote request */
  3    31 	4 delete bit (1) unaligned,			/* delete source object after good transfer */
  3    32 	4 extend bit (1) unaligned,			/* place this data at end of current segment */
  3    33 	4 update bit (1) unaligned,			/* replace contents of current segment with this data */
  3    34 	4 pad bit (24) unaligned;
  3    35 
  3    36 dcl  ft_request_ptr pointer;
  3    37 
  3    38 dcl  FT_REQUEST_VERSION_1 character (8) static options (constant) initial ("ftr_1.00");
  3    39 
  3    40 dcl  FT_GENERIC_TYPE character (32) static options (constant) initial ("imft");
  3    41 dcl  FT_MESSAGE_TYPE fixed binary static options (constant) initial (5);
  3    42 
  3    43 dcl (REPLACE_DIRECTORIES	initial ("10"b),		/* replace entry on target if namedup and source is a dir */
  3    44      MERGE_DIRECTORIES	initial ("11"b))		/* merge target and source dirs; replace if target not dir */
  3    45 	bit (2) aligned static options (constant);
  3    46 
  3    47 dcl (DEFAULT_CHASE		initial ("00"b),		/* chase non-starnames; don't chase starnames */
  3    48      NEVER_CHASE		initial ("01"b),		/* never chase any links */
  3    49      ALWAYS_CHASE		initial ("10"b))		/* always chase links */
  3    50 	bit (2) aligned static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... _imft_ft_request.incl.pl1 */
     1018 
     1019 
  4     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  4     2 
  4     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  4     4 
  4     5 /* This include file contains branch and link structures returned by
  4     6*   hcs_$status_ and hcs_$status_long. */
  4     7 
  4     8 dcl 1 status_branch aligned based (status_ptr),
  4     9     2 short aligned,
  4    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  4    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  4    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  4    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  4    14       3 dtu bit (36) unaligned,			/* date/time last used */
  4    15       3 mode bit (5) unaligned,			/* caller's effective access */
  4    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  4    17       3 pad1 bit (8) unaligned,
  4    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  4    19 
  4    20 /* Limit of information returned by hcs_$status_ */
  4    21 
  4    22     2 long aligned,
  4    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  4    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  4    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  4    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  4    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  4    28       3 pad2 bit (8) unaligned,
  4    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  4    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  4    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  4    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  4    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  4    34       3 pad3 bit (5) unaligned,
  4    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  4    36       3 uid bit (36) unaligned;			/* unique ID */
  4    37 
  4    38 dcl 1 status_link aligned based (status_ptr),
  4    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  4    40     2 nnames fixed bin (16) unaligned unsigned,
  4    41     2 names_relp bit (18) unaligned,
  4    42     2 dtem bit (36) unaligned,
  4    43     2 dtd bit (36) unaligned,
  4    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  4    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  4    46 
  4    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  4    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  4    49 						/* array of names returned */
  4    50      status_pathname character (status_link.pathname_length) aligned
  4    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  4    52 						/* link target path */
  4    53      status_area_ptr pointer,
  4    54      status_ptr pointer;
  4    55 
  4    56 dcl (Link initial (0),
  4    57      Segment initial (1),
  4    58      Directory initial (2)) fixed bin internal static options (constant);
  4    59 						/* values for type fields declared above */
  4    60 
  4    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1020 
     1021 
  5     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  5     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  5     3 /*	version number changed to 4, 08/10/78 WOS */
  5     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  5     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  5     6 
  5     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  5     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  5     9     2 switches aligned,                                     /* various bit switch values */
  5    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  5    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  5    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  5    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  5    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  5    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  5    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  5    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  5    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  5    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  5    20 
  5    21 /*  Limit of data defined for version 2 */
  5    22 
  5    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  5    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  5    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  5    26 						/* minimum of 30 seconds required for repeat */
  5    27 						/* otherwise, no repeat will occur */
  5    28 /* Limit of data defined for version 4 */
  5    29 
  5    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  5    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  5    32 
  5    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  5    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  5    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  5    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  5    37 
  5    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     1022 
     1023 
     1024      end imft_cir_mir_commands_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/14/88  1214.5  imft_cir_mir_commands_.pl1        >special_ldd>install>MR12.2-1165>imft_cir_mir_commands_.pl1
1014         1    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
1016         2    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
1018         3    10/14/88  1212.4  _imft_ft_request.incl.pl1         >special_ldd>install>MR12.2-1165>_imft_ft_request.incl.pl1
1020         4    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
1022         5    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALL                                    constant        fixed bin(2,0)           initial dcl 86 ref 297
A_EXTENDED_ACCESS               000132 constant        bit(36)                  initial dcl 100 set ref 537* 574
CANCEL                                 constant        fixed bin(1,0)           initial dcl 82 ref 162 628 656 666
CANCEL_IMFT_REQUEST             000024 constant        char(32)                 initial packed unaligned dcl 109 ref 163
CHASE                           000144 constant        fixed bin(1,0)           initial dcl 106 set ref 401* 737*
ENTRY                                  constant        fixed bin(2,0)           initial dcl 86 ref 359 643 656 722 752 761
FT_GENERIC_TYPE                 000000 constant        char(32)                 initial packed unaligned dcl 3-40 ref 263 332
FT_REQUEST_VERSION_1            000010 constant        char(8)                  initial packed unaligned dcl 3-38 ref 714 834 912
ID                                     constant        fixed bin(2,0)           initial dcl 86 ref 377 619
MATCH_ALL                              constant        fixed bin(2,0)           initial dcl 86 ref 627 722
MATCH_ONE                              constant        fixed bin(2,0)           initial dcl 86 ref 223 652 862
MATCH_SUBSET                           constant        fixed bin(2,0)           initial dcl 86 ref 378
MOVE                                   constant        fixed bin(1,0)           initial dcl 82 ref 173 309 314 339 424 513 522 536
                                                                                  676
MOVE_IMFT_REQUEST               000014 constant        char(32)                 initial packed unaligned dcl 110 ref 174
MSEG_MESSAGE_INFO_V1            000012 constant        char(8)                  initial dcl 1-28 ref 213
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 1-30 ref 777
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 1-30 ref 697
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 1-30 ref 814 892
NONE                                   constant        fixed bin(2,0)           initial dcl 86 ref 222 617
O_EXTENDED_ACCESS                      constant        bit(36)                  initial dcl 100 ref 500 574
PATH                                   constant        fixed bin(2,0)           initial dcl 86 ref 399 624 628 643 656 734 761
RD_EXTENDED_ACCESS                     constant        bit(36)                  initial dcl 100 ref 503
STATE_RUNNING                          constant        fixed bin(17,0)          initial dcl 2-45 ref 836 914
STATE_UNPROCESSED                      constant        fixed bin(17,0)          initial dcl 2-41 ref 923
SUBSET                                 constant        fixed bin(2,0)           initial dcl 86 ref 300 628 716 727
USER                                   constant        fixed bin(2,0)           initial dcl 86 ref 209 288 499 513 628 837 855 862
                                                                                  915 925 931 942 956
a_dirname                       000326 automatic       char(168)                packed unaligned dcl 67 set ref 388* 395* 395* 401*
                                                                                  624* 628* 643* 643* 656* 656* 745
access_required                 000430 automatic       bit(36)                  dcl 75 set ref 500* 503* 524* 532*
add_entry                       000424 automatic       entry variable           dcl 73 set ref 513* 516*
addr                                                   builtin function         dcl 152 ref 401 401 608 628 628 699 699 737 737 780
                                                                                  780 817 817 895 895 928 928
after                                                  builtin function         dcl 152 ref 201 291 291 296 296 303 372 372 375 719
                                                                                  730
all_queues                      000271 automatic       bit(1)                   dcl 59 set ref 519* 628* 643* 656* 862 862*
an_ename                        000400 automatic       char(32)                 packed unaligned dcl 68 set ref 352* 353* 355* 388*
                                                                                  393* 395* 395* 624* 643* 643* 656* 656* 735*
answer                          000431 automatic       varying char(16)         dcl 77 set ref 628* 633
answer_iocbp              6     000442 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
argument                               based           char                     packed unaligned dcl 36 set ref 239 239 239 245 245
                                                                                  270 270 282 282 285 285 286 286 288 289 309 309
                                                                                  314 314 339 339 351 351 363 383* 388* 390* 460
                                                                                  477* 482 624* 643* 656* 753* 758*
argument_idx                    000166 automatic       fixed bin(17,0)          dcl 40 set ref 231* 233* 235* 359 360 377 378 379
                                                                                  399 400 402* 462 468* 468 470* 472* 615* 617 619
                                                                                  622* 624 627 628 643 643 652 656 656* 722 722 734
                                                                                  741 741 745 752 761 761 862
argument_lth                    000162 automatic       fixed bin(21,0)          dcl 39 set ref 233* 239 239 239 245 245 270 270 282
                                                                                  282 285 285 286 286 288 289 309 309 314 314 339
                                                                                  339 351 351 363 383 383 388 388 390 390 460 470*
                                                                                  476 477 477 482 622* 624 624 643 643 656 656 753
                                                                                  753 758 758
argument_ptr                    000156 automatic       pointer                  dcl 38 set ref 233* 239 239 239 245 245 270 270 282
                                                                                  282 285 285 286 286 288 289 309 309 314 314 339
                                                                                  339 351 351 363 383 388 390 460 470* 477 482 622*
                                                                                  624 643 656 753 758
before                                                 builtin function         dcl 152 ref 295 295 301 373 717 728
check_star_name_$entry          000032 constant        entry                    external dcl 120 ref 353 393
cleanup                         000000 stack reference condition                dcl 150 ref 497
code                            000436 automatic       fixed bin(35,0)          dcl 79 set ref 178* 180 181* 233* 234 235* 253* 254
                                                                                  255 259* 272* 273 322* 323 324 328* 341* 342 353*
                                                                                  354 354 354 355* 360 388* 389 390* 393* 394 394
                                                                                  394 395* 400 401* 402 402 415* 416 433* 434 470*
                                                                                  471 472* 560* 561 562* 566* 567 568* 583* 584 597*
                                                                                  598 599* 699* 700 707 735* 736 737* 738 738 753*
                                                                                  754 780* 781 788 788 789* 817* 818 824 825 825*
                                                                                  846* 848 854 854 855* 895* 896 902 903 903* 925*
                                                                                  928* 930 931* 948* 950 956 956 956*
com_err_                        000034 constant        entry                    external dcl 121 ref 181 235 255 259 264 274 292 324
                                                                                  328 333 343 355 367 383 390 395 410 419 426 437
                                                                                  442 463 472 477 509 562 568 574 599 643 656 789
                                                                                  825 837 855 903 915 931 956
com_err_$suppress_name          000036 constant        entry                    external dcl 122 ref 186
command_name                    000170 automatic       char(32)                 packed unaligned dcl 43 set ref 163* 174* 181* 186*
                                                                                  186* 235* 255* 259* 264* 274* 292* 324* 328* 333*
                                                                                  343* 355* 367* 383* 390* 395* 410* 419* 426* 437*
                                                                                  442* 463* 472* 477* 509* 562* 568* 574* 597* 599*
                                                                                  608 628* 643* 656* 789* 825* 837* 855* 903* 915*
                                                                                  931* 956* 992*
command_query_                  000040 constant        entry                    external dcl 123 ref 628
control_argument                000144 automatic       char(32)                 packed unaligned dcl 458 set ref 460* 463* 477*
control_flags             3     000114 automatic       structure                level 2 packed packed unaligned dcl 27
convert                                                builtin function         dcl 152 ref 558
cp_escape_control         1(02) 000442 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
cu_$arg_count                   000042 constant        entry                    external dcl 124 ref 178
cu_$arg_list_ptr                000044 constant        entry                    external dcl 125 ref 192
cu_$arg_ptr_rel                 000046 constant        entry                    external dcl 126 ref 233 470 605 622
currentsize                                            builtin function         dcl 152 ref 925
cv_dec_check_                   000050 constant        entry                    external dcl 127 ref 272 341
default_queue                   000242 automatic       fixed bin(17,0)          dcl 56 set ref 415* 417 433* 435
dir_uids                        000100 automatic       bit(36)                  array dcl 220 set ref 224* 402* 741 741 745
dirname                   3            based           char(168)                level 3 dcl 3-16 ref 737 745
ename                    55            based           char(32)                 level 3 dcl 3-16 set ref 735 753 837* 855* 862* 915*
                                                                                  931* 942* 956*
entry                     1     000200 automatic       fixed bin(17,0)          level 2 dcl 45 set ref 358* 358 407 409 605
error_table_$bad_segment        000012 external static fixed bin(35,0)          dcl 115 ref 700 781 818 848 896 950
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 115 set ref 383*
error_table_$id_not_found       000016 external static fixed bin(35,0)          dcl 115 ref 255 324
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 115 set ref 410* 426*
error_table_$moderr             000022 external static fixed bin(35,0)          dcl 115 set ref 574*
error_table_$no_message         000024 external static fixed bin(35,0)          dcl 115 ref 788 825 854 903 956
error_table_$no_s_permission    000026 external static fixed bin(35,0)          dcl 115 ref 402 738
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 115 set ref 463*
expand_pathname_                000052 constant        entry                    external dcl 128 ref 388 624
explanation_len          14     000442 automatic       fixed bin(21,0)          initial level 2 dcl 5-7 set ref 5-7*
explanation_ptr          12     000442 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
foreign_system                  000217 automatic       char(24)                 packed unaligned dcl 51 set ref 201* 202 202* 204
                                                                                  247* 249 251 255* 259* 264*
ft_request                             based           structure                level 1 dcl 3-16 set ref 771 867 925 962 987
ft_request_ptr                  000440 automatic       pointer                  dcl 3-36 set ref 495* 711* 714 714 735 737 745 753
                                                                                  758 763 771 773* 831* 834 834 836 837 855 862 867
                                                                                  869* 909* 912 912 914 915 923 925* 925 931 941 942
                                                                                  956 962 964* 986 987 988*
function                        000167 automatic       fixed bin(1,0)           dcl 42 set ref 162* 173* 309 314 339 424 513 522 536
                                                                                  628 656 666 676
generic_type                    000250 automatic       char(32)                 packed unaligned dcl 58 set ref 253* 263 322* 332
get_system_free_area_           000054 constant        entry                    external dcl 129 ref 492
get_temp_segment_               000056 constant        entry                    external dcl 130 ref 597
hcs_$status_long                000060 constant        entry                    external dcl 131 ref 401 737
hdr_version               2            based           fixed bin(17,0)          level 3 dcl 3-16 ref 714 834 912
header                                 based           structure                level 2 dcl 3-16
id                        2     000200 automatic       fixed bin(17,0)          level 2 in structure "n_identifiers" dcl 45
                                                                                  in procedure "imft_cir_mir_commands_" set ref 376*
                                                                                  376 407 409 605
id                                     based           bit(72)                  array level 2 in structure "message_ids" dcl 29
                                                                                  in procedure "imft_cir_mir_commands_" set ref 768*
                                                                                  811 889
id_qualifier                           based           char                     packed unaligned dcl 37 set ref 619 643 643* 652 656
                                                                                  656* 761 763*
id_qualifier_idx                000165 automatic       fixed bin(17,0)          dcl 40 set ref 225* 379 379* 605*
id_qualifier_lth                000163 automatic       fixed bin(21,0)          dcl 39 set ref 605* 609* 619 643 643 643 652 656 656
                                                                                  656 761 763 763
id_qualifier_ptr                000160 automatic       pointer                  dcl 38 set ref 605* 608* 619 643 643 652 656 656 761
                                                                                  763
identifier_types                000100 automatic       fixed bin(2,0)           array dcl 218 set ref 222* 359* 377* 399* 617 619
                                                                                  624 628 643 643 656 656 722 734 752 761 761
imft_data_$queue_dirname        000010 external static char(168)                packed unaligned dcl 112 set ref 560* 562* 562* 568*
                                                                                  568*
imft_default_rqt_               000062 constant        entry                    external dcl 132 ref 199
index                                                  builtin function         dcl 152 ref 239
ioa_                            000064 constant        entry                    external dcl 133 ref 676 862 942
iod_info_$generic_type          000066 constant        entry                    external dcl 134 ref 253 322
iod_info_$queue_data            000070 constant        entry                    external dcl 135 ref 415 433
length                                                 builtin function         dcl 152 ref 373 373 375 375 476 477 477 712 832 910
linkage_error                   000000 stack reference condition                dcl 150 ref 507
literal_sw                1(05) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
local_mmi                       000114 automatic       structure                level 1 dcl 27 set ref 212* 699 699 780 780 817 817
                                                                                  895 895 928 928
local_sb                        000102 automatic       structure                level 1 dcl 26 set ref 401 401 737 737
long                      4     000102 automatic       structure                level 2 in structure "local_sb" dcl 26 in procedure
                                                                                  "imft_cir_mir_commands_"
long                            000273 automatic       bit(1)                   dcl 62 in procedure "imft_cir_mir_commands_" set ref
                                                                                  210* 285* 286* 643 676 862 940
match_any_person                000324 automatic       bit(1)                   dcl 65 set ref 295* 297
match_any_project               000325 automatic       bit(1)                   dcl 65 set ref 296* 297
match_request_id_               000072 constant        entry                    external dcl 136 ref 758 763
match_star_name_                000074 constant        entry                    external dcl 137 ref 735 753
max_queues                      000243 automatic       fixed bin(17,0)          dcl 56 set ref 415* 418 419* 419 521 638 996
message_code              2     000114 automatic       fixed bin(17,0)          level 2 dcl 27 set ref 697* 777* 814* 892*
message_id                      000262 automatic       bit(72)                  dcl 884 in procedure "move_single_request" set ref
                                                                                  889* 894 903* 931* 942* 948* 956*
message_id                      000234 automatic       bit(72)                  dcl 806 in procedure "cancel_single_request" set ref
                                                                                  811* 816 825* 846* 855* 862*
message_ids                            based           structure                array level 1 dcl 29
message_ids_ptr                 000146 automatic       pointer                  dcl 33 set ref 495* 597* 768 769 810 811 888 889 991
                                                                                  992* 993*
message_idx                     000153 automatic       fixed bin(17,0)          dcl 34 set ref 665* 810 811 888 889
message_segment_$add_index      000076 constant        entry                    external dcl 138 ref 513 925
message_segment_$close          000100 constant        entry                    external dcl 139 ref 578 790 998 1004
message_segment_$delete_index   000102 constant        entry                    external dcl 140 ref 846 948
message_segment_$get_message_count_index
                                000104 constant        entry                    external dcl 141 ref 583
message_segment_$get_mode_index 000106 constant        entry                    external dcl 142 ref 566
message_segment_$open           000112 constant        entry                    external dcl 144 ref 560
message_segment_$read_message_index
                                000110 constant        entry                    external dcl 143 ref 699 780 817 895
ms_id                     7     000114 automatic       bit(72)                  level 2 dcl 27 set ref 709 768 779* 816* 894*
ms_ptr                    4     000114 automatic       pointer                  level 2 dcl 27 set ref 711 831 909
mseg_message_info                      based           structure                level 1 dcl 1-9
msg_time                               based           fixed bin(71,0)          level 3 dcl 3-16 set ref 758* 763* 941*
n_arguments                     000164 automatic       fixed bin(17,0)          dcl 40 set ref 178* 185 218 219 220 231 462 615
n_identifiers                   000200 automatic       structure                level 1 dcl 45 set ref 197*
n_previous_requests             000152 automatic       fixed bin(17,0)          dcl 34 set ref 537* 676 676*
n_requests_moved                000151 automatic       fixed bin(17,0)          dcl 34 set ref 603* 676 676* 676 938* 938
n_requests_selected             000150 automatic       fixed bin(17,0)          dcl 34 set ref 636* 642 652 656* 665 766* 766 768
                                                                                  769
null                                                   builtin function         dcl 152 ref 5-7 5-7 5-7 401 401 495 737 737 773 869
                                                                                  964 986 988 991 993
opened_a_queue                  000270 automatic       bit(1)                   dcl 59 set ref 520* 526* 528
own                       3     000114 automatic       bit(1)                   level 3 packed packed unaligned dcl 27 set ref 501*
p_access_required                      parameter       bit(36)                  dcl 551 ref 546 573 573 574 574
p_arg_description                      parameter       char                     packed unaligned dcl 456 set ref 453 463*
p_argument                             parameter       char                     packed unaligned dcl 457 set ref 453 476 477 477
                                                                                  482*
p_get_message_count                    parameter       bit(1)                   dcl 552 ref 546 582
p_message_count                        parameter       fixed bin(17,0)          dcl 550 set ref 546 583* 584*
p_queue                                parameter       fixed bin(17,0)          dcl 550 in procedure "open_single_queue" set ref 546
                                                                                  558 574*
p_queue                                parameter       fixed bin(17,0)          dcl 688 in procedure "scan_single_queue" set ref 685
                                                                                  699 769 780 789* 790 791
p_queue_index                          parameter       fixed bin(17,0)          dcl 550 set ref 546 560* 566* 578* 579* 583*
p_request_type                         parameter       char(24)                 packed unaligned dcl 549 set ref 546 558 574*
padding                   1(07) 000442 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
path                            000200 automatic       fixed bin(17,0)          level 2 dcl 45 set ref 398* 398 407 409 605
pathname_                       000114 constant        entry                    external dcl 145 ref 395 395 562 562 568 568 643 643
                                                                                  656 656
person_id                       000304 automatic       char(32)                 packed unaligned dcl 64 set ref 301* 302 302* 305
                                                                                  717 717 728 728
previous_message_id             000212 automatic       bit(72)                  dcl 691 set ref 709* 779
project_id                      000314 automatic       char(32)                 packed unaligned dcl 64 set ref 303* 304 304* 305
                                                                                  719 719 730 730
prompt_after_explanation
                          1(06) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
query_code                3     000442 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
query_info                      000442 automatic       structure                level 1 dcl 5-7 set ref 628 628
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 5-35 ref 612
question_iocbp            4     000442 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
queue                           000264 automatic       fixed bin(17,0)          dcl 885 in procedure "move_single_request" set ref
                                                                                  888* 895 903* 931* 942* 948 956*
queue                           000236 automatic       fixed bin(17,0)          dcl 807 in procedure "cancel_single_request" set ref
                                                                                  810* 817 825* 846 855* 862*
queue                     2            based           fixed bin(17,0)          array level 2 in structure "message_ids" dcl 29
                                                                                  in procedure "imft_cir_mir_commands_" set ref 769*
                                                                                  810 888
queue                           000240 automatic       fixed bin(17,0)          dcl 56 in procedure "imft_cir_mir_commands_" set ref
                                                                                  206* 272* 279 279 282* 417 417* 418 419* 441 442*
                                                                                  518 522 532* 532 533 628 628* 643* 656*
queue_admin_$add_index          000116 constant        entry                    external dcl 146 ref 516 928
queue_ename                     000162 automatic       char(32)                 packed unaligned dcl 554 set ref 558* 560* 562* 562*
                                                                                  568* 568*
queue_idx                       000245 automatic       fixed bin(17,0)          dcl 56 set ref 521* 524* 524 526* 638* 639 639* 996*
                                                                                  997 998 999*
queue_indeces                   000233 automatic       fixed bin(17,0)          array dcl 52 set ref 494* 524* 526 532* 533 639 699*
                                                                                  780* 790* 791* 817* 846* 895* 948* 997 998* 999*
queue_mode                      000172 automatic       bit(36)                  dcl 556 set ref 566* 573
queue_msg_hdr                          based           structure                level 1 dcl 2-12
queue_msg_hdr_version_1                constant        fixed bin(17,0)          initial dcl 2-37 ref 714 834 912
queue_picture                          automatic       picture(1)               packed unaligned dcl 555 ref 558
queue_string                    000260 automatic       char(32)                 packed unaligned dcl 58 set ref 271* 272* 274* 340*
                                                                                  341* 343*
release_temp_segment_           000120 constant        entry                    external dcl 147 ref 992
remote                          000246 automatic       bit(1)                   dcl 57 set ref 205* 241* 246* 249 255* 259* 264*
                                                                                  419* 425 425
repeat_time              10     000442 automatic       fixed bin(71,0)          initial level 2 dcl 5-7 set ref 5-7*
request                  76            based           structure                level 2 dcl 3-16
request_id                      000415 automatic       varying char(19)         dcl 71 in procedure "imft_cir_mir_commands_" set ref
                                                                                  365* 366 367* 372 373 375
request_id                      000260 automatic       char(8)                  packed unaligned dcl 883 in procedure
                                                                                  "move_single_request" set ref 941* 942*
request_id_                     000122 constant        entry                    external dcl 148 ref 941
request_id_nonvarying           000410 automatic       char(19)                 packed unaligned dcl 70 set ref 364* 365
request_type                    000203 automatic       char(24)                 packed unaligned dcl 50 set ref 199* 201 202 249*
                                                                                  251* 253* 415* 419* 432 441 442* 522 524* 532*
                                                                                  628* 643* 656* 789* 825* 855* 903* 931* 931 942*
                                                                                  956*
request_uid                     000214 automatic       bit(36)                  dcl 692 set ref 738* 740* 741 741 745
retry_operation                 000237 automatic       bit(1)                   dcl 808 in procedure "cancel_single_request" set ref
                                                                                  813* 818 820* 845* 848 850*
retry_operation                 000265 automatic       bit(1)                   dcl 886 in procedure "move_single_request" set ref
                                                                                  891* 896 898* 947* 950 952*
retry_read                      000215 automatic       bit(1)                   dcl 693 set ref 695* 700 702* 775* 781 783*
rtrim                                                  builtin function         dcl 152 ref 305 365 558 712 832 910
sender_id                13     000114 automatic       char(32)                 level 2 packed packed unaligned dcl 27 set ref 712
                                                                                  712 832 832 910 910
star_types                      000100 automatic       fixed bin(2,0)           array dcl 219 set ref 223* 360* 378* 400* 627 652
                                                                                  722 862
state                    67            based           fixed bin(17,0)          level 3 dcl 3-16 set ref 836 914 923*
status_branch                          based           structure                level 1 dcl 4-8
status_code               2     000442 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
substr                                                 builtin function         dcl 152 ref 712 832 910 941
supported_version               000266 automatic       bit(1)                   dcl 886 in procedure "move_single_request" set ref
                                                                                  913* 921* 931* 942* 956*
supported_version               000240 automatic       bit(1)                   dcl 808 in procedure "cancel_single_request" set ref
                                                                                  835* 843* 855* 862*
suppress_name_sw          1(01) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7* 613*
suppress_spacing          1(04) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
switches                  1     000442 automatic       structure                level 2 dcl 5-7
system_area                            based           area(1024)               dcl 23 ref 771 867 962 987
system_area_ptr                 000100 automatic       pointer                  dcl 24 set ref 492* 699* 771 780* 817* 867 895* 962
                                                                                  987
target_foreign_system           000225 automatic       char(24)                 packed unaligned dcl 51 set ref 204* 316* 318 320
                                                                                  324* 328* 333*
target_max_queues               000244 automatic       fixed bin(17,0)          dcl 56 set ref 433* 436 437* 437
target_queue                    000241 automatic       fixed bin(17,0)          dcl 56 set ref 207* 341* 348 348 435 435* 436 437*
                                                                                  441 522 537* 676* 931* 956*
target_queue_index              000237 automatic       fixed bin(17,0)          dcl 52 set ref 494* 537* 539 925* 928* 1003 1004*
                                                                                  1005*
target_remote                   000247 automatic       bit(1)                   dcl 57 set ref 205* 310* 315* 318 324* 328* 333* 425
                                                                                  425 426* 426* 437*
target_request_type             000211 automatic       char(24)                 packed unaligned dcl 50 set ref 200* 318* 320* 322*
                                                                                  432 432* 433* 437* 441 522 537* 676* 931 931* 956*
the_argument_list               000154 automatic       pointer                  dcl 38 set ref 192* 233* 470* 605* 622*
uid                      11     000102 automatic       bit(36)                  level 3 packed packed unaligned dcl 26 set ref 402
                                                                                  738
user_id                         000202 automatic       char(30)                 packed unaligned dcl 690 in procedure
                                                                                  "scan_single_queue" set ref 712* 717 719 728 730
user_id                         000274 automatic       char(32)                 packed unaligned dcl 64 in procedure
                                                                                  "imft_cir_mir_commands_" set ref 290* 291 292* 295
                                                                                  295 296 296 301 303 305* 628*
user_id                         000250 automatic       char(30)                 packed unaligned dcl 882 in procedure
                                                                                  "move_single_request" set ref 910* 915* 931* 942*
                                                                                  956*
user_id                         000224 automatic       char(30)                 packed unaligned dcl 805 in procedure
                                                                                  "cancel_single_request" set ref 832* 837* 855*
                                                                                  862*
user_selection                  000272 automatic       fixed bin(2,0)           dcl 61 set ref 209* 288* 297* 300* 499 513 628 628
                                                                                  716 727 837 855 862 915 925 931 942 956
verify                                                 builtin function         dcl 152 ref 366
version                         000442 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "imft_cir_mir_commands_" set ref 612*
version                         000114 automatic       char(8)                  level 2 in structure "local_mmi" dcl 27 in procedure
                                                                                  "imft_cir_mir_commands_" set ref 213*
version                  76            based           char(8)                  level 3 in structure "ft_request" dcl 3-16
                                                                                  in procedure "imft_cir_mir_commands_" ref 714 834
                                                                                  912
yes_or_no_sw              1     000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7* 613*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALWAYS_CHASE                           internal static bit(2)                   initial dcl 3-47
DEFAULT_CHASE                          internal static bit(2)                   initial dcl 3-47
Directory                              internal static fixed bin(17,0)          initial dcl 4-56
FT_MESSAGE_TYPE                        internal static fixed bin(17,0)          initial dcl 3-41
Link                                   internal static fixed bin(17,0)          initial dcl 4-56
MERGE_DIRECTORIES                      internal static bit(2)                   initial dcl 3-43
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 1-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 1-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 1-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 1-38
NEVER_CHASE                            internal static bit(2)                   initial dcl 3-47
REPLACE_DIRECTORIES                    internal static bit(2)                   initial dcl 3-43
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 2-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 2-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 2-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 2-44
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 2-43
Segment                                internal static fixed bin(17,0)          initial dcl 4-56
mseg_message_info_ptr                  automatic       pointer                  dcl 1-7
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 5-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 5-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 5-36
status_area_ptr                        automatic       pointer                  dcl 4-47
status_entry_names                     based           char(32)                 array dcl 4-47
status_link                            based           structure                level 1 dcl 4-38
status_pathname                        based           char                     dcl 4-47
status_ptr                             automatic       pointer                  dcl 4-47

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_ARGUMENT_PARSE            011204 constant        label                    dcl 977 ref 465 473 479
ADD_THIS_MESSAGE                007517 constant        label                    dcl 766 ref 724
BEGIN_PROCESSING                001362 constant        label                    dcl 178 ref 164 175
FOREIGN_SYSTEM                  001756 constant        label                    dcl 247 ref 242
INVALID_DESTINATION_SPECIFICATION
                                002057 constant        label                    dcl 255 ref 416
INVALID_QUEUE_SPECIFICATION     002276 constant        label                    dcl 274 ref 279
INVALID_REQUEST_ID              003503 constant        label                    dcl 367 ref 372 373 375
INVALID_TARGET_DESTINATION_SPECIFICATION
                                003021 constant        label                    dcl 324 ref 434
INVALID_TARGET_QUEUE_SPECIFICATION
                                003243 constant        label                    dcl 343 ref 348
MAIN_CIR_MIR_BLOCK              001552 constant        label                    dcl 215
PRINT_USAGE_MESSAGE             001415 constant        label                    dcl 186 ref 407
PROCESS_NEXT_IDENTIFIER         006062 constant        label                    dcl 673 ref 633 649 662
READ_THE_MESSAGE                007703 constant        label                    dcl 814 in procedure "cancel_single_request" ref 821
READ_THE_MESSAGE                010346 constant        label                    dcl 892 in procedure "move_single_request" ref 899
RETRY_DELETE_MESSAGE            011043 constant        label                    dcl 948 in procedure "move_single_request" ref 953
RETRY_DELETE_MESSAGE            010116 constant        label                    dcl 846 in procedure "cancel_single_request" ref 851
RETRY_FIRST_READ                007013 constant        label                    dcl 697 ref 703
RETRY_READ_NEXT_MESSAGE         007543 constant        label                    dcl 777 ref 784
RETURN_FROM_CANCEL_SINGLE_REQUEST
                                010323 constant        label                    dcl 867 ref 840 859
RETURN_FROM_CIR_MIR_COMMANDS    011200 constant        label                    dcl 974 ref 510 528 533 539 563 570 600
RETURN_FROM_MOVE_SINGLE_REQUEST 011171 constant        label                    dcl 962 ref 918 935
SKIP_THIS_MESSAGE               007534 constant        label                    dcl 771 ref 717 719 722 728 730 736 741 745 745 754
                                                                                  758 763
TARGET_FOREIGN_SYSTEM           002720 constant        label                    dcl 316 ref 311
cancel_imft_request             001321 constant        entry                    external dcl 158
cancel_single_request           007667 constant        entry                    internal dcl 802 ref 666
cir                             001311 constant        entry                    external dcl 158
cleanup_handler                 011206 constant        entry                    internal dcl 983 ref 497 974
get_next_argument               006146 constant        entry                    internal dcl 453 ref 247 271 290 316 340 352 364
imft_cir_mir_commands_          001301 constant        entry                    external dcl 19
mir                             001336 constant        entry                    external dcl 169
move_imft_request               001346 constant        entry                    external dcl 169
move_single_request             010332 constant        entry                    internal dcl 879 ref 668
open_single_queue               006376 constant        entry                    internal dcl 546 ref 524 532 537
scan_single_queue               007010 constant        entry                    internal dcl 685 ref 639

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         ref 212

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12300       12424   11547       12310
Length     13070   11547       124         430     530           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
imft_cir_mir_commands_              354 external procedure  is an external procedure.  
begin block on line 215             974 begin block         uses auto adjustable storage, and enables or reverts conditions.  
get_next_argument                       internal procedure  shares stack frame of begin block on line 215.  
on unit on line 497                  64 on unit               
on unit on line 507                  96 on unit               
open_single_queue                       internal procedure  shares stack frame of begin block on line 215.  
scan_single_queue                       internal procedure  shares stack frame of begin block on line 215.  
cancel_single_request                   internal procedure  shares stack frame of begin block on line 215.  
move_single_request                     internal procedure  shares stack frame of begin block on line 215.  
cleanup_handler                      80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 215  000100 star_types                  begin block on line 215
                         000100 dir_uids                    begin block on line 215
                         000100 identifier_types            begin block on line 215
                         000144 control_argument            get_next_argument
                         000162 queue_ename                 open_single_queue
                         000172 queue_mode                  open_single_queue
                         000202 user_id                     scan_single_queue
                         000212 previous_message_id         scan_single_queue
                         000214 request_uid                 scan_single_queue
                         000215 retry_read                  scan_single_queue
                         000224 user_id                     cancel_single_request
                         000234 message_id                  cancel_single_request
                         000236 queue                       cancel_single_request
                         000237 retry_operation             cancel_single_request
                         000240 supported_version           cancel_single_request
                         000250 user_id                     move_single_request
                         000260 request_id                  move_single_request
                         000262 message_id                  move_single_request
                         000264 queue                       move_single_request
                         000265 retry_operation             move_single_request
                         000266 supported_version           move_single_request
imft_cir_mir_commands_   000100 system_area_ptr             imft_cir_mir_commands_
                         000102 local_sb                    imft_cir_mir_commands_
                         000114 local_mmi                   imft_cir_mir_commands_
                         000146 message_ids_ptr             imft_cir_mir_commands_
                         000150 n_requests_selected         imft_cir_mir_commands_
                         000151 n_requests_moved            imft_cir_mir_commands_
                         000152 n_previous_requests         imft_cir_mir_commands_
                         000153 message_idx                 imft_cir_mir_commands_
                         000154 the_argument_list           imft_cir_mir_commands_
                         000156 argument_ptr                imft_cir_mir_commands_
                         000160 id_qualifier_ptr            imft_cir_mir_commands_
                         000162 argument_lth                imft_cir_mir_commands_
                         000163 id_qualifier_lth            imft_cir_mir_commands_
                         000164 n_arguments                 imft_cir_mir_commands_
                         000165 id_qualifier_idx            imft_cir_mir_commands_
                         000166 argument_idx                imft_cir_mir_commands_
                         000167 function                    imft_cir_mir_commands_
                         000170 command_name                imft_cir_mir_commands_
                         000200 n_identifiers               imft_cir_mir_commands_
                         000203 request_type                imft_cir_mir_commands_
                         000211 target_request_type         imft_cir_mir_commands_
                         000217 foreign_system              imft_cir_mir_commands_
                         000225 target_foreign_system       imft_cir_mir_commands_
                         000233 queue_indeces               imft_cir_mir_commands_
                         000237 target_queue_index          imft_cir_mir_commands_
                         000240 queue                       imft_cir_mir_commands_
                         000241 target_queue                imft_cir_mir_commands_
                         000242 default_queue               imft_cir_mir_commands_
                         000243 max_queues                  imft_cir_mir_commands_
                         000244 target_max_queues           imft_cir_mir_commands_
                         000245 queue_idx                   imft_cir_mir_commands_
                         000246 remote                      imft_cir_mir_commands_
                         000247 target_remote               imft_cir_mir_commands_
                         000250 generic_type                imft_cir_mir_commands_
                         000260 queue_string                imft_cir_mir_commands_
                         000270 opened_a_queue              imft_cir_mir_commands_
                         000271 all_queues                  imft_cir_mir_commands_
                         000272 user_selection              imft_cir_mir_commands_
                         000273 long                        imft_cir_mir_commands_
                         000274 user_id                     imft_cir_mir_commands_
                         000304 person_id                   imft_cir_mir_commands_
                         000314 project_id                  imft_cir_mir_commands_
                         000324 match_any_person            imft_cir_mir_commands_
                         000325 match_any_project           imft_cir_mir_commands_
                         000326 a_dirname                   imft_cir_mir_commands_
                         000400 an_ename                    imft_cir_mir_commands_
                         000410 request_id_nonvarying       imft_cir_mir_commands_
                         000415 request_id                  imft_cir_mir_commands_
                         000424 add_entry                   imft_cir_mir_commands_
                         000430 access_required             imft_cir_mir_commands_
                         000431 answer                      imft_cir_mir_commands_
                         000436 code                        imft_cir_mir_commands_
                         000440 ft_request_ptr              imft_cir_mir_commands_
                         000442 query_info                  imft_cir_mir_commands_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   enter_begin_block
leave_begin_block   call_ext_out_desc   call_ext_out        call_int_this       call_int_other      begin_return_mac
return_mac          tra_ext_1           alloc_auto_adj      enable_op           shorten_stack       ext_entry
int_entry           set_chars_eis       op_freen_           index_after_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      com_err_$suppress_name        command_query_
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel               cv_dec_check_
expand_pathname_              get_system_free_area_         get_temp_segment_             hcs_$status_long
imft_default_rqt_             ioa_                          iod_info_$generic_type        iod_info_$queue_data
match_request_id_             match_star_name_              message_segment_$add_index    message_segment_$close
message_segment_$delete_index message_segment_$get_message_count_index
message_segment_$get_mode_index                             message_segment_$open
message_segment_$read_message_index                         pathname_                     queue_admin_$add_index
release_temp_segment_         request_id_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$badopt           error_table_$id_not_found     error_table_$inconsistent
error_table_$moderr           error_table_$no_message       error_table_$no_s_permission  error_table_$noarg
imft_data_$queue_dirname




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5    7 001246        19 001300       158 001307       162 001327       163 001331       164 001334       169 001335
    173 001354       174 001356       175 001361       178 001362       180 001373       181 001375       182 001412
    185 001413       186 001415       189 001445       192 001446       197 001455       199 001460       200 001501
    201 001505       202 001522       204 001531       205 001534       206 001536       207 001540       209 001541
    210 001543       212 001545       213 001550       215 001552       218 001555       219 001562       220 001566
    222 001572       223 001604       224 001616       225 001627       231 001631       233 001642       234 001661
    235 001664       236 001714       239 001716       241 001742       242 001743       245 001744       246 001754
    247 001756       249 001776       251 002016       253 002032       254 002054       255 002057       259 002121
    261 002154       263 002156       264 002162       266 002217       268 002221       270 002222       271 002232
    272 002250       273 002274       274 002276       277 002327       279 002331       280 002336       282 002337
    285 002352       286 002365       288 002377       289 002406       290 002412       291 002432       292 002471
    293 002521       295 002523       296 002543       297 002563       300 002571       301 002573       302 002577
    303 002606       304 002613       305 002622       306 002661       307 002662       309 002663       310 002701
    311 002702       314 002703       315 002716       316 002720       318 002740       320 002760       322 002774
    323 003016       324 003021       328 003063       330 003116       332 003120       333 003124       335 003161
    337 003163       339 003164       340 003177       341 003215       342 003241       343 003243       346 003274
    348 003276       349 003303       351 003304       352 003315       353 003336       354 003354       355 003363
    356 003411       358 003413       359 003414       360 003420       361 003423       363 003424       364 003430
    365 003447       366 003470       367 003503       370 003535       372 003537       373 003576       375 003606
    376 003611       377 003612       378 003616       379 003621       380 003625       383 003626       384 003657
    385 003661       388 003662       389 003712       390 003715       391 003747       393 003751       394 003766
    395 003775       396 004045       398 004047       399 004050       400 004054       401 004057       402 004117
    405 004131       407 004134       409 004144       410 004152       412 004176       415 004200       416 004225
    417 004230       418 004234       419 004236       421 004311       424 004313       425 004316       426 004332
    429 004364       432 004366       433 004375       434 004421       435 004424       436 004430       437 004432
    439 004505       441 004507       442 004515       445 004552       492 004554       494 004563       495 004576
    497 004601       499 004623       500 004627       501 004631       502 004633       503 004634       507 004636
    509 004652       510 004700       513 004703       516 004720       518 004725       519 004730       520 004732
    521 004733       522 004744       524 004757       526 005003       527 005011       528 005013       529 005020
    532 005021       533 005044       536 005053       537 005057       539 005101       597 005107       598 005131
    599 005134       600 005160       603 005163       605 005164       608 005213       609 005215       612 005216
    613 005221       615 005225       617 005236       619 005241       622 005251       624 005271       627 005330
    628 005336       633 005455       636 005463       638 005464       639 005474       640 005504       642 005507
    643 005511       649 005653       652 005654       656 005671       662 006041       665 006042       666 006052
    668 006056       669 006057       673 006062       676 006065       970 006144       453 006146       460 006164
    462 006172       463 006175       465 006235       468 006240       470 006241       471 006260       472 006263
    473 006313       476 006316       477 006321       479 006363       482 006366       484 006375       546 006376
    558 006400       560 006461       561 006511       562 006514       563 006566       566 006571       567 006605
    568 006610       570 006661       573 006664       574 006671       578 006744       579 006757       582 006761
    583 006765       584 007001       587 007007       685 007010       695 007012       697 007013       699 007016
    700 007037       702 007046       703 007050       707 007051       709 007055       711 007060       712 007062
    714 007077       716 007107       717 007112       719 007127       722 007152       724 007163       727 007164
    728 007167       730 007204       734 007227       735 007234       736 007260       737 007263       738 007327
    740 007340       741 007341       745 007352       750 007365       752 007366       753 007370       754 007417
    755 007422       758 007423       761 007452       763 007470       766 007517       768 007521       769 007531
    771 007534       773 007537       775 007542       777 007543       779 007546       780 007551       781 007572
    783 007601       784 007603       786 007604       788 007605       789 007611       790 007645       791 007662
    794 007666       802 007667       810 007670       811 007677       813 007702       814 007703       816 007706
    817 007711       818 007731       820 007740       821 007742       824 007743       825 007746       828 010010
    831 010011       832 010013       834 010030       835 010040       836 010042       837 010045       840 010112
    842 010113       843 010114       845 010115       846 010116       848 010133       850 010142       851 010144
    854 010145       855 010153       859 010236       862 010237       867 010323       869 010326       871 010331
    879 010332       888 010333       889 010342       891 010345       892 010346       894 010351       895 010354
    896 010374       898 010403       899 010405       902 010406       903 010411       906 010453       909 010454
    910 010456       912 010473       913 010503       914 010505       915 010510       918 010555       920 010556
    921 010557       923 010560       925 010564       928 010613       930 010634       931 010637       935 010741
    938 010742       940 010743       941 010745       942 010761       947 011042       948 011043       950 011060
    952 011067       953 011071       956 011072       962 011171       964 011174       966 011177       974 011200
    977 011204       983 011205       986 011213       987 011220       988 011222       991 011225       992 011231
    993 011253       996 011256       997 011266       998 011270       999 011303      1001 011306      1003 011310
   1004 011312      1005 011324      1008 011326


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
