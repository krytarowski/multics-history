	COMPILATION LISTING OF SEGMENT apl_rotate_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1615.6 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /*
       11* * apl_rotate_ implements the dyadic o| operator
       12* *
       13* * Written 7/28/73 by DAM
       14* * Modified 740909 by PG for new value bead declaration, and correct handling of value stack and error marker.
       15*   Modified 780211 by PG to fix 278 (apl_push_stack_) and 230 (can't rotate a scalar).
       16*   Modified 781004 by Willaim York to fix 342 (not poping left arg).
       17*   Modified 800313 by PG to fix 460 (rotate fails if left arg is on stack, and left arg is longer than result,
       18*	because left_numbers array gets overlayed on original left operand, and copy fails).
       19* */
       20 
       21 /* format: style3 */
       22 apl_rotate_:
       23      procedure (operators_argument);
       24 
       25 /* process left operand - always numeric */
       26 
       27 	left_vb = operands (1).value;
       28 	if ^(left_vb -> value_bead.data_type.numeric_value)
       29 	then go to domain_error_left;
       30 	left = left_vb -> value_bead.data_pointer;
       31 
       32 /* process right operand - character or numeric */
       33 
       34 	right_vb = operands (2).value;
       35 	right = right_vb -> value_bead.data_pointer;
       36 	characters = right_vb -> value_bead.data_type.character_value;
       37 	rhorho = right_vb -> value_bead.rhorho;
       38 	data_elements = right_vb -> value_bead.total_data_elements;
       39 
       40 	coord = operators_argument.dimension;
       41 	if coord > rhorho
       42 	then go to rank_error;
       43 
       44 /* determine conformability */
       45 
       46 	if left_vb -> value_bead.total_data_elements = 1	/* extend scalar */
       47 	then left_scalar_fudge = 0;
       48 	else if left_vb -> value_bead.rhorho ^= rhorho - 1
       49 	then go to rank_error_left;
       50 	else do;
       51 		left_scalar_fudge = 1;		/* left opnd must have same dimensions as right, except coord */
       52 		do i = 1 by 1 while (i < coord);
       53 		     if left_vb -> value_bead.rho (i) ^= right_vb -> value_bead.rho (i)
       54 		     then go to length_error_left;
       55 		end;
       56 
       57 		do i = coord + 1 by 1 while (i <= rhorho);
       58 		     if left_vb -> value_bead.rho (i - 1) ^= right_vb -> value_bead.rho (i)
       59 		     then go to length_error_left;
       60 		end;
       61 	     end;
       62 
       63 	left_is_integer = left_vb -> value_bead.data_type.integral_value;
       64 	integer_fuzz = ws_info.integer_fuzz;
       65 
       66 	if rhorho > 0
       67 	then temp_row_length = right_vb -> value_bead.rho (coord);
       68 	else temp_row_length = 1;			/* scalar case */
       69 
       70 	if operands (2).on_stack
       71 	then do;
       72 
       73 /* doing it in place.  allocate a temporary to hold one row while it is being rotated */
       74 
       75 		if characters
       76 		then n_words = size (temp_chars_row);
       77 		else n_words = size (temp_nums_row);
       78 		save_vsp = ws_info.value_stack_ptr;
       79 		temp_row_ptr = apl_push_stack_ (n_words);
       80 		ws_info.value_stack_ptr = save_vsp;
       81 
       82 		in_place = "1"b;
       83 		result_vb = right_vb;
       84 		result = right;
       85 
       86 		if operands (1).on_stack
       87 		then ws_info.value_stack_ptr = left_vb;
       88 	     end;
       89 	else do;
       90 
       91 /* doing it by copy from heap to stack.  allocate space on stack for result and temp_row needed
       92*   if not rotating last dimension.  in order to allocate space, first move left operand out of the way */
       93 
       94 /* Compute size of result. */
       95 
       96 		number_of_dimensions = rhorho;
       97 		n_words = size (value_bead);
       98 
       99 		if characters
      100 		then n_words = n_words + size (character_string_overlay);
      101 		else n_words = n_words + size (numeric_datum) + 1;
      102 
      103 /* If the left argument is on the stack, reallocate it so that it is higher
      104*   than both the result bead and the old copy of itself. (Can't overlap either) */
      105 
      106 		if operators_argument.operands (1).on_stack
      107 		then do;
      108 			ws_info.value_stack_ptr = left_vb;
      109 						/* pop left operand */
      110 
      111 			left_data_elements = left_vb -> value_bead.total_data_elements;
      112 			n_words_left_vb = currentsize (left_vb -> value_bead) + size (left_numeric_datum) + 1;
      113 		     end;
      114 		else n_words_left_vb = 0;
      115 
      116 		result_vb = apl_push_stack_ (max (n_words, n_words_left_vb));
      117 
      118 		save_vsp = ws_info.value_stack_ptr;	/* This is the only thing to protect */
      119 
      120 		result = addr (result_vb -> value_bead.rho (rhorho + 1));
      121 
      122 		if ^characters
      123 		then if substr (rel (result), 18, 1)
      124 		     then result = addrel (result, 1);
      125 
      126 		if coord ^= rhorho
      127 		then do;
      128 			if characters
      129 			then n_words = size (temp_chars_row);
      130 			else n_words = size (temp_nums_row);
      131 
      132 			temp_row_ptr = apl_push_stack_ (n_words);
      133 		     end;
      134 
      135 		if operands (1).on_stack
      136 		then do;
      137 			n_words = size (left_numbers);
      138 
      139 			next_p = apl_push_stack_ (n_words);
      140 			next_p -> left_numbers (*) = left -> left_numbers (*);
      141 			left = next_p;
      142 		     end;
      143 
      144 		ws_info.value_stack_ptr = save_vsp;	/* forget previous stuff */
      145 
      146 		string (result_vb -> value_bead.type) = string (right_vb -> value_bead.type);
      147 		result_vb -> value_bead.data_pointer = result;
      148 		result_vb -> value_bead.total_data_elements = data_elements;
      149 		result_vb -> value_bead.rhorho = rhorho;
      150 
      151 		if rhorho ^= 0
      152 		then unspec (result_vb -> value_bead.rho (*)) = unspec (right_vb -> value_bead.rho (*));
      153 
      154 		in_place = "0"b;
      155 
      156 	     end;
      157 
      158 	operators_argument.result = result_vb;		/* since we have carefully arranged for this to be at bottom
      159*						   of stack, never have to move it down */
      160 
      161 /* compute do-loop parameters */
      162 
      163 	innersize = 1;
      164 	do i = coord by 1 while (i < rhorho);
      165 	     innersize = innersize * right_vb -> value_bead.rho (i + 1);
      166 	end;
      167 
      168 	if rhorho > 0
      169 	then if right_vb -> value_bead.rho (coord) ^= 0
      170 	     then left_outersize = divide (data_elements, right_vb -> value_bead.rho (coord), 21, 0);
      171 	     else left_outersize = 0;
      172 	else left_outersize = 1;			/* scalar case */
      173 
      174 /* do the actual operation */
      175 
      176 	do left_outer = 0 by innersize while (left_outer < left_outersize);
      177 	     right_outer = left_outer * temp_row_length;
      178 	     do inner = 0 by 1 while (inner < innersize);
      179 
      180 		if left_is_integer
      181 		then rotation = fixed (left -> numeric_datum ((left_outer + inner) * left_scalar_fudge));
      182 		else do;
      183 			float_rot = floor (left -> numeric_datum ((left_outer + inner) * left_scalar_fudge) + 0.5);
      184 			if abs (float_rot - left -> numeric_datum ((left_outer + inner) * left_scalar_fudge))
      185 			     > integer_fuzz
      186 			then go to domain_error_left;
      187 			if abs (float_rot) >= 1e21b
      188 			then go to domain_error_left;
      189 			rotation = float_rot;
      190 		     end;
      191 		rotation = mod (rotation, temp_row_length);
      192 
      193 		if rotation = 0
      194 		then if in_place
      195 		     then go to nugatory;
      196 
      197 		if ^in_place
      198 		then if coord = rhorho
      199 		     then do;			/* temp_xxx_row overlayed on operand */
      200 			     if characters
      201 			     then temp_row_ptr = addr (right -> character_datum (right_outer + inner));
      202 			     else temp_row_ptr = addr (right -> numeric_datum (right_outer + inner));
      203 			     go to so_rotate;
      204 			end;
      205 
      206 		if characters
      207 		then do temp_row_idx = 0 by 1 while (temp_row_idx < temp_row_length);
      208 			temp_chars_row (temp_row_idx) =
      209 			     right -> character_datum (temp_row_idx * innersize + right_outer + inner);
      210 		     end;
      211 		else do temp_row_idx = 0 by 1 while (temp_row_idx < temp_row_length);
      212 			temp_nums_row (temp_row_idx) =
      213 			     right -> numeric_datum (temp_row_idx * innersize + right_outer + inner);
      214 		     end;
      215 
      216 /* now move the temp_xxx_row into the result, with rotation */
      217 
      218 so_rotate:
      219 		do i = 0 by 1 to temp_row_length - rotation - 1;
      220 		     if characters
      221 		     then result -> character_datum (i * innersize + right_outer + inner) = temp_chars_row (i + rotation);
      222 		     else result -> numeric_datum (i * innersize + right_outer + inner) = temp_nums_row (i + rotation);
      223 		end;
      224 		do j = i by 1 while (j < temp_row_length);
      225 		     if characters
      226 		     then result -> character_datum (j * innersize + right_outer + inner) = temp_chars_row (j - i);
      227 		     else result -> numeric_datum (j * innersize + right_outer + inner) = temp_nums_row (j - i);
      228 		end;
      229 nugatory:
      230 	     end;
      231 	end;
      232 
      233 	return;
      234 
      235 
      236 
      237 
      238 domain_error_left:
      239 	operators_argument.error_code = apl_error_table_$domain;
      240 	go to mark_left;
      241 
      242 length_error_left:
      243 	operators_argument.error_code = apl_error_table_$length;
      244 	go to mark_left;
      245 
      246 rank_error_left:
      247 	operators_argument.error_code = apl_error_table_$rank;
      248 mark_left:
      249 	operators_argument.where_error = operators_argument.where_error + 1;
      250 	return;
      251 
      252 rank_error:
      253 	operators_argument.error_code = apl_error_table_$operator_subscript_range;
      254 	return;
      255 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_push_stack_fcn.incl.pl1 =============================== */
  1     2 
  1     3 /* format: style3 */
  1     4 apl_push_stack_:
  1     5      procedure (P_n_words) returns (ptr);
  1     6 
  1     7 /* Function to (1) double-word align ws_info.value_stack_ptr, and
  1     8*   (2) make sure allocation request will fit on current value stack.
  1     9*
  1    10*   Written 770413 by PG
  1    11*   Modified 780210 by PG to round allocations up to an even number of words.
  1    12**/
  1    13 
  1    14 /* parameters */
  1    15 
  1    16 declare	P_n_words		fixed bin (19) parameter;
  1    17 
  1    18 /* automatic */
  1    19 
  1    20 declare	block_ptr		ptr,
  1    21 	num_words		fixed bin (19);
  1    22 
  1    23 /* builtins */
  1    24 
  1    25 declare	(addrel, binary, rel, substr, unspec)
  1    26 			builtin;
  1    27 
  1    28 /* entries */
  1    29 
  1    30 declare	apl_get_value_stack_
  1    31 			entry (fixed bin (19));
  1    32 
  1    33 /* program */
  1    34 
  1    35 	num_words = P_n_words;
  1    36 
  1    37 	if substr (unspec (num_words), 36, 1) = "1"b	/* num_words odd */
  1    38 	then num_words = num_words + 1;
  1    39 
  1    40 	if binary (rel (ws_info.value_stack_ptr), 18) + num_words > ws_info.maximum_value_stack_size
  1    41 	then call apl_get_value_stack_ (num_words);
  1    42 
  1    43 	block_ptr = ws_info.value_stack_ptr;
  1    44 	ws_info.value_stack_ptr = addrel (ws_info.value_stack_ptr, num_words);
  1    45 	return (block_ptr);
  1    46 
  1    47      end apl_push_stack_;
  1    48 
  1    49 /* ------ END INCLUDE SEGMENT		apl_push_stack_fcn.incl.pl1 ------------------------------- */
      256 
      257 
      258 /* automatic */
      259 
      260 dcl	left_vb		pointer,			/* -> value bead of left operand */
      261 	left		pointer,			/* -> value array of left operand, may have got moved in stack */
      262 	next_p		pointer,			/* random pointer */
      263 	rhorho		fixed bin,		/* rhorho of right operand and result */
      264 	right_vb		pointer,			/* -> value_bead of right opnd */
      265 	right		pointer,			/* -> value array of right operand */
      266 	save_vsp		ptr,			/* used to pop temps off value stack */
      267 	characters	bit (1),			/* "1"b if right opnd and result are character, "0"b if numeric */
      268 	data_elements	fixed bin (21),		/* size in elements of roght operand, result */
      269 	coord		fixed bin,		/* the dimension of the rows to be rowtated */
      270 	left_scalar_fudge	fixed bin,		/* horrible kludge: 0 if left arg is scalar, 1 if not.
      271*						   used to hack the subscript calculation so extension
      272*						   of scalar left arguments works correctly */
      273 	(i, j)		fixed bin,		/* random do-loop indices */
      274 	left_is_integer	bit (1),			/* copy of left_vb->value_bead.integral_value, for eff. */
      275 	integer_fuzz	float,			/* copy of the fuzz, also for eff. */
      276 	temp_row_length	fixed bin (21),		/* length of a row being rhotated, also of others dcl'ed below */
      277 	temp_row_ptr	pointer,
      278 	n_words		fixed bin (19),		/* size in words of amount of space needed in stack */
      279 	result_vb		pointer,			/* -> value_bead for result */
      280 	result		pointer,			/* -> value array for result */
      281 	in_place		bit (1),			/* "1"b => result overlays right opnd, "0"b => it doesn't */
      282 	innersize		fixed bin (21),		/* times reduction of rho of opnd|result after coord */
      283 	left_outersize	fixed bin (21),		/* number of things in (expnaded if scalar) left argument */
      284 	left_outer	fixed bin (21),		/* part of subscript into left operand for rotate amount */
      285 	right_outer	fixed bin (21),		/* part of subscript into right operand for row to mung */
      286 	inner		fixed bin (21),		/* portion of subscript derived from rho to right of coord */
      287 	rotation		fixed bin (21),		/* amount by which this row is to be munged */
      288 	float_rot		float,
      289 	temp_row_idx	fixed bin (21),		/* do-loop index for moving disconnected arrays (rows) into
      290*						   the temp_row */
      291 	left_data_elements	fixed bin (21),		/* used in stack alloc calculation */
      292 	n_words_left_vb	fixed bin (19);		/* .. */
      293 
      294 /* based */
      295 
      296 dcl	temp_chars_row	(0:temp_row_length - 1) char (1) unal based (temp_row_ptr),
      297 						/* _m_u_s_t be unal for hack with coord=rhorho */
      298 	temp_nums_row	(0:temp_row_length - 1) float aligned based (temp_row_ptr),
      299 						/* these two arrays are used to hold
      300*						a row being rotated, to avoid in-place overlay problems */
      301 	left_numbers	(left_vb -> value_bead.total_data_elements) float aligned based,
      302 	left_numeric_datum	(left_data_elements) float aligned based;
      303 
      304 /* external static */
      305 
      306 dcl	(
      307 	apl_error_table_$domain,
      308 	apl_error_table_$rank,
      309 	apl_error_table_$length,
      310 	apl_error_table_$operator_subscript_range
      311 	)		fixed bin (35) external;
      312 
      313 /* builtins */
      314 
      315 dcl	(abs, addr, addrel, currentsize, divide, max, mod, rel, substr, size, string, unspec, fixed, floor)
      316 			builtin;
      317 
      318 /* include files */
      319 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_number_data.incl.pl1 ================================== */
  2     2 
  2     3 /*
  2     4*   This include file contains information about the machine representation of numbers.
  2     5*   In all programs numbers should simply be declared 'float'.
  2     6*   All default statements should be in this include file.
  2     7*
  2     8*   This is the binary version.  The manifest constant Binary should be used by programs
  2     9*   that need to know whether we are using binary or decimal.
  2    10* */
  2    11 
  2    12 /* format: style3,initlm0,idind30 */
  2    13 
  2    14 default (float & ^decimal & ^binary & ^precision & ^constant) float binary (63);
  2    15 
  2    16 declare	(
  2    17 	TheBiggestNumberWeveGot	float initial (0.1701411834604692317e+39),
  2    18 	TheSmallestNumberWeveGot	float initial (.1469367938527859385e-38),
  2    19 	Binary			bit (1) aligned initial ("1"b)
  2    20 	)			internal static options (constant);
  2    21 
  2    22 /* Number of characters in a number datum entry; used for copying float number arrays as strings.
  2    23*   (Obsolete! use array copies!) */
  2    24 
  2    25 declare	NumberSize		fixed binary precision (4) internal static initial (8);
  2    26 
  2    27 /* ------ END INCLUDE SEGMENT		apl_number_data.incl.pl1 ---------------------------------- */
      320 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_ws_info.incl.pl1 ====================================== */
  3     2 
  3     3 /* This structure contains all of the global data (or pointers to it) for the APL subsystem */
  3     4 
  3     5 /* automatic */
  3     6 
  3     7 declare	ws_info_ptr ptr initial (apl_static_$ws_info_ptr.static_ws_info_ptr);
  3     8 
  3     9 /* external static */
  3    10 
  3    11 declare	1 apl_static_$ws_info_ptr	external static aligned structure,
  3    12 	  2 static_ws_info_ptr	unaligned pointer;
  3    13 
  3    14 /* based */
  3    15 
  3    16 declare	1 ws_info			aligned based (ws_info_ptr),
  3    17 	  2 version_number		fixed bin,	/* version of this structure (3) */
  3    18 	  2 switches		unaligned,	/* mainly ws parameters */
  3    19 	    3 long_error_mode	bit,		/* if 1, long Multics format, else APL/360 format */
  3    20 	    3 debug_mode		bit,		/* if 1, system error causes escape to command level */
  3    21 	    3 canonicalize_mode	bit,		/* if 1, the editor canonicalizes user input */
  3    22 	    3 restrict_exec_command	bit,		/* if 1, the )EXEC command may not be used */
  3    23 	    3 restrict_debug_command	bit,		/* if 1, the )DEBUG command may not be used */
  3    24 	    3 restrict_external_functions
  3    25 				bit,		/* if 1, the )ZFN, )MFN, and )DFN commands may not be used */
  3    26 	    3 restrict_load		bit,		/* if 1, the )LOAD and )COPY commands may not be used */
  3    27 	    3 restrict_load_directory	bit,		/* if 1, no directory allowed in )LOAD or )COPY pathnames */
  3    28 	    3 restrict_save		bit,		/* if 1, the )SAVE command may not be used */
  3    29 	    3 restrict_save_directory	bit,		/* if 1, no directory allowed in )SAVE pathnames */
  3    30 	    3 off_hold		bit,		/* if 1, )OFF HOLD was typed, else just )OFF */
  3    31 	    3 transparent_to_signals	bit,		/* if 1, any conditions slip right past APL */
  3    32 	    3 meter_mode		bit,		/* if 1, metering may be done, else speed is all-important */
  3    33 	    3 restrict_msg_command	bit,		/* if 1, the )MSG command may not be used. */
  3    34 	    3 compatibility_check_mode
  3    35 				bit,		/* if 1, check for incompatible operators */
  3    36 	    3 no_quit_handler	bit,		/* if 1, do not trap QUITs. */
  3    37 						/* remaining 20 bits not presently used */
  3    38 
  3    39 	  2 values,				/* attributes of the workspace */
  3    40 	    3 digits		fixed bin,	/* number of digits of precision printed on output */
  3    41 	    3 width		fixed bin,	/* line length for formatted output */
  3    42 	    3 index_origin		fixed bin,	/* the index origin (0 or 1) */
  3    43 	    3 random_link		fixed bin(35),	/* seed for random number generator */
  3    44 	    3 fuzz		float,		/* comparison tolerance (relative fuzz) */
  3    45 	    3 float_index_origin	float,		/* the index origin	in floating point */
  3    46 	    3 number_of_symbols	fixed bin,	/* the number of symbol_beads currently in existence */
  3    47 	    3 maximum_value_stack_size
  3    48 				fixed bin (18),	/* maximum number of words in one segment of value stack */
  3    49 
  3    50 	  2 pointers,				/* pointers to various internal tables */
  3    51 	    3 symbol_table_ptr	unaligned pointer,	/* -> symbol_table (apl_symbol_table.incl.pl1) */
  3    52 	    3 current_parse_frame_ptr	unaligned pointer,	/* -> topmost parse frame */
  3    53 	    3 value_stack_ptr	unaligned pointer,	/* -> next free location on value stack */
  3    54 	    3 alloc_free_info_ptr	unaligned pointer,	/* -> apl_storage_mngr_ data (apl_storage_system_data.incl.pl1) */
  3    55 
  3    56 	  2 time_invoked		fixed bin(71),	/* clock time that APL was entered */
  3    57 	  2 integer_fuzz		float,		/* the absolute fuzz used in checking for integers */
  3    58 	  2 user_number		fixed bin(35),	/* number under which the user is signed on */
  3    59 	  2 latent_expression	unaligned pointer,	/* -> value_bead for QuadLX */
  3    60 	  2 lock			char(32),		/* the lock currently set on this workspace (password) */
  3    61 	  2 wsid			char(100),	/* the workspace identification: name, number name, or clear ws */
  3    62 	  2 last_error_code		fixed bin(35),	/* last code passed to apl_error_ */
  3    63 	  2 signoff_lock		character (32),
  3    64 
  3    65 	  2 interrupt_info		aligned,		/* bits used by apl_interpreter_ to tell when to abort */
  3    66 	    3 dont_interrupt_parse	bit,		/* if 1, don't do a dirty stop because the parser is running */
  3    67 	    3 dont_interrupt_operator	bit,		/* if 1, don't do a dirty stop because an operator is running */
  3    68 	    3 dont_interrupt_storage_manager		/* if 1, don't stop because apl_storage_mngr_ is */
  3    69 				bit,		/*       munging his tables */
  3    70 	    3 unused_interrupt_bit	bit,		/* not presently used */
  3    71 	    3 dont_interrupt_command	bit,
  3    72 	    3 can_be_interrupted	bit,		/* if 1, OK to do a clean stop (we are between lines, reading) */
  3    73 	    3 clean_interrupt_pending	bit,		/* interrupt occured, break cleanly (between lines) */
  3    74 	    3 dirty_interrupt_pending	bit,		/* interrupt occured, break as soon as not inhibited */
  3    75 
  3    76 	  2 user_name		char (32),	/* process group id of user */
  3    77 	  2 immediate_input_prompt	char (32) varying,	/* normal input */
  3    78 	  2 evaluated_input_prompt	char (32) varying,	/* quad input */
  3    79 	  2 character_input_prompt	char (32) varying,	/* quad-quote input */
  3    80 	  2 vcpu_time		aligned,
  3    81 	    3 total		fixed bin (71),
  3    82 	    3 setup		fixed bin (71),
  3    83 	    3 parse		fixed bin (71),
  3    84 	    3 lex			fixed bin (71),
  3    85 	    3 operator		fixed bin (71),
  3    86 	    3 storage_manager	fixed bin (71),
  3    87 	  2 output_info		aligned,		/* data pertaining to output buffer */
  3    88 	    3 output_buffer_ptr	unal ptr,		/* ptr to output buffer */
  3    89 	    3 output_buffer_len	fixed bin (21),	/* length (bytes) of output buffer */
  3    90 	    3 output_buffer_pos	fixed bin (21),	/* index of next byte to write in */
  3    91 	    3 output_buffer_ll	fixed bin (21),	/* print positions used up so far */
  3    92 	  2 tab_width		fixed bin (21);	/* number of columns a tabs moves cursor */
  3    93 
  3    94 declare	output_buffer char (ws_info.output_buffer_len) based (ws_info.output_buffer_ptr);
  3    95 
  3    96 /* internal static */
  3    97 
  3    98 declare	max_parse_stack_depth fixed bin int static init(64536);
  3    99 
  3   100 /* ------ END INCLUDE SEGMENT		apl_ws_info.incl.pl1 -------------------------------------- */
      321 
  4     1 /* ====== BEGIN INCLUDE SEGEMENT	apl_operators_argument.incl.pl1 =========================== */
  4     2 
  4     3 declare	1 operators_argument	aligned,
  4     4 	  2 operands (2)		aligned,		/* these are the operands to the operator to be executed.
  4     5*						   if operand (1).value is null, operator is monadic */
  4     6 	    3 value		pointer unaligned,	/* a pointer to the value bead for this operand */
  4     7 	    3 on_stack		bit (1) aligned,	/* ON if this value resides on the value stack */
  4     8 	  2 operator		aligned,		/* information about the operator to be executed */
  4     9 	    3 dimension		fixed bin,	/* (optional) dimension along which to operate */
  4    10 	    3 padding		bit (18) unaligned,	/* unused part of operator bead */
  4    11 	    3 op2			fixed bin (8) unal,	/* a modifier for op1, or a 2nd operator if inner product */
  4    12 	    3 op1			fixed bin (8) unal,	/* code for the actual operator to be executed */
  4    13 	  2 result		pointer unal,	/* (output) set by operator to point to result bead in stack */
  4    14 	  2 error_code		fixed bin (35),	/* (output) set before signaling apl_operator_error_ */
  4    15 	  2 where_error		fixed bin;	/* parseme index of where error was - parse sets to operator */
  4    16 
  4    17 /* ------ END INCLUDE SEGMENT		apl_operators_argument.incl.pl1 --------------------------- */
      322 
  5     1 /* ====== BEGIN INCLUDE SEGMENT	apl_bead_format.incl.pl1 ================================== */
  5     2 
  5     3 declare 1 general_bead  		aligned based,	/* The Venerable Bead		*/
  5     4 	2 type 			unaligned,
  5     5 	  3 bead_type		unaligned,
  5     6 	    4 operator		bit (1),		/* ON if operator bead		*/
  5     7 	    4 symbol		bit (1),		/* ON if symbol bead		*/
  5     8 	    4 value		bit (1),		/* ON if value bead			*/
  5     9 	    4 function		bit (1),		/* ON if function bead		*/
  5    10 	    4 group		bit (1),		/* ON if group bead			*/
  5    11 	    4 label		bit (1),		/* ON if label bead			*/
  5    12 	    4 shared_variable	bit (1),		/* ON if shared variable bead 	*/
  5    13 	    4 lexed_function	bit (1),		/* ON if lexed function bead  	*/
  5    14 	  3 data_type		unaligned,
  5    15 	    4 list_value		bit (1),		/* ON if a list value bead		*/
  5    16 	    4 character_value	bit (1),		/* ON if a character value bead	*/
  5    17 	    4 numeric_value		bit (1),		/* ON if a numeric value bead		*/
  5    18 	    4 integral_value	bit (1),		/* ON if an integral value bead	*/
  5    19 	    4 zero_or_one_value	bit (1),		/* ON if a boolean value bead		*/
  5    20 	    4 complex_value		bit (1),		/* ON if a complex, numeric value bead   */
  5    21 	  3 unused_bits		bit (4) unaligned,	/* pad to 18 bits (for future use)	*/
  5    22 	2 size			bit (18) unaligned,	/* Number of words this bead occupies
  5    23*						   (used by bead storage manager)	*/
  5    24 	2 reference_count 		fixed binary (29);	/* Number of pointers which point
  5    25*						   to this bead (used by bead manager)	*/
  5    26 
  5    27 
  5    28 /* constant strings for initing type field in various beads */
  5    29 
  5    30 declare (
  5    31 	operator_type		init("100000000000000000"b),
  5    32 	symbol_type		init("010000000000000000"b),
  5    33     	value_type		init("001000000000000000"b),
  5    34 	function_type		init("000100000000000000"b),
  5    35 	group_type		init("000010000000000000"b),
  5    36 	label_type		init("001001000011000000"b),
  5    37 	shared_variable_type	init("001000100000000000"b),
  5    38 	lexed_function_type		init("000000010000000000"b),
  5    39 
  5    40 	list_value_type		init("000000001000000000"b),
  5    41 	character_value_type 	init("001000000100000000"b),
  5    42 	numeric_value_type		init("001000000010000000"b),
  5    43 	integral_value_type		init("001000000011000000"b),
  5    44 	zero_or_one_value_type	init("001000000011100000"b),
  5    45 	complex_value_type		init("001000000000010000"b),
  5    46 
  5    47 	not_integer_mask		init("111111111110011111"b),		/* to clear integral, zero_or_one bits */
  5    48 	not_zero_or_one_mask	init("111111111111011111"b)		/* to clear zero_or_one bit */
  5    49         ) bit(18) internal static;
  5    50 
  5    51 /* ------ END INCLUDE SEGMENT		apl_bead_format.incl.pl1 ---------------------------------- */
      323 
  6     1 /* ====== BEGIN INCLUDE SEGMENT	apl_value_bead.incl.pl1 =================================== */
  6     2 
  6     3 declare
  6     4 	number_of_dimensions fixed bin,
  6     5 
  6     6 	1 value_bead		aligned based,
  6     7 	2 header			aligned like general_bead,
  6     8 	2 total_data_elements	fixed binary (21),	/* length of ,[value] in APL		*/
  6     9 	2 rhorho			fixed binary,	/* number of dimensions of value	*/
  6    10 	2 data_pointer		pointer unaligned,	/* packed pointer to the data in value	*/
  6    11 	2 rho			fixed binary (21) dimension (number_of_dimensions refer (value_bead.rhorho));
  6    12 						/* dimensions of value (zero-origin)	*/
  6    13 
  6    14 
  6    15 declare 1 character_data_structure	aligned based,	/* alignment trick for PL/I compiler	*/
  6    16 	2 character_datum		character (1) unaligned dimension (0:data_elements - 1);
  6    17 						/* actual elements of character array	*/
  6    18 
  6    19 declare   character_string_overlay	character (data_elements) aligned based;
  6    20 						/* to overlay on above structure	 */
  6    21 
  6    22 
  6    23 declare   numeric_datum		float aligned dimension (0:data_elements - 1) based;
  6    24 						/* actual elements of numeric array	*/
  6    25 
  6    26 declare	complex_datum		complex float aligned dimension (0:data_elements -1) based;
  6    27 
  6    28 declare	MAX_VALUE_BEAD_SIZE		fixed bin (19) init (261120) int static options (constant);
  6    29 
  6    30 /* ------ END INCLUDE SEGMENT		apl_value_bead.incl.pl1 ----------------------------------- */
      324 
      325      end apl_rotate_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1347.1  apl_rotate_.pl1                   >special_ldd>on>apl.1129>apl_rotate_.pl1
256          1    03/27/82  0429.8  apl_push_stack_fcn.incl.pl1       >ldd>include>apl_push_stack_fcn.incl.pl1
320          2    03/27/82  0429.8  apl_number_data.incl.pl1          >ldd>include>apl_number_data.incl.pl1
321          3    03/27/82  0439.2  apl_ws_info.incl.pl1              >ldd>include>apl_ws_info.incl.pl1
322          4    03/27/82  0439.0  apl_operators_argument.incl.pl1   >ldd>include>apl_operators_argument.incl.pl1
323          5    03/27/82  0438.5  apl_bead_format.incl.pl1          >ldd>include>apl_bead_format.incl.pl1
324          6    03/27/82  0439.2  apl_value_bead.incl.pl1           >ldd>include>apl_value_bead.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_n_words                              parameter       fixed bin(19,0)          dcl 1-16 ref 1-4 1-35
abs                                                    builtin function         dcl 315 ref 184 187
addr                                                   builtin function         dcl 315 ref 120 200 202
addrel                                                 builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-44
addrel                                                 builtin function         dcl 315 in procedure "apl_rotate_" ref 122
apl_error_table_$domain         000010 external static fixed bin(35,0)          dcl 306 ref 238
apl_error_table_$length         000014 external static fixed bin(35,0)          dcl 306 ref 242
apl_error_table_$operator_subscript_range
                                000016 external static fixed bin(35,0)          dcl 306 ref 252
apl_error_table_$rank           000012 external static fixed bin(35,0)          dcl 306 ref 246
apl_get_value_stack_            000022 constant        entry                    external dcl 1-30 ref 1-40
apl_static_$ws_info_ptr         000020 external static structure                level 1 dcl 3-11
binary                                                 builtin function         dcl 1-25 ref 1-40
block_ptr                       000174 automatic       pointer                  dcl 1-20 set ref 1-43* 1-45
character_data_structure               based           structure                level 1 dcl 6-15
character_datum                        based           char(1)                  array level 2 packed unaligned dcl 6-15 set ref 200
                                                                                  208 220* 225*
character_string_overlay               based           char                     dcl 6-19 ref 99
character_value           0(09)        based           bit(1)                   level 5 packed unaligned dcl 6-3 set ref 36
characters                      000116 automatic       bit(1)                   unaligned dcl 260 set ref 36* 75 99 122 128 200 206
                                                                                  220 225
coord                           000120 automatic       fixed bin(17,0)          dcl 260 set ref 40* 41 52 57 66 126 164 168 168 197
currentsize                                            builtin function         dcl 315 ref 112
data_elements                   000117 automatic       fixed bin(21,0)          dcl 260 set ref 38* 99 99 101 148 168
data_pointer              4            based           pointer                  level 2 packed unaligned dcl 6-3 set ref 30 35 147*
data_type                 0(08)        based           structure                level 4 packed unaligned dcl 6-3
dimension                 4            parameter       fixed bin(17,0)          level 3 dcl 4-3 ref 40
divide                                                 builtin function         dcl 315 ref 168
error_code                7            parameter       fixed bin(35,0)          level 2 dcl 4-3 set ref 238* 242* 246* 252*
fixed                                                  builtin function         dcl 315 ref 180
float_rot                       000152 automatic       float bin(63)            dcl 260 set ref 183* 184 187 189
floor                                                  builtin function         dcl 315 ref 183
general_bead                           based           structure                level 1 dcl 5-3
header                                 based           structure                level 2 dcl 6-3
i                               000122 automatic       fixed bin(17,0)          dcl 260 set ref 52* 52* 53 53* 57* 57* 58 58* 164*
                                                                                  164* 165* 218* 220 220 222 222* 224 225 227
in_place                        000142 automatic       bit(1)                   unaligned dcl 260 set ref 82* 154* 193 197
inner                           000147 automatic       fixed bin(21,0)          dcl 260 set ref 178* 178* 180 183 184 200 202 208
                                                                                  212 220 222 225 227*
innersize                       000143 automatic       fixed bin(21,0)          dcl 260 set ref 163* 165* 165 176 178 208 212 220
                                                                                  222 225 227
integer_fuzz                    000126 automatic       float bin(63)            dcl 260 in procedure "apl_rotate_" set ref 64* 184
integer_fuzz             22            based           float bin(63)            level 2 in structure "ws_info" dcl 3-16 in procedure
                                                                                  "apl_rotate_" ref 64
integral_value            0(11)        based           bit(1)                   level 5 packed unaligned dcl 6-3 set ref 63
j                               000123 automatic       fixed bin(17,0)          dcl 260 set ref 224* 224* 225 225 227 227*
left                            000102 automatic       pointer                  dcl 260 set ref 30* 140 141* 180 183 184
left_data_elements              000155 automatic       fixed bin(21,0)          dcl 260 set ref 111* 112
left_is_integer                 000124 automatic       bit(1)                   unaligned dcl 260 set ref 63* 180
left_numbers                           based           float bin(63)            array dcl 296 set ref 137 140* 140
left_numeric_datum                     based           float bin(63)            array dcl 296 ref 112
left_outer                      000145 automatic       fixed bin(21,0)          dcl 260 set ref 176* 176* 177 180 183 184*
left_outersize                  000144 automatic       fixed bin(21,0)          dcl 260 set ref 168* 171* 172* 176
left_scalar_fudge               000121 automatic       fixed bin(17,0)          dcl 260 set ref 46* 51* 180 183 184
left_vb                         000100 automatic       pointer                  dcl 260 set ref 27* 28 30 46 48 53 58 63 86 108 111
                                                                                  112 137 140
max                                                    builtin function         dcl 315 ref 116 116
maximum_value_stack_size
                         13            based           fixed bin(18,0)          level 3 dcl 3-16 ref 1-40
mod                                                    builtin function         dcl 315 ref 191
n_words                         000134 automatic       fixed bin(19,0)          dcl 260 set ref 75* 77* 79* 97* 99* 99 101* 101 116
                                                                                  116 128* 130* 132* 137* 139*
n_words_left_vb                 000156 automatic       fixed bin(19,0)          dcl 260 set ref 112* 114* 116 116
next_p                          000104 automatic       pointer                  dcl 260 set ref 139* 140 141
num_words                       000176 automatic       fixed bin(19,0)          dcl 1-20 set ref 1-35* 1-37 1-37* 1-37 1-40 1-40*
                                                                                  1-44
number_of_dimensions            000162 automatic       fixed bin(17,0)          dcl 6-3 set ref 96* 97
numeric_datum                          based           float bin(63)            array dcl 6-23 set ref 101 180 183 184 202 212 222*
                                                                                  227*
numeric_value             0(10)        based           bit(1)                   level 5 packed unaligned dcl 6-3 set ref 28
on_stack                  1            parameter       bit(1)                   array level 3 dcl 4-3 ref 70 86 106 135
operands                               parameter       structure                array level 2 dcl 4-3
operator                  4            parameter       structure                level 2 dcl 4-3
operators_argument                     parameter       structure                level 1 dcl 4-3 set ref 22
pointers                 14            based           structure                level 2 dcl 3-16
rel                                                    builtin function         dcl 315 in procedure "apl_rotate_" ref 122
rel                                                    builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-40
result                    6            parameter       pointer                  level 2 in structure "operators_argument" packed
                                                                                  unaligned dcl 4-3 in procedure "apl_rotate_" set
                                                                                  ref 158*
result                          000140 automatic       pointer                  dcl 260 in procedure "apl_rotate_" set ref 84* 120*
                                                                                  122 122* 122 147 220 222 225 227
result_vb                       000136 automatic       pointer                  dcl 260 set ref 83* 116* 120 146 147 148 149 151 158
rho                       5            based           fixed bin(21,0)          array level 2 dcl 6-3 set ref 53 53 58 58 66 120
                                                                                  151* 151 165 168 168
rhorho                    3            based           fixed bin(17,0)          level 2 in structure "value_bead" dcl 6-3
                                                                                  in procedure "apl_rotate_" set ref 37 48 112 149*
                                                                                  151 151
rhorho                          000106 automatic       fixed bin(17,0)          dcl 260 in procedure "apl_rotate_" set ref 37* 41 48
                                                                                  57 66 96 120 126 149 151 164 168 197
right                           000112 automatic       pointer                  dcl 260 set ref 35* 84 200 202 208 212
right_outer                     000146 automatic       fixed bin(21,0)          dcl 260 set ref 177* 200 202 208 212 220 222 225 227
right_vb                        000110 automatic       pointer                  dcl 260 set ref 34* 35 36 37 38 53 58 66 83 146 151
                                                                                  165 168 168
rotation                        000150 automatic       fixed bin(21,0)          dcl 260 set ref 180* 189* 191* 191 193 218 220 222
save_vsp                        000114 automatic       pointer                  dcl 260 set ref 78* 80 118* 144
size                                                   builtin function         dcl 315 ref 75 77 97 99 101 112 128 130 137
static_ws_info_ptr              000020 external static pointer                  level 2 packed unaligned dcl 3-11 ref 3-7
string                                                 builtin function         dcl 315 set ref 146* 146
substr                                                 builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-37
substr                                                 builtin function         dcl 315 in procedure "apl_rotate_" ref 122
temp_chars_row                         based           char(1)                  array unaligned dcl 296 set ref 75 128 208* 220 225
temp_nums_row                          based           float bin(63)            array dcl 296 set ref 77 130 212* 222 227
temp_row_idx                    000154 automatic       fixed bin(21,0)          dcl 260 set ref 206* 206* 208 208* 211* 211* 212
                                                                                  212*
temp_row_length                 000130 automatic       fixed bin(21,0)          dcl 260 set ref 66* 68* 75 77 128 130 177 191 206
                                                                                  211 218 224
temp_row_ptr                    000132 automatic       pointer                  dcl 260 set ref 75 77 79* 128 130 132* 200* 202* 208
                                                                                  212 220 222 225 227
total_data_elements       2            based           fixed bin(21,0)          level 2 dcl 6-3 set ref 38 46 111 137 140 148*
type                                   based           structure                level 3 packed unaligned dcl 6-3 set ref 146* 146
unspec                                                 builtin function         dcl 1-25 in procedure "apl_push_stack_" ref 1-37
unspec                                                 builtin function         dcl 315 in procedure "apl_rotate_" set ref 151* 151
value                                  parameter       pointer                  array level 3 packed unaligned dcl 4-3 ref 27 34
value_bead                             based           structure                level 1 dcl 6-3 set ref 97 112
value_stack_ptr          16            based           pointer                  level 3 packed unaligned dcl 3-16 set ref 78 80* 86*
                                                                                  108* 118 144* 1-40 1-43 1-44* 1-44
values                    2            based           structure                level 2 dcl 3-16
where_error              10            parameter       fixed bin(17,0)          level 2 dcl 4-3 set ref 248* 248
ws_info                                based           structure                level 1 dcl 3-16
ws_info_ptr                     000160 automatic       pointer                  initial dcl 3-7 set ref 64 78 80 86 108 118 144 3-7*
                                                                                  1-40 1-40 1-43 1-44 1-44

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Binary                                 internal static bit(1)                   initial dcl 2-16
MAX_VALUE_BEAD_SIZE                    internal static fixed bin(19,0)          initial dcl 6-28
NumberSize                             internal static fixed bin(4,0)           initial dcl 2-25
TheBiggestNumberWeveGot                internal static float bin(63)            initial dcl 2-16
TheSmallestNumberWeveGot               internal static float bin(63)            initial dcl 2-16
character_value_type                   internal static bit(18)                  initial unaligned dcl 5-30
complex_datum                          based           complex float bin(63)    array dcl 6-26
complex_value_type                     internal static bit(18)                  initial unaligned dcl 5-30
function_type                          internal static bit(18)                  initial unaligned dcl 5-30
group_type                             internal static bit(18)                  initial unaligned dcl 5-30
integral_value_type                    internal static bit(18)                  initial unaligned dcl 5-30
label_type                             internal static bit(18)                  initial unaligned dcl 5-30
lexed_function_type                    internal static bit(18)                  initial unaligned dcl 5-30
list_value_type                        internal static bit(18)                  initial unaligned dcl 5-30
max_parse_stack_depth                  internal static fixed bin(17,0)          initial dcl 3-98
not_integer_mask                       internal static bit(18)                  initial unaligned dcl 5-30
not_zero_or_one_mask                   internal static bit(18)                  initial unaligned dcl 5-30
numeric_value_type                     internal static bit(18)                  initial unaligned dcl 5-30
operator_type                          internal static bit(18)                  initial unaligned dcl 5-30
output_buffer                          based           char                     unaligned dcl 3-94
shared_variable_type                   internal static bit(18)                  initial unaligned dcl 5-30
symbol_type                            internal static bit(18)                  initial unaligned dcl 5-30
value_type                             internal static bit(18)                  initial unaligned dcl 5-30
zero_or_one_value_type                 internal static bit(18)                  initial unaligned dcl 5-30

NAMES DECLARED BY EXPLICIT CONTEXT.
apl_push_stack_                 000755 constant        entry                    internal dcl 1-4 ref 79 116 132 139
apl_rotate_                     000032 constant        entry                    external dcl 22
domain_error_left               000730 constant        label                    dcl 238 set ref 28 184 187
length_error_left               000736 constant        label                    dcl 242 ref 53 58
mark_left                       000746 constant        label                    dcl 248 ref 240 244
nugatory                        000722 constant        label                    dcl 229 ref 193
rank_error                      000752 constant        label                    dcl 252 ref 41
rank_error_left                 000744 constant        label                    dcl 246 ref 48
so_rotate                       000616 constant        label                    dcl 218 ref 203

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1146        1172    1042        1156
Length      1470    1042        24         261     104           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_rotate_                         136 external procedure  is an external procedure.  
apl_push_stack_                         internal procedure  shares stack frame of external procedure apl_rotate_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_rotate_              000100 left_vb                     apl_rotate_
                         000102 left                        apl_rotate_
                         000104 next_p                      apl_rotate_
                         000106 rhorho                      apl_rotate_
                         000110 right_vb                    apl_rotate_
                         000112 right                       apl_rotate_
                         000114 save_vsp                    apl_rotate_
                         000116 characters                  apl_rotate_
                         000117 data_elements               apl_rotate_
                         000120 coord                       apl_rotate_
                         000121 left_scalar_fudge           apl_rotate_
                         000122 i                           apl_rotate_
                         000123 j                           apl_rotate_
                         000124 left_is_integer             apl_rotate_
                         000126 integer_fuzz                apl_rotate_
                         000130 temp_row_length             apl_rotate_
                         000132 temp_row_ptr                apl_rotate_
                         000134 n_words                     apl_rotate_
                         000136 result_vb                   apl_rotate_
                         000140 result                      apl_rotate_
                         000142 in_place                    apl_rotate_
                         000143 innersize                   apl_rotate_
                         000144 left_outersize              apl_rotate_
                         000145 left_outer                  apl_rotate_
                         000146 right_outer                 apl_rotate_
                         000147 inner                       apl_rotate_
                         000150 rotation                    apl_rotate_
                         000152 float_rot                   apl_rotate_
                         000154 temp_row_idx                apl_rotate_
                         000155 left_data_elements          apl_rotate_
                         000156 n_words_left_vb             apl_rotate_
                         000160 ws_info_ptr                 apl_rotate_
                         000162 number_of_dimensions        apl_rotate_
                         000174 block_ptr                   apl_push_stack_
                         000176 num_words                   apl_push_stack_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              fl2_to_fx1          fl2_to_fx2          mod_fx1             ext_entry
floor_fl

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
apl_get_value_stack_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
apl_error_table_$domain       apl_error_table_$length       apl_error_table_$operator_subscript_range
apl_error_table_$rank         apl_static_$ws_info_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000027    3    7 000037        27 000041        28 000044        30 000047        34 000051        35 000054
     36 000056        37 000062        38 000064        40 000066        41 000070        46 000072        48 000100
     51 000104        52 000106        53 000113        55 000121        57 000123        58 000131        60 000137
     63 000141        64 000145        66 000150        68 000157        70 000161        75 000166        77 000174
     78 000176        79 000200        80 000202        82 000205        83 000207        84 000211        86 000213
     88 000223        96 000224        97 000226        99 000230       101 000237       106 000244       108 000247
    111 000251       112 000253       113 000262       114 000263       116 000264       118 000273       120 000276
    122 000302       126 000312       128 000315       130 000324       132 000327       135 000331       137 000336
    139 000342       140 000344       141 000354       144 000355       146 000360       147 000363       148 000366
    149 000370       151 000372       154 000404       158 000405       163 000411       164 000413       165 000421
    166 000426       168 000430       171 000442       172 000444       176 000446       177 000455       178 000457
    180 000463       183 000474       184 000504       187 000511       189 000520       191 000523       193 000526
    197 000531       200 000536       202 000546       203 000553       206 000554       208 000563       210 000574
    211 000577       212 000603       214 000614       218 000616       220 000627       222 000646       223 000660
    224 000662       225 000667       227 000706       228 000720       229 000722       231 000724       233 000727
    238 000730       240 000735       242 000736       244 000743       246 000744       248 000746       250 000751
    252 000752       254 000754    1    4 000755    1   35 000757    1   37 000761    1   40 000766    1   43 001003
 1   44 001006    1   45 001015


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
