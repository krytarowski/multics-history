	COMPILATION LISTING OF SEGMENT gcos_build_library
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 09/09/83  1057.3 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 gcos_build_library: gcbl: build: proc;
        7 
        8 /* This procedure builds a catalog for a GCOS system-loadable file. The
        9*   catalog contains 2 words per module: program name (in BCD), and offset (of
       10*   the preface record preceeding the module). This format is similar to the
       11*   "GECALL TABLE" that is kept in core by the real GCOS, and it differs from
       12*   the format of the catalog produced by SYSEDIT for a  random system loadable
       13*   file (commonly used for ** files).
       14*
       15*   WARNING: This command can not be used to manipulate a random system loadable
       16*   file. See the GCOS PLM (AN77 for a detailed description of the differences
       17*   between a random system loadable file, a tape system loadable file, and a
       18*   simulator format software library. NOTE: THERE IS NO SUCH PLM.
       19*
       20*   The catalog occupies the first 1000 words of the file, and has room for 499
       21*   name-offset pairs.
       22*
       23*   Usage: gcbl input_path output_path -brief -append append_path
       24*
       25*   input_path
       26*
       27*   is the pathname of the input file. This file may or may not already have a
       28*   catalog. The file may have been created by this
       29*   procedure (in which case it has a catalog), or by gcos_extract_module or
       30*   gcos_pull_tapefile (in which case it does NOT have a catalog).
       31*
       32*   output_path
       33*
       34*   is the pathname of the file into which the modules in the input file (plus
       35*   those in the optional append file) are to be copied, preceeded by a catalog.
       36*   If this file already exists, it will be overwritten with no warning.
       37*
       38*   append_path
       39*
       40*   is the pathname of a file whose contents are to be appended to those of the
       41*   input file (i.e., copied to the end of the output file) before the new catalog
       42*   is built. This file is optional. If it is given, the pathname must be
       43*   preceeded by one of the two control arguments: -append, or -append_cat,
       44*   depending on whether or not the file TO BE APPENDED has a catalog.
       45*
       46*   The following is no longer the case but is kept for historical reference.
       47*   NOTE that when an append file is given, either with or without a catalog,
       48*   the input file is assumed to have a catalog, and otherwise the input file
       49*   is assumed NOT to have a catalog. This might appear at first to be an arbitrary
       50*   and unwise assumption, but use of earlier versions of this procedure has shown
       51*   that the appending function is always used to add modules to a library that is
       52*   already being used by the simulator (and thus has a catalog). (End of not true.)
       53*
       54*   NOTE that existing modules are NOT replaced by the appending function. The only
       55*   way to replace an existing module with a different version of itself is
       56*   to extract from the existing library, into a new file, all the modules EXCEPT
       57*   the one(s) to be replaced, extract the new versions of those modules into the
       58*   new file (they will be appended to those previously extracted into the file),
       59*   and then build a catalog for the new file.
       60*
       61*
       62*   WRITTEN BY DICK SNYDER .... 1971
       63*   MODIFIED BY T. CASEY JUNE 1974, AUGUST 1974
       64*   Modified: Ron Barstad  2.0  83-02-28  Added dcl precision to conform to standards
       65*                                         Added version (start with 2.0)
       66*   Modified: Ron Barstad  2.1  83-04-20  Removed catalog-nocatalog restriction
       67*
       68*   */
       69 
       70 
       71 /*  D  E  C  L  A  R  A  T  I  O  N  S      */
       72 
       73 /*  External Entries  */
       74 
       75 dcl  ios_$detach ext entry (char (*), char (*), char (*), bit (72));
       76 dcl  ios_$attach ext entry (char (*), char (*), char (*), char (*), bit (72));
       77 dcl  ios_$seek ext entry (char (*), char (*), char (*), fixed bin(24), bit (72));
       78 dcl (ios_$read, ios_$write) ext entry (char (*), pointer, fixed bin(24), fixed bin(24), fixed bin(24), bit (72));
       79 dcl  ios_$setsize ext entry (char (*), fixed bin(24), bit (72));
       80 dcl (ioa_, com_err_) ext entry options (variable);
       81 dcl (elindex, offset) fixed bin(24);
       82 dcl  progname char (6);
       83 dcl  gcos_cv_gebcd_ascii_ ext entry (pointer, fixed bin(24), pointer, fixed bin(24));
       84 
       85 dcl  cu_$arg_count entry (fixed bin, fixed bin(35));
       86 dcl  cu_$arg_ptr ext entry (fixed bin(24), ptr, fixed bin(24), fixed bin(35));
       87 
       88 /*  Work Variables */
       89 
       90 dcl  nargs fixed bin(17);
       91 dcl  argp ptr;
       92 dcl  argl fixed bin(24);
       93 dcl  arg char (argl) based (argp);
       94 dcl  argno fixed bin(24);
       95 
       96 dcl  cleanup condition;
       97 
       98 dcl  err_msg char (200) varying;
       99 
      100 dcl  cat char (4000) aligned init (" ");		/* place to build catalog */
      101 dcl  buffer char (4000) aligned init (" ");		/* buffer */
      102 dcl  first_word fixed bin(35) based (addr(buffer));         /* first word of buffer */
      103 
      104 dcl 1 catblk aligned based (catp),			/* catalog image */
      105     2 nxt fixed bin(24),				/* pointer to next cat blk */
      106     2 no_ent fixed bin(24),				/* no. of entries in this cat blk */
      107     2 elblock (499),				/* room for 499 entries */
      108       3 element bit (36) unaligned,			/* prog name */
      109       3 address fixed bin(24);				/* offset in file */
      110 
      111 dcl  catp pointer;
      112 dcl (i, j, k) fixed bin(24);				/* temps */
      113 
      114 dcl  st bit (72);					/* ios status */
      115 dcl (load_origin, pgm_length, transfer_addr, load_increment, reloc_len) fixed bin(24); /* temps */
      116 
      117 dcl 1 status aligned based (addr (st)),			/* overlay for ios_ status */
      118     2 code fixed bin (35),				/* standard error code */
      119     2 fill bit (9) unaligned,
      120     2 eof bit (1) unaligned;				/* eof bit */
      121 
      122 dcl 1 gecall aligned based (callp),			/* overlay for gecall parameters */
      123     2 prog_name bit (36) unaligned,			/* bcd pgm name */
      124     2 origin bit (18) unaligned,			/* place to begin loading */
      125     2 filler bit (18) unaligned,
      126     2 xfer_addr bit (18) unaligned;			/* transfer address */
      127 dcl  callp pointer;
      128 
      129 dcl 1 preface aligned based (prefp),			/* model of preface record */
      130     2 data_check fixed bin(24),				/* checksum of following data words */
      131     2 rel_check fixed bin(24),				/* checksum of following reloc. words */
      132     2 rel_abs fixed bin(24),				/* 0=absolute|^0=relocatable */
      133     2 name bit (36) unaligned,			/* name of pgm */
      134     2 entry bit (18) unaligned,			/* entry address */
      135     2 origin bit (18) unaligned,			/* origin */
      136     2 reloc_words fixed bin (17) unaligned,		/* no. of relocation words */
      137     2 data_words fixed bin (17) unaligned,		/* no. of data words */
      138     2 dcws (ndcw) bit (36) unaligned;			/* dcw(s) to load following data records */
      139 dcl  prefp pointer;
      140 dcl  ndcw fixed bin(24);
      141 
      142 dcl 1 dcw_model aligned based (dcwp),			/* model of dcw */
      143     2 data_addr bit (18) unaligned,
      144     2 zero bit (3) unaligned,
      145     2 action bit (3) unaligned,
      146     2 count bit (12) unaligned;			/* number of words to xfer */
      147 dcl  dcwp pointer;
      148 
      149 dcl  checker (pgm_length) bit (36) aligned based (ptr);	/* overlay for computing chksum */
      150 dcl  ptr pointer;
      151 dcl  reloc_bits (size) bit (2) based (prefp);		/* overlay for relocation record */
      152 
      153 dcl 1 gecos_reloc (size) aligned based (ptr),		/* overlay for each word of loaded pgm */
      154     2 upper bit (18) unaligned,
      155     2 lower bit (18) unaligned;
      156 dcl  size fixed bin(24);				/* size of pgm overlay arrays */
      157 dcl  accum fixed bin (71);				/* checksum accumulator */
      158 
      159 dcl (input_path, output_path, append_path, err_path) char (168);
      160 
      161 dcl  me char (24) int static options (constant) init ("gcos_build_library (2.1)");
      162 dcl  stream_names (2) char (12) int static init (
      163      "gcbl_input",
      164      "gcbl_output");
      165 
      166 dcl (briefsw
      167      , catalogsw
      168      , appendsw
      169      , append_cat_sw
      170      , append_path_sw
      171      , ineof
      172      , usage_sw
      173      ) bit (1) aligned init ("0"b);
      174 
      175 dcl  path_counter fixed bin(24)init (0);
      176 
      177 dcl (error_table_$badopt, error_table_$noarg) ext fixed bin (35);
      178 
      179 dcl (addr, divide, mod, substr) builtin;
      180 
      181 
      182 /*  */
      183 
      184 /* P  R  O  C  E  D  U  R  E     */
      185 
      186 	on condition (cleanup) call cleanup_proc;
      187 
      188 	call cu_$arg_count (nargs, code);
      189 
      190 	if nargs < 2 & code = 0 then code = error_table_$noarg;
      191 
      192 	if code ^= 0 then
      193 	     do;
      194 	     call com_err_ (code, me);
      195 
      196 print_usage:   call ioa_ ("Usage: gcbl INPUT_PATH OUTPUT_PATH {-brief} {-append APPEND_PATH}");
      197 
      198 exit:	     call cleanup_proc;
      199 
      200 	     return;
      201 
      202 	end;
      203 
      204 arg_loop:	do argno = 1 to nargs;
      205 
      206 	     call cu_$arg_ptr (argno, argp, argl, code);
      207 
      208 	     if code ^= 0 then do;
      209 		err_msg = arg;
      210 call_com_err:	call com_err_ (code, me, err_msg, err_path);
      211 		if usage_sw then goto print_usage;
      212 		else goto exit;
      213 	     end;
      214 
      215 
      216 	     err_path = arg;			/* in case of error in argument processing */
      217 
      218 	     if substr (arg, 1, 1) ^= "-" then		/* if not control argument */
      219 get_path:		do;				/* must be a pathname */
      220 						/* which one is it? */
      221 
      222 		if append_path_sw then		/* if previous argument was -append or -append_cat */
      223 get_append:	     do;
      224 		     append_path = arg;		/* save path */
      225 		     append_path_sw = "0"b;		/* remember we got it */
      226 		end get_append;
      227 
      228 		else if path_counter = 0 then		/* if we have no paths */
      229 get_input:	     do;				/* has to be input_path */
      230 		     input_path = arg;		/* save it */
      231 		     path_counter = 1;		/* remember we got it */
      232 		end get_input;
      233 
      234 		else if path_counter = 1 then		/* if we have input path */
      235 get_output:	     do;				/* this has to be output */
      236 		     output_path = arg;		/* save it */
      237 		     path_counter = 2;		/* remember we got it */
      238 		end get_output;
      239 
      240 		else do;				/* if we have both, this is garbage */
      241 		     usage_sw = "1"b;		/* tell user how to use command */
      242 		     err_msg = "unidentified non-control argument: ^a";
      243 		     code = 0;
      244 		     goto call_com_err;
      245 		end;
      246 
      247 	     end get_path;
      248 
      249 	     else if arg = "-bf" | arg = "-brief" then
      250 		briefsw = "1"b;
      251 
      252 	     else if arg = "-append" then do;
      253 append_arg:	appendsw, catalogsw = "1"b;
      254 		append_path_sw = "1"b;
      255 	     end;
      256 
      257 	     else if arg = "-append_cat" then do;
      258 		append_cat_sw = "1"b;
      259 		goto append_arg;
      260 	     end;
      261 
      262 	     else do;
      263 		code = error_table_$badopt;
      264 		err_msg = "^a";
      265 		goto call_com_err;
      266 	     end;
      267 
      268 	end arg_loop;
      269 
      270 	if path_counter ^= 2 then do;			/* complain if required paths missing */
      271 	     err_msg = "";
      272 noarg_err:     code = error_table_$noarg;
      273 	     usage_sw = "1"b;			/* show user required args */
      274 	     goto call_com_err;
      275 	end;
      276 
      277 	if append_path_sw then do;			/* if we were waiting for append path
      278*						   and it was not there, complain */
      279 	     err_msg = "append_path";
      280 	     goto noarg_err;
      281 	end;
      282 
      283 	err_path = output_path;			/* in case of error initializing output file */
      284 
      285 
      286 	call ios_$attach ("gcbl_output", "file_", output_path, "", st);
      287 	if code ^= 0 then do;
      288 attach_err:    err_msg = "from ios_$attach ^a";
      289 	     goto call_com_err;
      290 	end;
      291 
      292 	call ios_$setsize ("gcbl_output", 36, st);
      293 	if code ^= 0 then do;
      294 setsize_err:   err_msg = "from ios_$setsize ^a";
      295 	     goto call_com_err;
      296 	end;
      297 
      298 	call ios_$seek ("gcbl_output", "last", "first", 1000, st);
      299 	if code ^= 0 then do;
      300 	     err_msg = "from ios_$seek last 1000 ^a";
      301 	     goto call_com_err;
      302 	end;
      303 
      304 	call ios_$seek ("gcbl_output", "write", "first", 1000, st);
      305 	if code ^= 0 then do;
      306 	     err_msg = "from ios_$seek write 1000 ^a";
      307 	     goto call_com_err;
      308 	end;
      309 
      310 /* copy entire input (or append) file into output file */
      311 
      312 attach_input:					/* come here to attach input or append file for reading */
      313 	err_path = input_path;			/* in case of error while reading */
      314 	call ios_$attach ("gcbl_input", "file_", input_path, "r", st);
      315 	if code ^= 0 then
      316 	     goto attach_err;
      317 
      318 	call ios_$setsize ("gcbl_input", 36, st);
      319 	if code ^= 0 then
      320 	     goto setsize_err;
      321 
      322 	/*** The input or append library is determined to have or not have
      323*               a catalog by inspection. If the first word is 0, then it is a 
      324*               simulator library and has a catalog. If the first word not=0,
      325*               then the lib does not have a catalog and is a native gcos lib.
      326*                Neither catalogsw, nor append_cat_sw is examined.            */
      327 	call ios_$read ("gcbl_input", addr (buffer), 0, 1000, j, st);
      328 	if code ^= 0 then goto read_err;
      329 	if first_word ^= 0 then goto no_skip_cat;
      330 	else
      331 skip_catalog:  do;
      332 	     call ios_$seek ("gcbl_input", "read", "first", 1000, st);
      333 	     if code ^= 0 then do;
      334 seek_read_err:	err_msg = "from ios_$seek read 1000 ^a";
      335 		goto call_com_err;
      336 	     end;
      337 	end skip_catalog;
      338 
      339 /* Come here to read next 1000 words from input or append file */
      340 
      341 loop:	call ios_$read ("gcbl_input", addr (buffer), 0, 1000, j, st);
      342 	if code ^= 0 then do;
      343 read_err:	     err_msg = "from ios_$read ^a";
      344 	     goto call_com_err;
      345 	end;
      346 
      347 no_skip_cat:
      348 	if status.eof then ineof = "1"b;		/* remember end of file, since we clear status by writing */
      349 
      350 	call ios_$write ("gcbl_output", addr (buffer), 0, j, k, st);
      351 	if code ^= 0 then do;
      352 write_err:     err_msg = "from ios_$write ^a";
      353 	     err_path = output_path;
      354 	     goto call_com_err;
      355 	end;
      356 
      357 	if ^ineof then go to loop;			/* go read next block, if not end of file */
      358 
      359 	if appendsw then do;			/* eof on input...append now?? */
      360 	     ineof = "0"b;
      361 	     appendsw = "0"b;			/* after next eof we won't append again */
      362 	     catalogsw = append_cat_sw;		/* if append file has catalog, skip over it */
      363 	     call ios_$detach ("gcbl_input", "", "", st); /* detach input file */
      364 	     if code ^= 0 then do;
      365 		err_msg = "from ios_$detach ^a";
      366 		goto call_com_err;
      367 	     end;
      368 
      369 	     input_path = append_path;
      370 	     goto attach_input;			/* go attach and read append file */
      371 	end;
      372 
      373 /* Fall thru here to start reading thru output file and building catalog */
      374 
      375 	err_path = output_path;			/* in case of error on output file */
      376 
      377 	call ios_$seek ("gcbl_output", "read", "first", 1000, st); /* seek to first preface record for reading */
      378 	if code ^= 0 then
      379 	     goto seek_read_err;
      380 
      381 	call ios_$seek ("gcbl_output", "write", "first", 0, st); /* seek to start of empty catalog for writing */
      382 	if code ^= 0 then do;
      383 	     err_msg = "from ios_$seek write first ^a";
      384 	     goto call_com_err;
      385 	end;
      386 
      387 
      388 	catp = addr (cat);				/* place to build catalog */
      389 	prefp = addr (buffer);			/* place to read preface records into */
      390 	catblk.nxt = 0;				/* clear rel ptr to next catalog block (there never is
      391*						   another catalog block) */
      392 	elindex = 1;				/* first modue - first catalog position */
      393 	offset = 1000;				/* offset of its preface record */
      394 
      395 read:	call ios_$read ("gcbl_output", prefp, 0, 1000, j, st); /* read the preface record */
      396 	if code ^= 0 then goto read_err;
      397 
      398 	elblock (elindex).element = preface.name;	/* copy name */
      399 	elblock (elindex).address = offset;		/* copy preface offset */
      400 	elindex = elindex + 1;			/* bump index */
      401 	if elindex = 500 then do;
      402 	     code = 0;
      403 	     err_msg = "catalog overflow - more than 499 modules in file: ^a";
      404 	     goto call_com_err;
      405 	end;
      406 
      407 	if ^briefsw then do;			/* unless told not to, print name and offset */
      408 	     call gcos_cv_gebcd_ascii_ (addr (preface.name), 6, addr (progname), j);
      409 	     call ioa_ ("^a ^o", progname, offset);
      410 	end;
      411 
      412 /* Count DCWs, by looking for one with action code = "000"b */
      413 
      414 	do ndcw = 1 to 58				/* there may be up to 58 of them in a block */
      415 		while (substr (preface.dcws (ndcw), 22, 3) ^= "000"b);
      416 	end;
      417 
      418 	offset = offset+6+ndcw+preface.data_words+preface.reloc_words; /* compute offset of next preface record */
      419 
      420 	call ios_$seek ("gcbl_output", "read", "first", offset, st); /* seek to it */
      421 	if code ^= 0 then do;
      422 	     err_msg = "from ios_$seek read next_preface ^a";
      423 	     goto call_com_err;
      424 	end;
      425 
      426 	if ^eof then go to read;			/* if not end of file on seek, go read it */
      427 
      428 	call ioa_ ("end of file");
      429 
      430 	catblk.no_ent = elindex-1;			/* compute total elements in catalog */
      431 	call ios_$write ("gcbl_output", addr (cat), 0, 1000, j, st); /* write catalog into file */
      432 	if code ^= 0 then
      433 	     goto write_err;
      434 
      435 	goto exit;				/* all done */
      436 
      437 
      438 cleanup_proc: proc;
      439 
      440 	     do i = 1 to 2;
      441 		call ios_$detach (stream_names (i), "", "", st);
      442 	     end;
      443 	     return;
      444 	end cleanup_proc;
      445 
      446      end gcos_build_library;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/09/83  1006.5  gcos_build_library.pl1            >spec>on>09/07/83-gcos>gcos_build_library.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 179 ref 188 190 190 192 194 206 208 210 243 263
                                                                                  272 287 293 299 305 315 319 327 327 328 329 333
                                                                                  341 341 342 347 350 350 351 364 378 382 388 389
                                                                                  396 402 408 408 408 408 421 426 431 431 432
address                   3            based           fixed bin(24,0)          array level 3 dcl 104 set ref 399*
append_cat_sw                   004412 automatic       bit(1)                   initial dcl 166 set ref 166* 258* 362
append_path                     004263 automatic       char(168)                unaligned dcl 159 set ref 224* 369
append_path_sw                  004413 automatic       bit(1)                   initial dcl 166 set ref 166* 222 225* 254* 277
appendsw                        004411 automatic       bit(1)                   initial dcl 166 set ref 166* 253* 359 361*
arg                                    based           char                     unaligned dcl 93 ref 209 216 218 224 230 236 249 249
                                                                                  252 257
argl                            000110 automatic       fixed bin(24,0)          dcl 92 set ref 206* 209 216 218 224 230 236 249 249
                                                                                  252 257
argno                           000111 automatic       fixed bin(24,0)          dcl 94 set ref 204* 206*
argp                            000106 automatic       pointer                  dcl 91 set ref 206* 209 216 218 224 230 236 249 249
                                                                                  252 257
briefsw                         004407 automatic       bit(1)                   initial dcl 166 set ref 166* 249* 407
buffer                          002153 automatic       char(4000)               initial dcl 101 set ref 101* 327 327 329 341 341 350
                                                                                  350 389
cat                             000203 automatic       char(4000)               initial dcl 100 set ref 100* 388 431 431
catalogsw                       004410 automatic       bit(1)                   initial dcl 166 set ref 166* 253* 362*
catblk                                 based           structure                level 1 dcl 104
catp                            004124 automatic       pointer                  dcl 111 set ref 388* 390 398 399 430
cleanup                         000112 stack reference condition                dcl 96 ref 186
code                                   based           fixed bin(35,0)          level 2 dcl 117 set ref 188* 190 190* 192 194* 206*
                                                                                  208 210* 243* 263* 272* 287 293 299 305 315 319
                                                                                  328 333 342 351 364 378 382 396 402* 421 432
com_err_                        000034 constant        entry                    external dcl 80 ref 194 210
cu_$arg_count                   000040 constant        entry                    external dcl 85 ref 188
cu_$arg_ptr                     000042 constant        entry                    external dcl 86 ref 206
data_words                5(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 129 ref 418
dcws                      6            based           bit(36)                  array level 2 packed unaligned dcl 129 ref 414
elblock                   2            based           structure                array level 2 dcl 104
element                   2            based           bit(36)                  array level 3 packed unaligned dcl 104 set ref 398*
elindex                         000100 automatic       fixed bin(24,0)          dcl 81 set ref 392* 398 399 400* 400 401 430
eof                       1(09)        based           bit(1)                   level 2 packed unaligned dcl 117 ref 347 426
err_msg                         000120 automatic       varying char(200)        dcl 98 set ref 209* 210* 242* 264* 271* 279* 288*
                                                                                  294* 300* 306* 334* 343* 352* 365* 383* 403* 422*
err_path                        004335 automatic       char(168)                unaligned dcl 159 set ref 210* 216* 283* 312* 353*
                                                                                  375*
error_table_$badopt             000044 external static fixed bin(35,0)          dcl 177 ref 263
error_table_$noarg              000046 external static fixed bin(35,0)          dcl 177 ref 190 272
first_word                             based           fixed bin(35,0)          dcl 102 ref 329
gcos_cv_gebcd_ascii_            000036 constant        entry                    external dcl 83 ref 408
i                               004126 automatic       fixed bin(24,0)          dcl 112 set ref 440* 441*
ineof                           004414 automatic       bit(1)                   initial dcl 166 set ref 166* 347* 357 360*
input_path                      004137 automatic       char(168)                unaligned dcl 159 set ref 230* 312 314* 369*
ioa_                            000032 constant        entry                    external dcl 80 ref 196 409 428
ios_$attach                     000020 constant        entry                    external dcl 76 ref 286 314
ios_$detach                     000016 constant        entry                    external dcl 75 ref 363 441
ios_$read                       000024 constant        entry                    external dcl 78 ref 327 341 395
ios_$seek                       000022 constant        entry                    external dcl 77 ref 298 304 332 377 381 420
ios_$setsize                    000030 constant        entry                    external dcl 79 ref 292 318
ios_$write                      000026 constant        entry                    external dcl 78 ref 350 431
j                               004127 automatic       fixed bin(24,0)          dcl 112 set ref 327* 341* 350* 395* 408* 431*
k                               004130 automatic       fixed bin(24,0)          dcl 112 set ref 350*
me                              000000 constant        char(24)                 initial unaligned dcl 161 set ref 194* 210*
name                      3            based           bit(36)                  level 2 packed unaligned dcl 129 set ref 398 408 408
nargs                           000104 automatic       fixed bin(17,0)          dcl 90 set ref 188* 190 204
ndcw                            004136 automatic       fixed bin(24,0)          dcl 140 set ref 414* 414* 418
no_ent                    1            based           fixed bin(24,0)          level 2 dcl 104 set ref 430*
nxt                                    based           fixed bin(24,0)          level 2 dcl 104 set ref 390*
offset                          000101 automatic       fixed bin(24,0)          dcl 81 set ref 393* 399 409* 418* 418 420*
output_path                     004211 automatic       char(168)                unaligned dcl 159 set ref 236* 283 286* 353 375
path_counter                    004416 automatic       fixed bin(24,0)          initial dcl 175 set ref 175* 228 231* 234 237* 270
preface                                based           structure                level 1 dcl 129
prefp                           004134 automatic       pointer                  dcl 139 set ref 389* 395* 398 408 408 414 418 418
progname                        000102 automatic       char(6)                  unaligned dcl 82 set ref 408 408 409*
reloc_words               5            based           fixed bin(17,0)          level 2 packed unaligned dcl 129 ref 418
st                              004132 automatic       bit(72)                  unaligned dcl 114 set ref 188 190 190 192 194 206
                                                                                  208 210 243 263 272 286* 287 292* 293 298* 299
                                                                                  304* 305 314* 315 318* 319 327* 328 332* 333 341*
                                                                                  342 347 350* 351 363* 364 377* 378 381* 382 395*
                                                                                  396 402 420* 421 426 431* 432 441*
status                                 based           structure                level 1 dcl 117
stream_names                    000010 internal static char(12)                 initial array unaligned dcl 162 set ref 441*
substr                                                 builtin function         dcl 179 ref 218 414
usage_sw                        004415 automatic       bit(1)                   initial dcl 166 set ref 166* 211 241* 273*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
accum                                  automatic       fixed bin(71,0)          dcl 157
callp                                  automatic       pointer                  dcl 127
checker                                based           bit(36)                  array dcl 149
dcw_model                              based           structure                level 1 dcl 142
dcwp                                   automatic       pointer                  dcl 147
divide                                                 builtin function         dcl 179
gecall                                 based           structure                level 1 dcl 122
gecos_reloc                            based           structure                array level 1 dcl 153
load_increment                         automatic       fixed bin(24,0)          dcl 115
load_origin                            automatic       fixed bin(24,0)          dcl 115
mod                                                    builtin function         dcl 179
pgm_length                             automatic       fixed bin(24,0)          dcl 115
ptr                                    automatic       pointer                  dcl 150
reloc_bits                             based           bit(2)                   array unaligned dcl 151
reloc_len                              automatic       fixed bin(24,0)          dcl 115
size                                   automatic       fixed bin(24,0)          dcl 156
transfer_addr                          automatic       fixed bin(24,0)          dcl 115

NAMES DECLARED BY EXPLICIT CONTEXT.
append_arg                      000577 constant        label                    dcl 253 ref 259
arg_loop                        000412 constant        label                    dcl 204
attach_err                      000713 constant        label                    dcl 288 ref 315
attach_input                    001105 constant        label                    dcl 312 ref 370
build                           000260 constant        entry                    external dcl 6
call_com_err                    000453 constant        label                    dcl 210 ref 244 265 274 289 295 301 307 335 344 354
                                                                                  366 384 404 423
cleanup_proc                    002242 constant        entry                    internal dcl 438 ref 186 198
exit                            000405 constant        label                    dcl 198 ref 212 435
gcbl                            000270 constant        entry                    external dcl 6
gcos_build_library              000300 constant        entry                    external dcl 6
get_append                      000516 constant        label                    dcl 222
get_input                       000526 constant        label                    dcl 228
get_output                      000537 constant        label                    dcl 234
get_path                        000514 constant        label                    dcl 218
loop                            001333 constant        label                    dcl 341 ref 357
no_skip_cat                     001410 constant        label                    dcl 347 ref 329
noarg_err                       000631 constant        label                    dcl 272 ref 280
print_usage                     000371 constant        label                    dcl 196 ref 211
read                            001701 constant        label                    dcl 395 ref 426
read_err                        001402 constant        label                    dcl 343 ref 328 396
seek_read_err                   001325 constant        label                    dcl 334 ref 378
setsize_err                     000752 constant        label                    dcl 294 ref 319
skip_catalog                    001257 constant        label                    dcl 330
write_err                       001461 constant        label                    dcl 352 ref 432

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2504        2554    2310        2514
Length      2764    2310        50         173     173           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
build                              2426 external procedure  is an external procedure.  
on unit on line 186                  64 on unit               
cleanup_proc                         84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 stream_names                build

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
build                    000100 elindex                     build
                         000101 offset                      build
                         000102 progname                    build
                         000104 nargs                       build
                         000106 argp                        build
                         000110 argl                        build
                         000111 argno                       build
                         000120 err_msg                     build
                         000203 cat                         build
                         002153 buffer                      build
                         004124 catp                        build
                         004126 i                           build
                         004127 j                           build
                         004130 k                           build
                         004132 st                          build
                         004134 prefp                       build
                         004136 ndcw                        build
                         004137 input_path                  build
                         004211 output_path                 build
                         004263 append_path                 build
                         004335 err_path                    build
                         004407 briefsw                     build
                         004410 catalogsw                   build
                         004411 appendsw                    build
                         004412 append_cat_sw               build
                         004413 append_path_sw              build
                         004414 ineof                       build
                         004415 usage_sw                    build
                         004416 path_counter                build

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   gcos_cv_gebcd_ascii_
ioa_                          ios_$attach                   ios_$detach                   ios_$read
ios_$seek                     ios_$setsize                  ios_$write

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    100 000237       101 000242       166 000245       175 000254         6 000257       186 000306       188 000330
    190 000341       192 000353       194 000355       196 000371       198 000405       200 000411       204 000412
    206 000421       208 000436       209 000442       210 000453       211 000500       212 000502       216 000503
    218 000510       222 000514       224 000516       225 000522       226 000523       228 000524       230 000526
    231 000532       232 000534       234 000535       236 000537       237 000543       238 000545       241 000546
    242 000550       243 000555       244 000556       247 000557       249 000560       252 000573       253 000577
    254 000602       255 000603       257 000604       258 000610       259 000612       263 000613       264 000616
    265 000622       268 000623       270 000625       271 000630       272 000631       273 000634       274 000636
    277 000637       279 000641       280 000646       283 000647       286 000652       287 000711       288 000713
    289 000720       292 000721       293 000750       294 000752       295 000757       298 000760       299 001023
    300 001025       301 001032       304 001033       305 001075       306 001077       307 001104       312 001105
    314 001110       315 001152       318 001154       319 001204       327 001206       328 001253       329 001255
    332 001257       333 001323       334 001325       335 001332       341 001333       342 001400       343 001402
    344 001407       347 001410       350 001415       351 001457       352 001461       353 001466       354 001471
    357 001472       359 001474       360 001476       361 001477       362 001500       363 001502       364 001533
    365 001535       366 001542       369 001543       370 001546       375 001547       377 001552       378 001615
    381 001617       382 001660       383 001662       384 001667       388 001670       389 001672       390 001674
    392 001675       393 001677       395 001701       396 001743       398 001745       399 001752       400 001756
    401 001757       402 001762       403 001763       404 001770       407 001771       408 001773       409 002016
    414 002041       416 002053       418 002055       420 002073       421 002134       422 002140       423 002145
    426 002146       428 002151       430 002166       431 002172       432 002236       435 002240       438 002241
    440 002247       441 002256       442 002303       443 002306


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
