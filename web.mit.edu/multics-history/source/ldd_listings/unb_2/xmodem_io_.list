	COMPILATION LISTING OF SEGMENT xmodem_io_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/19/84  0934.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2 */
        7 /*  the user ring xmodem io module --- xmodem_io_
        8*    Uses the xmodem protocol, defined by Ward Christensen, for data
        9*    transfer.    
       10*
       11*    1. Definitions
       12*    
       13*         <soh>  01(HEX)  01(OCT)
       14*         <eot>  04(HEX)  04(OCT)
       15*         <ack>  06(HEX)  06(OCT)
       16*         <nak>  15(HEX)  25(OCT)
       17*    
       18*    2. Transmission Medium Level Protocol
       19*    
       20*         Asynchronous, 8 data bits, no parity, one stop bit.
       21*    
       22*         There are no restrictions on the contents of the data being 
       23*    transmitted.  Any kind of data may be sent: binary, ASCII, etc.  No 
       24*    control characters are looked for in the 128-byte data messages.
       25*    
       26*    3. Message Block Level Protocol
       27*         The standard transmission portion of the block is a 132 character
       28*    block without framing characters.  Each block of the transfer looks like:
       29*    
       30*         <SOH><blk #><255-blk #><..128 data bytes..><chksum> where:
       31*    
       32*         <SOH>       =   01 (Hex).
       33*         <blk #>     =   binary number, starts at 01 increments by 1
       34*                         and wraps 0FF (Hex) to 00 (Hex).
       35*         <255-blk #> =   The one's complement of the block number.
       36*         <cksum>     =   The sum of the data bytes only.
       37*    
       38*    4. File Level Protocol
       39*    
       40*    4a. Common to Both Sender and Receiver
       41*    
       42*         All errors are retried 10 times.  
       43*    
       44*    4b. Receive Program Considerations
       45*    
       46*     The receiver has a 10-second timeout.  Once transmission begins, it
       47*sends a <nak> every time it times out.
       48*
       49*Before transmission begins, the receiver performs a handshake with the 
       50*sender to determine the type of error detecting code to be used during 
       51*transmission.  If in checksum mode, the receiver's first timeout sends
       52*a <nak> to request checksum mode, and signals the transmitter to start.
       53*If in CRC mode, the receiver's first timeout sends a "C" to request
       54*CRC mode.  It then waits for up to 10 seconds for an <soh>.  This process 
       55*continues until either (1) six "C"'s have been sent without receiving an
       56*<soh>, or (2) an <soh> is received within 10 seconds of sending a "C".  If
       57*an <soh> is received within 10 seconds of sending a "C", it is assumed that 
       58*the "C" was accepted by the sender and that it will send in CRC mode. 
       59*If six "C"'s are sent without receiving an <soh>, the receiver switches to
       60*checksum mode and sends  out a <nak>.
       61*
       62*     Once into receiving a block, the receiver goes into a one-second
       63*timeout for each character and the checksum.  If a valid block is
       64*received, the receiver will transmit an <ack>.  For invalid blocks,
       65*a <nak> is transmitted.
       66*
       67*    
       68*    4c. Sending Program Considerations
       69*         
       70*         The sender has a high-level 110-second timeout.  If a timeout occurs,
       71*    transmission is aborted.
       72*
       73*         The sender starts transmission upon receipt of a <nak> or a "C".
       74*    An initial <nak> causes the sender to transmit in checksum mode, while
       75*    a "C" signals the sender to transmit in CRC mode.
       76*
       77*    If the block was successfully received (receiver sends an <ack>),
       78*    the next block is sent.  If the receiver responds with a <nak>,
       79*    the sender retransmits the last block.  When the sender has no more 
       80*    data, it sends an <eot>, and awaits an <ack>, resending the <eot> if
       81*    it doesn't get one.
       82*
       83*    Status:
       84*    0) 24 August 1984:  Initial coding, M. Mallmes.
       85**/
       86 
       87 
       88 xmodem_io_:
       89      proc;
       90 	return;					/* not an entry  */
       91 						/*  iox_ io module for xmodem protocol i/o written 6/84 by M.J. Mallmes  */
       92 
       93 /*  Parameters  */
       94 
       95 	dcl     arg_actual_len	 fixed bin (21);
       96 	dcl     arg_buf_ptr		 ptr;		/* ptr to user buffer (input) */
       97 	dcl     arg_buf_len		 fixed bin (21);	/* length of user buffer (input) */
       98 	dcl     arg_iocbp		 ptr;		/* ptr to iocb (input) */
       99 	dcl     code		 fixed bin (35);	/*  Multics standard error code  (output */
      100 	dcl     com_err_switch	 bit (1) aligned;	/* ON if should call com_err_ for errors (input)  */
      101 	dcl     mode		 fixed bin;
      102 	dcl     option_array	 (*) char (*) varying;
      103 
      104 
      105 /*  Automatic  */
      106 
      107 	dcl     actual_iocbp	 ptr;		/* copy of iocb.actual_iocb_ptr */
      108 	dcl     arg_buf_pos		 fixed bin;	/* index into passed argument buffer  */
      109 	dcl     attach_data_ptr	 ptr;		/* ptr to iocb's attach_data  */
      110 	dcl     block_rx		 char (1);
      111 	dcl     block_rx_1		 char (1);
      112 	dcl     check_char		 (2) char (1);
      113 	dcl     buf_ptr		 ptr;
      114 	dcl     ec		 fixed bin (35);
      115 	dcl     edc		 fixed bin;
      116 	dcl     i			 fixed bin;
      117 	dcl     iocbp		 ptr;		/*  copy of arg_iocbp */
      118 	dcl     mask		 bit (36) aligned;	/* ips mask */
      119 	dcl     newline_found	 bit (1);
      120 	dcl     newline_needed	 bit (1);
      121 	dcl     packet_type		 char (1);
      122 	dcl     retry_count		 fixed bin;
      123 	dcl     system_free_area_ptr	 ptr;
      124 	dcl     successful		 bit (1);
      125 	dcl     buffer_empty	 bit (1);		/* ON of a packet is to be received  */
      126 	dcl     buffer_full		 bit (1);		/* ON of a packet is to be sent  */
      127 
      128 /*  Based  */
      129 
      130 	dcl     01 attach_data	 aligned based (attach_data_ptr),
      131 						/* iocb attach_data */
      132 		02 attach_descrip	 char (256) varying,
      133 		02 open_descrip	 char (32) varying,
      134 		02 target_iocbp	 ptr,		/* ptr to target switch iocb */
      135 		02 buf		 char (128),	/* internal buffer  */
      136 		02 buf_pos	 fixed bin (21),	/*  index into buf  */
      137 		02 my_rx_n	 uns fixed bin (9) unal,
      138 						/* packet number when receiving */
      139 		02 my_tx_n	 uns fixed bin (9) unal,
      140 						/* packet number when sending */
      141 		02 error_code	 fixed bin (35),	/* 0 if normal close operation */
      142 		02 crc_init	 bit (1) unal,
      143 		02 block_check_type	 fixed bin;	/* Check type being used  */
      144 
      145 	dcl     01 open_descrip	 based aligned,	/* open description for iocb  */
      146 		02 length		 fixed bin (17),
      147 		02 string		 char (0 refer (open_descrip.length));
      148 
      149 	dcl     system_free_area	 area based (system_free_area_ptr);
      150 
      151 /*  Constants  */
      152 
      153 	dcl     Abort_Interval	 fixed bin (71) static options (constant) init (100000000);
      154 						/* 110 seconds */
      155 	dcl     ACK		 char (1) static options (constant) init ("");
      156 	dcl     Buf_Size		 fixed bin (21) static options (constant) init (128);
      157 	dcl     CAN		 char (1) static options (constant) init ("");
      158 	dcl     Check_Sum		 fixed bin static options (constant) init (1);
      159 	dcl     Cyclic_Redundancy_Code fixed bin static options (constant) init (2);
      160 	dcl     Dim_name		 char (10) static options (constant) init ("xmodem_io_");
      161 	dcl     EOT		 char (1) static options (constant) init ("");
      162 	dcl     NAK		 char (1) static options (constant) init ("");
      163 	dcl     NL		 char (1) static options (constant) init ("
      164 ");
      165 	dcl     NUL		 char (1) static options (constant) init (" ");
      166 	dcl     Retry_Threshold	 fixed bin static options (constant) init (10);
      167 	dcl     SOH		 char (1) static options (constant) init ("");
      168 	dcl     Timeout_Interval	 fixed bin (71) static options (constant) init (10000000);
      169 						/* 10 seconds */
      170 
      171 /*  Builtin    */
      172 
      173 	dcl     (addcharno, addr, byte, bool, hbound, index, lbound, mod, null, rank, rtrim, substr, unspec)
      174 				 builtin;
      175 
      176 /* Conditions */
      177 
      178 	dcl     (any_other, cleanup)	 condition;
      179 
      180 /*  External Static  */
      181 
      182 	dcl     error_table_$bad_arg	 fixed bin (35) ext static;
      183 	dcl     error_table_$bad_mode	 fixed bin (35) ext static;
      184 	dcl     error_table_$badopt	 fixed bin (35) ext static;
      185 	dcl     error_table_$end_of_info
      186 				 fixed bin (35) ext static;
      187 	dcl     error_table_$incompatible_attach
      188 				 fixed bin (35) ext static;
      189 	dcl     error_table_$long_record
      190 				 fixed bin (35) ext static;
      191 	dcl     error_table_$noarg	 fixed bin (35) ext static;
      192 	dcl     error_table_$no_iocb	 fixed bin (35) ext static;
      193 	dcl     error_table_$not_attached
      194 				 fixed bin (35) ext static;
      195 	dcl     error_table_$not_detached
      196 				 fixed bin (35) ext static;
      197 	dcl     error_table_$not_open	 fixed bin (35) ext static;
      198 	dcl     error_table_$timeout	 fixed bin (35) ext static;
      199 	dcl     error_table_$unable_to_do_io
      200 				 fixed bin (35) ext static;
      201 
      202 /*  Procedures       */
      203 
      204 	dcl     com_err_		 entry () options (variable);
      205 	dcl     get_system_free_area_	 entry () returns (ptr);
      206 	dcl     hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      207 	dcl     hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      208 	dcl     iox_$err_no_operation	 entry () options (variable);
      209 	dcl     iox_$err_not_attached	 entry () options (variable);
      210 	dcl     iox_$err_not_open	 entry () options (variable);
      211 	dcl     iox_$err_not_closed	 entry () options (variable);
      212 	dcl     iox_$look_iocb	 entry (char (*), ptr, fixed bin (35));
      213 	dcl     iox_$propagate	 entry (ptr);
      214 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      215 	dcl     timed_io_$get_chars	 entry (ptr, fixed bin (71), ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      216 
      217 
      218 
      219 
      220 /*  Include Files    */
      221 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     3*      version number to IOX2. */
  1     4 /* format: style2 */
  1     5 
  1     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     7 	     2 version	      character (4) aligned,	/* IOX2 */
  1     8 	     2 name	      char (32),		/* I/O name of this block. */
  1     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    17 						/* open(p,mode,not_used,s) */
  1    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    24 						/* put_chars(p,bufptr,buflen,s) */
  1    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    26 						/* modes(p,newmode,oldmode,s) */
  1    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    28 						/* position(p,u1,u2,s) */
  1    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    30 						/* control(p,order,infptr,s) */
  1    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* write_record(p,bufptr,buflen,s) */
  1    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    36 						/* rewrite_record(p,bufptr,buflen,s) */
  1    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* seek_key(p,key,len,s) */
  1    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    41 						/* read_key(p,key,len,s) */
  1    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  1    43 						/* read_length(p,len,s) */
  1    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    45 						/* open_file(p,mode,desc,not_used,s) */
  1    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    47 						/* close_file(p,desc,s) */
  1    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  1    49 						/* detach(p,desc,s) */
  1    50 
  1    51      declare iox_$iocb_version_sentinel
  1    52 			      character (4) aligned external static;
  1    53 
  1    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      222 
      223 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
      224 
      225 
      226 
      227 /*  This entry attaches the xmodem_io_ i/o module after verifying that
      228*    the target switch is open for stream_input_output  */
      229 
      230 xmodem_io_attach:
      231      entry (arg_iocbp, option_array, com_err_switch, code);
      232 
      233 	ec = 0;
      234 	mask = ""b;
      235 	iocbp = arg_iocbp;
      236 
      237 	if hbound (option_array, 1) < 1
      238 	then call error (0, com_err_switch, error_table_$noarg, "Usage:  xmodem_io_ switch_name {-control_arguments}");
      239 
      240 	attach_data_ptr = null ();
      241 	on cleanup call clean_up_attach;
      242 
      243 	if iocbp -> iocb.attach_descrip_ptr ^= null ()
      244 	then call error (0, com_err_switch, error_table_$not_detached, "");
      245 
      246 	system_free_area_ptr = get_system_free_area_ ();
      247 	allocate attach_data in (system_free_area) set (attach_data_ptr);
      248 
      249 /*  see if the target switch is attached and open  for stream_input_output */
      250 	call iox_$look_iocb (rtrim (option_array (1)), target_iocbp, ec);
      251 	if ec = error_table_$no_iocb
      252 	then call error (1, com_err_switch, ec, rtrim (option_array (1)));
      253 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.attach_descrip_ptr = null
      254 	then call error (1, com_err_switch, error_table_$not_attached, rtrim (option_array (1)));
      255 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr = null
      256 	then call error (1, com_err_switch, error_table_$not_open, rtrim (option_array (1)));
      257 	if target_iocbp -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr -> open_descrip.string
      258 	     ^= iox_modes (Stream_input_output)
      259 	then call error (1, com_err_switch, error_table_$bad_mode, rtrim (option_array (1)));
      260 
      261 	edc = Check_Sum;
      262 	do i = lbound (option_array, 1) + 1 to hbound (option_array, 1);
      263 	     if option_array (i) = "-error_detection_code" | option_array (i) = "-edc"
      264 	     then do;
      265 		     i = i + 1;
      266 		     if i > hbound (option_array, 1)
      267 		     then call error (1, com_err_switch, error_table_$noarg,
      268 			     "-edc given without an error correction code");
      269 		     if option_array (i) = "cyclic_redundancy_code" | option_array (i) = "crc"
      270 		     then edc = Cyclic_Redundancy_Code;
      271 		     else if option_array (i) = "check_sum" | option_array (i) = "cs"
      272 		     then edc = Check_Sum;
      273 		     else call error (1, com_err_switch, error_table_$badopt, rtrim (option_array (i)));
      274 		end;
      275 	     else call error (1, com_err_switch, error_table_$badopt, rtrim (option_array (i)));
      276 	end;
      277 
      278 	attach_data.attach_descrip = Dim_name || " " || rtrim (option_array (1));
      279 	attach_data.open_descrip = "";
      280 	attach_data.block_check_type = edc;
      281 	if edc = Cyclic_Redundancy_Code
      282 	then attach_data.crc_init = "1"b;
      283 	else attach_data.crc_init = "0"b;
      284 	attach_data.my_rx_n = 1;
      285 	attach_data.my_tx_n = 1;
      286 	attach_data.buf_pos = 0;
      287 	attach_data.error_code = 0;
      288 
      289 	call hcs_$set_ips_mask (""b, mask);
      290 	iocbp -> iocb.attach_data_ptr = attach_data_ptr;
      291 	iocbp -> iocb.attach_descrip_ptr = addr (attach_data.attach_descrip);
      292 	iocbp -> iocb.detach_iocb = xmodem_io_detach;
      293 	iocbp -> iocb.open_descrip_ptr = null ();
      294 	iocbp -> iocb.open = xmodem_io_open;
      295 	iocbp -> iocb.modes = iox_$err_no_operation;
      296 	iocbp -> iocb.control = iox_$err_no_operation;
      297 	call iox_$propagate (iocbp);
      298 	call hcs_$reset_ips_mask (mask, ""b);
      299 EXIT:
      300 	return;
      301 
      302 
      303 
      304 /*  Error calls com_err_ if the loud switch is set and goes to the attach return */
      305 
      306 error:
      307      proc (cleanup_level, call_com_err, ec, msg);
      308 
      309 	dcl     cleanup_level	 fixed bin;
      310 	dcl     call_com_err	 bit (1) aligned;
      311 	dcl     ec		 fixed bin (35);	/* Multics standard error code */
      312 	dcl     msg		 char (*);	/* Additional error information */
      313 
      314 	goto Err (cleanup_level);
      315 
      316 Err (1):
      317 	free attach_data;
      318 
      319 Err (0):
      320 	if call_com_err
      321 	then call com_err_ (ec, Dim_name, "^a", msg);
      322 	code = ec;
      323 	goto EXIT;
      324      end error;
      325 
      326 
      327 
      328 
      329 /*  This entry detaches the xmodem_io_ i/o module and frees the associated
      330*    information  */
      331 
      332 xmodem_io_detach:
      333      entry (arg_iocbp, code);
      334 
      335 	call set_up;
      336 	on any_other call handler;
      337 	call hcs_$set_ips_mask ("0"b, mask);
      338 	actual_iocbp -> iocb.attach_descrip_ptr = null ();
      339 	actual_iocbp -> iocb.attach_data_ptr = null ();
      340 	actual_iocbp -> iocb.open = iox_$err_not_attached;
      341 	actual_iocbp -> iocb.detach_iocb = iox_$err_not_attached;
      342 	call iox_$propagate (actual_iocbp);
      343 	call hcs_$reset_ips_mask (mask, "0"b);
      344 	revert any_other;
      345 	free attach_data;
      346 	return;
      347 
      348 
      349 
      350 /*  This entry sets the open description and the legal operation entries
      351*    in the iocb.  Operation permitted:
      352*
      353*             all the time: close
      354*	   input:        get_chars, get_line
      355*	   output:       put_chars
      356*
      357*    Before returning it performs a handshake with the remote xmodem,
      358*    determining the type of error correction code to be used.      */
      359 
      360 xmodem_io_open:
      361      entry (arg_iocbp, mode, com_err_switch, code);
      362 
      363 	on cleanup attach_data.error_code = 1;
      364 	call set_up;
      365 
      366 	if mode = Stream_input | mode = Stream_output
      367 	then do;
      368 		if mode = Stream_output & crc_init
      369 		then do;
      370 			code = error_table_$incompatible_attach;
      371 			return;
      372 		     end;
      373 		else attach_data_ptr -> attach_data.open_descrip = iox_modes (mode);
      374 	     end;
      375 
      376 	else do;
      377 		code = error_table_$bad_mode;
      378 		return;
      379 	     end;
      380 
      381 	if mode = Stream_output
      382 	then do;					/* Perform handshake - sender */
      383 		call get_char (packet_type, Abort_Interval, ec);
      384 		retry_count = 2;
      385 
      386 		do while (ec = 0 & packet_type ^= NAK & packet_type ^= "C" & retry_count <= Retry_Threshold);
      387 		     call get_char (packet_type, Abort_Interval, ec);
      388 		     retry_count = retry_count + 1;
      389 		end;
      390 
      391 		if retry_count > Retry_Threshold | ec ^= 0
      392 		then do;
      393 			if ec = error_table_$timeout | retry_count > Retry_Threshold
      394 			then code = error_table_$unable_to_do_io;
      395 			else code = ec;
      396 			return;
      397 		     end;
      398 
      399 		if packet_type = "C"
      400 		then attach_data.block_check_type = Cyclic_Redundancy_Code;
      401 		else attach_data.block_check_type = Check_Sum;
      402 	     end;
      403 
      404 
      405 	if mode = Stream_input
      406 	then do;					/* Perform handshake - receiver */
      407 
      408 		if attach_data.crc_init
      409 		then do;
      410 			call get_data_packet (ec);
      411 			if ec ^= 0
      412 			then do;
      413 				attach_data.buf_pos = 0;
      414 				code = ec;
      415 				return;
      416 			     end;
      417 			attach_data.my_rx_n = mod (attach_data.my_rx_n + 1, 256);
      418 			attach_data.crc_init = "0"b;
      419 		     end;
      420 	     end;
      421 
      422 
      423 	on any_other call handler;
      424 
      425 	call hcs_$set_ips_mask (""b, mask);
      426 	actual_iocbp -> iocb.open_descrip_ptr = addr (attach_data.open_descrip);
      427 	actual_iocbp -> iocb.open = iox_$err_not_closed;
      428 	actual_iocbp -> iocb.close = xmodem_io_close;
      429 	actual_iocbp -> iocb.detach_iocb = iox_$err_not_closed;
      430 	if mode = Stream_input
      431 	then do;
      432 		actual_iocbp -> iocb.get_line = xmodem_io_get_line;
      433 		actual_iocbp -> iocb.get_chars = xmodem_io_get_chars;
      434 	     end;
      435 	else if mode = Stream_output
      436 	then actual_iocbp -> iocb.put_chars = xmodem_io_put_chars;
      437 	call iox_$propagate (actual_iocbp);
      438 	call hcs_$reset_ips_mask (mask, ""b);
      439 	revert any_other;
      440 
      441 	return;
      442 
      443 
      444 /*  This procedure closes the xmodem i/o switch.  If the switch was
      445*    open for stream_output it flushes the output buffer and sends
      446*    an EOT control character to the remote xmodem.
      447*    If the last packet cannot be transmitted, the i/o switch is
      448*    closed and the error code error_table_$unable_to_do_io is returned.   */
      449 
      450 xmodem_io_close:
      451      entry (arg_iocbp, code);
      452 
      453 	on cleanup attach_data.error_code = 1;
      454 	call set_up;
      455 
      456 	if actual_iocbp -> iocb.open_descrip_ptr -> open_descrip.string = iox_modes (Stream_output)
      457 	     & attach_data.error_code = 0
      458 	then do;
      459 		call flush_output (ec);
      460 
      461 		if ec = 0
      462 		then do;				/*  send EOT */
      463 			call send_char (EOT);
      464 			call get_char (packet_type, Timeout_Interval, ec);
      465 			do retry_count = 2 to Retry_Threshold
      466 			     while (packet_type ^= ACK | ec = error_table_$timeout);
      467 			     call send_char (EOT);
      468 			     call get_char (packet_type, Timeout_Interval, ec);
      469 			end;
      470 		     end;
      471 
      472 		if ec = error_table_$timeout | retry_count > Retry_Threshold
      473 		then ec = error_table_$unable_to_do_io;
      474 	     end;
      475 
      476 	on any_other call handler;
      477 	call hcs_$set_ips_mask ("0"b, mask);
      478 	actual_iocbp -> iocb.open_descrip_ptr = null;
      479 	actual_iocbp -> iocb.open = xmodem_io_open;
      480 	actual_iocbp -> iocb.detach_iocb = xmodem_io_detach;
      481 	call iox_$propagate (actual_iocbp);
      482 	call hcs_$reset_ips_mask (mask, "0"b);
      483 	revert any_other;
      484 	code = ec;
      485 	return;
      486 
      487 /*  flush_output transmits any remaining data to the remote xmodem during
      488*    a close operation.  The last data packet sent is filled with the NUL
      489*    ascii character, if and only if it is not a multiple of 128.  */
      490 
      491 flush_output:
      492      proc (ec);
      493 
      494 	dcl     ec		 fixed bin (35);
      495 	dcl     n_chars		 fixed bin;
      496 
      497 	ec = 0;
      498 
      499 	buf_ptr = addr (attach_data.buf);
      500 	if attach_data.buf_pos = 0
      501 	then return;
      502 
      503 	do n_chars = attach_data.buf_pos + 1 to Buf_Size;
      504 	     substr (attach_data.buf, n_chars, 1) = NUL;
      505 	end;
      506 
      507 	call send_data_packet (ec);
      508 
      509 	return;
      510      end flush_output;
      511 
      512 
      513 
      514 /*  This entry is called to input characters received from the remote
      515*    connection.  Packets are read until the user request is satisfied.  
      516*    Data received, but not requested by the user, is stored in an internal
      517*    buffer, and is available on subsequent reads.            */
      518 
      519 xmodem_io_get_chars:
      520      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_actual_len, code);
      521 
      522 	newline_needed = "0"b;
      523 	goto get_data;
      524 
      525 /*  This entry is called to input characters received from the remote
      526*    connection.  Packets are read until the user request is satisfied.
      527*    i.e. a newline is found or the user buffer is filled. Data
      528*    received, but not requested by the user, is stored in an internal
      529*    buffer, and is available on subsequent reads            */
      530 
      531 xmodem_io_get_line:
      532      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_actual_len, code);
      533 
      534 	newline_needed = "1"b;
      535 
      536 get_data:
      537 	on cleanup attach_data.error_code = 1;
      538 	call set_up;
      539 
      540 	if arg_buf_len = 0
      541 	then return;
      542 	if arg_buf_len < 0
      543 	then do;
      544 		code = error_table_$bad_arg;
      545 		return;
      546 	     end;
      547 
      548 	newline_found = "0"b;
      549 	arg_buf_pos = 0;
      550 	do while ("1"b);
      551 	     ec = 0;
      552 	     call unload_internal_buffer (buffer_empty);
      553 	     if buffer_empty
      554 	     then do;
      555 		     call get_data_packet (ec);
      556 		     if ec ^= 0
      557 		     then do;
      558 			     attach_data.buf_pos = 0;
      559 			     attach_data.error_code = ec;
      560 			     goto done_receive;
      561 			end;
      562 		     else attach_data.my_rx_n = mod (attach_data.my_rx_n + 1, 256);
      563 		end;
      564 	     else goto done_receive;
      565 	end;
      566 
      567 done_receive:
      568 	if (ec = 0) & newline_needed & ^newline_found
      569 	then ec = error_table_$long_record;
      570 	arg_actual_len = arg_buf_pos;
      571 	code = ec;
      572 	return;
      573 
      574 
      575 
      576 
      577 /*  This internal procedure moves the data from the internal buffer to the user's
      578*    buffer during a get_chars or get_line operation.  */
      579 
      580 unload_internal_buffer:
      581      proc (buffer_empty);
      582 	dcl     buffer_empty	 bit (1);		/* ON if we need more data from the remote xmodem */
      583 	dcl     n_chars		 fixed bin;
      584 	dcl     overlay		 char (arg_buf_len) based;
      585 						/* user buffer */
      586 	dcl     i			 fixed bin;
      587 
      588 
      589 	buffer_empty = "0"b;
      590 	if attach_data.buf_pos = 0
      591 	then do;
      592 		buffer_empty = "1"b;
      593 		return;
      594 	     end;
      595 
      596 	if arg_buf_len - arg_buf_pos > attach_data.buf_pos
      597 	then n_chars = attach_data.buf_pos;
      598 	else n_chars = arg_buf_len - arg_buf_pos;
      599 
      600 	if newline_needed
      601 	then do;
      602 		i = index (substr (attach_data.buf, 1, n_chars), NL);
      603 		if i ^= 0
      604 		then do;
      605 			newline_found = "1"b;
      606 			n_chars = i;
      607 		     end;
      608 
      609 	     end;
      610 
      611 	substr (arg_buf_ptr -> overlay, arg_buf_pos + 1, n_chars) = substr (attach_data.buf, 1, n_chars);
      612 	substr (attach_data.buf, 1, attach_data.buf_pos - n_chars) =
      613 	     substr (attach_data.buf, n_chars + 1, attach_data.buf_pos - n_chars);
      614 	attach_data.buf_pos = attach_data.buf_pos - n_chars;
      615 	arg_buf_pos = arg_buf_pos + n_chars;
      616 	if (^newline_found) & (arg_buf_pos < arg_buf_len)
      617 	then buffer_empty = "1"b;
      618 	return;
      619      end unload_internal_buffer;
      620 
      621 
      622 /*  This internal procedure gets the actual packet from the remote xmodem
      623*    during a get_chars or get_line operation.  Data is received via packets
      624*    of the following form:
      625*        <SOH><BLOCK #><^BLOCK #><128 data characters><CHECKSUM>
      626*
      627*    Acknowledge its receipt by sending either an ACK or NAK  */
      628 
      629 get_data_packet:
      630      proc (ec);
      631 	dcl     bad_char		 bit (1);
      632 	dcl     chase_buf_ptr	 ptr;
      633 	dcl     ec		 fixed bin (35);
      634 	dcl     n_read		 fixed bin (21);
      635 	dcl     soh_eot_char	 char (1);
      636 	dcl     to_read		 fixed bin (21);
      637 
      638 
      639 	retry_count = 1;
      640 
      641 	do while (retry_count <= Retry_Threshold);
      642 	     bad_char = "0"b;
      643 	     ec = 0;
      644 
      645 /*  Get the SOH character  */
      646 	     call get_char (soh_eot_char, Timeout_Interval, ec);
      647 	     if ec ^= 0
      648 	     then goto try_again;
      649 
      650 	     if soh_eot_char = EOT
      651 	     then do;
      652 		     ec = error_table_$end_of_info;
      653 		     call send_char (ACK);
      654 		     return;
      655 		end;
      656 
      657 	     else if soh_eot_char ^= SOH
      658 	     then do;
      659 		     bad_char = "1"b;
      660 		     goto try_again;
      661 		end;
      662 
      663 /*  Get the block number  */
      664 	     call get_char (block_rx, Timeout_Interval, ec);
      665 	     if ec ^= 0
      666 	     then goto try_again;
      667 
      668 	     if attach_data.my_rx_n ^= rank (block_rx)
      669 	     then do;				/* Our last ACK may have been garbled */
      670 		     if attach_data.my_rx_n ^= mod (rank (block_rx) + 1, 256)
      671 		     then bad_char = "1"b;
      672 		     goto try_again;
      673 		end;
      674 
      675 /* Get the block number complement  */
      676 	     call get_char (block_rx_1, Timeout_Interval, ec);
      677 	     if ec ^= 0
      678 	     then goto try_again;
      679 
      680 	     if (255 - attach_data.my_rx_n) ^= rank (block_rx_1)
      681 	     then do;				/* Bad complement */
      682 		     bad_char = "1"b;		/* only complement bad so try again */
      683 		     goto try_again;
      684 		end;
      685 
      686 /*  Get the data  (128 characters)  */
      687 	     buf_ptr = addr (attach_data.buf);
      688 	     chase_buf_ptr = buf_ptr;
      689 	     attach_data.buf_pos = 0;
      690 	     to_read = Buf_Size;
      691 
      692 	     do while (to_read > 0 & ec = 0);
      693 		call timed_io_$get_chars (attach_data.target_iocbp, Timeout_Interval, chase_buf_ptr, to_read, n_read,
      694 		     ec);
      695 		if ec ^= 0
      696 		then goto try_again;
      697 		else do;
      698 			attach_data.buf_pos = n_read + attach_data.buf_pos;
      699 			chase_buf_ptr = addcharno (buf_ptr, attach_data.buf_pos);
      700 			to_read = Buf_Size - attach_data.buf_pos;
      701 		     end;
      702 	     end;
      703 
      704 /*  Get the checksum character */
      705 	     call get_char (check_char (1), Timeout_Interval, ec);
      706 	     if ec ^= 0
      707 	     then goto try_again;
      708 
      709 /*  Verify the data received  */
      710 	     if attach_data.block_check_type = Check_Sum
      711 	     then do;
      712 		     if rank (check_char (1)) ^= my_checksum ()
      713 		     then bad_char = "1"b;
      714 		end;
      715 
      716 	     else do;
      717 		     call get_char (check_char (2), Timeout_Interval, ec);
      718 		     if ec ^= 0
      719 		     then goto try_again;
      720 		     if ^good_crc (check_char)
      721 		     then bad_char = "1"b;
      722 		end;
      723 
      724 	     if ^bad_char
      725 	     then do;
      726 		     call flush_input;
      727 		     call send_char (ACK);
      728 		     return;
      729 		end;
      730 
      731 try_again:
      732 	     call flush_input;
      733 
      734 	     if (ec ^= 0) | bad_char
      735 	     then do;
      736 		     if attach_data.crc_init		/* First time, must agree on error code */
      737 		     then do;
      738 			     if retry_count <= 6
      739 			     then call send_char ("C");
      740 			     else do;
      741 				     attach_data.crc_init = "0"b;
      742 				     attach_data.block_check_type = Check_Sum;
      743 				     call send_char (NAK);
      744 				end;
      745 			end;
      746 		     else call send_char (NAK);
      747 		end;
      748 	     else call send_char (ACK);
      749 	     retry_count = retry_count + 1;
      750 	end;
      751 	if retry_count > Retry_Threshold
      752 	then ec = error_table_$unable_to_do_io;
      753 	return;
      754      end get_data_packet;
      755 
      756 
      757 
      758 
      759 /*  flush_input throws out any data that was sent by the remote xmodem but is
      760*    not required during a get_chars operation because:
      761*	   1.  It is known that the current packet is bad.
      762*	   2.  An ACK or NAK is to be sent in response to the packet
      763*                 received, or not received.        */
      764 
      765 flush_input:
      766      proc;
      767 
      768 	dcl     bad_char		 char (1);
      769 	dcl     bad_char_ptr	 ptr;
      770 	dcl     ec		 fixed bin (35);
      771 	dcl     interval		 fixed bin (71) init (1000000);
      772 						/* one second */
      773 	dcl     n_read		 fixed bin (21);
      774 
      775 
      776 	ec = 0;
      777 
      778 	bad_char_ptr = addr (bad_char);
      779 	do while (ec = 0);
      780 	     call timed_io_$get_chars (attach_data.target_iocbp, interval, bad_char_ptr, 1, n_read, ec);
      781 	end;
      782 	return;
      783      end flush_input;
      784 
      785 
      786 
      787 
      788 /*  This entry is called to output characters to the remote connection.
      789*    Data passed by the user is transmitted via packets of the following form:
      790*          <SOH><BLOCK #><^BLOCK #><128 data characters><CHECKSUM>
      791* 
      792*    Packets are transmitted until the user request is satisfied.
      793*    If a full packet cannot be sent, data is stored in an internal
      794*    buffer until (1) subsequent writes fill the buffer, or (2) the xmodem
      795*    switch is closed            */
      796 
      797 xmodem_io_put_chars:
      798      entry (arg_iocbp, arg_buf_ptr, arg_buf_len, code);
      799 	/*** entry to perform put_chars operation */
      800 
      801 	on cleanup attach_data.error_code = 1;
      802 	call set_up;
      803 
      804 	if arg_buf_len = 0
      805 	then return;
      806 	if arg_buf_len < 0
      807 	then do;
      808 		code = error_table_$bad_arg;
      809 		return;
      810 	     end;
      811 
      812 	arg_buf_pos = 0;
      813 	buf_ptr = addr (attach_data.buf);
      814 
      815 	do while ("1"b);
      816 	     ec = 0;
      817 	     call load_internal_buffer (buffer_full);
      818 	     if buffer_full
      819 	     then do;
      820 		     call send_data_packet (ec);
      821 		     if ec ^= 0
      822 		     then do;
      823 			     attach_data.error_code = ec;
      824 			     goto done_transmitting;
      825 			end;
      826 		     else do;
      827 			     attach_data.my_tx_n = mod (attach_data.my_tx_n + 1, 256);
      828 			     attach_data.buf_pos = 0;
      829 			end;
      830 		end;
      831 	     else goto done_transmitting;
      832 	end;
      833 done_transmitting:
      834 	code = ec;
      835 	return;
      836 
      837 
      838 /*  This internal procedure controls the necessary buffer operations
      839*    during a put_chars operation.  If the user's buffer is a multiple
      840*    of 128 characters then the data is sent directly from the user's
      841*    buffer; otherwise the data is placed in an internal buffer before
      842*    transmission. */
      843 
      844 load_internal_buffer:
      845      proc (buffer_full);
      846 
      847 	dcl     buffer_full		 bit (1);
      848 	dcl     n_chars		 fixed bin;
      849 	dcl     overlay		 char (arg_buf_len) based;
      850 
      851 
      852 	buffer_full = "0"b;
      853 	if arg_buf_pos = arg_buf_len
      854 	then return;
      855 
      856 	if mod (arg_buf_len - arg_buf_pos, Buf_Size) = 0 & (attach_data.buf_pos = 0)
      857 	then do;					/* User's buffer is a multiple of 128 characters */
      858 		buf_ptr = addcharno (arg_buf_ptr, arg_buf_pos);
      859 		arg_buf_pos = arg_buf_pos + Buf_Size;
      860 		buffer_full = "1"b;
      861 		return;
      862 	     end;
      863 
      864 	if arg_buf_len - arg_buf_pos > Buf_Size - attach_data.buf_pos
      865 	then n_chars = Buf_Size - attach_data.buf_pos;
      866 	else n_chars = arg_buf_len - arg_buf_pos;
      867 
      868 	substr (attach_data.buf, attach_data.buf_pos + 1, n_chars) =
      869 	     substr (arg_buf_ptr -> overlay, arg_buf_pos + 1, n_chars);
      870 
      871 	arg_buf_pos = arg_buf_pos + n_chars;
      872 	if attach_data.buf_pos + n_chars = Buf_Size
      873 	then buffer_full = "1"b;
      874 	else attach_data.buf_pos = attach_data.buf_pos + n_chars;
      875 	return;
      876      end load_internal_buffer;
      877 
      878 
      879 
      880 
      881 
      882 /*  This internal procedure sends a data packet  during a put_chars operation.
      883*    The data packet is retransmitted until a timeout occurs, the packet
      884*    is acknowledged, or the Retry_Threshold is reached   */
      885 
      886 send_data_packet:
      887      proc (ec);
      888 	dcl     ec		 fixed bin (35);
      889 
      890 
      891 	ec = 0;
      892 	successful = "0"b;
      893 	retry_count = 1;
      894 	do while (^successful & retry_count <= Retry_Threshold);
      895 						/*  Send packet  */
      896 	     call send_char (SOH);
      897 	     call send_char (byte (attach_data.my_tx_n));
      898 	     call send_char (byte (255 - attach_data.my_tx_n));
      899 	     call send_data;
      900 	     if attach_data.block_check_type = Check_Sum
      901 	     then call send_char (byte (my_checksum ()));
      902 	     else do;
      903 		     call my_crc (check_char);
      904 		     call send_char (check_char (1));
      905 		     call send_char (check_char (2));
      906 		end;
      907 
      908 	     call get_char (packet_type, Abort_Interval, ec);
      909 	     if ec ^= 0
      910 	     then do;
      911 		     if ec = error_table_$timeout
      912 		     then ec = error_table_$unable_to_do_io;
      913 		     return;
      914 		end;
      915 
      916 	     if packet_type = CAN
      917 	     then do;
      918 		     ec = error_table_$unable_to_do_io;
      919 		     return;
      920 		end;
      921 
      922 	     if packet_type = ACK
      923 	     then successful = "1"b;
      924 	     else retry_count = retry_count + 1;
      925 	end;
      926 
      927 	if retry_count > Retry_Threshold
      928 	then do;
      929 		ec = error_table_$unable_to_do_io;
      930 		return;
      931 	     end;
      932 
      933 	attach_data.buf_pos = 0;
      934 	ec = 0;
      935 	return;
      936      end send_data_packet;
      937 
      938 /*  This internal procedure sends the data portion of the packet during a
      939*    put_chars operation.  */
      940 
      941 send_data:
      942      proc;
      943 
      944 	call iox_$put_chars (attach_data.target_iocbp, buf_ptr, Buf_Size, code);
      945 	return;
      946      end send_data;
      947 
      948 /*  This internal procedure sends a control character */
      949 
      950 send_char:
      951      proc (control_char);
      952 
      953 	dcl     control_char	 char (1);
      954 	dcl     control_char_ptr	 ptr;
      955 
      956 	control_char_ptr = addr (control_char);
      957 	call iox_$put_chars (attach_data_ptr -> attach_data.target_iocbp, control_char_ptr, 1, (0));
      958 
      959 	return;
      960      end send_char;
      961 
      962 
      963 
      964 /*  Get the checksum character for the packet (8 bits).  It is the sum
      965*    of the data characters only  */
      966 
      967 my_checksum:					/* checksum, 8-bit sum of data bytes only */
      968      proc returns (fixed bin (9));
      969 	dcl     chksum		 fixed bin (9);
      970 	dcl     i			 fixed bin;
      971 	dcl     overlay		 (128) char (1) based unal;
      972 
      973 	chksum = 0;
      974 
      975 	do i = 1 to Buf_Size;
      976 	     chksum = mod (chksum + rank (buf_ptr -> overlay (i)), 256);
      977 	end;
      978 	return (chksum);
      979      end my_checksum;
      980 
      981 
      982 
      983 /*
      984*This procedure performs the CRC-CCITT calculation resulting in a 16-bit
      985*error-detecting-code.
      986*
      987*   1.  Let r be the degree of the generator polynomial, G(x), where
      988*       G(x) = x**16 + x**12 + x**5 + 1.
      989*       Append r zero bits to the low-order end of the message, so it
      990*       now contains m+r bits.
      991*
      992*   2.  Divide the bit string corresponding to G(x) into the bit
      993*       string corresponding to m+r bits. (m+r bits is hereafter referred
      994*       to as M(x).
      995*
      996*   3.  Subtract the remainder (which is alway r or fewer bits) from
      997*       the bit string M(x) using modulo 2 subtraction.  The result is the
      998*       checksummed message to be transmitted.
      999**/
     1000 my_crc:						/* CRC-CCITT */
     1001      proc (crc_char);
     1002 	dcl     crc_char		 (2) char (1);
     1003 	dcl     dividend		 bit (1168) var;
     1004 	dcl     i			 fixed bin;
     1005 
     1006 	dcl     01 overlay		 (128) based unal,
     1007 		02 pad		 bit (1),
     1008 		02 mx_char	 bit (8);
     1009 	dcl     remainder		 bit (16);
     1010 
     1011 	dividend = ""b;
     1012 	do i = 1 to 128;
     1013 	     dividend = dividend || buf_ptr -> overlay.mx_char (i);
     1014 	end;
     1015 
     1016 	dividend = dividend || "0000"b4;
     1017 	remainder = mod2_div (dividend);
     1018 	unspec (crc_char (1)) = "0"b || substr (remainder, 1, 8);
     1019 	unspec (crc_char (2)) = "0"b || substr (remainder, 9, 8);
     1020 	return;
     1021      end;
     1022 
     1023 /*  Receiving - divide the message by the generator polynomial.
     1024*    If there is no remainder, the message is correct           */
     1025 
     1026 good_crc:
     1027      proc (crc_char) returns (bit (1));
     1028 	dcl     crc_char		 (2) char (1);
     1029 	dcl     crc_bits		 (2) bit (9) based (addr (crc_char));
     1030 	dcl     dividend		 bit (1168) var;
     1031 	dcl     i			 fixed bin;
     1032 	dcl     01 overlay		 (128) based unal,
     1033 		02 pad		 bit (1),
     1034 		02 mx_char	 bit (8);
     1035 	dcl     remainder		 bit (16);
     1036 
     1037 	dividend = ""b;
     1038 	do i = 1 to 128;
     1039 	     dividend = dividend || buf_ptr -> overlay.mx_char (i);
     1040 	end;
     1041 
     1042 	dividend = dividend || substr (crc_bits (1), 2, 8) || substr (crc_bits (2), 2, 8);
     1043 	remainder = mod2_div (dividend);
     1044 	if remainder = "0"b
     1045 	then return ("1"b);
     1046 	else return ("0"b);
     1047      end good_crc;
     1048 
     1049 
     1050 mod2_div:
     1051      proc (dividend) returns (bit (16));
     1052 	dcl     dividend		 bit (*) var;	/*128 data words + 16-bit crc */
     1053 	dcl     GX		 bit (17) init ("10001000000100001"b);
     1054 	dcl     i			 fixed bin;
     1055 	dcl     length		 builtin;
     1056 	dcl     remainder		 bit (16);
     1057 	dcl     XOR		 bit (4) init ("0110"b);
     1058 
     1059 	remainder = "0"b;
     1060 	i = index (dividend, "1"b);
     1061 	if i ^= 0
     1062 	then dividend = substr (dividend, i, length (dividend) - i + 1);
     1063 	else dividend = "0"b;
     1064 
     1065 	do while (length (dividend) > length (GX) - 1);
     1066 	     dividend =
     1067 		bool (substr (dividend, 1, length (GX)), GX, XOR)
     1068 		|| substr (dividend, length (GX) + 1, length (dividend) - length (GX));
     1069 	     i = index (dividend, "1"b);
     1070 	     if i ^= 0
     1071 	     then dividend = substr (dividend, i, length (dividend) - i + 1);
     1072 	     else dividend = "0"b;
     1073 	end;
     1074 	substr (remainder, length (remainder) - length (dividend) + 1, length (dividend)) = dividend;
     1075 	return (remainder);
     1076      end mod2_div;
     1077 
     1078 /*  Get a packet control character  */
     1079 
     1080 get_char:
     1081      proc (packet_type, interval, ec);
     1082 
     1083 	dcl     packet_type		 char (1);
     1084 	dcl     ec		 fixed bin (35);
     1085 	dcl     interval		 fixed bin (71);
     1086 	dcl     n_read		 fixed bin (21);
     1087 	dcl     packet_type_ptr	 ptr;
     1088 
     1089 	packet_type = "";
     1090 	packet_type_ptr = addr (packet_type);
     1091 	call timed_io_$get_chars (attach_data.target_iocbp, interval, packet_type_ptr, 1, n_read, ec);
     1092 	return;
     1093      end get_char;
     1094 
     1095 
     1096 
     1097 
     1098 set_up:
     1099      proc;					/* fill in */
     1100 	ec = 0;
     1101 	mask = ""b;
     1102 	actual_iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
     1103 	attach_data_ptr = actual_iocbp -> iocb.attach_data_ptr;
     1104 	return;
     1105      end set_up;
     1106 
     1107 
     1108 
     1109 /*  Cleans up the attach data and allocated storage if the attach operation is aborted  */
     1110 
     1111 clean_up_attach:
     1112      proc;
     1113 
     1114 	if mask ^= ""b
     1115 	then call handler;				/* Fatal error */
     1116 	if attach_data_ptr = null ()
     1117 	then return;
     1118 	free attach_data_ptr -> attach_data;
     1119 	return;
     1120      end clean_up_attach;
     1121 
     1122 
     1123 
     1124 
     1125 /*  Internal procedure to handle faults while IPS interrupts are masked.  For a
     1126*    fault while masked, the process is terminated (with the reason "unable to do
     1127*    critical I/O")  because the I/O control blocks are in an inconsistent state  */
     1128 
     1129 handler:
     1130      procedure options (non_quick);			/* visible in ifd */
     1131 
     1132 	dcl     error_table_$unable_to_do_io
     1133 				 fixed (35) ext;
     1134 	if mask ^= ""b
     1135 	then call terminate_this_process (error_table_$unable_to_do_io);
     1136 	else return;
     1137      end handler;
     1138 
     1139 
     1140 
     1141 terminate_this_process:
     1142      proc (cd);
     1143 
     1144 	dcl     cd		 fixed bin (35);
     1145 	dcl     terminate_process_	 entry (char (*), ptr);
     1146 	dcl     01 ti		 aligned automatic,
     1147 		02 version	 fixed,
     1148 		02 code		 fixed (35);
     1149 
     1150 	ti.version = 0;
     1151 	ti.code = code;
     1152 	call terminate_process_ ("fatal_error", addr (ti));
     1153 
     1154      end terminate_this_process;
     1155      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/19/84  0925.2  xmodem_io_.pl1                    >special_ldd>online>7045-11/19/84>xmodem_io_.pl1
222          1    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
224          2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACK                             000127 constant        char(1)                  initial unaligned dcl 155 set ref 465 653* 727* 748*
                                                                                  922
Abort_Interval                  000130 constant        fixed bin(71,0)          initial dcl 153 set ref 383* 387* 908*
Buf_Size                        000136 constant        fixed bin(21,0)          initial dcl 156 set ref 503 690 700 856 859 864 864
                                                                                  872 944* 975
CAN                                    constant        char(1)                  initial unaligned dcl 157 ref 916
Check_Sum                              constant        fixed bin(17,0)          initial dcl 158 ref 261 271 401 710 742 900
Cyclic_Redundancy_Code                 constant        fixed bin(17,0)          initial dcl 159 ref 269 281 399
Dim_name                        000124 constant        char(10)                 initial unaligned dcl 160 set ref 278 319*
EOT                             000123 constant        char(1)                  initial unaligned dcl 161 set ref 463* 467* 650
GX                              000434 automatic       bit(17)                  initial unaligned dcl 1053 set ref 1053* 1065 1066
                                                                                  1066 1066 1066
NAK                             000122 constant        char(1)                  initial unaligned dcl 162 set ref 386 743* 746*
NL                                     constant        char(1)                  initial unaligned dcl 163 ref 602
NUL                                    constant        char(1)                  initial unaligned dcl 165 ref 504
Retry_Threshold                        constant        fixed bin(17,0)          initial dcl 166 ref 386 391 393 465 472 641 751 894
                                                                                  927
SOH                                    constant        char(1)                  initial unaligned dcl 167 set ref 657 896*
Stream_input                           constant        fixed bin(17,0)          initial dcl 2-15 ref 366 405 430
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 2-15 ref 257
Stream_output                          constant        fixed bin(17,0)          initial dcl 2-15 ref 366 368 381 435 456
Timeout_Interval                000120 constant        fixed bin(71,0)          initial dcl 168 set ref 464* 468* 646* 664* 676*
                                                                                  693* 705* 717*
XOR                             000437 automatic       bit(4)                   initial unaligned dcl 1057 set ref 1057* 1066
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-6 ref 253 255 257 1102
actual_iocbp                    000100 automatic       pointer                  dcl 107 set ref 338 339 340 341 342* 426 427 428 429
                                                                                  432 433 435 437* 456 478 479 480 481* 1102* 1103
addcharno                                              builtin function         dcl 173 ref 699 858
addr                                                   builtin function         dcl 173 ref 291 426 499 687 778 813 956 1042 1042
                                                                                  1090 1152 1152
any_other                       000136 stack reference condition                dcl 178 ref 336 344 423 439 476 483
arg_actual_len                         parameter       fixed bin(21,0)          dcl 95 set ref 519 531 570*
arg_buf_len                            parameter       fixed bin(21,0)          dcl 97 ref 519 531 540 542 596 598 611 616 797 804
                                                                                  806 853 856 864 866 868
arg_buf_pos                     000102 automatic       fixed bin(17,0)          dcl 108 set ref 549* 570 596 598 611 615* 615 616
                                                                                  812* 853 856 858 859* 859 864 866 868 871* 871
arg_buf_ptr                            parameter       pointer                  dcl 96 ref 519 531 611 797 858 868
arg_iocbp                              parameter       pointer                  dcl 98 ref 230 235 332 360 450 519 531 797 1102
attach_data                            based           structure                level 1 dcl 130 set ref 247 316 345 1118
attach_data_ptr          16            based           pointer                  level 2 in structure "iocb" dcl 1-6 in procedure
                                                                                  "xmodem_io_" set ref 290* 339* 1103
attach_data_ptr                 000104 automatic       pointer                  dcl 109 in procedure "xmodem_io_" set ref 240* 247*
                                                                                  250 253 255 257 278 279 280 281 283 284 285 286
                                                                                  287 290 291 316 345 363 368 373 399 401 408 413
                                                                                  417 417 418 426 453 456 499 500 503 504 536 558
                                                                                  559 562 562 590 596 596 602 611 612 612 612 612
                                                                                  614 614 668 670 680 687 689 693 698 698 699 700
                                                                                  710 736 741 742 780 801 813 823 827 827 828 856
                                                                                  864 864 868 868 872 874 874 897 897 898 898 900
                                                                                  933 944 957 1091 1103* 1116 1118
attach_descrip                         based           varying char(256)        level 2 dcl 130 set ref 278* 291
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-6 set ref 243 253 291* 338*
bad_char                        000222 automatic       char(1)                  unaligned dcl 768 in procedure "flush_input" set ref
                                                                                  778
bad_char                        000204 automatic       bit(1)                   unaligned dcl 631 in procedure "get_data_packet" set
                                                                                  ref 642* 659* 670* 682* 712* 720* 724 734
bad_char_ptr                    000224 automatic       pointer                  dcl 769 set ref 778* 780*
block_check_type        160            based           fixed bin(17,0)          level 2 dcl 130 set ref 280* 399* 401* 710 742* 900
block_rx                        000106 automatic       char(1)                  unaligned dcl 110 set ref 664* 668 670
block_rx_1                      000107 automatic       char(1)                  unaligned dcl 111 set ref 676* 680
bool                                                   builtin function         dcl 173 ref 1066
buf                     114            based           char(128)                level 2 dcl 130 set ref 499 504* 602 611 612* 612
                                                                                  687 813 868*
buf_pos                 154            based           fixed bin(21,0)          level 2 dcl 130 set ref 286* 413* 500 503 558* 590
                                                                                  596 596 612 612 614* 614 689* 698* 698 699 700
                                                                                  828* 856 864 864 868 872 874* 874 933*
buf_ptr                         000112 automatic       pointer                  dcl 113 set ref 499* 687* 688 699 813* 858* 944* 976
                                                                                  1013 1039
buffer_empty                           parameter       bit(1)                   unaligned dcl 582 in procedure
                                                                                  "unload_internal_buffer" set ref 580 589* 592*
                                                                                  616*
buffer_empty                    000133 automatic       bit(1)                   unaligned dcl 125 in procedure "xmodem_io_" set ref
                                                                                  552* 553
buffer_full                            parameter       bit(1)                   unaligned dcl 847 in procedure
                                                                                  "load_internal_buffer" set ref 844 852* 860* 872*
buffer_full                     000134 automatic       bit(1)                   unaligned dcl 126 in procedure "xmodem_io_" set ref
                                                                                  817* 818
byte                                                   builtin function         dcl 173 ref 897 897 898 898 900 900
call_com_err                           parameter       bit(1)                   dcl 310 ref 306 319
cd                                     parameter       fixed bin(35,0)          dcl 1144 ref 1141
chase_buf_ptr                   000206 automatic       pointer                  dcl 632 set ref 688* 693* 699*
check_char                      000110 automatic       char(1)                  array unaligned dcl 112 set ref 705* 712 717* 720*
                                                                                  903* 904* 905*
chksum                          000276 automatic       fixed bin(9,0)           dcl 969 set ref 973* 976* 976 978
cleanup                         000144 stack reference condition                dcl 178 ref 241 363 453 536 801
cleanup_level                          parameter       fixed bin(17,0)          dcl 309 ref 306 314
close                    36            based           entry variable           level 2 dcl 1-6 set ref 428*
code                      1     000106 automatic       fixed bin(35,0)          level 2 in structure "ti" dcl 1146 in procedure
                                                                                  "terminate_this_process" set ref 1151* 1151
code                                   parameter       fixed bin(35,0)          dcl 99 in procedure "xmodem_io_" set ref 230 322*
                                                                                  332 360 370* 377* 393* 395* 414* 450 484* 519 531
                                                                                  544* 571* 797 808* 833* 944*
com_err_                        000042 constant        entry                    external dcl 204 ref 319
com_err_switch                         parameter       bit(1)                   dcl 100 set ref 230 237* 243* 251* 253* 255* 257*
                                                                                  266* 273* 275* 360
control                  66            based           entry variable           level 2 dcl 1-6 set ref 296*
control_char                           parameter       char(1)                  unaligned dcl 953 set ref 950 956
control_char_ptr                000266 automatic       pointer                  dcl 954 set ref 956* 957*
crc_bits                               based           bit(9)                   array unaligned dcl 1029 ref 1042 1042
crc_char                               parameter       char(1)                  array unaligned dcl 1028 in procedure "good_crc" set
                                                                                  ref 1026 1042 1042
crc_char                               parameter       char(1)                  array unaligned dcl 1002 in procedure "my_crc" set
                                                                                  ref 1000 1018* 1019*
crc_init                157            based           bit(1)                   level 2 packed unaligned dcl 130 set ref 281* 283*
                                                                                  368 408 418* 736 741*
detach_iocb              26            based           entry variable           level 2 dcl 1-6 set ref 292* 341* 429* 480*
dividend                               parameter       varying bit              dcl 1052 in procedure "mod2_div" set ref 1050 1060
                                                                                  1061* 1061 1061 1063* 1065 1066* 1066 1066 1066
                                                                                  1069 1070* 1070 1070 1072* 1074 1074 1074
dividend                        000362 automatic       varying bit(1168)        dcl 1030 in procedure "good_crc" set ref 1037* 1039*
                                                                                  1039 1042* 1042 1043*
dividend                        000310 automatic       varying bit(1168)        dcl 1003 in procedure "my_crc" set ref 1011* 1013*
                                                                                  1013 1016* 1016 1017*
ec                                     parameter       fixed bin(35,0)          dcl 1084 in procedure "get_char" set ref 1080 1091*
ec                              000114 automatic       fixed bin(35,0)          dcl 114 in procedure "xmodem_io_" set ref 233* 250*
                                                                                  251 251* 383* 386 387* 391 393 395 410* 411 414
                                                                                  459* 461 464* 465 468* 472 472* 484 551* 555* 556
                                                                                  559 567 567* 571 816* 820* 821 823 833 1100*
ec                              000226 automatic       fixed bin(35,0)          dcl 770 in procedure "flush_input" set ref 776* 779
                                                                                  780*
ec                                     parameter       fixed bin(35,0)          dcl 311 in procedure "error" set ref 306 319* 322
ec                                     parameter       fixed bin(35,0)          dcl 494 in procedure "flush_output" set ref 491 497*
                                                                                  507*
ec                                     parameter       fixed bin(35,0)          dcl 888 in procedure "send_data_packet" set ref 886
                                                                                  891* 908* 909 911 911* 918* 929* 934*
ec                                     parameter       fixed bin(35,0)          dcl 633 in procedure "get_data_packet" set ref 629
                                                                                  643* 646* 647 652* 664* 665 676* 677 692 693* 695
                                                                                  705* 706 717* 718 734 751*
edc                             000115 automatic       fixed bin(17,0)          dcl 115 set ref 261* 269* 271* 280 281
error_code              156            based           fixed bin(35,0)          level 2 dcl 130 set ref 287* 363* 453* 456 536* 559*
                                                                                  801* 823*
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 182 ref 544 808
error_table_$bad_mode           000012 external static fixed bin(35,0)          dcl 183 set ref 257* 377
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 184 set ref 273* 275*
error_table_$end_of_info        000016 external static fixed bin(35,0)          dcl 185 ref 652
error_table_$incompatible_attach
                                000020 external static fixed bin(35,0)          dcl 187 ref 370
error_table_$long_record        000022 external static fixed bin(35,0)          dcl 189 ref 567
error_table_$no_iocb            000026 external static fixed bin(35,0)          dcl 192 ref 251
error_table_$noarg              000024 external static fixed bin(35,0)          dcl 191 set ref 237* 266*
error_table_$not_attached       000030 external static fixed bin(35,0)          dcl 193 set ref 253*
error_table_$not_detached       000032 external static fixed bin(35,0)          dcl 195 set ref 243*
error_table_$not_open           000034 external static fixed bin(35,0)          dcl 197 set ref 255*
error_table_$timeout            000036 external static fixed bin(35,0)          dcl 198 ref 393 465 472 911
error_table_$unable_to_do_io    000070 external static fixed bin(35,0)          dcl 1132 in procedure "handler" set ref 1134*
error_table_$unable_to_do_io    000040 external static fixed bin(35,0)          dcl 199 in procedure "xmodem_io_" ref 393 472 751
                                                                                  911 918 929
get_chars                46            based           entry variable           level 2 dcl 1-6 set ref 433*
get_line                 42            based           entry variable           level 2 dcl 1-6 set ref 432*
get_system_free_area_           000044 constant        entry                    external dcl 205 ref 246
hbound                                                 builtin function         dcl 173 ref 237 262 266
hcs_$reset_ips_mask             000046 constant        entry                    external dcl 206 ref 298 343 438 482
hcs_$set_ips_mask               000050 constant        entry                    external dcl 207 ref 289 337 425 477
i                               000424 automatic       fixed bin(17,0)          dcl 1031 in procedure "good_crc" set ref 1038* 1039*
i                               000277 automatic       fixed bin(17,0)          dcl 970 in procedure "my_checksum" set ref 975* 976*
i                               000175 automatic       fixed bin(17,0)          dcl 586 in procedure "unload_internal_buffer" set
                                                                                  ref 602* 603 606
i                               000116 automatic       fixed bin(17,0)          dcl 116 in procedure "xmodem_io_" set ref 262* 263
                                                                                  263 265* 265 266 269 269 271 271 273 273 275 275*
i                               000435 automatic       fixed bin(17,0)          dcl 1054 in procedure "mod2_div" set ref 1060* 1061
                                                                                  1061 1061 1069* 1070 1070 1070
i                               000352 automatic       fixed bin(17,0)          dcl 1004 in procedure "my_crc" set ref 1012* 1013*
index                                                  builtin function         dcl 173 ref 602 1060 1069
interval                        000230 automatic       fixed bin(71,0)          initial dcl 771 in procedure "flush_input" set ref
                                                                                  771* 780*
interval                               parameter       fixed bin(71,0)          dcl 1085 in procedure "get_char" set ref 1080 1091*
iocb                                   based           structure                level 1 dcl 1-6
iocbp                           000120 automatic       pointer                  dcl 117 set ref 235* 243 290 291 292 293 294 295 296
                                                                                  297*
iox_$err_no_operation           000052 constant        entry                    external dcl 208 ref 295 296
iox_$err_not_attached           000054 constant        entry                    external dcl 209 ref 340 341
iox_$err_not_closed             000056 constant        entry                    external dcl 211 ref 427 429
iox_$look_iocb                  000060 constant        entry                    external dcl 212 ref 250
iox_$propagate                  000062 constant        entry                    external dcl 213 ref 297 342 437 481
iox_$put_chars                  000064 constant        entry                    external dcl 214 ref 944 957
iox_modes                       000002 constant        char(24)                 initial array dcl 2-6 ref 257 373 456
lbound                                                 builtin function         dcl 173 ref 262
length                                 based           fixed bin(17,0)          level 2 in structure "open_descrip" dcl 145
                                                                                  in procedure "xmodem_io_" ref 257 456
length                                                 builtin function         dcl 1055 in procedure "mod2_div" ref 1061 1065 1065
                                                                                  1066 1066 1066 1066 1070 1074 1074 1074
mask                            000122 automatic       bit(36)                  dcl 118 set ref 234* 289* 298* 337* 343* 425* 438*
                                                                                  477* 482* 1101* 1114 1134
mod                                                    builtin function         dcl 173 ref 417 562 670 827 856 976
mode                                   parameter       fixed bin(17,0)          dcl 101 ref 360 366 366 368 373 381 405 430 435
modes                    56            based           entry variable           level 2 dcl 1-6 set ref 295*
msg                                    parameter       char                     unaligned dcl 312 set ref 306 319*
mx_char                   0(01)        based           bit(8)                   array level 2 in structure "overlay" packed
                                                                                  unaligned dcl 1006 in procedure "my_crc" ref 1013
mx_char                   0(01)        based           bit(8)                   array level 2 in structure "overlay" packed
                                                                                  unaligned dcl 1032 in procedure "good_crc" ref
                                                                                  1039
my_rx_n                 155            based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 130 set ref
                                                                                  284* 417* 417 562* 562 668 670 680
my_tx_n                 155(09)        based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 130 set ref
                                                                                  285* 827* 827 897 897 898 898
n_chars                         000174 automatic       fixed bin(17,0)          dcl 583 in procedure "unload_internal_buffer" set
                                                                                  ref 596* 598* 602 606* 611 611 612 612 612 614 615
n_chars                         000242 automatic       fixed bin(17,0)          dcl 848 in procedure "load_internal_buffer" set ref
                                                                                  864* 866* 868 868 871 872 874
n_chars                         000164 automatic       fixed bin(17,0)          dcl 495 in procedure "flush_output" set ref 503*
                                                                                  504*
n_read                          000232 automatic       fixed bin(21,0)          dcl 773 in procedure "flush_input" set ref 780*
n_read                          000210 automatic       fixed bin(21,0)          dcl 634 in procedure "get_data_packet" set ref 693*
                                                                                  698
n_read                          000446 automatic       fixed bin(21,0)          dcl 1086 in procedure "get_char" set ref 1091*
newline_found                   000123 automatic       bit(1)                   unaligned dcl 119 set ref 548* 567 605* 616
newline_needed                  000124 automatic       bit(1)                   unaligned dcl 120 set ref 522* 534* 567 600
null                                                   builtin function         dcl 173 ref 240 243 253 255 293 338 339 478 1116
open                     32            based           entry variable           level 2 dcl 1-6 set ref 294* 340* 427* 479*
open_descrip            101            based           varying char(32)         level 2 in structure "attach_data" dcl 130
                                                                                  in procedure "xmodem_io_" set ref 279* 373* 426
open_descrip                           based           structure                level 1 dcl 145 in procedure "xmodem_io_"
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-6 set ref 255 257 293* 426* 456 478*
option_array                           parameter       varying char             array dcl 102 ref 230 237 250 250 251 251 253 253
                                                                                  255 255 257 257 262 262 263 263 266 269 269 271
                                                                                  271 273 273 275 275 278
overlay                                based           structure                array level 1 packed unaligned dcl 1032 in procedure
                                                                                  "good_crc"
overlay                                based           char(1)                  array unaligned dcl 971 in procedure "my_checksum"
                                                                                  ref 976
overlay                                based           structure                array level 1 packed unaligned dcl 1006 in procedure
                                                                                  "my_crc"
overlay                                based           char                     unaligned dcl 849 in procedure
                                                                                  "load_internal_buffer" ref 868
overlay                                based           char                     unaligned dcl 584 in procedure
                                                                                  "unload_internal_buffer" set ref 611*
packet_type                            parameter       char(1)                  unaligned dcl 1083 in procedure "get_char" set ref
                                                                                  1080 1089* 1090
packet_type                     000125 automatic       char(1)                  unaligned dcl 121 in procedure "xmodem_io_" set ref
                                                                                  383* 386 386 387* 399 464* 465 468* 908* 916 922
packet_type_ptr                 000450 automatic       pointer                  dcl 1087 set ref 1090* 1091*
put_chars                52            based           entry variable           level 2 dcl 1-6 set ref 435*
rank                                                   builtin function         dcl 173 ref 668 670 680 712 976
remainder                       000353 automatic       bit(16)                  unaligned dcl 1009 in procedure "my_crc" set ref
                                                                                  1017* 1018 1019
remainder                       000436 automatic       bit(16)                  unaligned dcl 1056 in procedure "mod2_div" set ref
                                                                                  1059* 1074 1074* 1075
remainder                       000425 automatic       bit(16)                  unaligned dcl 1035 in procedure "good_crc" set ref
                                                                                  1043* 1044
retry_count                     000126 automatic       fixed bin(17,0)          dcl 122 set ref 384* 386 388* 388 391 393 465* 472
                                                                                  639* 641 738 749* 749 751 893* 894 924* 924 927
rtrim                                                  builtin function         dcl 173 ref 250 250 251 251 253 253 255 255 257 257
                                                                                  273 273 275 275 278
soh_eot_char                    000211 automatic       char(1)                  unaligned dcl 635 set ref 646* 650 657
string                    1            based           char                     level 2 dcl 145 ref 257 456
substr                                                 builtin function         dcl 173 set ref 504* 602 611* 611 612* 612 868* 868
                                                                                  1018 1019 1042 1042 1061 1066 1066 1070 1074*
successful                      000132 automatic       bit(1)                   unaligned dcl 124 set ref 892* 894 922*
system_free_area                       based           area(1024)               dcl 149 ref 247
system_free_area_ptr            000130 automatic       pointer                  dcl 123 set ref 246* 247
target_iocbp            112            based           pointer                  level 2 dcl 130 set ref 250* 253 255 257 693* 780*
                                                                                  944* 957* 1091*
terminate_process_              000072 constant        entry                    external dcl 1145 ref 1152
ti                              000106 automatic       structure                level 1 dcl 1146 set ref 1152 1152
timed_io_$get_chars             000066 constant        entry                    external dcl 215 ref 693 780 1091
to_read                         000212 automatic       fixed bin(21,0)          dcl 636 set ref 690* 692 693* 700*
unspec                                                 builtin function         dcl 173 set ref 1018* 1019*
version                         000106 automatic       fixed bin(17,0)          level 2 dcl 1146 set ref 1150*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
iox_$err_not_open               000000 constant        entry                    external dcl 210
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-51
short_iox_modes                        internal static char(4)                  initial array dcl 2-12

NAMES DECLARED BY EXPLICIT CONTEXT.
EXIT                            001640 constant        label                    dcl 299 ref 323
Err                             000000 constant        label                    array(0:1) dcl 316 ref 314
clean_up_attach                 004616 constant        entry                    internal dcl 1111 ref 241
done_receive                    002637 constant        label                    dcl 567 ref 553 560
done_transmitting               002762 constant        label                    dcl 833 ref 818 824
error                           002766 constant        entry                    internal dcl 306 ref 237 243 251 253 255 257 266 273
                                                                                  275
flush_input                     003562 constant        entry                    internal dcl 765 ref 726 731
flush_output                    003052 constant        entry                    internal dcl 491 ref 459
get_char                        004545 constant        entry                    internal dcl 1080 ref 383 387 464 468 646 664 676
                                                                                  705 717 908
get_data                        002554 constant        label                    dcl 536 ref 523
get_data_packet                 003213 constant        entry                    internal dcl 629 ref 410 555
good_crc                        004247 constant        entry                    internal dcl 1026 ref 720
handler                         004641 constant        entry                    internal dcl 1129 ref 336 423 476 1114
load_internal_buffer            003620 constant        entry                    internal dcl 844 ref 817
mod2_div                        004360 constant        entry                    internal dcl 1050 ref 1017 1043
my_checksum                     004127 constant        entry                    internal dcl 967 ref 712 900 900
my_crc                          004160 constant        entry                    internal dcl 1000 ref 903
send_char                       004101 constant        entry                    internal dcl 950 ref 463 467 653 727 738 743 746 748
                                                                                  896 897 898 900 904 905
send_data                       004061 constant        entry                    internal dcl 941 ref 899
send_data_packet                003715 constant        entry                    internal dcl 886 ref 507 820
set_up                          004603 constant        entry                    internal dcl 1098 ref 335 364 454 538 802
terminate_this_process          004662 constant        entry                    internal dcl 1141 ref 1134
try_again                       003516 constant        label                    dcl 731 ref 647 660 665 672 677 683 695 706 718
unload_internal_buffer          003113 constant        entry                    internal dcl 580 ref 552
xmodem_io_                      000256 constant        entry                    external dcl 88
xmodem_io_attach                000271 constant        entry                    external dcl 230
xmodem_io_close                 002307 constant        entry                    external dcl 450 ref 428
xmodem_io_detach                001645 constant        entry                    external dcl 332 ref 292 480
xmodem_io_get_chars             002526 constant        entry                    external dcl 519 ref 433
xmodem_io_get_line              002542 constant        entry                    external dcl 531 ref 432
xmodem_io_open                  001760 constant        entry                    external dcl 360 ref 294 479
xmodem_io_put_chars             002663 constant        entry                    external dcl 797 ref 435

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5534        5630    5050        5544
Length      6152    5050        74         306     464           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
xmodem_io_                          450 external procedure  is an external procedure.  
on unit on line 241                  70 on unit               
error                                84 internal procedure  is called during a stack extension.  
on unit on line 336                  64 on unit               
on unit on line 363                  64 on unit               
on unit on line 423                  64 on unit               
on unit on line 453                  64 on unit               
on unit on line 476                  64 on unit               
flush_output                            internal procedure  shares stack frame of external procedure xmodem_io_.  
on unit on line 536                  64 on unit               
unload_internal_buffer                  internal procedure  shares stack frame of external procedure xmodem_io_.  
get_data_packet                         internal procedure  shares stack frame of external procedure xmodem_io_.  
flush_input                             internal procedure  shares stack frame of external procedure xmodem_io_.  
on unit on line 801                  64 on unit               
load_internal_buffer                    internal procedure  shares stack frame of external procedure xmodem_io_.  
send_data_packet                        internal procedure  shares stack frame of external procedure xmodem_io_.  
send_data                               internal procedure  shares stack frame of external procedure xmodem_io_.  
send_char                               internal procedure  shares stack frame of external procedure xmodem_io_.  
my_checksum                             internal procedure  shares stack frame of external procedure xmodem_io_.  
my_crc                                  internal procedure  shares stack frame of external procedure xmodem_io_.  
good_crc                                internal procedure  shares stack frame of external procedure xmodem_io_.  
mod2_div                                internal procedure  shares stack frame of external procedure xmodem_io_.  
get_char                                internal procedure  shares stack frame of external procedure xmodem_io_.  
set_up                                  internal procedure  shares stack frame of external procedure xmodem_io_.  
clean_up_attach                         internal procedure  shares stack frame of on unit on line 241.  
handler                              94 internal procedure  is declared options(non_quick).  
terminate_this_process                  internal procedure  shares stack frame of internal procedure handler.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
handler                  000106 ti                          terminate_this_process
xmodem_io_               000100 actual_iocbp                xmodem_io_
                         000102 arg_buf_pos                 xmodem_io_
                         000104 attach_data_ptr             xmodem_io_
                         000106 block_rx                    xmodem_io_
                         000107 block_rx_1                  xmodem_io_
                         000110 check_char                  xmodem_io_
                         000112 buf_ptr                     xmodem_io_
                         000114 ec                          xmodem_io_
                         000115 edc                         xmodem_io_
                         000116 i                           xmodem_io_
                         000120 iocbp                       xmodem_io_
                         000122 mask                        xmodem_io_
                         000123 newline_found               xmodem_io_
                         000124 newline_needed              xmodem_io_
                         000125 packet_type                 xmodem_io_
                         000126 retry_count                 xmodem_io_
                         000130 system_free_area_ptr        xmodem_io_
                         000132 successful                  xmodem_io_
                         000133 buffer_empty                xmodem_io_
                         000134 buffer_full                 xmodem_io_
                         000164 n_chars                     flush_output
                         000174 n_chars                     unload_internal_buffer
                         000175 i                           unload_internal_buffer
                         000204 bad_char                    get_data_packet
                         000206 chase_buf_ptr               get_data_packet
                         000210 n_read                      get_data_packet
                         000211 soh_eot_char                get_data_packet
                         000212 to_read                     get_data_packet
                         000222 bad_char                    flush_input
                         000224 bad_char_ptr                flush_input
                         000226 ec                          flush_input
                         000230 interval                    flush_input
                         000232 n_read                      flush_input
                         000242 n_chars                     load_internal_buffer
                         000266 control_char_ptr            send_char
                         000276 chksum                      my_checksum
                         000277 i                           my_checksum
                         000310 dividend                    my_crc
                         000352 i                           my_crc
                         000353 remainder                   my_crc
                         000362 dividend                    good_crc
                         000424 i                           good_crc
                         000425 remainder                   good_crc
                         000434 GX                          mod2_div
                         000435 i                           mod2_div
                         000436 remainder                   mod2_div
                         000437 XOR                         mod2_div
                         000446 n_read                      get_char
                         000450 packet_type_ptr             get_char

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_cs            alloc_bs            cat_realloc_cs      cat_realloc_bs
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other      return              tra_ext
mod_fx1             enable              shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc      index_bs_1_eis      alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      get_system_free_area_         hcs_$reset_ips_mask           hcs_$set_ips_mask
iox_$err_no_operation         iox_$err_not_attached         iox_$err_not_closed           iox_$look_iocb
iox_$propagate                iox_$put_chars                terminate_process_            timed_io_$get_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_mode         error_table_$badopt           error_table_$end_of_info
error_table_$incompatible_attach                            error_table_$long_record      error_table_$no_iocb
error_table_$noarg            error_table_$not_attached     error_table_$not_detached     error_table_$not_open
error_table_$timeout          error_table_$unable_to_do_io  error_table_$unable_to_do_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     88 000255        90 000263       230 000264       233 000307       234 000310       235 000311       237 000315
    240 000353       241 000355       243 000373       246 000427       247 000436       250 000443       251 000526
    253 000622       255 000722       257 001022       261 001126       262 001131       263 001143       265 001170
    266 001171       269 001226       271 001256       273 001273       274 001361       275 001363       276 001451
    278 001454       279 001537       280 001541       281 001543       283 001550       284 001551       285 001553
    286 001555       287 001556       289 001557       290 001572       291 001575       292 001577       293 001603
    294 001605       295 001611       296 001615       297 001617       298 001625       299 001640       332 001641
    335 001655       336 001656       337 001700       338 001713       339 001716       340 001717       341 001724
    342 001726       343 001734       344 001747       345 001750       346 001752       360 001753       363 001770
    364 002011       366 002012       368 002022       370 002027       371 002032       373 002033       374 002044
    377 002045       378 002050       381 002051       383 002054       384 002056       386 002060       387 002073
    388 002075       389 002076       391 002077       393 002106       395 002117       396 002120       399 002121
    401 002131       405 002134       408 002140       410 002143       411 002145       413 002147       414 002151
    415 002152       417 002153       418 002163       423 002164       425 002206       426 002221       427 002225
    428 002232       429 002235       430 002240       432 002244       433 002250       434 002253       435 002254
    437 002262       438 002270       439 002303       441 002304       450 002305       453 002317       454 002340
    456 002341       459 002355       461 002357       463 002361       464 002363       465 002365       467 002405
    468 002407       469 002411       472 002413       476 002424       477 002446       478 002461       479 002464
    480 002470       481 002473       482 002502       483 002515       484 002516       485 002520       519 002521
    522 002536       523 002537       531 002540       534 002552       536 002554       538 002575       540 002576
    542 002601       544 002602       545 002605       548 002606       549 002607       551 002610       552 002611
    553 002613       555 002616       556 002620       558 002622       559 002624       560 002625       562 002626
    565 002636       567 002637       570 002650       571 002653       572 002655       797 002656       801 002673
    802 002714       804 002715       806 002720       808 002721       809 002724       812 002725       813 002726
    815 002731       816 002732       817 002733       818 002735       820 002740       821 002742       823 002744
    824 002746       827 002747       828 002760       832 002761       833 002762       835 002764       306 002765
    314 003001       316 003004       319 003007       322 003043       323 003047       491 003052       497 003054
    499 003055       500 003060       503 003064       504 003075       505 003101       507 003103       509 003112
    580 003113       589 003115       590 003121       592 003124       593 003127       596 003130       598 003140
    600 003143       602 003145       603 003156       605 003157       606 003161       611 003162       612 003171
    614 003176       615 003200       616 003202       618 003212       629 003213       639 003215       641 003217
    642 003223       643 003224       646 003226       647 003240       650 003243       652 003247       653 003252
    654 003254       657 003255       659 003257       660 003261       664 003262       665 003274       668 003277
    670 003310       672 003317       676 003320       677 003332       680 003335       682 003350       683 003352
    687 003353       688 003355       689 003356       690 003357       692 003361       693 003367       695 003411
    698 003414       699 003417       700 003423       702 003426       705 003427       706 003442       710 003445
    712 003451       714 003461       717 003462       718 003476       720 003501       724 003510       726 003512
    727 003513       728 003515       731 003516       734 003517       736 003524       738 003527       741 003537
    742 003540       743 003542       745 003544       746 003545       747 003547       748 003550       749 003552
    750 003553       751 003554       753 003561       765 003562       771 003563       776 003565       778 003566
    779 003570       780 003572       781 003616       782 003617       844 003620       852 003622       853 003626
    856 003633       858 003644       859 003651       860 003653       861 003656       864 003657       866 003670
    868 003673       871 003702       872 003703       874 003712       875 003714       886 003715       891 003717
    892 003720       893 003721       894 003723       896 003731       897 003733       898 003743       899 003756
    900 003757       903 003773       904 003775       905 003777       908 004001       909 004014       911 004017
    913 004024       916 004025       918 004031       919 004034       922 004035       924 004042       925 004043
    927 004044       929 004047       930 004053       933 004054       934 004056       935 004060       941 004061
    944 004062       945 004100       950 004101       956 004103       957 004105       959 004126       967 004127
    973 004131       975 004132       976 004141       977 004152       978 004154      1000 004160      1011 004162
   1012 004163      1013 004171      1014 004206      1016 004210      1017 004222      1018 004225      1019 004236
   1020 004246      1026 004247      1037 004251      1038 004252      1039 004257      1040 004274      1042 004276
   1043 004334      1044 004341      1046 004352      1050 004360      1053 004371      1057 004373      1059 004375
   1060 004376      1061 004405      1063 004422      1065 004432      1066 004437      1069 004474      1070 004502
   1072 004517      1073 004527      1074 004530      1075 004540      1080 004545      1089 004547      1090 004553
   1091 004555      1092 004602      1098 004603      1100 004604      1101 004605      1102 004606      1103 004613
   1104 004615      1111 004616      1114 004617      1116 004627      1118 004635      1119 004637      1129 004640
   1134 004646      1136 004660      1137 004661      1141 004662      1150 004664      1151 004665      1152 004667
   1154 004712


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
