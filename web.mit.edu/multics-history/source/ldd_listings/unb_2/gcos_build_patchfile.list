	COMPILATION LISTING OF SEGMENT gcos_build_patchfile
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 09/09/83  1057.7 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*
       12*   ********************************************************************************************
       13*   ********************************************************************************************
       14*   *
       15*   *
       16*   *	G C O S   B U I L D   P A T C H F I L E
       17*   *
       18*   *
       19*   *  The gcos_build_patchfile command is used to build a patch file to be used by the
       20*   *  GCOS Environment Simulator.  The arguments to the command are the name of the
       21*   *  Multics ASCII segment containing the patches and the name of the resulting
       22*   *  patchfile.  In order to have the patches applied by MME GECALL the patchfile
       23*   *  must be called gcos_system_software_patchfile_ and must be locatable by the
       24*   *  search rules.
       25*   *
       26*   *
       27*   *  Written by M. R. Jordan,  September 1977
       28*   *
       29*   ********************************************************************************************
       30*   ********************************************************************************************
       31**/
       32 
       33 
       34 
       35 
       36 gcos_build_patchfile: gbp: proc ();
       37 
       38 dcl  ME char (20) static internal options (constant) init ("gcos_build_patchfile");
       39 dcl  NL char (1) static internal options (constant) init ("
       40 ");
       41 dcl  aclinfo_ptr ptr init (null ());
       42 dcl  addr builtin;
       43 dcl  arg char (arg_len) based (arg_ptr);
       44 dcl  arg_len fixed bin;
       45 dcl  arg_num fixed bin;
       46 dcl  arg_ptr ptr;
       47 dcl  ascii_module_name char (6);
       48 dcl  bit_count fixed bin (24);
       49 dcl  cleanup condition;
       50 dcl  code fixed bin (35);
       51 dcl  com_err_ entry options (variable);
       52 dcl  cu_$arg_count entry (fixed bin);
       53 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       54 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       55 dcl  divide builtin;
       56 dcl  dummy fixed bin;
       57 dcl  end_of_info bit (1);
       58 dcl  error_table_$bad_arg fixed bin (35) ext;
       59 dcl  error_table_$badopt fixed bin (35) ext;
       60 dcl  error_table_$noarg fixed bin (35) ext;
       61 dcl  error_table_$too_many_names fixed bin (35) ext;
       62 dcl  error_table_$translation_failed fixed bin (35) ext;
       63 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       64 dcl  fixed builtin;
       65 dcl  gcos_cv_ascii_gebcd_ entry (ptr, fixed bin, ptr, fixed bin);
       66 dcl  get_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
       67 dcl  hbound builtin;
       68 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       69 dcl  highest_severity fixed bin init (0);
       70 dcl  i fixed bin;
       71 dcl  in_dirname char (168);
       72 dcl  in_ename char (32);
       73 dcl  in_line char (in_line_len) based (in_line_ptr);
       74 dcl  in_line_len fixed bin (20);
       75 dcl  in_line_num fixed bin;
       76 dcl  in_line_ptr ptr;
       77 dcl  in_seg char (in_seg_len) based (in_seg_ptr);
       78 dcl  in_seg_len fixed bin (20);
       79 dcl  in_seg_offset fixed bin (20);
       80 dcl  in_seg_ptr ptr;
       81 dcl  index builtin;
       82 dcl  ioa_ entry options (variable);
       83 dcl  last_name bit (36);
       84 dcl  length builtin;
       85 dcl  n fixed bin;
       86 dcl  nargs fixed bin;
       87 dcl  null builtin;
       88 dcl  number_of_patches fixed bin;
       89 dcl  out_dirname char (168);
       90 dcl  out_ename char (32);
       91 dcl  out_seg_bit_count fixed bin (24);
       92 dcl  out_seg_ptr ptr init (null ());
       93 dcl  patch_ptr ptr;
       94 dcl  rel builtin;
       95 dcl  release_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
       96 dcl  search builtin;
       97 dcl  substr builtin;
       98 dcl  table_ptr ptr;
       99 dcl  temp_ptr (2) ptr init ((2)null ());
      100 dcl  temp_segments_cleanup_needed bit (1) aligned init ("0"b);
      101 dcl  tssi_$clean_up_segment entry (ptr);
      102 dcl  tssi_$finish_segment entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
      103 dcl  tssi_$get_segment entry (char (*), char (*), ptr, ptr, fixed bin (35));
      104 dcl  tssi_cleanup_needed bit (1) aligned init ("0"b);
      105 
      106 dcl 1 patch (number_of_patches+1) aligned based (patch_ptr),
      107     2 location fixed bin (17),
      108     2 content fixed bin (35);
      109 
      110 
      111 dcl 1 patch_file aligned based (out_seg_ptr),
      112     2 version fixed bin,
      113     2 number_of_names fixed bin,
      114     2 module (130560),
      115       3 name bit (36),
      116       3 first_patch_offset bit (18) unal,
      117       3 number_of_patches fixed bin (17) unal;
      118 
      119 dcl 1 table (87040) aligned based (table_ptr),
      120     2 name bit (36),
      121     2 location fixed bin (17),
      122     2 content fixed bin (35) ;
      123 
      124 /*
      125*
      126*   Make sure there are at least enough arguments to get started.
      127*
      128**/
      129 
      130 
      131 	call cu_$arg_count (nargs);
      132 	if nargs < 2 then do;
      133 	     call com_err_ (error_table_$noarg, ME, "^/Usage is: gcos_build_patchfile patches patchfile");
      134 	     return;
      135 	end;
      136 
      137 	on cleanup call Cleanup ();
      138 
      139 
      140 /*
      141*
      142*   Process the pathname of the input file containing patches.
      143*
      144**/
      145 
      146 
      147 	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
      148 	if code ^= 0 then do;
      149 	     call com_err_ (code, ME, "referencing argument 1.");
      150 	     return;
      151 	end;
      152 
      153 	call Process_Input_Pathname ();
      154 	if code ^= 0 then return;
      155 
      156 
      157 /*
      158*
      159*   Process the patchfile pathname.
      160*
      161**/
      162 
      163 
      164 	call cu_$arg_ptr (2, arg_ptr, arg_len, code);
      165 	if code ^= 0 then do;
      166 	     call com_err_ (code, ME, "referencing argument 2.");
      167 	     return;
      168 	end;
      169 
      170 	call Process_Output_Pathname ();
      171 	if code ^= 0 then return;
      172 
      173 
      174 /*
      175*
      176*   Process the remaining arguments.  These should all be control arguments.
      177*
      178*
      179**/
      180 
      181 
      182 	do arg_num = 3 to nargs;
      183 
      184 	     call cu_$arg_ptr (arg_num, arg_ptr, arg_len, code);
      185 	     if code ^= 0 then do;
      186 		call com_err_ (code, ME, "referencing argument ^d.", arg_num);
      187 		return;
      188 	     end;
      189 
      190 	     call Process_Argument ();
      191 	     if code ^= 0 then return;
      192 
      193 	end;
      194 
      195 
      196 	temp_segments_cleanup_needed = "1"b;
      197 	call get_temp_segments_ (ME, temp_ptr, code);
      198 	if code ^= 0 then do;
      199 	     call com_err_ (code, ME);
      200 	     return;
      201 	end;
      202 
      203 	table_ptr = temp_ptr (1);
      204 
      205 	call Process_Patch_Cards ();
      206 
      207 	if code ^= 0 then return;
      208 
      209 
      210 	if highest_severity < 3 then do;
      211 
      212 	     call Sort_Patches ();
      213 	     if code ^= 0 then return;
      214 
      215 	     call Generate_Patch_File ();
      216 	     if code ^= 0 then return;
      217 
      218 	end;
      219 	else call com_err_ (error_table_$translation_failed, ME);
      220 
      221 
      222 give_up:
      223 
      224 	call tssi_$finish_segment (out_seg_ptr, out_seg_bit_count, "110"b, aclinfo_ptr, code);
      225 	tssi_cleanup_needed = "0"b;
      226 
      227 
      228 	call release_temp_segments_ (ME, temp_ptr, code);
      229 	temp_segments_cleanup_needed = "0"b;
      230 
      231 
      232 	return;
      233 
      234 Process_Input_Pathname: proc ();
      235 
      236 
      237 	     call expand_pathname_ (arg, in_dirname, in_ename, code);
      238 	     if code ^= 0 then do;
      239 		call com_err_ (code, ME, """^a""", arg);
      240 		return;
      241 	     end;
      242 
      243 
      244 	     call hcs_$initiate_count (in_dirname, in_ename, "", bit_count, 0, in_seg_ptr, code);
      245 	     if in_seg_ptr = null () then do;
      246 		call com_err_ (code, ME, """^a^[>^]^a""", in_dirname, (in_dirname ^= ">"), in_ename);
      247 		return;
      248 	     end;
      249 	     else code = 0;
      250 	     in_seg_len = divide (bit_count, 9, 20, 0);
      251 
      252 
      253 	     in_seg_offset = 1;
      254 	     in_line_len = 0;
      255 	     in_line_num = 0;
      256 	     in_line_ptr = null ();
      257 
      258 
      259 	     return;
      260 
      261 
      262 	end Process_Input_Pathname;
      263 
      264 Process_Output_Pathname: proc ();
      265 
      266 	     call expand_pathname_ (arg, out_dirname, out_ename, code);
      267 	     if code ^= 0 then do;
      268 		call com_err_ (code, ME, """^a""", arg);
      269 		return;
      270 	     end;
      271 
      272 
      273 	     tssi_cleanup_needed = "1"b;
      274 	     call tssi_$get_segment (out_dirname, out_ename, out_seg_ptr, aclinfo_ptr, code);
      275 	     if code ^= 0 then do;
      276 		call com_err_ (code, ME, """^a^[>^]^a""", out_dirname, (out_dirname ^= ">"), out_ename);
      277 		return;
      278 	     end;
      279 
      280 
      281 	     return;
      282 
      283 
      284 	end Process_Output_Pathname;
      285 
      286 Process_Argument: proc ();
      287 
      288 
      289 	     code = error_table_$badopt;
      290 	     call com_err_ (code, ME, """^a""", arg);
      291 
      292 
      293 	     return;
      294 
      295 
      296 	end Process_Argument;
      297 
      298 Get_Input_Line: proc ();
      299 
      300 
      301 dcl  in_char (in_seg_len) char (1) based (in_seg_ptr) unal;
      302 
      303 
      304 /*
      305*
      306*   Make sure we still have text to process.  If not, quit while
      307*   we're ahead.
      308*
      309**/
      310 
      311 
      312 loop:
      313 
      314 	     if in_seg_offset >= in_seg_len then do;
      315 		end_of_info = "1"b;
      316 		return;
      317 	     end;
      318 	     else end_of_info = "0"b;
      319 
      320 
      321 /*
      322*
      323*   Get the next line from the source.
      324*
      325**/
      326 
      327 
      328 	     in_line_ptr = addr (in_char (in_seg_offset));
      329 
      330 	     in_line_len = index (substr (in_seg, in_seg_offset), NL)-1;
      331 	     if in_line_len < 0 then in_line_len = in_seg_len-in_seg_offset+1;
      332 	     in_line_num = in_line_num+1;
      333 
      334 
      335 /*
      336*
      337*   Now update the offset of the next line.
      338*
      339**/
      340 
      341 
      342 	     in_seg_offset = in_seg_offset+in_line_len+1;
      343 
      344 
      345 	     if in_line_len < 78 then do;
      346 		call Error (3, "1"b, "Missing or incomplete program name.", "");
      347 		goto loop;
      348 	     end;
      349 
      350 	     if substr (in_line, 7, 9) ^= " octal   " &
      351 	     substr (in_line, 7, 9) ^= " OCTAL   " then do;
      352 		call Error (3, "1"b, "Source is not an ""octal"" line.", "");
      353 		goto loop;
      354 	     end;
      355 
      356 
      357 	     return;
      358 
      359 
      360 	end Get_Input_Line;
      361 
      362 Octal_Value: proc (text)returns (fixed bin (35));
      363 
      364 
      365 dcl  i fixed bin;
      366 dcl  result fixed bin (35);
      367 dcl  text char (*);
      368 
      369 
      370 	     i = search (text, " ,")-1;
      371 	     if i < 0 then i = length (text);
      372 	     else if substr (text, i+1, 1) = "," then do;
      373 		call Error (3, "1"b, "Bad delimiter in octal field.  ""^a""", substr (text, i+1, 1));
      374 		return (0);
      375 	     end;
      376 
      377 	     result = cv_oct_check_ (substr (text, 1, i), code);
      378 	     if code ^= 0 then do;
      379 		call Error (3, "1"b, "Bad octal value.  ""^a""", substr (text, 1, i));
      380 		return (0);
      381 	     end;
      382 
      383 
      384 	     return (result);
      385 
      386 
      387 	end Octal_Value;
      388 
      389 Process_Patch_Cards: proc ();
      390 
      391 
      392 	     end_of_info = "0"b;
      393 	     number_of_patches = 0;
      394 
      395 	     do i = 1 to hbound (table, 1) while (^end_of_info);
      396 
      397 		call Get_Input_Line ();
      398 
      399 		ascii_module_name = substr (in_line, 73, 6);
      400 		call gcos_cv_ascii_gebcd_ (addr (ascii_module_name), 6, addr (table (i).name), n);
      401 		table (i).location = Octal_Value (substr (in_line, 1, 7));
      402 		table (i).content = Octal_Value (substr (in_line, 16, 13));
      403 
      404 		number_of_patches = number_of_patches+1;
      405 
      406 	     end;
      407 
      408 
      409 	     if ^end_of_info then do;
      410 		code = error_table_$too_many_names;
      411 		call com_err_ (code, ME, "Too many patches.");
      412 		return;
      413 	     end;
      414 
      415 
      416 	     return;
      417 
      418 
      419 	end Process_Patch_Cards;
      420 
      421 Sort_Patches: proc ();
      422 
      423 
      424 dcl  i fixed bin;
      425 dcl  j fixed bin;
      426 
      427 dcl 1 R (number_of_patches) aligned based (table_ptr),
      428     2 K bit (36),
      429     2 data1 fixed bin (17),
      430     2 data2 fixed bin (35) ;
      431 
      432 dcl 1 Record aligned,
      433     2 Key bit (36),
      434     2 data1 fixed bin (17),
      435     2 data2 fixed bin (35) ;
      436 
      437 
      438 	     do j = 2 to number_of_patches;
      439 
      440 		i = j-1;
      441 		Record = R (j);
      442 
      443 
      444 l:
      445 
      446 		if Key < K (i) then do;
      447 		     R (i+1) = R (i);
      448 		     i = i-1;
      449 		     if i>0 then goto l;
      450 		end;
      451 
      452 		R (i+1) = Record;
      453 
      454 
      455 	     end;
      456 
      457 
      458 	     return;
      459 
      460 
      461 	end Sort_Patches;
      462 
      463 Generate_Patch_File: proc ();
      464 
      465 
      466 	     patch_file.version = 1;
      467 	     n = 0;
      468 	     last_name = (36)"0"b;
      469 
      470 
      471 	     do i = 1 to number_of_patches;
      472 
      473 		if table (i).name ^= last_name then do;
      474 
      475 		     n = n+1;
      476 		     last_name = table (i).name;
      477 		     patch_file.module (n).name = table (i).name;
      478 		     patch_file.module (n).first_patch_offset = (18)"0"b;
      479 		     patch_file.module (n).number_of_patches = 0;
      480 
      481 		end;
      482 
      483 	     end;
      484 
      485 
      486 	     patch_file.number_of_names = n;
      487 	     patch_ptr = addr (patch_file.module (n+1));
      488 
      489 
      490 	     n = 0;
      491 	     last_name = (36)"0"b;
      492 
      493 
      494 	     do i = 1 to number_of_patches;
      495 
      496 		if table (i).name ^= last_name then do;
      497 
      498 		     last_name = table (i).name;
      499 		     n = n+1;
      500 
      501 		     patch_file.module (n).first_patch_offset = rel (addr (patch (i)));
      502 
      503 		end;
      504 
      505 		patch_file.module (n).number_of_patches = patch_file.module (n).number_of_patches+1;
      506 		patch (i).location = table (i).location;
      507 		patch (i).content = table (i).content;
      508 
      509 	     end;
      510 
      511 
      512 	     out_seg_bit_count = fixed (rel (addr (patch (number_of_patches+1))), 18)*36;
      513 
      514 
      515 	     return;
      516 
      517 
      518 	end Generate_Patch_File;
      519 
      520 Cleanup:	proc ();
      521 
      522 
      523 	     if tssi_cleanup_needed then do;
      524 		call tssi_$clean_up_segment (aclinfo_ptr);
      525 		tssi_cleanup_needed = "0"b;
      526 	     end;
      527 
      528 
      529 	     if temp_segments_cleanup_needed then do;
      530 		call release_temp_segments_ (ME, temp_ptr, code);
      531 		temp_segments_cleanup_needed = "0"b;
      532 	     end;
      533 
      534 
      535 	     return;
      536 
      537 
      538 	end Cleanup;
      539 
      540 Error:	proc (severity, print_source, message, arg);
      541 
      542 
      543 dcl  arg char (*);
      544 dcl  message char (*);
      545 dcl  print_source bit (1) aligned;
      546 dcl  severity fixed bin;
      547 
      548 
      549 dcl  HEADING (4) char (16) init (
      550      "WARNING",
      551      "ERROR SEVERITY 2",
      552      "ERROR SEVERITY 3",
      553      "ERROR SEVERITY 4");
      554 
      555 
      556 	     call ioa_ ("^/^a, LINE ^d.", HEADING (severity), in_line_num);
      557 	     call ioa_ (message, arg);
      558 	     if print_source then call ioa_ ("SOURCE:^/^a", in_line);
      559 
      560 
      561 	     if severity>highest_severity then highest_severity = severity;
      562 
      563 
      564 	     if severity = 4 then goto give_up;
      565 
      566 
      567 	     return;
      568 
      569 
      570 	end Error;
      571 
      572 
      573      end gcos_build_patchfile;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/09/83  1006.5  gcos_build_patchfile.pl1          >spec>on>09/07/83-gcos>gcos_build_patchfile.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HEADING                         000100 automatic       char(16)                 initial array unaligned dcl 549 set ref 549* 549*
                                                                                  549* 549* 556*
K                                      based           bit(36)                  array level 2 dcl 427 set ref 444
Key                             000402 automatic       bit(36)                  level 2 dcl 432 set ref 444
ME                              000000 constant        char(20)                 initial unaligned dcl 38 set ref 133* 149* 166* 186*
                                                                                  197* 199* 219* 228* 239* 246* 268* 276* 290* 411*
                                                                                  530*
NL                                     constant        char(1)                  initial unaligned dcl 39 ref 330
R                                      based           structure                array level 1 dcl 427 set ref 441 447* 447 452*
Record                          000402 automatic       structure                level 1 dcl 432 set ref 441* 452
aclinfo_ptr                     000100 automatic       pointer                  initial dcl 41 set ref 41* 222* 274* 524*
addr                                                   builtin function         dcl 42 ref 328 400 400 400 400 487 501 512
arg                                    parameter       char                     unaligned dcl 543 in procedure "Error" set ref 540
                                                                                  557*
arg                                    based           char                     unaligned dcl 43 in procedure "gbp" set ref 237*
                                                                                  239* 266* 268* 290*
arg_len                         000102 automatic       fixed bin(17,0)          dcl 44 set ref 147* 164* 184* 237 237 239 239 266
                                                                                  266 268 268 290 290
arg_num                         000103 automatic       fixed bin(17,0)          dcl 45 set ref 182* 184* 186*
arg_ptr                         000104 automatic       pointer                  dcl 46 set ref 147* 164* 184* 237 239 266 268 290
ascii_module_name               000106 automatic       char(6)                  unaligned dcl 47 set ref 399* 400 400
bit_count                       000110 automatic       fixed bin(24,0)          dcl 48 set ref 244* 250
cleanup                         000112 stack reference condition                dcl 49 ref 137
code                            000120 automatic       fixed bin(35,0)          dcl 50 set ref 147* 148 149* 154 164* 165 166* 171
                                                                                  184* 185 186* 191 197* 198 199* 207 213 216 222*
                                                                                  228* 237* 238 239* 244* 246* 249* 266* 267 268*
                                                                                  274* 275 276* 289* 290* 377* 378 410* 411* 530*
com_err_                        000010 constant        entry                    external dcl 51 ref 133 149 166 186 199 219 239 246
                                                                                  268 276 290 411
content                   2            based           fixed bin(35,0)          array level 2 in structure "table" dcl 119
                                                                                  in procedure "gbp" set ref 402* 507
content                   1            based           fixed bin(35,0)          array level 2 in structure "patch" dcl 106
                                                                                  in procedure "gbp" set ref 507*
cu_$arg_count                   000012 constant        entry                    external dcl 52 ref 131
cu_$arg_ptr                     000014 constant        entry                    external dcl 53 ref 147 164 184
cv_oct_check_                   000016 constant        entry                    external dcl 54 ref 377
divide                                                 builtin function         dcl 55 ref 250
end_of_info                     000121 automatic       bit(1)                   unaligned dcl 57 set ref 315* 318* 392* 395 409
error_table_$badopt             000020 external static fixed bin(35,0)          dcl 59 ref 289
error_table_$noarg              000022 external static fixed bin(35,0)          dcl 60 set ref 133*
error_table_$too_many_names     000024 external static fixed bin(35,0)          dcl 61 ref 410
error_table_$translation_failed 000026 external static fixed bin(35,0)          dcl 62 set ref 219*
expand_pathname_                000030 constant        entry                    external dcl 63 ref 237 266
first_patch_offset        3            based           bit(18)                  array level 3 packed unaligned dcl 111 set ref 478*
                                                                                  501*
fixed                                                  builtin function         dcl 64 ref 512
gcos_cv_ascii_gebcd_            000032 constant        entry                    external dcl 65 ref 400
get_temp_segments_              000034 constant        entry                    external dcl 66 ref 197
hbound                                                 builtin function         dcl 67 ref 395
hcs_$initiate_count             000036 constant        entry                    external dcl 68 ref 244
highest_severity                000122 automatic       fixed bin(17,0)          initial dcl 69 set ref 69* 210 561 561*
i                               000123 automatic       fixed bin(17,0)          dcl 70 in procedure "gbp" set ref 395* 400 400 401
                                                                                  402* 471* 473 476 477* 494* 496 498 501 506 506
                                                                                  507 507*
i                               000362 automatic       fixed bin(17,0)          dcl 365 in procedure "Octal_Value" set ref 370* 371
                                                                                  371* 372 373 373 377 377 379 379
i                               000400 automatic       fixed bin(17,0)          dcl 424 in procedure "Sort_Patches" set ref 440* 444
                                                                                  447 447 448* 448 449 452
in_char                                based           char(1)                  array unaligned dcl 301 set ref 328
in_dirname                      000124 automatic       char(168)                unaligned dcl 71 set ref 237* 244* 246* 246
in_ename                        000176 automatic       char(32)                 unaligned dcl 72 set ref 237* 244* 246*
in_line                                based           char                     unaligned dcl 73 set ref 350 350 399 401 401 402 402
                                                                                  558*
in_line_len                     000206 automatic       fixed bin(20,0)          dcl 74 set ref 254* 330* 331 331* 342 345 350 350
                                                                                  399 401 401 402 402 558 558
in_line_num                     000207 automatic       fixed bin(17,0)          dcl 75 set ref 255* 332* 332 556*
in_line_ptr                     000210 automatic       pointer                  dcl 76 set ref 256* 328* 350 350 399 401 401 402 402
                                                                                  558
in_seg                                 based           char                     unaligned dcl 77 ref 330
in_seg_len                      000212 automatic       fixed bin(20,0)          dcl 78 set ref 250* 312 330 331
in_seg_offset                   000213 automatic       fixed bin(20,0)          dcl 79 set ref 253* 312 328 330 331 342* 342
in_seg_ptr                      000214 automatic       pointer                  dcl 80 set ref 244* 245 328 330
index                                                  builtin function         dcl 81 ref 330
ioa_                            000040 constant        entry                    external dcl 82 ref 556 557 558
j                               000401 automatic       fixed bin(17,0)          dcl 425 set ref 438* 440 441*
last_name                       000216 automatic       bit(36)                  unaligned dcl 83 set ref 468* 473 476* 491* 496 498*
length                                                 builtin function         dcl 84 ref 371
location                               based           fixed bin(17,0)          array level 2 in structure "patch" dcl 106
                                                                                  in procedure "gbp" set ref 506*
location                  1            based           fixed bin(17,0)          array level 2 in structure "table" dcl 119
                                                                                  in procedure "gbp" set ref 401* 506
message                                parameter       char                     unaligned dcl 544 set ref 540 557*
module                    2            based           structure                array level 2 dcl 111 set ref 487
n                               000217 automatic       fixed bin(17,0)          dcl 85 set ref 400* 467* 475* 475 477 478 479 486
                                                                                  487 490* 499* 499 501 505 505
name                                   based           bit(36)                  array level 2 in structure "table" dcl 119
                                                                                  in procedure "gbp" set ref 400 400 473 476 477 496
                                                                                  498
name                      2            based           bit(36)                  array level 3 in structure "patch_file" dcl 111
                                                                                  in procedure "gbp" set ref 477*
nargs                           000220 automatic       fixed bin(17,0)          dcl 86 set ref 131* 132 182
null                                                   builtin function         dcl 87 ref 41 92 99 99 245 256
number_of_names           1            based           fixed bin(17,0)          level 2 dcl 111 set ref 486*
number_of_patches         3(18)        based           fixed bin(17,0)          array level 3 in structure "patch_file" packed
                                                                                  unaligned dcl 111 in procedure "gbp" set ref 479*
                                                                                  505* 505
number_of_patches               000221 automatic       fixed bin(17,0)          dcl 88 in procedure "gbp" set ref 393* 404* 404 438
                                                                                  471 494 512
out_dirname                     000222 automatic       char(168)                unaligned dcl 89 set ref 266* 274* 276* 276
out_ename                       000274 automatic       char(32)                 unaligned dcl 90 set ref 266* 274* 276*
out_seg_bit_count               000304 automatic       fixed bin(24,0)          dcl 91 set ref 222* 512*
out_seg_ptr                     000306 automatic       pointer                  initial dcl 92 set ref 92* 222* 274* 466 477 478 479
                                                                                  486 487 501 505 505
patch                                  based           structure                array level 1 dcl 106 set ref 501 512
patch_file                             based           structure                level 1 dcl 111
patch_ptr                       000310 automatic       pointer                  dcl 93 set ref 487* 501 506 507 512
print_source                           parameter       bit(1)                   dcl 545 ref 540 558
rel                                                    builtin function         dcl 94 ref 501 512
release_temp_segments_          000042 constant        entry                    external dcl 95 ref 228 530
result                          000363 automatic       fixed bin(35,0)          dcl 366 set ref 377* 384
search                                                 builtin function         dcl 96 ref 370
severity                               parameter       fixed bin(17,0)          dcl 546 ref 540 556 561 561 564
substr                                                 builtin function         dcl 97 ref 330 350 350 372 373 373 377 377 379 379
                                                                                  399 401 401 402 402
table                                  based           structure                array level 1 dcl 119 set ref 395
table_ptr                       000312 automatic       pointer                  dcl 98 set ref 203* 395 400 400 401 402 441 444 447
                                                                                  447 452 473 476 477 496 498 506 507
temp_ptr                        000314 automatic       pointer                  initial array dcl 99 set ref 99* 99* 197* 203 228*
                                                                                  530*
temp_segments_cleanup_needed    000320 automatic       bit(1)                   initial dcl 100 set ref 100* 196* 229* 529 531*
text                                   parameter       char                     unaligned dcl 367 ref 362 370 371 372 373 373 377
                                                                                  377 379 379
tssi_$clean_up_segment          000044 constant        entry                    external dcl 101 ref 524
tssi_$finish_segment            000046 constant        entry                    external dcl 102 ref 222
tssi_$get_segment               000050 constant        entry                    external dcl 103 ref 274
tssi_cleanup_needed             000321 automatic       bit(1)                   initial dcl 104 set ref 104* 225* 273* 523 525*
version                                based           fixed bin(17,0)          level 2 dcl 111 set ref 466*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
dummy                                  automatic       fixed bin(17,0)          dcl 56
error_table_$bad_arg                   external static fixed bin(35,0)          dcl 58

NAMES DECLARED BY EXPLICIT CONTEXT.
Cleanup                         002322 constant        entry                    internal dcl 520 ref 137
Error                           002366 constant        entry                    internal dcl 540 ref 346 352 373 379
Generate_Patch_File             002156 constant        entry                    internal dcl 463 ref 215
Get_Input_Line                  001356 constant        entry                    internal dcl 298 ref 397
Octal_Value                     001526 constant        entry                    internal dcl 362 ref 401 402
Process_Argument                001320 constant        entry                    internal dcl 286 ref 190
Process_Input_Pathname          000706 constant        entry                    internal dcl 234 ref 153
Process_Output_Pathname         001125 constant        entry                    internal dcl 264 ref 170
Process_Patch_Cards             001731 constant        entry                    internal dcl 389 ref 205
Sort_Patches                    002076 constant        entry                    internal dcl 421 ref 212
gbp                             000241 constant        entry                    external dcl 36
gcos_build_patchfile            000251 constant        entry                    external dcl 36
give_up                         000641 constant        label                    dcl 222 ref 564
l                               002122 constant        label                    dcl 444 ref 449
loop                            001357 constant        label                    dcl 312 ref 347 353

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3246        3320    3003        3256
Length      3540    3003        52         203     243           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gbp                                 576 external procedure  is an external procedure.  
on unit on line 137                  88 on unit               
Process_Input_Pathname                  internal procedure  shares stack frame of external procedure gbp.  
Process_Output_Pathname                 internal procedure  shares stack frame of external procedure gbp.  
Process_Argument                        internal procedure  shares stack frame of external procedure gbp.  
Get_Input_Line                          internal procedure  shares stack frame of external procedure gbp.  
Octal_Value                             internal procedure  shares stack frame of external procedure gbp.  
Process_Patch_Cards                     internal procedure  shares stack frame of external procedure gbp.  
Sort_Patches                            internal procedure  shares stack frame of external procedure gbp.  
Generate_Patch_File                     internal procedure  shares stack frame of external procedure gbp.  
Cleanup                                 internal procedure  shares stack frame of on unit on line 137.  
Error                               102 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
Error                    000100 HEADING                     Error
gbp                      000100 aclinfo_ptr                 gbp
                         000102 arg_len                     gbp
                         000103 arg_num                     gbp
                         000104 arg_ptr                     gbp
                         000106 ascii_module_name           gbp
                         000110 bit_count                   gbp
                         000120 code                        gbp
                         000121 end_of_info                 gbp
                         000122 highest_severity            gbp
                         000123 i                           gbp
                         000124 in_dirname                  gbp
                         000176 in_ename                    gbp
                         000206 in_line_len                 gbp
                         000207 in_line_num                 gbp
                         000210 in_line_ptr                 gbp
                         000212 in_seg_len                  gbp
                         000213 in_seg_offset               gbp
                         000214 in_seg_ptr                  gbp
                         000216 last_name                   gbp
                         000217 n                           gbp
                         000220 nargs                       gbp
                         000221 number_of_patches           gbp
                         000222 out_dirname                 gbp
                         000274 out_ename                   gbp
                         000304 out_seg_bit_count           gbp
                         000306 out_seg_ptr                 gbp
                         000310 patch_ptr                   gbp
                         000312 table_ptr                   gbp
                         000314 temp_ptr                    gbp
                         000320 temp_segments_cleanup_needed
                                                            gbp
                         000321 tssi_cleanup_needed         gbp
                         000362 i                           Octal_Value
                         000363 result                      Octal_Value
                         000400 i                           Sort_Patches
                         000401 j                           Sort_Patches
                         000402 Record                      Sort_Patches

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out        call_int_this_desc  return
tra_ext             enable              shorten_stack       ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_oct_check_
expand_pathname_              gcos_cv_ascii_gebcd_          get_temp_segments_            hcs_$initiate_count
ioa_                          release_temp_segments_        tssi_$clean_up_segment        tssi_$finish_segment
tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg            error_table_$too_many_names
error_table_$translation_failed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     41 000213        69 000215        92 000216        99 000217       100 000234       104 000235        36 000240
    131 000257       132 000266       133 000271       134 000315       137 000316       147 000334       148 000353
    149 000355       150 000401       153 000402       154 000403       164 000405       165 000424       166 000426
    167 000452       170 000453       171 000454       182 000456       184 000465       185 000502       186 000504
    187 000534       190 000535       191 000536       193 000540       196 000542       197 000544       198 000565
    199 000567       200 000604       203 000605       205 000607       207 000610       210 000612       212 000615
    213 000616       215 000620       216 000621       218 000623       219 000624       222 000641       225 000662
    228 000663       229 000704       232 000705       234 000706       237 000707       238 000737       239 000741
    240 000773       244 000774       245 001036       246 001042       247 001111       249 001112       250 001113
    253 001116       254 001120       255 001121       256 001122       259 001124       264 001125       266 001126
    267 001156       268 001160       269 001212       273 001213       274 001215       275 001245       276 001247
    277 001316       281 001317       286 001320       289 001321       290 001324       293 001355       298 001356
    312 001357       315 001362       316 001364       318 001365       328 001366       330 001373       331 001411
    332 001416       342 001417       345 001422       346 001425       347 001460       350 001461       352 001471
    353 001524       357 001525       362 001526       370 001537       371 001552       372 001556       373 001564
    374 001621       377 001624       378 001652       379 001655       380 001721       384 001725       389 001731
    392 001732       393 001733       395 001734       397 001743       399 001744       400 001751       401 001777
    402 002016       404 002036       406 002037       409 002041       410 002043       411 002046       412 002074
    416 002075       421 002076       438 002077       440 002107       441 002111       444 002122       447 002130
    448 002137       449 002141       452 002143       455 002153       458 002155       463 002156       466 002157
    467 002161       468 002162       471 002163       473 002173       475 002201       476 002202       477 002203
    478 002210       479 002213       483 002216       486 002220       487 002223       490 002227       491 002230
    494 002231       496 002241       498 002247       499 002250       501 002251       503 002264       505 002265
    506 002277       507 002306       509 002310       512 002312       515 002321       520 002322       523 002323
    524 002326       525 002335       529 002337       530 002341       531 002362       535 002364       540 002365
    549 002406       556 002454       557 002504       558 002523       561 002554       564 002562       567 002567


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
