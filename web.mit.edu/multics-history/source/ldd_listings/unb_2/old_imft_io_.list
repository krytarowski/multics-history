	COMPILATION LISTING OF SEGMENT old_imft_io_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/14/88  1215.0 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* I/O module to transmit files between Multics sites using I/O daemon record oriented communications modules */
        9 
       10 /* Created:  October 1980 by G. Palter */
       11 /* Modified: April 1982 by G. Palter to greatly simplify attach description and internal operation */
       12 /* Modified: 26 July 1982 by G. Palter to add get_channel_names control order */
       13 /* Modified: February 1983 by Robert Coren to change from imft_io_ to old_imft_io_ */
       14 
       15 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       16 
       17 
       18 old_imft_io_:
       19      procedure ();
       20 	return;					/* not an entry */
       21 
       22 
       23 /* Parameters */
       24 
       25 dcl  P_iocb_ptr pointer parameter;			/* *: -> I/O switch being operated upon */
       26 dcl  P_code fixed binary (35) parameter;
       27 
       28 dcl  P_attach_options (*) character (*) varying parameter;	/* attach: attachment arguments */
       29 dcl  P_loud_sw bit (1) parameter;			/* attach: ON => attachment errors should call com_err_ */
       30 
       31 dcl  P_open_mode fixed binary parameter;		/* open: opening mode */
       32 dcl  P_open_sw bit (1) parameter;			/* open: obsolete parameter */
       33 
       34 dcl  P_data_lth fixed binary (21) parameter;		/* get_*: set to # of characters read into buffer;
       35*						   put_chars: # of characters to transmit as logical record */
       36 
       37 dcl  P_buffer_ptr pointer parameter;			/* get_*: -> area to place result of read */
       38 dcl  P_buffer_max_lth fixed binary (21) parameter;	/* get_*: size of area in characters */
       39 
       40 dcl  P_data_ptr pointer parameter;			/* put_chars: -> data stream to be written */
       41 
       42 dcl  P_order character (*) parameter;			/* control: name of control order to be performed */
       43 dcl  P_info_ptr pointer parameter;			/* control: -> additional information required to execute the
       44*						   control order */
       45 
       46 dcl  P_new_modes character (*) parameter;		/* modes: new modes to be set */
       47 dcl  P_old_modes character (*) parameter;		/* modes: set to modes in effect before change */
       48 
       49 
       50 /* Local copies of parameters */
       51 
       52 dcl  iocb_ptr pointer;
       53 dcl  code fixed binary (35);
       54 
       55 dcl  argument character (argument_lth) based (argument_ptr);/* based on attach options */
       56 dcl  argument_lth fixed binary (21);
       57 dcl  argument_ptr pointer;
       58 
       59 dcl  loud_sw bit (1) aligned;
       60 
       61 dcl  open_mode fixed binary;
       62 
       63 dcl  buffer_lth fixed binary (21);
       64 
       65 dcl  order character (32);
       66 dcl  info_ptr pointer;
       67 
       68 
       69 /* Remaining declarations */
       70 
       71 dcl  1 local_tgci aligned like tty_get_channel_info;	/* for get_channel_names */
       72 
       73 dcl  system_area area aligned based (system_area_ptr);
       74 dcl  system_area_ptr pointer;
       75 
       76 dcl  argument_idx fixed binary;			/* # of attach option being processed */
       77 
       78 dcl  direction character (32);
       79 dcl  (input_description_idx, output_description_idx) fixed binary;
       80 
       81 dcl  an_attach_description character (512);
       82 
       83 dcl  terminal_switch_name character (32);
       84 dcl  terminal_iocb_ptr pointer;
       85 dcl  terminal_attach_count fixed binary static initial (0);
       86 dcl  terminal_attach_count_pic picture "999";
       87 
       88 dcl  ips_mask bit (36);
       89 
       90 dcl  local_record_type fixed binary;
       91 
       92 dcl  IMFT_IO_ character (32) static options (constant) initial ("old_imft_io_");
       93 
       94 dcl  N_BITS_PER_CHARACTER fixed binary static options (constant) initial (9);
       95 
       96 dcl  RELATIVE_SECONDS bit (2) static options (constant) initial ("11"b);
       97 dcl  ONE_MINUTE fixed binary (71) static options (constant) initial (60);
       98 
       99 dcl  SP character (1) static options (constant) initial (" ");
      100 
      101 /* format: off */
      102 dcl (error_table_$action_not_performed, error_table_$badopt, error_table_$bad_arg, error_table_$bad_conversion,
      103      error_table_$bad_mode, error_table_$eof_record, error_table_$improper_data_format, error_table_$invalid_read,
      104      error_table_$invalid_write, error_table_$noarg, error_table_$no_operation, error_table_$not_attached,
      105      error_table_$not_closed, error_table_$not_detached, error_table_$not_open, error_table_$null_info_ptr,
      106      error_table_$short_record, error_table_$undefined_order_request, error_table_$unimplemented_version)
      107 	fixed binary (35) external;
      108 
      109 dcl (imft_et_$cant_get_channel_names, imft_et_$reply_pending, imft_et_$timeout)
      110 	fixed binary (35) external;
      111 /* format: on */
      112 
      113 dcl  add_bit_offset_ entry (pointer, fixed binary (24)) returns (pointer);
      114 dcl  com_err_ entry () options (variable);
      115 dcl  continue_to_signal_ entry (fixed binary (35));
      116 dcl  cu_$arg_list_ptr entry () returns (pointer);
      117 dcl  cu_$arg_ptr entry (fixed binary, pointer, fixed binary (21), fixed binary (35));
      118 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
      119 dcl  get_system_free_area_ entry () returns (pointer);
      120 dcl  hcs_$reset_ips_mask entry (bit (36), bit (36));
      121 dcl  hcs_$set_ips_mask entry (bit (36), bit (36));
      122 dcl  ioa_$general_rs entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21), bit (1), bit (1));
      123 dcl  iox_$attach_ioname entry (character (*), pointer, character (*), fixed binary (35));
      124 dcl  iox_$control entry (pointer, character (*), pointer, fixed binary (35));
      125 dcl  iox_$close entry (pointer, fixed binary (35));
      126 dcl  iox_$destroy_iocb entry (pointer, fixed binary (35));
      127 dcl  iox_$detach_iocb entry (pointer, fixed binary (35));
      128 dcl  iox_$err_no_operation entry () options (variable);
      129 dcl  iox_$open entry (pointer, fixed binary, bit (1) aligned, fixed binary (35));
      130 dcl  iox_$propagate entry (pointer);
      131 dcl  iox_$read_record entry (pointer, pointer, fixed binary (21), fixed binary (21), fixed binary (35));
      132 dcl  iox_$write_record entry (pointer, pointer, fixed binary (21), fixed binary (35));
      133 dcl  requote_string_ entry (character (*)) returns (character (*));
      134 dcl  timer_manager_$alarm_call entry (fixed binary (71), bit (2), entry);
      135 dcl  timer_manager_$reset_alarm_call entry (entry);
      136 
      137 dcl  (any_other, cleanup, imft_debug_, imft_read_abort_, imft_write_abort_) condition;
      138 
      139 dcl  (addr, collate, convert, currentsize, divide, hbound, lbound, length, ltrim, min, mod, null, rtrim, string, substr,
      140      verify, unspec) builtin;
      141 
      142 /**/
      143 
      144 /* Description of a switch attached through this module */
      145 
      146 dcl  1 iad aligned based (iad_ptr),
      147        2 attach_description character (1024) varying,	/* attach description for this I/O switch */
      148        2 open_description character (24) varying,		/* open description for this I/O switch */
      149        2 input_switch like switch_info,			/* defines the input terminal switch */
      150        2 output_switch like switch_info,		/* defines the output terminal switch */
      151        2 abort_code fixed binary (35),			/* status code of last aborted I/O operation */
      152        2 flags aligned,
      153          3 input_direction bit (1) unaligned,		/* ON => receives data from remote system */
      154          3 abort_in_progress bit (1) unaligned,		/* ON => last I/O operation failed */
      155          3 debug_mode bit (1) unaligned,		/* ON => trying to debug IMFT: stop on errors */
      156          3 pad bit (33) unaligned;
      157 
      158 dcl  iad_ptr pointer;
      159 
      160 
      161 /* Description of a single terminal level I/O switch */
      162 
      163 dcl  1 switch_info aligned based (switch_info_ptr),
      164        2 terminal_iocb_ptr pointer,			/* -> IOCB for terminal level module */
      165        2 current_physical_record_type fixed binary,	/* type of record currently in buffer (if any) */
      166        2 current_physical_record_n_els fixed binary (24),	/* # of characters or bits in current record */
      167        2 current_physical_record_used fixed binary (24),	/* # of characters or bits already returned to caller */
      168        2 pad bit (36),
      169        2 tior,					/* terminal_io_record used for I/O */
      170          3 header like terminal_io_record.header,
      171          3 data character (IMFT_PHYSICAL_RECORD_LTH) unaligned;
      172 
      173 dcl  switch_info_ptr pointer;
      174 
      175 /**/
      176 
      177 /* Physical record structure used to transmit data and control information */
      178 
      179 dcl  1 imft_physical_record aligned based (ipr_ptr),
      180        2 pad1 bit (2) unaligned,
      181        2 record_type fixed binary (7) unaligned unsigned,	/* type of record: data or control */
      182        2 pad2 bit (2) unaligned,
      183        2 flags unaligned,
      184          3 binary bit (1) unaligned,			/* ON => binary data in record as 7-bit bytes */
      185          3 bolr bit (1) unaligned,			/* ON => this is first physical record of a logical record */
      186          3 eolr bit (1) unaligned,			/* ON => last physical record in logical record */
      187          3 pad3 bit (4) unaligned,
      188        2 n_els unaligned,				/* # of elements (characters or 7-bit bytes) */
      189          3 pad4 bit (2) unaligned,
      190          3 high_order bit (7) unaligned,
      191          3 pad5 bit (2) unaligned,
      192          3 low_order bit (7) unaligned,
      193        2 data character (IMFT_PHYSICAL_RECORD_DATA_LTH) unaligned;
      194 						/* the actual data */
      195 
      196 dcl  1 ipr_data_overlay unaligned based (addr (imft_physical_record.data)),
      197        2 elements (IMFT_PHYSICAL_RECORD_DATA_LTH) unaligned,/* 7-bit bytes of binary data unpacked in 9 bits */
      198          3 pad1 bit (2) unaligned,
      199          3 byte bit (7) unaligned;
      200 
      201 dcl  ipr_ptr pointer;
      202 
      203 dcl  (
      204      IMFT_PHYSICAL_RECORD_LTH initial (80),		/* size of each physical record */
      205      IMFT_PHYSICAL_RECORD_DATA_LTH initial (76),		/* # of bytes of user's data in each record */
      206      IMFT_PHYSICAL_RECORD_DATA_BITS_LTH initial (532)	/* # of bits of user's data in each record for binary data */
      207      ) fixed binary static options (constant);
      208 
      209 /**/
      210 
      211 /* Attach an I/O switch for file transfer */
      212 
      213 old_imft_io_attach:
      214      entry (P_iocb_ptr, P_attach_options, P_loud_sw, P_code);
      215 
      216 	iocb_ptr = P_iocb_ptr;
      217 	loud_sw = P_loud_sw;
      218 	code = 0;
      219 
      220 	iad_ptr = null ();				/* avoid freeing garbage if I/O switch already attached */
      221 
      222 	if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then do;
      223 	     P_code = error_table_$not_detached;
      224 	     if loud_sw then call com_err_ (P_code, IMFT_IO_, "For switch ^a.", iocb_ptr -> iocb.name);
      225 	     return;
      226 	end;
      227 
      228 	system_area_ptr = get_system_free_area_ ();
      229 
      230 	on condition (cleanup) call cleanup_attachment ((0));
      231 
      232 
      233 /* Process attachment options */
      234 
      235 	if hbound (P_attach_options, 1) < 1 then
      236 	     call abort_attachment (error_table_$noarg,
      237 		"""-direction"", ""-input_description"", and ""-output_description"" must be supplied.");
      238 
      239 	allocate iad in (system_area) set (iad_ptr);
      240 	iad.input_switch.terminal_iocb_ptr,		/* keeps cleanup handler happy */
      241 	     iad.output_switch.terminal_iocb_ptr = null ();
      242 
      243 	direction = "";				/* haven't seen -direction yet */
      244 	input_description_idx = 0;			/* haven't seen -input_description yet */
      245 	output_description_idx = 0;			/* haven't seen -output_description yet */
      246 	iad.debug_mode = "0"b;			/* haven't seen -debug yet */
      247 
      248 	iad.attach_description = "";
      249 	iad.open_description = "";
      250 
      251 
      252 	do argument_idx = lbound (P_attach_options, 1) to hbound (P_attach_options, 1);
      253 
      254 	     argument_ptr = substraddr (P_attach_options (argument_idx), 1);
      255 	     argument_lth = length (P_attach_options (argument_idx));
      256 
      257 	     if argument = "-direction" then do;
      258 		direction = get_string_argument ();
      259 		if (direction ^= "input") & (direction ^= "output") then
      260 		     call abort_attachment (error_table_$bad_arg,
      261 			"-direction must be followed by ""input"" or ""output""; not ""^a"".", direction);
      262 	     end;
      263 
      264 	     else if (argument = "-input_description") | (argument = "-ids") then do;
      265 		an_attach_description = get_string_argument ();
      266 		input_description_idx = argument_idx;
      267 	     end;
      268 
      269 	     else if (argument = "-output_description") | (argument = "-ods") then do;
      270 		an_attach_description = get_string_argument ();
      271 		output_description_idx = argument_idx;
      272 	     end;
      273 
      274 	     else if argument = "-debug" then iad.debug_mode = "1"b;
      275 
      276 	     else call abort_attachment (error_table_$badopt, """^a""", argument);
      277 	end;
      278 
      279 	if direction = "" then call abort_attachment (error_table_$noarg, "-direction");
      280 
      281 	if input_description_idx = 0 then call abort_attachment (error_table_$noarg, "-input_description");
      282 
      283 	if output_description_idx = 0 then call abort_attachment (error_table_$noarg, "-output_description");
      284 
      285 
      286 /* Construct our attach description */
      287 
      288 	iad.attach_description = rtrim (IMFT_IO_);
      289 
      290 	iad.attach_description = iad.attach_description || " -direction ";
      291 	iad.attach_description = iad.attach_description || rtrim (direction);
      292 
      293 	argument_ptr = substraddr (P_attach_options (input_description_idx), 1);
      294 	argument_lth = length (P_attach_options (input_description_idx));
      295 	iad.attach_description = iad.attach_description || " -input_description ";
      296 	iad.attach_description = iad.attach_description || requote_string_ (argument);
      297 
      298 	argument_ptr = substraddr (P_attach_options (output_description_idx), 1);
      299 	argument_lth = length (P_attach_options (output_description_idx));
      300 	iad.attach_description = iad.attach_description || " -output_description ";
      301 	iad.attach_description = iad.attach_description || requote_string_ (argument);
      302 
      303 
      304 /* Attach through the terminal level */
      305 
      306 	iad.input_direction = (direction = "input");
      307 
      308 	terminal_attach_count = terminal_attach_count + 1;
      309 	if terminal_attach_count > 999 then terminal_attach_count = 1;
      310 
      311 	terminal_switch_name =
      312 	     rtrim (IMFT_IO_) || ".input." || ltrim (convert (terminal_attach_count_pic, terminal_attach_count));
      313 
      314 	call iox_$attach_ioname (terminal_switch_name, terminal_iocb_ptr, (P_attach_options (input_description_idx)),
      315 	     code);
      316 	if code ^= 0 then
      317 	     call abort_attachment (code, "Unable to attach input channel via: ^a",
      318 		P_attach_options (input_description_idx));
      319 
      320 	iad.input_switch.terminal_iocb_ptr = terminal_iocb_ptr;
      321 
      322 
      323 	terminal_switch_name =
      324 	     rtrim (IMFT_IO_) || ".output." || ltrim (convert (terminal_attach_count_pic, terminal_attach_count));
      325 
      326 	call iox_$attach_ioname (terminal_switch_name, terminal_iocb_ptr, (P_attach_options (output_description_idx)),
      327 	     code);
      328 	if code ^= 0 then
      329 	     call abort_attachment (code, "Unable to attach output channel via: ^a",
      330 		P_attach_options (output_description_idx));
      331 
      332 	iad.output_switch.terminal_iocb_ptr = terminal_iocb_ptr;
      333 
      334 
      335 /* Initialize the input and output terminal switch structures */
      336 
      337 	iad.input_switch.current_physical_record_type, iad.output_switch.current_physical_record_type = -1;
      338 	iad.input_switch.current_physical_record_n_els, iad.output_switch.current_physical_record_n_els = 0;
      339 	iad.input_switch.current_physical_record_used, iad.output_switch.current_physical_record_used = 0;
      340 
      341 	iad.input_switch.tior.version, iad.output_switch.tior.version = terminal_io_record_version_1;
      342 
      343 	iad.input_switch.tior.device_type = READER_DEVICE;
      344 	iad.output_switch.tior.device_type = PUNCH_DEVICE;
      345 
      346 	iad.input_switch.tior.slew_type, iad.output_switch.tior.slew_type = SLEW_BY_COUNT;
      347 	iad.input_switch.tior.slew_count, iad.output_switch.tior.slew_count = 1;
      348 
      349 	string (iad.input_switch.tior.flags), string (iad.output_switch.tior.flags) = ""b;
      350 
      351 	iad.input_switch.tior.element_size, iad.output_switch.tior.element_size = N_BITS_PER_CHARACTER;
      352 	iad.input_switch.tior.n_elements, iad.output_switch.tior.n_elements = IMFT_PHYSICAL_RECORD_LTH;
      353 
      354 	iad.abort_in_progress = "0"b;			/* didn't encounter any errors yet */
      355 	iad.abort_code = 0;
      356 
      357 
      358 /* Mask and complete construction of the IOCB */
      359 
      360 	ips_mask = ""b;
      361 
      362 	on condition (any_other) call any_other_handler ();
      363 
      364 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      365 
      366 	iocb_ptr -> iocb.attach_descrip_ptr = addr (iad.attach_description);
      367 	iocb_ptr -> iocb.attach_data_ptr = iad_ptr;
      368 	iocb_ptr -> iocb.open = imft_io_open;
      369 	iocb_ptr -> iocb.detach_iocb = imft_io_detach;
      370 
      371 	call iox_$propagate (iocb_ptr);
      372 
      373 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      374 
      375 RETURN_FROM_ATTACH:
      376 	P_code = code;
      377 	return;
      378 
      379 /**/
      380 
      381 /* Open an I/O switch for file transfer */
      382 
      383 imft_io_open:
      384      entry (P_iocb_ptr, P_open_mode, P_open_sw, P_code);
      385 
      386 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      387 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      388 
      389 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      390 	     P_code = error_table_$not_closed;
      391 	     return;
      392 	end;
      393 
      394 	open_mode = P_open_mode;
      395 
      396 	if ^((iad.input_direction & (open_mode = Stream_input)) | (^iad.input_direction & (open_mode = Stream_output)))
      397 	then do;					/* opening mode and direction must agree */
      398 	     P_code = error_table_$bad_mode;
      399 	     return;
      400 	end;
      401 
      402 	call iox_$open (iad.input_switch.terminal_iocb_ptr, Sequential_input, "0"b, P_code);
      403 	if P_code ^= 0 then return;
      404 
      405 	call iox_$open (iad.output_switch.terminal_iocb_ptr, Sequential_output, "0"b, P_code);
      406 	if P_code ^= 0 then do;			/* must close the other one to stay happy */
      407 	     call iox_$close (iad.input_switch.terminal_iocb_ptr, (0));
      408 	     return;
      409 	end;
      410 
      411 	iad.open_description = rtrim (iox_modes (open_mode));
      412 
      413 	ips_mask = ""b;
      414 
      415 	on condition (any_other) call any_other_handler ();
      416 
      417 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      418 
      419 	if iad.input_direction then
      420 	     iocb_ptr -> iocb.get_chars, iocb_ptr -> iocb.get_line = imft_io_get_chars;
      421 	else iocb_ptr -> iocb.put_chars = imft_io_put_chars;
      422 
      423 	iocb_ptr -> iocb.control = imft_io_control;
      424 	iocb_ptr -> iocb.modes = imft_io_modes;
      425 
      426 	iocb_ptr -> iocb.close = imft_io_close;
      427 	iocb_ptr -> iocb.detach_iocb = imft_io_detach;
      428 
      429 	iocb_ptr -> iocb.open_descrip_ptr = addr (iad.open_description);
      430 						/* it's now open */
      431 
      432 	call iox_$propagate (iocb_ptr);
      433 
      434 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      435 
      436 	P_code = 0;
      437 	return;
      438 
      439 /**/
      440 
      441 /* Close an I/O switch used for file transfer */
      442 
      443 imft_io_close:
      444      entry (P_iocb_ptr, P_code);
      445 
      446 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      447 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      448 	code = 0;
      449 
      450 	if iocb_ptr -> iocb.open_descrip_ptr = null () then do;
      451 	     P_code = error_table_$not_open;
      452 	     return;
      453 	end;
      454 
      455 	call iox_$close (iad.output_switch.terminal_iocb_ptr, code);
      456 	if (code = error_table_$not_open) | (code = error_table_$not_attached) then code = 0;
      457 
      458 	call iox_$close (iad.input_switch.terminal_iocb_ptr, code);
      459 	if (code = error_table_$not_open) | (code = error_table_$not_attached) then code = 0;
      460 
      461 	ips_mask = ""b;
      462 
      463 	on condition (cleanup) call any_other_handler ();
      464 
      465 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      466 
      467 	iocb_ptr -> iocb.open_descrip_ptr = null ();
      468 
      469 	iocb_ptr -> iocb.open = imft_io_open;
      470 	iocb_ptr -> iocb.detach_iocb = imft_io_detach;
      471 
      472 	iocb_ptr -> iocb.control, iocb_ptr -> iocb.modes, iocb_ptr -> iocb.get_chars, iocb_ptr -> iocb.get_line,
      473 	     iocb_ptr -> iocb.put_chars = iox_$err_no_operation;
      474 
      475 	call iox_$propagate (iocb_ptr);
      476 
      477 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      478 
      479 	P_code = code;
      480 
      481 	return;
      482 
      483 /**/
      484 
      485 /* Detach an I/O switch from file transfer */
      486 
      487 imft_io_detach:
      488      entry (P_iocb_ptr, P_code);
      489 
      490 	iocb_ptr = P_iocb_ptr;
      491 	code = 0;
      492 
      493 	if iocb_ptr -> iocb.attach_descrip_ptr = null () then do;
      494 	     P_code = error_table_$not_attached;
      495 	     return;
      496 	end;
      497 
      498 	if iocb_ptr -> iocb.open_descrip_ptr ^= null () then do;
      499 	     P_code = error_table_$not_closed;
      500 	     return;
      501 	end;
      502 
      503 	system_area_ptr = get_system_free_area_ ();
      504 
      505 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      506 
      507 	call cleanup_attachment (code);
      508 
      509 	ips_mask = ""b;
      510 
      511 	on condition (any_other) call any_other_handler ();
      512 
      513 	call hcs_$set_ips_mask (((36)"0"b), ips_mask);
      514 
      515 	iocb_ptr -> iocb.attach_descrip_ptr = null ();	/* it's detached */
      516 
      517 	call iox_$propagate (iocb_ptr);
      518 
      519 	call hcs_$reset_ips_mask (ips_mask, ips_mask);
      520 
      521 	P_code = code;				/* in case trouble freeing the channel */
      522 	return;
      523 
      524 /**/
      525 
      526 /* Write data records to the remote Multics: formats the user's data stream into IMFT physical records and
      527*   transmits them to the remote Multics.  The IMFT physical record format is designed so that one put_chars call on this
      528*   system will be converted into one get_chars (or get_line) call on the remote.  If any errors are detected while
      529*   writing, this I/O module signals the "imft_write_abort_" condition which imft_transmit_object_ handles through the
      530*   "get_abort_info" control order */
      531 
      532 imft_io_put_chars:
      533      entry (P_iocb_ptr, P_data_ptr, P_data_lth, P_code);
      534 
      535 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      536 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      537 	code = 0;
      538 
      539 	if iad.input_direction then do;		/* can't write the input side of a pipe */
      540 	     P_code = error_table_$invalid_write;
      541 	     return;
      542 	end;
      543 
      544 	call transmit_logical_data_record (IMFT_DATA, P_data_ptr, P_data_lth);
      545 						/* does the actual work */
      546 
      547 	P_code = code;
      548 	return;
      549 
      550 /**/
      551 
      552 /* Read data records from the remote Multics:  reads requested number of data characters from the remote system.
      553*   Data is read until either the user's buffer is filled or a control record is encountered.  If a control record is read
      554*   before any data is found or an I/O error occurs during a read, the condition "imft_read_abort_" is signalled which is
      555*   recognized by the caller.  The reason for the termination of the read request can be determined by the "get_abort_info"
      556*   control order */
      557 
      558 imft_io_get_chars:
      559      entry (P_iocb_ptr, P_buffer_ptr, P_buffer_max_lth, P_data_lth, P_code);
      560 
      561 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      562 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      563 
      564 	if ^iad.input_direction then do;		/* attempt to read the "punch" */
      565 	     P_code = error_table_$invalid_read;
      566 	     return;
      567 	end;
      568 
      569 	call receive_logical_data_records (P_buffer_ptr, P_buffer_max_lth, P_data_lth);
      570 
      571 	P_code = 0;				/* here iff successful */
      572 	return;
      573 
      574 /**/
      575 
      576 /* Perform control operations on an I/O switch attached for file transfer */
      577 
      578 imft_io_control:
      579      entry (P_iocb_ptr, P_order, P_info_ptr, P_code);
      580 
      581 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      582 	iad_ptr = iocb_ptr -> iocb.attach_data_ptr;
      583 
      584 	order = P_order;
      585 	info_ptr = P_info_ptr;
      586 
      587 	code = 0;
      588 
      589 
      590 	if order = "write_command_record" then do;
      591 
      592 /* Write a command record:  Commands are sent by an output driver to the remote system's input driver to instruct the
      593*   input driver as to what it should do next (begin reception of an object, abort, synchronize, etc.) */
      594 
      595 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      596 
      597 	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;
      598 
      599 	     else if iad.input_direction then		/* must be transmitting data */
      600 		code = error_table_$invalid_write;
      601 
      602 	     else do;
      603 		icri_ptr = info_ptr;
      604 		if icri.timeout > 0 then do;		/* trap no response */
      605 		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
      606 		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
      607 		end;
      608 		call transmit_logical_control_record ((icri.record_type), icri.record_ptr, icri.record_lth, code);
      609 		call timer_manager_$reset_alarm_call (read_write_timeout);
      610 	     end;
      611 	end;
      612 
      613 
      614 	else if order = "read_command_record" then do;
      615 
      616 /* Read a command record: any intervening data records are discarded */
      617 
      618 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      619 
      620 	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;
      621 
      622 	     else if ^iad.input_direction then		/* must be receiving data to receive control records */
      623 		code = error_table_$invalid_read;
      624 
      625 	     else do;
      626 		icri_ptr = info_ptr;
      627 		if icri.timeout > 0 then do;		/* trap no response */
      628 		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
      629 		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
      630 		end;
      631 		call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
      632 		     icri.record_type, code);
      633 		call timer_manager_$reset_alarm_call (read_write_timeout);
      634 	     end;
      635 	end;
      636 
      637 
      638 	else if order = "write_reply_record" then do;
      639 
      640 /* Write a reply record:  Reply records are often sent by an input driver in response to a command record and indicate the
      641*   input driver's reasons for accepting or rejecting a command */
      642 
      643 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      644 
      645 	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;
      646 
      647 	     else if ^iad.input_direction then		/* must be receive side of a connection */
      648 		code = error_table_$invalid_write;
      649 
      650 	     else do;
      651 		icri_ptr = info_ptr;
      652 		if icri.timeout > 0 then do;		/* trap no response */
      653 		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
      654 		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
      655 		end;
      656 		call transmit_logical_control_record ((icri.record_type), icri.record_ptr, icri.record_lth, code);
      657 		call timer_manager_$reset_alarm_call (read_write_timeout);
      658 	     end;
      659 	end;
      660 
      661 
      662 	else if order = "read_reply_record" then do;
      663 
      664 /* Read a reply record */
      665 
      666 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      667 
      668 	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;
      669 
      670 	     else if iad.input_direction then		/* must be transmitting side of connection */
      671 		code = error_table_$invalid_read;
      672 
      673 	     else do;
      674 		icri_ptr = info_ptr;
      675 		if icri.timeout > 0 then do;		/* trap no response */
      676 		     call timer_manager_$alarm_call ((icri.timeout), RELATIVE_SECONDS, read_write_timeout);
      677 		     on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
      678 		end;
      679 		call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
      680 		     icri.record_type, code);
      681 		call timer_manager_$reset_alarm_call (read_write_timeout);
      682 	     end;
      683 	end;
      684 
      685 
      686 	else if order = "get_abort_info" then do;
      687 
      688 /* Return cause of previous get_chars or put_chars failure */
      689 
      690 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      691 
      692 	     else if info_ptr -> icri.version ^= ICRI_VERSION_1 then code = error_table_$unimplemented_version;
      693 
      694 	     else do;
      695 		icri_ptr = info_ptr;
      696 
      697 		if iad.abort_in_progress then do;	/* something did indeed go wrong */
      698 		     iad.abort_in_progress = "0"b;
      699 
      700 		     if (iad.abort_code ^= 0) & (iad.abort_code ^= imft_et_$reply_pending) then do;
      701 						/* I/O error during read/write */
      702 			icri.record_type = IMFT_ABORT;
      703 			abort_command_ptr = icri.record_ptr;
      704 			abort_command.reason = IMFT_ABORT_IO_ERROR;
      705 			abort_command.code = iad.abort_code;
      706 			icri.record_lth = 4 * currentsize (abort_command);
      707 		     end;				/* let caller see exact error */
      708 
      709 		     else do;			/* encountered a control record: return it */
      710 			call timer_manager_$alarm_call (ONE_MINUTE, RELATIVE_SECONDS, read_write_timeout);
      711 			on condition (cleanup) call timer_manager_$reset_alarm_call (read_write_timeout);
      712 			call receive_logical_control_record (icri.record_ptr, icri.record_max_lth, icri.record_lth,
      713 			     icri.record_type, code);
      714 			call timer_manager_$reset_alarm_call (read_write_timeout);
      715 		     end;
      716 		end;
      717 
      718 		else code = error_table_$no_operation;	/* no abort was happening */
      719 	     end;
      720 	end;
      721 
      722 
      723 	else if order = "get_channel_names" then do;
      724 
      725 /* Return the names of the channels attached through this switch */
      726 
      727 	     if info_ptr = null () then code = error_table_$null_info_ptr;
      728 
      729 	     else if info_ptr -> get_channel_names.version ^= GET_CHANNEL_NAMES_VERSION_1 then
      730 		code = error_table_$unimplemented_version;
      731 
      732 	     else do;
      733 		get_channel_names_ptr = info_ptr;
      734 		local_tgci.version = tty_get_channel_info_version;
      735 
      736 		call iox_$control (iad.input_switch.terminal_iocb_ptr, "get_channel_info", addr (local_tgci), code);
      737 
      738 		if code = 0 then do;		/* got the input channel ... */
      739 		     get_channel_names.input_channel = local_tgci.channel_name;
      740 		     call iox_$control (iad.output_switch.terminal_iocb_ptr, "get_channel_info", addr (local_tgci),
      741 			code);
      742 		     if code = 0 then		/* ... and got the output channel */
      743 			get_channel_names.output_channel = local_tgci.channel_name;
      744 		end;
      745 
      746 		if code ^= 0 then			/* couldn't get one of the channel names */
      747 		     if code = error_table_$undefined_order_request then code = imft_et_$cant_get_channel_names;
      748 	     end;
      749 	end;
      750 
      751 
      752 	else if (order = "read_status") | (order = "resetread") then
      753 	     call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
      754 						/* always apply these to the input connection */
      755 
      756 	else if (order = "write_status") | (order = "resetwrite") | (order = "runout") then
      757 	     call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
      758 						/* always apply these to the output connection */
      759 
      760 	else if order = "abort" then do;		/* always apply this to both switches */
      761 	     call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
      762 	     call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
      763 	end;
      764 
      765 	else do;					/* pass others on to the appropriate half of the connection */
      766 	     if iad.input_direction then
      767 		call iox_$control (iad.input_switch.terminal_iocb_ptr, order, info_ptr, code);
      768 	     else call iox_$control (iad.output_switch.terminal_iocb_ptr, order, info_ptr, code);
      769 	end;
      770 
      771 RETURN_FROM_IMFT_CONTROL:
      772 	P_code = code;
      773 
      774 	return;
      775 
      776 /**/
      777 
      778 /* Internal procedure which is invoked when a read/write of a command/reply record times out */
      779 
      780 read_write_timeout:
      781      procedure ();
      782 
      783 	code = imft_et_$timeout;
      784 
      785 	if iad.debug_mode then			/* give the programmer a chance when debugging */
      786 	     signal condition (imft_debug_);
      787 
      788 	go to RETURN_FROM_IMFT_CONTROL;
      789 
      790      end read_write_timeout;
      791 
      792 /**/
      793 
      794 /* Change modes: no modes are supported */
      795 
      796 imft_io_modes:
      797      entry (P_iocb_ptr, P_new_modes, P_old_modes, P_code);
      798 
      799 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      800 	P_old_modes = "";				/* no modes are reflected to caller */
      801 
      802 	if P_new_modes = "" then
      803 	     P_code = 0;
      804 	else P_code = error_table_$bad_mode;
      805 
      806 	return;
      807 
      808 /**/
      809 
      810 /* Cleanup whatever portion of an attachment exists */
      811 
      812 cleanup_attachment:
      813      procedure (P_code);
      814 
      815 dcl  P_code fixed binary (35) parameter;		/* a parameter to allow callers to ignore it */
      816 
      817 	P_code = 0;
      818 
      819 	if iad_ptr ^= null () then do;		/* there is an I/O switch */
      820 
      821 	     if iad.input_switch.terminal_iocb_ptr ^= null () then do;
      822 		call iox_$close (iad.input_switch.terminal_iocb_ptr, (0));
      823 		call iox_$detach_iocb (iad.input_switch.terminal_iocb_ptr, P_code);
      824 		call iox_$destroy_iocb (iad.input_switch.terminal_iocb_ptr, (0));
      825 		iad.input_switch.terminal_iocb_ptr = null ();
      826 	     end;
      827 
      828 	     if iad.output_switch.terminal_iocb_ptr ^= null () then do;
      829 		call iox_$close (iad.output_switch.terminal_iocb_ptr, (0));
      830 		call iox_$detach_iocb (iad.output_switch.terminal_iocb_ptr, P_code);
      831 		call iox_$destroy_iocb (iad.output_switch.terminal_iocb_ptr, (0));
      832 		iad.output_switch.terminal_iocb_ptr = null ();
      833 	     end;
      834 
      835 	     free iad in (system_area);
      836 	     iad_ptr = null ();
      837 
      838 	end;
      839 
      840 	return;
      841 
      842      end cleanup_attachment;
      843 
      844 /**/
      845 
      846 /* Wrapper to protect against errors while IPS interrupts are masked */
      847 
      848 any_other_handler:
      849      procedure () options (non_quick);
      850 
      851 	if ips_mask then call hcs_$reset_ips_mask (ips_mask, ips_mask);
      852 	ips_mask = ""b;
      853 
      854 	call continue_to_signal_ ((0));		/* not interested, */
      855 
      856 	return;
      857 
      858      end any_other_handler;
      859 
      860 
      861 
      862 /* Abort a call to the attach entry:  print an error message if requested */
      863 
      864 abort_attachment:
      865      procedure () options (variable, non_quick);
      866 
      867 dcl  the_code fixed binary (35) based (the_code_ptr);
      868 dcl  the_code_ptr pointer;
      869 
      870 dcl  caller_message character (256);
      871 
      872 	call cu_$arg_ptr (1, the_code_ptr, (0), (0));
      873 
      874 	if loud_sw then do;				/* an error message is requested */
      875 	     call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, caller_message, (0), "1"b, "0"b);
      876 	     call com_err_ (the_code, IMFT_IO_, "For switch ^a: ^a", iocb_ptr -> iocb.name, caller_message);
      877 	end;
      878 
      879 	call cleanup_attachment ((0));		/* get rid of anything that was accomplished */
      880 
      881 	if the_code = 0 then
      882 	     code = error_table_$action_not_performed;
      883 	else code = the_code;			/* save the error code */
      884 
      885 	go to RETURN_FROM_ATTACH;
      886 
      887      end abort_attachment;
      888 
      889 /**/
      890 
      891 /* Fetch the next argument from the attach options and validate that it is a non-null character string */
      892 
      893 get_string_argument:
      894      procedure () returns (character (*));
      895 
      896 dcl  option_name character (32);
      897 
      898 	option_name = argument;			/* about to move on to the next one */
      899 
      900 	if argument_idx = hbound (P_attach_options, 1) then
      901 	     call abort_attachment (error_table_$noarg, "Character string following ""^a"".", option_name);
      902 
      903 	argument_idx = argument_idx + 1;
      904 
      905 	argument_ptr = substraddr (P_attach_options (argument_idx), 1);
      906 	argument_lth = length (P_attach_options (argument_idx));
      907 
      908 	if argument = "" then
      909 	     call abort_attachment (0, "Character string following ""^a"" must be non-null.", option_name);
      910 
      911 	return (argument);
      912 
      913      end get_string_argument;
      914 
      915 /**/
      916 
      917 /* Transmit a logical record to the remote system as multiple physical records */
      918 
      919 transmit_logical_record:
      920      procedure ();
      921 
      922 	return;					/* not an entry */
      923 
      924 
      925 /* Parameters */
      926 
      927 dcl  P_logical_record_type fixed binary (7) unaligned unsigned parameter;
      928 						/* type of record being transmitted */
      929 dcl  P_logical_record_data_ptr pointer parameter;		/* -> the logical record */
      930 dcl  P_logical_record_data_lth fixed binary (21) parameter; /* length of logical record in characters */
      931 
      932 dcl  P_code fixed binary (35) parameter;		/* control: status code */
      933 
      934 
      935 /* Remaining declarations */
      936 
      937 dcl  logical_record_data character (logical_record_data_lth) unaligned based (logical_record_data_ptr);
      938 dcl  logical_record_data_lth fixed binary (21);
      939 dcl  logical_record_data_ptr pointer;
      940 
      941 dcl  logical_record_data_bits bit (logical_record_data_n_bits) unaligned based (logical_record_data_ptr);
      942 dcl  logical_record_data_bits_lth fixed binary (24);
      943 
      944 dcl  bytes_array (n_bytes) bit (7) unaligned based (bytes_array_ptr);
      945 dcl  n_bytes fixed binary;
      946 dcl  bytes_array_ptr pointer;
      947 
      948 dcl  1 trsi aligned like tty_read_status_info automatic;
      949 
      950 dcl  put_chars_operation bit (1) aligned;		/* ON => iox_$put_chars (data records) */
      951 
      952 dcl  (amount_sent, amount_left) fixed binary (24);	/* may hold bit counters */
      953 dcl  amount_to_send fixed binary (14);
      954 dcl  fb14uu fixed binary (14) unaligned unsigned;
      955 
      956 dcl  based_character character (1) unaligned based;
      957 
      958 dcl  idx fixed binary;
      959 
      960 
      961 
      962 /* Transmit a data record: aborts by signalling imft_write_abort_ if an I/O error is encountered */
      963 
      964 transmit_logical_data_record:
      965      entry (P_logical_record_type, P_logical_record_data_ptr, P_logical_record_data_lth);
      966 
      967 	put_chars_operation = "1"b;
      968 	go to TRANSMIT_COMMON;
      969 
      970 
      971 /* Transmit a control record: any errors are reflected to the caller */
      972 
      973 transmit_logical_control_record:
      974      entry (P_logical_record_type, P_logical_record_data_ptr, P_logical_record_data_lth, P_code);
      975 
      976 	P_code = 0;
      977 	put_chars_operation = "0"b;
      978 
      979 
      980 TRANSMIT_COMMON:
      981 	if ^iad.input_direction then do;		/* output side: check for unexpected replies */
      982 	     trsi.input_pending = "0"b;		/* ... in case the next call fails */
      983 	     call iox_$control (iad.input_switch.terminal_iocb_ptr, "read_status", addr (trsi), (0));
      984 	     if trsi.input_pending then call abort_write_operation (imft_et_$reply_pending);
      985 	end;
      986 
      987 	logical_record_data_ptr = P_logical_record_data_ptr;
      988 	logical_record_data_lth = P_logical_record_data_lth;
      989 
      990 	terminal_io_record_ptr = addr (iad.output_switch.tior);
      991 	ipr_ptr = addr (terminal_io_record.data);
      992 
      993 	unspec (imft_physical_record) = ""b;		/* start out clean */
      994 
      995 	imft_physical_record.record_type = P_logical_record_type;
      996 
      997 	if logical_record_data_lth > 0 then
      998 	     imft_physical_record.binary = (verify (logical_record_data, collate ()) ^= 0);
      999 
     1000 	amount_sent = 0;
     1001 
     1002 
     1003 	if logical_record_data_lth = 0 then do;		/* empty record: transmit header only */
     1004 	     imft_physical_record.bolr,		/* this is the entire logical record */
     1005 		imft_physical_record.eolr = "1"b;
     1006 	     call transmit_physical_record ();
     1007 	end;
     1008 
     1009 
     1010 	else if imft_physical_record.binary then do;
     1011 
     1012 /* Binary data: unpack 7 bits at a time into 9 bit forming valid ASCII characters for transmission.  At some future time,
     1013*   support for binary transmission should be provided */
     1014 
     1015 	     logical_record_data_bits_lth = N_BITS_PER_CHARACTER * logical_record_data_lth;
     1016 
     1017 	     do while (amount_sent < logical_record_data_bits_lth);
     1018 
     1019 		amount_left = logical_record_data_bits_lth - amount_sent;
     1020 		amount_to_send = min (amount_left, IMFT_PHYSICAL_RECORD_DATA_BITS_LTH);
     1021 						/* are using 7 bits per character */
     1022 
     1023 		n_bytes = divide (amount_to_send + 6, 7, 17, 0);
     1024 		bytes_array_ptr = add_bit_offset_ (logical_record_data_ptr, (amount_sent));
     1025 						/* first bit to go into this record */
     1026 		do idx = 1 to n_bytes;
     1027 		     if idx = n_bytes then		/* special case last byte */
     1028 			if mod (amount_to_send, 7) ^= 0 then
     1029 			     unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
     1030 				"00"b || substr (bytes_array (idx), 1, mod (amount_to_send, 7));
     1031 			else unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
     1032 				"00"b || bytes_array (idx);
     1033 		     else unspec (substraddr (imft_physical_record.data, (idx)) -> based_character) =
     1034 			     "00"b || bytes_array (idx);
     1035 		end;
     1036 
     1037 		fb14uu = amount_to_send;		/* record # of bits transmitted */
     1038 		imft_physical_record.n_els.high_order = substr (unspec (fb14uu), 1, 7);
     1039 		imft_physical_record.n_els.low_order = substr (unspec (fb14uu), 8, 7);
     1040 
     1041 		if amount_sent = 0 then		/* first physical record of logical record */
     1042 		     imft_physical_record.bolr = "1"b;
     1043 		if amount_to_send = amount_left then	/* last physical record */
     1044 		     imft_physical_record.eolr = "1"b;
     1045 
     1046 		call transmit_physical_record ();	/* zap! */
     1047 
     1048 		amount_sent = amount_sent + amount_to_send;
     1049 	     end;
     1050 	end;
     1051 
     1052 
     1053 	else do;
     1054 
     1055 /* Character only data */
     1056 
     1057 	     do while (amount_sent < logical_record_data_lth);
     1058 
     1059 		amount_left = logical_record_data_lth - amount_sent;
     1060 		amount_to_send = min (amount_left, IMFT_PHYSICAL_RECORD_DATA_LTH);
     1061 						/* determine how much to send now */
     1062 		imft_physical_record.data = substr (logical_record_data, (amount_sent + 1), amount_to_send);
     1063 
     1064 		fb14uu = amount_to_send;		/* put # of characters in record into the record */
     1065 		imft_physical_record.n_els.high_order = substr (unspec (fb14uu), 1, 7);
     1066 		imft_physical_record.n_els.low_order = substr (unspec (fb14uu), 8, 7);
     1067 
     1068 		if amount_sent = 0 then		/* first physical record of logical one */
     1069 		     imft_physical_record.bolr = "1"b;
     1070 		if amount_to_send = amount_left then	/* last physical record */
     1071 		     imft_physical_record.eolr = "1"b;
     1072 
     1073 		call transmit_physical_record ();	/* zap! */
     1074 
     1075 		amount_sent = amount_sent + amount_to_send;
     1076 	     end;
     1077 	end;
     1078 
     1079 	if ^put_chars_operation then			/* here iff all written OK */
     1080 	     P_code = 0;
     1081 
     1082 RETURN_FROM_TRANSMIT_LOGICAL_RECORD:
     1083 	return;
     1084 
     1085 
     1086 
     1087 /* Internal to transmit_logical_record: transmits a single physical record to the remote system */
     1088 
     1089 transmit_physical_record:
     1090 	procedure ();
     1091 
     1092 dcl  saved_record_type fixed binary;
     1093 dcl  saved_binary_flag bit (1) aligned;
     1094 dcl  code fixed binary (35);
     1095 
     1096 	     saved_record_type = imft_physical_record.record_type;
     1097 	     saved_binary_flag = imft_physical_record.binary;
     1098 
     1099 	     terminal_io_record.element_size = 9;
     1100 	     terminal_io_record.n_elements = IMFT_PHYSICAL_RECORD_LTH;
     1101 						/* make sure they're still correct */
     1102 
     1103 	     call iox_$write_record (iad.output_switch.terminal_iocb_ptr, terminal_io_record_ptr,
     1104 		(4 * currentsize (terminal_io_record)), code);
     1105 	     if code ^= 0 then call abort_write_operation (code);
     1106 
     1107 	     unspec (imft_physical_record) = ""b;	/* start next record clean */
     1108 	     imft_physical_record.record_type = saved_record_type;
     1109 	     imft_physical_record.binary = saved_binary_flag;
     1110 
     1111 	     return;				/* it won */
     1112 
     1113 	end transmit_physical_record;
     1114 
     1115 
     1116 
     1117 /* Internal to transmit_logical_record: aborts the current write operation */
     1118 
     1119 abort_write_operation:
     1120 	procedure (p_code);
     1121 
     1122 dcl  p_code fixed binary (35) parameter;
     1123 
     1124 	     if put_chars_operation then do;		/* data stream: abort the operation completely */
     1125 		iad.abort_in_progress = "1"b;
     1126 		iad.abort_code = p_code;
     1127 SIGNAL_TRANSMISSION_FAILURE_FOREVER:
     1128 		signal condition (imft_write_abort_);
     1129 		go to SIGNAL_TRANSMISSION_FAILURE_FOREVER;
     1130 	     end;					/* imft_transmit_object_ shouldn't return */
     1131 
     1132 	     else do;				/* writing a control record: reflect error to caller */
     1133 		P_code = p_code;
     1134 		go to RETURN_FROM_TRANSMIT_LOGICAL_RECORD;
     1135 	     end;
     1136 
     1137 	end abort_write_operation;
     1138 
     1139      end transmit_logical_record;
     1140 
     1141 /**/
     1142 
     1143 /* Receive the contents of a logical record from the remote system */
     1144 
     1145 receive_logical_record:
     1146      procedure ();
     1147 
     1148 	return;					/* not an entry */
     1149 
     1150 dcl  P_buffer_ptr pointer parameter;			/* -> buffer to place record contents */
     1151 dcl  P_buffer_max_lth fixed binary (21) parameter;	/* maximum size of buffer (in characters) */
     1152 dcl  P_buffer_used fixed binary (21) parameter;		/* # of characters placed into buffer */
     1153 
     1154 dcl  P_record_type fixed binary parameter;		/* control: set to type of control record found */
     1155 dcl  P_code fixed binary (35) parameter;		/* control: status cod */
     1156 
     1157 
     1158 /* Remaining declarations */
     1159 
     1160 dcl  buffer bit (buffer_max_lth) unaligned based (buffer_ptr);
     1161 dcl  (buffer_used, buffer_max_lth) fixed binary (24);
     1162 dcl  buffer_ptr pointer;
     1163 
     1164 dcl  buffer_as_chars character (P_buffer_max_lth) unaligned based (buffer_ptr);
     1165 
     1166 dcl  1 byte_structure aligned,
     1167        2 pad bit (2) unaligned,
     1168        2 byte bit (7) unaligned;
     1169 
     1170 dcl  get_chars_operation bit (1) aligned;		/* ON => reading data stream */
     1171 dcl  continue bit (1) aligned;
     1172 
     1173 dcl  (space_left, amount_left, amount_to_copy, amount_done) fixed binary (24);
     1174 dcl  (characters_used, characters_to_copy) fixed binary (21);
     1175 dcl  byte_idx fixed binary (21);
     1176 dcl  n_bits_from_byte fixed binary;
     1177 
     1178 
     1179 
     1180 /* Receive data records: aborts by signalling imft_read_abort_ if an I/O error is encountered or the previous read
     1181*   operation terminated with a control record */
     1182 
     1183 receive_logical_data_records:
     1184      entry (P_buffer_ptr, P_buffer_max_lth, P_buffer_used);
     1185 
     1186 	get_chars_operation = "1"b;
     1187 	go to RECEIVE_COMMON;
     1188 
     1189 
     1190 /* Receive a control record: flushes all data records until a control record is found and returned */
     1191 
     1192 receive_logical_control_record:
     1193      entry (P_buffer_ptr, P_buffer_max_lth, P_buffer_used, P_record_type, P_code);
     1194 
     1195 	P_record_type = -1;				/* haven't found it yet */
     1196 	P_code = 0;
     1197 	get_chars_operation = "0"b;
     1198 
     1199 
     1200 RECEIVE_COMMON:
     1201 	buffer_ptr = P_buffer_ptr;
     1202 	buffer_max_lth = N_BITS_PER_CHARACTER * P_buffer_max_lth;
     1203 
     1204 	buffer_used = 0;
     1205 
     1206 	terminal_io_record_ptr = addr (iad.input_switch.tior);
     1207 	ipr_ptr = addr (terminal_io_record.data);
     1208 
     1209 
     1210 	continue = "1"b;
     1211 
     1212 	do while (continue);
     1213 
     1214 	     if iad.input_switch.current_physical_record_type = -1 then
     1215 READ_ANOTHER_RECORD:
     1216 		call receive_physical_record ();
     1217 
     1218 	     if iad.input_switch.current_physical_record_type = IMFT_DATA then
     1219 		if get_chars_operation then
     1220 		     ;				/* data record OK */
     1221 		else go to READ_ANOTHER_RECORD;	/* data records should be ignored */
     1222 
     1223 	     else					/* control record ... */
     1224 		if get_chars_operation then		/* ... while reading data ... */
     1225 		if buffer_used = 0 then		/* ... is only fatal if first read */
     1226 		     call abort_read_operation (0);
     1227 		else go to END_OF_GET_CHARS;		/* in middle of stream: end of get_chars */
     1228 
     1229 	     if ^get_chars_operation then		/* if reading control records ... */
     1230 		if P_record_type = -1 then		/* ... and haven't determined type yet */
     1231 		     P_record_type = iad.input_switch.current_physical_record_type;
     1232 
     1233 
     1234 	     if iad.input_switch.current_physical_record_n_els = 0 then ;
     1235 						/* nothing in this record to unpack or copy */
     1236 
     1237 
     1238 	     else if imft_physical_record.binary then do;
     1239 
     1240 /* Binary data: pack low order 7-bits of each character into the caller's buffer as a continuous bit stream */
     1241 
     1242 		if buffer_used < buffer_max_lth then do;
     1243 
     1244 		     space_left = buffer_max_lth - buffer_used;
     1245 		     amount_left =
     1246 			iad.input_switch.current_physical_record_n_els
     1247 			- iad.input_switch.current_physical_record_used;
     1248 		     amount_to_copy = min (space_left, amount_left);
     1249 
     1250 		     amount_done = 0;
     1251 		     do while (amount_done < amount_to_copy);
     1252 			byte_idx = divide (iad.input_switch.current_physical_record_used, 7, 17, 0) + 1;
     1253 			n_bits_from_byte = min ((amount_to_copy - amount_done), 7);
     1254 			unspec (byte_structure) = unspec (substr (imft_physical_record.data, byte_idx, 1));
     1255 			substr (buffer, (buffer_used + 1), n_bits_from_byte) =
     1256 			     substr (byte_structure.byte,
     1257 			     (mod (iad.input_switch.current_physical_record_used, 7) + 1), n_bits_from_byte);
     1258 			buffer_used = buffer_used + n_bits_from_byte;
     1259 			iad.input_switch.current_physical_record_used =
     1260 			     iad.input_switch.current_physical_record_used + n_bits_from_byte;
     1261 			amount_done = amount_done + n_bits_from_byte;
     1262 		     end;
     1263 		end;
     1264 	     end;
     1265 
     1266 
     1267 	     else do;
     1268 
     1269 /* Character data: copy it to caller's buffer */
     1270 
     1271 		call adjust_buffer_used ();		/* make sure it's integral # of characters */
     1272 		characters_used = divide ((buffer_used + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);
     1273 
     1274 		if buffer_used < buffer_max_lth then do;
     1275 		     space_left = buffer_max_lth - buffer_used;
     1276 		     amount_left =
     1277 			N_BITS_PER_CHARACTER
     1278 			* (iad.input_switch.current_physical_record_n_els
     1279 			- iad.input_switch.current_physical_record_used);
     1280 		     amount_to_copy = min (space_left, amount_left);
     1281 		     characters_to_copy =
     1282 			divide ((amount_to_copy + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);
     1283 		     substr (buffer_as_chars, (characters_used + 1), characters_to_copy) =
     1284 			substr (imft_physical_record.data, (iad.input_switch.current_physical_record_used + 1),
     1285 			characters_to_copy);
     1286 		     buffer_used = buffer_used + amount_to_copy;
     1287 		     iad.input_switch.current_physical_record_used =
     1288 			iad.input_switch.current_physical_record_used + characters_to_copy;
     1289 		end;
     1290 	     end;
     1291 
     1292 	     if iad.input_switch.current_physical_record_used >= iad.input_switch.current_physical_record_n_els then
     1293 		iad.input_switch.current_physical_record_type = -1;
     1294 
     1295 	     if ^get_chars_operation & imft_physical_record.eolr then continue = "0"b;
     1296 						/* got it all */
     1297 
     1298 	     continue = continue & (buffer_used < buffer_max_lth);
     1299 	end;
     1300 
     1301 END_OF_GET_CHARS:
     1302 	call adjust_buffer_used ();			/* make sure it's integral # of characters */
     1303 	P_buffer_used = divide ((buffer_used + N_BITS_PER_CHARACTER - 1), N_BITS_PER_CHARACTER, 21, 0);
     1304 
     1305 
     1306 RETURN_FROM_RECEIVE_LOGICAL_RECORD:
     1307 	return;
     1308 
     1309 
     1310 
     1311 /* Internal to receive_logical_record: receives a single physical record */
     1312 
     1313 receive_physical_record:
     1314 	procedure ();
     1315 
     1316 dcl  fb14uu fixed binary (14) unaligned unsigned;
     1317 dcl  code fixed binary (35);
     1318 
     1319 	     terminal_io_record.element_size = 9;
     1320 	     terminal_io_record.n_elements = IMFT_PHYSICAL_RECORD_LTH;
     1321 
     1322 	     call iox_$read_record (iad.input_switch.terminal_iocb_ptr, terminal_io_record_ptr,
     1323 		(4 * currentsize (terminal_io_record)), (0), code);
     1324 	     if code ^= 0 then call abort_read_operation (code);
     1325 
     1326 	     if terminal_io_record.n_elements ^= IMFT_PHYSICAL_RECORD_LTH then
     1327 		call abort_read_operation (error_table_$short_record);
     1328 
     1329 	     iad.input_switch.current_physical_record_type = imft_physical_record.record_type;
     1330 
     1331 	     unspec (fb14uu) = imft_physical_record.n_els.high_order || imft_physical_record.n_els.low_order;
     1332 	     iad.input_switch.current_physical_record_n_els = fb14uu;
     1333 						/* record # of characters or bytes */
     1334 
     1335 	     iad.input_switch.current_physical_record_used = 0;
     1336 						/* haven't taken any */
     1337 
     1338 	     if imft_physical_record.bolr & ^get_chars_operation then
     1339 		if buffer_used ^= 0 then		/* missed end of control record */
     1340 		     call abort_read_operation (error_table_$improper_data_format);
     1341 
     1342 	     return;
     1343 
     1344 	end receive_physical_record;
     1345 
     1346 
     1347 
     1348 /* Internal to receive_logical_record: aborts the current read operation */
     1349 
     1350 abort_read_operation:
     1351 	procedure (p_code);
     1352 
     1353 dcl  p_code fixed binary (35) parameter;
     1354 
     1355 	     if get_chars_operation then do;		/* get_chars (data stream): signal imft_read_abort_ */
     1356 		iad.abort_in_progress = "1"b;
     1357 		iad.abort_code = p_code;
     1358 SIGNAL_RECEIVE_FAILURE_FOREVER:
     1359 		signal condition (imft_read_abort_);
     1360 		go to SIGNAL_RECEIVE_FAILURE_FOREVER;
     1361 	     end;
     1362 
     1363 	     else do;				/* reading control record: return code to caller */
     1364 		P_code = p_code;
     1365 		go to RETURN_FROM_RECEIVE_LOGICAL_RECORD;
     1366 	     end;
     1367 
     1368 	end abort_read_operation;
     1369 
     1370 
     1371 
     1372 /* Internal to receive_logical_record: adjusts buffer_used to be an integral # of characters */
     1373 
     1374 adjust_buffer_used:
     1375 	procedure ();
     1376 
     1377 dcl  n_bits_to_zero fixed binary;
     1378 
     1379 	     if mod (buffer_used, N_BITS_PER_CHARACTER) ^= 0 then do;
     1380 
     1381 		n_bits_to_zero = N_BITS_PER_CHARACTER - mod (buffer_used, N_BITS_PER_CHARACTER);
     1382 
     1383 		substr (buffer, (buffer_used + 1), n_bits_to_zero) = ""b;
     1384 						/* insure no garbage in buffer */
     1385 		buffer_used = buffer_used + n_bits_to_zero;
     1386 	     end;
     1387 
     1388 	     return;
     1389 
     1390 	end adjust_buffer_used;
     1391 
     1392      end receive_logical_record;
     1393 
     1394 /**/
     1395 
     1396 /* substraddr:  Return a pointer to the specified character of a varying or nonvarying string.  When the substraddr
     1397*   builtin function is finally implemented, these internal procedures should be removed */
     1398 
     1399 dcl  substraddr
     1400 	generic (substraddr_nonvarying when (character (*) nonvarying, fixed binary precision (1:35)),
     1401 	substraddr_varying when (character (*) varying, fixed binary precision (1:35)));
     1402 
     1403 
     1404 substraddr_nonvarying:
     1405      procedure (P_string, P_position) returns (pointer);
     1406 
     1407 dcl  P_string character (*) nonvarying parameter;
     1408 dcl  P_position fixed binary (21) parameter;
     1409 
     1410 dcl  string_overlay (length (P_string)) character (1) unaligned based (addr (P_string));
     1411 
     1412 	return (addr (string_overlay (P_position)));
     1413 
     1414      end substraddr_nonvarying;
     1415 
     1416 
     1417 substraddr_varying:
     1418      procedure (P_string, P_position) returns (pointer);
     1419 
     1420 dcl  P_string character (*) varying parameter;
     1421 dcl  P_position fixed binary (21) parameter;
     1422 
     1423 dcl  1 string_overlay aligned based (addr (P_string)),
     1424        2 lth fixed binary (21),
     1425        2 characters (0 refer (string_overlay.lth)) character (1) unaligned;
     1426 
     1427 	return (addr (string_overlay.characters (P_position)));
     1428 
     1429      end substraddr_varying;
     1430 
     1431 /**/
     1432 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     3*      version number to IOX2. */
  1     4 /* format: style2 */
  1     5 
  1     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     7 	     2 version	      character (4) aligned,	/* IOX2 */
  1     8 	     2 name	      char (32),		/* I/O name of this block. */
  1     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    17 						/* open(p,mode,not_used,s) */
  1    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    24 						/* put_chars(p,bufptr,buflen,s) */
  1    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    26 						/* modes(p,newmode,oldmode,s) */
  1    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    28 						/* position(p,u1,u2,s) */
  1    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    30 						/* control(p,order,infptr,s) */
  1    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* write_record(p,bufptr,buflen,s) */
  1    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    36 						/* rewrite_record(p,bufptr,buflen,s) */
  1    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* seek_key(p,key,len,s) */
  1    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    41 						/* read_key(p,key,len,s) */
  1    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  1    43 						/* read_length(p,len,s) */
  1    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    45 						/* open_file(p,mode,desc,not_used,s) */
  1    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    47 						/* close_file(p,desc,s) */
  1    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  1    49 						/* detach(p,desc,s) */
  1    50 
  1    51      declare iox_$iocb_version_sentinel
  1    52 			      character (4) aligned external static;
  1    53 
  1    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1433 
     1434 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
     1435 
     1436 
  3     1 /* BEGIN INCLUDE FILE ... terminal_io_record.incl.pl1 */
  3     2 /* Created:  November 1979 by G. Palter */
  3     3 /* Modified: 26 March 1982 by G. Palter to make the structure more compatible with use of the like attribute */
  3     4 
  3     5 
  3     6 /* Record format used by I/O modules designed for communcation with remote I/O daemon stations */
  3     7 
  3     8 dcl 1 terminal_io_record aligned based (terminal_io_record_ptr),
  3     9       2 header,
  3    10         3 version fixed binary,
  3    11         3 device_type fixed binary,			/* type of device sending/receiving this record --
  3    12*						   reader/printer/punch/teleprinter */
  3    13         3 slew_control,				/* slew control data: used for printer and teleprinter only */
  3    14 	4 slew_type fixed binary (18) unaligned unsigned,	/* type of slewing operation before/after this line --
  3    15*						   by-count/top-of-form/inside-page/outside-page/to-channel */
  3    16 	4 slew_count fixed binary (18) unaligned unsigned,/* # of lines if by count; channel # if to channel */
  3    17         3 flags,
  3    18 	4 binary bit (1) unaligned,			/* ON => data in record should be written in binary mode */
  3    19 	4 preslew bit (1) unaligned,			/* ON => perform above slew before printing data;
  3    20*						   OFF => perform above slew after printing data */
  3    21 	4 pad bit (34) unaligned,
  3    22         3 element_size fixed binary,			/* # of bits in a data element */
  3    23         3 n_elements fixed binary (24),			/* # of elements in the record */
  3    24       2 data,					/* force word alignment */
  3    25         3 bits (terminal_io_record_n_elements refer (terminal_io_record.n_elements))
  3    26 	  bit (terminal_io_record_element_size refer (terminal_io_record.element_size)) unaligned;
  3    27 
  3    28 dcl  terminal_io_record_ptr pointer;
  3    29 
  3    30 dcl  terminal_io_record_element_size fixed binary;	/* used for allocating terminal_io_record structures */
  3    31 dcl  terminal_io_record_n_elements fixed binary (24);
  3    32 
  3    33 
  3    34 /* Manifest constants */
  3    35 
  3    36 dcl  terminal_io_record_version_1 fixed binary static options (constant) initial (1);
  3    37 
  3    38 dcl (TELEPRINTER_DEVICE	initial (1),
  3    39      READER_DEVICE		initial (2),
  3    40      PRINTER_DEVICE		initial (3),
  3    41      PUNCH_DEVICE		initial (4))
  3    42 	fixed binary static options (constant);
  3    43 
  3    44 dcl (SLEW_BY_COUNT		initial (1),
  3    45      SLEW_TO_TOP_OF_PAGE	initial (2),
  3    46      SLEW_TO_INSIDE_PAGE	initial (3),		/* skip to top of next inside page (head sheet) */
  3    47      SLEW_TO_OUTSIDE_PAGE	initial (4),		/* skip to top of next outside page (tail sheet) */
  3    48      SLEW_TO_CHANNEL	initial (5))		/* skip to specified channel stop */
  3    49 	fixed binary static options (constant);
  3    50 
  3    51 
  3    52 /* Data in record as a character string (terminal_io_record.element_size = 9) */
  3    53 
  3    54 dcl  terminal_io_record_data_chars character (terminal_io_record.n_elements) unaligned
  3    55 	based (addr (terminal_io_record.bits));
  3    56 
  3    57 dcl  terminal_io_record_data_chars_varying_max_len fixed binary (21);  /* Set this before using the varying string. */
  3    58 dcl  terminal_io_record_data_chars_varying character (terminal_io_record_data_chars_varying_max_len) varying
  3    59 	based (addr (terminal_io_record.n_elements));	/* varying string consists of length and data */
  3    60 
  3    61 
  3    62 /* Data in record as a bit string (terminal_io_record.element_size = 1) */
  3    63 
  3    64 dcl terminal_io_record_data_bits bit (terminal_io_record.n_elements) unaligned based (addr (terminal_io_record.bits));
  3    65 
  3    66 /* END INCLUDE FILE ... terminal_io_record.incl.pl1 */
     1437 
     1438 
  4     1 /* BEGIN INCLUDE FILE ... tty_read_status_info.incl.pl1
  4     2*
  4     3*   control structure for the read_status and write_status orders to tty_
  4     4*
  4     5*   Modified 2/1/83 by Olin Sibert to add tty_write_status_info structure in
  4     6*     support of lap_simplex_ MPX.
  4     7**/
  4     8 
  4     9 
  4    10 /****^  HISTORY COMMENTS:
  4    11*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
  4    12*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
  4    13*     Prepared for installation.
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 
  4    17      dcl	   1 tty_read_status_info aligned based (tty_read_status_info_ptr),
  4    18 	     2 event_channel      fixed bin (71),
  4    19 	     2 input_pending      bit (1);
  4    20 
  4    21      dcl	   tty_read_status_info_ptr ptr;
  4    22 
  4    23      dcl	   1 tty_write_status_info aligned based (tty_write_status_info_ptr),
  4    24 	     2 event_channel      fixed bin (71),
  4    25 	     2 output_pending     bit (1);
  4    26 
  4    27      dcl	   tty_write_status_info_ptr ptr;
  4    28 
  4    29 /* END INCLUDE FILE ... tty_read_status_info.incl.pl1 */
     1439 
     1440 
  5     1 /* BEGIN INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
  5     2 
  5     3 /* for get_channel_info order to tty_ */
  5     4 
  5     5      dcl	   1 tty_get_channel_info aligned based,
  5     6 	     2 version	      fixed bin init (tty_get_channel_info_version),
  5     7 	     2 devx	      fixed bin,
  5     8 	     2 channel_name	      char (32);
  5     9 
  5    10      dcl	   tty_get_channel_info_version fixed bin init (1) internal static options (constant);
  5    11 
  5    12 /* END INCLUDE FILE ... tty_get_channel_info.incl.pl1 */
     1441 
     1442 
  6     1 /* BEGIN INCLUDE FILE ... _imft_cri.incl.pl1 */
  6     2 /* Created:  April 1982 by G. Palter */
  6     3 
  6     4 /* Data structure used by read/write_command/reply_record and get_abort_info control orders */
  6     5 
  6     6 dcl  1 icri aligned based (icri_ptr),
  6     7        2 version character (8),
  6     8        2 timeout fixed binary (35),			/* # of seconds to wait for read/write to complete */
  6     9        2 pad bit (36),
  6    10        2 record_info,
  6    11          3 record_ptr pointer,			/* -> record to write or buffer where it will be read */
  6    12          3 record_type fixed binary,			/* type of record read/written */
  6    13          3 record_max_lth fixed binary (21),		/* size of buffer when reading records */
  6    14          3 record_lth fixed binary (21);		/* length of record read/written in characters */
  6    15 
  6    16 dcl  icri_ptr pointer;
  6    17 
  6    18 dcl  ICRI_VERSION_1 character (8) static options (constant) initial ("cri_1.00");
  6    19 
  6    20 /* END INCLUDE FILE ... _imft_cri.incl.pl1 */
     1443 
     1444 
  7     1 /* ***********************************************************
  7     2*   *                                                         *
  7     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  7     4*   *                                                         *
  7     5*   *********************************************************** */
  7     6 /* BEGIN INCLUDE FILE ... _imft_get_channel_names.incl.pl1 */
  7     7 /* Created:  July 1982 by G. Palter */
  7     8 
  7     9 /* Data structure used by imft_io_ to return names of channels used for data transmission */
  7    10 
  7    11 dcl  1 get_channel_names aligned based (get_channel_names_ptr),
  7    12        2 version character (8),
  7    13        2 input_channel character (32) unaligned,
  7    14        2 output_channel character (32) unaligned;
  7    15 
  7    16 dcl  get_channel_names_ptr pointer;
  7    17 
  7    18 dcl  GET_CHANNEL_NAMES_VERSION_1 character (8) static options (constant) initial ("igcn_001");
  7    19 
  7    20 /* END INCLUDE FILE ... _imft_get_channel_names.incl.pl1 */
     1445 
     1446 
  8     1 /* BEGIN INCLUDE FILE ... _imft_std_commands.incl.pl1 */
  8     2 
  8     3 /* Created:  April 1982 by G. Palter */
  8     4 /* Modified: July 1982 by G. Palter to add true AIM support */
  8     5 /* Modified: March 1983 by Robert Coren to add local_io_error abort code */
  8     6 /* Modified: August 1983 by Robert Coren to add access_floor to AIM2 record */
  8     7 
  8     8 
  8     9 /****^  HISTORY COMMENTS:
  8    10*  1) change(88-08-12,Beattie), approve(88-08-01,MCR7948),
  8    11*     audit(88-10-14,Farley), install(88-10-14,MR12.2-1165):
  8    12*     Add imft_version to sync_record structure to inform other driver of this
  8    13*     driver's version of the IMFT software.
  8    14*                                                   END HISTORY COMMENTS */
  8    15 
  8    16 
  8    17 /* Standard command and reply control records used by IMFT drivers */
  8    18 
  8    19 
  8    20 /* Standard command/reply types */
  8    21 
  8    22 dcl (IMFT_DATA		initial (0),		/* data record */
  8    23      IMFT_SYNC1		initial (1),		/* first half of synchronization sequence */
  8    24      IMFT_SYNC2		initial (2),		/* second half of synchronization sequence */
  8    25      IMFT_ABORT		initial (3),		/* abort the current operation */
  8    26      IMFT_LOGOUT		initial (4),		/* one side requests that the other logout */
  8    27      IMFT_RESYNCHRONIZE	initial (5),		/* reply requesting resynchronization */
  8    28      IMFT_AIM1		initial (6),		/* first half of establsihing AIM ceiling */
  8    29      IMFT_AIM2		initial (7))		/* second half of establishing AIM ceiling */
  8    30 	fixed binary (7) unaligned unsigned static options (constant);
  8    31 
  8    32 
  8    33 /* Synchronization control record: sent as the SYNC1 command and reply and as the SYNC2 command; the SYNC2 reply is a
  8    34*   zero-length record which is only sent if the SYNC2 command indicates success */
  8    35 
  8    36 dcl  1 sync_record aligned based (sync_record_ptr),
  8    37        2 my_userid character (32),			/* Person_id of system sending this record */
  8    38        2 my_password character (8),			/* scrambled card input passowrd */
  8    39        2 code fixed binary (35),			/* non-zero code => validation failed; break the connection */
  8    40        2 correct_userid character (32),			/* Person_id that was expected if incorrect */
  8    41        2 imft_version character (8);			/* version of IMFT being used by driver */
  8    42 
  8    43 dcl  sync_record_ptr pointer;
  8    44 
  8    45 
  8    46 /* Abort command record */
  8    47 
  8    48 dcl  1 abort_command aligned based (abort_command_ptr),
  8    49        2 reason fixed binary,				/* reason to abort this operation */
  8    50        2 code fixed binary (35);			/* real error code for an I/O error */
  8    51 
  8    52 dcl  abort_command_ptr pointer;
  8    53 
  8    54 dcl (IMFT_ABORT_IO_ERROR	initial (1),		/* I/O error */
  8    55      IMFT_ABORT_ABORTED	initial (2),		/* random fault */
  8    56      IMFT_ABORT_DEFERRED	initial (3),		/* operator deferred request */
  8    57      IMFT_ABORT_CANCELLED	initial (4),		/* operator cancelled request */
  8    58      IMFT_ABORT_SAVED	initial (5),		/* operator saved the request silently */
  8    59      IMFT_ABORT_RESTARTED	initial (6),		/* operator restarted the request */
  8    60      IMFT_ABORT_LOCAL_IO_ERROR initial (7))		/* I/O error on local system */
  8    61 	fixed binary static options (constant);
  8    62 
  8    63 
  8    64 /* AIM ceiling control records: the AIM1 command and reply are the aim_attributes structures defining the attributes on
  8    65*   the system; the AIM2 command/reply record follows */
  8    66 
  8    67 dcl  1 aim2_record aligned based (aim2_record_ptr),
  8    68        2 code fixed binary (35),			/* non-zero => AIM ceiling can not be established */
  8    69        2 computed_ceiling bit (72),			/* ceiling computed by other system (before translation) */
  8    70        2 computed_floor bit (72),			/* floor computed by other system (before translation) */
  8    71        2 flags unaligned,
  8    72          3 explicit_ceiling_given bit (1),		/* ON => an explicit access ceiling follows */
  8    73          3 explicit_floor_given bit (1),		/* ON => an explicit access floor follows */
  8    74          3 pad bit (34),
  8    75        2 explicit_ceiling bit (72),			/* the explicitly requested ceiling (before translation) */
  8    76        2 explicit_floor bit (72);			/* the explicitly requested floor (before translation) */
  8    77 
  8    78 /* The following version of the structure is used for pre-version 3.0 IMFT */
  8    79 
  8    80 dcl  1 v2_aim2_record aligned based (aim2_record_ptr),
  8    81        2 code fixed binary (35),			/* non-zero => AIM ceiling can not be established */
  8    82        2 computed_ceiling bit (72),			/* ceiling computed by other system (before translation) */
  8    83        2 explicit_ceiling_given bit (1),		/* ON => an explicit access ceiling follows */
  8    84        2 explicit_ceiling bit (72);			/* the explicitly requested ceiling (before translation) */
  8    85 
  8    86 dcl  aim2_record_ptr pointer;
  8    87 
  8    88 /* END INCLUDE FILE ... _imft_std_commands.incl.pl1 */
     1447 
     1448 
     1449      end old_imft_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/14/88  1214.6  old_imft_io_.pl1                  >special_ldd>install>MR12.2-1165>old_imft_io_.pl1
1433         1    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
1435         2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1437         3    11/12/82  1624.8  terminal_io_record.incl.pl1       >ldd>include>terminal_io_record.incl.pl1
1439         4    08/11/88  2015.0  tty_read_status_info.incl.pl1     >ldd>include>tty_read_status_info.incl.pl1
1441         5    01/28/81  0923.4  tty_get_channel_info.incl.pl1     >ldd>include>tty_get_channel_info.incl.pl1
1443         6    05/28/82  1334.9  _imft_cri.incl.pl1                >ldd>include>_imft_cri.incl.pl1
1445         7    09/30/82  2011.0  _imft_get_channel_names.incl.pl1  >ldd>include>_imft_get_channel_names.incl.pl1
1447         8    10/14/88  1212.4  _imft_std_commands.incl.pl1       >special_ldd>install>MR12.2-1165>_imft_std_commands.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
GET_CHANNEL_NAMES_VERSION_1     000000 constant        char(8)                  initial packed unaligned dcl 7-18 ref 729
ICRI_VERSION_1                  000002 constant        char(8)                  initial packed unaligned dcl 6-18 ref 597 620 645
                                                                                  668 692
IMFT_ABORT                             constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22 ref 702
IMFT_ABORT_IO_ERROR                    constant        fixed bin(17,0)          initial dcl 8-54 ref 704
IMFT_DATA                       000122 constant        fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22 set ref
                                                                                  544* 1218
IMFT_IO_                        000125 constant        char(32)                 initial packed unaligned dcl 92 set ref 224* 288 311
                                                                                  323 876*
IMFT_PHYSICAL_RECORD_DATA_BITS_LTH     constant        fixed bin(17,0)          initial dcl 203 ref 1020
IMFT_PHYSICAL_RECORD_DATA_LTH          constant        fixed bin(17,0)          initial dcl 203 ref 993 1027 1027 1031 1031 1033
                                                                                  1033 1060 1062 1107 1254 1283
IMFT_PHYSICAL_RECORD_LTH               constant        fixed bin(17,0)          initial dcl 203 ref 239 239 240 246 246 274 274 306
                                                                                  306 332 337 338 339 341 344 346 347 349 351 352
                                                                                  352 354 354 355 355 396 396 396 396 405 419 419
                                                                                  455 539 539 564 564 599 599 622 622 647 647 670
                                                                                  670 697 697 698 698 700 700 700 700 705 705 740
                                                                                  756 762 766 766 768 785 785 828 829 830 831 832
                                                                                  835 835 980 980 990 1100 1103 1125 1125 1126 1126
                                                                                  1320 1326 1356 1356 1357 1357
N_BITS_PER_CHARACTER            010325 constant        fixed bin(17,0)          initial dcl 94 ref 351 1015 1202 1272 1272 1276 1281
                                                                                  1281 1303 1303 1379 1381 1381
ONE_MINUTE                      000122 constant        fixed bin(71,0)          initial dcl 97 set ref 710*
PUNCH_DEVICE                           constant        fixed bin(17,0)          initial dcl 3-38 ref 344
P_attach_options                       parameter       varying char             array dcl 28 set ref 213 235 252 252 254* 255 293*
                                                                                  294 298* 299 314 316* 326 328* 900 905* 906
P_buffer_max_lth                       parameter       fixed bin(21,0)          dcl 1151 in procedure "receive_logical_record" ref
                                                                                  1183 1192 1202 1283
P_buffer_max_lth                       parameter       fixed bin(21,0)          dcl 38 in procedure "old_imft_io_" set ref 558 569*
P_buffer_ptr                           parameter       pointer                  dcl 1150 in procedure "receive_logical_record" ref
                                                                                  1183 1192 1200
P_buffer_ptr                           parameter       pointer                  dcl 37 in procedure "old_imft_io_" set ref 558 569*
P_buffer_used                          parameter       fixed bin(21,0)          dcl 1152 set ref 1183 1192 1303*
P_code                                 parameter       fixed bin(35,0)          dcl 26 in procedure "old_imft_io_" set ref 213 223*
                                                                                  224* 375* 383 390* 398* 402* 403 405* 406 436* 443
                                                                                  451* 479* 487 494* 499* 521* 532 540* 547* 558
                                                                                  565* 571* 578 771* 796 802* 804*
P_code                                 parameter       fixed bin(35,0)          dcl 815 in procedure "cleanup_attachment" set ref
                                                                                  812 817* 823* 830*
P_code                                 parameter       fixed bin(35,0)          dcl 1155 in procedure "receive_logical_record" set
                                                                                  ref 1192 1196* 1364*
P_code                                 parameter       fixed bin(35,0)          dcl 932 in procedure "transmit_logical_record" set
                                                                                  ref 973 976* 1079* 1133*
P_data_lth                             parameter       fixed bin(21,0)          dcl 34 set ref 532 544* 558 569*
P_data_ptr                             parameter       pointer                  dcl 40 set ref 532 544*
P_info_ptr                             parameter       pointer                  dcl 43 ref 578 585
P_iocb_ptr                             parameter       pointer                  dcl 25 ref 213 216 383 386 443 446 487 490 532 535
                                                                                  558 561 578 581 796 799
P_logical_record_data_lth              parameter       fixed bin(21,0)          dcl 930 ref 964 973 988
P_logical_record_data_ptr              parameter       pointer                  dcl 929 ref 964 973 987
P_logical_record_type                  parameter       fixed bin(7,0)           packed unsigned unaligned dcl 927 ref 964 973 995
P_loud_sw                              parameter       bit(1)                   packed unaligned dcl 29 ref 213 217
P_new_modes                            parameter       char                     packed unaligned dcl 46 ref 796 802
P_old_modes                            parameter       char                     packed unaligned dcl 47 set ref 796 800*
P_open_mode                            parameter       fixed bin(17,0)          dcl 31 ref 383 394
P_open_sw                              parameter       bit(1)                   packed unaligned dcl 32 ref 383
P_order                                parameter       char                     packed unaligned dcl 42 ref 578 584
P_position                             parameter       fixed bin(21,0)          dcl 1408 in procedure "substraddr_nonvarying" ref
                                                                                  1404 1412
P_position                             parameter       fixed bin(21,0)          dcl 1421 in procedure "substraddr_varying" ref 1417
                                                                                  1427
P_record_type                          parameter       fixed bin(17,0)          dcl 1154 set ref 1192 1195* 1229 1229*
P_string                               parameter       varying char             dcl 1420 in procedure "substraddr_varying" set ref
                                                                                  1417 1427
P_string                               parameter       char                     packed unaligned dcl 1407 in procedure
                                                                                  "substraddr_nonvarying" set ref 1404 1412
READER_DEVICE                          constant        fixed bin(17,0)          initial dcl 3-38 ref 343
RELATIVE_SECONDS                000124 constant        bit(2)                   initial packed unaligned dcl 96 set ref 605* 628*
                                                                                  653* 676* 710*
SLEW_BY_COUNT                          constant        fixed bin(17,0)          initial dcl 3-44 ref 346
Sequential_input                000170 constant        fixed bin(17,0)          initial dcl 2-15 set ref 402*
Sequential_output               000167 constant        fixed bin(17,0)          initial dcl 2-15 set ref 405*
Stream_input                           constant        fixed bin(17,0)          initial dcl 2-15 ref 396
Stream_output                          constant        fixed bin(17,0)          initial dcl 2-15 ref 396
abort_code                             based           fixed bin(35,0)          level 2 dcl 146 set ref 355* 700 700 705 1126* 1357*
abort_command                          based           structure                level 1 dcl 8-48 set ref 706
abort_command_ptr               000414 automatic       pointer                  dcl 8-52 set ref 703* 704 705 706
abort_in_progress                      based           bit(1)                   level 3 packed packed unaligned dcl 146 set ref 354*
                                                                                  697 698* 1125* 1356*
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-6 ref 386 446 535 561 581 799
add_bit_offset_                 000062 constant        entry                    external dcl 113 ref 1024
addr                                                   builtin function         dcl 139 ref 366 429 736 736 740 740 983 983 990 991
                                                                                  1206 1207 1412 1412 1427 1427
amount_done                     000522 automatic       fixed bin(24,0)          dcl 1173 set ref 1250* 1251 1253 1261* 1261
amount_left                     000520 automatic       fixed bin(24,0)          dcl 1173 in procedure "receive_logical_record" set
                                                                                  ref 1245* 1248 1276* 1280
amount_left                     000447 automatic       fixed bin(24,0)          dcl 952 in procedure "transmit_logical_record" set
                                                                                  ref 1019* 1020 1043 1059* 1060 1070
amount_sent                     000446 automatic       fixed bin(24,0)          dcl 952 set ref 1000* 1017 1019 1024 1041 1048* 1048
                                                                                  1057 1059 1062 1068 1075* 1075
amount_to_copy                  000521 automatic       fixed bin(24,0)          dcl 1173 set ref 1248* 1251 1253 1280* 1281 1286
amount_to_send                  000450 automatic       fixed bin(14,0)          dcl 953 set ref 1020* 1023 1027 1027 1037 1043 1048
                                                                                  1060* 1062 1064 1070 1075
an_attach_description           000151 automatic       char(512)                packed unaligned dcl 81 set ref 265* 270*
any_other                       000366 stack reference condition                dcl 137 ref 362 415 511
argument                               based           char                     packed unaligned dcl 55 set ref 257 264 264 269 269
                                                                                  274 276* 296* 301* 898 908 911
argument_idx                    000136 automatic       fixed bin(17,0)          dcl 76 set ref 252* 254 255 266 271* 900 903* 903
                                                                                  905 906
argument_lth                    000103 automatic       fixed bin(21,0)          dcl 56 set ref 255* 257 264 264 269 269 274 276 276
                                                                                  294* 296 296 299* 301 301 898 906* 908 911
argument_ptr                    000104 automatic       pointer                  dcl 57 set ref 254* 257 264 264 269 269 274 276 293*
                                                                                  296 298* 301 898 905* 908 911
attach_data_ptr          16            based           pointer                  level 2 dcl 1-6 set ref 367* 387 447 505 536 562 582
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-6 set ref 222 366* 493 515*
attach_description                     based           varying char(1024)       level 2 dcl 146 set ref 248* 288* 290* 290 291* 291
                                                                                  295* 295 296* 296 300* 300 301* 301 366
based_character                        based           char(1)                  packed unaligned dcl 956 set ref 1027* 1031* 1033*
binary                    0(11)        based           bit(1)                   level 3 packed packed unaligned dcl 179 set ref 997*
                                                                                  1010 1097 1109* 1238
bolr                      0(12)        based           bit(1)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  1004* 1041* 1068* 1338
buffer                                 based           bit                      packed unaligned dcl 1160 set ref 1255* 1383*
buffer_as_chars                        based           char                     packed unaligned dcl 1164 set ref 1283*
buffer_max_lth                  000511 automatic       fixed bin(24,0)          dcl 1161 set ref 1202* 1242 1244 1255 1274 1275 1298
                                                                                  1383
buffer_ptr                      000512 automatic       pointer                  dcl 1162 set ref 1200* 1255 1283 1383
buffer_used                     000510 automatic       fixed bin(24,0)          dcl 1161 set ref 1204* 1223 1242 1244 1255 1258*
                                                                                  1258 1272 1274 1275 1286* 1286 1298 1303 1338 1379
                                                                                  1381 1383 1385* 1385
byte                      0(02) 000514 automatic       bit(7)                   level 2 packed packed unaligned dcl 1166 set ref
                                                                                  1255
byte_idx                        000525 automatic       fixed bin(21,0)          dcl 1175 set ref 1252* 1254
byte_structure                  000514 automatic       structure                level 1 dcl 1166 set ref 1254*
bytes_array                            based           bit(7)                   array packed unaligned dcl 944 ref 1027 1031 1033
bytes_array_ptr                 000440 automatic       pointer                  dcl 946 set ref 1024* 1027 1031 1033
caller_message                  000102 automatic       char(256)                packed unaligned dcl 870 set ref 875* 876*
channel_name              2     000122 automatic       char(32)                 level 2 dcl 71 set ref 739 742
characters                1            based           char(1)                  array level 2 packed packed unaligned dcl 1423 set
                                                                                  ref 1427
characters_to_copy              000524 automatic       fixed bin(21,0)          dcl 1174 set ref 1281* 1283 1283 1287
characters_used                 000523 automatic       fixed bin(21,0)          dcl 1174 set ref 1272* 1283
cleanup                         000374 stack reference condition                dcl 137 ref 230 463 606 629 654 677 711
close                    36            based           entry variable           level 2 dcl 1-6 set ref 426*
code                            000102 automatic       fixed bin(35,0)          dcl 53 in procedure "old_imft_io_" set ref 218* 314*
                                                                                  316 316* 326* 328 328* 375 448* 455* 456 456 456*
                                                                                  458* 459 459 459* 479 491* 507* 521 537* 547 587*
                                                                                  595* 597* 599* 608* 618* 620* 622* 631* 643* 645*
                                                                                  647* 656* 666* 668* 670* 679* 690* 692* 712* 718*
                                                                                  727* 729* 736* 738 740* 742 746 746 746* 752* 756*
                                                                                  761* 762* 766* 768* 771 783* 881* 883*
code                            000464 automatic       fixed bin(35,0)          dcl 1094 in procedure "transmit_physical_record" set
                                                                                  ref 1103* 1105 1105*
code                            000537 automatic       fixed bin(35,0)          dcl 1317 in procedure "receive_physical_record" set
                                                                                  ref 1322* 1324 1324*
code                      1            based           fixed bin(35,0)          level 2 in structure "abort_command" dcl 8-48
                                                                                  in procedure "old_imft_io_" set ref 705*
collate                                                builtin function         dcl 139 ref 997
com_err_                        000064 constant        entry                    external dcl 114 ref 224 876
continue                        000516 automatic       bit(1)                   dcl 1171 set ref 1210* 1212 1295* 1298* 1298
continue_to_signal_             000066 constant        entry                    external dcl 115 ref 854
control                  66            based           entry variable           level 2 dcl 1-6 set ref 423* 472*
convert                                                builtin function         dcl 139 ref 311 323
cu_$arg_list_ptr                000070 constant        entry                    external dcl 116 ref 875 875
cu_$arg_ptr                     000072 constant        entry                    external dcl 117 ref 872
current_physical_record_n_els          based           fixed bin(24,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 338*
current_physical_record_n_els
                        413            based           fixed bin(24,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 338* 1234 1245 1276 1292
                                                                                  1332*
current_physical_record_type
                        412            based           fixed bin(17,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 337* 1214 1218 1229 1292*
                                                                                  1329*
current_physical_record_type           based           fixed bin(17,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 337*
current_physical_record_used           based           fixed bin(24,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 339*
current_physical_record_used
                        414            based           fixed bin(24,0)          level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 339* 1245 1252 1255 1259*
                                                                                  1259 1276 1283 1287* 1287 1292 1335*
currentsize                                            builtin function         dcl 139 ref 706 1103 1322
data                      1            based           char                     level 2 in structure "imft_physical_record" packed
                                                                                  packed unaligned dcl 179 in procedure
                                                                                  "old_imft_io_" set ref 1027* 1031* 1033* 1062*
                                                                                  1254 1283
data                      6            based           structure                level 2 in structure "terminal_io_record" dcl 3-8
                                                                                  in procedure "old_imft_io_" set ref 991 1207
debug_mode                             based           bit(1)                   level 3 packed packed unaligned dcl 146 set ref 246*
                                                                                  274* 785
detach_iocb              26            based           entry variable           level 2 dcl 1-6 set ref 369* 427* 470*
device_type             417            based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 343*
device_type                            based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 344*
direction                       000137 automatic       char(32)                 packed unaligned dcl 78 set ref 243* 258* 259 259
                                                                                  259* 279 291 306
divide                                                 builtin function         dcl 139 ref 1023 1252 1272 1281 1303
element_size            422            based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 351*
element_size                           based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 351*
element_size              4            based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 3-8
                                                                                  in procedure "old_imft_io_" set ref 1099* 1103
                                                                                  1319* 1322
eolr                      0(13)        based           bit(1)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  1004* 1043* 1070* 1295
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 102 ref 881
error_table_$bad_arg            000016 external static fixed bin(35,0)          dcl 102 set ref 259*
error_table_$bad_mode           000020 external static fixed bin(35,0)          dcl 102 ref 398 804
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 102 set ref 276*
error_table_$improper_data_format
                                000022 external static fixed bin(35,0)          dcl 102 set ref 1338*
error_table_$invalid_read       000024 external static fixed bin(35,0)          dcl 102 ref 565 622 670
error_table_$invalid_write      000026 external static fixed bin(35,0)          dcl 102 ref 540 599 647
error_table_$no_operation       000032 external static fixed bin(35,0)          dcl 102 ref 718
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 102 set ref 235* 279* 281* 283* 900*
error_table_$not_attached       000034 external static fixed bin(35,0)          dcl 102 ref 456 459 494
error_table_$not_closed         000036 external static fixed bin(35,0)          dcl 102 ref 390 499
error_table_$not_detached       000040 external static fixed bin(35,0)          dcl 102 ref 223
error_table_$not_open           000042 external static fixed bin(35,0)          dcl 102 ref 451 456 459
error_table_$null_info_ptr      000044 external static fixed bin(35,0)          dcl 102 ref 595 618 643 666 690 727
error_table_$short_record       000046 external static fixed bin(35,0)          dcl 102 set ref 1326*
error_table_$undefined_order_request
                                000050 external static fixed bin(35,0)          dcl 102 ref 746
error_table_$unimplemented_version
                                000052 external static fixed bin(35,0)          dcl 102 ref 597 620 645 668 692 729
fb14uu                          000451 automatic       fixed bin(14,0)          packed unsigned unaligned dcl 954 in procedure
                                                                                  "transmit_logical_record" set ref 1037* 1038 1039
                                                                                  1064* 1065 1066
fb14uu                          000536 automatic       fixed bin(14,0)          packed unsigned unaligned dcl 1316 in procedure
                                                                                  "receive_physical_record" set ref 1331* 1332
flags                                  based           structure                level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 349*
flags                   421            based           structure                level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 349*
flags                     0(11)        based           structure                level 2 in structure "imft_physical_record" packed
                                                                                  packed unaligned dcl 179 in procedure
                                                                                  "old_imft_io_"
flags                                  based           structure                level 2 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_"
get_channel_names                      based           structure                level 1 dcl 7-11
get_channel_names_ptr           000412 automatic       pointer                  dcl 7-16 set ref 733* 739 742
get_chars                46            based           entry variable           level 2 dcl 1-6 set ref 419* 472*
get_chars_operation             000515 automatic       bit(1)                   dcl 1170 set ref 1186* 1197* 1218 1223 1229 1295
                                                                                  1338 1355
get_line                 42            based           entry variable           level 2 dcl 1-6 set ref 419* 472*
get_system_free_area_           000074 constant        entry                    external dcl 119 ref 228 503
hbound                                                 builtin function         dcl 139 ref 235 252 900
hcs_$reset_ips_mask             000076 constant        entry                    external dcl 120 ref 373 434 477 519 851
hcs_$set_ips_mask               000100 constant        entry                    external dcl 121 ref 364 417 465 513
header                                 based           structure                level 2 in structure "terminal_io_record" dcl 3-8
                                                                                  in procedure "old_imft_io_"
header                                 based           structure                level 4 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_"
header                  416            based           structure                level 4 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_"
high_order                0(20)        based           bit(7)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  1038* 1065* 1331
iad                                    based           structure                level 1 dcl 146 set ref 239 835
iad_ptr                         000402 automatic       pointer                  dcl 158 set ref 220* 239* 240 240 246 248 249 274
                                                                                  288 290 290 291 291 295 295 296 296 300 300 301
                                                                                  301 306 320 332 337 337 338 338 339 339 341 341
                                                                                  343 344 346 346 347 347 349 349 351 351 352 352
                                                                                  354 355 366 367 387* 396 396 402 405 407 411 419
                                                                                  429 447* 455 458 505* 536* 539 562* 564 582* 599
                                                                                  622 647 670 697 698 700 700 705 736 740 752 756
                                                                                  761 762 766 766 768 785 819 821 822 823 824 825
                                                                                  828 829 830 831 832 835 836* 980 983 990 1103 1125
                                                                                  1126 1206 1214 1218 1229 1234 1245 1245 1252 1255
                                                                                  1259 1259 1276 1276 1283 1287 1287 1292 1292 1292
                                                                                  1322 1329 1332 1335 1356 1357
icri                                   based           structure                level 1 dcl 6-6
icri_ptr                        000410 automatic       pointer                  dcl 6-16 set ref 603* 604 605 608 608 608 626* 627
                                                                                  628 631 631 631 631 651* 652 653 656 656 656 674*
                                                                                  675 676 679 679 679 679 695* 702 703 706 712 712
                                                                                  712 712
idx                             000452 automatic       fixed bin(17,0)          dcl 958 set ref 1026* 1027 1027 1027 1031 1031 1033
                                                                                  1033*
imft_debug_                     000000 stack reference condition                dcl 137 ref 785
imft_et_$cant_get_channel_names 000054 external static fixed bin(35,0)          dcl 109 ref 746
imft_et_$reply_pending          000056 external static fixed bin(35,0)          dcl 109 set ref 700 984*
imft_et_$timeout                000060 external static fixed bin(35,0)          dcl 109 ref 783
imft_physical_record                   based           structure                level 1 dcl 179 set ref 993* 1107*
imft_read_abort_                000000 stack reference condition                dcl 137 ref 1358
imft_write_abort_               000000 stack reference condition                dcl 137 ref 1127
info_ptr                        000120 automatic       pointer                  dcl 66 set ref 585* 595 597 603 618 620 626 643 645
                                                                                  651 666 668 674 690 692 695 727 729 733 752* 756*
                                                                                  761* 762* 766* 768*
input_channel             2            based           char(32)                 level 2 packed packed unaligned dcl 7-11 set ref
                                                                                  739*
input_description_idx           000147 automatic       fixed bin(17,0)          dcl 79 set ref 244* 266* 281 293 294 314 316
input_direction                        based           bit(1)                   level 3 packed packed unaligned dcl 146 set ref 306*
                                                                                  396 396 419 539 564 599 622 647 670 766 980
input_pending             2     000442 automatic       bit(1)                   level 2 dcl 948 set ref 982* 984
input_switch            410            based           structure                level 2 dcl 146
ioa_$general_rs                 000102 constant        entry                    external dcl 122 ref 875
iocb                                   based           structure                level 1 dcl 1-6
iocb_ptr                        000100 automatic       pointer                  dcl 52 set ref 216* 222 224 366 367 368 369 371*
                                                                                  386* 387 389 419 419 421 423 424 426 427 429 432*
                                                                                  446* 447 450 467 469 470 472 472 472 472 472 475*
                                                                                  490* 493 498 505 515 517* 535* 536 561* 562 581*
                                                                                  582 799* 876
iox_$attach_ioname              000104 constant        entry                    external dcl 123 ref 314 326
iox_$close                      000110 constant        entry                    external dcl 125 ref 407 455 458 822 829
iox_$control                    000106 constant        entry                    external dcl 124 ref 736 740 752 756 761 762 766 768
                                                                                  983
iox_$destroy_iocb               000112 constant        entry                    external dcl 126 ref 824 831
iox_$detach_iocb                000114 constant        entry                    external dcl 127 ref 823 830
iox_$err_no_operation           000116 constant        entry                    external dcl 128 ref 472
iox_$open                       000120 constant        entry                    external dcl 129 ref 402 405
iox_$propagate                  000122 constant        entry                    external dcl 130 ref 371 432 475 517
iox_$read_record                000124 constant        entry                    external dcl 131 ref 1322
iox_$write_record               000126 constant        entry                    external dcl 132 ref 1103
iox_modes                       000004 constant        char(24)                 initial array dcl 2-6 ref 411
ipr_ptr                         000404 automatic       pointer                  dcl 201 set ref 991* 993 995 997 1004 1004 1010 1027
                                                                                  1031 1033 1038 1039 1041 1043 1062 1065 1066 1068
                                                                                  1070 1096 1097 1107 1108 1109 1207* 1238 1254 1283
                                                                                  1295 1329 1331 1331 1338
ips_mask                        000364 automatic       bit(36)                  packed unaligned dcl 88 set ref 360* 364* 373* 373*
                                                                                  413* 417* 434* 434* 461* 465* 477* 477* 509* 513*
                                                                                  519* 519* 851 851* 851* 852*
lbound                                                 builtin function         dcl 139 ref 252
length                                                 builtin function         dcl 139 ref 255 294 299 906
local_tgci                      000122 automatic       structure                level 1 dcl 71 set ref 736 736 740 740
logical_record_data                    based           char                     packed unaligned dcl 937 ref 997 1062
logical_record_data_bits_lth    000436 automatic       fixed bin(24,0)          dcl 942 set ref 1015* 1017 1019
logical_record_data_lth         000432 automatic       fixed bin(21,0)          dcl 938 set ref 988* 997 997 1003 1015 1057 1059
                                                                                  1062
logical_record_data_ptr         000434 automatic       pointer                  dcl 939 set ref 987* 997 1024* 1062
loud_sw                         000106 automatic       bit(1)                   dcl 59 set ref 217* 224 874
low_order                 0(29)        based           bit(7)                   level 3 packed packed unaligned dcl 179 set ref
                                                                                  1039* 1066* 1331
ltrim                                                  builtin function         dcl 139 ref 311 323
min                                                    builtin function         dcl 139 ref 1020 1060 1248 1253 1280
mod                                                    builtin function         dcl 139 ref 1027 1027 1255 1379 1381
modes                    56            based           entry variable           level 2 dcl 1-6 set ref 424* 472*
n_bits_from_byte                000526 automatic       fixed bin(17,0)          dcl 1176 set ref 1253* 1255 1255 1258 1259 1261
n_bits_to_zero                  000562 automatic       fixed bin(17,0)          dcl 1377 set ref 1381* 1383 1385
n_bytes                         000437 automatic       fixed bin(17,0)          dcl 945 set ref 1023* 1026 1027
n_elements              423            based           fixed bin(24,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 352*
n_elements                5            based           fixed bin(24,0)          level 3 in structure "terminal_io_record" dcl 3-8
                                                                                  in procedure "old_imft_io_" set ref 1100* 1103
                                                                                  1320* 1322 1326
n_elements                             based           fixed bin(24,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 352*
n_els                     0(18)        based           structure                level 2 packed packed unaligned dcl 179
name                      1            based           char(32)                 level 2 dcl 1-6 set ref 224* 876*
null                                                   builtin function         dcl 139 ref 220 222 240 389 450 467 493 498 515 595
                                                                                  618 643 666 690 727 819 821 825 828 832 836
open                     32            based           entry variable           level 2 dcl 1-6 set ref 368* 469*
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-6 set ref 389 429* 450 467* 498
open_description        401            based           varying char(24)         level 2 dcl 146 set ref 249* 411* 429
open_mode                       000107 automatic       fixed bin(17,0)          dcl 61 set ref 394* 396 396 411
option_name                     000100 automatic       char(32)                 packed unaligned dcl 896 set ref 898* 900* 908*
order                           000110 automatic       char(32)                 packed unaligned dcl 65 set ref 584* 590 614 638 662
                                                                                  686 723 752 752 752* 756 756 756 756* 760 761*
                                                                                  762* 766* 768*
output_channel           12            based           char(32)                 level 2 packed packed unaligned dcl 7-11 set ref
                                                                                  742*
output_description_idx          000150 automatic       fixed bin(17,0)          dcl 79 set ref 245* 271* 283 298 299 326 328
output_switch                          based           structure                level 2 dcl 146
p_code                                 parameter       fixed bin(35,0)          dcl 1353 in procedure "abort_read_operation" ref
                                                                                  1350 1357 1364
p_code                                 parameter       fixed bin(35,0)          dcl 1122 in procedure "abort_write_operation" ref
                                                                                  1119 1126 1133
put_chars                52            based           entry variable           level 2 dcl 1-6 set ref 421* 472*
put_chars_operation             000445 automatic       bit(1)                   dcl 950 set ref 967* 977* 1079 1124
reason                                 based           fixed bin(17,0)          level 2 dcl 8-48 set ref 704*
record_info               4            based           structure                level 2 dcl 6-6
record_lth               10            based           fixed bin(21,0)          level 3 dcl 6-6 set ref 608* 631* 656* 679* 706*
                                                                                  712*
record_max_lth            7            based           fixed bin(21,0)          level 3 dcl 6-6 set ref 631* 679* 712*
record_ptr                4            based           pointer                  level 3 dcl 6-6 set ref 608* 631* 656* 679* 703 712*
record_type               6            based           fixed bin(17,0)          level 3 in structure "icri" dcl 6-6 in procedure
                                                                                  "old_imft_io_" set ref 608 631* 656 679* 702* 712*
record_type               0(02)        based           fixed bin(7,0)           level 2 in structure "imft_physical_record" packed
                                                                                  packed unsigned unaligned dcl 179 in procedure
                                                                                  "old_imft_io_" set ref 995* 1096 1108* 1329
requote_string_                 000130 constant        entry                    external dcl 133 ref 296 301
rtrim                                                  builtin function         dcl 139 ref 288 291 311 323 411
saved_binary_flag               000463 automatic       bit(1)                   dcl 1093 set ref 1097* 1109
saved_record_type               000462 automatic       fixed bin(17,0)          dcl 1092 set ref 1096* 1108
slew_control                           based           structure                level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_"
slew_control            420            based           structure                level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_"
slew_count                             based           fixed bin(18,0)          level 6 in structure "iad" packed packed unsigned
                                                                                  unaligned dcl 146 in procedure "old_imft_io_" set
                                                                                  ref 347*
slew_count              420(18)        based           fixed bin(18,0)          level 6 in structure "iad" packed packed unsigned
                                                                                  unaligned dcl 146 in procedure "old_imft_io_" set
                                                                                  ref 347*
slew_type               420            based           fixed bin(18,0)          level 6 in structure "iad" packed packed unsigned
                                                                                  unaligned dcl 146 in procedure "old_imft_io_" set
                                                                                  ref 346*
slew_type                              based           fixed bin(18,0)          level 6 in structure "iad" packed packed unsigned
                                                                                  unaligned dcl 146 in procedure "old_imft_io_" set
                                                                                  ref 346*
space_left                      000517 automatic       fixed bin(24,0)          dcl 1173 set ref 1244* 1248 1275* 1280
string                                                 builtin function         dcl 139 set ref 349* 349*
string_overlay                         based           structure                level 1 dcl 1423 in procedure "substraddr_varying"
string_overlay                         based           char(1)                  array packed unaligned dcl 1410 in procedure
                                                                                  "substraddr_nonvarying" set ref 1412
substr                                                 builtin function         dcl 139 set ref 1027 1038 1039 1062 1065 1066 1254
                                                                                  1255* 1255 1283* 1283 1383*
substraddr                                             generic function         dcl 1399 ref 254 293 298 905 1027 1031 1033
switch_info                            based           structure                level 1 dcl 163
system_area                            based           area(1024)               dcl 73 ref 239 835
system_area_ptr                 000134 automatic       pointer                  dcl 74 set ref 228* 239 503* 835
terminal_attach_count           000010 internal static fixed bin(17,0)          initial dcl 85 set ref 308* 308 309 309* 311 323
terminal_attach_count_pic              automatic       picture(3)               packed unaligned dcl 86 ref 311 323
terminal_io_record                     based           structure                level 1 dcl 3-8 set ref 1103 1322
terminal_io_record_ptr          000406 automatic       pointer                  dcl 3-28 set ref 990* 991 1099 1100 1103* 1103 1206*
                                                                                  1207 1319 1320 1322* 1322 1326
terminal_io_record_version_1           constant        fixed bin(17,0)          initial dcl 3-36 ref 341
terminal_iocb_ptr       410            based           pointer                  level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 240* 320* 402* 407* 458*
                                                                                  736* 752* 761* 766* 821 822* 823* 824* 825* 983*
                                                                                  1322*
terminal_iocb_ptr                      based           pointer                  level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 240* 332* 405* 455* 740*
                                                                                  756* 762* 768* 828 829* 830* 831* 832* 1103*
terminal_iocb_ptr               000362 automatic       pointer                  dcl 84 in procedure "old_imft_io_" set ref 314* 320
                                                                                  326* 332
terminal_switch_name            000351 automatic       char(32)                 packed unaligned dcl 83 set ref 311* 314* 323* 326*
the_code                               based           fixed bin(35,0)          dcl 867 set ref 876* 881 883
the_code_ptr                    000100 automatic       pointer                  dcl 868 set ref 872* 876 881 883
timeout                   2            based           fixed bin(35,0)          level 2 dcl 6-6 ref 604 605 627 628 652 653 675 676
timer_manager_$alarm_call       000132 constant        entry                    external dcl 134 ref 605 628 653 676 710
timer_manager_$reset_alarm_call 000134 constant        entry                    external dcl 135 ref 606 609 629 633 654 657 677 681
                                                                                  711 714
tior                                   based           structure                level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 990
tior                    416            based           structure                level 3 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 1206
trsi                            000442 automatic       structure                level 1 dcl 948 set ref 983 983
tty_get_channel_info                   based           structure                level 1 dcl 5-5
tty_get_channel_info_version           constant        fixed bin(17,0)          initial dcl 5-10 ref 71 734
tty_read_status_info                   based           structure                level 1 dcl 4-17
unspec                                                 builtin function         dcl 139 set ref 993* 1027* 1031* 1033* 1038 1039
                                                                                  1065 1066 1107* 1254* 1254 1331*
verify                                                 builtin function         dcl 139 ref 997
version                                based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 341*
version                 416            based           fixed bin(17,0)          level 5 in structure "iad" dcl 146 in procedure
                                                                                  "old_imft_io_" set ref 341*
version                                based           char(8)                  level 2 in structure "icri" dcl 6-6 in procedure
                                                                                  "old_imft_io_" ref 597 620 645 668 692
version                                based           char(8)                  level 2 in structure "get_channel_names" dcl 7-11
                                                                                  in procedure "old_imft_io_" ref 729
version                         000122 automatic       fixed bin(17,0)          initial level 2 in structure "local_tgci" dcl 71
                                                                                  in procedure "old_imft_io_" set ref 71* 734*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
IMFT_ABORT_ABORTED                     internal static fixed bin(17,0)          initial dcl 8-54
IMFT_ABORT_CANCELLED                   internal static fixed bin(17,0)          initial dcl 8-54
IMFT_ABORT_DEFERRED                    internal static fixed bin(17,0)          initial dcl 8-54
IMFT_ABORT_LOCAL_IO_ERROR              internal static fixed bin(17,0)          initial dcl 8-54
IMFT_ABORT_RESTARTED                   internal static fixed bin(17,0)          initial dcl 8-54
IMFT_ABORT_SAVED                       internal static fixed bin(17,0)          initial dcl 8-54
IMFT_AIM1                              internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
IMFT_AIM2                              internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
IMFT_LOGOUT                            internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
IMFT_RESYNCHRONIZE                     internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
IMFT_SYNC1                             internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
IMFT_SYNC2                             internal static fixed bin(7,0)           initial packed unsigned unaligned dcl 8-22
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
PRINTER_DEVICE                         internal static fixed bin(17,0)          initial dcl 3-38
SLEW_TO_CHANNEL                        internal static fixed bin(17,0)          initial dcl 3-44
SLEW_TO_INSIDE_PAGE                    internal static fixed bin(17,0)          initial dcl 3-44
SLEW_TO_OUTSIDE_PAGE                   internal static fixed bin(17,0)          initial dcl 3-44
SLEW_TO_TOP_OF_PAGE                    internal static fixed bin(17,0)          initial dcl 3-44
SP                                     internal static char(1)                  initial packed unaligned dcl 99
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
TELEPRINTER_DEVICE                     internal static fixed bin(17,0)          initial dcl 3-38
aim2_record                            based           structure                level 1 dcl 8-67
aim2_record_ptr                        automatic       pointer                  dcl 8-86
buffer_lth                             automatic       fixed bin(21,0)          dcl 63
cv_dec_check_                   000000 constant        entry                    external dcl 118
error_table_$bad_conversion            external static fixed bin(35,0)          dcl 102
error_table_$eof_record                external static fixed bin(35,0)          dcl 102
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-51
ipr_data_overlay                       based           structure                level 1 packed packed unaligned dcl 196
local_record_type                      automatic       fixed bin(17,0)          dcl 90
logical_record_data_bits               based           bit                      packed unaligned dcl 941
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
switch_info_ptr                        automatic       pointer                  dcl 173
sync_record                            based           structure                level 1 dcl 8-36
sync_record_ptr                        automatic       pointer                  dcl 8-43
terminal_io_record_data_bits           based           bit                      packed unaligned dcl 3-64
terminal_io_record_data_chars          based           char                     packed unaligned dcl 3-54
terminal_io_record_data_chars_varying  based           varying char             dcl 3-58
terminal_io_record_data_chars_varying_max_len
                                       automatic       fixed bin(21,0)          dcl 3-57
terminal_io_record_element_size        automatic       fixed bin(17,0)          dcl 3-30
terminal_io_record_n_elements          automatic       fixed bin(24,0)          dcl 3-31
tty_read_status_info_ptr               automatic       pointer                  dcl 4-21
tty_write_status_info                  based           structure                level 1 dcl 4-23
tty_write_status_info_ptr              automatic       pointer                  dcl 4-27
v2_aim2_record                         based           structure                level 1 dcl 8-80

NAMES DECLARED BY EXPLICIT CONTEXT.
END_OF_GET_CHARS                007632 constant        label                    dcl 1301 ref 1223
READ_ANOTHER_RECORD             007422 constant        label                    dcl 1214 ref 1218
RECEIVE_COMMON                  007375 constant        label                    dcl 1200 set ref 1187
RETURN_FROM_ATTACH              002601 constant        label                    dcl 375 ref 885
RETURN_FROM_IMFT_CONTROL        005502 constant        label                    dcl 771 ref 788
RETURN_FROM_RECEIVE_LOGICAL_RECORD
                                007640 constant        label                    dcl 1306 ref 1365
RETURN_FROM_TRANSMIT_LOGICAL_RECORD
                                007222 constant        label                    dcl 1082 ref 1134
SIGNAL_RECEIVE_FAILURE_FOREVER  010005 constant        label                    dcl 1358 ref 1360
SIGNAL_TRANSMISSION_FAILURE_FOREVER
                                007347 constant        label                    dcl 1127 ref 1129
TRANSMIT_COMMON                 006470 constant        label                    dcl 980 ref 968
abort_attachment                006070 constant        entry                    internal dcl 864 ref 235 259 276 279 281 283 316 328
                                                                                  900 908
abort_read_operation            007760 constant        entry                    internal dcl 1350 ref 1223 1324 1326 1338
abort_write_operation           007322 constant        entry                    internal dcl 1119 ref 984 1105
adjust_buffer_used              010015 constant        entry                    internal dcl 1374 ref 1271 1301
any_other_handler               006035 constant        entry                    internal dcl 848 ref 362 415 463 511
cleanup_attachment              005623 constant        entry                    internal dcl 812 ref 230 507 879
get_string_argument             006265 constant        entry                    internal dcl 893 ref 258 265 270
imft_io_close                   003160 constant        entry                    external dcl 443 ref 426
imft_io_control                 003724 constant        entry                    external dcl 578 ref 423
imft_io_detach                  003402 constant        entry                    external dcl 487 ref 369 427 470
imft_io_get_chars               003637 constant        entry                    external dcl 558 ref 419
imft_io_modes                   005512 constant        entry                    external dcl 796 ref 424
imft_io_open                    002611 constant        entry                    external dcl 383 ref 368 469
imft_io_put_chars               003550 constant        entry                    external dcl 532 ref 421
old_imft_io_                    000551 constant        entry                    external dcl 18
old_imft_io_attach              000565 constant        entry                    external dcl 213
read_write_timeout              005565 constant        entry                    internal dcl 780 ref 605 605 606 606 609 609 628 628
                                                                                  629 629 633 633 653 653 654 654 657 657 676 676
                                                                                  677 677 681 681 710 710 711 711 714 714
receive_logical_control_record  007366 constant        entry                    internal dcl 1192 ref 631 679 712
receive_logical_data_records    007361 constant        entry                    internal dcl 1183 ref 569
receive_logical_record          007357 constant        entry                    internal dcl 1145
receive_physical_record         007641 constant        entry                    internal dcl 1313 ref 1214
substraddr_nonvarying           010035 constant        entry                    internal dcl 1404 ref 1027 1031 1033
substraddr_varying              010057 constant        entry                    internal dcl 1417 ref 254 293 298 905
transmit_logical_control_record 006463 constant        entry                    internal dcl 973 ref 608 656
transmit_logical_data_record    006456 constant        entry                    internal dcl 964 ref 544
transmit_logical_record         006454 constant        entry                    internal dcl 919
transmit_physical_record        007223 constant        entry                    internal dcl 1089 ref 1006 1046 1073

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11304       11442   10331       11314
Length     12210   10331       136         532     752           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
old_imft_io_                        494 external procedure  is an external procedure.  
on unit on line 230                  72 on unit               
on unit on line 362                  64 on unit               
on unit on line 415                  64 on unit               
on unit on line 463                  64 on unit               
on unit on line 511                  64 on unit               
on unit on line 606                  72 on unit               
on unit on line 629                  72 on unit               
on unit on line 654                  72 on unit               
on unit on line 677                  72 on unit               
on unit on line 711                  72 on unit               
read_write_timeout                   72 internal procedure  is assigned to an entry variable.  
cleanup_attachment                   72 internal procedure  is called by several nonquick procedures.  
any_other_handler                    71 internal procedure  is declared options(non_quick).  
abort_attachment                    178 internal procedure  is declared options(non_quick), and is declared options(variable).  
get_string_argument                 116 internal procedure  uses returns(char(*)) or returns(bit(*)).  
transmit_logical_record                 internal procedure  shares stack frame of external procedure old_imft_io_.  
transmit_physical_record                internal procedure  shares stack frame of external procedure old_imft_io_.  
abort_write_operation                   internal procedure  shares stack frame of external procedure old_imft_io_.  
receive_logical_record                  internal procedure  shares stack frame of external procedure old_imft_io_.  
receive_physical_record                 internal procedure  shares stack frame of external procedure old_imft_io_.  
abort_read_operation                    internal procedure  shares stack frame of external procedure old_imft_io_.  
adjust_buffer_used                      internal procedure  shares stack frame of external procedure old_imft_io_.  
substraddr_nonvarying                   internal procedure  shares stack frame of external procedure old_imft_io_.  
substraddr_varying                   65 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 terminal_attach_count       old_imft_io_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abort_attachment         000100 the_code_ptr                abort_attachment
                         000102 caller_message              abort_attachment
get_string_argument      000100 option_name                 get_string_argument
old_imft_io_             000100 iocb_ptr                    old_imft_io_
                         000102 code                        old_imft_io_
                         000103 argument_lth                old_imft_io_
                         000104 argument_ptr                old_imft_io_
                         000106 loud_sw                     old_imft_io_
                         000107 open_mode                   old_imft_io_
                         000110 order                       old_imft_io_
                         000120 info_ptr                    old_imft_io_
                         000122 local_tgci                  old_imft_io_
                         000134 system_area_ptr             old_imft_io_
                         000136 argument_idx                old_imft_io_
                         000137 direction                   old_imft_io_
                         000147 input_description_idx       old_imft_io_
                         000150 output_description_idx      old_imft_io_
                         000151 an_attach_description       old_imft_io_
                         000351 terminal_switch_name        old_imft_io_
                         000362 terminal_iocb_ptr           old_imft_io_
                         000364 ips_mask                    old_imft_io_
                         000402 iad_ptr                     old_imft_io_
                         000404 ipr_ptr                     old_imft_io_
                         000406 terminal_io_record_ptr      old_imft_io_
                         000410 icri_ptr                    old_imft_io_
                         000412 get_channel_names_ptr       old_imft_io_
                         000414 abort_command_ptr           old_imft_io_
                         000432 logical_record_data_lth     transmit_logical_record
                         000434 logical_record_data_ptr     transmit_logical_record
                         000436 logical_record_data_bits_lth
                                                            transmit_logical_record
                         000437 n_bytes                     transmit_logical_record
                         000440 bytes_array_ptr             transmit_logical_record
                         000442 trsi                        transmit_logical_record
                         000445 put_chars_operation         transmit_logical_record
                         000446 amount_sent                 transmit_logical_record
                         000447 amount_left                 transmit_logical_record
                         000450 amount_to_send              transmit_logical_record
                         000451 fb14uu                      transmit_logical_record
                         000452 idx                         transmit_logical_record
                         000462 saved_record_type           transmit_physical_record
                         000463 saved_binary_flag           transmit_physical_record
                         000464 code                        transmit_physical_record
                         000510 buffer_used                 receive_logical_record
                         000511 buffer_max_lth              receive_logical_record
                         000512 buffer_ptr                  receive_logical_record
                         000514 byte_structure              receive_logical_record
                         000515 get_chars_operation         receive_logical_record
                         000516 continue                    receive_logical_record
                         000517 space_left                  receive_logical_record
                         000520 amount_left                 receive_logical_record
                         000521 amount_to_copy              receive_logical_record
                         000522 amount_done                 receive_logical_record
                         000523 characters_used             receive_logical_record
                         000524 characters_to_copy          receive_logical_record
                         000525 byte_idx                    receive_logical_record
                         000526 n_bits_from_byte            receive_logical_record
                         000536 fb14uu                      receive_physical_record
                         000537 code                        receive_physical_record
                         000562 n_bits_to_zero              adjust_buffer_used

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              r_ne_as             alloc_char_temp     alloc_bit_temp      cat_realloc_chars
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return_mac          move_label_var      make_label_var      tra_ext_1           mdfx1               signal_op
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
return_chars_eis    op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_bit_offset_               com_err_                      continue_to_signal_           cu_$arg_list_ptr
cu_$arg_ptr                   get_system_free_area_         hcs_$reset_ips_mask           hcs_$set_ips_mask
ioa_$general_rs               iox_$attach_ioname            iox_$close                    iox_$control
iox_$destroy_iocb             iox_$detach_iocb              iox_$err_no_operation         iox_$open
iox_$propagate                iox_$read_record              iox_$write_record             requote_string_
timer_manager_$alarm_call     timer_manager_$reset_alarm_call

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$bad_mode
error_table_$badopt           error_table_$improper_data_format                           error_table_$invalid_read
error_table_$invalid_write    error_table_$no_operation     error_table_$noarg            error_table_$not_attached
error_table_$not_closed       error_table_$not_detached     error_table_$not_open         error_table_$null_info_ptr
error_table_$short_record     error_table_$undefined_order_request
error_table_$unimplemented_version                          imft_et_$cant_get_channel_names
imft_et_$reply_pending        imft_et_$timeout




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     71 000544        18 000550        20 000557       213 000560       216 000604       217 000610       218 000615
    220 000616       222 000620       223 000623       224 000626       225 000660       228 000661       230 000670
    235 000715       239 000742       240 000760       243 000772       244 000775       245 000776       246 000777
    248 001006       249 001007       252 001010       254 001021       255 001061       257 001075       258 001102
    259 001122       262 001157       264 001160       265 001170       266 001210       267 001213       269 001214
    270 001224       271 001244       272 001247       274 001250       276 001273       277 001320       279 001322
    281 001350       283 001375       288 001417       290 001440       291 001452       293 001476       294 001536
    295 001552       296 001565       298 001626       299 001667       300 001703       301 001716       306 001757
    308 002002       309 002004       311 002011       314 002076       316 002147       320 002211       323 002214
    326 002302       328 002353       332 002415       337 002426       338 002433       339 002435       341 002437
    343 002442       344 002444       346 002446       347 002456       349 002466       351 002470       352 002473
    354 002476       355 002507       360 002510       362 002511       364 002533       366 002546       367 002551
    368 002553       369 002557       371 002562       373 002571       375 002601       377 002603       383 002604
    386 002622       387 002627       389 002631       390 002635       391 002640       394 002641       396 002643
    398 002673       399 002676       402 002677       403 002716       405 002720       406 002745       407 002747
    408 002762       411 002763       413 003015       415 003016       417 003040       419 003053       421 003110
    423 003115       424 003120       426 003123       427 003126       429 003131       432 003133       434 003142
    436 003152       437 003153       443 003154       446 003171       447 003176       448 003200       450 003201
    451 003205       452 003210       455 003211       456 003230       458 003237       459 003250       461 003257
    463 003260       465 003302       467 003315       469 003320       470 003324       472 003327       475 003357
    477 003365       479 003375       481 003377       487 003400       490 003413       491 003417       493 003420
    494 003424       495 003427       498 003430       499 003434       500 003437       503 003440       505 003447
    507 003452       509 003460       511 003461       513 003503       515 003516       517 003521       519 003530
    521 003540       522 003542       532 003543       535 003563       536 003570       537 003572       539 003573
    540 003611       541 003614       544 003615       547 003627       548 003631       558 003632       561 003652
    562 003657       564 003661       565 003677       566 003702       569 003703       571 003715       572 003716
    578 003717       581 003743       582 003750       584 003752       585 003757       587 003762       590 003763
    595 003767       597 003777       599 004007       603 004031       604 004032       605 004035       606 004056
    608 004106       609 004130       611 004142       614 004143       618 004147       620 004157       622 004167
    626 004211       627 004212       628 004215       629 004236       631 004266       633 004305       635 004317
    638 004320       643 004324       645 004334       647 004344       651 004366       652 004367       653 004372
    654 004413       656 004443       657 004465       659 004477       662 004500       666 004504       668 004514
    670 004524       674 004546       675 004547       676 004552       677 004573       679 004623       681 004642
    683 004654       686 004655       690 004661       692 004671       695 004701       697 004702       698 004723
    700 004725       702 004733       703 004737       704 004741       705 004743       706 004745       707 004747
    710 004750       711 004766       712 005016       714 005035       716 005047       718 005050       720 005053
    723 005054       727 005060       729 005070       733 005100       734 005101       736 005103       738 005136
    739 005140       740 005144       742 005205       746 005213       749 005221       752 005222       756 005257
    760 005326       761 005332       762 005356       763 005410       766 005411       768 005455       771 005502
    774 005504       796 005505       799 005536       800 005543       802 005550       804 005560       806 005563
    780 005564       783 005572       785 005575       788 005617       812 005622       817 005630       819 005632
    821 005637       822 005644       823 005655       824 005671       825 005705       828 005711       829 005725
    830 005740       831 005761       832 006002       835 006014       836 006030       840 006033       848 006034
    851 006042       852 006054       854 006056       856 006066       864 006067       872 006075       874 006115
    875 006120       876 006177       879 006240       881 006250       883 006257       885 006261       893 006264
    898 006272       900 006300       903 006331       905 006333       906 006374       908 006411       911 006443
    919 006454       922 006455       964 006456       967 006460       968 006462       973 006463       976 006465
    977 006467       980 006470       982 006507       983 006510       984 006544       987 006555       988 006561
    990 006563       991 006574       993 006576       995 006604       997 006610      1000 006631      1003 006632
   1004 006634      1006 006640      1007 006641      1010 006642      1015 006645      1017 006647      1019 006653
   1020 006656      1023 006662      1024 006665      1026 006702      1027 006711      1031 006772      1033 007041
   1035 007106      1037 007110      1038 007113      1039 007120      1041 007125      1043 007131      1046 007136
   1048 007137      1049 007141      1050 007142      1057 007143      1059 007147      1060 007152      1062 007156
   1064 007165      1065 007167      1066 007174      1068 007201      1070 007205      1073 007212      1075 007213
   1076 007215      1079 007216      1082 007222      1089 007223      1096 007224      1097 007230      1099 007234
   1100 007237      1103 007241      1105 007274      1107 007300      1108 007307      1109 007314      1111 007321
   1119 007322      1124 007324      1125 007326      1126 007345      1127 007347      1129 007352      1133 007353
   1134 007356      1145 007357      1148 007360      1183 007361      1186 007363      1187 007365      1192 007366
   1195 007370      1196 007373      1197 007374      1200 007375      1202 007401      1204 007404      1206 007405
   1207 007410      1210 007412      1212 007414      1214 007416      1218 007423      1223 007432      1229 007441
   1234 007452      1238 007456      1242 007461      1244 007464      1245 007467      1248 007472      1250 007476
   1251 007477      1252 007503      1253 007510      1254 007516      1255 007525      1258 007536      1259 007540
   1261 007541      1262 007542      1264 007543      1271 007544      1272 007545      1274 007551      1275 007554
   1276 007557      1280 007564      1281 007570      1283 007573      1286 007605      1287 007607      1292 007611
   1295 007617      1298 007625      1299 007631      1301 007632      1303 007633      1306 007640      1313 007641
   1319 007642      1320 007645      1322 007647      1324 007676      1326 007702      1329 007715      1331 007722
   1332 007735      1335 007740      1338 007741      1342 007757      1350 007760      1355 007762      1356 007764
   1357 010003      1358 010005      1360 010010      1364 010011      1365 010014      1374 010015      1379 010016
   1381 010022      1383 010026      1385 010033      1388 010034      1404 010035      1412 010046      1417 010056
   1427 010072


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
