	COMPILATION LISTING OF SEGMENT apl_dim_write_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 11/29/83  1601.6 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* Write portion of the APL Device Interface Module.
       11*   Paul Green, July 1973 */
       12 /* Modified 740328 by PG to add features for net2741 device type */
       13 /* Modified 741101 by PG to emit final downshift upon write so [MqN] editing will work. */
       14 /* Modified 750320 by PG to get above fix to work correctly! */
       15 /* Modified 770407 by PG to get )TABS command to work properly (not all wired-in 10's had been parameterized!). */
       16 /* Modified 790411 by PG to fix 381 (was not padding backspace chars) */
       17 /* Modified 791017 by PG to "fix" bug 395 by moving write_buffer to the stack and enlarging it.
       18*   Modified 791220 by PG to improve fix to 381 by padding only first BS char in a sequence, to speed up
       19*	[MqN] style of editing on a TN300, and to fix bug 432 in which [MqN] editing failed with 4.00
       20*	editor because read_back_spaces returned wrong number of spaces (especially when tabs were
       21*	present, but also at other times). This also fixes bug 410, where overstruck characters get
       22*	converted to 3 spaces on input.
       23*   Modified 800128 by Warren Johnson to handle graphic mode.
       24*   Modified 800130 by PG to once and for all fix the **** fatal process error bug (443).
       25*   Modified 800131 by PG to fix bug in graphic mode.
       26*   Modified 800226 by PG to implement ^ll mode.
       27*   Discovered Modified 831107 by M. Pandolf in writing CR when whitespace
       28*	character is a CR instead of just setting column to 0
       29**/
       30 
       31 /* format: style3 */
       32 apl_dim_write_:
       33      procedure (P_sdb_ptr, P_data_ptr, P_data_offset, P_data_length, P_n_elements_transmitted, P_status);
       34 
       35 /* parameters */
       36 
       37 dcl	(P_data_offset, P_data_length, P_n_elements_transmitted)
       38 			fixed bin,
       39 	P_sdb_ptr		ptr,
       40 	P_data_ptr	ptr,
       41 	P_status		bit (72);
       42 
       43 /* automatic */
       44 
       45 dcl	data_ptr		ptr,
       46 	current_char	char (1);
       47 dcl	(n_delays, nl_addend, nl_multiplier, tab_addend, tab_multiplier)
       48 			fixed bin (21);
       49 dcl	(i, ini, wcol, seqi, ei, ereti, escape_index)
       50 			fixed bin (21),
       51 	(col, oldcol)	fixed bin (9),
       52 	initial_column	fixed bin (9),		/* column we are in before any output is done. */
       53 	(donesw, last_char_was_BS, whitesw)
       54 			bit (1) aligned,
       55 	(shift, mode)	bit (2),
       56 	(inchar, enchar, outchar, oldoutchar)
       57 			bit (9),
       58 	erets		(0:4) fixed bin,
       59 	error_mark_line	char (150),
       60 	(device_last_line_start, last_line_start, out_char)
       61 			fixed bin,
       62 	1 write_struc	aligned,
       63 	  2 write_buffer	dim (4096) bit (9) unal;
       64 
       65 /* based */
       66 
       67 dcl	based_string	dim (0:1044479) char (1) based,
       68 	data_string	char (P_data_length) based (data_ptr),
       69 	write_buffer_overlay
       70 			char (4096) aligned based (addr (write_struc));
       71 
       72 /* entries */
       73 
       74 dcl	iox_$put_chars	entry (ptr, ptr, fixed bin (21), fixed bin (35));
       75 
       76 /* builtins */
       77 
       78 dcl	(addr, addrel, binary, copy, divide, length, max, mod, substr, unspec)
       79 			builtin;
       80 
       81 /* include files */
       82 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_dim_sdb.incl.pl1 ====================================== */
  1     2 
  1     3 /* format: style3,initlm0,idind30 */
  1     4 dcl	sdb_ptr			ptr;
  1     5 
  1     6 dcl	1 stream_data_block		aligned based (sdb_ptr),
  1     7 	  2 outer_module_name	char (32) init (my_name),
  1     8 						/* standard I/O System SDB header */
  1     9 	  2 device_name_list_ptr	ptr init (addr (stream_data_block.device_name)),
  1    10 	  2 device_name		aligned,
  1    11 	    3 next_ptr		ptr init (null ()),
  1    12 	    3 name_size		fixed bin init (length (att_stream)),
  1    13 	    3 name		char (32) init (att_stream),
  1    14 	  2 device_iocb_ptr		ptr,		/* ptr to IOCB for sdb.name */
  1    15 	  2 iocb_ptr		ptr,		/* ptr to IOCB for this attachment */
  1    16 						/* info about conversion tables */
  1    17 	  2 sequence_table_ptr	ptr,		/* points to escape sequences in use */
  1    18 	  2 device_info_ptr		ptr init (null ()), /* pointer to dev-info table */
  1    19 	  2 conv_tab_ptr		ptr init (null ()), /* pointer to conversion tables */
  1    20 	  2 compression_in_ptr	ptr initial (null ()),
  1    21 						/* pointer to compression input table */
  1    22 	  2 compression_out_ptr	ptr initial (null ()),
  1    23 						/* pointer to compression output table */
  1    24 						/* parameters of the device */
  1    25 	  2 keying_time		fixed bin (71) init (0),
  1    26 						/* keying time of device */
  1    27 	  2 max_col		fixed bin init (-1),/* number of columns per line */
  1    28 	  2 max_line		fixed bin init (-1),/* number of lines per frame */
  1    29 	  2 actcol		fixed bin init (0), /* present column */
  1    30 	  2 actline		fixed bin init (0), /* present line */
  1    31 	  2 actshift		unal bit (2) init ("11"b),
  1    32 						/* present shift */
  1    33 						/* modes of the device */
  1    34 	  2 tabm			unal bit (1) init ("1"b),
  1    35 						/* tabs may be used */
  1    36 	  2 conm			unal bit (1) init ("1"b),
  1    37 						/* canonicalization should be performed */
  1    38 	  2 graphic		unal bit (1) init ("0"b),
  1    39 						/* graphic mode */
  1    40 	  2 escm			unal bit (1) init ("1"b),
  1    41 						/* processing escapes on input */
  1    42 	  2 erklm			unal bit (1) init ("1"b),
  1    43 						/* erase/kill on */
  1    44 	  2 rawim			unal bit (1) init ("0"b),
  1    45 						/* raw input mode */
  1    46 	  2 red_mode		unal bit (1) init ("1"b),
  1    47 						/* red/black shifts may be transmitted */
  1    48 	  2 escape_out_seen		unal bit (1) init ("0"b),
  1    49 						/* user typed overstruck O-U-T */
  1    50 	  2 tabsin_mode		unal bit (1) init ("0"b),
  1    51 						/* ON means let tabs thru, OFF means change to spaces */
  1    52 	  2 hndlquit_mode		unal bit (1) init ("1"b),
  1    53 						/* ON means dim does reset(read write), OFF it doesn't */
  1    54 	  2 padding		unal bit (24),
  1    55 	  2 read_back		fixed bin init (0), /* input processing mode */
  1    56 						/* info about read/write buffers */
  1    57 	  2 canonicalization_index	fixed bin init (1), /* offset in canonicalization_buffer of next "free" char */
  1    58 	  2 read_offset		fixed bin init (-1),/* offset in canonicalization_buffer of first character */
  1    59 	  2 character_error_index	fixed bin init (-1),/* index of last good character */
  1    60 	  2 error_mark_column	fixed bin init (0), /* column error marker goes in */
  1    61 	  2 inimax		fixed bin init (0), /* index of last char (0-origin) + 1 */
  1    62 	  2 tab_width		fixed bin init (10),/* how wide a tab stop is. */
  1    63 	  2 baud_rate		fixed bin init (0), /* see apl_dim_table.incl.pl1 */
  1    64 	  2 internal_type		unal dim (0:255) bit (9),
  1    65 						/* copied from device_info.code_move */
  1    66 	  2 canonicalization_buffer	char (512),
  1    67 	  2 normal_read_buffer	char (512),
  1    68 	  2 quit_read_buffer	char (512);
  1    69 
  1    70 dcl	1 type			unal dim (0:255) defined (stream_data_block.internal_type (0)),
  1    71 						/* indexed by internal code */
  1    72 	  2 white			bit (1),		/* on if white space char */
  1    73 	  2 red			bit (1),		/* on if red/black shift char */
  1    74 	  2 action		bit (4),		/* 0 none, 1 esc, 2 erase, 3 kill, 4 delim, 5 break */
  1    75 	  2 move			bit (3);		/* 0=+1, 1=0, 2=-1, 3=tab, 4=cr, 5=nl, 6=np, 7=vt */
  1    76 
  1    77 /* constants for stream_data_block.read_back field. */
  1    78 
  1    79 declare	read_back_names		char (16) dimension (0:2) internal static options (constant)
  1    80 				initial ("read_back_spaces", "read_back_input", "read_back_output");
  1    81 
  1    82 dcl	(
  1    83 	read_back_spaces		init (0),		/* just keep track of column input starts in */
  1    84 	read_back_input		init (1),		/* just read what user typed */
  1    85 	read_back_output		init (2)		/* remember output & recanonicalize entire line */
  1    86 	)			fixed bin internal static options (constant);
  1    87 
  1    88 dcl	status			bit (72);
  1    89 
  1    90 dcl	1 status_bits		based (addr (status)),
  1    91 	  2 status_code		fixed bin (35),
  1    92 	  (
  1    93 	  2 logical_initiation	bit (1),
  1    94 	  2 logical_completion	bit (1),
  1    95 	  2 physical_initiation	bit (1),
  1    96 	  2 physical_completion	bit (1),
  1    97 	  2 transaction_terminated	bit (1),
  1    98 	  2 unused_42_45		bit (4),
  1    99 	  2 end_of_logical_data	bit (1),
  1   100 	  2 end_of_physical_data	bit (1),
  1   101 	  2 unused_48_51		bit (4),
  1   102 	  2 stream_detached		bit (1),
  1   103 	  2 unused_53		bit (1),
  1   104 	  2 transaction_aborted	bit (1),
  1   105 	  2 transaction_index	bit (18)
  1   106 	  )			unaligned;
  1   107 
  1   108 /* ------ END INCLUDE SEGMENT		apl_dim_sdb.incl.pl1 -------------------------------------- */
       83 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_dim_table.incl.pl1 ==================================== */
  2     2 
  2     3 dcl	 (conversion_ptr, device_ptr, sequence_ptr) ptr,
  2     4 	n fixed bin;
  2     5 
  2     6 dcl (	baud_rate_110		init (0),
  2     7 	baud_rate_150_or_134	init (1),
  2     8 	baud_rate_300		init (2),
  2     9 	baud_rate_1200		init (3)
  2    10 	) fixed bin internal static options (constant);
  2    11 
  2    12 
  2    13 dcl     1 device_info		based (device_ptr) aligned,
  2    14 	2 conversion_offset		unal bit (18),
  2    15 	2 sequence_offset		unal bit (18),
  2    16 	2 compression_in_offset	unal bit (18),
  2    17 	2 compression_out_offset	unal bit (18),
  2    18 	2 device_name		unal char (32),
  2    19 	2 graphic_terminal		unal bit (1),
  2    20 	2 shift_needed		unal bit (1),
  2    21 	2 quit_editing_allowed	unal bit (1),
  2    22 	2 unused_bits_1		unal bit (15),
  2    23 	2 linefeed_character_device	unal bit (9),
  2    24 	2 escape_character_code	unal bit (9),	/* internal 8-bit code */
  2    25 	2 delay_character		unal bit (9),
  2    26 	2 upper_case		unal bit (9),
  2    27 	2 lower_case		unal bit (9),
  2    28 	2 escape_character_device	unal bit (9),	/* external 7-bit device */
  2    29 	2 default_page_length	unal fixed bin (17),
  2    30 	2 default_line_length	unal fixed bin (17),
  2    31 	2 pad_info		dim (0:3) aligned,	/* 110, 150, 300, 1200 */
  2    32 	  3 nl_addend		unal fixed bin (17),
  2    33 	  3 nl_multiplier		unal fixed bin (17),
  2    34 	  3 tab_addend		unal fixed bin (17),
  2    35 	  3 tab_multiplier		unal fixed bin (17),
  2    36 	  3 bs_n_pads		unal fixed bin (17),	/* number of pads after bs. */
  2    37 	  3 np_n_pads		unal fixed bin (17),	/* number of pads after new page. */
  2    38 	2 editing_prompt		varying char (8);
  2    39 
  2    40 dcl	1 conversions	based (conversion_ptr) aligned,
  2    41 	2 out		unal dim (0:255) bit (9),	/* internal 8-bit code to external 7-bit device */
  2    42 	2 in		unal dim (0:127) bit (9),	/* external 7-bit device to internal 8-bit code */
  2    43 	2 code_move	unal dim (0:255) bit (9),	/* internal movement of code */
  2    44 	2 device_move	unal dim (0:127) bit (6),	/* external movement of device */
  2    45 	2 unused_1	unal bit (24),
  2    46 	2 size		fixed bin,
  2    47 	2 escape		dim (0:n refer (conversions.size)),
  2    48 	  3 prefix	unal bit (1),
  2    49 	  3 conceal	unal bit (1),
  2    50 	  3 unused_2	unal bit (7),
  2    51 	  3 inchar	unal bit (9),
  2    52 	  3 outchar	unal bit (9),
  2    53 	  3 unused_3	unal bit (9);
  2    54 
  2    55 dcl	1 sequence	based (sequence_ptr) aligned,
  2    56 	2 size		unal fixed bin (8),
  2    57 	2 characters	unal dim (sequence.size) bit (9);
  2    58 
  2    59 dcl	1 compression_in	based (compression_in_ptr) aligned,
  2    60 	2 size		fixed bin,
  2    61 	2 compression_string char (compression_in.size);
  2    62 
  2    63 dcl	1 compression_out	based (compression_out_ptr) aligned,
  2    64 	2 size		fixed bin,
  2    65 	2 output_character	dim (compression_out.size) unal bit (9);
  2    66 
  2    67 /* ------ END INCLUDE SEGMENT		apl_dim_table.incl.pl1 ------------------------------------ */
       84 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_characters.incl.pl1 =================================== */
  3     2 
  3     3 /*
  3     4* * This include file contains all the characters in the APL character set,
  3     5* * declared char(1)  [Instead of fixed bin as in the apl_character_codes.incl.pl1 file]
  3     6* *
  3     7*   Modified 780913 by PG to add CentSign
  3     8*   Modified 790319 by PG to add CommaHyphen
  3     9* */
  3    10 
  3    11 declare (
  3    12 	QBell		init(""),
  3    13 	QBackSpace	init(""),
  3    14 	QTab		init("	"),
  3    15 	QNewLine		init("
  3    16 "),
  3    17 	QSpace		init(" "),
  3    18 	QExclamation	init("!"),
  3    19 	QDollar		init("$"),
  3    20 	QApostrophe	init("'"),
  3    21 	QLeftParen	init("("),
  3    22 	QRightParen	init(")"),
  3    23 	QStar		init("*"),
  3    24 	QPlus		init("+"),
  3    25 	QComma		init(","),
  3    26 	QMinus		init("-"),
  3    27 	QPeriod		init("."),
  3    28 	QSlash		init("/"),
  3    29 	QZero		init("0"),
  3    30 	QOne		init("1"),
  3    31 	QTwo		init("2"),
  3    32 	QThree		init("3"),
  3    33 	QFour		init("4"),
  3    34 	QFive		init("5"),
  3    35 	QSix		init("6"),
  3    36 	QSeven		init("7"),
  3    37 	QEight		init("8"),
  3    38 	QNine		init("9"),
  3    39 	QColon		init(":"),
  3    40 	QSemiColon	init(";"),
  3    41 	QLessThan		init("<"),
  3    42 	QEqual		init("="),
  3    43 	QGreaterThan	init(">"),
  3    44 	QQuestion		init("?"),
  3    45 	QLetterA_		init("A"),
  3    46 	QLetterB_		init("B"),
  3    47 	QLetterC_		init("C"),
  3    48 	QLetterD_		init("D"),
  3    49 	QLetterE_		init("E"),
  3    50 	QLetterF_		init("F"),
  3    51 	QLetterG_		init("G"),
  3    52 	QLetterH_		init("H"),
  3    53 	QLetterI_		init("I"),
  3    54 	QLetterJ_		init("J"),
  3    55 	QLetterK_		init("K"),
  3    56 	QLetterL_		init("L"),
  3    57 	QLetterM_		init("M"),
  3    58 	QLetterN_		init("N"),
  3    59 	QLetterO_		init("O"),
  3    60 	QLetterP_		init("P"),
  3    61 	QLetterQ_		init("Q"),
  3    62 	QLetterR_		init("R"),
  3    63 	QLetterS_		init("S"),
  3    64 	QLetterT_		init("T"),
  3    65 	QLetterU_		init("U"),
  3    66 	QLetterV_		init("V"),
  3    67 	QLetterW_		init("W"),
  3    68 	QLetterX_		init("X"),
  3    69 	QLetterY_		init("Y"),
  3    70 	QLetterZ_		init("Z"),
  3    71 	QLeftBracket	init("["),
  3    72 	QBackSlash	init("\"),
  3    73 	QRightBracket	init("]"),
  3    74 	QUnderLine	init("_"),
  3    75 	QLetterA		init("a"),
  3    76 	QLetterB		init("b"),
  3    77 	QLetterC		init("c"),
  3    78 	QLetterD		init("d"),
  3    79 	QLetterE		init("e"),
  3    80 	QLetterF		init("f"),
  3    81 	QLetterG		init("g"),
  3    82 	QLetterH		init("h"),
  3    83 	QLetterI		init("i"),
  3    84 	QLetterJ		init("j"),
  3    85 	QLetterK		init("k"),
  3    86 	QLetterL		init("l"),
  3    87 	QLetterM		init("m"),
  3    88 	QLetterN		init("n"),
  3    89 	QLetterO		init("o"),
  3    90 	QLetterP		init("p"),
  3    91 	QLetterQ		init("q"),
  3    92 	QLetterR		init("r"),
  3    93 	QLetterS		init("s"),
  3    94 	QLetterT		init("t"),
  3    95 	QLetterU		init("u"),
  3    96 	QLetterV		init("v"),
  3    97 	QLetterW		init("w"),
  3    98 	QLetterX		init("x"),
  3    99 	QLetterY		init("y"),
  3   100 	QLetterZ		init("z"),
  3   101 	QLeftBrace	init("{"),
  3   102 	QVerticalBar	init("|"),
  3   103 	QRightBrace	init("}"),
  3   104 	QTilde		init("~"),
  3   105 	QLessOrEqual	init("€"),
  3   106 	QGreaterOrEqual	init(""),
  3   107 	QNotEqual		init("‚"),
  3   108 	QOrSign		init("ƒ"),
  3   109 	QAndSign		init("„"),
  3   110 	QDivision		init("…"),
  3   111 	QEpsilon		init("†"),
  3   112 	QUpArrow		init("‡"),
  3   113 	QDownArrow	init("ˆ"),
  3   114 	QCircle		init("‰"),
  3   115 	QCeiling		init("Š"),
  3   116 	QFloor		init("‹"),
  3   117 	QDelta		init("Œ"),
  3   118 	QSmallCircle	init(""),
  3   119 	QQuad		init("Ž"),
  3   120 	QCap		init(""),
  3   121 	QDeCode		init(""),
  3   122 	QEnCode		init("‘"),
  3   123 	QLeftLump		init("’"),
  3   124 	QRightLump	init("“"),
  3   125 	QCup		init("”"),
  3   126 	QNorSign		init("•"),
  3   127 	QNandSign		init("–"),
  3   128 	QCircleHyphen	init("—"),
  3   129 	QSlashHyphen	init("˜"),
  3   130 	QDelTilde		init("™"),
  3   131 	QCircleStar	init("š"),
  3   132 	QCircleBar	init("›"),
  3   133 	QCircleBackSlash	init("œ"),
  3   134 	QCircleSlash	init(""),
  3   135 	QGradeDown	init("ž"),
  3   136 	QGradeUp		init("Ÿ"),
  3   137 	QLamp		init(" "),
  3   138 	QQuadQuote	init("¡"),
  3   139 	QIBeam		init("¢"),
  3   140 	QBackSlashHyphen	init("£"),
  3   141 	QDomino		init("¤"),
  3   142 	QDiaresis		init("¥"),
  3   143 	QOmega		init("¦"),
  3   144 	QIota		init("§"),
  3   145 	QRho		init("¨"),
  3   146 	QTimes		init("©"),
  3   147 	QAlpha		init("ª"),
  3   148 	QUpperMinus	init("«"),
  3   149 	QDel		init("¬"),
  3   150 	QLeftArrow	init("­"),
  3   151 	QRightArrow	init("®"),
  3   152 	QDiamond		init("¯"),
  3   153 	QZero_		init("°"),
  3   154 	QOne_		init("±"),
  3   155 	QTwo_		init("²"),
  3   156 	QThree_		init("³"),
  3   157 	QFour_		init("´"),
  3   158 	QFive_		init("µ"),
  3   159 	QSix_		init("¶"),
  3   160 	QSeven_		init("·"),
  3   161 	QEight_		init("¸"),
  3   162 	QNine_		init("¹"),
  3   163 	QDelta_		init("º"),
  3   164 	QMarkError	init("»"),
  3   165 	QExecuteSign	init("¼"),
  3   166 	QFormatSign	init("½"),
  3   167 	QLeftTack		init("¾"),
  3   168 	QRightTack	init("¿"),
  3   169 	QLineFeed		init("À"),
  3   170 	QConditionalNewLine	init("Á"),
  3   171 	QCentSign		init("Â"),
  3   172 	QCommaHyphen	init("Ã")
  3   173      ) char(1) internal static options (constant);
  3   174 
  3   175 /* ------ END INCLUDE SEGMENT		apl_characters.incl.pl1 ----------------------------------- */
       85 
       86 
       87 /* program */
       88 
       89 /* copy input parameters */
       90 
       91 	sdb_ptr = P_sdb_ptr;
       92 	data_ptr = addr (P_data_ptr -> based_string (P_data_offset));
       93 
       94 /* initialize output parameters */
       95 
       96 	P_n_elements_transmitted = 0;
       97 	P_status, status = ""b;
       98 
       99 /* get ptrs to conversion tables, and extract commonly used values */
      100 
      101 	device_ptr = device_info_ptr;
      102 	conversion_ptr = conv_tab_ptr;
      103 
      104 	nl_addend = device_info.pad_info (baud_rate).nl_addend;
      105 	nl_multiplier = device_info.pad_info (baud_rate).nl_multiplier;
      106 	tab_addend = device_info.pad_info (baud_rate).tab_addend;
      107 	tab_multiplier = device_info.pad_info (baud_rate).tab_multiplier;
      108 
      109 	initial_column, col = actcol;			/* get current column */
      110 	shift = actshift;				/* pick up shift */
      111 
      112 	if shift
      113 	then shift = "11"b;				/* undefined...will cause leading shift to be emitted */
      114 
      115 	ereti = 0;				/* init stack index for enter */
      116 	whitesw = "0"b;				/* currently not moving carriage */
      117 	last_char_was_BS = "0"b;			/* was no last char, couldn't have been BS */
      118 	last_line_start, ini = 1;			/* get starting offset */
      119 	donesw = "0"b;				/* not done */
      120 	device_last_line_start,			/* start of last output line... */
      121 	     out_char = 1;				/* where to store in output buffer */
      122 
      123 /* **************************** READ A CHARACTER ********************* */
      124 r (0):
      125 loop:
      126 	if ini > length (data_string)
      127 	then do;
      128 		donesw = "1"b;
      129 		goto asblack;			/* done except for positioning carriage */
      130 	     end;
      131 
      132 	current_char = substr (data_string, ini, 1);	/* get char to process */
      133 	unspec (inchar) = unspec (current_char);
      134 	ini = ini + 1;				/* get ready to get next char */
      135 
      136 /* ***********************JUST KEEP TRACK OF CARRIAGE POSITION FOR WHITE CHARACTERS ***************************** */
      137 	if (inchar & "400"b3)			/* if too big for table, assume black */
      138 	then go to asblack;
      139 
      140 	if ^red_mode
      141 	then if type (binary (inchar, 9)).red
      142 	     then if stream_data_block.graphic
      143 		then go to asblack;			/* keep in graphic mode */
      144 		else go to loop;			/* otherwise discard it */
      145 
      146 /* This red mode stuff may still not be right for graphic mode... */
      147 
      148 	if type (binary (inchar, 9)).white		/* carriage movement */
      149 	then do;
      150 		if whitesw = "0"b
      151 		then do;
      152 			wcol = col;		/* this is  first white after black so init wcol */
      153 			whitesw = "1"b;		/* note we are in white mode */
      154 		     end;
      155 		i = binary (type (binary (inchar, 9)).move, 3);
      156 						/* i is movement type */
      157 		if i = 0
      158 		then wcol = wcol + 1;		/* blank */
      159 		else if i = 5
      160 		then do;				/* nl */
      161 			whitesw = "0"b;		/* treat it as black */
      162 			oldcol = col;		/* save for delay comp */
      163 			outchar = out (10);		/* output nl */
      164 			erets (0) = 1;
      165 			goto enter;		/* set up return and 'call' enter */
      166 r (1):
      167 			n_delays = divide (nl_addend + oldcol * nl_multiplier, 512, 17, 0);
      168 			call enter_delays (n_delays);
      169 		     end;
      170 		else if i = 3			/* tab */
      171 		then if stream_data_block.tab_width < 2 /* turned off */
      172 		     then wcol = wcol + 1;
      173 		     else wcol = wcol + stream_data_block.tab_width - mod (wcol, stream_data_block.tab_width);
      174 		else if i = 2			/* bs */
      175 		then if wcol > 0			/* and not at left margin */
      176 		     then wcol = wcol - 1;		/* then back up */
      177 		     else ;			/* else stay at margin */
      178 		else if i = 4			/* cr */
      179 		then if wcol = 0 then do;
      180 		     if out_char > length (write_buffer_overlay)
      181 		     then call flush_output_buffer;
      182 		     write_buffer (out_char) = "015"b3;
      183 		     out_char = out_char + 1;
      184 		end;
      185 		else wcol = 0;
      186 		goto loop;
      187 	     end;
      188 	else do;					/* character is a printing character */
      189 
      190 /* ****************************** POSITION CARRIAGE ************************* */
      191 asblack:
      192 		if whitesw
      193 		then do;
      194 			whitesw = "0"b;		/* this is first black after white */
      195 			if max_col > 3		/* don't get stuck in a loop */
      196 			then do while (wcol > max_col);
      197 						/* reduce below limit */
      198 				oldcol = col;
      199 				outchar = out (10);
      200 				erets (0) = 2;
      201 				goto enter;	/* output nl */
      202 r (2):
      203 				n_delays = divide (nl_addend + oldcol * nl_multiplier, 512, 17, 0);
      204 				call enter_delays (n_delays);
      205 				outchar = escape_character_device;
      206 						/* output escape char */
      207 				erets (0) = 3;
      208 				goto enter;
      209 r (3):
      210 				outchar = out (99); /* output a 'c' */
      211 				erets (0) = 4;
      212 				goto enter;
      213 r (4):
      214 				wcol = wcol - max_col + col;
      215 						/* set up target column */
      216 			     end;
      217 			if wcol < col		/* backward motion required */
      218 			then do;
      219 				if wcol = 0	/* if going to left margin */
      220 				then if out (13) ^= "602"b3
      221 						/* and cr available */
      222 				     then do;	/* use cr */
      223 					     outchar = out (13);
      224 					     erets (0) = 9;
      225 					     go to enter;
      226 					end;
      227 				erets (0) = 5;	/* not going to col 0 or no cr available */
      228 				do i = 1 to col - wcol;
      229 				     outchar = out (8);
      230 				     goto enter;
      231 r (5):
      232 				end;
      233 			     end;
      234 			else do;
      235 
      236 /* if in tab mode & worth using tab(s) */
      237 				if tabm & ((wcol - col) > 2)
      238 				then do;
      239 					if mod (col, tab_width) >= (tab_width - 2)
      240 						/* if not enough spaces before tab */
      241 					then do;
      242 						erets (0) = 6;
      243 						/* blanks */
      244 						do i = 1 to tab_width - mod (col, tab_width);
      245 						     outchar = out (32);
      246 						     goto enter;
      247 r (6):
      248 						end;
      249 					     end;
      250 					erets (0) = 7;
      251 					do i = 1
      252 					     to divide (wcol, tab_width, 17, 0) - divide (col, tab_width, 17, 0);
      253 					     oldcol = col;
      254 					     outchar = out (9);
      255 						/* tab char */
      256 					     goto enter;
      257 r (7):
      258 					     n_delays =
      259 						divide (tab_addend + (col - oldcol) * tab_multiplier, 512, 17, 0);
      260 					     call enter_delays (n_delays);
      261 					end;
      262 				     end;
      263 				if wcol > col	/* if blanks needed */
      264 				then do;
      265 					erets (0) = 8;
      266 					do i = 1 to wcol - col;
      267 					     outchar = out (32);
      268 					     goto enter;
      269 r (8):
      270 					end;
      271 				     end;
      272 
      273 			     end;
      274 		     end;
      275 r (9):
      276 		if donesw
      277 		then do;				/* if really done */
      278 
      279 /* **************** TRANSMIT CONTENTS OF THE CONVERSION BUFFER & RETURN **************** */
      280 
      281 			if shift & "10"b
      282 			then do;			/* if in upper case, emit final downshift */
      283 				if out_char > length (write_buffer_overlay)
      284 				then call flush_output_buffer;
      285 
      286 				write_buffer (out_char) = device_info.lower_case;
      287 				out_char = out_char + 1;
      288 				shift = "01"b;	/* now in LC */
      289 			     end;
      290 
      291 			call flush_output_buffer;
      292 			P_n_elements_transmitted = ini - 1;
      293 
      294 			actcol = col;
      295 			actshift = shift;		/* save present shift state (not used, really) */
      296 
      297 			if stream_data_block.error_mark_column > 0
      298 			then do;
      299 				i = stream_data_block.error_mark_column;
      300 				stream_data_block.error_mark_column = 0;
      301 				substr (error_mark_line, 1, i - 1) = "";
      302 				substr (error_mark_line, i, 2) = QAndSign || QNewLine;
      303 				call iox_$put_chars (stream_data_block.iocb_ptr, addr (error_mark_line), i + 1,
      304 				     status_code);
      305 			     end;
      306 			return;
      307 		     end;
      308 
      309 /* **************************** ENTER THE CHARACTER ************************* */
      310 		erets (0) = 0;			/* place data char */
      311 
      312 		if inchar & "400"b3			/*  if too big */
      313 		then outchar = "602"b3;		/* make look like octal escape */
      314 		else outchar = out (binary (inchar, 9));
      315 
      316 /* If we are in graphic output mode, and we are outputting an ASCII control character, and the tables
      317*   say to discard (600) or escape (602) the character, then pass it on unmolested.  The purpose of
      318*   graphic output mode is to enable an APL program to do terminal control functions ("plot mode") itself. */
      319 
      320 		if stream_data_block.graphic
      321 		then if binary (inchar, 9) < 32	/* no problem with these, just send 'em out */
      322 		     then outchar = inchar;
      323 		     else if (outchar = "602"b3) | (outchar = "600"b3)
      324 		     then outchar = inchar;		/* don't mess up these, either */
      325 
      326 /*		go to enter;		*/
      327 	     end;
      328 
      329 enter:
      330 	mode = outchar;				/* get shift code */
      331 	enchar = outchar & "177"b3;
      332 	if mode = "11"b				/* special action */
      333 	then do;
      334 		if enchar = "001"b3			/* if mark error */
      335 		then do;
      336 			stream_data_block.error_mark_column = col + 1;
      337 		     end;
      338 		else if enchar = "002"b3		/* if escape */
      339 		then do;
      340 			ereti = ereti + 1;		/* set up recursion */
      341 			erets (ereti) = 10;
      342 			outchar = escape_character_device;
      343 						/* escape char */
      344 			goto enter;
      345 r (10):
      346 			erets (ereti) = 11;		/* set up return */
      347 			do escape_index = 1 to 9 by 3;/* pick off 3-bit bytes */
      348 			     outchar = out (binary (substr (inchar, escape_index, 3), 3) + 48);
      349 			     goto enter;
      350 r (11):
      351 			end;
      352 			ereti = ereti - 1;
      353 			go to r (erets (ereti));
      354 		     end;
      355 		else if enchar = "003"b3		/* Conditional New Line */
      356 		then do;
      357 			if col > 0
      358 			then do;
      359 				ereti = ereti + 1;
      360 				erets (ereti) = 16;
      361 				outchar = out (10); /* nl */
      362 				go to enter;
      363 r (16):
      364 				ereti = ereti - 1;
      365 			     end;
      366 			else last_line_start = last_line_start + 1;
      367 						/* <NL><CNL> case...skip over CNL */
      368 			go to r (erets (ereti));
      369 		     end;
      370 		seqi = binary (enchar, 9) - 8;	/* else it is a character sequence */
      371 		if seqi >= 0
      372 		then do;
      373 			ereti = ereti + 1;
      374 			erets (ereti) = 12;		/* save return */
      375 			sequence_ptr = addrel (sequence_table_ptr, seqi);
      376 						/* pointer to given sequence */
      377 			do seqi = 1 to sequence.size;
      378 			     outchar = sequence.characters (seqi);
      379 			     goto enter;
      380 r (12):
      381 			end;
      382 			ereti = ereti - 1;
      383 		     end;
      384 		go to r (erets (ereti));
      385 	     end;
      386 	ei = binary (conversions.device_move (binary (enchar, 9)), 6);
      387 						/* update col */
      388 	go to new_col (ei);
      389 
      390 new_col (0):					/* normal */
      391 	col = col + 1;
      392 	go to end_col;
      393 
      394 new_col (2):					/* backspace */
      395 	col = col - 1;
      396 	go to end_col;
      397 
      398 new_col (3):					/* tab */
      399 	if stream_data_block.tab_width < 2
      400 	then col = col + 1;
      401 	else col = col + stream_data_block.tab_width - mod (col, stream_data_block.tab_width);
      402 
      403 	if max_col > 0
      404 	then if col > max_col
      405 	     then if max_col < stream_data_block.tab_width/* hmm. shouldn't be permitted. */
      406 		then go to r (erets (ereti));
      407 	go to end_col;
      408 
      409 new_col (4):					/* carriage return */
      410 	initial_column, col = 0;
      411 	go to end_col;
      412 
      413 new_col (5):					/* new line */
      414 	stream_data_block.canonicalization_index = 1;	/* don't need this stuff anymore */
      415 	last_line_start = ini;
      416 	device_last_line_start = out_char + 1;
      417 	if mode & shift				/* KLUDGE: tables make NL lower-case, skip shift char */
      418 	then device_last_line_start = device_last_line_start + 1;
      419 
      420 	initial_column, col = 0;
      421 	actline = actline + 1;
      422 	go to end_col;
      423 
      424 new_col (6):					/* prefix */
      425 	col = col - 1;				/* prefix */
      426 	go to end_col;
      427 
      428 new_col (10):					/* 2 character sequences at device */
      429 	col = col + 2;
      430 
      431 new_col (1):
      432 new_col (7):
      433 new_col (8):
      434 new_col (9):
      435 end_col:
      436 	if max_col > 3				/* don't loop */
      437 	then if col > max_col			/* check for end of carriage */
      438 	     then if col > 3			/* don't loop */
      439 		then do;
      440 			oldoutchar = outchar;
      441 			outchar = out (10);		/* nl */
      442 			ereti = ereti + 1;
      443 			erets (ereti) = 13;
      444 			goto enter;
      445 r (13):
      446 			n_delays = divide (nl_addend + binary (max_col, 9) * nl_multiplier, 512, 17, 0);
      447 			call enter_delays (n_delays);
      448 			outchar = escape_character_device;
      449 						/* output escape char */
      450 			erets (ereti) = 14;
      451 			goto enter;
      452 r (14):
      453 			outchar = out (99);		/* output 'c' */
      454 			erets (ereti) = 15;
      455 			goto enter;
      456 r (15):
      457 			ereti = ereti - 1;		/* setup return */
      458 			outchar = oldoutchar;	/* put original character */
      459 			goto enter;
      460 		     end;
      461 
      462 	if mode & shift				/* if shift needed */
      463 	then do;
      464 		if out_char > length (write_buffer_overlay)
      465 		then call flush_output_buffer;
      466 
      467 		if mode & "01"b			/* if char must be upper case */
      468 		then write_buffer (out_char) = device_info.upper_case;
      469 		else write_buffer (out_char) = device_info.lower_case;
      470 		out_char = out_char + 1;
      471 		shift = ^mode;
      472 	     end;
      473 
      474 	if out_char > length (write_buffer_overlay)
      475 	then call flush_output_buffer;
      476 
      477 	write_buffer (out_char) = enchar;		/* store actual character */
      478 	out_char = out_char + 1;
      479 
      480 	if binary (conversions.device_move (binary (enchar, 7)), 6) = 2
      481 						/* BS */
      482 	then do;
      483 		n_delays = device_info.pad_info (baud_rate).bs_n_pads;
      484 		if n_delays > 0
      485 		then if ^last_char_was_BS		/* only pad first BS in a sequence */
      486 		     then call enter_delays (n_delays);
      487 
      488 		last_char_was_BS = "1"b;
      489 	     end;
      490 	else last_char_was_BS = "0"b;
      491 
      492 	go to r (erets (ereti));
      493 
      494 enter_delays:
      495      procedure (P_n_delays);
      496 
      497 /* parameters */
      498 
      499 declare	P_n_delays	fixed bin (21);
      500 
      501 /* automatic */
      502 
      503 declare	padx		fixed bin (21);
      504 
      505 /* program */
      506 
      507 	if out_char + P_n_delays > length (write_buffer_overlay)
      508 	then call flush_output_buffer;
      509 
      510 	do padx = 1 to P_n_delays;
      511 	     write_buffer (out_char) = delay_character;
      512 	     out_char = out_char + 1;
      513 	end;
      514 
      515      end enter_delays;
      516 
      517 flush_output_buffer:
      518      procedure ();
      519 
      520 	call iox_$put_chars (stream_data_block.device_iocb_ptr, addr (write_buffer), out_char - 1, status_code);
      521 
      522 /* If sdb.read_back = read_back_output, and output does not end in new-line,
      523*   save the partial output line in the input buffer so that the input the user types
      524*   will be read back in and re-canonicalized.
      525*
      526*   If sdb.read_back = read_back_spaces, substitute spaces for the actual characters,
      527*   at the rate of one space per column of output, no matter how many characters it took.
      528*   Since spaces have been converted to tabs, and delay characters have been inserted, the
      529*   number of characters output is not relevant.
      530*
      531*   If sdb.read_back = read_back_input, skip this operation. */
      532 
      533 	if last_line_start < length (data_string)	/* if output does not end in NL */
      534 	then if read_back ^= read_back_input
      535 	     then do;
      536 		     if read_back = read_back_output
      537 		     then do;
      538 			     i = (out_char - 1) - device_last_line_start + 1;
      539 			     substr (canonicalization_buffer, canonicalization_index, i) =
      540 				substr (write_buffer_overlay, device_last_line_start, i);
      541 			end;
      542 		     else do;			/* read back spaces */
      543 			     i = col - initial_column;
      544 			     if i > 0
      545 			     then unspec (substr (canonicalization_buffer, canonicalization_index, i)) =
      546 				     copy (out (32), i);
      547 						/* "i" spaces */
      548 			end;
      549 		     canonicalization_index = max (1, canonicalization_index + i);
      550 						/* i can be negative */
      551 		end;
      552 
      553 	device_last_line_start, out_char = 1;
      554 	return;
      555 
      556      end flush_output_buffer;
      557 
      558      end /* apl_dim_write_ */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/29/83  1346.3  apl_dim_write_.pl1                >special_ldd>on>apl.1129>apl_dim_write_.pl1
83           1    03/27/82  0429.8  apl_dim_sdb.incl.pl1              >ldd>include>apl_dim_sdb.incl.pl1
84           2    03/27/82  0438.6  apl_dim_table.incl.pl1            >ldd>include>apl_dim_table.incl.pl1
85           3    03/27/82  0438.6  apl_characters.incl.pl1           >ldd>include>apl_characters.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_data_length                          parameter       fixed bin(17,0)          dcl 37 ref 32 124 132 533
P_data_offset                          parameter       fixed bin(17,0)          dcl 37 ref 32 92
P_data_ptr                             parameter       pointer                  dcl 37 ref 32 92
P_n_delays                             parameter       fixed bin(21,0)          dcl 499 ref 494 507 510
P_n_elements_transmitted               parameter       fixed bin(17,0)          dcl 37 set ref 32 96* 292*
P_sdb_ptr                              parameter       pointer                  dcl 37 ref 32 91
P_status                               parameter       bit(72)                  unaligned dcl 37 set ref 32 97*
QAndSign                               constant        char(1)                  initial unaligned dcl 3-11 ref 302
QNewLine                               constant        char(1)                  initial unaligned dcl 3-11 ref 302
actcol                   50            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 109 294*
actline                  51            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 421* 421
actshift                 52            based           bit(2)                   initial level 2 packed unaligned dcl 1-6 set ref 110
                                                                                  295*
addr                                                   builtin function         dcl 78 ref 92 180 283 303 303 303 464 474 507 520
                                                                                  520 520 539
addrel                                                 builtin function         dcl 78 ref 375
based_string                           based           char(1)                  array unaligned dcl 67 set ref 92
baud_rate                62            based           fixed bin(17,0)          initial level 2 dcl 1-6 ref 104 105 106 107 483
binary                                                 builtin function         dcl 78 ref 140 148 155 155 314 320 348 370 386 386
                                                                                  445 480 480
bs_n_pads                17            based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-13 ref 483
canonicalization_buffer
                        163            based           char(512)                level 2 dcl 1-6 set ref 539* 544*
canonicalization_index
                         54            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 413* 539 544 549*
                                                                                  549
characters                0(09)        based           bit(9)                   array level 2 packed unaligned dcl 2-55 ref 378
col                             000117 automatic       fixed bin(9,0)           dcl 49 set ref 109* 152 162 198 213 217 228 237 239
                                                                                  244 251 253 257 263 266 294 336 357 390* 390 394*
                                                                                  394 398* 398 401* 401 401 403 409* 420* 424* 424
                                                                                  428* 428 431 431 543
conv_tab_ptr             36            based           pointer                  initial level 2 dcl 1-6 ref 102
conversion_ptr                  002216 automatic       pointer                  dcl 2-3 set ref 102* 163 199 209 219 223 229 245 254
                                                                                  267 314 348 361 386 441 452 480 544
conversions                            based           structure                level 1 dcl 2-40
copy                                                   builtin function         dcl 78 ref 544
current_char                    000102 automatic       char(1)                  unaligned dcl 45 set ref 132* 133
data_ptr                        000100 automatic       pointer                  dcl 45 set ref 92* 124 132 533
data_string                            based           char                     unaligned dcl 67 ref 124 132 533
delay_character          13            based           bit(9)                   level 2 packed unaligned dcl 2-13 ref 511
device_info                            based           structure                level 1 dcl 2-13
device_info_ptr          34            based           pointer                  initial level 2 dcl 1-6 ref 101
device_iocb_ptr          26            based           pointer                  level 2 dcl 1-6 set ref 520*
device_last_line_start          000206 automatic       fixed bin(17,0)          dcl 49 set ref 120* 416* 417* 417 538 539 553*
device_move             240            based           bit(6)                   array level 2 packed unaligned dcl 2-40 ref 386 480
device_ptr                      002220 automatic       pointer                  dcl 2-3 set ref 101* 104 105 106 107 205 286 342 448
                                                                                  467 469 483 511
divide                                                 builtin function         dcl 78 ref 166 202 251 251 257 445
donesw                          000122 automatic       bit(1)                   dcl 49 set ref 119* 128* 275
ei                              000114 automatic       fixed bin(21,0)          dcl 49 set ref 386* 388
enchar                          000130 automatic       bit(9)                   unaligned dcl 49 set ref 331* 334 338 355 370 386
                                                                                  477 480
ereti                           000115 automatic       fixed bin(21,0)          dcl 49 set ref 115* 340* 340 341 345 352* 352 353
                                                                                  359* 359 360 363* 363 368 373* 373 374 382* 382
                                                                                  384 403 442* 442 443 450 454 456* 456 492
erets                           000133 automatic       fixed bin(17,0)          array dcl 49 set ref 164* 200* 207* 211* 224* 227*
                                                                                  242* 250* 265* 310* 341* 345* 353 360* 368 374*
                                                                                  384 403 443* 450* 454* 492
error_mark_column        57            based           fixed bin(17,0)          initial level 2 dcl 1-6 set ref 297 299 300* 336*
error_mark_line                 000140 automatic       char(150)                unaligned dcl 49 set ref 301* 302* 303 303
escape_character_device
                         13(27)        based           bit(9)                   level 2 packed unaligned dcl 2-13 ref 205 342 448
escape_index                    000116 automatic       fixed bin(21,0)          dcl 49 set ref 347* 348*
graphic                  52(04)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 ref 140 320
i                               000110 automatic       fixed bin(21,0)          dcl 49 set ref 155* 157 159 170 174 178 228* 244*
                                                                                  251* 266* 299* 301 302 303 538* 539 539 543* 544
                                                                                  544 544 549
inchar                          000127 automatic       bit(9)                   unaligned dcl 49 set ref 133* 137 140 148 155 312
                                                                                  314 320 320 323 348
ini                             000111 automatic       fixed bin(21,0)          dcl 49 set ref 118* 124 132 134* 134 292 415
initial_column                  000121 automatic       fixed bin(9,0)           dcl 49 set ref 109* 409* 420* 543
internal_type            63            based           bit(9)                   array level 2 packed unaligned dcl 1-6 ref 140 140
                                                                                  148 148 155 155
iocb_ptr                 30            based           pointer                  level 2 dcl 1-6 set ref 303*
iox_$put_chars                  000010 constant        entry                    external dcl 74 ref 303 520
last_char_was_BS                000123 automatic       bit(1)                   dcl 49 set ref 117* 484 488* 490*
last_line_start                 000207 automatic       fixed bin(17,0)          dcl 49 set ref 118* 366* 366 415* 533
length                                                 builtin function         dcl 78 ref 124 180 283 464 474 507 533
lower_case               13(18)        based           bit(9)                   level 2 packed unaligned dcl 2-13 ref 286 469
max                                                    builtin function         dcl 78 ref 549
max_col                  46            based           fixed bin(17,0)          initial level 2 dcl 1-6 ref 195 195 213 403 403 403
                                                                                  431 431 445
mod                                                    builtin function         dcl 78 ref 173 239 244 401
mode                            000126 automatic       bit(2)                   unaligned dcl 49 set ref 329* 332 417 462 467 471
move                      0(06)        defined         bit(3)                   array level 2 packed unaligned dcl 1-70 ref 155
n_delays                        000103 automatic       fixed bin(21,0)          dcl 47 set ref 166* 168* 202* 204* 257* 260* 445*
                                                                                  447* 483* 484 484*
nl_addend                15            based           fixed bin(17,0)          array level 3 in structure "device_info" packed
                                                                                  unaligned dcl 2-13 in procedure "apl_dim_write_"
                                                                                  ref 104
nl_addend                       000104 automatic       fixed bin(21,0)          dcl 47 in procedure "apl_dim_write_" set ref 104*
                                                                                  166 202 445
nl_multiplier            15(18)        based           fixed bin(17,0)          array level 3 in structure "device_info" packed
                                                                                  unaligned dcl 2-13 in procedure "apl_dim_write_"
                                                                                  ref 105
nl_multiplier                   000105 automatic       fixed bin(21,0)          dcl 47 in procedure "apl_dim_write_" set ref 105*
                                                                                  166 202 445
oldcol                          000120 automatic       fixed bin(9,0)           dcl 49 set ref 162* 166 198* 202 253* 257
oldoutchar                      000132 automatic       bit(9)                   unaligned dcl 49 set ref 440* 458
out                                    based           bit(9)                   array level 2 packed unaligned dcl 2-40 ref 163 199
                                                                                  209 219 223 229 245 254 267 314 348 361 441 452
                                                                                  544
out_char                        000210 automatic       fixed bin(17,0)          dcl 49 set ref 120* 180 182 183* 183 283 286 287*
                                                                                  287 416 464 467 469 470* 470 474 477 478* 478 507
                                                                                  511 512* 512 520 538 553*
outchar                         000131 automatic       bit(9)                   unaligned dcl 49 set ref 163* 199* 205* 209* 223*
                                                                                  229* 245* 254* 267* 312* 314* 320* 323 323 323*
                                                                                  329 331 342* 348* 361* 378* 440 441* 448* 452*
                                                                                  458*
pad_info                 15            based           structure                array level 2 dcl 2-13
padx                            002250 automatic       fixed bin(21,0)          dcl 503 set ref 510*
read_back                53            based           fixed bin(17,0)          initial level 2 dcl 1-6 ref 533 536
read_back_input                        constant        fixed bin(17,0)          initial dcl 1-82 ref 533
read_back_output                       constant        fixed bin(17,0)          initial dcl 1-82 ref 536
red                       0(01)        defined         bit(1)                   array level 2 packed unaligned dcl 1-70 ref 140
red_mode                 52(08)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 ref 140
sdb_ptr                         002212 automatic       pointer                  dcl 1-4 set ref 91* 101 102 104 105 106 107 109 110
                                                                                  140 140 140 148 155 170 173 173 195 195 213 237
                                                                                  239 239 244 244 251 251 294 295 297 299 300 303
                                                                                  320 336 375 398 401 401 403 403 403 403 413 421
                                                                                  421 431 431 445 483 520 533 536 539 539 544 544
                                                                                  549 549
seqi                            000113 automatic       fixed bin(21,0)          dcl 49 set ref 370* 371 375 377* 378*
sequence                               based           structure                level 1 dcl 2-55
sequence_ptr                    002222 automatic       pointer                  dcl 2-3 set ref 375* 377 378
sequence_table_ptr       32            based           pointer                  level 2 dcl 1-6 ref 375
shift                           000125 automatic       bit(2)                   unaligned dcl 49 set ref 110* 112 112* 281 288* 295
                                                                                  417 462 471*
size                                   based           fixed bin(8,0)           level 2 packed unaligned dcl 2-55 ref 377
status                          002214 automatic       bit(72)                  unaligned dcl 1-88 set ref 97* 303 520
status_bits                            based           structure                level 1 unaligned dcl 1-90
status_code                            based           fixed bin(35,0)          level 2 dcl 1-90 set ref 303* 520*
stream_data_block                      based           structure                level 1 dcl 1-6
substr                                                 builtin function         dcl 78 set ref 132 301* 302* 348 539* 539 544
tab_addend               16            based           fixed bin(17,0)          array level 3 in structure "device_info" packed
                                                                                  unaligned dcl 2-13 in procedure "apl_dim_write_"
                                                                                  ref 106
tab_addend                      000106 automatic       fixed bin(21,0)          dcl 47 in procedure "apl_dim_write_" set ref 106*
                                                                                  257
tab_multiplier           16(18)        based           fixed bin(17,0)          array level 3 in structure "device_info" packed
                                                                                  unaligned dcl 2-13 in procedure "apl_dim_write_"
                                                                                  ref 107
tab_multiplier                  000107 automatic       fixed bin(21,0)          dcl 47 in procedure "apl_dim_write_" set ref 107*
                                                                                  257
tab_width                61            based           fixed bin(17,0)          initial level 2 dcl 1-6 ref 170 173 173 239 239 244
                                                                                  244 251 251 398 401 401 403
tabm                     52(02)        based           bit(1)                   initial level 2 packed unaligned dcl 1-6 ref 237
type                                   defined         structure                array level 1 packed unaligned dcl 1-70
unspec                                                 builtin function         dcl 78 set ref 133* 133 544*
upper_case               13(09)        based           bit(9)                   level 2 packed unaligned dcl 2-13 ref 467
wcol                            000112 automatic       fixed bin(21,0)          dcl 49 set ref 152* 157* 157 170* 170 173* 173 173
                                                                                  174 174* 174 178 185* 195 213* 213 217 219 228 237
                                                                                  251 263 266
white                                  defined         bit(1)                   array level 2 packed unaligned dcl 1-70 ref 148
whitesw                         000124 automatic       bit(1)                   dcl 49 set ref 116* 150 153* 161* 191 194*
write_buffer                    000211 automatic       bit(9)                   array level 2 packed unaligned dcl 49 set ref 182*
                                                                                  286* 467* 469* 477* 511* 520 520
write_buffer_overlay                   based           char(4096)               dcl 67 ref 180 283 464 474 507 539
write_struc                     000211 automatic       structure                level 1 dcl 49 set ref 180 283 464 474 507 539

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
QAlpha                                 internal static char(1)                  initial unaligned dcl 3-11
QApostrophe                            internal static char(1)                  initial unaligned dcl 3-11
QBackSlash                             internal static char(1)                  initial unaligned dcl 3-11
QBackSlashHyphen                       internal static char(1)                  initial unaligned dcl 3-11
QBackSpace                             internal static char(1)                  initial unaligned dcl 3-11
QBell                                  internal static char(1)                  initial unaligned dcl 3-11
QCap                                   internal static char(1)                  initial unaligned dcl 3-11
QCeiling                               internal static char(1)                  initial unaligned dcl 3-11
QCentSign                              internal static char(1)                  initial unaligned dcl 3-11
QCircle                                internal static char(1)                  initial unaligned dcl 3-11
QCircleBackSlash                       internal static char(1)                  initial unaligned dcl 3-11
QCircleBar                             internal static char(1)                  initial unaligned dcl 3-11
QCircleHyphen                          internal static char(1)                  initial unaligned dcl 3-11
QCircleSlash                           internal static char(1)                  initial unaligned dcl 3-11
QCircleStar                            internal static char(1)                  initial unaligned dcl 3-11
QColon                                 internal static char(1)                  initial unaligned dcl 3-11
QComma                                 internal static char(1)                  initial unaligned dcl 3-11
QCommaHyphen                           internal static char(1)                  initial unaligned dcl 3-11
QConditionalNewLine                    internal static char(1)                  initial unaligned dcl 3-11
QCup                                   internal static char(1)                  initial unaligned dcl 3-11
QDeCode                                internal static char(1)                  initial unaligned dcl 3-11
QDel                                   internal static char(1)                  initial unaligned dcl 3-11
QDelTilde                              internal static char(1)                  initial unaligned dcl 3-11
QDelta                                 internal static char(1)                  initial unaligned dcl 3-11
QDelta_                                internal static char(1)                  initial unaligned dcl 3-11
QDiamond                               internal static char(1)                  initial unaligned dcl 3-11
QDiaresis                              internal static char(1)                  initial unaligned dcl 3-11
QDivision                              internal static char(1)                  initial unaligned dcl 3-11
QDollar                                internal static char(1)                  initial unaligned dcl 3-11
QDomino                                internal static char(1)                  initial unaligned dcl 3-11
QDownArrow                             internal static char(1)                  initial unaligned dcl 3-11
QEight                                 internal static char(1)                  initial unaligned dcl 3-11
QEight_                                internal static char(1)                  initial unaligned dcl 3-11
QEnCode                                internal static char(1)                  initial unaligned dcl 3-11
QEpsilon                               internal static char(1)                  initial unaligned dcl 3-11
QEqual                                 internal static char(1)                  initial unaligned dcl 3-11
QExclamation                           internal static char(1)                  initial unaligned dcl 3-11
QExecuteSign                           internal static char(1)                  initial unaligned dcl 3-11
QFive                                  internal static char(1)                  initial unaligned dcl 3-11
QFive_                                 internal static char(1)                  initial unaligned dcl 3-11
QFloor                                 internal static char(1)                  initial unaligned dcl 3-11
QFormatSign                            internal static char(1)                  initial unaligned dcl 3-11
QFour                                  internal static char(1)                  initial unaligned dcl 3-11
QFour_                                 internal static char(1)                  initial unaligned dcl 3-11
QGradeDown                             internal static char(1)                  initial unaligned dcl 3-11
QGradeUp                               internal static char(1)                  initial unaligned dcl 3-11
QGreaterOrEqual                        internal static char(1)                  initial unaligned dcl 3-11
QGreaterThan                           internal static char(1)                  initial unaligned dcl 3-11
QIBeam                                 internal static char(1)                  initial unaligned dcl 3-11
QIota                                  internal static char(1)                  initial unaligned dcl 3-11
QLamp                                  internal static char(1)                  initial unaligned dcl 3-11
QLeftArrow                             internal static char(1)                  initial unaligned dcl 3-11
QLeftBrace                             internal static char(1)                  initial unaligned dcl 3-11
QLeftBracket                           internal static char(1)                  initial unaligned dcl 3-11
QLeftLump                              internal static char(1)                  initial unaligned dcl 3-11
QLeftParen                             internal static char(1)                  initial unaligned dcl 3-11
QLeftTack                              internal static char(1)                  initial unaligned dcl 3-11
QLessOrEqual                           internal static char(1)                  initial unaligned dcl 3-11
QLessThan                              internal static char(1)                  initial unaligned dcl 3-11
QLetterA                               internal static char(1)                  initial unaligned dcl 3-11
QLetterA_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterB                               internal static char(1)                  initial unaligned dcl 3-11
QLetterB_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterC                               internal static char(1)                  initial unaligned dcl 3-11
QLetterC_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterD                               internal static char(1)                  initial unaligned dcl 3-11
QLetterD_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterE                               internal static char(1)                  initial unaligned dcl 3-11
QLetterE_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterF                               internal static char(1)                  initial unaligned dcl 3-11
QLetterF_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterG                               internal static char(1)                  initial unaligned dcl 3-11
QLetterG_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterH                               internal static char(1)                  initial unaligned dcl 3-11
QLetterH_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterI                               internal static char(1)                  initial unaligned dcl 3-11
QLetterI_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterJ                               internal static char(1)                  initial unaligned dcl 3-11
QLetterJ_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterK                               internal static char(1)                  initial unaligned dcl 3-11
QLetterK_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterL                               internal static char(1)                  initial unaligned dcl 3-11
QLetterL_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterM                               internal static char(1)                  initial unaligned dcl 3-11
QLetterM_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterN                               internal static char(1)                  initial unaligned dcl 3-11
QLetterN_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterO                               internal static char(1)                  initial unaligned dcl 3-11
QLetterO_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterP                               internal static char(1)                  initial unaligned dcl 3-11
QLetterP_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterQ                               internal static char(1)                  initial unaligned dcl 3-11
QLetterQ_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterR                               internal static char(1)                  initial unaligned dcl 3-11
QLetterR_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterS                               internal static char(1)                  initial unaligned dcl 3-11
QLetterS_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterT                               internal static char(1)                  initial unaligned dcl 3-11
QLetterT_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterU                               internal static char(1)                  initial unaligned dcl 3-11
QLetterU_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterV                               internal static char(1)                  initial unaligned dcl 3-11
QLetterV_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterW                               internal static char(1)                  initial unaligned dcl 3-11
QLetterW_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterX                               internal static char(1)                  initial unaligned dcl 3-11
QLetterX_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterY                               internal static char(1)                  initial unaligned dcl 3-11
QLetterY_                              internal static char(1)                  initial unaligned dcl 3-11
QLetterZ                               internal static char(1)                  initial unaligned dcl 3-11
QLetterZ_                              internal static char(1)                  initial unaligned dcl 3-11
QLineFeed                              internal static char(1)                  initial unaligned dcl 3-11
QMarkError                             internal static char(1)                  initial unaligned dcl 3-11
QMinus                                 internal static char(1)                  initial unaligned dcl 3-11
QNandSign                              internal static char(1)                  initial unaligned dcl 3-11
QNine                                  internal static char(1)                  initial unaligned dcl 3-11
QNine_                                 internal static char(1)                  initial unaligned dcl 3-11
QNorSign                               internal static char(1)                  initial unaligned dcl 3-11
QNotEqual                              internal static char(1)                  initial unaligned dcl 3-11
QOmega                                 internal static char(1)                  initial unaligned dcl 3-11
QOne                                   internal static char(1)                  initial unaligned dcl 3-11
QOne_                                  internal static char(1)                  initial unaligned dcl 3-11
QOrSign                                internal static char(1)                  initial unaligned dcl 3-11
QPeriod                                internal static char(1)                  initial unaligned dcl 3-11
QPlus                                  internal static char(1)                  initial unaligned dcl 3-11
QQuad                                  internal static char(1)                  initial unaligned dcl 3-11
QQuadQuote                             internal static char(1)                  initial unaligned dcl 3-11
QQuestion                              internal static char(1)                  initial unaligned dcl 3-11
QRho                                   internal static char(1)                  initial unaligned dcl 3-11
QRightArrow                            internal static char(1)                  initial unaligned dcl 3-11
QRightBrace                            internal static char(1)                  initial unaligned dcl 3-11
QRightBracket                          internal static char(1)                  initial unaligned dcl 3-11
QRightLump                             internal static char(1)                  initial unaligned dcl 3-11
QRightParen                            internal static char(1)                  initial unaligned dcl 3-11
QRightTack                             internal static char(1)                  initial unaligned dcl 3-11
QSemiColon                             internal static char(1)                  initial unaligned dcl 3-11
QSeven                                 internal static char(1)                  initial unaligned dcl 3-11
QSeven_                                internal static char(1)                  initial unaligned dcl 3-11
QSix                                   internal static char(1)                  initial unaligned dcl 3-11
QSix_                                  internal static char(1)                  initial unaligned dcl 3-11
QSlash                                 internal static char(1)                  initial unaligned dcl 3-11
QSlashHyphen                           internal static char(1)                  initial unaligned dcl 3-11
QSmallCircle                           internal static char(1)                  initial unaligned dcl 3-11
QSpace                                 internal static char(1)                  initial unaligned dcl 3-11
QStar                                  internal static char(1)                  initial unaligned dcl 3-11
QTab                                   internal static char(1)                  initial unaligned dcl 3-11
QThree                                 internal static char(1)                  initial unaligned dcl 3-11
QThree_                                internal static char(1)                  initial unaligned dcl 3-11
QTilde                                 internal static char(1)                  initial unaligned dcl 3-11
QTimes                                 internal static char(1)                  initial unaligned dcl 3-11
QTwo                                   internal static char(1)                  initial unaligned dcl 3-11
QTwo_                                  internal static char(1)                  initial unaligned dcl 3-11
QUnderLine                             internal static char(1)                  initial unaligned dcl 3-11
QUpArrow                               internal static char(1)                  initial unaligned dcl 3-11
QUpperMinus                            internal static char(1)                  initial unaligned dcl 3-11
QVerticalBar                           internal static char(1)                  initial unaligned dcl 3-11
QZero                                  internal static char(1)                  initial unaligned dcl 3-11
QZero_                                 internal static char(1)                  initial unaligned dcl 3-11
baud_rate_110                          internal static fixed bin(17,0)          initial dcl 2-6
baud_rate_1200                         internal static fixed bin(17,0)          initial dcl 2-6
baud_rate_150_or_134                   internal static fixed bin(17,0)          initial dcl 2-6
baud_rate_300                          internal static fixed bin(17,0)          initial dcl 2-6
compression_in                         based           structure                level 1 dcl 2-59
compression_out                        based           structure                level 1 dcl 2-63
n                                      automatic       fixed bin(17,0)          dcl 2-3
read_back_names                        internal static char(16)                 initial array unaligned dcl 1-79
read_back_spaces                       internal static fixed bin(17,0)          initial dcl 1-82

NAMES DECLARED BY EXPLICIT CONTEXT.
apl_dim_write_                  000050 constant        entry                    external dcl 32
asblack                         000340 constant        label                    dcl 191 ref 129 137 140
end_col                         001235 constant        label                    dcl 431 ref 392 396 407 411 422 426
enter                           000753 constant        label                    dcl 329 ref 165 201 208 212 225 230 246 256 268 344
                                                                                  349 362 379 444 451 455 459
enter_delays                    001422 constant        entry                    internal dcl 494 ref 168 204 260 447 484
flush_output_buffer             001453 constant        entry                    internal dcl 517 ref 180 283 291 464 474 507
loop                            000146 constant        label                    dcl 124 ref 144 186
new_col                         000021 constant        label                    array(0:10) dcl 390 ref 388
r                               000000 constant        label                    array(0:16) dcl 124 ref 353 368 384 403 492

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1634        1646    1577        1644
Length      2066    1577        12         203      35           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
apl_dim_write_                     1229 external procedure  is an external procedure.  
enter_delays                            internal procedure  shares stack frame of external procedure apl_dim_write_.  
flush_output_buffer                     internal procedure  shares stack frame of external procedure apl_dim_write_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
apl_dim_write_           000100 data_ptr                    apl_dim_write_
                         000102 current_char                apl_dim_write_
                         000103 n_delays                    apl_dim_write_
                         000104 nl_addend                   apl_dim_write_
                         000105 nl_multiplier               apl_dim_write_
                         000106 tab_addend                  apl_dim_write_
                         000107 tab_multiplier              apl_dim_write_
                         000110 i                           apl_dim_write_
                         000111 ini                         apl_dim_write_
                         000112 wcol                        apl_dim_write_
                         000113 seqi                        apl_dim_write_
                         000114 ei                          apl_dim_write_
                         000115 ereti                       apl_dim_write_
                         000116 escape_index                apl_dim_write_
                         000117 col                         apl_dim_write_
                         000120 oldcol                      apl_dim_write_
                         000121 initial_column              apl_dim_write_
                         000122 donesw                      apl_dim_write_
                         000123 last_char_was_BS            apl_dim_write_
                         000124 whitesw                     apl_dim_write_
                         000125 shift                       apl_dim_write_
                         000126 mode                        apl_dim_write_
                         000127 inchar                      apl_dim_write_
                         000130 enchar                      apl_dim_write_
                         000131 outchar                     apl_dim_write_
                         000132 oldoutchar                  apl_dim_write_
                         000133 erets                       apl_dim_write_
                         000140 error_mark_line             apl_dim_write_
                         000206 device_last_line_start      apl_dim_write_
                         000207 last_line_start             apl_dim_write_
                         000210 out_char                    apl_dim_write_
                         000211 write_struc                 apl_dim_write_
                         002212 sdb_ptr                     apl_dim_write_
                         002214 status                      apl_dim_write_
                         002216 conversion_ptr              apl_dim_write_
                         002220 device_ptr                  apl_dim_write_
                         002222 sequence_ptr                apl_dim_write_
                         002250 padx                        enter_delays

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              mod_fx1             shorten_stack       ext_entry           repeat
set_bs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$put_chars

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000042        91 000055        92 000061        96 000066        97 000067       101 000075       102 000077
    104 000101       105 000107       106 000113       107 000116       109 000122       110 000125       112 000130
    115 000133       116 000134       117 000135       118 000136       119 000142       120 000143       124 000146
    128 000152       129 000154       132 000155       133 000162       134 000164       137 000165       140 000171
    144 000210       148 000211       150 000222       152 000224       153 000226       155 000230       157 000237
    159 000243       161 000245       162 000246       163 000250       164 000255       165 000257       166 000260
    168 000265       169 000267       170 000270       173 000277       174 000310       177 000316       178 000317
    180 000323       182 000327       183 000334       184 000335       185 000336       186 000337       191 000340
    194 000342       195 000343       198 000354       199 000356       200 000363       201 000365       202 000366
    204 000373       205 000375       207 000401       208 000403       209 000404       211 000410       212 000412
    213 000413       216 000420       217 000421       219 000424       223 000435       224 000436       225 000440
    227 000441       228 000443       229 000453       230 000457       231 000460       233 000462       237 000463
    239 000472       242 000502       244 000505       245 000515       246 000521       247 000522       250 000524
    251 000526       253 000543       254 000545       256 000552       257 000553       260 000561       261 000563
    263 000565       265 000570       266 000572       267 000603       268 000607       269 000610       275 000612
    281 000614       283 000617       286 000623       287 000631       288 000632       291 000634       292 000635
    294 000641       295 000644       297 000650       299 000652       300 000653       301 000654       302 000660
    303 000667       306 000710       310 000711       312 000712       314 000721       320 000730       323 000743
    329 000753       331 000756       332 000761       334 000764       336 000767       337 000773       338 000774
    340 000776       341 000777       342 001002       344 001006       345 001007       347 001012       348 001017
    349 001033       350 001034       352 001037       353 001041       355 001044       357 001046       359 001050
    360 001051       361 001054       362 001061       363 001062       365 001064       366 001065       368 001066
    370 001071       371 001074       373 001075       374 001076       375 001101       377 001106       378 001117
    379 001125       380 001126       382 001130       384 001132       386 001135       388 001147       390 001150
    392 001151       394 001152       396 001154       398 001155       401 001163       403 001173       407 001204
    409 001205       411 001207       413 001210       415 001213       416 001215       417 001220       420 001224
    421 001226       422 001227       424 001230       426 001232       428 001233       431 001235       440 001246
    441 001250       442 001255       443 001256       444 001261       445 001262       447 001270       448 001272
    450 001276       451 001301       452 001302       454 001306       455 001311       456 001312       458 001314
    459 001316       462 001317       464 001322       467 001326       469 001340       470 001346       471 001347
    474 001352       477 001356       478 001363       480 001364       483 001377       484 001406       488 001413
    489 001415       490 001416       492 001417       494 001422       507 001424       510 001431       511 001441
    512 001447       513 001450       515 001452       517 001453       520 001454       533 001477       536 001507
    538 001511       539 001516       541 001523       543 001524       544 001527       548 001556       549 001557
    553 001565       554 001570


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
