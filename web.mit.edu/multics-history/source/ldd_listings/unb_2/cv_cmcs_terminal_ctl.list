	COMPILATION LISTING OF SEGMENT cv_cmcs_terminal_ctl
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/17/86  1452.4 mst Mon
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  cv_cmcs_terminal_ctl.rd         	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  03/17/86  1452.4 mst Mon                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   *                                                         *
       14*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
       15*   *                                                         *
       16*   *                                                         *
       17*   *********************************************************** */
       18 
       19 
       20 /* Modified on 10/27/82 by FCH, [5.1-1], term subchannel name can only start with a/b/c/d, BUG14117(phx14117) */
       21 /* Modified on 04/23/81 by FCH, [4.4-1], accept minus in station names, BUG468 */
       22 /* Modified on 03/03/81 by FCH, [4.4-2], once per process initialization, BUG468 */
       23 /* Modified on 02/27/81 by FCH, [4.4-1], BUG 467(TR9227), terminal name check */
       24 /* Modified since Version 4.3 */
       25 
       26 /* This procedure converts an ASCII list of terminal subchannels and
       27*   their correspnding default station names to a binary control segment */
       28 
       29 /*++
       30*
       31*   BEGIN	/ <valid_terminal> :	/ LEX (2)			/ station \
       32*2	/ end ;			/ 			/ RETURN \
       33*3	/ <any-token>		/ ERROR (1) NEXT_STMT	/ BEGIN \
       34*4	/ <no-token>		/ ERROR (2)		/ RETURN \
       35*
       36*   station / <valid_station> ;	/ add LEX (2)		/ BEGIN \
       37*6	/ <any-token>		/ ERROR (1) NEXT_STMT	/ BEGIN \
       38*7	/ <no-token>		/ ERROR (2)		/ RETURN \
       39*
       40*++*/
       41 
       42 cv_cmcs_terminal_ctl: proc;
       43 
       44 dcl  new_station_name char (12),
       45      new_terminal_name char (8),
       46      j fixed bin,
       47      aclinfo_ptr ptr,				/* for use by tssi_ */
       48      temp3 char (3);
       49 
  1     1 /* BEGIN INCLUDE FILE... cmcs_control_hdr.incl.pl1 */
  1     2 
  1     3 /* This include file is the 1st part of all cobol_mcs tables */
  1     4 
  1     5 /* Bob May, 4/30/77 */
  1     6 
  1     7 dcl  control_hdr_len fixed bin int static options (constant) init (32);
  1     8 
  1     9 dcl  control_hdr_ptr ptr;
  1    10 
  1    11 dcl 1 control_hdr aligned based (control_hdr_ptr),
  1    12     2 lockword bit (36) aligned,			/* for process_id */
  1    13     2 version fixed bin,
  1    14     2 clock_created fixed bin (71),
  1    15     2 author aligned,
  1    16       3 group_id char (32),				/* person.proj.tag */
  1    17       3 process_id bit (36),
  1    18     2 max_size fixed bin (18),			/* maximum number of entries seg can hold */
  1    19     2 current_size fixed bin (18),			/* index of last active entry */
  1    20     2 entry_count fixed bin (18),			/* number of active entries */
  1    21     2 cmcs_control_hdr_filler (16) fixed bin;		/* words (17-32) for later expansion */
  1    22 
  1    23 /* END INCLUDE FILE... cmcs_control_hdr.incl.pl1 */
       50 
       51 
  2     1 /* BEGIN INCLUDE FILE... cmcs_station_ctl.incl.pl1 */
  2     2 
  2     3 /* This include file defines the station control structure for COBOL MCS */
  2     4 
  2     5 /* Bob May, 5/31/77 */
  2     6 
  2     7 dcl (station_ctl_hdr_len init (0),			/* no special fields in hdr */
  2     8      station_ctl_entry_len init (6),
  2     9      station_ctl_version init (1)) fixed bin int static options (constant);
  2    10 
  2    11 dcl  station_ctl_ptr ptr int static;
  2    12 
  2    13 dcl 1 station_ctl aligned based (station_ctl_ptr),
  2    14     2 hdr like control_hdr,
  2    15     2 entries (station_ctl.current_size) like station_ctl_entry;
  2    16 
  2    17 dcl  station_ctl_eindex fixed bin;
  2    18 
  2    19 dcl  station_ctl_eptr ptr;
  2    20 
  2    21 dcl 1 station_ctl_entry aligned based (station_ctl_eptr),
  2    22     2 station_name char (12),
  2    23     2 lockword bit (36) aligned,			/* owner process_id */
  2    24     2 flags,
  2    25      (3 inactive_sw bit (1),				/* station is currently not legal to use */
  2    26       3 destination_sw bit (1),			/* station attached as a destination */
  2    27       3 input_disabled_sw bit (1),			/* if terminal, can't input */
  2    28       3 output_disabled_sw bit (1),			/* if terminal, can't get output */
  2    29       3 filler bit (32)) unaligned,
  2    30     2 filler fixed bin;
  2    31 
  2    32 /* END INCLUDE FILE... cmcs_station_ctl.incl.pl1 */
       52 
       53 
  3     1 /* BEGIN INCLUDE FILE... cmcs_terminal_ctl.incl.pl1 */
  3     2 
  3     3 /* This table does nothing more than supply the default station_name
  3     4*   for a given terminal subchannel (user$device_channel */
  3     5 
  3     6 /* Bob May, 4/30/77 */
  3     7 
  3     8 dcl (terminal_ctl_hdr_len init (0),
  3     9      terminal_ctl_entry_len init (6),
  3    10      terminal_ctl_version init (1)) fixed bin int static options (constant);
  3    11 
  3    12 dcl  terminal_ctl_ptr ptr int static;
  3    13 
  3    14 dcl 1 terminal_ctl aligned based (terminal_ctl_ptr),
  3    15     2 hdr like control_hdr,
  3    16     2 entries (terminal_ctl.current_size) like terminal_ctl_entry;
  3    17 
  3    18 dcl  terminal_ctl_eindex fixed bin;
  3    19 
  3    20 dcl  terminal_ctl_eptr ptr;
  3    21 
  3    22 dcl 1 terminal_ctl_entry aligned based (terminal_ctl_eptr),
  3    23     2 flags,
  3    24      (3 inactive_sw bit (1),
  3    25       3 filler bit (35)) unaligned,
  3    26     2 device_channel char (8),			/* from user$device_channel */
  3    27     2 station_name char (12);				/* default station for the given terminal */
  3    28 
  3    29 /* END INCLUDE FILE... cmcs_terminal_ctl.incl.pl1 */
       54 
       55 
  4     1 /* BEGIN INCLUDE FILE... cmcs_entry_dcls.incl.pl1 */
  4     2 
  4     3 /* Entry declarations for the COBOL MCS runtime support package */
  4     4 
  4     5 /* Modified on 04/29/81 by FCH, [4.4-1] */
  4     6 /* Bob May, 6/01/77 */
  4     7 
  4     8 dcl  cmcs_create_queues_ entry (fixed bin (35));
  4     9 
  4    10 dcl  cmcs_date_time_ entry (fixed bin (71), char (6) unaligned, char (8) unaligned);
  4    11 
  4    12 dcl  cmcs_decode_status_ entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
  4    13 
  4    14 dcl  cmcs_expand_tree_path_ entry (char (*), char (48), fixed bin (35));
  4    15 
  4    16 dcl  cmcs_fillin_hdr_ entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  4    17 
  4    18 dcl  cmcs_initiate_ctl_ entry (char (*), ptr, fixed bin (35));
  4    19 
  4    20 dcl  cmcs_print_ entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  4    21 
  4    22 dcl  cmcs_purge_queues_ entry (fixed bin, bit (1), fixed bin (35));
  4    23 
  4    24 dcl  cmcs_queue_ctl_$accept_message_count entry (ptr, fixed bin, fixed bin (35));
  4    25 dcl  cmcs_queue_ctl_$disable entry (ptr, fixed bin, char (10), fixed bin (35));
  4    26 dcl  cmcs_queue_ctl_$enable entry (ptr, fixed bin, char (10), fixed bin (35));
  4    27 dcl  cmcs_queue_ctl_$print entry (ptr, fixed bin, ptr, fixed bin (35));
  4    28 dcl  cmcs_queue_ctl_$purge entry (ptr, fixed bin, fixed bin (35));
  4    29 dcl  cmcs_queue_ctl_$receive entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35));
  4    30 dcl  cmcs_queue_ctl_$send entry (ptr, fixed bin, ptr, fixed bin, fixed bin, bit (36), fixed bin (35));
  4    31 dcl  cmcs_queue_ctl_$stop_run entry (fixed bin, fixed bin (35));
  4    32 
  4    33 dcl  cmcs_scramble_ entry (char (10)) returns (char (10));
  4    34 
  4    35 dcl  cmcs_set_lock_$lock entry (bit (36) aligned, fixed bin (35));
  4    36 dcl  cmcs_set_lock_$unlock entry (bit (36) aligned, fixed bin (35));
  4    37 
  4    38 dcl  cmcs_station_ctl_$attach entry (char (12), fixed bin, fixed bin (35));
  4    39 dcl  cmcs_station_ctl_$detach entry (fixed bin, fixed bin (35));
  4    40 dcl  cmcs_station_ctl_$detach_name entry (char (12), fixed bin (35));
  4    41 dcl  cmcs_station_ctl_$disable_input_terminal entry (ptr, char (10), fixed bin (35));
  4    42 dcl  cmcs_station_ctl_$disable_output_terminal entry (ptr, char (10), fixed bin (35));
  4    43 dcl  cmcs_station_ctl_$enable_input_terminal entry (ptr, char (10), fixed bin (35));
  4    44 dcl  cmcs_station_ctl_$enable_output_terminal entry (ptr, char (10), fixed bin (35));
  4    45 dcl cmcs_station_ctl_$find_destination entry(char(12),fixed bin,ptr,fixed bin(35));	/*[4.4-1]*/
  4    46 dcl  cmcs_station_ctl_$input_disabled entry (fixed bin, bit (1), fixed bin (35));
  4    47 dcl  cmcs_station_ctl_$output_disabled entry (fixed bin, bit (1), fixed bin (35));
  4    48 dcl  cmcs_station_ctl_$validate entry (char (12), fixed bin, fixed bin (35));
  4    49 
  4    50 dcl  cmcs_status_list_ctl_$add entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
  4    51 dcl  cmcs_status_list_ctl_$delete entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
  4    52 dcl  cmcs_status_list_ctl_$move entry (ptr, ptr, ptr, fixed bin, fixed bin, fixed bin (35));
  4    53 
  4    54 dcl  cmcs_terminal_ctl_$find entry (char (8), char (12), fixed bin (35));
  4    55 
  4    56 dcl  cmcs_tree_ctl_$find_destination entry (char (12), fixed bin, ptr, fixed bin (35));
  4    57 dcl  cmcs_tree_ctl_$find_index entry (fixed bin, ptr, fixed bin (35));
  4    58 dcl  cmcs_tree_ctl_$find_tree_path entry (ptr, fixed bin, fixed bin, ptr, fixed bin (35));
  4    59 dcl  cmcs_tree_ctl_$find_qual_name entry(char(12),fixed bin,ptr,char(52),fixed bin(35)); /*[4.4-1]*/
  4    60 
  4    61 dcl  cmcs_wait_ctl_$add entry (char (48), fixed bin, fixed bin (35));
  4    62 dcl  cmcs_wait_ctl_$delete entry (fixed bin, fixed bin (35));
  4    63 dcl  cmcs_wait_ctl_$find entry (char (48), ptr, fixed bin (35));
  4    64 dcl  cmcs_wait_ctl_$mp_available entry (fixed bin, fixed bin, fixed bin (35));
  4    65 dcl  cmcs_wait_ctl_$mp_login entry (fixed bin, fixed bin (35));
  4    66 dcl  cmcs_wait_ctl_$mp_logout entry (fixed bin, fixed bin (35));
  4    67 dcl  cmcs_wait_ctl_$clear_mp entry (fixed bin (35));
  4    68 dcl  cmcs_wait_ctl_$start_mp entry (fixed bin (35));
  4    69 dcl  cmcs_wait_ctl_$stop_mp entry (fixed bin (35));
  4    70 
  4    71 /* END INCLUDE FILE... cmcs_entry_dcls.incl.pl1 */
       56 
       57 
       58 /* automatic */
       59 
       60 
       61 declare (APstmt, APtoken) ptr,
       62          area_ptr ptr,				/* for use by lex_string_. */
       63          arg_length fixed bin (21),			/* length of command argument. */
       64          arg_ptr ptr,				/* ptr to command argument */
       65          bitcount fixed bin (24),
       66          code fixed bin (35),
       67          dname char (168),
       68          ename char (32),
       69          i fixed bin,
       70          n_chars fixed bin (21),
       71          object_name char (32),			/* entry name of output control seg */
       72         (pntep, object_ptr) ptr,			/* ptrs to base of pnte and pnt */
       73          source_ptr ptr;				/* ptr to base of persmf */
       74 
       75 /* based */
       76 
       77 declare  arg_string char (arg_length) based (arg_ptr) unaligned;
       78 
       79 /* builtin */
       80 
       81 declare (addr, collate, dimension, divide, index, length, null,
       82          reverse, string, substr, verify) builtin;
       83 
       84 /* conditions */
       85 
       86 declare  cleanup condition;
       87 
       88 /* entries */
       89 
       90 declare
       91          clock_ entry () returns (fixed bin (71)),
       92          com_err_ entry options (variable),
       93          cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       94          cv_dec_check_ entry (char (*), fixed bin) returns (fixed bin (35)),
       95          expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
       96          get_group_id_ entry () returns (char (32) aligned),
       97          get_process_id_ entry () returns (bit (36)),
       98          get_wdir_ entry () returns (char (168) aligned),
       99          hcs_$delentry_seg entry (ptr, fixed bin (35)),
      100          hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      101          hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (1), ptr, fixed bin (35)),
      102          hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
      103          hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
      104          hcs_$terminate_noname entry (ptr, fixed bin (35)),
      105          hcs_$truncate_seg entry (ptr, fixed bin (18), fixed bin (35)),
      106          lex_error_ entry options (variable),
      107          lex_string_$init_lex_delims entry (char (*), char (*), char (*), char (*), char (*),
      108          bit (*), char (*) var, char (*) var, char (*) var, char (*) var),
      109          lex_string_$lex entry (ptr, fixed bin (21), fixed bin, ptr, bit (*), char (*), char (*), char (*),
      110          char (*), char (*), char (*) var, char (*) var, char (*) var, char (*) var, ptr, ptr, fixed bin (35)),
      111          translator_temp_$get_segment entry (char (*), ptr, fixed bin (35)),
      112          translator_temp_$release_all_segments entry (ptr, fixed bin (35)),
      113 
      114          tssi_$get_segment entry (char (*), char (*), ptr, ptr, fixed bin (35)),
      115          tssi_$finish_segment entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35)),
      116          tssi_$clean_up_segment entry (ptr),
      117 
      118          unique_chars_ entry (bit (*)) returns (char (15) aligned);
      119 
      120 /* internal static */
      121 
      122 declare ((BREAKS, IGBREAKS, LEXCTL, LEXDLM) char (128) varying,
      123 /*[4.4-2]*/         first_time bit (1) aligned initial ("1"b)) int static;
      124 
      125 dcl (LEGAL char (71) aligned initial ("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'_-^`~ ."),
      126      my_name char (20) initial ("cv_cmcs_terminal_ctl"),
      127      ALPHANUMERICS char (64) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-") /*[4.4-1]*/
      128      ) internal static options (constant);
      129 
      130 /* external static */
      131 
      132 declare ((error_table_$badopt, error_table_$entlong,
      133          error_table_$bad_name, error_table_$translation_failed) fixed bin (35),
      134          sys_info$max_seg_size fixed bin (18)
      135          ) external static;
      136 
      137 
      138 /* program */
      139 
      140 	call cu_$arg_ptr (1, arg_ptr, arg_length, code);
      141 
      142 	if code ^= 0
      143 	then do;
      144 
      145 	     call com_err_ (code, my_name, "Usage: cv_cmcs_terminal_ctl pathname (-brief|-bf|-long|-lg)");
      146 	     return;
      147 
      148 	end;
      149 
      150 	call expand_pathname_ (arg_string, dname, ename, code);
      151 
      152 	if code ^= 0
      153 	then do;
      154 
      155 	     call com_err_ (code, my_name, "^a", arg_string);
      156 	     return;
      157 
      158 	end;
      159 
      160 	call cu_$arg_ptr (2, arg_ptr, arg_length, code);
      161 
      162 	if code = 0
      163 	then if arg_string = "-brief" | arg_string = "-bf"
      164 	     then SERROR_CONTROL = "01"b;
      165 	     else if arg_string = "-long" | arg_string = "-lg"
      166 	     then SERROR_CONTROL = "10"b;
      167 	     else do;
      168 
      169 		call com_err_ (error_table_$badopt, my_name, "^a", arg_string);
      170 		return;
      171 
      172 	     end;
      173 
      174 	source_ptr = null;				/* Initialize for cleanup handler */
      175 	object_ptr = null;				/* .. */
      176 	area_ptr = null;				/* .. */
      177 	aclinfo_ptr = null;				/* .. */
      178 
      179 	on cleanup call clean_up;
      180 
      181 	call hcs_$initiate_count (dname, ename, "", bitcount, 1b, source_ptr, code);
      182 
      183 	if source_ptr = null
      184 	then do;
      185 
      186 report_error:
      187 
      188 	     call com_err_ (code, my_name, "^a>^a", dname, ename);
      189 	     return;
      190 
      191 	end;
      192 
      193 	i = index (ename, ".src") - 1;
      194 
      195 	if i < 1 then do;
      196 
      197 	     call com_err_ (error_table_$bad_name, my_name, "Source segment must have "".src"" suffix.");
      198 	     return;
      199 
      200 	end;
      201 
      202 	if i + length (".control") > length (object_name)
      203 	then do;
      204 
      205 	     code = error_table_$entlong;
      206 	     go to report_error;
      207 
      208 	end;
      209 
      210 	object_name = substr (ename, 1, i) || ".control";
      211 
      212 	n_chars = divide (bitcount + 8, 9, 24, 0);
      213 
      214 	dname = get_wdir_ ();
      215 
      216 	call tssi_$get_segment (dname, object_name, object_ptr, aclinfo_ptr, code);
      217 
      218 	if code ^= 0
      219 	then do;
      220 
      221 	     call com_err_ (code, my_name, "^a>^a", dname, object_name);
      222 	     return;
      223 
      224 	end;
      225 
      226 	terminal_ctl_ptr = object_ptr;		/* actual working ptr - other is generic ptr */
      227 
      228 	call cmcs_fillin_hdr_ (terminal_ctl_ptr, terminal_ctl_version, terminal_ctl_hdr_len, terminal_ctl_entry_len, code);
      229 
      230 	if code ^= 0
      231 	then do;
      232 
      233 	     call com_err_ (code, my_name, "Setting common header data.");
      234 	     return;
      235 
      236 	end;
      237 
      238 /*[4.4-2]*/	if first_time
      239 /*[4.4-2]*/	then	do;
      240 
      241 	     BREAKS = substr (collate, 1, 8) || substr (collate, 10, 24) || ":,()";
      242 	     IGBREAKS = substr (BREAKS, 1, 8+24);
      243 
      244 	     call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b,
      245 		BREAKS, IGBREAKS, LEXDLM, LEXCTL);
      246 
      247 	     call hcs_$initiate
      248 		(get_wdir_ (), "cmcs_station_ctl.control", "cmcs_station_ctl.control", 0, 0, station_ctl_ptr, code);
      249 
      250 	     if station_ctl_ptr = null ()
      251 	     then do;
      252 
      253 		call com_err_ (code, my_name,
      254 		     "The cmcs_station_ctl.control segment must exist in the current working directory before this command can be run.");
      255 		return;
      256 
      257 	     end;
      258 
      259 /*[4.4-2]*/			first_time = "1"b;
      260 
      261 /*[4.4-2]*/		end;
      262 
      263 	call translator_temp_$get_segment (my_name, area_ptr, code);
      264 
      265 	if area_ptr = null ()
      266 	then do;
      267 
      268 	     call com_err_ (code, my_name, "Making temporary segment in process directory.");
      269 	     return;
      270 
      271 	end;
      272 
      273 	call lex_string_$lex (source_ptr, n_chars, 0, area_ptr, "1000"b, """", """", "/*", "*/", ";",
      274 	     BREAKS, IGBREAKS, LEXDLM, LEXCTL, APstmt, APtoken, code);
      275 
      276 	if code ^= 0
      277 	then do;
      278 
      279 	     call com_err_ (code, my_name, ename);
      280 	     return;
      281 
      282 	end;
      283 
      284 	Pthis_token = APtoken;
      285 
      286 	call SEMANTIC_ANALYSIS ();
      287 
      288 	if MERROR_SEVERITY > 1
      289 	then do;
      290 
      291 	     call com_err_ (error_table_$translation_failed, my_name, ename);
      292 	     call hcs_$delentry_seg (object_ptr, code);
      293 
      294 	end;
      295 	else do;
      296 
      297 	     bitcount = 36 * (terminal_ctl_hdr_len + terminal_ctl_entry_len * terminal_ctl.current_size);
      298 	     call tssi_$finish_segment (object_ptr, bitcount, "100"b, aclinfo_ptr, code);
      299 
      300 	     if code ^= 0
      301 	     then call com_err_ (code, my_name, "Unable to set bitcount on ^a>^a to ^d", dname, object_name, bitcount);
      302 
      303 	end;
      304 
      305 	call clean_up;				/* terminate input segments */
      306 
      307 	return;
      308 
      309 /* Clean up procedure. Called if command is "quit" out of, and at end of normal processing. */
      310 
      311 clean_up:
      312 	procedure;
      313 
      314 	     if source_ptr ^= null
      315 	     then call hcs_$terminate_noname (source_ptr, code);
      316 
      317 	     if object_ptr ^= null
      318 	     then call hcs_$terminate_noname (object_ptr, code);
      319 
      320 	     if area_ptr ^= null
      321 	     then call translator_temp_$release_all_segments (area_ptr, code);
      322 
      323 	     if aclinfo_ptr ^= null
      324 	     then call tssi_$clean_up_segment (aclinfo_ptr);
      325 
      326 	end /* clean_up */ ;
      327 
      328 
      329 
      330 
      331 declare 1 error_control_table (2) aligned internal static,
      332         2 severity fixed bin (17) unaligned initial (
      333        (2)3),
      334         2 Soutput_stmt bit (1) unaligned initial (
      335          "1"b,
      336          "0"b),
      337         2 message char (64) varying initial (
      338          "Syntax error in ""^a"" statement.",
      339          "Premature end of input encountered."),
      340         2 brief_message char (20) varying initial (
      341          "^a",
      342          "Premature EOF.");
      343 
      344 /*  */
      345 
      346 valid_terminal: proc () returns (bit (1) aligned);
      347 
      348 /*[4.4-1]*/
      349 			/* name of communications channel, see CC92, Apendix A */
      350 	i = length(token_value);
      351 
      352 	if i < 6 | i > 32 then return("0"b);
      353 
      354 /*[5.1-1]*/	i = index("abcdefghijklmnopqrst",substr(token_value,1,1));
      355 	if i <= 0 then return("0"b);
      356 
      357 	if substr(token_value,2,1) ^= "." then return("0"b);
      358 
      359 	i = index("lh",substr(token_value,3,1));
      360 	if i <= 0 then return("0"b);
      361 
      362 	i = cv_dec_check_(substr(token_value,4,1),j);
      363 	if j ^= 0 then return("0"b);
      364 
      365 	if substr(token_value,3,1) = "h"
      366 	then	do;	if i > 5 then return("0"b);	end;
      367 	else	do;	if i > 2 then return("0"b);	end;
      368 
      369 	i = cv_dec_check_(substr(token_value,5,2),j);
      370 
      371 	if j ^= 0 then return("0"b);
      372 
      373 /*[4.4-1]*/
      374 
      375 
      376 	     new_terminal_name = token_value;
      377 
      378 	     return ("1"b);
      379 
      380 	end /* valid_terminal */ ;
      381 
      382 
      383 
      384 valid_station: proc () returns (bit (1) aligned);
      385 
      386 	     if token_value = "end" then return ("0"b);	/* special case */
      387 
      388 	     if length (token_value) > 12 then return ("0"b);
      389 
      390 	     if verify (token_value, ALPHANUMERICS) ^= 0 then return ("0"b);
      391 
      392 	     new_station_name = token_value;
      393 
      394 	     do station_ctl_eindex = 1 to station_ctl.current_size;
      395 
      396 		station_ctl_eptr = addr (station_ctl.entries (station_ctl_eindex));
      397 
      398 		if ^station_ctl_entry.inactive_sw
      399 		then if station_ctl_entry.station_name = new_station_name
      400 		     then return ("1"b);
      401 
      402 	     end;
      403 
      404 	     return ("0"b);
      405 
      406 	end /* valid_station */ ;
      407 
      408 /*  */
      409 
      410 add:	proc ();
      411 
      412 	     terminal_ctl.entry_count, terminal_ctl.current_size = terminal_ctl.current_size + 1;
      413 	     string (terminal_ctl.flags (terminal_ctl.current_size)) = (36) "0"b;
      414 	     terminal_ctl.device_channel (terminal_ctl.current_size) = new_terminal_name;
      415 	     terminal_ctl.station_name (terminal_ctl.current_size) = new_station_name;
      416 
      417 	     return;
      418 
      419 	end /* add */ ;
      420 
      421 
      422 
      423      dcl	TRACING			bit(1) aligned int static init("0"b);
      424 
      425 
  5     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     4 	/*							*/
  5     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  5     6 	/*							*/
  5     7 	/*      This include segment is used by compilers generated by the	*/
  5     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  5     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  5    10 	/* compares a chain of input tokens with token requirements		*/
  5    11 	/* specified in reductions.  This include segment declares the 	*/
  5    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  5    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  5    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  5    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  5    16 	/*							*/
  5    17 	/* S__t_a_t_u_s							*/
  5    18 	/*							*/
  5    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  5    20 	/*							*/
  5    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    22 
  5    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  5    24 
  6     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  6     2 	
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     4 	/*							*/
  6     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  6     6 	/*							*/
  6     7 	/*      This include segment defines the structure of the token	*/
  6     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  6     9 	/* by the lex_string_ program.				*/
  6    10 	/*							*/
  6    11 	/* Status:						*/
  6    12 	/*							*/
  6    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  6    14 	/*							*/
  6    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    16 	
  6    17 	
  6    18 	
  6    19 	
  6    20      dcl	
  6    21 	1 comment			aligned based (Pcomment),
  6    22 						/* descriptor for a comment.			*/
  6    23 	  2 group1		unaligned,
  6    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  6    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  6    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  6    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  6    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  6    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  6    30 	  2 group2		unaligned,
  6    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  6    32 	    3 S,					/* switches:				*/
  6    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  6    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  6    35 	      4 pad		bit(16),
  6    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  6    37 						/* body of comment.				*/
  6    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  6    39 	
  6    40      dcl	
  6    41 	1 stmt			aligned based (Pstmt),
  6    42 						/* descriptor for a statement.		*/
  6    43 	  2 group1		unaligned,
  6    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  6    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  6    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  6    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  6    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  6    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  6    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  6    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  6    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  6    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  6    54 	  2 group2		unaligned,
  6    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  6    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  6    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  6    58 						/* (the number includes this stmt.)		*/
  6    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  6    60 	    3 S,					/* switches:				*/
  6    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  6    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  6    63 	      4 pad		bit(34),
  6    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  6    65 						/* text of the statement.			*/
  6    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  6    67 	
  6    68      dcl	
  6    69 	1 token			aligned based (Ptoken),
  6    70 						/* descriptor for a token.			*/
  6    71 	  2 group1		unaligned,
  6    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  6    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  6    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  6    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  6    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  6    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  6    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  6    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  6    80 	  2 group2		unaligned,
  6    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  6    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  6    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  6    84 	    3 S,					/* switches:				*/
  6    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  6    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  6    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  6    88 						/* string (as doubled quotes on input.)		*/
  6    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  6    90 						/* string has been lexed into a token.		*/
  6    91 	      4 pad2		bit(32),
  6    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  6    93 						/* value of the token.			*/
  6    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  6    95 
  6    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  5    25 
  5    26 
  5    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    28 
  5    29 
  5    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  5    31 						/* semantics of the tokens in the input list.	*/
  5    32 
  5    33      dcl						/*	automatic variables			*/
  5    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  5    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  5    36 						/* compared to.				*/
  5    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  5    38 						/* compared to.				*/
  5    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  5    40 						/* with reduction tokens are being compared to.	*/
  5    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  5    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  5    43 	CODE			fixed bin(35),	/* an error code.				*/
  5    44 	I			fixed bin,	/* a do-group index.			*/
  5    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  5    46 						/* number character string.			*/
  5    47 
  5    48      dcl						/*	based variables			*/
  5    49 	1 RED			aligned based (PRED),
  5    50 						/* descriptor for reduction tokens are being 	*/
  5    51 						/* compared to.				*/
  5    52 	  2 TOKEN_REQD		unaligned,
  5    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  5    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  5    55 						/* with this reduction.			*/
  5    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  5    57 						/* a token requirement descriptor.		*/
  5    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  5    59 						/*  -1 = relative token requirement function;	*/
  5    60 						/*       TYPE = index of the particular token	*/
  5    61 						/*	      function in the token_fcn array.	*/
  5    62 						/*   0 = built-in token requirement function;	*/
  5    63 						/*       TYPE = as defined below.		*/
  5    64 						/*  >0 = absolute token requirement:		*/
  5    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  5    66 						/*       TYPE = length(TOKEN_REQD);		*/
  5    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  5    68 						/*   1 = compile test to see if input token 	*/
  5    69 						/*       chain is exhausted (<no-token>).	*/
  5    70 						/*   2 = compile test for any token value	*/
  5    71 						/*       (<any-token>).			*/
  5    72 						/*   3 = compile test for a PL/I identifier	*/
  5    73 						/*       (<name>) of 32 or fewer characters.	*/
  5    74 						/*   4 = compile test for token which is a	*/
  5    75 						/*       <decimal-integer>.			*/
  5    76 						/*   5 = compile test for token which is a single	*/
  5    77 						/*       backspace character (<BS>).		*/
  5    78 						/*   6 = compile test for a token which is a	*/
  5    79 						/*       <quoted-string>.			*/
  5    80 
  5    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  5    82 						/* overlay for an absolute token requirement	*/
  5    83 						/* descriptor.				*/
  5    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  5    85 						/* absolute token string assoc w/ descriptor.	*/
  5    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  5    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  5    88 						/* absolute token string which token is reqd	*/
  5    89 						/* to match in order for tokens which are	*/
  5    90 						/* "current" on the list to match the reduction.	*/
  5    91 
  5    92      dcl						/*	builtin functions			*/
  5    93          (addr, max, null, search, substr, verify)
  5    94 				builtin;
  5    95 
  5    96      dcl						/*	entries				*/
  5    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  5    98 
  5    99      dcl						/*	static variables			*/
  5   100 	BACKSPACE			char(1) aligned int static init ("");
  5   101 
  5   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
      426 
      427 
      428      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
      429 
      430 
      431      dcl	1 REDUCTION (7)		unaligned based (addr (REDUCTIONS)),
      432 						/* object reductions.			*/
      433 	  2 TOKEN_REQD,
      434 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
      435 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
      436 
      437 	REDUCTIONS  (14)		fixed bin(17) unaligned internal static options(constant) initial (
      438 	         1,     2,	/*     1/  <valid_terminal> :                                                   */
      439 	         3,     4,	/*     2/  end ;                                                                */
      440 	         5,     5,	/*     3/  <any-token>                                                          */
      441 	         6,     6,	/*     4/  <no-token>                                                           */
      442 	         7,     8,	/*     5/  <valid_station> ;                                                    */
      443 	         5,     5,	/*     6/  <any-token>                                                          */
      444 	         6,     6);	/*     7/  <no-token>                                                           */
      445 
      446      dcl	1 TOKEN_REQUIREMENT (8)	unaligned based (addr (TOKEN_REQUIREMENTS)),
      447 						/* object token requirements.			*/
      448 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
      449 						/*  -1 = relative token requirement function;	*/
      450 						/*       TYPE = index of the particular token	*/
      451 						/*	      function in the token_fcn array.	*/
      452 						/*   0 = built-in token requirement function;	*/
      453 						/*       TYPE = as defined below.		*/
      454 						/*  >0 = absolute token requirement:		*/
      455 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
      456 						/*       TYPE = length(TOKEN_REQD);		*/
      457 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
      458 						/* function:				*/
      459 						/*   1 = compile test to see if input token 	*/
      460 						/*       chain is exhausted (<no-token>).	*/
      461 						/*   2 = compile test for any token value	*/
      462 						/*       (<any-token>).			*/
      463 						/*   3 = compile test for a PL/I identifier	*/
      464 						/*       (<name>) of 32 or fewer characters.	*/
      465 						/*   4 = compile test for token which is a	*/
      466 						/*       <decimal-integer>.			*/
      467 						/*   5 = compile test for token which is a single	*/
      468 						/*       backspace character (<BS>).		*/
      469 						/*   6 = compile test for a token which is a	*/
      470 						/*       <quoted-string>.			*/
      471 
      472 	TOKEN_REQUIREMENTS  (16)	fixed bin(17) unaligned internal static options(constant) initial (
      473 	        -1,    1,       1,    1,       2,    3,       5,    1,       0,    2,       0,    1,      -1,    2,   
      474 	         5,    1);
      475 
      476 
      477      dcl	TOKEN_STRINGS		char(5) aligned based (addr (TOKEN_STRING_ARRAYS)),
      478 						/* object token values.			*/
      479 	TOKEN_STRING_ARRAYS (1)	char(100) aligned internal static options(constant) initial (
      480 	     ":end;");
      481 
      482 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  7     6*     old history comments:
  7     7*      0) Created: April, 1974 by G. C. Dixon
  7     8*      1) Modified: Feb, 1975  by G. C. Dixon
  7     9*         a) support for Version 2.0 of reduction_compiler.
  7    10*      2) Modified: Feb, 1981  by G. C. Dixon
  7    11*         a) support for Version  2.2 of reduction_compiler
  7    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  7    13*                        reductions command.
  7    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  7    15*     install(86-03-17,MR12.0-1032):
  7    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  7    17*     implemented to avoid references through a null pointer.  The two
  7    18*     accepted uses are:
  7    19*     
  7    20*        / <no-token>               / ... / ... \
  7    21*                    A
  7    22*                    |
  7    23*           Pthis_token (points to top of push down stack)
  7    24*     
  7    25*     which checks to see if the push down stack is totally exhausted (ie,
  7    26*     Ptoken = null); and:
  7    27*     
  7    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  7    29*                           A
  7    30*                           |
  7    31*                 Pthis_token (points to top of push down stack)
  7    32*     
  7    33*     which checks to see whether SPECN is topmost on the push down stack
  7    34*     AND is the final token in the input list.
  7    35*                                                   END HISTORY COMMENTS */
  7    36 
  7    37 
  7    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    39 	/*									*/
  7    40 	/* NAME:  rdc_end_.incl.pl1							*/
  7    41 	/*									*/
  7    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  7    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  7    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  7    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  7    47 	/*									*/
  7    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    49 
  7    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  7    51 						/*   options(constant) because it is never set.	*/
  7    52 	NRED = 1;
  7    53 	go to RD_TEST_REDUCTION;
  7    54 
  7    55 RD_NEXT_REDUCTION:
  7    56 	NRED = NRED + 1;
  7    57 
  7    58 RD_TEST_REDUCTION:
  7    59 	PRED = addr(REDUCTION(NRED));
  7    60 	Ptoken = Pthis_token;
  7    61 
  7    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  7    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  7    64 	     if Ptoken = null then do;
  7    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  7    66 		     if TOKEN_REQD.TYPE = 1 then
  7    67 			go to RD_TEST_TOKEN(1);
  7    68 		go to RD_NEXT_REDUCTION;
  7    69 		end;
  7    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  7    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  7    72 
  7    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  7    74 						/* In push-down-language, there are 2 		*/
  7    75 						/*   interpretations of <no-token>.		*/
  7    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  7    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  7    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  7    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  7    80 			   RED.TOKEN_REQD.IFIRST = I &
  7    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  7    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  7    83 						/*  and is SPECN the final input token?"	*/
  7    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  7    85 						/* down language mode for <no-token>.		*/
  7    86 		else if Ptoken = null then
  7    87 		     go to RD_MATCH_NO_TOKEN;
  7    88 		go to RD_NEXT_REDUCTION;
  7    89 
  7    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  7    91 
  7    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  7    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  7    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  7    95 		     > 0 then
  7    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  7    97 			= 0 then
  7    98 			     go to RD_MATCH;
  7    99 		go to RD_NEXT_REDUCTION;
  7   100 
  7   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  7   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  7   103 		     go to RD_MATCH;
  7   104 		if token.S.quoted_string then
  7   105 		     go to RD_NEXT_REDUCTION;
  7   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  7   107 		if CODE = 0 then do;
  7   108 		     token.Nvalue = NUMBER;
  7   109 		     go to RD_MATCH;
  7   110 		     end;
  7   111 		go to RD_NEXT_REDUCTION;
  7   112 
  7   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  7   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  7   115 			go to RD_MATCH;
  7   116 		go to RD_NEXT_REDUCTION;
  7   117 
  7   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  7   119 		     go to RD_MATCH;
  7   120 		go to RD_NEXT_REDUCTION;
  7   121 		end;
  7   122 
  7   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  7   124 		if token.S.quoted_string then
  7   125 		     go to RD_NEXT_REDUCTION;
  7   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  7   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  7   128 		if token_value = TOKEN_REQD_VALUE then
  7   129 		     go to RD_MATCH;
  7   130 		go to RD_NEXT_REDUCTION;
  7   131 		end;
  7   132 
  7   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      482 
      483 
      484 	     else do;				/* relative syntax function.			*/
      485 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
      486 
      487 RD_TOKEN_FCN(1):	STOKEN_FCN = valid_terminal();
      488 		go to RD_TEST_RESULT;
      489 RD_TOKEN_FCN(2):	STOKEN_FCN = valid_station();
      490 		go to RD_TEST_RESULT;
      491 
      492 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
      493 		else go to RD_NEXT_REDUCTION;
      494 		end;
      495 
      496 RD_MATCH:      Ptoken = token.Pnext;
      497 RD_MATCH_NO_TOKEN:
      498 	     end;
      499 	Ptoken = Pthis_token;
      500 	go to RD_ACTION(NRED);
      501 
      502 
      503 RD_ACTION(1):					/* /					*/
      504 	call 					     LEX ( 2 );
      505 	NRED = 5;
      506 	go to RD_TEST_REDUCTION;			/* / station \                         		*/
      507 
      508 RD_ACTION(2):					/* /					*/
      509 	return;					/* / RETURN	\			*/
      510 
      511 RD_ACTION(3):					/* /					*/
      512 	call 					     ERROR ( 1 );
      513 	call					     NEXT_STMT();
      514 	NRED = 1;
      515 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      516 
      517 RD_ACTION(4):					/* /					*/
      518 	call 					     ERROR ( 2 );
      519 	return;					/* / RETURN	\			*/
      520 
      521 RD_ACTION(5):					/* /					*/
      522 	call					     add();
      523 	call 					     LEX ( 2 );
      524 	NRED = 1;
      525 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      526 
      527 RD_ACTION(6):					/* /					*/
      528 	call 					     ERROR ( 1 );
      529 	call					     NEXT_STMT();
      530 	NRED = 1;
      531 	go to RD_TEST_REDUCTION;			/* / BEGIN \                           		*/
      532 
      533 RD_ACTION(7):					/* /					*/
      534 	call 					     ERROR ( 2 );
      535 	return;					/* / RETURN	\			*/
      536 
      537 
      538 	end SEMANTIC_ANALYSIS;
      539 
      540 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      541 
      542      dcl	SPDL			bit(1) aligned init ("0"b);
      543 						/* off: This compiler parses a non-PUSH DOWN	*/
      544 						/*      LANGUAGE.				*/
      545 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  8     6 	/*									*/
  8     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  8     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  8     9 	/* "current" token, Pthis_token.						*/
  8    10 	/*									*/
  8    11 	/* E__n_t_r_y:  LEX								*/
  8    12 	/*									*/
  8    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  8    14 	/* _n is its positive (or negative) input argument.				*/
  8    15 	/*									*/
  8    16 	/* U__s_a_g_e									*/
  8    17 	/*									*/
  8    18 	/*      call LEX(n);							*/
  8    19 	/*									*/
  8    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  8    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  8    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  8    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  8    24 	/*									*/
  8    25 	/* S__t_a_t_u_s									*/
  8    26 	/*									*/
  8    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  8    28 	/*									*/
  8    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    30 
  8    31 LEX:	procedure (n);
  8    32 
  8    33      dcl	n			fixed bin,
  8    34 	i			fixed bin;
  8    35 
  8    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  8    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  8    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  8    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  8    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  8    41 		end;
  8    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  8    43 						/*   running off end of token list.		*/
  8    44 	     end;
  8    45 	else					/* new "current" token precedes present one.	*/
  8    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  8    47 		Ptoken = token.Plast;
  8    48 		end;
  8    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  8    50 
  8    51 	end LEX;
  8    52 
  8    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      545 
      546 
      547 		/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3      dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
  9     4 	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
  9     5 	SERROR_PRINTED (dimension (error_control_table,1))
  9     6 				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
  9     7 						/* Array bit is on if corresponding error message	*/
  9     8 						/* in error_control_table has already been printed*/
  9     9 	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
  9    10 	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/
  9    11 
  9    12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    13 	/*									*/
  9    14 	/* N__a_m_e:  rdc_error_.incl.pl1							*/
  9    15 	/*									*/
  9    16 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  9    17 	/* It defines a procedure which the compilers can use to print error messages.  	*/
  9    18 	/*									*/
  9    19 	/* E__n_t_r_y:  ERROR								*/
  9    20 	/*									*/
  9    21 	/*      Given an error number, this procedure prints a corresponding error message.	*/
  9    22 	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
  9    23 	/* which specifies the severity level of the error, and a switch which specifies whether	*/
  9    24 	/* the source statement in which the error occurred (if any) should be printed after the	*/
  9    25 	/* error message.  The printing of the error message may be supressed for all messages	*/
  9    26 	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
  9    27 	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
  9    28 	/*  the error message.							*/
  9    29 	/*									*/
  9    30 	/* U__s_a_g_e									*/
  9    31 	/*									*/
  9    32 	/*      call ERROR (error_number);						*/
  9    33 	/*									*/
  9    34 	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
  9    35 	/*		which defines the error message to be printed.			*/
  9    36 	/*									*/
  9    37 	/* N__o_t_e_s									*/
  9    38 	/*									*/
  9    39 	/*      The format of the error_control_table is shown below.			*/
  9    40 	/*									*/
  9    41 	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
  9    42 	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
  9    43 	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
  9    44 	/*	  2 message		char(252) varying initial (			*/
  9    45 	/*		"The reduction source segment does not contain any reductions.",	*/
  9    46 	/*		"Reduction label  '^a'  is invalid."),				*/
  9    47 	/*	  2 brief_message		char(100) varying initial (			*/
  9    48 	/*		"", "'^a'");						*/
  9    49 	/*									*/
  9    50 	/* error_control_table is an array of structures, with one array element per error.	*/
  9    51 	/* Each structure contains: a severity level for the error; a switch which specifies	*/
  9    52 	/* whether the source statement being processed should be output after the error message;	*/
  9    53 	/* the long form of the error message text;  and the brief form of the error message text.*/
  9    54 	/* The dimension of the error_control_table array of structures, and the lengths of	*/
  9    55 	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
  9    56 	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
  9    57 	/* The only requirement is that the messages be 256 characters or less in length.	*/
  9    58 	/* (Remember that the longest character string which can be used in an initial attribute	*/
  9    59 	/* is 254 characters in length.)						*/
  9    60 	/*									*/
  9    61 	/*      The severity number causes the error message to be preceded by a herald which	*/
  9    62 	/* includes one of the following prefixes:					*/
  9    63 	/*									*/
  9    64 	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
  9    65 	/*	0 = COMMENT		- this is a comment.			*/
  9    66 	/*	1 = WARNING		- a possible error has been detected.  The	*/
  9    67 	/*				  compiler will still generate an object segment.	*/
  9    68 	/*	2 = ERROR			- a probable error has been detected.  The	*/
  9    69 	/*				  compiler will still generate an object segment.	*/
  9    70 	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
  9    71 	/*				  that no object segment will be generated.	*/
  9    72 	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
  9    73 	/*				  the compiler or translator.  No object segment	*/
  9    74 	/*				  will be generated.			*/
  9    75 	/*									*/
  9    76 	/* Full error messages are of the form:						*/
  9    77 	/*									*/
  9    78 	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
  9    79 	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
  9    80 	/*	SOURCE:								*/
  9    81 	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
  9    82 	/*									*/
  9    83 	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
  9    84 	/* If the source statement has been printed in a previous error message, it is omitted.	*/
  9    85 	/*									*/
  9    86 	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
  9    87 	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
  9    88 	/*									*/
  9    89 	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
  9    90 	/*	"00"b		the first time a particular error occurs, the long message	*/
  9    91 	/*			is printed; the brief message is used in subsequent	*/
  9    92 	/*			occurrences of that error.				*/
  9    93 	/*        "10"b or "11"b	the long error message is always used.			*/
  9    94 	/*	"01"b		the brief error message is always used.			*/
  9    95 	/* The initial value of SERROR_CONTROL is "00"b.					*/
  9    96 	/*									*/
  9    97 	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
  9    98 	/* of switches (one per error).  The switch corresponding to a particular error is	*/
  9    99 	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
  9   100 	/* subsequent occurrences of that same error.					*/
  9   101 	/*									*/
  9   102 	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
  9   103 	/* in which the severity of the highest-severity error encountered is maintained.	*/
  9   104 	/* The compiler may reference this integer.					*/
  9   105 	/*									*/
  9   106 	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
  9   107 	/* which controls the printing of error messages by the ERROR procedure.		*/
  9   108 	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
  9   109 	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
  9   110 	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
  9   111 	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/
  9   112 
  9   113 	/*									*/
  9   114 	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
  9   115 	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
  9   116 	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
  9   117 	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
  9   118 	/* called.  The compiler may set this bit string, as shown below.			*/
  9   119 	/*									*/
  9   120 	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
  9   121 	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
  9   122 	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
  9   123 	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
  9   124 	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
  9   125 	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
  9   126 	/*									*/
  9   127 	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
  9   128 	/* error message.  A compiler action routine can output more flexible error messages	*/
  9   129 	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
  9   130 	/*									*/
  9   131 	/* S__t_a_t_u_s									*/
  9   132 	/*									*/
  9   133 	/* 0) Created:  April, 1974 by G. C. Dixon					*/
  9   134 	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
  9   135 	/*		PRINT_SEVERITY_CONTROL.					*/
  9   136 	/*									*/
  9   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9   138 
  9   139 ERROR:	procedure (Nerror);
  9   140 
  9   141      dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/
  9   142 
  9   143      dcl	Pstmt			ptr,
  9   144 	1 erring_token		aligned based (Perring_token) like token,
  9   145 	Perring_token		ptr,
  9   146 	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);
  9   147 
  9   148      dcl 	(max, null)		builtin;
  9   149 
  9   150      dcl	lex_error_		entry options (variable);
  9   151 
  9   152 
  9   153 	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
  9   154 	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
  9   155 		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
  9   156 	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
  9   157 		SERROR_PRINTED(Nerror) = "1"b;
  9   158 	     return;
  9   159 	end;
  9   160 	Perring_token = Pthis_token;			/* address the current erring_token.		*/
  9   161 	if error_control_table.Soutput_stmt(Nerror) then
  9   162 	     if Perring_token = null then
  9   163 		Pstmt = null;
  9   164 	     else
  9   165 		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
  9   166 	else
  9   167 	     Pstmt = null;
  9   168 	if Perring_token = null then
  9   169 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  9   170 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  9   171 		(error_control_table.brief_message(Nerror)));
  9   172 	else
  9   173 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  9   174 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  9   175 		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);
  9   176 
  9   177 	end ERROR;
  9   178 
  9   179 	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      547 
      548 
      549 		/* START OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
 10     2 
 10     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     4 	/*							*/
 10     5 	/* N__a_m_e:  rdc_next_stmt_.incl.pl1				*/
 10     6 	/*							*/
 10     7 	/*      This include segment is used by compilers generated by the	*/
 10     8 	/* reduction_compiler.  It includes a procedure which shifts the	*/
 10     9 	/* compilation process to the next source statement.		*/
 10    10 	/*							*/
 10    11 	/* S__t_a_t_u_s							*/
 10    12 	/*							*/
 10    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
 10    14 	/*							*/
 10    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10    16 
 10    17 
 10    18 NEXT_STMT:	procedure;			/* invoked to begin parsing the next statement of	*/
 10    19 						/* the input tokens.			*/
 10    20 
 10    21      dcl	null			builtin,
 10    22 	Ssearching		bit(1) aligned;
 10    23 
 10    24 	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/
 10    25 	Pstmt = token.Pstmt;			/* address "current" statement's descriptor.	*/
 10    26 	Ssearching = "1"b;				/* start scanning forward for next statement.	*/
 10    27 	do while (Ssearching & token.Pnext ^= null);
 10    28 	     Ptoken = token.Pnext;
 10    29 	     if token.Pstmt = Pstmt then;
 10    30 	     else Ssearching = "0"b;
 10    31 	     end;
 10    32 	if token.Pstmt = Pstmt then			/* if there is no next statement, and		*/
 10    33 	     if SPDL then				/*   in PUSH DOWN LANGUAGE mode, can't run off	*/
 10    34 		Ptoken = Ptoken;			/*   end of input list.			*/
 10    35 	     else Ptoken, Pthis_token = null;		/*   otherwise, input list exhausted.		*/
 10    36 	else Pthis_token = Ptoken;			/* normally, next statement exists and Ptoken	*/
 10    37 						/*   points to its 1st _n_o_n-__d_e_l_e_t_e_d token.	*/
 10    38 
 10    39 	end NEXT_STMT;
 10    40 
 10    41 	/* END OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
      549 
      550 
      551 	end cv_cmcs_terminal_ctl;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/17/86  1452.5  cv_cmcs_terminal_ctl.pl1          >spec>install>1032>cv_cmcs_terminal_ctl.pl1
50           1    03/27/82  0439.5  cmcs_control_hdr.incl.pl1         >ldd>include>cmcs_control_hdr.incl.pl1
52           2    03/27/82  0439.6  cmcs_station_ctl.incl.pl1         >ldd>include>cmcs_station_ctl.incl.pl1
54           3    03/27/82  0439.6  cmcs_terminal_ctl.incl.pl1        >ldd>include>cmcs_terminal_ctl.incl.pl1
56           4    03/27/82  0431.4  cmcs_entry_dcls.incl.pl1          >ldd>include>cmcs_entry_dcls.incl.pl1
426          5    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
5-25         6    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
482          7    03/17/86  1404.9  rdc_end_.incl.pl1                 >spec>install>1032>rdc_end_.incl.pl1
545          8    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
547          9    08/15/83  1511.7  rdc_error_.incl.pl1               >ldd>include>rdc_error_.incl.pl1
549         10    04/18/75  1242.4  rdc_next_stmt_.incl.pl1           >ldd>include>rdc_next_stmt_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALPHANUMERICS                   000147 constant        char(64)                 initial unaligned dcl 125 ref 390
APstmt                          000116 automatic       pointer                  dcl 61 set ref 273*
APtoken                         000120 automatic       pointer                  dcl 61 set ref 273* 284
BACKSPACE                       004313 constant        char(1)                  initial dcl 5-99 ref 7-113
BREAKS                          000014 internal static varying char(128)        dcl 122 set ref 241* 242 244* 273*
CODE                            000327 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-107
DIRECTION                       000332 automatic       fixed bin(17,0)          initial dcl 428 set ref 7-62 428*
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-65 7-70
                                                                                  7-123
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 5-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 7-126
I                               000330 automatic       fixed bin(17,0)          dcl 5-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  7-62* 7-63 7-79*
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
                                                                                  7-79
IGBREAKS                        000055 internal static varying char(128)        dcl 122 set ref 242* 244* 273*
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-127
LEXCTL                          000116 internal static varying char(128)        dcl 122 set ref 244* 273*
LEXDLM                          000157 internal static varying char(128)        dcl 122 set ref 244* 273*
LTOKEN_REQD_VALUE               000316 automatic       fixed bin(18,0)          dcl 5-33 set ref 7-127* 7-128
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "erring_token" dcl 9-143
                                                                                  in procedure "ERROR" ref 9-172 9-172 9-172 9-172
                                                                                  9-172 9-172
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 6-68 in procedure
                                                                                  "cv_cmcs_terminal_ctl" ref 350 354 357 359 362 362
                                                                                  365 369 369 376 386 388 390 392 7-92 7-92 7-92
                                                                                  7-92 7-106 7-106 7-113 7-113 7-128
MERROR_SEVERITY                 000247 automatic       fixed bin(17,0)          initial dcl 9-3 set ref 288 9-3* 9-154* 9-154 9-168*
                                                                                  9-172*
MIN_PRINT_SEVERITY              000251 automatic       fixed bin(17,0)          initial dcl 9-3 set ref 9-3* 9-153
NRED                            000317 automatic       fixed bin(17,0)          dcl 5-33 set ref 7-52* 7-55* 7-55 7-58 500 505* 514*
                                                                                  524* 530*
NUMBER                          000331 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-108
Nerror                                 parameter       fixed bin(17,0)          dcl 9-141 set ref 9-139 9-153 9-154 9-156 9-161
                                                                                  9-168* 9-168 9-168 9-168 9-168 9-172* 9-172 9-172
                                                                                  9-172 9-172
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 6-68 set ref 7-101
                                                                                  7-108*
PRED                            000320 automatic       pointer                  dcl 5-33 set ref 7-58* 7-62 7-62 7-73 7-73 7-79 7-79
                                                                                  7-79
PRINT_SEVERITY_CONTROL          000252 automatic       bit(2)                   initial unaligned dcl 9-3 set ref 9-3* 9-154 9-156
PTOKEN_REQD                     000322 automatic       pointer                  dcl 5-33 set ref 7-63* 7-65 7-65 7-70 7-71 7-123
                                                                                  7-126 7-127 485
PTOKEN_REQD_VALUE               000324 automatic       pointer                  dcl 5-33 set ref 7-126* 7-128
Perring_token                   000400 automatic       pointer                  dcl 9-143 set ref 9-160* 9-161 9-164 9-168 9-168*
                                                                                  9-172* 9-172 9-172 9-172 9-172 9-172 9-172 9-172
                                                                                  9-172 9-172
Plast                     2            based           pointer                  level 2 packed unaligned dcl 6-68 ref 8-45 8-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 6-68 ref 7-79 496 8-39
                                                                                  8-40 10-27 10-28
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 6-68 in procedure "cv_cmcs_terminal_ctl" ref
                                                                                  10-25 10-29 10-32
Pstmt                           000242 automatic       pointer                  dcl 6-40 in procedure "cv_cmcs_terminal_ctl" set ref
                                                                                  10-25* 10-29 10-32
Pstmt                           000376 automatic       pointer                  dcl 9-143 in procedure "ERROR" set ref 9-161* 9-164*
                                                                                  9-166* 9-168* 9-172*
Pstmt                     5            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 9-143 in procedure "ERROR" ref 9-164
Pthis_token                     000240 automatic       pointer                  dcl 5-23 set ref 284* 7-60 499 8-36 8-49* 9-160
                                                                                  10-24 10-35* 10-36*
Ptoken                          000244 automatic       pointer                  dcl 6-68 set ref 350 350 354 354 357 357 359 359 362
                                                                                  362 362 362 365 365 369 369 369 369 376 376 386
                                                                                  386 388 388 390 390 392 392 7-60* 7-64 7-73 7-79
                                                                                  7-86 7-92 7-92 7-92 7-92 7-92 7-92 7-92 7-101
                                                                                  7-104 7-106 7-106 7-106 7-108 7-113 7-113 7-113
                                                                                  7-113 7-118 7-124 7-128 7-128 496* 496 499* 8-36*
                                                                                  8-37 8-39 8-40* 8-40 8-42* 8-45 8-47* 8-47 8-49
                                                                                  10-24* 10-25 10-27 10-28* 10-28 10-29 10-32 10-32*
                                                                                  10-32 10-35* 10-36
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 6-68 in procedure "cv_cmcs_terminal_ctl" ref
                                                                                  350 354 357 359 362 362 365 369 369 376 386 388
                                                                                  390 392 7-92 7-92 7-106 7-113 7-128
Pvalue                    3            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 9-143 in procedure "ERROR" ref 9-172 9-172
                                                                                  9-172
RED                                    based           structure                level 1 dcl 5-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 431 set ref 7-58
REDUCTIONS                      000140 constant        fixed bin(17,0)          initial array unaligned dcl 431 set ref 7-58
S                        11            based           structure                level 3 packed unaligned dcl 6-68
SERROR_CONTROL                  000250 automatic       bit(2)                   initial unaligned dcl 9-3 set ref 162* 165* 9-3*
                                                                                  9-168* 9-172*
SERROR_PRINTED                  000251 automatic       bit(1)                   initial array unaligned dcl 9-3 set ref 9-3* 9-156*
                                                                                  9-168* 9-172*
SPDL                            000246 automatic       bit(1)                   initial dcl 542 set ref 542* 7-73 8-42 10-32
STOKEN_FCN                      000326 automatic       bit(1)                   dcl 5-33 set ref 487* 489* 492
Soutput_stmt              0(18) 000000 constant        bit(1)                   initial array level 2 packed unaligned dcl 331 ref
                                                                                  9-161
Ssearching                      000410 automatic       bit(1)                   dcl 10-21 set ref 10-26* 10-27 10-30*
TOKEN_REQD                             based           structure                level 1 dcl 5-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 5-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 5-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 5-48 ref 7-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 446 set ref 7-63
TOKEN_REQUIREMENTS              000130 constant        fixed bin(17,0)          initial array unaligned dcl 446 set ref 7-63
TOKEN_STRINGS                          based           char(5)                  dcl 477 set ref 7-126
TOKEN_STRING_ARRAYS             000077 constant        char(100)                initial array dcl 477 set ref 7-126
TRACING                         000221 internal static bit(1)                   initial dcl 423 set ref 7-50* 7-50
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-65 7-71 485
aclinfo_ptr                     000110 automatic       pointer                  dcl 44 set ref 177* 216* 298* 323 323*
addr                                                   builtin function         dcl 81 in procedure "cv_cmcs_terminal_ctl" ref 396
addr                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-58
                                                                                  7-58 7-63 7-63 7-126 7-126
area_ptr                        000122 automatic       pointer                  dcl 61 set ref 176* 263* 265 273* 320 320*
arg_length                      000124 automatic       fixed bin(21,0)          dcl 61 set ref 140* 150 150 155 155 160* 162 162 165
                                                                                  165 169 169
arg_ptr                         000126 automatic       pointer                  dcl 61 set ref 140* 150 155 160* 162 162 165 165 169
arg_string                             based           char                     unaligned dcl 77 set ref 150* 155* 162 162 165 165
                                                                                  169*
bitcount                        000130 automatic       fixed bin(24,0)          dcl 61 set ref 181* 212 297* 298* 300*
brief_message            22     000000 constant        varying char(20)         initial array level 2 dcl 331 ref 9-168 9-172
cleanup                         000232 stack reference condition                dcl 86 ref 179
cmcs_fillin_hdr_                000222 constant        entry                    external dcl 4-16 ref 228
code                            000131 automatic       fixed bin(35,0)          dcl 61 set ref 140* 142 145* 150* 152 155* 160* 162
                                                                                  181* 186* 205* 216* 218 221* 228* 230 233* 247*
                                                                                  253* 263* 268* 273* 276 279* 292* 298* 300 300*
                                                                                  314* 317* 320*
collate                                                builtin function         dcl 81 ref 241 241
com_err_                        000224 constant        entry                    external dcl 90 ref 145 155 169 186 197 221 233 253
                                                                                  268 279 291 300
control_hdr                            based           structure                level 1 dcl 1-11
cu_$arg_ptr                     000226 constant        entry                    external dcl 90 ref 140 160
current_size             16            based           fixed bin(18,0)          level 3 in structure "terminal_ctl" dcl 3-14
                                                                                  in procedure "cv_cmcs_terminal_ctl" set ref 297
                                                                                  412 412* 413 414 415
current_size             16            based           fixed bin(18,0)          level 3 in structure "station_ctl" dcl 2-13
                                                                                  in procedure "cv_cmcs_terminal_ctl" ref 394
cv_dec_check_                   000230 constant        entry                    external dcl 90 in procedure "cv_cmcs_terminal_ctl"
                                                                                  ref 362 369
cv_dec_check_                   000274 constant        entry                    external dcl 5-96 in procedure "SEMANTIC_ANALYSIS"
                                                                                  ref 7-106
device_channel           41            based           char(8)                  array level 3 dcl 3-14 set ref 414*
dimension                                              builtin function         dcl 81 ref 9-3 9-3
divide                                                 builtin function         dcl 81 ref 212
dname                           000132 automatic       char(168)                unaligned dcl 61 set ref 150* 181* 186* 214* 216*
                                                                                  221* 300*
ename                           000204 automatic       char(32)                 unaligned dcl 61 set ref 150* 181* 186* 193 210 279*
                                                                                  291*
entries                  40            based           structure                array level 2 in structure "terminal_ctl" dcl 3-14
                                                                                  in procedure "cv_cmcs_terminal_ctl"
entries                  40            based           structure                array level 2 in structure "station_ctl" dcl 2-13
                                                                                  in procedure "cv_cmcs_terminal_ctl" set ref 396
entry_count              17            based           fixed bin(18,0)          level 3 dcl 3-14 set ref 412*
erring_token                           based           structure                level 1 dcl 9-143
erring_token_value                     based           char                     unaligned dcl 9-143 set ref 9-172* 9-172* 9-172*
error_control_table             000000 constant        structure                array level 1 dcl 331 ref 9-3 9-3
error_table_$bad_name           000270 external static fixed bin(35,0)          dcl 132 set ref 197*
error_table_$badopt             000264 external static fixed bin(35,0)          dcl 132 set ref 169*
error_table_$entlong            000266 external static fixed bin(35,0)          dcl 132 ref 205
error_table_$translation_failed 000272 external static fixed bin(35,0)          dcl 132 set ref 291*
expand_pathname_                000232 constant        entry                    external dcl 90 ref 150
first_time                      000220 internal static bit(1)                   initial dcl 122 set ref 238 259*
flags                    40            based           structure                array level 3 in structure "terminal_ctl" dcl 3-14
                                                                                  in procedure "cv_cmcs_terminal_ctl" set ref 413*
flags                     4            based           structure                level 2 in structure "station_ctl_entry" dcl 2-21
                                                                                  in procedure "cv_cmcs_terminal_ctl"
get_wdir_                       000234 constant        entry                    external dcl 90 ref 214 247 247
group2                    7            based           structure                level 2 packed unaligned dcl 6-68
hcs_$delentry_seg               000236 constant        entry                    external dcl 90 ref 292
hcs_$initiate                   000240 constant        entry                    external dcl 90 ref 247
hcs_$initiate_count             000242 constant        entry                    external dcl 90 ref 181
hcs_$terminate_noname           000244 constant        entry                    external dcl 90 ref 314 317
hdr                                    based           structure                level 2 in structure "terminal_ctl" dcl 3-14
                                                                                  in procedure "cv_cmcs_terminal_ctl"
hdr                                    based           structure                level 2 in structure "station_ctl" dcl 2-13
                                                                                  in procedure "cv_cmcs_terminal_ctl"
i                               000214 automatic       fixed bin(17,0)          dcl 61 in procedure "cv_cmcs_terminal_ctl" set ref
                                                                                  193* 195 202 210 350* 352 352 354* 355 359* 360
                                                                                  362* 366 367 369*
i                               000364 automatic       fixed bin(17,0)          dcl 8-33 in procedure "LEX" set ref 8-39* 8-42 8-45*
inactive_sw               4            based           bit(1)                   level 3 packed unaligned dcl 2-21 ref 398
index                                                  builtin function         dcl 81 ref 193 354 359
j                               000106 automatic       fixed bin(17,0)          dcl 44 set ref 362* 363 369* 371
length                                                 builtin function         dcl 81 ref 202 202 350 388
lex_error_                      000276 constant        entry                    external dcl 9-150 ref 9-168 9-172
lex_string_$init_lex_delims     000246 constant        entry                    external dcl 90 ref 244
lex_string_$lex                 000250 constant        entry                    external dcl 90 ref 273
max                                                    builtin function         dcl 9-148 ref 9-154
message                   1     000000 constant        varying char(64)         initial array level 2 dcl 331 ref 9-168 9-172
my_name                         000167 constant        char(20)                 initial unaligned dcl 125 set ref 145* 155* 169*
                                                                                  186* 197* 221* 233* 253* 263* 268* 279* 291* 300*
n                                      parameter       fixed bin(17,0)          dcl 8-33 ref 8-31 8-38 8-39 8-42 8-45
n_chars                         000215 automatic       fixed bin(21,0)          dcl 61 set ref 212* 273*
new_station_name                000100 automatic       char(12)                 unaligned dcl 44 set ref 392* 398 415
new_terminal_name               000104 automatic       char(8)                  unaligned dcl 44 set ref 376* 414
null                                                   builtin function         dcl 9-148 in procedure "ERROR" ref 9-161 9-161 9-166
                                                                                  9-168
null                                                   builtin function         dcl 10-21 in procedure "NEXT_STMT" ref 10-27 10-35
null                                                   builtin function         dcl 81 in procedure "cv_cmcs_terminal_ctl" ref 174
                                                                                  175 176 177 183 250 265 314 317 320 323 8-37 8-39
                                                                                  8-42 8-45
null                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-64
                                                                                  7-73 7-79 7-86
object_name                     000216 automatic       char(32)                 unaligned dcl 61 set ref 202 210* 216* 221* 300*
object_ptr                      000226 automatic       pointer                  dcl 61 set ref 175* 216* 226 292* 298* 317 317*
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 6-68 ref 7-92 7-104
                                                                                  7-113 7-118 7-124
search                                                 builtin function         dcl 5-92 ref 7-92
severity                        000000 constant        fixed bin(17,0)          initial array level 2 packed unaligned dcl 331 ref
                                                                                  9-153 9-154 9-168 9-172
source_ptr                      000230 automatic       pointer                  dcl 61 set ref 174* 181* 183 273* 314 314*
station_ctl                            based           structure                level 1 dcl 2-13
station_ctl_eindex              000112 automatic       fixed bin(17,0)          dcl 2-17 set ref 394* 396*
station_ctl_entry                      based           structure                level 1 dcl 2-21
station_ctl_eptr                000114 automatic       pointer                  dcl 2-19 set ref 396* 398 398
station_ctl_ptr                 000010 internal static pointer                  dcl 2-11 set ref 247* 250 394 396
station_name                           based           char(12)                 level 2 in structure "station_ctl_entry" dcl 2-21
                                                                                  in procedure "cv_cmcs_terminal_ctl" ref 398
station_name             43            based           char(12)                 array level 3 in structure "terminal_ctl" dcl 3-14
                                                                                  in procedure "cv_cmcs_terminal_ctl" set ref 415*
string                                                 builtin function         dcl 81 set ref 413*
substr                                                 builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-92
                                                                                  7-126
substr                                                 builtin function         dcl 81 in procedure "cv_cmcs_terminal_ctl" ref 210
                                                                                  241 241 242 354 357 359 362 362 365 369 369
terminal_ctl                           based           structure                level 1 dcl 3-14
terminal_ctl_entry                     based           structure                level 1 dcl 3-22
terminal_ctl_entry_len          000245 constant        fixed bin(17,0)          initial dcl 3-8 set ref 228* 297
terminal_ctl_hdr_len            000234 constant        fixed bin(17,0)          initial dcl 3-8 set ref 228* 297
terminal_ctl_ptr                000012 internal static pointer                  dcl 3-12 set ref 226* 228* 297 412 412 412 413 413
                                                                                  414 414 415 415
terminal_ctl_version            000246 constant        fixed bin(17,0)          initial dcl 3-8 set ref 228*
token                                  based           structure                level 1 dcl 6-68
token_value                            based           char                     unaligned dcl 6-68 set ref 350 354 357 359 362 362
                                                                                  365 369 369 376 386 388 390 392 7-92 7-92 7-106*
                                                                                  7-113 7-128
translator_temp_$get_segment    000252 constant        entry                    external dcl 90 ref 263
translator_temp_$release_all_segments
                                000254 constant        entry                    external dcl 90 ref 320
tssi_$clean_up_segment          000262 constant        entry                    external dcl 90 ref 323
tssi_$finish_segment            000260 constant        entry                    external dcl 90 ref 298
tssi_$get_segment               000256 constant        entry                    external dcl 90 ref 216
verify                                                 builtin function         dcl 81 in procedure "cv_cmcs_terminal_ctl" ref 390
verify                                                 builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-92

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
LEGAL                                  internal static char(71)                 initial dcl 125
Pcomment                               automatic       pointer                  dcl 6-20
clock_                          000000 constant        entry                    external dcl 90
cmcs_create_queues_             000000 constant        entry                    external dcl 4-8
cmcs_date_time_                 000000 constant        entry                    external dcl 4-10
cmcs_decode_status_             000000 constant        entry                    external dcl 4-12
cmcs_expand_tree_path_          000000 constant        entry                    external dcl 4-14
cmcs_initiate_ctl_              000000 constant        entry                    external dcl 4-18
cmcs_print_                     000000 constant        entry                    external dcl 4-20
cmcs_purge_queues_              000000 constant        entry                    external dcl 4-22
cmcs_queue_ctl_$accept_message_count
                                000000 constant        entry                    external dcl 4-24
cmcs_queue_ctl_$disable         000000 constant        entry                    external dcl 4-25
cmcs_queue_ctl_$enable          000000 constant        entry                    external dcl 4-26
cmcs_queue_ctl_$print           000000 constant        entry                    external dcl 4-27
cmcs_queue_ctl_$purge           000000 constant        entry                    external dcl 4-28
cmcs_queue_ctl_$receive         000000 constant        entry                    external dcl 4-29
cmcs_queue_ctl_$send            000000 constant        entry                    external dcl 4-30
cmcs_queue_ctl_$stop_run        000000 constant        entry                    external dcl 4-31
cmcs_scramble_                  000000 constant        entry                    external dcl 4-33
cmcs_set_lock_$lock             000000 constant        entry                    external dcl 4-35
cmcs_set_lock_$unlock           000000 constant        entry                    external dcl 4-36
cmcs_station_ctl_$attach        000000 constant        entry                    external dcl 4-38
cmcs_station_ctl_$detach        000000 constant        entry                    external dcl 4-39
cmcs_station_ctl_$detach_name   000000 constant        entry                    external dcl 4-40
cmcs_station_ctl_$disable_input_terminal
                                000000 constant        entry                    external dcl 4-41
cmcs_station_ctl_$disable_output_terminal
                                000000 constant        entry                    external dcl 4-42
cmcs_station_ctl_$enable_input_terminal
                                000000 constant        entry                    external dcl 4-43
cmcs_station_ctl_$enable_output_terminal
                                000000 constant        entry                    external dcl 4-44
cmcs_station_ctl_$find_destination
                                000000 constant        entry                    external dcl 4-45
cmcs_station_ctl_$input_disabled
                                000000 constant        entry                    external dcl 4-46
cmcs_station_ctl_$output_disabled
                                000000 constant        entry                    external dcl 4-47
cmcs_station_ctl_$validate      000000 constant        entry                    external dcl 4-48
cmcs_status_list_ctl_$add       000000 constant        entry                    external dcl 4-50
cmcs_status_list_ctl_$delete    000000 constant        entry                    external dcl 4-51
cmcs_status_list_ctl_$move      000000 constant        entry                    external dcl 4-52
cmcs_terminal_ctl_$find         000000 constant        entry                    external dcl 4-54
cmcs_tree_ctl_$find_destination 000000 constant        entry                    external dcl 4-56
cmcs_tree_ctl_$find_index       000000 constant        entry                    external dcl 4-57
cmcs_tree_ctl_$find_qual_name   000000 constant        entry                    external dcl 4-59
cmcs_tree_ctl_$find_tree_path   000000 constant        entry                    external dcl 4-58
cmcs_wait_ctl_$add              000000 constant        entry                    external dcl 4-61
cmcs_wait_ctl_$clear_mp         000000 constant        entry                    external dcl 4-67
cmcs_wait_ctl_$delete           000000 constant        entry                    external dcl 4-62
cmcs_wait_ctl_$find             000000 constant        entry                    external dcl 4-63
cmcs_wait_ctl_$mp_available     000000 constant        entry                    external dcl 4-64
cmcs_wait_ctl_$mp_login         000000 constant        entry                    external dcl 4-65
cmcs_wait_ctl_$mp_logout        000000 constant        entry                    external dcl 4-66
cmcs_wait_ctl_$start_mp         000000 constant        entry                    external dcl 4-68
cmcs_wait_ctl_$stop_mp          000000 constant        entry                    external dcl 4-69
comment                                based           structure                level 1 dcl 6-20
comment_value                          based           char                     unaligned dcl 6-20
control_hdr_len                        internal static fixed bin(17,0)          initial dcl 1-7
control_hdr_ptr                        automatic       pointer                  dcl 1-9
get_group_id_                   000000 constant        entry                    external dcl 90
get_process_id_                 000000 constant        entry                    external dcl 90
hcs_$make_seg                   000000 constant        entry                    external dcl 90
hcs_$set_bc_seg                 000000 constant        entry                    external dcl 90
hcs_$truncate_seg               000000 constant        entry                    external dcl 90
lex_error_                      000000 constant        entry                    external dcl 90
max                                                    builtin function         dcl 5-92
pntep                                  automatic       pointer                  dcl 61
reverse                                                builtin function         dcl 81
station_ctl_entry_len                  internal static fixed bin(17,0)          initial dcl 2-7
station_ctl_hdr_len                    internal static fixed bin(17,0)          initial dcl 2-7
station_ctl_version                    internal static fixed bin(17,0)          initial dcl 2-7
stmt                                   based           structure                level 1 dcl 6-40
stmt_value                             based           char                     unaligned dcl 6-40
sys_info$max_seg_size                  external static fixed bin(18,0)          dcl 132
temp3                                  automatic       char(3)                  unaligned dcl 44
terminal_ctl_eindex                    automatic       fixed bin(17,0)          dcl 3-18
terminal_ctl_eptr                      automatic       pointer                  dcl 3-20
unique_chars_                   000000 constant        entry                    external dcl 90

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           003323 constant        entry                    internal dcl 9-139 ref 511 517 527 533
LEX                             003236 constant        entry                    internal dcl 8-31 ref 503 523
NEXT_STMT                       003634 constant        entry                    internal dcl 10-18 ref 513 529
RD_ACTION                       000070 constant        label                    array(7) dcl 503 ref 500
RD_MATCH                        003152 constant        label                    dcl 496 ref 7-90 7-92 7-101 7-109 7-113 7-118 7-128
                                                                                  492
RD_MATCH_NO_TOKEN               003155 constant        label                    dcl 497 ref 7-73 7-79 7-86
RD_NEXT_REDUCTION               002653 constant        label                    dcl 7-55 ref 7-68 7-84 7-88 7-99 7-104 7-111 7-116
                                                                                  7-120 7-124 7-130 493
RD_TEST_REDUCTION               002654 constant        label                    dcl 7-58 ref 7-53 506 515 525 531
RD_TEST_RESULT                  003146 constant        label                    dcl 492 ref 488 490
RD_TEST_TOKEN                   000060 constant        label                    array(6) dcl 7-73 ref 7-65 7-71
RD_TOKEN_FCN                    000066 constant        label                    array(2) dcl 487 ref 485
SEMANTIC_ANALYSIS               002643 constant        entry                    internal dcl 5-30 ref 286
add                             002620 constant        entry                    internal dcl 410 ref 521
clean_up                        002223 constant        entry                    internal dcl 311 ref 179 305
cv_cmcs_terminal_ctl            000517 constant        entry                    external dcl 42
report_error                    001122 constant        label                    dcl 186 ref 206
valid_station                   002521 constant        entry                    internal dcl 384 ref 489
valid_terminal                  002316 constant        entry                    internal dcl 346 ref 487

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4624        5124    4317        4634
Length      5576    4317       300         435     305         212

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cv_cmcs_terminal_ctl                674 external procedure  is an external procedure.  
on unit on line 179                  64 on unit               
clean_up                             70 internal procedure  is called by several nonquick procedures.  
valid_terminal                          internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
valid_station                           internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
add                                     internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
LEX                                     internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
ERROR                                   internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  
NEXT_STMT                               internal procedure  shares stack frame of external procedure cv_cmcs_terminal_ctl.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 station_ctl_ptr             cv_cmcs_terminal_ctl
000012 terminal_ctl_ptr            cv_cmcs_terminal_ctl
000014 BREAKS                      cv_cmcs_terminal_ctl
000055 IGBREAKS                    cv_cmcs_terminal_ctl
000116 LEXCTL                      cv_cmcs_terminal_ctl
000157 LEXDLM                      cv_cmcs_terminal_ctl
000220 first_time                  cv_cmcs_terminal_ctl
000221 TRACING                     cv_cmcs_terminal_ctl

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_cmcs_terminal_ctl     000100 new_station_name            cv_cmcs_terminal_ctl
                         000104 new_terminal_name           cv_cmcs_terminal_ctl
                         000106 j                           cv_cmcs_terminal_ctl
                         000110 aclinfo_ptr                 cv_cmcs_terminal_ctl
                         000112 station_ctl_eindex          cv_cmcs_terminal_ctl
                         000114 station_ctl_eptr            cv_cmcs_terminal_ctl
                         000116 APstmt                      cv_cmcs_terminal_ctl
                         000120 APtoken                     cv_cmcs_terminal_ctl
                         000122 area_ptr                    cv_cmcs_terminal_ctl
                         000124 arg_length                  cv_cmcs_terminal_ctl
                         000126 arg_ptr                     cv_cmcs_terminal_ctl
                         000130 bitcount                    cv_cmcs_terminal_ctl
                         000131 code                        cv_cmcs_terminal_ctl
                         000132 dname                       cv_cmcs_terminal_ctl
                         000204 ename                       cv_cmcs_terminal_ctl
                         000214 i                           cv_cmcs_terminal_ctl
                         000215 n_chars                     cv_cmcs_terminal_ctl
                         000216 object_name                 cv_cmcs_terminal_ctl
                         000226 object_ptr                  cv_cmcs_terminal_ctl
                         000230 source_ptr                  cv_cmcs_terminal_ctl
                         000240 Pthis_token                 cv_cmcs_terminal_ctl
                         000242 Pstmt                       cv_cmcs_terminal_ctl
                         000244 Ptoken                      cv_cmcs_terminal_ctl
                         000246 SPDL                        cv_cmcs_terminal_ctl
                         000247 MERROR_SEVERITY             cv_cmcs_terminal_ctl
                         000250 SERROR_CONTROL              cv_cmcs_terminal_ctl
                         000251 SERROR_PRINTED              cv_cmcs_terminal_ctl
                         000251 MIN_PRINT_SEVERITY          cv_cmcs_terminal_ctl
                         000252 PRINT_SEVERITY_CONTROL      cv_cmcs_terminal_ctl
                         000316 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000317 NRED                        SEMANTIC_ANALYSIS
                         000320 PRED                        SEMANTIC_ANALYSIS
                         000322 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000324 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000326 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000327 CODE                        SEMANTIC_ANALYSIS
                         000330 I                           SEMANTIC_ANALYSIS
                         000331 NUMBER                      SEMANTIC_ANALYSIS
                         000332 DIRECTION                   SEMANTIC_ANALYSIS
                         000364 i                           LEX
                         000376 Pstmt                       ERROR
                         000400 Perring_token               ERROR
                         000410 Ssearching                  NEXT_STMT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              alloc_auto_adj      mpfx2               enable              shorten_stack
ext_entry           int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cmcs_fillin_hdr_              com_err_                      cu_$arg_ptr                   cv_dec_check_
cv_dec_check_                 expand_pathname_              get_wdir_                     hcs_$delentry_seg
hcs_$initiate                 hcs_$initiate_count           hcs_$terminate_noname         lex_error_
lex_string_$init_lex_delims   lex_string_$lex               translator_temp_$get_segment
translator_temp_$release_all_segments                       tssi_$clean_up_segment        tssi_$finish_segment
tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_name         error_table_$badopt           error_table_$entlong
error_table_$translation_failed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     42 000516       542 000524    9    3 000525    9  168 000557       140 000561       142 000600       145 000602
    146 000626       150 000627       152 000657       155 000661       156 000713       160 000714       162 000733
    165 000754       169 000771       170 001023       174 001024       175 001026       176 001027       177 001030
    179 001031       181 001053       183 001116       186 001122       189 001155       193 001156       195 001166
    197 001170       198 001214       202 001215       205 001220       206 001223       210 001224       212 001241
    214 001246       216 001260       218 001310       221 001312       222 001345       226 001346       228 001351
    230 001367       233 001371       234 001415       238 001416       241 001421       242 001443       244 001451
    247 001532       250 001614       253 001621       255 001644       259 001645       263 001647       265 001667
    268 001673       269 001717       273 001720       276 002034       279 002036       280 002057       284 002060
    286 002062       288 002063       291 002066       292 002107       294 002120       297 002121       298 002133
    300 002153       305 002215       307 002221       311 002222       314 002230       317 002245       320 002263
    323 002301       326 002315       346 002316       350 002320       352 002323       354 002331       355 002343
    357 002347       359 002355       360 002366       362 002371       363 002420       365 002425       366 002434
    366 002442       367 002443       369 002451       371 002501       376 002506       378 002515       384 002521
    386 002523       388 002536       390 002543       392 002557       394 002562       396 002573       398 002600
    402 002613       404 002615       410 002620       412 002621       413 002627       414 002631       415 002635
    417 002642    5   30 002643       428 002644    7   50 002646    7   52 002651    7   53 002652    7   55 002653
 7   58 002654    7   60 002657    7   62 002661    7   63 002704    7   64 002707    7   65 002713    7   68 002723
 7   70 002724    7   71 002730    7   73 002732    7   79 002751    7   84 002762    7   86 002763    7   88 002767
 7   90 002770    7   92 002771    7   99 003025    7  101 003026    7  104 003031    7  106 003034    7  107 003060
 7  108 003062    7  109 003065    7  111 003066    7  113 003067    7  116 003103    7  118 003104    7  120 003110
 7  123 003111    7  124 003112    7  126 003116    7  127 003123    7  128 003127    7  130 003135       485 003136
    487 003140       488 003142       489 003143       490 003145       492 003146       493 003151       496 003152
    497 003155       499 003160       500 003162       503 003164       505 003170       506 003172       508 003173
    511 003174       513 003200       514 003201       515 003203       517 003204       519 003210       521 003211
    523 003212       524 003216       525 003220       527 003221       529 003225       530 003226       531 003230
    533 003231       535 003235    8   31 003236    8   36 003240    8   37 003242    8   38 003247    8   39 003251
 8   40 003263    8   41 003265    8   42 003267    8   44 003277    8   45 003300    8   47 003313    8   48 003315
 8   49 003320    8   51 003322    9  139 003323    9  153 003325    9  154 003335    9  156 003344    9  158 003353
 9  160 003354    9  161 003356    9  164 003371    9  166 003375    9  168 003377    9  172 003503    9  177 003632
10   18 003634   10   24 003635   10   25 003637   10   26 003642   10   27 003644   10   28 003652   10   29 003654
10   30 003661   10   31 003662   10   32 003663   10   35 003674   10   36 003700   10   39 003701


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
