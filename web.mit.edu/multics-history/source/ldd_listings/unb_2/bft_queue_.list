	COMPILATION LISTING OF SEGMENT bft_queue_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/24/88  0848.0 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 bft_queue_:
       10      proc (p_q_ptr, p_code);
       11 
       12 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,^indprocbody,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
       13 
       14 /* PROGRAM FUNCTION
       15*
       16*This is a collection of entrypoints which service the queues associated with
       17*bft.  Entrypoints contained are:
       18*
       19*   add
       20*   initialize
       21*   remove
       22*   terminate
       23*
       24*Calling bft_queue_ will return a pointer to the current queue.
       25**/
       26 
       27 
       28 /* NOTES
       29**/
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(87-10-06,Flegel), approve(87-10-23,MCR7787),
       33*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
       34*     Created.
       35*                                                   END HISTORY COMMENTS */
       36 
       37 /* PARAMETERS */
       38 dcl p_header	       bit(1) parameter;	    /* Display header required */
       39 dcl p_long_sw	       bit(1) parameter;	    /* Long display requested */
       40 dcl p_state	       bit(1) parameter;	    /* Transfer activity state */
       41 dcl p_id_sw	       fixed bin parameter;	    /* 0 = path, 1 = ID */
       42 dcl p_id		       char (*) parameter;	    /* Entry ID */
       43 dcl p_direction	       fixed bin parameter;	    /* Transfer direction */
       44 dcl p_priority	       fixed bin parameter;	    /* Element priority level */
       45 dcl p_e_ptr	       ptr parameter;	    /* Queue element pointer */
       46 dcl p_q_ptr	       ptr parameter;	    /* Pointer to bft queues */
       47 dcl p_code	       fixed bin (35) parameter;  /* Error code */
       48 
       49 /* MISC VARIABLES */
       50 dcl time_string	       char (20) var;
       51 dcl formatted_time	       char (250);
       52 dcl time_stamp	       fixed bin (71);
       53 dcl lock_sw	       bit(1);		    /* If the lock has been set */
       54 dcl match_q	       fixed bin;
       55 dcl first_slot	       fixed bin (35);
       56 dcl match_prev_slot	       fixed bin (35);
       57 dcl match_slot	       fixed bin (35);
       58 dcl match_found	       (2) bit (1);
       59 dcl prev_slot	       fixed bin (35);
       60 dcl i		       fixed bin;
       61 dcl mask		       bit (36) aligned;
       62 dcl slot		       fixed bin (35);	    /* Array position of queue element */
       63 dcl new_queue	       bit (1);		    /* Just created */
       64 
       65 /* STRUCTURES */
       66 
       67 /* SYSTEM CALLS */
       68 dcl date_time_	        entry (fixed bin(71), char(*));
       69 dcl request_id_	        entry (fixed bin(71)) returns(char(19));
       70 dcl ioa_		       	entry() options(variable);
       71 dcl match_request_id_      entry (fixed bin (71), char (*)) returns (bit (1) aligned);
       72 dcl hcs_$reset_ips_mask    entry (bit (36) aligned, bit (36) aligned);
       73 dcl hcs_$set_ips_mask      entry (bit (36) aligned, bit (36) aligned);
       74 dcl set_lock_$unlock       entry (bit (36) aligned, fixed bin (35));
       75 dcl set_lock_$lock	       entry (bit (36) aligned, fixed bin, fixed bin (35));
       76 dcl hcs_$truncate_seg      entry (ptr, fixed bin (19), fixed bin (35));
       77 dcl initiate_file_	       entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
       78 dcl hcs_$make_seg	       entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
       79 dcl user_info_	       entry (char (*), char (*), char (*));
       80 dcl user_info_$homedir     entry (char (*));
       81 
       82 /* SYSTEM CALL SUPPORT */
       83 dcl error_table_$noentry   fixed bin (35) ext static;
       84 dcl error_table_$request_id_ambiguous fixed bin (35) ext static;
       85 dcl error_table_$bad_conversion fixed bin (35) ext static;
       86 dcl error_table_$noalloc   fixed bin (35) ext static;
       87 dcl sys_info$max_seg_size  fixed bin (35) ext static;
       88 
       89 /* EXTERNAL CALLS */
       90 
       91 /* EXTERNAL CALL SUPPORT */
       92 dcl bft_error_table_$store_in_progress 	fixed bin(35) ext static;
       93 dcl bft_error_table_$fetch_in_progress 	fixed bin(35) ext static;
       94 dcl bft_error_table_$invalid_direction fixed bin (35) ext static;
       95 dcl bft_error_table_$no_entries fixed bin (35) ext static;
       96 dcl bft_error_table_$invalid_queue fixed bin (35) ext static;
       97 dcl bft_error_table_$invalid_priority fixed bin (35) ext static;
       98 dcl bft_error_table_$no_queue fixed bin (35) ext static;
       99 
      100 /* BUILTINS */
      101 dcl reverse	       builtin;
      102 dcl substr	       builtin;
      103 dcl verify	       builtin;
      104 dcl index		       builtin;
      105 dcl unspec	       builtin;
      106 dcl size		       builtin;
      107 dcl addr		       builtin;
      108 dcl null		       builtin;
      109 dcl rtrim		       builtin;
      110 
      111 /* CONDITIONS */
      112 dcl cleanup	       condition;
      113 
      114 /* CONSTANTS */
      115 
      116 /**/
      117 
      118 /* INITIALIZATION */
      119 
      120 	p_q_ptr = null;
      121 	lock_sw = "0"b;
      122 	call initialize_entry ();
      123 	on cleanup call set_lock_$unlock (queue.header.lockword, (0));
      124 
      125 /* MAIN */
      126 
      127 	p_q_ptr = null;
      128 	new_queue = find_bft_queue ("0"b, p_code);
      129 	if new_queue then
      130 	     p_code = bft_error_table_$no_queue;
      131 
      132 	p_q_ptr = queue_ptr;
      133 
      134 	goto BFT_QUEUE_RETURN;
      135 
      136 /**/
      137 
      138 /* INTERNAL ENTRIES */
      139 
      140 
      141 /* *** Entry: add - Internal entry for bft_queue_  *** */
      142 
      143 add:
      144      entry (p_q_ptr, p_e_ptr, p_priority, p_direction, p_code);
      145 
      146 
      147 /* ENTRY FUNCTION
      148*
      149*Add the provided element to the bft queue.
      150**/
      151 
      152 /* NOTES
      153**/
      154 
      155      lock_sw = "1"b;
      156      call initialize_entry ();
      157      on cleanup call set_lock_$unlock (queue.header.lockword, (0));
      158 
      159 /* If element pointer is null, then ignore */
      160 
      161      if p_e_ptr = null then
      162 	goto BFT_QUEUE_RETURN;
      163 
      164 /* If queue pointer is null, then error */
      165 
      166      if queue_ptr = null then do;
      167 	p_code = bft_error_table_$invalid_queue;
      168 	goto BFT_QUEUE_RETURN;
      169      end;
      170 
      171 /* If priority level is invalid, then error */
      172 
      173      if p_priority < BFT_MIN_PRIORITY | p_priority > BFT_MAX_PRIORITY then do;
      174 	p_code = bft_error_table_$invalid_priority;
      175 	goto BFT_QUEUE_RETURN;
      176      end;
      177 
      178 /* If direction is invalid, then error */
      179 
      180      if p_direction ^= BFT_PC_to_MULTICS & p_direction ^= BFT_MULTICS_to_PC then do;
      181 	p_code = bft_error_table_$invalid_direction;
      182 	goto BFT_QUEUE_RETURN;
      183      end;
      184 
      185 /* Find queue slot */
      186 
      187      call find_new_slot (slot, p_code);
      188      if p_code ^= 0 then
      189 	goto BFT_QUEUE_RETURN;
      190 
      191 /* Copy the element structure into the queue element */
      192 
      193      queue.array (slot) = p_e_ptr -> queue_element;
      194      queue.array (slot).flags.allocated = "1"b;
      195      queue.array (slot).next = 0;
      196 
      197 /* Chain the new element into the appropriate queue */
      198 
      199      call hcs_$set_ips_mask (""b, mask);
      200      if p_direction = BFT_PC_to_MULTICS then do;
      201 	if queue.header.fetch_queue (p_priority).last = 0 then
      202 	     queue.header.fetch_queue (p_priority).first = slot;
      203 	else
      204 	     queue.array (queue.header.fetch_queue (p_priority).last).next = slot;
      205 	queue.header.fetch_queue (p_priority).last = slot;
      206      end;
      207      else do;
      208 	if queue.header.store_queue (p_priority).last = 0 then
      209 	     queue.header.store_queue (p_priority).first = slot;
      210 	else
      211 	     queue.array (queue.header.store_queue (p_priority).last).next = slot;
      212 	queue.header.store_queue (p_priority).last = slot;
      213      end;
      214      call hcs_$reset_ips_mask (mask, mask);
      215 
      216      goto BFT_QUEUE_RETURN;
      217 
      218 /**/
      219 
      220 /* *** Entry: cancel - Internal entry for bft_queue_  *** */
      221 
      222 cancel:
      223      entry (p_q_ptr, p_id, p_id_sw, p_code);
      224 
      225 
      226 /* ENTRY FUNCTION
      227*
      228*Remove the specified entry from the transfer queue.  BFT will then not find the
      229*entry and will not transfer the entry.  Entries which are currently in
      230*transfer, ie.  the fetching or storing field of the queue header are initiated
      231*and meet the cancellation specs, will merely have their "initiated" bit field
      232*turned off.  It will then be up to the caller to check this bit field.
      233*
      234*ID's are either:
      235*
      236*	PATHNAME - absolute or relative, star NOT allowed
      237*	ENTRY    - entryname of request.
      238*	ID       - time stamp ID tagged to the entry.
      239**/
      240 
      241 /* NOTES
      242**/
      243 
      244      p_code = 0;
      245 
      246      lock_sw = "1"b;
      247      call initialize_entry ();
      248      on cleanup call set_lock_$unlock (queue.header.lockword, (0));
      249 
      250      match_slot = 0;
      251      match_prev_slot = 0;
      252 
      253 /* Verify the ID specifier */
      254 
      255      if p_id_sw = BFT_TIME_ID then do;
      256 	if verify (rtrim (p_id), "+-.0123456789") ^= 0 then do;
      257 	     p_code = error_table_$bad_conversion;
      258 	     goto BFT_QUEUE_RETURN;
      259 	end;
      260      end;
      261 
      262 /* Check the "running" elements, these have priority */
      263 
      264      if queue.header.storing.flags.initiated then do;
      265 	if match_request_type (addr (queue.header.storing), p_id, p_id_sw) then do;
      266 	     queue.header.storing.flags.initiated = "0"b;
      267 	     return;
      268 	end;
      269      end;
      270      if queue.header.fetching.flags.initiated then do;
      271 	if match_request_type (addr (queue.header.fetching), p_id, p_id_sw) then do;
      272 	     queue.header.fetching.flags.initiated = "0"b;
      273 	     return;
      274 	end;
      275      end;
      276 
      277 /* Hunt down the entry */
      278 
      279      match_found (*) = "0"b;
      280 
      281      do i = BFT_MIN_PRIORITY to BFT_MAX_PRIORITY;
      282 	first_slot = queue.header.store_queue (i).first;
      283 	do while (match_entry (first_slot, prev_slot, slot, rtrim (p_id), p_id_sw));
      284 	     if ^match_found (1) & ^match_found (2) then do;
      285 		match_found (1) = "1"b;
      286 		match_slot = slot;
      287 		match_prev_slot = prev_slot;
      288 		match_q = i;
      289 		first_slot = queue.array (slot).next;
      290 	     end;
      291 	     else do;
      292 		p_code = error_table_$request_id_ambiguous;
      293 		goto BFT_QUEUE_RETURN;
      294 	     end;
      295 	end;
      296 
      297 	first_slot = queue.header.fetch_queue (i).first;
      298 	do while (match_entry (first_slot, prev_slot, slot, rtrim (p_id), p_id_sw));
      299 	     if ^match_found (1) & ^match_found (2) then do;
      300 		match_found (2) = "1"b;
      301 		match_slot = slot;
      302 		match_prev_slot = prev_slot;
      303 		match_q = i;
      304 		first_slot = queue.array (slot).next;
      305 	     end;
      306 	     else do;
      307 		p_code = error_table_$request_id_ambiguous;
      308 		goto BFT_QUEUE_RETURN;
      309 	     end;
      310 	end;
      311      end;
      312 
      313 /* If there was a single match, remove the entry */
      314 
      315      if match_found (1) then
      316 	call remove_entry (queue.header.store_queue (match_q).first, queue.header.store_queue (match_q).last, match_prev_slot, match_slot);
      317 
      318      else if match_found (2) then
      319 	call remove_entry (queue.header.fetch_queue (match_q).first, queue.header.fetch_queue (match_q).last, match_prev_slot, match_slot);
      320 
      321      else do;
      322 	p_code = error_table_$noentry;
      323 	goto BFT_QUEUE_RETURN;
      324      end;
      325 
      326      goto BFT_QUEUE_RETURN;
      327 
      328 /**/
      329 
      330 /* *** Entry: display_element - Internal entry for bft_queue_  *** */
      331 
      332 display_element:
      333      entry (p_e_ptr, p_long_sw, p_direction, p_state, p_header);
      334 
      335 
      336 /* ENTRY FUNCTION
      337*
      338*Display a queue element.
      339**/
      340 
      341 /* NOTES
      342**/
      343 
      344      time_stamp = p_e_ptr -> queue_element.time_id;
      345 
      346      if ^p_long_sw then do;
      347 	if p_header then
      348 	     call ioa_ ("Multics Path^30tDirection^40tPC Path^55tID");
      349 	call ioa_ ("^a^33t^[->^;<-^]^[*^]^40t^a^55t^a^[ (running)^]",
      350 	     strip_path (p_e_ptr -> queue_element.multics_path, ">"),
      351 	     (p_direction = BFT_MULTICS_to_PC),
      352 	     p_e_ptr -> queue_element.flags.binary_sw,
      353 	     strip_path (p_e_ptr -> queue_element.pc_path, "\"),
      354 	     substr (request_id_ (time_stamp), 7, 8),
      355 	     p_state);
      356      end;
      357      else do;
      358 	time_string = request_id_ (time_stamp);
      359 	call date_time_ (time_stamp, formatted_time);
      360 	call ioa_ (
      361 	     "Source:^21t^[^a^s^;^s^a^]^/Destination:^21t^[^a^s^;^s^a^]"
      362 	     || "^/Request ID:^21t^a^/Time queued:^21t^a"
      363 	     || "^/State:^21t^[running^;unprocessed^]^/Notify:^21t^[yes^;no^]"
      364 	     || "^/File type:^21t^[binary^;ascii^]",
      365 	     (p_direction = BFT_PC_to_MULTICS),
      366 	     p_e_ptr -> queue_element.pc_path,
      367 	     p_e_ptr -> queue_element.multics_path,
      368 	     (p_direction = BFT_PC_to_MULTICS),
      369 	     p_e_ptr -> queue_element.multics_path,
      370 	     p_e_ptr -> queue_element.pc_path,
      371 	     time_string, rtrim (formatted_time),
      372 	     p_state, p_e_ptr -> queue_element.flags.notify_sw,
      373 	     p_e_ptr -> queue_element.flags.binary_sw);
      374      end;
      375 
      376      return;
      377 
      378 /**/
      379 
      380 /* *** Entry: initiate - Internal entry for bft_queue_  *** */
      381 
      382 initiate:
      383      entry (p_q_ptr, p_code);
      384 
      385 
      386 /* ENTRY FUNCTION
      387*
      388*This entry will initiate the bft queue segment.  If the segment does not
      389*already exist it will be created and formatted.
      390**/
      391 
      392 /* NOTES
      393**/
      394 
      395      p_q_ptr = null;
      396      lock_sw = "0"b;
      397      call initialize_entry ();
      398      on cleanup call set_lock_$unlock (queue.header.lockword, (0));
      399 
      400 /* Find the queue segment */
      401 
      402      new_queue = find_bft_queue ("1"b, p_code);
      403      if p_code ^= 0 then
      404 	goto BFT_QUEUE_RETURN;
      405 
      406 /* Initialize the header field */
      407 
      408      if new_queue then
      409 	call initialize_queue_header ();
      410 
      411      p_q_ptr = queue_ptr;
      412 
      413      goto BFT_QUEUE_RETURN;
      414 
      415 /**/
      416 
      417 /* *** Entry: remove - Internal entry for bft_queue_  *** */
      418 
      419 remove:
      420      entry (p_q_ptr, p_direction, p_code);
      421 
      422 
      423 /* ENTRY FUNCTION
      424*
      425*Move the next element from the specified queue (PC -> Multics or
      426*Multics -> PC) to the appropriate "in progress" element in the header.  The
      427*highest priority (1,2,3,4) is removed from the queue.
      428**/
      429 
      430 /* NOTES
      431**/
      432 
      433      lock_sw = "1"b;
      434      call initialize_entry ();
      435      on cleanup call set_lock_$unlock (queue.header.lockword, (0));
      436 
      437 /* If the queue ptr is null, then error */
      438 
      439      if queue_ptr = null then do;
      440 	p_code = bft_error_table_$invalid_queue;
      441 	goto BFT_QUEUE_RETURN;
      442      end;
      443 
      444 /* If the transfer in the specified direction is not complete, then error
      445* * Might as well verify the direction at the same time
      446* */
      447      if p_direction = BFT_PC_to_MULTICS then do;
      448 	if queue.header.fetching.flags.initiated then do;
      449 	     p_code = bft_error_table_$fetch_in_progress;
      450 	     goto BFT_QUEUE_RETURN;
      451 	end;
      452      end;
      453      else if p_direction = BFT_MULTICS_to_PC then do;
      454 	if queue.header.storing.flags.initiated then do;
      455 	     p_code = bft_error_table_$store_in_progress;
      456 	     goto BFT_QUEUE_RETURN;
      457 	end;
      458      end;
      459      else do;
      460 	p_code = bft_error_table_$invalid_direction;
      461 	goto BFT_QUEUE_RETURN;
      462      end;
      463 		
      464 /* Find the next element slot */
      465 
      466      call find_old_slot (p_direction, slot, p_code);
      467      if p_code ^= 0 | slot = 0 then do;
      468 	if p_code = 0 then
      469 	     p_code = bft_error_table_$no_entries;
      470 	goto BFT_QUEUE_RETURN;
      471      end;
      472 
      473 /* Move the element out the callers structure */
      474 
      475      queue.array (slot).flags.initiated = "1"b;
      476      if p_direction = BFT_PC_to_MULTICS then do;
      477 	queue.header.fetch_file_pos = 0;
      478 	queue.header.fetching = queue.array (slot);
      479      end;
      480      else do;
      481 	queue.header.store_file_pos = 0;
      482 	queue.header.storing = queue.array (slot);
      483      end;
      484 
      485      call free_old_slot (slot, p_code);
      486      if p_code ^= 0 then
      487 	goto BFT_QUEUE_RETURN;
      488 
      489      goto BFT_QUEUE_RETURN;
      490 
      491 /**/
      492 
      493 /* GLOBAL LABEL ENTRY */
      494 
      495 /* *** Label: BFT_QUEUE_RETURN - Internal label for bft_queue_ *** */
      496 
      497 /* LABEL FUNCTION
      498*
      499*This label is to be used to return from the bft_queue_ entry points to the
      500*caller of that entry.  It serves to unlock the lockword that exists within
      501*the queue segment.
      502**/
      503 
      504 BFT_QUEUE_RETURN:
      505 
      506      if lock_sw then
      507 	call set_lock_$unlock (queue.header.lockword, (0));
      508 
      509      return;
      510 
      511 /**/
      512 
      513 /* INTERNAL PROCEDURES */
      514 
      515 
      516 /* *** Procedure: allocate_slot - Internal proc for bft_queue_  *** */
      517 
      518 allocate_slot:
      519      proc (p_code);
      520 
      521 
      522 /* PROCEDURE FUNCTION
      523*
      524*Allocate another element slot at the end of the segment.
      525**/
      526 
      527 /* NOTES
      528**/
      529 
      530 /* PARAMETERS */
      531 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      532 
      533 /* MISC VARIABLES */
      534 dcl mask		       bit(36) aligned;
      535 dcl new_slot	       fixed bin (35);
      536 
      537 /* STRUCTURES */
      538 
      539 /* INITIALIZATION */
      540      p_code = 0;
      541 
      542 /* MAIN */
      543 
      544      if size (queue) + size (queue_element) > sys_info$max_seg_size then do;
      545 	p_code = error_table_$noalloc;
      546 	return;
      547      end;
      548 
      549 /* Increase the queue size */
      550 
      551      new_slot = queue.header.segment_size + 1;
      552      call initialize_element (addr (queue.array (new_slot)));
      553 
      554      call hcs_$set_ips_mask (""b, mask);
      555      queue.array (new_slot).next = queue.header.free_list;
      556      queue.header.free_list = new_slot;
      557      queue.header.segment_size = new_slot;
      558      call hcs_$reset_ips_mask (mask, mask);
      559 
      560      end allocate_slot;
      561 
      562 /**/
      563 
      564 /* *** Procedure: find_bft_queue - Internal proc for bft_queue_  *** */
      565 
      566 find_bft_queue:
      567      proc (p_create_sw, p_code) returns (bit (1));
      568 
      569 
      570 /* PROCEDURE FUNCTION
      571*
      572*Get a pointer to the bft queue segment.
      573**/
      574 
      575 /* NOTES
      576**/
      577 
      578 /* PARAMETERS */
      579 dcl p_create_sw	       bit (1) parameter;	    /* True if to be created */
      580 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      581 
      582 /* MISC VARIABLES */
      583 dcl code		       fixed bin (35);
      584 dcl name		       char (168);		    /* Queue segment name */
      585 dcl home_path	       char (64);		    /* Home directory */
      586 dcl account_id	       char (32);
      587 dcl project_id	       char (9);
      588 dcl person_id	       char (22);
      589 
      590 /* STRUCTURES */
      591 
      592 /* INITIALIZATION */
      593 
      594      p_code = 0;
      595 
      596 /* MAIN */
      597 
      598      call user_info_$homedir (home_path);
      599      call user_info_ (person_id, project_id, account_id);
      600      name = rtrim (person_id) || ".bft";
      601 
      602 /* If the segment is to be created, create it if it doesn't exist. */
      603 
      604      if p_create_sw then do;
      605 	call hcs_$make_seg (home_path, name, "", RW_ACCESS_BIN, queue_ptr,
      606 	     code);
      607 	return ((code = 0));
      608      end;
      609 
      610 /* Else do not attempt to create the queue, just look for it */
      611 
      612      else do;
      613 	call initiate_file_ (home_path, name, unspec (RW_ACCESS_BIN),
      614 	     queue_ptr, (0), code);
      615 	return ((code ^= 0));
      616      end;
      617 
      618      end find_bft_queue;
      619 
      620 /**/
      621 
      622 /* *** Procedure: find_old_slot - Internal proc for bft_queue_  *** */
      623 
      624 find_old_slot:
      625      proc (p_direction, p_slot, p_code);
      626 
      627 
      628 /* PROCEDURE FUNCTION
      629*
      630*Find the next element of highest priority in the specified direction.
      631**/
      632 
      633 /* NOTES
      634*
      635*The entry is removed from the specified queue but is not released to the free
      636*list.
      637**/
      638 
      639 /* PARAMETERS */
      640 dcl p_direction	       fixed bin parameter;	    /* Direction of element */
      641 dcl p_slot	       fixed bin (35) parameter;  /* Found slot */
      642 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      643 
      644 /* MISC VARIABLES */
      645 dcl mask		       bit(36) aligned;
      646 dcl i		       fixed bin;
      647 
      648 /* STRUCTURES */
      649 
      650 /* INITIALIZATION */
      651      p_code = 0;
      652      p_slot = 0;
      653 
      654 /* MAIN */
      655 
      656      do i = 1 to 4;
      657 	if p_direction = BFT_PC_to_MULTICS then do;
      658 	     if queue.header.fetch_queue (i).first ^= 0 then do;
      659 		call hcs_$set_ips_mask (""b, mask);
      660 		p_slot = queue.header.fetch_queue (i).first;
      661 		queue.header.fetch_queue (i).first = queue.array (p_slot).next;
      662 		if queue.header.fetch_queue (i).first = 0 then
      663 		     queue.header.fetch_queue (i).last = 0;
      664 		call hcs_$reset_ips_mask (mask, mask);
      665 
      666 		return;
      667 	     end;
      668 	end;
      669 	else do;
      670 	     if queue.header.store_queue (i).first ^= 0 then do;
      671 		call hcs_$set_ips_mask (""b, mask);
      672 		p_slot = queue.header.store_queue (i).first;
      673 		queue.header.store_queue (i).first = queue.array (p_slot).next;
      674 		if queue.header.store_queue (i).first = 0 then
      675 		     queue.header.store_queue (i).last = 0;
      676 		call hcs_$reset_ips_mask (mask, mask);
      677 
      678 		return;
      679 	     end;
      680 	end;
      681      end;
      682 
      683 /* Element was not found, so it's an error */
      684 
      685      p_code = bft_error_table_$no_entries;
      686 
      687      end find_old_slot;
      688 
      689 /**/
      690 
      691 /* *** Procedure: find_new_slot - Internal proc for bft_queue_  *** */
      692 
      693 find_new_slot:
      694      proc (p_slot, p_code);
      695 
      696 
      697 /* PROCEDURE FUNCTION
      698*
      699*Find an empty position in the queue element array 
      700**/
      701 
      702 /* NOTES
      703**/
      704 
      705 /* PARAMETERS */
      706 dcl p_slot	       fixed bin (35) parameter;  /* Found slot in array */
      707 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      708 
      709 /* MISC VARIABLES */
      710 dcl mask		       bit(36) aligned;
      711 
      712 /* STRUCTURES */
      713 
      714 /* INITIALIZATION */
      715      p_code = 0;
      716      p_slot = 0;
      717 
      718 /* MAIN */
      719 
      720      if queue.header.free_list = 0 then do;
      721 	call allocate_slot (p_code);
      722 	if p_code ^= 0 then
      723 	     return;
      724      end;
      725 
      726      call hcs_$set_ips_mask (""b, mask);
      727      p_slot = queue.header.free_list;
      728      queue.header.free_list = queue.array (queue.header.free_list).next;
      729      queue.array (p_slot).next = 0;
      730      call hcs_$reset_ips_mask (mask, mask);
      731 
      732      end find_new_slot;
      733 
      734 /**/
      735 
      736 /* *** Procedure: free_old_slot - Internal proc for bft_queue_  *** */
      737 
      738 free_old_slot:
      739      proc (p_slot, p_code);
      740 
      741 
      742 /* PROCEDURE FUNCTION
      743*
      744*Place the specified slot into the free list.  Check if a page of the queue
      745*segment can be released.
      746**/
      747 
      748 /* NOTES
      749**/
      750 
      751 /* PARAMETERS */
      752 dcl p_slot	       fixed bin (35) parameter;  /* Slot to be freed */
      753 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      754 
      755 /* MISC VARIABLES */
      756 dcl mask		       bit(36) aligned;
      757 
      758 /* STRUCTURES */
      759 
      760 /* INITIALIZATION */
      761      p_code = 0;
      762 
      763 /* MAIN */
      764 
      765 /* Add the element to the free list */
      766 
      767      call initialize_element (addr (queue.array (p_slot)));
      768      call hcs_$set_ips_mask (""b, mask);
      769      queue.array (p_slot).next = queue.header.free_list;
      770      queue.header.free_list = p_slot;
      771      call hcs_$reset_ips_mask (mask, mask);
      772 
      773 /* If the element is the last element in the segment, shrink the segment */
      774 
      775      if p_slot = queue.header.segment_size then do;
      776 	call free_seg (p_code);
      777 	if p_code ^= 0 then
      778 	     return;
      779      end;
      780 
      781      end free_old_slot;
      782 
      783 /**/
      784 
      785 /* *** Procedure: free_seg - Internal proc for bft_queue_  *** */
      786 
      787 free_seg:
      788      proc (p_code);
      789 
      790 
      791 /* PROCEDURE FUNCTION
      792*
      793*Reduce the segment size of the queue, truncate the segment to the nearest page.
      794**/
      795 
      796 /* NOTES
      797**/
      798 
      799 /* PARAMETERS */
      800 dcl p_code	       fixed bin (35) parameter;  /* Error code */
      801 
      802 /* MISC VARIABLES */
      803 dcl mask		       bit(36) aligned;
      804 dcl word_count	       fixed bin (19);	    /* New segment length */
      805 dcl previous_slot	       fixed bin (35);	    /* Slot before current search */
      806 dcl free_slot	       fixed bin (35);	    /* Slot to free */
      807 dcl slot		       fixed bin (35);	    /* Index slot */
      808 dcl last_alloc	       fixed bin (35);	    /* Last allocated element */
      809 dcl total_free	       fixed bin (35);	    /* Elements to free */
      810 
      811 /* STRUCTURES */
      812 
      813 /* INITIALIZATION */
      814      p_code = 0;
      815 
      816 /* MAIN */
      817 
      818 /* Find last NON-allocated element */
      819 
      820      total_free = 0;
      821      last_alloc = queue.header.segment_size;
      822      do while (^queue.array (last_alloc).flags.allocated & last_alloc > 0);
      823 	total_free = total_free + 1;
      824 	last_alloc = last_alloc - 1;
      825      end;
      826 
      827 /* Remove the slots to be released from the free list */
      828 
      829      previous_slot = 0;
      830      slot = queue.header.free_list;
      831      do while (slot ^= 0);
      832 	if slot > last_alloc then do;
      833 	     call hcs_$set_ips_mask (""b, mask);
      834 	     free_slot = slot;
      835 	     if previous_slot = 0 then do;	    /* First in list */
      836 		slot = queue.array (free_slot).next;
      837 		queue.header.free_list = slot;
      838 	     end;
      839 	     else do;			    /* Middle of list */
      840 		queue.array (previous_slot).next = queue.array (free_slot).next;
      841 		previous_slot = slot;
      842 		slot = queue.array (slot).next;
      843 	     end;
      844 	     call hcs_$reset_ips_mask (mask, mask);
      845 
      846 	     call initialize_element (addr (queue.array (free_slot)));
      847 	end;
      848 	else do;
      849 	     previous_slot = slot;
      850 	     slot = queue.array (slot).next;
      851 	end;
      852 
      853 	queue.header.segment_size = last_alloc;
      854 	word_count = size (queue_header) + (last_alloc * size (queue_element));
      855 	call hcs_$truncate_seg (queue_ptr, word_count, p_code);
      856 	if p_code ^= 0 then
      857 	     return;
      858      end;
      859 
      860      end free_seg;
      861 
      862 /**/
      863 
      864 /* *** Procedure: initialize_element - Internal proc for bft_queue_  *** */
      865 
      866 initialize_element:
      867      proc (p_e_ptr);
      868 
      869 
      870 /* PROCEDURE FUNCTION
      871*
      872*Initialize the element structure.
      873**/
      874 
      875 /* NOTES
      876**/
      877 
      878 /* PARAMETERS */
      879 dcl p_e_ptr	       ptr parameter;	    /* Element to be initialized */
      880 
      881 /* MISC VARIABLES */
      882 
      883 /* STRUCTURES */
      884 
      885 /* INITIALIZATION */
      886 
      887 /* MAIN */
      888 
      889      p_e_ptr -> queue_element.next = 0;
      890      p_e_ptr -> queue_element.multics_path = "";
      891      p_e_ptr -> queue_element.pc_path = "";
      892      p_e_ptr -> queue_element.time_id = 0;
      893      p_e_ptr -> queue_element.flags.allocated = "0"b;
      894      p_e_ptr -> queue_element.flags.binary_sw = "0"b;
      895      p_e_ptr -> queue_element.flags.pad = ""b;
      896      p_e_ptr -> queue_element.flags.mbz = ""b;
      897 
      898      end initialize_element;
      899 
      900 /**/
      901 
      902 /* *** Procedure: initialize_entry - Internal proc for bft_queue_  *** */
      903 
      904 initialize_entry:
      905      proc ();
      906 
      907 
      908 /* PROCEDURE FUNCTION
      909*
      910*Initialize entrypoint variables.
      911**/
      912 
      913 /* MAIN */
      914 
      915      p_code = 0;
      916      queue_ptr = p_q_ptr;
      917 
      918 /* Lock out other accesses to the queue segment */
      919 
      920      if lock_sw then
      921 	call set_lock_$lock (queue.header.lockword, BFT_QUEUE_WAIT_TIME, p_code);
      922 
      923      end initialize_entry;
      924 
      925 /**/
      926 
      927 /* *** Procedure: initialize_queue_header - Internal proc for bft_queue_  *** */
      928 
      929 initialize_queue_header:
      930      proc ();
      931 
      932 
      933 /* PROCEDURE FUNCTION
      934*
      935*Initialize the fields of the queue header to casue the queue to have 0
      936*elements.
      937**/
      938 
      939 /* NOTES
      940**/
      941 
      942 /* PARAMETERS */
      943 
      944 /* MISC VARIABLES */
      945 
      946 /* STRUCTURES */
      947 
      948 /* INITIALIZATION */
      949 
      950 /* MAIN */
      951 
      952      queue.header.version = "VERSION1";
      953      queue.header.lockword = ""b;
      954      queue.header.store_queue (*).last = 0;
      955      queue.header.store_queue (*).first = 0;
      956      queue.header.store_queue (*).flags.pad = "0"b;
      957      queue.header.fetch_queue (*).last = 0;
      958      queue.header.fetch_queue (*).first = 0;
      959      queue.header.fetch_queue (*).flags.pad = "0"b;
      960      queue.header.storing.flags.initiated = "0"b;
      961      queue.header.store_file_pos = 0;
      962      queue.header.fetching.flags.initiated = "0"b;
      963      queue.header.fetch_file_pos = 0;
      964      queue.header.free_list = 0;
      965      queue.header.segment_size = 0;
      966 
      967      end initialize_queue_header;
      968 
      969 /**/
      970 
      971 /* *** Procedure: match_entry - Internal proc for bft_queue_  *** */
      972 
      973 match_entry:
      974      proc (p_start_slot, p_prev_slot, p_slot, p_id, p_id_sw) returns (bit (1));
      975 
      976 
      977 /* PROCEDURE FUNCTION
      978*
      979*Find a match in the chain specified by start_slot.
      980**/
      981 
      982 /* NOTES
      983**/
      984 
      985 /* PARAMETERS */
      986 dcl p_id_sw	       fixed bin parameter;	    /* A time ID */
      987 dcl p_id		       char (*) parameter;	    /* Match ID */
      988 dcl p_start_slot	       fixed bin (35) parameter;  /* Start of queue list */
      989 dcl p_prev_slot	       fixed bin (35) parameter;  /* Previous slot to matched entry */
      990 dcl p_slot	       fixed bin (35) parameter;  /* Slot matched */
      991 
      992 /* MISC VARIABLES */
      993 
      994 /* STRUCTURES */
      995 
      996 /* INITIALIZATION */
      997 
      998 /* MAIN */
      999      p_prev_slot = 0;
     1000      p_slot = p_start_slot;
     1001      do while (p_slot ^= 0);
     1002 	if match_request_type (addr (queue.array (p_slot)), p_id, p_id_sw) then
     1003 	     return ("1"b);
     1004 
     1005 	p_prev_slot = p_slot;
     1006 	p_slot = queue.array (p_prev_slot).next;
     1007      end;
     1008 
     1009      return ("0"b);
     1010 
     1011      end match_entry;
     1012 
     1013 /**/
     1014 
     1015 /* *** Procedure: match_request_type - Internal proc for bft_queue_  *** */
     1016 
     1017 match_request_type:
     1018      proc (p_e_ptr, p_id, p_id_sw) returns (bit(1));
     1019 
     1020 
     1021 /* PROCEDURE FUNCTION
     1022*
     1023*Verify the element passed against the ID and ID type provided.
     1024**/
     1025 
     1026 /* NOTES
     1027**/
     1028 
     1029 /* PARAMETERS */
     1030 dcl p_e_ptr	       ptr parameter;	    /* Element to match */
     1031 dcl p_id		       char (*) parameter;	    /* Match ID */
     1032 dcl p_id_sw	       fixed bin parameter;	    /* Type of id */
     1033 
     1034 /* MISC VARIABLES */
     1035 
     1036 /* STRUCTURES */
     1037 
     1038 /* INITIALIZATION */
     1039 
     1040 /* MAIN */
     1041 
     1042      if p_id_sw = BFT_TIME_ID then do;
     1043 	if match_request_id_ (p_e_ptr -> queue_element.time_id, p_id) then
     1044 	     return ("1"b);
     1045      end;
     1046 
     1047      else if p_id_sw = BFT_PATH_ID then do;
     1048 	if rtrim (p_id) = rtrim (p_e_ptr -> queue_element.multics_path)
     1049 	     | rtrim (p_id) = rtrim (p_e_ptr -> queue_element.pc_path)
     1050 	then
     1051 	     return ("1"b);
     1052      end;
     1053 
     1054      else do;
     1055 	if rtrim (p_id) = strip_path (rtrim (p_e_ptr -> queue_element.multics_path), ">") then
     1056 	     return ("1"b);
     1057 
     1058 	if rtrim (p_id) = strip_path (rtrim (p_e_ptr -> queue_element.pc_path), "\") then
     1059 	     return ("1"b);
     1060      end;
     1061 
     1062      return ("0"b);
     1063 
     1064 end match_request_type;
     1065 
     1066 /**/
     1067 
     1068 /* *** Procedure: remove_entry - Internal proc for bft_queue_  *** */
     1069 
     1070 remove_entry:
     1071      proc (p_start_slot, p_last_slot, p_prev_slot, p_slot);
     1072 
     1073 
     1074 /* PROCEDURE FUNCTION
     1075*
     1076*Remove slot from the queue.
     1077**/
     1078 
     1079 /* NOTES
     1080**/
     1081 
     1082 /* PARAMETERS */
     1083 dcl p_last_slot	       fixed bin (35) parameter;  /* Last entry in list */
     1084 dcl p_start_slot	       fixed bin (35) parameter;  /* Start of list */
     1085 dcl p_prev_slot	       fixed bin (35) parameter;  /* Predecessor to slot */
     1086 dcl p_slot	       fixed bin (35) parameter;  /* Slot to be removed */
     1087 
     1088 /* MISC VARIABLES */
     1089 
     1090 /* STRUCTURES */
     1091 
     1092 /* INITIALIZATION */
     1093 
     1094 /* MAIN */
     1095 
     1096      if queue.array (p_slot).next = 0 then
     1097 	p_last_slot = p_prev_slot;
     1098 
     1099      if p_prev_slot = 0 then
     1100 	p_start_slot = queue.array (p_slot).next;
     1101      else
     1102 	queue.array (p_prev_slot).next = queue.array (p_slot).next;
     1103 
     1104      call free_old_slot (p_slot, (0));
     1105 
     1106      end remove_entry;
     1107 
     1108 /**/
     1109 
     1110 /* *** Procedure: strip_path - Internal proc for bft_queue_  *** */
     1111 
     1112 strip_path:
     1113      proc (p_path, p_separator) returns (char (*));
     1114 
     1115 
     1116 /* PROCEDURE FUNCTION
     1117*
     1118*Strip of the entryname from the given path, given the directory spearator.
     1119**/
     1120 
     1121 /* NOTES
     1122**/
     1123 
     1124 /* PARAMETERS */
     1125 dcl p_path	       char (*) parameter;	    /* Path to be stripped */
     1126 dcl p_separator	       char (1) parameter;	    /* Directory separator */
     1127 
     1128 /* MISC VARIABLES */
     1129 dcl indx		       fixed bin (21);	    /* Revers entry index */
     1130 
     1131 /* STRUCTURES */
     1132 
     1133 /* INITIALIZATION */
     1134 
     1135 /* MAIN */
     1136 
     1137      indx = index (reverse (rtrim (p_path)), p_separator) - 1;
     1138      if indx < 0 then
     1139 	return (p_path);
     1140 
     1141      return (reverse (substr (reverse (rtrim (p_path)), 1, indx)));
     1142 
     1143 end strip_path;
     1144 
     1145 /**/
     1146 
     1147 /* INCLUDE FILES */
  1     1 /*  BEGIN INCLUDE FILE: bft_values.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-07-15,Flegel), approve(87-07-15,MCR7580),
  1     6*     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
  1     7*     Created.
  1     8*  2) change(87-10-23,Flegel), approve(87-10-23,MCR7787),
  1     9*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  1    10*     Converted to use with new queueing strategy;  added data_block structure;
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
  1    14 
  1    15 dcl bft_minor_$add_to_fetch_queue fixed bin int static options (constant) init (64);
  1    16 dcl bft_minor_$add_to_store_queue fixed bin int static options (constant) init (65);
  1    17 dcl bft_minor_$check_file_length fixed bin int static options (constant) init (66);
  1    18 dcl bft_minor_$initiate_fetch fixed bin int static options (constant) init (67);
  1    19 dcl bft_minor_$bft_shut_down fixed bin int static options (constant) init (68);
  1    20 dcl bft_minor_$position_file_pointer fixed bin int static options (constant) init (69);
  1    21 dcl bft_minor_$receive_data fixed bin int static options (constant) init (70);
  1    22 dcl bft_minor_$receive_eof fixed bin int static options (constant) init (71);
  1    23 dcl bft_minor_$recover_fetch fixed bin int static options (constant) init (72);
  1    24 dcl bft_minor_$recover_store fixed bin int static options (constant) init (73);
  1    25 dcl bft_minor_$read_error fixed bin int static options (constant) init (74);
  1    26 dcl bft_minor_$initiate_store fixed bin int static options (constant) init (75);
  1    27 dcl bft_minor_$write_error fixed bin int static options (constant) init (76);
  1    28 dcl bft_minor_$send_data   fixed bin int static options (constant) init (77);
  1    29 dcl bft_minor_$cancel_request fixed bin int static options (constant) init (78);
  1    30 dcl bft_minor_$expand_pc_path fixed bin int static options (constant) init (80);
  1    31 dcl bft_minor_$full_pc_path fixed bin int static options (constant) init (81);
  1    32 
  1    33 
  1    34 dcl BFT_MINOR_CAPS	       fixed bin int static options (constant) init (13);
  1    35 dcl BFT_INBUFFER_SIZE      fixed bin int static options (constant) init (128);
  1    36 dcl BFT_OUTBUFFER_SIZE     fixed bin int static options (constant) init (128);
  1    37 dcl BFT_BLOCK_SIZE	       fixed bin (21) int static options (constant) init (110);
  1    38 dcl BFT_FIRST	       char (1) int static options (constant) init (" ");
  1    39 dcl BFT_NEXT	       char (1) int static options (constant) init ("!");
  1    40 dcl DELIM_CHAR	       char (1) based (addr (DEL));
  1    41 dcl DEL		       bit (9) unaligned internal static
  1    42 		       options (constant) init ("011111111"b);
  1    43 
  1    44 dcl 01 bft_values_struct,
  1    45        02 destination_filename char (164),
  1    46        02 source_filename  char (164);
  1    47 
  1    48 /* New declarations for queueing */
  1    49 
  1    50 dcl BFT_PC_to_MULTICS     fixed bin internal static options (constant)
  1    51 		      init (32);
  1    52 dcl BFT_MULTICS_to_PC     fixed bin internal static options (constant)
  1    53 		      init (33);
  1    54 dcl BFT_DATA_BLOCK_VERSION_1 char (8) internal static options (constant)
  1    55 		      init ("VERSION1");
  1    56 dcl BFT_INBUFF_LENGTH     fixed bin internal static options (constant)
  1    57 		      init (128);
  1    58 dcl BFT_OUTBUFF_LENGTH    fixed bin internal static options (constant)
  1    59 		      init (128);
  1    60 
  1    61 dcl data_block_ptr	      ptr;		    /* Data to be kept around */
  1    62 dcl 01 data_block	      based (data_block_ptr),
  1    63        02 version	      char (8),		    /* Version ID */
  1    64        02 pc_bft_num      fixed bin,		    /* Major of PC:BFT */
  1    65        02 inbuff_len      fixed bin,		    /* Input buffer length */
  1    66        02 outbuff_len     fixed bin,		    /* Output buffer length */
  1    67        02 receive_iocb_ptr ptr,		    /* IOCB of receiving file */
  1    68        02 send_iocb_ptr   ptr,		    /* IOCB of sending file */
  1    69        02 system_free_area_ptr ptr,		    /* Pointer to sys free */
  1    70        02 fetch_pending   ptr,		    /* Fetch waiting for PC path */
  1    71        02 store_pending   ptr,		    /* Store waiting for PC path */
  1    72        02 queue_ptr	      ptr,		    /* BFT queue segment */
  1    73        02 flags,
  1    74 	03 shut_down_sw bit (1) unal,		    /* BFT is shutting down */
  1    75 	03 pad	      bit (35) unal;
  1    76 
  1    77 /* Structure to contain transfer requests awaiting a PC path expansion */
  1    78 
  1    79 dcl 01 pending	      based,
  1    80        02 multics_path    char (168),		    /* Multics path */
  1    81        02 pc_path	      char (66),		    /* PC path */
  1    82        02 flags	      bit(36),		    /* Transfer modes */
  1    83        02 switches,
  1    84 	03 processing_sw bit (1) unal,	    /* Waiting for PC answer */
  1    85 	03 first_sw     bit (1) unal,		    /* First match requested */
  1    86 	03 pad	      bit (34) unal,
  1    87        02 priority	      fixed bin,		    /* Priority */
  1    88        02 id	      fixed bin,		    /* Request ID */
  1    89        02 next	      ptr;		    /* Next in chain */
  1    90 
  1    91 /*  END INCLUDE FILE: bft_values.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1148 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1149 
  3     1 /*  BEGIN INCLUDE FILE: bft_queue.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(87-10-06,Flegel), approve(87-10-23,MCR7787),
  3     5*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  3     6*     Created.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9 
  3    10 /* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,^indprocbody,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
  3    11 
  3    12 dcl BFT_QUEUE_VERSION_1    char (8) internal static options (constant)
  3    13 		       init ("VERSION1");
  3    14 dcl BFT_QUEUE_PRIORITIES   fixed bin internal static options (constant)
  3    15 		       init (4);
  3    16 dcl BFT_QUEUE_WAIT_TIME    fixed bin internal static options (constant)
  3    17 		       init (30);
  3    18 
  3    19 /* Queue */
  3    20 
  3    21 dcl queue_ptr	       ptr;
  3    22 dcl 01 queue	      based (queue_ptr) aligned,
  3    23        02 header	      like queue_header,
  3    24        02 array	      (queue.header.segment_size) like queue_element;
  3    25 
  3    26 /* Queue header */
  3    27 
  3    28 dcl 01 queue_header	       based,
  3    29        02 version	       char (8),		    /* Segment ID */
  3    30        02 lockword	       bit (36) aligned,	    /* Segment lock */
  3    31        02 store_queue      (4),		    /* Multics -> PC */
  3    32 	03 last	       fixed bin (35),	    /* Last element */
  3    33 	03 first	       fixed bin (35),	    /* Entry transferring */
  3    34 	03 flags,
  3    35 	   04 pad	       bit (36) unal,
  3    36        02 fetch_queue      (4),		    /* PC -> Multics */
  3    37 	03 last	       fixed bin (35),	    /* Last element */
  3    38 	03 first	       fixed bin (35),	    /* Entry transferring */
  3    39 	03 flags,
  3    40 	   04 pad	       bit (36) unal,
  3    41        02 storing	       like queue_element,	    /* Current store */
  3    42        02 store_file_pos   fixed bin (21),	    /* Position is send */
  3    43        02 fetching	       like queue_element,	    /* Current fetch */
  3    44        02 fetch_file_pos   fixed bin (21),	    /* Positin in fetch */
  3    45        02 free_list	       fixed bin (35),	    /* Free entries in Q */
  3    46        02 segment_size     fixed bin (35);	    /* Records in segment */
  3    47 
  3    48 /* Queue element definition */
  3    49 
  3    50 dcl 01 queue_element       based,
  3    51        02 next	       fixed bin (35),	    /* Next in Q */
  3    52        02 multics_path     char (168),		    /* Path on Multics */
  3    53        02 pc_path	       char (66),		    /* Drive:Path on PC */
  3    54        02 time_id	       fixed bin (71),	    /* Time stamp id */
  3    55        02 flags	       like bft_queue_flags,	    /* Entry switches */
  3    56        02 mbz	       bit (18);		    /* Word boundary size */
  3    57 
  3    58 /* We need the definitions for the queue flags */
  3    59 
  4     1 /*  BEGIN INCLUDE FILE: bft.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-11-16,Flegel), approve(87-11-16,MCR7787),
  4     6*     audit(88-01-27,RWaters), install(88-02-24,MR12.2-1028):
  4     7*     Created to provide access to flags structure for programs which call the
  4     8*     bft_$(fetch store) entrypoints.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 dcl BFT_MIN_PRIORITY      fixed bin int static options (constant) init (1);
  4    12 dcl BFT_MAX_PRIORITY      fixed bin int static options (constant) init (4);
  4    13 dcl BFT_PATH_ID	      fixed bin int static options (constant) init (32);
  4    14 dcl BFT_TIME_ID	      fixed bin int static options (constant) init (33);
  4    15 dcl BFT_ENTRY_ID	      fixed bin int static options (constant) init (34);
  4    16 
  4    17 /* BFT queue flags / switches;
  4    18*   NOTE that the pad and mbz are first, this is because a conversion routine
  4    19*   to convert significant bits to a respective character string assumes that
  4    20*   the bit string is RIGHT JUSTIFIED (this is to allow the accepting of
  4    21*   numerical values - eg. fixed bin */
  4    22 
  4    23 dcl 01 bft_queue_flags  based,
  4    24        02 mbz	    bit (4) unal,		    /* System word adjust */
  4    25        02 pad	    bit (28) unal,		    /* Future expansion */
  4    26        02 allocated     bit (1) unal,		    /* Is this an entry? */
  4    27        02 initiated     bit (1) unal,		    /* Transfer in progress */
  4    28        02 binary_sw     bit (1) unal,		    /* Binary file_type */
  4    29        02 notify_sw     bit (1) unal;		    /* If a notify is to be done */
  4    30 
  4    31 /*  END INCLUDE FILE: bft.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  3    60 
  3    61 
  3    62 /*  END INCLUDE FILE: bft_queue.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1150 
     1151 
     1152      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/24/88  0845.0  bft_queue_.pl1                    >special_ldd>install>MR12.2-1028>bft_queue_.pl1
1148         1    02/24/88  0846.4  bft_values.incl.pl1               >special_ldd>install>MR12.2-1028>bft_values.incl.pl1
1149         2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1150         3    02/24/88  0843.7  bft_queue.incl.pl1                >special_ldd>install>MR12.2-1028>bft_queue.incl.pl1
3-60         4    02/24/88  0843.9  bft.incl.pl1                      >special_ldd>install>MR12.2-1028>bft.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BFT_MAX_PRIORITY                       constant        fixed bin(17,0)          initial dcl 4-12 ref 173 281
BFT_MIN_PRIORITY                       constant        fixed bin(17,0)          initial dcl 4-11 ref 173 281
BFT_MULTICS_to_PC                      constant        fixed bin(17,0)          initial dcl 1-52 ref 180 349 453
BFT_PATH_ID                            constant        fixed bin(17,0)          initial dcl 4-13 ref 1047
BFT_PC_to_MULTICS                      constant        fixed bin(17,0)          initial dcl 1-50 ref 180 200 360 360 447 476 657
BFT_QUEUE_WAIT_TIME             000000 constant        fixed bin(17,0)          initial dcl 3-16 set ref 920*
BFT_TIME_ID                            constant        fixed bin(17,0)          initial dcl 4-14 ref 255 1042
RW_ACCESS_BIN                   000001 constant        fixed bin(5,0)           initial dcl 2-36 set ref 605* 613 613
account_id                      000355 automatic       char(32)                 packed unaligned dcl 586 set ref 599*
addr                                                   builtin function         dcl 107 ref 265 265 271 271 552 552 767 767 846 846
                                                                                  1002 1002
allocated               340(32)        based           bit(1)                   array level 4 in structure "queue" packed packed
                                                                                  unaligned dcl 3-22 in procedure "bft_queue_" set
                                                                                  ref 194* 822
allocated                76(32)        based           bit(1)                   level 3 in structure "queue_element" packed packed
                                                                                  unaligned dcl 3-50 in procedure "bft_queue_" set
                                                                                  ref 893*
array                   242            based           structure                array level 2 dcl 3-22 set ref 193* 478 482 552 552
                                                                                  767 767 846 846 1002 1002
bft_error_table_$fetch_in_progress
                                000056 external static fixed bin(35,0)          dcl 93 ref 449
bft_error_table_$invalid_direction
                                000060 external static fixed bin(35,0)          dcl 94 ref 181 460
bft_error_table_$invalid_priority
                                000066 external static fixed bin(35,0)          dcl 97 ref 174
bft_error_table_$invalid_queue  000064 external static fixed bin(35,0)          dcl 96 ref 167 440
bft_error_table_$no_entries     000062 external static fixed bin(35,0)          dcl 95 ref 468 685
bft_error_table_$no_queue       000070 external static fixed bin(35,0)          dcl 98 ref 129
bft_error_table_$store_in_progress
                                000054 external static fixed bin(35,0)          dcl 92 ref 455
bft_queue_flags                        based           structure                level 1 packed packed unaligned dcl 4-23
binary_sw                76(34)        based           bit(1)                   level 3 packed packed unaligned dcl 3-50 set ref
                                                                                  349* 360* 894*
cleanup                         000224 stack reference condition                dcl 112 ref 123 157 248 398 435
code                            000262 automatic       fixed bin(35,0)          dcl 583 set ref 605* 607 613* 615
date_time_                      000010 constant        entry                    external dcl 68 ref 359
error_table_$bad_conversion     000046 external static fixed bin(35,0)          dcl 85 ref 257
error_table_$noalloc            000050 external static fixed bin(35,0)          dcl 86 ref 545
error_table_$noentry            000042 external static fixed bin(35,0)          dcl 83 ref 322
error_table_$request_id_ambiguous
                                000044 external static fixed bin(35,0)          dcl 84 ref 292 307
fetch_file_pos          236            based           fixed bin(21,0)          level 3 dcl 3-22 set ref 477* 963*
fetch_queue              17            based           structure                array level 3 dcl 3-22
fetching                136            based           structure                level 3 dcl 3-22 set ref 271 271 478*
first                    20            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_" set ref 201* 297 318*
                                                                                  658 660 661* 662 958*
first                     4            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_" set ref 208* 282 315*
                                                                                  670 672 673* 674 955*
first_slot                      000212 automatic       fixed bin(35,0)          dcl 55 set ref 282* 283* 289* 297* 298* 304*
flags                   340            based           structure                array level 3 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_"
flags                     5            based           structure                array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_"
flags                   132            based           structure                level 4 in structure "queue" dcl 3-22 in procedure
                                                                                  "bft_queue_"
flags                    76            based           structure                level 2 in structure "queue_element" packed packed
                                                                                  unaligned dcl 3-50 in procedure "bft_queue_"
flags                   234            based           structure                level 4 in structure "queue" dcl 3-22 in procedure
                                                                                  "bft_queue_"
flags                    21            based           structure                array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_"
formatted_time                  000106 automatic       char(250)                packed unaligned dcl 51 set ref 359* 360 360
free_list               237            based           fixed bin(35,0)          level 3 dcl 3-22 set ref 555 556* 720 727 728* 728
                                                                                  769 770* 830 837* 964*
free_slot                       000437 automatic       fixed bin(35,0)          dcl 806 set ref 834* 836 840 846 846
hcs_$make_seg                   000034 constant        entry                    external dcl 78 ref 605
hcs_$reset_ips_mask             000020 constant        entry                    external dcl 72 ref 214 558 664 676 730 771 844
hcs_$set_ips_mask               000022 constant        entry                    external dcl 73 ref 199 554 659 671 726 768 833
hcs_$truncate_seg               000030 constant        entry                    external dcl 76 ref 855
header                                 based           structure                level 2 dcl 3-22
home_path                       000335 automatic       char(64)                 packed unaligned dcl 585 set ref 598* 605* 613*
i                               000217 automatic       fixed bin(17,0)          dcl 60 in procedure "bft_queue_" set ref 281* 282
                                                                                  288 297 303*
i                               000405 automatic       fixed bin(17,0)          dcl 646 in procedure "find_old_slot" set ref 656*
                                                                                  658 660 661 662 662 670 672 673 674 674*
index                                                  builtin function         dcl 104 ref 1137
indx                            000100 automatic       fixed bin(21,0)          dcl 1129 set ref 1137* 1138 1141
initiate_file_                  000032 constant        entry                    external dcl 77 ref 613
initiated               132(33)        based           bit(1)                   level 5 in structure "queue" packed packed unaligned
                                                                                  dcl 3-22 in procedure "bft_queue_" set ref 264
                                                                                  266* 454 960*
initiated               234(33)        based           bit(1)                   level 5 in structure "queue" packed packed unaligned
                                                                                  dcl 3-22 in procedure "bft_queue_" set ref 270
                                                                                  272* 448 962*
initiated               340(33)        based           bit(1)                   array level 4 in structure "queue" packed packed
                                                                                  unaligned dcl 3-22 in procedure "bft_queue_" set
                                                                                  ref 475*
ioa_                            000014 constant        entry                    external dcl 70 ref 347 349 360
last                      3            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_" set ref 208 210 212*
                                                                                  315* 674* 954*
last                     17            based           fixed bin(35,0)          array level 4 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_" set ref 201 203 205*
                                                                                  318* 662* 957*
last_alloc                      000441 automatic       fixed bin(35,0)          dcl 808 set ref 821* 822 822 824* 824 832 853 854
lock_sw                         000210 automatic       bit(1)                   packed unaligned dcl 53 set ref 121* 155* 246* 396*
                                                                                  433* 504 920
lockword                  2            based           bit(36)                  level 3 dcl 3-22 set ref 123* 157* 248* 398* 435*
                                                                                  504* 920* 953*
mask                            000404 automatic       bit(36)                  dcl 645 in procedure "find_old_slot" set ref 659*
                                                                                  664* 664* 671* 676* 676*
mask                            000220 automatic       bit(36)                  dcl 61 in procedure "bft_queue_" set ref 199* 214*
                                                                                  214*
mask                            000414 automatic       bit(36)                  dcl 710 in procedure "find_new_slot" set ref 726*
                                                                                  730* 730*
mask                            000252 automatic       bit(36)                  dcl 534 in procedure "allocate_slot" set ref 554*
                                                                                  558* 558*
mask                            000434 automatic       bit(36)                  dcl 803 in procedure "free_seg" set ref 833* 844*
                                                                                  844*
mask                            000424 automatic       bit(36)                  dcl 756 in procedure "free_old_slot" set ref 768*
                                                                                  771* 771*
match_found                     000215 automatic       bit(1)                   array packed unaligned dcl 58 set ref 279* 284 284
                                                                                  285* 299 299 300* 315 318
match_prev_slot                 000213 automatic       fixed bin(35,0)          dcl 56 set ref 251* 287* 302* 315* 318*
match_q                         000211 automatic       fixed bin(17,0)          dcl 54 set ref 288* 303* 315 315 318 318
match_request_id_               000016 constant        entry                    external dcl 71 ref 1043
match_slot                      000214 automatic       fixed bin(35,0)          dcl 57 set ref 250* 286* 301* 315* 318*
mbz                      76            based           bit(4)                   level 3 packed packed unaligned dcl 3-50 set ref
                                                                                  896*
multics_path              1            based           char(168)                level 2 packed packed unaligned dcl 3-50 set ref
                                                                                  349* 360* 360* 890* 1048 1055 1055
name                            000263 automatic       char(168)                packed unaligned dcl 584 set ref 600* 605* 613*
new_queue                       000222 automatic       bit(1)                   packed unaligned dcl 63 set ref 128* 129 402* 408
new_slot                        000253 automatic       fixed bin(35,0)          dcl 535 set ref 551* 552 552 555 556 557
next                                   based           fixed bin(35,0)          level 2 in structure "queue_element" dcl 3-50
                                                                                  in procedure "bft_queue_" set ref 889*
next                    242            based           fixed bin(35,0)          array level 3 in structure "queue" dcl 3-22
                                                                                  in procedure "bft_queue_" set ref 195* 203* 210*
                                                                                  289 304 555* 661 673 728 729* 769* 836 840* 840
                                                                                  842 850 1006 1096 1099 1101* 1101
notify_sw                76(35)        based           bit(1)                   level 3 packed packed unaligned dcl 3-50 set ref
                                                                                  360*
null                                                   builtin function         dcl 108 ref 120 127 161 166 395 439
p_code                                 parameter       fixed bin(35,0)          dcl 47 in procedure "bft_queue_" set ref 9 128* 129*
                                                                                  143 167* 174* 181* 187* 188 222 244* 257* 292*
                                                                                  307* 322* 382 402* 403 419 440* 449* 455* 460*
                                                                                  466* 467 468 468* 485* 486 915* 920*
p_code                                 parameter       fixed bin(35,0)          dcl 800 in procedure "free_seg" set ref 787 814*
                                                                                  855* 856
p_code                                 parameter       fixed bin(35,0)          dcl 707 in procedure "find_new_slot" set ref 693
                                                                                  715* 721* 722
p_code                                 parameter       fixed bin(35,0)          dcl 531 in procedure "allocate_slot" set ref 518
                                                                                  540* 545*
p_code                                 parameter       fixed bin(35,0)          dcl 753 in procedure "free_old_slot" set ref 738
                                                                                  761* 776* 777
p_code                                 parameter       fixed bin(35,0)          dcl 642 in procedure "find_old_slot" set ref 624
                                                                                  651* 685*
p_code                                 parameter       fixed bin(35,0)          dcl 580 in procedure "find_bft_queue" set ref 566
                                                                                  594*
p_create_sw                            parameter       bit(1)                   packed unaligned dcl 579 ref 566 604
p_direction                            parameter       fixed bin(17,0)          dcl 43 in procedure "bft_queue_" set ref 143 180 180
                                                                                  200 332 349 360 360 419 447 453 466* 476
p_direction                            parameter       fixed bin(17,0)          dcl 640 in procedure "find_old_slot" ref 624 657
p_e_ptr                                parameter       pointer                  dcl 1030 in procedure "match_request_type" ref 1017
                                                                                  1043 1048 1048 1055 1055 1058 1058
p_e_ptr                                parameter       pointer                  dcl 45 in procedure "bft_queue_" ref 143 161 193 332
                                                                                  344 349 349 349 360 360 360 360 360 360
p_e_ptr                                parameter       pointer                  dcl 879 in procedure "initialize_element" ref 866
                                                                                  889 890 891 892 893 894 895 896
p_header                               parameter       bit(1)                   packed unaligned dcl 38 ref 332 347
p_id                                   parameter       char                     packed unaligned dcl 42 in procedure "bft_queue_"
                                                                                  set ref 222 256 265* 271* 283 283 298 298
p_id                                   parameter       char                     packed unaligned dcl 987 in procedure "match_entry"
                                                                                  set ref 973 1002*
p_id                                   parameter       char                     packed unaligned dcl 1031 in procedure
                                                                                  "match_request_type" set ref 1017 1043* 1048 1048
                                                                                  1055 1058
p_id_sw                                parameter       fixed bin(17,0)          dcl 41 in procedure "bft_queue_" set ref 222 255
                                                                                  265* 271* 283* 298*
p_id_sw                                parameter       fixed bin(17,0)          dcl 1032 in procedure "match_request_type" ref 1017
                                                                                  1042 1047
p_id_sw                                parameter       fixed bin(17,0)          dcl 986 in procedure "match_entry" set ref 973 1002*
p_last_slot                            parameter       fixed bin(35,0)          dcl 1083 set ref 1070 1096*
p_long_sw                              parameter       bit(1)                   packed unaligned dcl 39 ref 332 346
p_path                                 parameter       char                     packed unaligned dcl 1125 ref 1112 1137 1138 1141
p_prev_slot                            parameter       fixed bin(35,0)          dcl 989 in procedure "match_entry" set ref 973 999*
                                                                                  1005* 1006
p_prev_slot                            parameter       fixed bin(35,0)          dcl 1085 in procedure "remove_entry" ref 1070 1096
                                                                                  1099 1101
p_priority                             parameter       fixed bin(17,0)          dcl 44 ref 143 173 173 201 201 203 205 208 208 210
                                                                                  212
p_q_ptr                                parameter       pointer                  dcl 46 set ref 9 120* 127* 132* 143 222 382 395*
                                                                                  411* 419 916
p_separator                            parameter       char(1)                  packed unaligned dcl 1126 ref 1112 1137
p_slot                                 parameter       fixed bin(35,0)          dcl 752 in procedure "free_old_slot" ref 738 767 767
                                                                                  769 770 775
p_slot                                 parameter       fixed bin(35,0)          dcl 706 in procedure "find_new_slot" set ref 693
                                                                                  716* 727* 729
p_slot                                 parameter       fixed bin(35,0)          dcl 1086 in procedure "remove_entry" set ref 1070
                                                                                  1096 1099 1101 1104*
p_slot                                 parameter       fixed bin(35,0)          dcl 641 in procedure "find_old_slot" set ref 624
                                                                                  652* 660* 661 672* 673
p_slot                                 parameter       fixed bin(35,0)          dcl 990 in procedure "match_entry" set ref 973 1000*
                                                                                  1001 1002 1002 1005 1006*
p_start_slot                           parameter       fixed bin(35,0)          dcl 1084 in procedure "remove_entry" set ref 1070
                                                                                  1099*
p_start_slot                           parameter       fixed bin(35,0)          dcl 988 in procedure "match_entry" ref 973 1000
p_state                                parameter       bit(1)                   packed unaligned dcl 40 set ref 332 349* 360*
pad                      76(04)        based           bit(28)                  level 3 in structure "queue_element" packed packed
                                                                                  unaligned dcl 3-50 in procedure "bft_queue_" set
                                                                                  ref 895*
pad                       5            based           bit(36)                  array level 5 in structure "queue" packed packed
                                                                                  unaligned dcl 3-22 in procedure "bft_queue_" set
                                                                                  ref 956*
pad                      21            based           bit(36)                  array level 5 in structure "queue" packed packed
                                                                                  unaligned dcl 3-22 in procedure "bft_queue_" set
                                                                                  ref 959*
pc_path                  53            based           char(66)                 level 2 packed packed unaligned dcl 3-50 set ref
                                                                                  349* 360* 360* 891* 1048 1058 1058
person_id                       000370 automatic       char(22)                 packed unaligned dcl 588 set ref 599* 600
prev_slot                       000216 automatic       fixed bin(35,0)          dcl 59 set ref 283* 287 298* 302
previous_slot                   000436 automatic       fixed bin(35,0)          dcl 805 set ref 829* 835 840 841* 849*
project_id                      000365 automatic       char(9)                  packed unaligned dcl 587 set ref 599*
queue                                  based           structure                level 1 dcl 3-22 set ref 544
queue_element                          based           structure                level 1 unaligned dcl 3-50 set ref 193 544 854
queue_header                           based           structure                level 1 unaligned dcl 3-28 ref 854
queue_ptr                       000232 automatic       pointer                  dcl 3-21 set ref 123 132 157 166 193 194 195 201 201
                                                                                  203 203 205 208 208 210 210 212 248 264 265 265
                                                                                  266 270 271 271 272 282 289 297 304 315 315 318
                                                                                  318 398 411 435 439 448 454 475 477 478 478 481
                                                                                  482 482 504 544 544 551 552 552 555 555 556 557
                                                                                  605* 613* 658 660 661 661 662 662 670 672 673 673
                                                                                  674 674 720 727 728 728 728 729 767 767 769 769
                                                                                  770 775 821 822 830 836 837 840 840 842 846 846
                                                                                  850 853 855* 916* 920 952 953 954 955 956 957 958
                                                                                  959 960 961 962 963 964 965 1002 1002 1006 1096
                                                                                  1099 1101 1101
request_id_                     000012 constant        entry                    external dcl 69 ref 349 349 358
reverse                                                builtin function         dcl 101 ref 1137 1141 1141
rtrim                                                  builtin function         dcl 109 ref 256 283 283 298 298 360 360 600 1048
                                                                                  1048 1048 1048 1055 1055 1055 1058 1058 1058 1137
                                                                                  1141
segment_size            240            based           fixed bin(35,0)          level 3 dcl 3-22 set ref 544 551 557* 775 821 853*
                                                                                  965*
set_lock_$lock                  000026 constant        entry                    external dcl 75 ref 920
set_lock_$unlock                000024 constant        entry                    external dcl 74 ref 123 157 248 398 435 504
size                                                   builtin function         dcl 106 ref 544 544 854 854
slot                            000221 automatic       fixed bin(35,0)          dcl 62 in procedure "bft_queue_" set ref 187* 193
                                                                                  193 193 193 193 193 193 193 193 193 193 193 194
                                                                                  195 201 203 205 208 210 212 283* 286 289 298* 301
                                                                                  304 466* 467 475 478 482 485*
slot                            000440 automatic       fixed bin(35,0)          dcl 807 in procedure "free_seg" set ref 830* 831 832
                                                                                  834 836* 837 841 842* 842 849 850* 850
store_file_pos          134            based           fixed bin(21,0)          level 3 dcl 3-22 set ref 481* 961*
store_queue               3            based           structure                array level 3 dcl 3-22
storing                  34            based           structure                level 3 dcl 3-22 set ref 265 265 482*
substr                                                 builtin function         dcl 102 ref 349 349 1141
sys_info$max_seg_size           000052 external static fixed bin(35,0)          dcl 87 ref 544
time_id                  74            based           fixed bin(71,0)          level 2 dcl 3-50 set ref 344 892* 1043*
time_stamp                      000206 automatic       fixed bin(71,0)          dcl 52 set ref 344* 349* 349* 358* 359*
time_string                     000100 automatic       varying char(20)         dcl 50 set ref 358* 360*
total_free                      000442 automatic       fixed bin(35,0)          dcl 809 set ref 820* 823* 823
unspec                                                 builtin function         dcl 105 ref 613 613
user_info_                      000036 constant        entry                    external dcl 79 ref 599
user_info_$homedir              000040 constant        entry                    external dcl 80 ref 598
verify                                                 builtin function         dcl 103 ref 256
version                                based           char(8)                  level 3 dcl 3-22 set ref 952*
word_count                      000435 automatic       fixed bin(19,0)          dcl 804 set ref 854* 855*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
BFT_BLOCK_SIZE                         internal static fixed bin(21,0)          initial dcl 1-37
BFT_DATA_BLOCK_VERSION_1               internal static char(8)                  initial packed unaligned dcl 1-54
BFT_ENTRY_ID                           internal static fixed bin(17,0)          initial dcl 4-15
BFT_FIRST                              internal static char(1)                  initial packed unaligned dcl 1-38
BFT_INBUFFER_SIZE                      internal static fixed bin(17,0)          initial dcl 1-35
BFT_INBUFF_LENGTH                      internal static fixed bin(17,0)          initial dcl 1-56
BFT_MINOR_CAPS                         internal static fixed bin(17,0)          initial dcl 1-34
BFT_NEXT                               internal static char(1)                  initial packed unaligned dcl 1-39
BFT_OUTBUFFER_SIZE                     internal static fixed bin(17,0)          initial dcl 1-36
BFT_OUTBUFF_LENGTH                     internal static fixed bin(17,0)          initial dcl 1-58
BFT_QUEUE_PRIORITIES                   internal static fixed bin(17,0)          initial dcl 3-14
BFT_QUEUE_VERSION_1                    internal static char(8)                  initial packed unaligned dcl 3-12
DEL                                    internal static bit(9)                   initial packed unaligned dcl 1-41
DELIM_CHAR                             based           char(1)                  packed unaligned dcl 1-40
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
bft_minor_$add_to_fetch_queue          internal static fixed bin(17,0)          initial dcl 1-15
bft_minor_$add_to_store_queue          internal static fixed bin(17,0)          initial dcl 1-16
bft_minor_$bft_shut_down               internal static fixed bin(17,0)          initial dcl 1-19
bft_minor_$cancel_request              internal static fixed bin(17,0)          initial dcl 1-29
bft_minor_$check_file_length           internal static fixed bin(17,0)          initial dcl 1-17
bft_minor_$expand_pc_path              internal static fixed bin(17,0)          initial dcl 1-30
bft_minor_$full_pc_path                internal static fixed bin(17,0)          initial dcl 1-31
bft_minor_$initiate_fetch              internal static fixed bin(17,0)          initial dcl 1-18
bft_minor_$initiate_store              internal static fixed bin(17,0)          initial dcl 1-26
bft_minor_$position_file_pointer       internal static fixed bin(17,0)          initial dcl 1-20
bft_minor_$read_error                  internal static fixed bin(17,0)          initial dcl 1-25
bft_minor_$receive_data                internal static fixed bin(17,0)          initial dcl 1-21
bft_minor_$receive_eof                 internal static fixed bin(17,0)          initial dcl 1-22
bft_minor_$recover_fetch               internal static fixed bin(17,0)          initial dcl 1-23
bft_minor_$recover_store               internal static fixed bin(17,0)          initial dcl 1-24
bft_minor_$send_data                   internal static fixed bin(17,0)          initial dcl 1-28
bft_minor_$write_error                 internal static fixed bin(17,0)          initial dcl 1-27
bft_values_struct                      automatic       structure                level 1 packed packed unaligned dcl 1-44
data_block                             based           structure                level 1 unaligned dcl 1-62
data_block_ptr                         automatic       pointer                  dcl 1-61
pending                                based           structure                level 1 unaligned dcl 1-79

NAMES DECLARED BY EXPLICIT CONTEXT.
BFT_QUEUE_RETURN                002231 constant        label                    dcl 504 ref 134 161 168 175 182 188 216 258 293 308
                                                                                  323 326 403 413 441 450 456 461 470 486 489
add                             000275 constant        entry                    external dcl 143
allocate_slot                   002247 constant        entry                    internal dcl 518 ref 721
bft_queue_                      000173 constant        entry                    external dcl 9
cancel                          000575 constant        entry                    external dcl 222
display_element                 001347 constant        entry                    external dcl 332
find_bft_queue                  002333 constant        entry                    internal dcl 566 ref 128 402
find_new_slot                   002701 constant        entry                    internal dcl 693 ref 187
find_old_slot                   002544 constant        entry                    internal dcl 624 ref 466
free_old_slot                   002761 constant        entry                    internal dcl 738 ref 485 1104
free_seg                        003047 constant        entry                    internal dcl 787 ref 776
initialize_element              003227 constant        entry                    internal dcl 866 ref 552 767 846
initialize_entry                003255 constant        entry                    internal dcl 904 ref 122 156 247 397 434
initialize_queue_header         003301 constant        entry                    internal dcl 929 ref 408
initiate                        001736 constant        entry                    external dcl 382
match_entry                     003415 constant        entry                    internal dcl 973 ref 283 298
match_request_type              003522 constant        entry                    internal dcl 1017 ref 265 271 1002
remove                          002035 constant        entry                    external dcl 419
remove_entry                    004066 constant        entry                    internal dcl 1070 ref 315 318
strip_path                      004127 constant        entry                    internal dcl 1112 ref 349 349 1055 1058

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5066        5160    4440        5076
Length      5534    4440        72         340     426           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bft_queue_                          634 external procedure  is an external procedure.  
on unit on line 123                  72 on unit               
on unit on line 157                  72 on unit               
on unit on line 248                  72 on unit               
on unit on line 398                  72 on unit               
on unit on line 435                  72 on unit               
allocate_slot                           internal procedure  shares stack frame of external procedure bft_queue_.  
find_bft_queue                          internal procedure  shares stack frame of external procedure bft_queue_.  
find_old_slot                           internal procedure  shares stack frame of external procedure bft_queue_.  
find_new_slot                           internal procedure  shares stack frame of external procedure bft_queue_.  
free_old_slot                           internal procedure  shares stack frame of external procedure bft_queue_.  
free_seg                                internal procedure  shares stack frame of external procedure bft_queue_.  
initialize_element                      internal procedure  shares stack frame of external procedure bft_queue_.  
initialize_entry                        internal procedure  shares stack frame of external procedure bft_queue_.  
initialize_queue_header                 internal procedure  shares stack frame of external procedure bft_queue_.  
match_entry                          88 internal procedure  is called during a stack extension.  
match_request_type                  103 internal procedure  is called by several nonquick procedures.  
remove_entry                            internal procedure  shares stack frame of external procedure bft_queue_.  
strip_path                           70 internal procedure  uses returns(char(*)) or returns(bit(*)), and   
                                                            is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bft_queue_               000100 time_string                 bft_queue_
                         000106 formatted_time              bft_queue_
                         000206 time_stamp                  bft_queue_
                         000210 lock_sw                     bft_queue_
                         000211 match_q                     bft_queue_
                         000212 first_slot                  bft_queue_
                         000213 match_prev_slot             bft_queue_
                         000214 match_slot                  bft_queue_
                         000215 match_found                 bft_queue_
                         000216 prev_slot                   bft_queue_
                         000217 i                           bft_queue_
                         000220 mask                        bft_queue_
                         000221 slot                        bft_queue_
                         000222 new_queue                   bft_queue_
                         000232 queue_ptr                   bft_queue_
                         000252 mask                        allocate_slot
                         000253 new_slot                    allocate_slot
                         000262 code                        find_bft_queue
                         000263 name                        find_bft_queue
                         000335 home_path                   find_bft_queue
                         000355 account_id                  find_bft_queue
                         000365 project_id                  find_bft_queue
                         000370 person_id                   find_bft_queue
                         000404 mask                        find_old_slot
                         000405 i                           find_old_slot
                         000414 mask                        find_new_slot
                         000424 mask                        free_old_slot
                         000434 mask                        free_seg
                         000435 word_count                  free_seg
                         000436 previous_slot               free_seg
                         000437 free_slot                   free_seg
                         000440 slot                        free_seg
                         000441 last_alloc                  free_seg
                         000442 total_free                  free_seg
strip_path               000100 indx                        strip_path

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_other_desc return_mac          enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           int_entry_desc      reverse_cs          set_chars_eis       return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
date_time_                    hcs_$make_seg                 hcs_$reset_ips_mask           hcs_$set_ips_mask
hcs_$truncate_seg             initiate_file_                ioa_                          match_request_id_
request_id_                   set_lock_$lock                set_lock_$unlock              user_info_
user_info_$homedir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bft_error_table_$fetch_in_progress                          bft_error_table_$invalid_direction
bft_error_table_$invalid_priority                           bft_error_table_$invalid_queue
bft_error_table_$no_entries   bft_error_table_$no_queue     bft_error_table_$store_in_progress
error_table_$bad_conversion   error_table_$noalloc          error_table_$noentry
error_table_$request_id_ambiguous                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000167       120 000203       121 000205       122 000206       123 000207       127 000237       128 000242
    129 000256       132 000264       134 000267       143 000270       155 000311       156 000313       157 000314
    161 000344       166 000350       167 000354       168 000357       173 000360       174 000366       175 000371
    180 000372       181 000377       182 000402       187 000403       188 000413       193 000415       194 000472
    195 000474       199 000475       200 000510       201 000513       203 000526       205 000532       206 000534
    208 000535       210 000550       212 000555       214 000557       216 000567       222 000570       244 000613
    246 000614       247 000616       248 000617       250 000647       251 000650       255 000651       256 000655
    257 000702       258 000705       264 000706       265 000712       266 000744       267 000747       270 000750
    271 000754       272 001007       273 001012       279 001013       281 001026       282 001035       283 001041
    284 001122       285 001126       286 001130       287 001132       288 001134       289 001136       290 001143
    292 001144       293 001147       295 001150       297 001151       298 001156       299 001236       300 001242
    301 001244       302 001246       303 001250       304 001252       305 001257       307 001260       308 001263
    310 001264       311 001265       315 001267       318 001312       322 001335       323 001340       326 001341
    332 001342       344 001361       346 001365       347 001373       349 001414       356 001554       358 001556
    359 001574       360 001611       374 001732       376 001733       382 001734       395 001746       396 001751
    397 001752       398 001753       402 002003       403 002017       408 002021       411 002025       413 002030
    419 002031       433 002047       434 002051       435 002052       439 002102       440 002106       441 002111
    447 002112       448 002115       449 002121       450 002124       452 002125       453 002126       454 002130
    455 002134       456 002137       458 002140       460 002141       461 002144       466 002145       467 002157
    468 002163       470 002170       475 002171       476 002175       477 002201       478 002202       479 002207
    481 002210       482 002211       485 002216       486 002226       489 002230       504 002231       509 002246
    518 002247       540 002251       544 002252       545 002262       546 002264       551 002265       552 002271
    554 002276       555 002311       556 002317       557 002321       558 002322       560 002332       566 002333
    594 002335       598 002336       599 002347       600 002370       604 002416       605 002425       607 002462
    613 002473       615 002533       624 002544       651 002546       652 002547       656 002550       657 002555
    658 002561       659 002567       660 002602       661 002607       662 002612       664 002614       666 002624
    668 002625       670 002626       671 002634       672 002647       673 002654       674 002657       676 002661
    678 002671       681 002672       685 002674       687 002700       693 002701       715 002703       716 002704
    720 002705       721 002710       722 002716       726 002722       727 002735       728 002741       729 002745
    730 002750       732 002760       738 002761       761 002763       767 002764       768 002773       769 003006
    770 003015       771 003017       775 003027       776 003034       777 003042       781 003046       787 003047
    814 003051       820 003052       821 003053       822 003056       823 003066       824 003072       825 003100
    829 003101       830 003102       831 003104       832 003106       833 003110       834 003123       835 003125
    836 003127       837 003134       838 003135       840 003136       841 003145       842 003147       844 003152
    846 003162       847 003171       849 003172       850 003173       853 003177       854 003202       855 003205
    856 003221       858 003225       860 003226       866 003227       889 003231       890 003233       891 003237
    892 003242       893 003244       894 003246       895 003250       896 003252       898 003254       904 003255
    915 003256       916 003257       920 003263       923 003300       929 003301       952 003302       953 003306
    954 003307       955 003321       956 003334       957 003346       958 003360       959 003372       960 003404
    961 003406       962 003407       963 003410       964 003411       965 003412       967 003413       973 003414
    999 003430      1000 003432      1001 003434      1002 003437      1005 003503      1006 003506      1007 003513
   1009 003514      1017 003521      1042 003535      1043 003541      1045 003574      1047 003575      1048 003577
   1052 003655      1055 003656      1058 003757      1062 004060      1070 004066      1096 004070      1099 004077
   1101 004106      1104 004114      1106 004125      1112 004126      1137 004142      1138 004167      1141 004177


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
