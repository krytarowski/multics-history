	COMPILATION LISTING OF SEGMENT gcos_gein_pass1_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1946.25_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 gcos_gein_pass1_: proc;
        7 
        8 /*
        9*   This procedure reads thru the input segment, and any $ SELECTed files,
       10*   performing the following functions:
       11*
       12*   1) optional canonicalization of ascii segments (conversion of tabs and
       13*   backspaces to the right number of blanks);
       14*
       15*   2) copying of $ SELECTed files into the job stream;
       16*
       17*   3) scanning for $ EXECUTE and $ 355SIM cards, for later PSW bit 5 setting.
       18*
       19*   It writes the job stream file in standard gcos format. This file contains
       20*   no $ SELECT cards; they are discarded when the $ SELECTed files are
       21*   copied into the job stream.
       22*
       23*   For each $ control card, the ascii image, as well as the bcd image, is
       24*   written on the job stream file (with a media code of "0110"b), the
       25*   ascii image preceeding the bcd image.
       26*
       27*   The $ control cards are written on the execution report at this time.
       28*
       29*   Author: T. CASEY APRIL 1973
       30*   Change: T. CASEY NOVEMBER 1973, FEBRUARY 1974, APRIL 1974, JUNE 1974, AUGUST 1974
       31*   Change: R.H. MORRISON OCTOBER 1974
       32*   Change: D. KAYDEN DECEMBER 1974, MARCH 1975
       33*   Change: R.H. MORRISON SEPTEMBER 19, 1975
       34*   Change: M. R. Jordan, August 1977
       35*   Change: Mel Wilson  March 1979 for gtss media codes.
       36*   Change: Dave Ward	06/21/81 Reorganized. Corrected bug tabulation & alter files.
       37*   Change: Ron Barstad  83-08-02  Start numbering jcl with 1 instead of 2!
       38*                                  Fix card count message to look like GCOS
       39**/
       40 	write_buffer_ptr = addr (write_buffer);
       41 /*	status_ptr = addr (status); */
       42 
       43 
       44 	ascii_work_area (*) = (4)"040"b3;
       45 	ascii_ptr = addr (ascii_work_area);
       46 	ascii_card_ptr = addrel (ascii_ptr, 1);
       47 	ascii_len = 20;
       48 	ascii_record.rcw = ascii_rcw;
       49 	substr (ascii_report_card, 85, 1) = ascii_newline;
       50 
       51 	write_buffer_ptr = addr (write_buffer);
       52 	output_word_ptr = addrel (write_buffer_ptr, 1);
       53 	remaining_output_words = 319;
       54 	write_buffer_ptr -> bcw.bsn = "000001"b3 ;
       55 	write_buffer_ptr -> bcw.length = (18)"0"b;
       56 
       57 	save_data.last_execute_act_no,		/* initialize activity numbers */
       58 	     act_no = 0;
       59 	gcos_ext_stat_$userid = "";
       60 
       61 /* stack the main input segment for reading */
       62 	stack_level = 0;
       63 	select_path = gcos_ext_stat_$input_segment_path;
       64 	select_path_len = length (gcos_ext_stat_$input_segment_path);
       65 
       66 	if gcos_ext_stat_$save_data.gcos then		/* input is gcos file */
       67 	     ascii_sw, canon_sw = "0"b;
       68 	else do;					/* input is ascii segment */
       69 	     if gcos_ext_stat_$save_data.no_canonicalize
       70 	     then canon_sw = "0"b;
       71 	     else canon_sw = "1"b;
       72 	     ascii_sw = "1"b;
       73 	end;
       74 
       75 	on condition (cleanup) call pass1_cleanup;	/* before we start allocating things */
       76 
       77 	call stack_selected_file;
       78 						/* inputs to stack_selected_file include: select_path,
       79*						   select_path_len, ascii_sw, canon_sw */
       80 
       81 /* attach gcos_job_stream_file for writing */
       82 	js_io_sw = "1"b;				/* in case of io error, print path of job stream file */
       83 
       84 	js_path = gcos_ext_stat_$save_dir || ">" || gcos_ext_stat_$job_id || ".job_deck";
       85 	call ios_$attach ("gcos_job_stream_", "file_", js_path, "w", status);
       86 	if code ^= 0 then do;
       87 	     err_msg = "from ios_$attach ^a w";
       88 	     goto file_error;
       89 	end;
       90 
       91 	call ios_$setsize ("gcos_job_stream_", 36, status);
       92 	if code ^= 0 then do;
       93 setsize_err:   err_msg = "from ios_$setsize ^a";
       94 	     goto file_error;
       95 	end;
       96 
       97 	call ios_$seek ("gcos_job_stream_", "last", "first", 0, status); /* truncate, in case it exists */
       98 	if code ^= 0 then do;
       99 	     err_msg = "from ios_$seek ^a";
      100 	     goto file_error;
      101 	end;
      102 
      103 	js_io_sw = "0"b;				/* in case of io error, print pathname of current input file */
      104 
      105 /*     Main loop. Read input as long as any remains. */
      106 	do while (stack_level > 0);			/* (stack level becomes zero at eof on main input seg) */
      107 
      108 	     dollar_sw, eof_sw, select_card = "0"b;
      109 
      110 	     call read_current_file;
      111 						/* outputs of read_current_file include:
      112*						   gcos_ptr,gcos_len,bcd_card_ptr,
      113*						   ascii_ptr,ascii_len,ascii_card_ptr,
      114*						   dollar_sw,eof_sw, card_type */
      115 
      116 	     if eof_sw then				/* if end of file, go back to reading the previous file,
      117*						   if there is one */
      118 
      119 		call unstack_current_file;
      120 
      121 /*   if eof occurred, fall thru to end of read_loop   */
      122 	     else					/* not eof */
      123 process_card:  do;
      124 
      125 		card_count = card_count + 1;		/* count cards */
      126 		if stack_level > 1 then selected_card_count = selected_card_count + 1;
      127 
      128 		if dollar_sw then do;		/* if this is a dollar card */
      129 
      130 		     if card_type = "endcop" then
      131 			if endfc = "" | substr (ascii_card, 16, 2) = endfc then copy_sw = "0"b;
      132 
      133 
      134 		     if substr (ascii_card, 8, 8) = "selectd" then goto process_select_card; /* even if copy_sw is on */
      135 		     if copy_sw | card_type = "alter" then do;
      136 			dollar_sw = "0"b;		/* pretend its not a dollar card */
      137 			goto end_process_dollar_card;
      138 		     end;
      139 
      140 		     if card_type = "data" then do;	/* check for copy option */
      141 			i = index (substr (ascii_card, 18), ",copy");
      142 
      143 /* NOTE: Above code does not provide for ",copy"
      144*   as comment on a data card.
      145**/
      146 			if i ^= 0 then do;
      147 			     copy_sw = "1"b;
      148 			     i = index (substr (ascii_card, 18), ",endfc");
      149 			     if i ^= 0 then endfc = substr (ascii_card, 16, 2);
      150 			     else endfc = "";
      151 			end;
      152 		     end;
      153 
      154 		     if card_type = "select" then do;	/* special handling of select cards */
      155 process_select_card:
      156 			select_card = "1"b;
      157 			call interpret_select_card;
      158 						/* outputs from interpret_select_card include:
      159*						   select_path,select_path_len,ascii_sw,canon_sw */
      160 
      161 /* stack the selected file for reading */
      162 			call stack_selected_file;
      163 		     end;
      164 		     else do;			/* Process non-select card. */
      165 			if card_type = "userid" then do; /* special handling of  $ USERID cards */
      166 			     gcos_ext_stat_$save_data.userid = "1"b; /* remember it, so prmfiles will be allowed */
      167 			     in_password = "0"b;
      168 
      169 			     if gcos_ptr ^= addr (bcd_work_area) then do; /* can't modify the input file */
      170 				overlay_ptr = addr (bcd_work_area); /* get ptr to our work area */
      171 				overlay_ptr -> bcd_card_overlay = gcos_ptr -> bcd_card_overlay;
      172 						/* copy card into it */
      173 				gcos_ptr = overlay_ptr; /* make it our working copy */
      174 				bcd_card_ptr = addrel (gcos_ptr, 1);
      175 			     end;
      176 
      177 			     do i = 16 to 72	/* scan card */
      178 				     while (substr (ascii_card, i, 1) ^= " "); /* to end of operand field */
      179 				if in_password then /* wiping out password */
      180 				     substr (ascii_card, i, 1) = "#";
      181 				else
      182 				if substr (ascii_card, i, 1) = "$" then /* or looking for start of password */
      183 				     in_password = "1"b;
      184 			     end;
      185 
      186 			     goto job_stream_write;	/* go write it on job stream and execution report */
      187 			end;
      188 
      189 			do i = 1 to gcos_control_tables_$totallen /* look up card in table */
      190 				while (card_type ^= substr (gcos_control_tables_$cardtable (i), 1, 6));
      191 			end;
      192 			if i <= gcos_control_tables_$totallen then /* if not implemented, complain */
      193 			     if i > gcos_control_tables_$tablelen then do;
      194 				unimp_sw = "1"b;	/* remember it */
      195 				if ^gcos_ext_stat_$save_data.brief then do; /* print warning unless told to be quiet */
      196 				     err_msg = "unimplemented control card read from ^a:^/" || ascii_card;
      197 				     call com_err_ (0, "gcos", err_msg, current_file.pathname);
      198 				end;
      199 			     end;
      200 
      201 /* see if it is an activity card */
      202 			if i >= gcos_control_tables_$exc_offset then
      203 						/* if it's not before the first activity card in the table */
      204 			     if i < gcos_control_tables_$nonact then do; /* and it's not after the last one */
      205 						/* then it must be an activity card */
      206 
      207 				act_no = act_no + 1; /* count activity cards */
      208 						/* and complain if too many   */
      209 				if act_no > gcos_ext_stat_$max_activities then
      210 				     call gcos_error_ (
      211 				     gcos_et_$too_many_activs
      212 				     , "Maximum number of activities allowed is ^d."
      213 				     , gcos_ext_stat_$max_activities
      214 				     );
      215 
      216 /* locate info table entry for this activity */
      217 				act_ptr = addr (gcos_control_tables_$activity_table); /* start of table */
      218 				act_ptr = addrel (act_ptr, (i-gcos_control_tables_$exc_offset)*3);
      219 
      220 /* pick up nondollar canonicalization index for this activity */
      221 				nondollar_canon_index = act_table_entry.canon_index;
      222 
      223 /* if execute card, remember to turn on PSW bit 5 for all preceeding activities */
      224 
      225 				if card_type = "execut" | card_type = "355sim" then
      226 				     save_data.last_execute_act_no = act_no;
      227 
      228 			     end;
      229 
      230 			if card_type = "msg1" then	/* print msg1 card in pass1 */
      231 			     call ioa_ ("^a", substr (ascii_card, 8, 73));
      232 
      233 job_stream_write:		call write_job_stream (ascii_ptr, ascii_len+1);
      234 		     end;
      235 
      236 print_before_etc:					/* come here to print card before reading $ ETC following */
      237 
      238 
      239 /* TO KEEP $ SELECT CARDS OFF THE EXECUTION REPORT, MOVE THE ABOVE END STATEMEMNT
      240*   DOWN PAST THE CODE THAT WRITES ON THE EXECUTION REPORT */
      241 
      242 /* The following logic puts a $ in column 2 of any dollar cards that were
      243*   in $ SELECTed files. For the case of selected bcd files, we must make a
      244*   copy of the bcd image before inserting the $, since otherwise we would
      245*   be attempting to write into the input file itself, and we probably do
      246*   not have write permission on it. */
      247 
      248 		     overlay_ptr = gcos_ptr;		/* point to image to be written on execution report */
      249 		     if stack_level > 1 then do;	/* if card is from a select file */
      250 						/* it needs a double dollar sign */
      251 			if gcos_ptr ^= addr (bcd_work_area) then do; /* bcd file. can't write into it */
      252 			     overlay_ptr = addr (bcd_work_area); /* get pointer to our work area */
      253 			     overlay_ptr -> bcd_card_overlay = gcos_ptr -> bcd_card_overlay; /* move card into it */
      254 			     gcos_ptr = overlay_ptr;	/* make it the working copy */
      255 			     bcd_card_ptr = addrel (gcos_ptr, 1);
      256 			end;
      257 
      258 			bcd_card.column (2) = bcd_dollar; /* put $ in column 2 */
      259 			substr (ascii_card, 2, 1) = "$"; /* put it in ASCII copy, also */
      260 		     end;
      261 
      262 		     if i >= gcos_control_tables_$exc_offset & i < gcos_control_tables_$nonact then act_flag = "a";
      263 		     else act_flag = " ";
      264 		     gcos_ext_stat_$card_num = mod (card_count, 10000);
      265 		     call ioa_$rs ("^a ^1a^a", rtn_string, rtn_string_len, gcos_ext_stat_$card_num, act_flag, substr (ascii_card_record_overlay, 5));
      266 		     if ^gcos_ext_stat_$save_data.debug then ioa_string = translate (ioa_string, UPPER_CASE, LOWER_CASE);
      267 		     call gcos_write_$ascii_ptr (gcos_ext_stat_$er, ioa_string, "11111100"b);
      268 
      269 		     if stack_level > 1 then do;	/* if from a select file */
      270 			bcd_card.column (2) = bcd_blank; /* wipe out the extra dollar sign */
      271 			substr (ascii_card, 2, 1) = " "; /* in both copies */
      272 		     end;
      273 
      274 
      275 /*	END OF WRITE EXECUTION REPORT CODING. MOVE THAT END STATEMENT HERE */
      276 
      277 		     if dbs_dollar then		/* FOR DEBUGGING */
      278 			call ioa_ (ascii_card);
      279 
      280 end_process_dollar_card: ;
      281 		end;
      282 
      283 
      284 /*   for all cards (dollar or not) except $ SELECT cards, write the bcd (or binary) image on the job stream file */
      285 
      286 		if ^select_card then
      287 		     call write_job_stream (gcos_ptr, gcos_len + 1);
      288 
      289 		if dbs_nondollar then		/*      FOR DEBUGGING     */
      290 		     if ^dollar_sw			/* if this was a nondollar card */
      291 		     then call ioa_ (ascii_card);	/* print it */
      292 						/* NOTE that read_current_file checks the dbs_nondollar, and
      293*						   gives us the ascii image of nondollar cards, if we need them */
      294 
      295 		if etc_next_sw then goto etc_label;	/* return to read $ ETC card, if one is expected */
      296 						/* NOTE: for etc after select cards, the select_card
      297*						   switch stays on, and the etc card does not get
      298*						   written on the job stream file */
      299 
      300 
      301 	     end;
      302 	end;
      303 
      304 /*  fall thru when we hit eof on main input segment */
      305 /* see if job ended in $ ENDJOB card */
      306 
      307 	if card_type ^= "endjob" then
      308 	     do;					/* generate endjob card if needed */
      309 
      310 	     ascii_card = "$      endjob                *** GENERATED BY GCOS ***";
      311 
      312 	     gcos_ptr = addr (bcd_work_area);		/* set up to get bcd image of it */
      313 	     bcd_card_ptr = addrel (gcos_ptr, 1);
      314 	     gcos_len = 14;
      315 
      316 
      317 	     call get_bcd;				/* entry point in read_current_file,
      318*						   just after reading ascii line */
      319 
      320 	     goto process_card;			/* in main loop, just after call to read_current_file */
      321 
      322 	end;
      323 
      324 /* print card count on execution report */
      325 
      326 
      327 	call ioa_$rsnnl ("^2xTotal card count this job = ^6d", err_path, i, card_count);
      328 						/* length of returned string must be multiple of 4 */
      329 	err_num = i + 1;				/* err_num = index of first vacant char in string */
      330 						/* it must be the first character in a word */
      331 
      332 	if selected_card_count > 0 then do;
      333 	     overlay_ptr = addr (addr (err_path) -> char_addrel (i)); /* get ptr to first vacant character */
      334 						/* ptr may not have a char offset -
      335*						   ioa_$rsnnl wants an aligned string */
      336 	     call ioa_$rsnnl ("  (including ^d from selected files)",
      337 		bcd_card_overlay,			/* convenient based char string, for return arg */
      338 		i, selected_card_count);
      339 	     err_num = err_num + i;			/* err_num = index of first vacant char in extended line */
      340 	end;
      341 
      342 	unspec (substr (err_path, err_num, 4)) = (4)"012"b3; /* append 4 newlines */
      343 						/* (skip 3 lines after message) */
      344 
      345 	err_num = err_num + 3;			/* now, err_num is the exact length of the message */
      346 
      347 	call gcos_write_$ptr (gcos_ext_stat_$er, substr (err_path, 1, err_num), "11111100"b);
      348 
      349 
      350 	if unimp_sw then
      351 	     if ^gcos_ext_stat_$save_data.continue then do;
      352 		if gcos_ext_stat_$save_data.debug then do;
      353 		     query_info.yes_or_no_sw = "1"b;
      354 		     call command_query_ (addr (query_info), answer, "gcos",
      355 			"unimplemented control cards have been found; do you wish to continue?");
      356 		     if answer = "yes" then goto unimp_continue;
      357 		end;
      358 		call gcos_error_ (0, "unimplemented control cards have been used in this job");
      359 	     end;
      360 
      361 unimp_continue: ;
      362 
      363 /* detach job stream file, see if it grew to a msf, and "open" it for reading
      364*   in the appropriate way */
      365 
      366 /*	WRITE EOF RECORD ON IT FIRST */
      367 
      368 	call write_job_stream (addr (eof_rcw), 1);
      369 
      370 	js_io_sw = "1"b;				/* in case of io error, print pathname of job stream file */
      371 
      372 	call ios_$detach ("gcos_job_stream_", "", "", status);
      373 	if code ^= 0 then do;
      374 detach_err:    err_msg = "from ios_$detach ^a";
      375 
      376 /* ALL-PURPOSE ERROR MESSAGE PRINTER */
      377 
      378 file_error:    if restartsw then do;
      379 		a_code = code;
      380 		return;
      381 	     end;
      382 	     if js_io_sw then err_path = js_path;
      383 	     else err_path = current_file.pathname;
      384 	     call gcos_error_ (code, err_msg, err_path, err_num); /* job will be aborted, and not return */
      385 	end;
      386 
      387 restart_join:
      388 	dirname = gcos_ext_stat_$save_dir;
      389 	ename = gcos_ext_stat_$job_id || ".job_deck";
      390 	call hcs_$status_minf (dirname, ename, chase, type, bit_count, code);
      391 
      392 	if code ^= 0 then do;
      393 status_minf_err: err_msg = "from hcs_$status_minf ^a";
      394 	     goto file_error;
      395 	end;
      396 
      397 	if type = 2				/* if it grew to a msf */
      398 	|dbs_msf_test then do;			/* or we just want to test the msf logic */
      399 	     call ios_$attach ("gcos_job_stream_", "file_", js_path, "r", status);
      400 	     if code ^= 0 then do;
      401 attach_r_err:	err_msg = "from ios_$attach ^a r";
      402 		goto file_error;
      403 	     end;
      404 
      405 	     call ios_$setsize ("gcos_job_stream_", 36, status);
      406 	     if code ^= 0 then goto setsize_err;
      407 
      408 
      409 	     save_data.job_deck = null;		/* tell rest of gcos it's not a segment */
      410 	end;
      411 	else
      412 	if type = 1 then do;			/* or if it's a segment */
      413 						/* initiate it, for faster reading than if it were a msf */
      414 
      415 	     call hcs_$initiate_count (dirname, ename, "", bit_count, 0, save_data.job_deck, code);
      416 
      417 	     if save_data.job_deck = null then do;
      418 initiate_err:	err_msg = "from hcs_$initiate_count ^a";
      419 		goto file_error;
      420 	     end;
      421 
      422 	     save_data.jd_size = divide (bit_count, 36, 24, 0); /* size in words!!! */
      423 
      424 
      425 	end;
      426 	else do;					/* bad type code */
      427 type_error:    code = 0;
      428 	     err_num = type;
      429 	     err_msg = "bad type code from hcs_$status_minf for ^a: ^d";
      430 	     goto file_error;
      431 	end;
      432 	call gcos_read_card_$read_init (restartsw);
      433 	return;
      434 
      435 job_stream_restart: entry (a_code);
      436 
      437 	write_buffer_ptr = addr (write_buffer);
      438 /*	status_ptr = addr (status); */
      439 	restartsw = "1"b;
      440 	a_code = 0;
      441 	js_path = gcos_ext_stat_$save_dir || ">" || gcos_ext_stat_$job_id || ".job_deck";
      442 	go to restart_join;
      443 
      444 /*  END OF MAIN PROCEDURE. DEBUGGING ENTRIES AND INTERNAL PROCEDURES FOLLOW     */
      445 
  1     1 /* BEGIN INCLUDE FILE gcos_canonicalizer.incl.pl1   (Wardd Multics)  06/21/81 1435.3 mst Sun */
  1     2 canonicalizer: proc (
  1     3 	     input_string_ptr
  1     4 	     , initial_input_characters
  1     5 	     , output_card_ptr
  1     6 	     , initial_output_columns
  1     7 	     );
  1     8 
  1     9 /* NOTE: a copy of this internal procedure exists also in gcos_card_utility_.
  1    10*   The initialization is different, but the canonicalization code is the same.
  1    11*   Any changes should be made to both copies, if appropriate.
  1    12**/
  1    13 dcl  initial_input_characters fixed bin(21) parm;
  1    14 dcl  initial_output_columns   fixed bin(24)parm;
  1    15 dcl  input_string_ptr         ptr parm;
  1    16 dcl  output_card_ptr          ptr parm;
  1    17 	next_input_character, next_output_column = 1;
  1    18 	remaining_input_characters = initial_input_characters;
  1    19 	remaining_output_columns = initial_output_columns;
  1    20 	more_backspaces, more_tabs = "1"b;		/* we want to look for backspaces and tabs at the start */
  1    21 	if substr (input_string, remaining_input_characters, 1) = ascii_newline /* if last char is a newline */
  1    22 	then remaining_input_characters = remaining_input_characters - 1; /* then get rid of it */
  1    23 
  1    24 
  1    25 /* choose the set of tabs to use for this card */
  1    26 	if substr (input_string, 1, 1) = "$" then
  1    27 	     if length (input_string)>1 then
  1    28 		if (substr (input_string, 2, 1) = TAB) | (substr (input_string, 2, 1) = SP) then do;
  1    29 		     tab_ptr = addr (tab (0));
  1    30 		     goto selected;
  1    31 		end;
  1    32 	tab_ptr = addr (tab (nondollar_canon_index));	/* tabs for the nondollar cards in this activity */
  1    33 selected:	;
  1    34 
  1    35 /*     MAIN LOOP. FILL UP OUTPUT CARD */
  1    36 
  1    37 	do while (remaining_output_columns > 0);	/* keep going while there is any room on output card */
  1    38 	     if more_backspaces then do;		/* if there MIGHT be more backspaces */
  1    39 						/* then look for one */
  1    40 
  1    41 		next_backspace = index (substr (input_string, next_input_character,
  1    42 		     remaining_input_characters), ascii_backspace);
  1    43 		if next_backspace = 0 then more_backspaces = "0"b; /* if none found, remember not to look again */
  1    44 	     end;
  1    45 
  1    46 	     if more_tabs then			/* if there MIGHT be more tabs */
  1    47 find_next_tab:	do;				/* then look for one */
  1    48 		next_tab = index (substr (input_string, next_input_character,
  1    49 		     remaining_input_characters), TAB);
  1    50 		if next_tab = 0 then more_tabs = "0"b;	/* if none found, remember not to look again */
  1    51 	     end;
  1    52 
  1    53 	     if more_backspaces then do;		/* if we found a backspace */
  1    54 						/* see if it is in a legal position */
  1    55 						/* maybe sometime allow backspaces to be in places other than
  1    56*						   immediately following tabs, but for now, it's an error */
  1    57 		if ^more_tabs | next_backspace ^= next_tab+1 then do;
  1    58 		     code = 0;
  1    59 		     err_msg = "canonicalizer: backspace (s) not following a tab in line from ^a:^/" || input_string;
  1    60 		     goto file_error;
  1    61 		end;
  1    62 
  1    63 	     end;
  1    64 
  1    65 	     if more_tabs then do;			/* if we found a tab, we want to move the characters before it */
  1    66 						/* to the output card, and fill with blanks to next tab stop */
  1    67 		character_count = min (		/* compute the number of characters */
  1    68 		     next_tab - 1,			/* before the tab */
  1    69 		     remaining_output_columns);	/* but not more than there's room for on output card */
  1    70 
  1    71 		first_blank = next_output_column + character_count;
  1    72 
  1    73 		do i = 1 to hbound (tabstop, 1)	/* look for a tabstop */
  1    74 			while (tabstop (i) <= first_blank); /* that's past the characters */
  1    75 						/* if it's in the column immediately after the characters,
  1    76*						   then go to next one, the way a typewriter will */
  1    77 		end;
  1    78 
  1    79 		if i <= hbound (tabstop, 1) then	/* if we found one */
  1    80 		     blank_count = min (		/* compute the number of blanks */
  1    81 		     tabstop (i) - first_blank,	/* needed to get there */
  1    82 		     remaining_output_columns);	/* but not more than there's room for on output card */
  1    83 		else				/* if no more tabstops, replace tab with one blank */
  1    84 		blank_count = min (1, remaining_output_columns);
  1    85 	     end;
  1    86 	     else do;
  1    87 						/* if there are no more tabs,
  1    88*						   we want to move the rest of the input characters
  1    89*						   to the output card, and fill the rest of it with blanks */
  1    90 
  1    91 		character_count = min (		/* compute rest of characters to move */
  1    92 		     remaining_input_characters,	/* all the rest, since no more tabs */
  1    93 		     remaining_output_columns);	/* but not more than there's room for on output card */
  1    94 
  1    95 		blank_count = max (0,		/* compute blanks needed to fill rest of card */
  1    96 		     remaining_output_columns - remaining_input_characters);
  1    97 	     end;
  1    98 
  1    99 	     if character_count > 0 then do;		/* move characters to output card, if there are any */
  1   100 		substr (output_card, next_output_column, character_count) =
  1   101 		     substr (input_string, next_input_character, character_count);
  1   102 		remaining_input_characters = remaining_input_characters - character_count;
  1   103 		next_input_character = next_input_character + character_count;
  1   104 		remaining_output_columns = remaining_output_columns - character_count;
  1   105 		next_output_column = next_output_column + character_count;
  1   106 	     end;
  1   107 
  1   108 	     if blank_count > 0 then do;		/* fill with blanks, if any */
  1   109 		substr (output_card, next_output_column, blank_count) = "";
  1   110 		remaining_output_columns = remaining_output_columns - blank_count;
  1   111 		next_output_column = next_output_column + blank_count;
  1   112 	     end;
  1   113 
  1   114 	     if more_tabs then do;			/* move past tab in input string */
  1   115 		remaining_input_characters = remaining_input_characters - 1;
  1   116 		next_input_character = next_input_character + 1;
  1   117 	     end;
  1   118 
  1   119 	     if more_backspaces then do;
  1   120 						/* if we found a backspace, we will:
  1   121*						   1) see if there's more than one of them, and
  1   122*						   2) move back that many columns, deleting whatever is there,
  1   123*						   (probably only blanks ) */
  1   124 
  1   125 		do i = next_input_character to initial_input_characters
  1   126 			while (substr (input_string, i, 1) = ascii_backspace);
  1   127 		end;
  1   128 		character_count = i - next_input_character; /* count backspace characters */
  1   129 		backspace_count = min (character_count, /* count columns to backspace */
  1   130 		     next_output_column - 1);		/* but don't backspace past beginning of card */
  1   131 
  1   132 
  1   133 /* skip over input backspace characters */
  1   134 		remaining_input_characters = remaining_input_characters - character_count;
  1   135 		next_input_character = next_input_character + character_count;
  1   136 
  1   137 /* backspace on output card */
  1   138 		remaining_output_columns = remaining_output_columns + backspace_count;
  1   139 		next_output_column = next_output_column - backspace_count;
  1   140 
  1   141 	     end;
  1   142 	end;
  1   143 
  1   144 /*     WE FALL THRU HERE WHEN remaining_output_columns BECOMES ZERO */
  1   145 
  1   146 	if remaining_input_characters > 0 then		/* if input left over */
  1   147 	     if ^gcos_ext_stat_$save_data.truncate then do; /* and -truncate not given, complain */
  1   148 
  1   149 		code = 0;
  1   150 		err_num = initial_input_characters;
  1   151 		err_msg = "line from ^a is too long (^d characters)^/" || input_string;
  1   152 		if ^gcos_ext_stat_$save_data.continue then /* this is a nonfatal error */
  1   153 		     goto file_error;
  1   154 		if ^gcos_ext_stat_$save_data.brief then /* complain unless told to be quiet */
  1   155 		     call ioa_ (err_msg, current_file.pathname, err_num);
  1   156 	     end;
  1   157 	return;
  1   158 
  1   159 dcl  backspace_count          fixed bin(24);
  1   160 dcl  blank_count              fixed bin(24);
  1   161 dcl  character_count          fixed bin(24);
  1   162 dcl  first_blank              fixed bin(24);
  1   163 dcl  input_string             char (initial_input_characters) based (input_string_ptr);
  1   164 dcl  more_backspaces          bit(1) aligned;
  1   165 dcl  more_tabs                bit(1)aligned;
  1   166 dcl  next_backspace           fixed bin(24)			/* relative to next_input_character */;
  1   167 dcl  next_input_character     fixed bin(24);
  1   168 dcl  next_output_column       fixed bin(24);
  1   169 dcl  next_tab                 fixed bin(24)				/* relative to next_input_character */;
  1   170 dcl  output_card              char (initial_output_columns) based (output_card_ptr);
  1   171 dcl  remaining_input_characters fixed bin(24);
  1   172 dcl  remaining_output_columns fixed bin(24);
  1   173 dcl  SP                       char(1)static int options(constant)init(" ");
  1   174 dcl  TAB                      char(1)static int options(constant)init("	");
  1   175 dcl  tabstop                  (10) fixed bin(24)based (tab_ptr);
  1   176 dcl  tab_ptr                  ptr;
  1   177      end canonicalizer;
  1   178 
  1   179 /*   END INCLUDE FILE gcos_canonicalizer.incl.pl1 */
      446 
      447 
      448 interpret_select_card: proc;
      449 
      450 dcl  ca                       char (1) aligned;
      451 dcl  path_type                fixed bin(24) init (0);
      452 dcl  prmfl_path               char (250) varying init ("")	/* file string is 233 chars max - use 250 to be safe */;
      453 
      454 pick_up_pathname:					/* come here to scan etc cards, too */
      455 	     etc_next_sw = "0"b;			/* off unless we find that path is not complete on this card */
      456 
      457 	     i = index (substr (ascii_card, 16, 57), " "); /* find end of pathname */
      458 	     if i = 0 then
      459 		i = 58;				/* it gets decremented below */
      460 	     if i = 1 then do;
      461 		code = 0;
      462 		err_msg = "no file given on select card from ^a:^/" || ascii_card;
      463 		goto file_error;
      464 	     end;
      465 
      466 	     i = i - 1;				/* get rid of trailing blank */
      467 
      468 /* check for possible continuation onto etc card */
      469 
      470 	     ca = substr (ascii_card, i+15, 1);		/* pick up last nonblank character */
      471 
      472 	     if ca = ">" then do;
      473 		etc_next_sw = "1"b;
      474 		path_type = 1;			/* must be Multics pathname */
      475 	     end;
      476 
      477 	     else
      478 	     if ca = "/" then do;
      479 		etc_next_sw = "1"b;
      480 		path_type = 2;			/* must be GCOS file string */
      481 	     end;
      482 
      483 	     prmfl_path = prmfl_path || substr (ascii_card, 16, i); /* pick up path from this card */
      484 
      485 /* if path is continued, finish processing this card, and then go get the etc card */
      486 
      487 	     if etc_next_sw then do;
      488 		etc_label = select_etc;		/* remember where to return */
      489 		goto print_before_etc;		/* go print on execution report */
      490 select_etc:					/* return here */
      491 		dollar_sw = "0"b;
      492 		call read_current_file;		/* read etc card */
      493 		if dollar_sw then			/* it better be an etc card ... */
      494 		     if card_type = "etc" then goto pick_up_pathname; /* go get rest of path */
      495 
      496 /* error if we fall thru - it was not an etc card */
      497 		code = 0;
      498 		err_msg = "expected etc card missing following:^/$      select  " || prmfl_path;
      499 		goto file_error;
      500 	     end;
      501 
      502 /* now we have the whole thing - do we know its type (pathname or file string) */
      503 
      504 	     if path_type = 0 then do;		/* we don't, so figure it out */
      505 		j = index (prmfl_path, "/");		/* a file string must have at least one "/" */
      506 		if j = 0 then			/* if it doesn't */
      507 		     path_type = 1;			/* it has to be a Multics pathname */
      508 		else do;				/* it has a "/" - could still be a pathname */
      509 		     j = index (prmfl_path, ">");	/* does it have a ">" */
      510 		     if j = 0 then			/* if it doesn't */
      511 			path_type = 2;		/* assume a GCOS file string */
      512 		     else				/* but if it does, Multics is going to interpret it as a
      513*						   separator, even if someone made up a GCOS file string
      514*						   containing a ">" in one of its catalog names or the file
      515*						   name, so we could not process it as a file string anyway */
      516 		     path_type = 1;
      517 		end;
      518 	     end;
      519 
      520 	     if path_type = 2 then
      521 		call gcos_interpret_file_string_ (prmfl_path, select_path, select_path_len, ascii_card);
      522 	     else do;
      523 		select_path = prmfl_path;
      524 		select_path_len = length (prmfl_path);
      525 	     end;
      526 
      527 /* note that value of i (length of path field on this card) has been preserved */
      528 /* look for -ascii and -nocan in comments field */
      529 
      530 	     i = i + 17;				/* move i to first char of comment field */
      531 
      532 	     j = index (substr (ascii_card, i), "-ascii"); /* search whole card image after pathname */
      533 						/* i.e. allow -ascii and -no to run past col 72 */
      534 	     if j ^= 0 then ascii_sw = "1"b;
      535 	     else ascii_sw = "0"b;
      536 
      537 	     if ascii_sw then do;
      538 		j = index (substr (ascii_card, i), "-no"); /* too many ways to spell "no canonicalize..." */
      539 		if j = 0 then canon_sw = "1"b;
      540 		else canon_sw = "0"b;
      541 	     end;
      542 
      543 	     return;
      544 	end interpret_select_card;
      545 
      546 pass1_cleanup: proc;				/* cleanup handler */
      547 
      548 	     do i = stack_level to 1 by -1;
      549 		current_pointer = stacked_pointers (i);
      550 		if i <= hbound (stacked_pointers, 1) then /* avoid freeing nonexistent stuff */
      551 		     if current_pointer ^= null then do;
      552 			if current_file.msf then
      553 			     call ios_$detach (current_file.stream, "", "", status);
      554 						/* ignore errors */
      555 			else
      556 			if current_file.init_ptr ^= null then
      557 			     call hcs_$terminate_noname (current_file.init_ptr, code);
      558 
      559 /* be sure the pointer points into free area */
      560 			if baseno (current_pointer) = baseno (gcos_ext_stat_$system_free_pointer) then
      561 			     free current_file in (system_free_area);
      562 		     end;
      563 	     end;
      564 	     call ios_$detach ("gcos_job_stream_", "", "", status);
      565 	end pass1_cleanup;
      566 
      567 
      568 read_current_file: proc;
      569 
      570 						/* come here to read next line,
      571*						   if this one is null (i.e., just a newline) */
      572 	     if current_file.eof then			/* if no more blocks in file */
      573 		if current_file.eob then do;		/* and no more lines in this block */
      574 		     eof_sw = "1"b;			/* tell caller */
      575 		     return;			/* and return */
      576 		end;
      577 
      578 	     if current_file.ascii then do;		/* Read an ascii file. */
      579 		if current_file.msf then do;		/* Read an ascii msf. */
      580 
      581 /* Ascii file not blocked. Read 1 line into buffer. Element size is 9 bits (one
      582*   ascii character). Delimiter is ascii newline character). Read up to 1280
      583*   characters only because the buffer holds that many. There must be a newline
      584*   long before that, if it is a legal line */
      585 
      586 		     call ios_$read (current_file.stream, buffer_ptr, 0, 1280, chars_read, status);
      587 
      588 		     if code ^= 0 then do;
      589 read_err:			err_msg = "from ios_$read ^a";
      590 show_where:		err_msg = err_msg || " (after card ^d of job)";
      591 			err_num = card_count;
      592 			goto file_error;
      593 		     end;
      594 
      595 		     current_file.eof = substr (unspec (status), 46, 1); /* pick up eof switch from ios */
      596 		end;
      597 		else do;				/* Read an ascii segment: current file is segment */
      598 						/* simulate ios_$read by moving buffer pointer ahead
      599*						   to next line, and setting chars_read to length of it */
      600 
      601 		     buffer_ptr = current_file.read_ptr; /* read_ptr was saved last time thru here */
      602 		     chars_read = index (current_segment, ascii_newline); /* current_segment is based on read_ptr, so
      603*						   it includes only lines we haven't read yet */
      604 		     if chars_read = 0		/* if no newline found */
      605 		     |chars_read >1280		/* or if it was a long way off */
      606 		     then chars_read = 1280;		/* ios_$read would have returned 1280 chars */
      607 
      608 		     if chars_read > current_file.remaining_len /* but if there are not 1280 chars left */
      609 		     then chars_read = current_file.remaining_len; /* ios_$read would have returned what was left */
      610 
      611 		     current_file.remaining_len = current_file.remaining_len - chars_read;
      612 						/* decrement remaining length */
      613 
      614 		     if current_file.remaining_len = 0 then current_file.eof = "1"b;
      615 						/* if none left, give eof on NEXT call */
      616 
      617 		     current_file.read_ptr = addr (buffer_ptr -> char_addrel (chars_read+1));
      618 						/* do addrel in terms of characters */
      619 						/* to get pointer to next line, for use in next call */
      620 
      621 		end;
      622 
      623 		if chars_read = 0 then do;
      624 		     code = 0;
      625 		     err_msg = "zero chars read from ^a";
      626 		     goto show_where;
      627 		end;
      628 
      629 		if chars_read = 1280 then
      630 		     if substr (char_buffer, 1280, 1) ^= ascii_newline then do;
      631 			code = 0;
      632 			err_msg = "no newline for 1280 characters in ^a";
      633 			goto show_where;
      634 		     end;
      635 
      636 		if current_file.needs_canonicalization then
      637 		     call canonicalizer (buffer_ptr, chars_read, ascii_card_ptr, 80);
      638 		else do;
      639 						/* check for long lines, wipe out newline,
      640*						   copy line to output card buffer */
      641 		     if chars_read <= 81 then chars_read = chars_read - 1; /* wipe out newline */
      642 		     else do;			/* line is too long */
      643 			if gcos_ext_stat_$save_data.truncate then /* if user said -truncate */
      644 			     chars_read = 80;	/* just ignore the extras */
      645 			else do;			/* other wise complain */
      646 			     code = 0;
      647 			     err_num = chars_read;
      648 			     err_msg = "line from ^a is too long (^d characters)^/" || char_buffer;
      649 			     if ^gcos_ext_stat_$save_data.continue then /* this is a nonfatal error */
      650 				goto file_error;
      651 			     if ^gcos_ext_stat_$save_data.brief then /* complain unless told to be quiet */
      652 				call ioa_ (err_msg, current_file.pathname, err_num);
      653 			end;
      654 		     end;
      655 		     ascii_card = char_buffer;	/* this statement SHOULD blank out the tail end of ascii_card */
      656 		end;
      657 
      658 /* get bcd image of card */
      659 
      660 get_bcd:		entry;				/* place to enter if creating an endjob card */
      661 
      662 		call gcos_cv_ascii_gebcd_check_ (ascii_card_ptr, 84, bcd_card_ptr, i);
      663 		if i ^= 0 then do;
      664 		     code = 0;
      665 		     err_num = i;
      666 		     err_msg = "line from ^a contains an illegal character in col. ^d^/" || char_buffer;
      667 		     go to file_error;
      668 		end;
      669 
      670 		gcos_record.rcw = bcd_rcw;		/* put standard rcw in front of bcd card */
      671 		if substr (ascii_card, 1, 2) = "$" then do;
      672 		     dollar_sw = "1"b;		/* tell caller about dollar card */
      673 		     card_type = substr (ascii_card, 8, 6); /* and give him its type */
      674 		end;
      675 	     end;
      676 
      677 /* IF WE READ AN ASCII FILE, CONTROL SKIPS OVER THE read_gcos_file BLOCK FOLLOWING, AND RETURNS */
      678 	     else do;				/* current file is in gcos format */
      679 		if current_file.eob then do;		/* do we need another block?  */
      680 		     if current_file.msf then do;
      681 			call ios_$read (current_file.stream, buffer_ptr, 0, 320, words_read, status);
      682 			if code ^= 0 then goto read_err;
      683 			current_file.eof = substr (unspec (status), 46, 1); /* pick up eof switch from ios_$read */
      684 
      685 			if ^current_file.eof then	/* in the unlikely event that the eof switch is NOT on */
      686 			     if words_read < 320 then do; /* when we get a short block */
      687 				code = 0;		/* complain about it */
      688 				err_num = words_read;
      689 				err_msg = "block from ^a contained only ^d words";
      690 				goto file_error;
      691 			     end;
      692 		     end;
      693 		     else do;			/* current file is a segment */
      694 						/* simulate ios_$read by moving pointer */
      695 
      696 			buffer_ptr = current_file.read_ptr;
      697 			words_read = min (320, current_file.remaining_len);
      698 
      699 			current_file.remaining_len = current_file.remaining_len - words_read;
      700 
      701 			if current_file.remaining_len = 0 then current_file.eof = "1"b;
      702 						/* remember to return eof NEXT get block call */
      703 
      704 			current_file.read_ptr = addrel (current_file.read_ptr, words_read);
      705 						/* get pointer to next block, for use in next call */
      706 		     end;
      707 
      708 /* now get first record in block */
      709 
      710 		     current_file.remaining_block_len = fixed (buffer_ptr -> bcw.length);
      711 
      712 		     if current_file.remaining_block_len > 319 /* if block length too long (probably garbage) */
      713 		     | current_file.remaining_block_len < 1 /* or too short (probably all zeros) */
      714 		     then do;			/* then complain */
      715 			code = 0;
      716 			err_num = current_file.remaining_block_len;
      717 			err_msg = "illegal block length in bcw from ^a: ^d words";
      718 			goto file_error;
      719 		     end;
      720 
      721 		     gcos_ptr, current_file.record_ptr = addrel (buffer_ptr, 1);
      722 		     current_file.eob = "0"b;		/* don't get another block 'til this one used up */
      723 		end;
      724 		else				/* just get next record in current block */
      725 		gcos_ptr, current_file.record_ptr =
      726 		     addrel (current_file.record_ptr, fixed (current_file.record_ptr -> rcw.length) + 1);
      727 						/* move pointer past LAST record, to THIS one;
      728*						   +1 because rcw.length does not include the rcw itself */
      729 
      730 /*   COMMON CODE FOR NEW BLOCK OR JUST NEXT RECORD */
      731 		if gcos_ptr -> rcw.eof = bcd_eof then do; /* if this is an eof record */
      732 		     eof_sw = "1"b;			/* return EOF THIS call */
      733 		     current_file.eob, current_file.eof = "1"b; /* in case anyone looks */
      734 		     return;
      735 		end;
      736 		bcd_card_ptr = addrel (gcos_ptr, 1);	/* get pointer to data words in record */
      737 
      738 		gcos_len = fixed (gcos_ptr -> rcw.length); /* get length of THIS record */
      739 
      740 		current_file.remaining_block_len = current_file.remaining_block_len - gcos_len -1;
      741 						/* -1 since gcos_len does not include the rcw */
      742 
      743 		if current_file.remaining_block_len < 0 then do; /* should never happen. program bug if it does */
      744 		     call gcos_error_ (0, "pass1-get next record: block len < 0");
      745 		end;
      746 
      747 		if current_file.remaining_block_len = 0 then current_file.eob = "1"b;
      748 						/* remember to get block NEXT call */
      749 
      750 		if gcos_ptr -> rcw.media_code = "0010"b
      751 		| gcos_ptr -> rcw.media_code = "0011"b
      752 		| gcos_ptr -> rcw.media_code = "0111"b
      753 		& gcos_ext_stat_$save_data.gtssflag then do;
      754 
      755 		     if bcd_card.column (1) = bcd_dollar then /* is it a dollar card ?   */
      756 			if bcd_card.column (2) = bcd_blank then dollar_sw = "1"b;
      757 
      758 		     if gcos_len > 14 then do;
      759 			call ioa_ ("gcos_gein_pass1_ bcd card > 14 words; using first 14");
      760 			gcos_len = 14;
      761 		     end;
      762 
      763 		     if dollar_sw			/* if this is a dollar card */
      764 		     |dbs_nondollar then do;		/* or we are tracing nondollar cards */
      765 			ascii_card = "";		/* blank out card; gcos_cv_gebcd_ascii_ does not blank it */
      766 			call gcos_cv_gebcd_ascii_ (bcd_card_ptr, min (80, gcos_len*6), ascii_card_ptr);
      767 		     end;
      768 
      769 		     if dollar_sw then		/* return type of dollar card */
      770 			card_type = substr (ascii_card, 8, 6);
      771 		end;
      772 
      773 		else
      774 		if gcos_ptr -> rcw.media_code = "0001"b then do; /* if binary card */
      775 		     if dbs_nondollar then ascii_card = "..... binary card .....";
      776 						/* give them something to print in trace */
      777 		end;
      778 		else do;				/* media code not bcd or binary */
      779 		     code = 0;
      780 		     err_num = fixed (gcos_ptr -> rcw.media_code); /* show the code */
      781 		     err_msg = "bad media code in record from ^a: ^d";
      782 		     goto file_error;
      783 		end;
      784 	     end;
      785 	     return;
      786 	end read_current_file;
      787 
      788 stack_selected_file: proc;
      789 
      790 	     stack_level = stack_level + 1;		/* increment stack level */
      791 
      792 	     if stack_level > hbound (stacked_pointers, 1) then do;
      793 		code = 0;
      794 		err_num = stack_level;
      795 		err_msg = "too many nested $ SELECT cards; ^a contains the ^dth";
      796 		goto file_error;
      797 	     end;
      798 
      799 	     allocate current_file
      800 		in (system_free_area)
      801 		set (stacked_pointers (stack_level));
      802 	     current_pointer = stacked_pointers (stack_level);
      803 	     current_file.init_ptr = null;
      804 	     current_file.pathname = select_path;
      805 	     current_file.ascii = ascii_sw;
      806 	     current_file.needs_canonicalization = canon_sw;
      807 	     current_file.eof = "0"b;
      808 	     current_file.eob = "1"b;			/* to get a new block on first call to read */
      809 
      810 	     if ascii_sw then do;
      811 		gcos_ptr = addr (bcd_work_area);
      812 		bcd_card_ptr = addrel (gcos_ptr, 1);
      813 		gcos_len = 14;
      814 	     end;
      815 						/* gcos file initialization done below:
      816*						   different for seg and msf */
      817 	     call expand_path_ (addr (select_path), select_path_len, addr (dirname), addr (ename), code);
      818 	     if code ^= 0 then do;
      819 		err_msg = "from expand_path_ ^a";
      820 		goto file_error;
      821 	     end;
      822 
      823 	     current_file.pathname = rtrim (dirname)||">"||rtrim (ename);
      824 	     call hcs_$status_minf (dirname, ename, chase, type, bit_count, code);
      825 	     if code ^= 0 then goto status_minf_err;
      826 
      827 	     if type = 2				/* if it it is a directory (msf, we hope) */
      828 	     | dbs_msf_test then do;			/* or if we want to test msf logic with a small job */
      829 
      830 		if bit_count = 0 then do;		/* zero bit count => directory, not msf */
      831 		     code = 0;
      832 		     err_msg = "attempt to $ SELECT a directory: ^a";
      833 		     goto file_error;
      834 		end;
      835 
      836 		current_file.msf = "1"b;
      837 		current_file.stream = "select";
      838 						/* convert stack level to characters, and append to "select" */
      839 		i = stack_level;
      840 		if i > 9 then i = divide (i, 10, 24, 0);
      841 		substr (current_file.stream, 7, 1) = substr ("123456789", i, 1);
      842 		if stack_level > 9 then
      843 		     substr (current_file.stream, 8, 1) = substr ("0123456789", 1+mod (stack_level, 10), 1);
      844 						/* this is better than a call to arith_to_char_ ??? */
      845 
      846 		call ios_$attach (current_file.stream, "file_", current_file.pathname, "r", status);
      847 
      848 		if code ^= 0 then goto attach_r_err;
      849 
      850 		buffer_ptr = addr (current_file.buffer);
      851 
      852 		if ^ascii_sw then do;
      853 						/* initializations needed for gcos format msf */
      854 		     call ios_$setsize (current_file.stream, 36, status); /* set element size to 36 (one word)
      855*						   and delimiter to "none" (by changing element size without
      856*						   defining a new delimiter */
      857 		     if code ^= 0 then goto setsize_err;
      858 		end;
      859 
      860 /* for an ascii file, the file dim defaults are used:
      861*   -	element size = 9 (one ascii character)
      862*   -	delimiter is ascii newline character. */
      863 
      864 	     end;
      865 	     else
      866 	     if type = 1 then do;			/* or if it's a segment */
      867 
      868 		current_file.msf = "0"b;
      869 		call hcs_$initiate_count (dirname, ename, "", bit_count, 0, current_file.init_ptr, code);
      870 		if current_file.init_ptr = null then goto initiate_err;
      871 
      872 		if bit_count = 0 then do;
      873 
      874 		     code = 0;
      875 		     err_msg = "zero length file $ SELECTed: ^a";
      876 		     goto file_error;
      877 		end;
      878 
      879 		if ascii_sw then do;		/* initializations needed for ascii segments */
      880 		     current_file.init_len = divide (bit_count, 9, 24, 0); /* length in characters */
      881 		end;
      882 		else do;				/* initializations for gcos format segment */
      883 		     current_file.init_len = divide (bit_count, 36, 24, 0); /* length in words */
      884 		end;
      885 
      886 /* for both ascii and gcos segments:     */
      887 
      888 		current_file.read_ptr = current_file.init_ptr; /* next block = first block */
      889 		current_file.remaining_len = current_file.init_len;
      890 	     end;
      891 	     else goto type_error;			/* if bad type code from hcs_$status_minf */
      892 	     return;
      893 	end stack_selected_file;
      894 
      895 unstack_current_file: proc;
      896 
      897 	     if current_file.msf then do;
      898 		call ios_$detach (current_file.stream, "", "", status);
      899 		if code ^= 0 then goto detach_err;
      900 	     end;
      901 	     else do;
      902 		call hcs_$terminate_noname (current_file.init_ptr, code);
      903 		if code ^= 0 then do;
      904 		     err_msg = "from hcs_$terminate_noname ^a";
      905 		     goto file_error;
      906 		end;
      907 	     end;
      908 	     free current_file in (system_free_area);
      909 	     stacked_pointers (stack_level) = null;	/* the free nulled current_pointer only */
      910 	     stack_level = stack_level -1;
      911 
      912 	     if stack_level > 0 then do;		/* if there's a file to resume reading */
      913 						/* then set up for reading it, where we left off */
      914 		current_pointer = stacked_pointers (stack_level); /* get pointer to info for it */
      915 
      916 		if current_file.ascii then do;	/* re-do some initializations that were not preserved */
      917 		     gcos_ptr = addr (bcd_work_area);
      918 		     bcd_card_ptr = addrel (gcos_ptr, 1);
      919 		     gcos_len = 14;
      920 		end;
      921 		if current_file.msf then buffer_ptr = addr (current_file.buffer);
      922 	     end;
      923 	     return;
      924 	end unstack_current_file;
      925 
      926 write_job_stream: proc (word_ptr, word_count);
      927 
      928 dcl  word_count               fixed bin(24);
      929 dcl  word_ptr                 ptr;
      930 	     if word_count > 319 then do;		/* if record bigger than block, complain */
      931 		code = 0;
      932 		err_num = word_count;		/* tell them how big it is */
      933 		err_msg = "record to be written on ^a is too long: ^d words";
      934 		js_io_sw = "1"b;			/* print job stream file in error message */
      935 		goto file_error;
      936 	     end;
      937 
      938 	     if word_count > remaining_output_words then do; /* if no room in block for this record */
      939 write_block:					/* write the block */
      940 		call ios_$write ("gcos_job_stream_", write_buffer_ptr, 0, 320, words_written, status);
      941 		if code ^= 0 then do;		/* if any problem, complain */
      942 		     err_msg = "from ios_$write ^a";
      943 		     js_io_sw = "1"b;
      944 		     goto file_error;
      945 		end;
      946 
      947 		if words_written ^= 320 then do;	/* if whole block not written, complain */
      948 		     code = 0;
      949 		     err_num = words_written;
      950 		     err_msg = "wrong number of words written on ^a: ^d";
      951 		     js_io_sw = "1"b;
      952 		     goto file_error;
      953 		end;
      954 
      955 /* set block to empty */
      956 		remaining_output_words = 319;
      957 		output_word_ptr = addrel (write_buffer_ptr, 1);
      958 		write_buffer_ptr -> bcw.bsn = bit (fixed (fixed (write_buffer_ptr -> bcw.bsn)+1, 18));
      959 						/* bsn = bsn + 1 */
      960 		write_buffer_ptr -> bcw.length = (18)"0"b; /* length = 0 */
      961 
      962 	     end;
      963 
      964 	     if last_block then return;		/* if we just wrote out the last block, return */
      965 
      966 /* append record to block   */
      967 	     write_buffer_ptr -> bcw.length = bit (fixed (fixed (write_buffer_ptr -> bcw.length) + word_count, 18));
      968 						/* length = length + word_count */
      969 	     output_word_ptr -> words = word_ptr -> words; /* move record to write buffer */
      970 	     output_word_ptr = addrel (output_word_ptr, word_count); /* advance pointer in buffer */
      971 	     remaining_output_words = remaining_output_words - word_count;
      972 
      973 	     if word_count = 1 then do;		/* one word record can only be an eof record */
      974 		last_block = "1"b;			/* remember to quit after writing */
      975 		goto write_block;			/* and go write the block out */
      976 	     end;
      977 	     return;
      978 
      979 dcl  last_block               bit (1) aligned init ("0"b)	/* used only when writing out final block */;
      980 dcl  words                    (word_count) bit (36) based;
      981 	end write_job_stream;
      982 
      983 /*   Variables for gcos_gein_pass1_:		 */
      984 /*   IDENTIFIER		ATTRIBUTES	 */
      985 dcl  act_ptr                  ptr;
      986 dcl  ascii_card               char (80) aligned based (ascii_card_ptr)   /* overlay for one line from an ascii file (segment or msf)  */;
      987 dcl  ascii_card_ptr           ptr	/* init(addrel(ascii_ptr,1)) */;
      988 dcl  ascii_card_record_overlay char (84) aligned based (ascii_ptr)	/* char overlay for ascii record, for gcos_write_$record */;
      989 dcl  ascii_len                fixed bin(24);
      990 dcl  ascii_ptr                ptr	/* init(addr(ascii_work_area)) */;
      991 dcl  ascii_report_card        char (85) aligned based (ascii_card_ptr)	/* to write on execution report. char 85 is nl */;
      992 dcl  ascii_work_area          (23) bit (36) aligned;
      993 dcl  a_code                   fixed bin(35)	/* used by restart entry */;
      994 dcl  bcd_card_overlay         char (60) aligned based (overlay_ptr)	/* to send 15 word gcos record to gcos_write */;
      995 dcl  bcd_card_ptr             ptr	/* always = addrel(gcos_ptr,1) */;
      996 dcl  bcd_work_area            (15) bit (36) aligned;
      997 dcl  buffer_ptr               ptr;
      998 dcl  chars_read               fixed bin(21);
      999 dcl  char_addrel              (1280) char (1) based	/* to do addrel in terms of characters */;
     1000 dcl  char_buffer              char (chars_read) based (buffer_ptr);
     1001 dcl  command_query_           ext entry options (variable);
     1002 dcl  com_err_                 ext entry options (variable);
     1003 dcl  current_pointer          ptr init (null) /* pointer to info structure for file currently being read, (equal to stacked_pointers(stack_level) */;
     1004 dcl  current_segment          char (current_file.remaining_len) based (current_file.read_ptr);
     1005 dcl  err_msg                  char (200) varying;
     1006 dcl  err_num                  fixed bin(24);
     1007 dcl  err_path                 char (200);
     1008 dcl  expand_path_             ext entry (ptr, fixed bin(24), ptr, ptr, fixed bin(35));
     1009 dcl  gcos_cv_ascii_gebcd_check_ ext entry (ptr, fixed bin(24), ptr, fixed bin(24));
     1010 dcl  gcos_cv_gebcd_ascii_     ext entry (ptr, fixed bin(24), ptr);
     1011 dcl  gcos_error_              ext entry options (variable);
     1012 dcl  gcos_et_$cc_bad_field    fixed bin(35) ext;
     1013 dcl  gcos_et_$too_many_activs fixed bin(35) ext;
     1014 dcl  gcos_interpret_file_string_ entry (char (*) varying, char (*), fixed bin(24), char (80) aligned);
     1015 dcl  gcos_len                 fixed bin(24);
     1016 dcl  gcos_ptr                 ptr	/* NOT always = addr(bcd_work_area) - just sometimes */;
     1017 dcl  gcos_read_card_$read_init ext entry (bit (1) aligned);
     1018 dcl  gcos_write_$ascii_ptr    entry (ptr, char (*) aligned, bit (8));
     1019 dcl  gcos_write_$ptr          ext entry (ptr, char (*) aligned, bit (8));
     1020 dcl  gcos_write_$record_ptr   ext entry (ptr, char (*) aligned, bit (8));
     1021 dcl  hcs_$initiate_count      ext entry (char (*), char (*), char (*), fixed bin(24), fixed bin(24), ptr, fixed bin(35));
     1022 dcl  hcs_$status_minf         ext entry (char (*), char (*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
     1023 dcl  hcs_$terminate_noname    ext entry (ptr, fixed bin(35));
     1024 dcl  ioa_                     ext entry options (variable);
     1025 dcl  ioa_$rs                  ext entry options (variable);
     1026 dcl  ioa_$rsnnl               ext entry options (variable);
     1027 dcl  output_word_ptr          ptr;
     1028 dcl  overlay_ptr              ptr;
     1029 dcl  remaining_output_words   fixed bin(24);
     1030 dcl  rtrim                    builtin;
     1031 dcl  SP                       char(1)static int options(constant)init(" ");
     1032 dcl  stacked_pointers         (11) ptr init ((11)null)	/* pointers to info structure for the open files */;
     1033 dcl  stack_level              fixed bin(24)	/* number of input files currently "open"  */;
     1034 dcl  system_free_area         area based (gcos_ext_stat_$system_free_pointer)	/* area to allocate things in   */;
     1035 dcl  unspec                   builtin;
     1036 dcl  words_read               fixed bin(21);
     1037 dcl  words_written            fixed bin(21);
     1038 dcl  write_buffer             (320) bit (36) aligned;
     1039 dcl  write_buffer_ptr         ptr ;
     1040 
     1041 dcl  act_flag                 char (1);
     1042 dcl  act_no                   fixed bin(24);
     1043 dcl  addr                     builtin;
     1044 dcl  addrel                   builtin;
     1045 dcl  answer                   char (4) varying;
     1046 dcl  ascii_backspace          char (1) int static init ("");
     1047 dcl  ascii_rcw                bit (36) aligned int static init ("000024000600"b3);
     1048 dcl  baseno                   builtin;
     1049 dcl  bcd_blank                bit (6) unaligned int static init ("20"b3);
     1050 dcl  bcd_dollar               bit (6) unaligned int static init ("53"b3);
     1051 dcl  bcd_eof                  bit (6) unaligned int static init ("17"b3);
     1052 dcl  bcd_newline_record       bit (72) aligned int static init ("0000010003747701"b3);
     1053 dcl  bcd_newline_record_overlay char (8) aligned based (addr (bcd_newline_record));
     1054 dcl  bcd_number_sign          bit (6) unaligned int static init ("13"b3);
     1055 dcl  bcd_rcw                  bit (36) aligned int static init ("000016000200"b3);
     1056 dcl  bit                      builtin;
     1057 dcl  bit_count                fixed bin(24);
     1058 dcl  card_count               fixed bin(24)init(0);
     1059 dcl  card_type                char (6);
     1060 dcl  chase                    fixed bin(1) init (1);
     1061 dcl  cleanup                  condition;
     1062 dcl  dirname                  char (168);
     1063 dcl  divide                   builtin;
     1064 dcl  ename                    char (32);
     1065 dcl  endfc                    char (2)	/* for endfc option of $ data card */;
     1066 dcl  eof_rcw                  bit (36) aligned int static init ("000000170000"b3);
     1067 dcl  etc_label                label local	/* place to return to after printing card before etc */;
     1068 dcl  fixed                    builtin;
     1069 dcl  hbound                   builtin;
     1070 dcl  i                        fixed bin(24);
     1071 dcl  index                    builtin;
     1072 dcl  ioa_string               char (rtn_string_len) aligned based (addr (rtn_string));
     1073 dcl  j                        fixed bin(24);
     1074 dcl  js_path                  char (168);
     1075 dcl  length                   builtin;
     1076 dcl  LOWER_CASE               char (26) static internal options (constant) init ("abcdefghijklmnopqrstuvwxyz");
     1077 dcl  max                      builtin;
     1078 dcl  min                      builtin;
     1079 dcl  mod                      builtin;
     1080 dcl  nondollar_canon_index    fixed bin(24) /* says which tabs to use for nondollar cards, in the current activity */;
     1081 dcl  null                     builtin;
     1082 dcl  rtn_string               char (256) aligned;
     1083 dcl  rtn_string_len           fixed bin(24);
     1084 dcl  selected_card_count      fixed bin(24)init(0);
     1085 dcl  select_path              char (168);
     1086 dcl  select_path_len          fixed bin(24);
     1087 dcl  substr                   builtin;
     1088 dcl  TAB                      char (1) int static init ("	");
     1089 dcl  translate                builtin;
     1090 dcl  type                     fixed bin(2);
     1091 dcl  UPPER_CASE               char (26) static internal options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
     1092 dcl  VALID_FMS_CHARS          char (38) static internal options (constant) init (".-0123456789abcdefghijklmnopqrstuvwxyz");
     1093 
     1094 dcl  ascii_newline            char (1) int static init ("
     1095 ");
     1096 
     1097 dcl (						/* switches */
     1098      ascii_sw,					/* on if file to be stacked is ascii */
     1099      canon_sw,					/* on if file being stacked needs canonicalization */
     1100      dollar_sw,					/* on if card read is a dollar card */
     1101      eof_sw,					/* on if attempt to read card got end of file */
     1102      select_card,					/* on if this is a select card */
     1103      unimp_sw,					/* on if any unimplemented card is found in the job */
     1104      copy_sw,					/* on if in a $ DATA ,,COPY deck */
     1105      etc_next_sw,					/* on if next card is expected to be etc */
     1106      js_io_sw,					/* on if doing io on job stream file (selects error message) */
     1107      in_password,					/* on while blanking out password on $ USERID card */
     1108      restartsw					/* on if restart entry called */
     1109      ) bit (1) aligned init ("0"b);
     1110 
     1111 dcl 1 current_file aligned based (current_pointer) /* info structure for open input files
     1112*						   new copy allocated each time a $ SELECT card is read,
     1113*						   and freed when eof occurs on the $ SELECTed file */
     1114 
     1115 ,2 stream		char (8)unal
     1116 ,2 init_ptr	ptr aligned
     1117 ,2 init_len	fixed bin(24) aligned
     1118 ,2 read_ptr	ptr aligned
     1119 ,2 record_ptr	ptr aligned
     1120 ,2 remaining_len	fixed bin(35) aligned
     1121 ,2 remaining_block_len	fixed bin(24) aligned
     1122 ,2 ascii 		bit (1) aligned
     1123 ,2 msf 		bit (1) aligned
     1124 ,2 needs_canonicalization bit (1) aligned
     1125 ,2 eob 		bit (1) aligned
     1126 ,2 eof 		bit (1) aligned
     1127 ,2 pathname	char (200) unal
     1128 ,2 buffer 	(320) bit 	(36) aligned
     1129 ;
     1130 
     1131 dcl 1 ascii_record aligned based (ascii_ptr),
     1132     2 rcw bit (36) aligned,
     1133     2 data_words (ascii_len) bit (36) aligned;
     1134 
     1135 dcl 1 bcd_card aligned based (bcd_card_ptr),
     1136     2 column (80) bit (6) unaligned;
     1137 
     1138 dcl 1 gcos_record aligned based (gcos_ptr),
     1139     2 rcw bit 	(36) aligned,
     1140     2 data_words (gcos_len) bit (36) aligned;
     1141 
     1142 dcl 1 bcw aligned based,				/* block control word overlay */
     1143     2 bsn bit (18) unaligned,
     1144     2 length bit (18) unaligned;
     1145 
     1146 dcl 1 rcw aligned based,				/* record control word overlay */
     1147     2 length bit (18) unaligned,
     1148     2 eof bit (6) unaligned,
     1149     2 zeroes bit (2) unaligned,
     1150     2 media_code bit (4) unaligned,
     1151     2 report_code bit (6) unaligned;
     1152 
     1153 dcl 1 act_table_entry based (act_ptr),
     1154     2 fill1 fixed bin(24),
     1155     2 fill2 char (4),
     1156     2 canon_index fixed bin(24);
     1157 
     1158 dcl 1 tabstops	aligned based (addr (gcos_control_tables_$tabstops)),
     1159     2 count	fixed bin(24) aligned,
     1160     2 tab		(0:tabstops.count-1),
     1161       3 stop	(10) fixed bin(24) aligned;
     1162 
  2     1 /* BEGIN INCLUDE FILE gcos_control_tables_.incl.pl1   (Wardd Multics)  09/11/80 1439.7 mst Thu */
  2     2 
  2     3 dcl  gcos_control_tables_$    ext static;
  2     4 dcl  gcos_control_tables_$activity_table ext static	/* table of info on each activity */;
  2     5 dcl  gcos_control_tables_$cardtable (151) char (8) ext static	/* card type table */;
  2     6 dcl  gcos_control_tables_$comp_offset fixed bin ext static	/* offset in cardtable where compilation activities begin */;
  2     7 dcl  gcos_control_tables_$exc_offset fixed bin (17) ext static	/* offset in card lookup table where activity def'ns begin */;
  2     8 dcl  gcos_control_tables_$filecard_count fixed bin ext static	/* length of filecard section of cardtable */;
  2     9 dcl  gcos_control_tables_$nonact fixed bin ext static	/* offset in card lookup table where activity cards end  */;
  2    10 dcl  gcos_control_tables_$tablelen fixed bin (17) ext static	/* length of card lookup table */;
  2    11 dcl  gcos_control_tables_$tabstops ext static	/* table of tabstops for canonicalizing ascii input lines */;
  2    12 dcl  gcos_control_tables_$totallen fixed bin ext static	/* length of cardtable, including unimplemented cards */;
  2    13 
  2    14 /*   END INCLUDE FILE gcos_control_tables_.incl.pl1 */
     1163 
     1164 
  3     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  3     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  3     3 /*	version number changed to 4, 08/10/78 WOS */
  3     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  3     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  3     6 
  3     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  3     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  3     9     2 switches aligned,                                     /* various bit switch values */
  3    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  3    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  3    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  3    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  3    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  3    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  3    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  3    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  3    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  3    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  3    20 
  3    21 /*  Limit of data defined for version 2 */
  3    22 
  3    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  3    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  3    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  3    26 						/* minimum of 30 seconds required for repeat */
  3    27 						/* otherwise, no repeat will occur */
  3    28 /* Limit of data defined for version 4 */
  3    29 
  3    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  3    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  3    32 
  3    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  3    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  3    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  3    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  3    37 
  3    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     1165 
     1166 
  4     1 /* BEGIN INCLUDE FILE gcos_ext_stat_.incl.pl1  */
  4     2 /*
  4     3*  Changes to gcos_ext_stat_ must be made here AND gcos_ext_stat_.cds
  4     4**/
  4     5 /* July 77 (MRJ) Mike Jordan. */
  4     6 /* Change: Mel Wilson Oct 1979 for gtss compatibility (Bell Canada). */
  4     7 /* Change: A. N. Kepner, March, 1978 to allow courtesy call i/o  within cc routines. */
  4     8 /* Change: Dave Ward 06/01/81 Reorganized to eliminate alm object (using cds). Use of like structures. */
  4     9 /* Change: Scott C. Akers 01/26/82 Add tape_buffer_size for GEINOS processing. */
  4    10 /* Change: Ron Barstad  83-08-02  Added activity_card_num for execution report */
  4    11 /*                                Increased size of statistics for 4js3 MMEs  */
  4    12 
  4    13 dcl  gcos_ext_stat_$abort_reason char(128) varying 	/* abort reason from gcos pgm */  ext;
  4    14 dcl  gcos_ext_stat_$abort_return label	/* abort return point */  ext;
  4    15 dcl  gcos_ext_stat_$activity_card_num pic "9999" ext;	/* card number defining current activity */
  4    16 dcl  gcos_ext_stat_$activity_name char(8) 	/* name of activity to be run */  ext;
  4    17 dcl  gcos_ext_stat_$activity_start_time fixed bin(71) 	/* TOD start of activity */  ext;
  4    18 dcl  gcos_ext_stat_$card_num  pic "9999"	/* ordinal number of card in input stream */  ext;
  4    19 dcl  gcos_ext_stat_$dbs       (36)bit(1)	/* Debugging switch. */  ext;
  4    20 dcl  gcos_ext_stat_$default_nondollar char(2) 	/* filecode where nondollar cards go by default */  ext;
  4    21 dcl  gcos_ext_stat_$dir_rings (3) fixed bin(3)	/* ring brackets for created catalogs */  ext;
  4    22 dcl  gcos_ext_stat_$dpno      char(100) varying 	/* arguments for call to dpunch */  ext;
  4    23 dcl  gcos_ext_stat_$dpo       char(100) varying 	/* arguments for call to dprint */  ext;
  4    24 dcl  gcos_ext_stat_$endfc     char(2) 	/* endfc value for endcopy processing */  ext;
  4    25 dcl  gcos_ext_stat_$er        ptr	/* fib pointer for *er */  ext;
  4    26 dcl  gcos_ext_stat_$etc_filecode char(2) 	/* filecode where $ ETC cards should be written */  ext;
  4    27 dcl  gcos_ext_stat_$gcos_slave_area_seg ptr	/* pointer to gcos slave area segment */  ext;
  4    28 dcl  gcos_ext_stat_$gf        fixed bin(24)/* sw used by getfield rtn */  ext;
  4    29 dcl  gcos_ext_stat_$incode    fixed bin(24)	/* switches to control incode processing */  ext;
  4    30 dcl  gcos_ext_stat_$increment_hold fixed bin(24)	/* Holds increment for courtesy call returns. */  ext;
  4    31 dcl  gcos_ext_stat_$initial_cpu_time fixed bin(71) 	/* vcu time at activity start */  ext;
  4    32 dcl  gcos_ext_stat_$input_segment_path char(168) varying 	/* pathname of input segment */  ext;
  4    33 dcl  gcos_ext_stat_$jcl_warnings fixed bin(24)	/* number warnings issued processing control cards */  ext;
  4    34 dcl  gcos_ext_stat_$job_cpu_time fixed bin(71)	/* cpu usage at job start */  ext;
  4    35 dcl  gcos_ext_stat_$job_id    char(18) varying 	/* unique job id for file naming */  ext;
  4    36 dcl  gcos_ext_stat_$job_real_time fixed bin(71)	/* job start time in microseconds */  ext;
  4    37 dcl  gcos_ext_stat_$last_mme  fixed bin(24)/* number of last mme executed */  ext;
  4    38 dcl  gcos_ext_stat_$ldrss     fixed bin(24)	/* loader shared stg. */  ext;
  4    39 dcl  gcos_ext_stat_$max_activities fixed bin(24)/* max activities in a job */  ext;
  4    40 dcl  gcos_ext_stat_$max_mem   fixed bin(19) 	/* maximum memory available to an activity */  ext;
  4    41 dcl  gcos_ext_stat_$mme_rtrn  label	/* where to return at activity end */  ext;
  4    42 dcl  gcos_ext_stat_$nondollar char(2)	/* non-dollar card file code */  ext;
  4    43 dcl  gcos_ext_stat_$nongcos   char(2) 	/* filecode where nongcos dollar cards go */  ext;
  4    44 dcl  gcos_ext_stat_$normal_return label	/* nonlocal goto for normal termination */  ext;
  4    45 dcl  gcos_ext_stat_$patchfile_ptr ptr	/* pointer to patchfile */  ext;
  4    46 dcl  gcos_ext_stat_$pathname_prefix char(168)var ext;
  4    47 dcl  gcos_ext_stat_$pch       ptr	/* pointer to fib for syspunch collector file */  ext;
  4    48 dcl  gcos_ext_stat_$pdir      char(168) varying 	/* pathname of process directory */  ext;
  4    49 dcl  gcos_ext_stat_$prt       ptr	/* pointer to fib for sysprint collector file */  ext;
  4    50 dcl  gcos_ext_stat_$rs        ptr	/* pointer to fib for geload r* collector file */  ext;
  4    51 dcl  gcos_ext_stat_$saveseg_ptr ptr 	/* pointer to save segment used by save/restart */  ext;
  4    52 dcl  gcos_ext_stat_$save_dir  char(168) varying 	/* pathname of temp save directory */  ext;
  4    53 dcl  gcos_ext_stat_$seg_rings (3) fixed bin(3)	/* ring brackets for created files */  ext;
  4    54 dcl  gcos_ext_stat_$sig_ptr   ptr	/* saved pointer to signal_ */  ext;
  4    55 dcl  gcos_ext_stat_$skip_umc  bit(1)  ext;
  4    56 dcl  gcos_ext_stat_$snumb     bit (30) aligned 	/* snumb of the current job */  ext;
  4    57 dcl  gcos_ext_stat_$sought_label char(8) 	/* Label from GOTO, IF, or WHEN card */  ext;
  4    58 dcl  gcos_ext_stat_$statistics (3*44) fixed bin(24)	/* mme usage statistics- 3 per mme */  ext;
  4    59 dcl  gcos_ext_stat_$stop_code fixed bin(24)	/* debugging, print results and stop. */  ext;
  4    60 dcl  gcos_ext_stat_$storage_limit fixed bin(19) 	/* activity storage limit */  ext;
  4    61 dcl  gcos_ext_stat_$sysout_limit fixed bin(35) 	/* sysout line limit */  ext;
  4    62 dcl  gcos_ext_stat_$sysout_lines fixed bin(35)	/* sysout lines used */  ext;
  4    63 dcl  gcos_ext_stat_$system_free_pointer ptr 	/* pointer to area for allocating in  ext; set by gcos */  ext;
  4    64 dcl  gcos_ext_stat_$tape_buffer_size fixed bin(35) external static;	/* tape buffer size for GEINOS. */
  4    65 dcl  gcos_ext_stat_$temp_dir  char(168) varying 	/* pathname of directory to hold temp files */  ext;
  4    66 dcl  gcos_ext_stat_$temp_seg_ptr ptr ext;
  4    67 dcl  gcos_ext_stat_$termination_code bit (18) 	/* termination code from gcos_mme_bort_ */  ext;
  4    68 dcl  gcos_ext_stat_$time_limit fixed bin(71) 	/* activity time limit */  ext;
  4    69 dcl  gcos_ext_stat_$userid    char(12) 	/* the USERID */  ext;
  4    70 dcl  gcos_ext_stat_$validation_level fixed bin(3)	/* current ring of execution */  ext;
  4    71 
  4    72 /*	Courtesy Call Queue
  4    73*   A queue for courtesy call addresses which must be saved during
  4    74*   execution of courtesy call routines. A courtesy call address is
  4    75*   saved each time a MME GEROUT or MME GEINOS, which specifies a
  4    76*   courtesy call, is executed within a courtesy call routine. Each
  4    77*   time a MME GEENDC is executed a courtesy call address will be
  4    78*   removed from this FIFO queue and the corresponding courtesy call
  4    79*   routine executed until the queue is empty. The FIFO "queue" is
  4    80*   implemented in a circular fashion. "next_avail" points to the
  4    81*   next empty location in the queue. "next_out" points to the
  4    82*   entry in the queue which has been in the queue longest. When
  4    83*   entering or removing entries from the queue the appropriate index
  4    84*   is incremented modulo the length of the queue. By convention the
  4    85*   queue is empty when "next_avail" equals "next_out". A
  4    86*   second convention is that the queue is considered to overflow
  4    87*   during an attempt to add an entry to the queue which would force
  4    88*   "next_avail" to "catch up" with "next_out". This means that
  4    89*   the last empty position in the queue will never be used.
  4    90**/
  4    91 
  4    92 dcl 1 gcos_ext_stat_$courtesy_call_control aligned ext
  4    93 ,     3 courtesy_call
  4    94 ,       4 hold             like save_machine_conditions	/* Mach. conds. restored on courtesy call returns. */
  4    95 ,       4 next_avail       fixed bin(24)		/* next available empty location in cc_queue. */
  4    96 ,       4 next_out         fixed bin(24)		/* next entry to remove from cc_queue. */
  4    97 ,       4 queue            (6) fixed bin(24)
  4    98 ;
  4    99 
  5     1 /* BEGIN INCLUDE FILE gcos_save_mc.incl.pl1   (Wardd Multics)  09/12/81 0905.9 mst Sat */
  5     2 
  5     3 /* Structure to isolate the definition of the size of the
  5     4*space needed to store he machine conditions structure (mc).
  5     5**/
  5     6 dcl 1 save_machine_conditions based
  5     7 ,     3 save_space		bit(1728)
  5     8 ;
  5     9 
  5    10 /*   END INCLUDE FILE gcos_save_mc.incl.pl1 */
  4   100 
  4   101 
  4   102 dcl 1 gcos_ext_stat_$fct	aligned ext,
  4   103       3 fct		(40) like fct_entry;
  6     1 /* BEGIN INCLUDE FILE gcos_fct_entry.incl.pl1   (Wardd Multics)  05/30/81 1758.6 mst Sat */
  6     2 
  6     3 dcl 1 fct_entry	aligned based,
  6     4       2 filecode	char(2) aligned,			/* file code (or blank) */
  6     5 						/* flags */
  6     6       2 sysout	bit(1) unaligned,			/* 1=file is sysout or dac */
  6     7       2 dac	bit(1) unaligned,			/* 1=file is dac,0=file is sysout */
  6     8       2 pad	bit(34) unaligned,			/* unused */
  6     9       2 fibptr	ptr aligned			/*	ptr to fib for this file */
  6    10 ;
  6    11 
  6    12 /*   END INCLUDE FILE gcos_fct_entry.incl.pl1 */
  4   104 
  4   105 
  4   106 dcl 1 gcos_ext_stat_$save_data aligned ext,
  4   107       3 save_data like save_data_entry;
  7     1 /* BEGIN INCLUDE FILE gcos_save_data_entry.incl.pl1   (Wardd Multics)  07/01/81 1339.9 mst Wed */
  7     2 /* Change: Dave Ward	07/01/81 include gcos_flags_. */
  7     3 /* Change: Dave Ward	09/10/81 fib changed to fibs & likened to fib. */
  7     4 
  7     5 dcl 1 save_data_entry  aligned based
  7     6 ,3 flgs                like flags	/* system wide flgs */
  7     7 ,3 actid               char(8)	/* activity no. and accnt i.d. */
  7     8 ,3 short_actid         bit(36) aligned	/* short form of activity id */
  7     9 ,3 ident               char(60)	/* holds ident info from snumb card */
  7    10 ,3 psw                 bit(36) aligned	/* program switch word */
  7    11 ,3 last_execute_act_no fixed bin(24)/* activity number of last $ EXECUTE card in job */
  7    12 ,3 activity_no         fixed bin(24)/* activity number */
  7    13 ,3 job_time_limit      fixed bin(71)	/* job time limit */
  7    14 ,3 job_sysout_limit    fixed bin(24)/* job sysout line limit */
  7    15 ,3 sysout_queue        (10) char(32)	/* sysout queue */
  7    16 ,3 sysout_queue_media  (10) fixed bin(24)/* medium (print,punch) of each file on queue */
  7    17 ,3 sqindex             fixed bin(24)/* curr offset in sysout queue */
  7    18 ,3 pathname_prefix     char(168)varying 	/* prefix for gcos cfdescs */
  7    19 ,3 skip_umc            aligned bit(1) 	/* flag to tell if we should skip umc names */
  7    20 ,3 job_deck            pointer	/* pointer to seg holding canonicalized job deck */
  7    21 ,3 jd_size             fixed bin(24)/* size in words of job deck */
  7    22 ,3 jd_position         fixed bin(24)	/* position of current block of job deck */
  7    23 ,3 jd_rem_block_len    fixed bin(24)/* words remaining in current block of job deck */
  7    24 ,3 syot_dir            char(168)varying	/* pathname of directory to hold sysout files */
  7    25 ,3 fibs		   (40) like fib
  7    26 ,3 param               (32) char(57)varying	/* parameters */
  7    27 ;
  7    28 
  8     1 /* BEGIN INCLUDE FILE gcos_flags.incl.pl1   (Wardd Multics)  07/01/81 1344.7 mst Wed */
  8     2 /* Change: Mel Wilson	03/01/79 to add gtssflag & identflag */
  8     3 /* Change: Dave Ward	07/01/81 revised, mad apart of gcos_ext_stat_. */
  8     4 
  8     5 
  8     6 /* 	Declaration of Simulator Wide Flags	 */
  8     7 
  8     8 dcl 1 flags aligned based,
  8     9       2 (
  8    10 	pad1,	/* no longer used */
  8    11 	copy,	/* 1=copy option on|0=off */
  8    12 	snumb,	/* 1=snumb card read|0=not */
  8    13 	ident,	/* 1=ident card read|0=not */
  8    14 	activ,	/* 1=activity being defined|0=not */
  8    15 	cc,	/* 1=courtesy call active|0=not */
  8    16 	pad2,	/* no longer used */
  8    17 	cksum,	/* 1=don't check checksums|0=do */
  8    18 	pad3,	/* no longer used */
  8    19 	wrapup,	/* 1=processing wrapup after abort */
  8    20 
  8    21 /* FOLLOWING ADDED AFTER MARCH 73 */
  8    22 
  8    23 	nosave,	/* 1=disable save/restart function,0=not */
  8    24 	pad4,	/* no longer used */
  8    25 	gcos,	/* 1=job deck segment in gcos file format */
  8    26 	raw,	/* 1=sysout punch files to be converted to raw bit strings */
  8    27 	list,	/* 1=sysout print files to be converted to ascii */
  8    28 	brief,	/* 1=print nothing but fatal error messages on terminal */
  8    29 	debug,	/* 1=give option to call debug before aborting */
  8    30 	no_canonicalize,	/* 1=do NOT canonicalize job deck */
  8    31 
  8    32 /* 18 bits into first word */
  8    33 
  8    34 	pad5,	/* no longer used */
  8    35 	dpunch,	/* 1=dpunch sysout punch files;0=don't */
  8    36 	dprint,	/* 1=dprint sysout print files,0=don't */
  8    37 	userid,	/* 1=userid card read,0=not */
  8    38 	userlib,	/* 1= -userlib ctl arg given, see gcos_gein_ */
  8    39 	dstar,	/* 1=current activity card written on d* */
  8    40 	write_etc,	/* 1 tells get_cc_field to write $ ETC cards on etc_filecode */
  8    41 	prev_act_abort,	/* turned on by abort and off by $ BREAK */
  8    42 	this_act_abort,	/* turned on by abort to select abort disp codes */
  8    43 	abort_subact,	/* 1=processing abort subactivity */
  8    44 	dump,	/* 1=dump option given on activity card */
  8    45 	nondollar,	/* 1=reading nondollar card deck in gein */
  8    46 	endjob,	/* 1=cc_endjob already called once in this job */
  8    47 	abort_card,	/* 1=the terminator for this activity was a $ ABORT card */
  8    48 	truncate,	/* 1=truncate option given:truncate long ascii input lines */
  8    49 	continue,	/* 1=continue option given:continue after nonfatal errors */
  8    50 	rout,	/* 1=gcos_mme_rout_ was called in this activity */
  8    51 	seeking,	/* 1=gein is looking for a label and/or terminator */
  8    52 
  8    53 /* end of first word */
  8    54 
  8    55 	seeking_terminator,	/* 1=gein is looking for a terminator */
  8    56 	lower_case,	/* 1=lower case print conversion wanted */
  8    57 	no_bar,	/* 1=do not run slave program in BAR mode */
  8    58 	long,	/* 1=print some lines from execution reort on terminal */
  8    59 	endfc,	/* 1=process endfc option on endcopy card */
  8    60 	gtssflag,	/* 1=update gtss_user_state_ during execution */
  8    61 	identflag,	/* 1= use $ident banner info for print & punch */
  8    62 	spawnflag,	/* 1= entry due to tss spawn */
  8    63 	taskflag	/* 1= entry due to tss drl task */
  8    64 		) bit(1) unal,
  8    65       2	pad6	  bit(27)unal
  8    66 ;
  8    67 
  8    68 /*   END INCLUDE FILE gcos_flags.incl.pl1 */
  7    29 
  7    30 
  7    31 /*   END INCLUDE FILE gcos_save_data_entry.incl.pl1 */
  4   108 
  4   109 
  9     1 /*     BEGIN INCLUDE FILE gcos_file_info_block_.incl.pl1   DAK - APRIL 74    */
  9     2 
  9     3 /* 	Declaration of File Information Block (fib)
  9     4*
  9     5*   Change: Mel Wilson	11/01/79 for gtss compatibility
  9     6*   Change: Dave Ward	05/20/81 *_file constants.
  9     7*   Change: Dave Ward	05/29/81 separated fct structures.
  9     8*   Change: Dave Ward	09/02/81 provision for tape density 6250, dens_hist 2 bits (not 3).
  9     9**/
  9    10 dcl 1 fib aligned based (fibptr)			/* fib structure */
  9    11 
  9    12 ,     2 buffer	ptr aligned			/* pointer to current buffer (gcos_write_) */
  9    13 ,     2 buffer_indx	fixed bin			/* Index to buffer in use. */
  9    14 ,     2 stream	char(8)unal			/* stream name for attaching this file */
  9    15 ,     2 pathnm	char(168)unal			/* pathname (for disk, print or punch files) */
  9    16 ,     2 unique_file_id bit(36)				/* multics unique segment id for file */
  9    17 ,     2 indicators					/* five words of flags */
  9    18 
  9    19 ,       3 indicators_word_1
  9    20 ,         4 used	bit(1) unal			/* 1=fib used, 0=fib used */
  9    21 ,         4 attached	bit(1) unal			/* 1=stream is attached */
  9    22 ,         4 type	bit(1) unal			/* 1=random, 0=linked */
  9    23 ,         4 perm	bit(1) unal			/* 1=permanent file, 0=not */
  9    24 ,         4 print	bit(1) unal			/* 1=file type is printer */
  9    25 ,         4 punch	bit(1) unal			/* 1=file type is punch */
  9    26 ,         4 reader	bit(1) unal			/* 1=file type is card reader */
  9    27 ,         4 tape	bit(1) unal			/* 1=file type is tape */
  9    28 ,         4 console	bit(1) unal			/* 1=file type is console typewriter */
  9    29 ,         4 read	bit(1) unal			/* 1=read access permitted */
  9    30 ,         4 write	bit(1) unal			/* 1=write access permitted */
  9    31 ,         4 null	bit(1) unal			/* 1=file is null */
  9    32 ,         4 purge	bit(1) unal			/* 1=purge file at time on release */
  9    33 ,         4 gein	bit(1) unal			/* 1 = this file contains data cards from the job deck */
  9    34 ,         4 disp	bit(2) unal			/* disposition code:
  9    35*						   00 = dismount
  9    36*						   01 = release
  9    37*						   10 = save
  9    38*						   11 = continue	 */
  9    39 ,         4 adisp	bit(2) unal			/* abort disp - same codes as disp */
  9    40 ,         4 order	bit(1) unal			/* 1 = write, 0 = read or other */
  9    41 ,         4 mode	bit(2) unal			/* tape i/o mode 
  9    42*						   00 = binary
  9    43*						   01 = decimal
  9    44*						   10 = nine	*/
  9    45 ,         4 tracks	bit(2) unal			/* tape request code:
  9    46*						   00 = installation default
  9    47*						   01 = 7 track
  9    48*						   10 = 9 track	*/
  9    49 ,         4 density	bit(4) unal			/* tape density from $ TAPE card
  9    50*						   0000 = site standard high
  9    51*						   0001 = 200 bpi
  9    52*						   0010 = 556 bpi
  9    53*						   0100 = 800 bpi
  9    54*						   1001 = 1600 bpi
  9    55*						   1100 = 6250 bpi
  9    56*						   1111 = handler capable of any appropriate denisty */
  9    57 ,         4 dens_hist	bit(2) unal			/* density history for MME GEFADD */
  9    58 ,         4 forced_acl_flag bit(1) unal 			/* 1 => acl forced for gtss file (2.4) */
  9    59 ,         4 fill	bit(6) unal			/* reserved for future use */
  9    60 ,       3 indicators_word_2
  9    61 ,         4 plud	bit(18) unal			/* primary log unit designator */
  9    62 						/* bcd channel and channel number */
  9    63 
  9    64 ,         4 slud	bit(18) unal			/* secondary log. unit designator */
  9    65 						/* bcd channel and channel number */
  9    66 ,       3 indicators_word_3
  9    67 ,         4 serial_no	bit(30) unal			/* tape serial number */
  9    68 ,         4 pad	bit( 6) unal			/* unused */
  9    69 ,       3 indicators_word_4
  9    70 ,         4 tape_name	bit(72) unal			/* tape name */
  9    71 
  9    72 ,     2 current	fixed bin(21)			/* current file position */
  9    73 ,     2 last	fixed bin(21)			/* eof for sequential disk files */
  9    74 ,     2 size	fixed bin(24)			/* offset of end of file in words */
  9    75 ,     2 init_size	fixed bin(24)			/* file size at start of activity */
  9    76 ,     2 init_posit	fixed bin(24)			/* file position at start of activity */
  9    77 ,     2 iocount	fixed bin(35)			/* total no. of i/o operations */
  9    78 ,     2 rec_len	fixed bin(24)			/* length of current record (gcos_write_) */
  9    79 ,     2 command_count	fixed bin(17) unal		/* size of command table for device (gcos_mme_inos_) */
  9    80 ,     2 command_index	fixed bin(17) unal		/* pointer to command table entry (gcos_mme_inos_) */
  9    81 ,     2 error_retry	fixed bin(17) unal		/* error retry counter */
  9    82 ,     2 seq_no	fixed bin(17) unal		/* tape reel sequence no */
  9    83 ;
  9    84 dcl  fibptr                   ptr			/* pointer to current fib in gcos_ext_stat_ */;
  9    85 
  9    86 /* File usage classification constants: */
  9    87 dcl  linked_file              bit(1)static int options(constant)init("0"b);
  9    88 dcl  random_file              bit(1)static int options(constant)init("1"b);
  9    89 dcl  read_file                bit(1)static int options(constant)init("0"b);
  9    90 dcl  write_file               bit(1)static int options(constant)init("1"b);
  9    91 
  9    92 /*     END INCLUDE FILE gcos_file_info_block_.incl.pl1     */
  4   110 
  4   111 
  4   112 dcl 1 gcos_ext_stat_$mc like mc	/* machine condition from abort or fault */  ext;
 10     1 /*  */
 10     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 10     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 10     4 /* Modified 07/07/76 by Morris for fault register data */
 10     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 10     6 /* Modified '82 to make values constant */
 10     7 
 10     8 /* words 0-15 pointer registers */
 10     9 
 10    10 dcl  mcp ptr;
 10    11 
 10    12 dcl 1 mc based (mcp) aligned,
 10    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 10    14    (2 regs,					/* registers */
 10    15       3 x (0:7) bit (18),				/* index registers */
 10    16       3 a bit (36),					/* accumulator */
 10    17       3 q bit (36),					/* q-register */
 10    18       3 e bit (8),					/* exponent */
 10    19       3 pad1 bit (28),
 10    20       3 t bit (27),					/* timer register */
 10    21       3 pad2 bit (6),
 10    22       3 ralr bit (3),				/* ring alarm register */
 10    23 
 10    24     2 scu (0:7) bit (36),
 10    25 
 10    26     2 mask bit (72),				/* mem controller mask at time of fault */
 10    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 10    28     2 errcode fixed bin (35),				/* fault handler's error code */
 10    29     2 fim_temp,
 10    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 10    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 10    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 10    33     2 fault_reg bit (36),				/* fault register */
 10    34     2 pad2 bit (1),
 10    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 10    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 10    37     2 fault_time bit (54),				/* time of fault */
 10    38 
 10    39     2 eis_info (0:7) bit (36)) unaligned;
 10    40 
 10    41 
 10    42 dcl (apx fixed bin init (0),
 10    43      abx fixed bin init (1),
 10    44      bpx fixed bin init (2),
 10    45      bbx fixed bin init (3),
 10    46      lpx fixed bin init (4),
 10    47      lbx fixed bin init (5),
 10    48      spx fixed bin init (6),
 10    49      sbx fixed bin init (7)) internal static options (constant);
 10    50 
 10    51 
 10    52 
 10    53 
 10    54 dcl  scup ptr;
 10    55 
 10    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 10    57 
 10    58 
 10    59 /*	WORD (0)		*/
 10    60 
 10    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 10    62       3 prr bit (3),				/* procedure ring register */
 10    63       3 psr bit (15),				/* procedure segment register */
 10    64       3 p bit (1),					/* procedure privileged bit */
 10    65 
 10    66     2 apu,					/* APPENDING UNIT STATUS */
 10    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 10    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 10    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 10    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 10    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 10    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 10    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 10    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 10    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 10    76       3 ptw bit (1),				/* Fetch of PTW */
 10    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 10    78       3 fap bit (1),				/* Fetch of final address paged */
 10    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 10    80       3 fabs bit (1),				/* Fetch of final address absolute */
 10    81 
 10    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 10    83 
 10    84 
 10    85 /*	WORD (1)		*/
 10    86 
 10    87     2 fd,						/* FAULT  DATA */
 10    88       3 iro bit (1),				/* illegal ring order */
 10    89       3 oeb bit (1),				/* out of execute bracket */
 10    90       3 e_off bit (1),				/* no execute */
 10    91       3 orb bit (1),				/* out of read bracket */
 10    92       3 r_off bit (1),				/* no read */
 10    93       3 owb bit (1),				/* out of write bracket */
 10    94       3 w_off bit (1),				/* no write */
 10    95       3 no_ga bit (1),				/* not a gate */
 10    96       3 ocb bit (1),				/* out of call bracket */
 10    97       3 ocall bit (1),				/* outward call */
 10    98       3 boc bit (1),				/* bad outward call */
 10    99       3 inret bit (1),				/* inward return */
 10   100       3 crt bit (1),				/* cross ring transfer */
 10   101       3 ralr bit (1),				/* ring alarm register */
 10   102       3 am_er bit (1),				/* associative memory fault */
 10   103       3 oosb bit (1),				/* out of segment bounds */
 10   104       3 paru bit (1),				/* processor parity upper */
 10   105       3 parl bit (1),				/* processor parity lower */
 10   106       3 onc_1 bit (1),				/* op not complete type 1 */
 10   107       3 onc_2 bit (1),				/* op not complete type 2 */
 10   108 
 10   109     2 port_stat,					/* PORT  STATUS */
 10   110       3 ial bit (4),				/* illegal action lines */
 10   111       3 iac bit (3),				/* illegal action channel */
 10   112       3 con_chan bit (3),				/* connect channel */
 10   113 
 10   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 10   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 10   116 
 10   117 
 10   118 /*	WORD (2)		*/
 10   119 
 10   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 10   121       3 trr bit (3),				/* temporary ring register */
 10   122       3 tsr bit (15),				/* temporary segment register */
 10   123 
 10   124     2 pad2 bit (9),
 10   125 
 10   126     2 cpu_no bit (3),				/* CPU number */
 10   127 
 10   128     2 delta bit (6),				/* tally modification DELTA */
 10   129 
 10   130 
 10   131 /*	WORD (3)		*/
 10   132 
 10   133     2 word3 bit (18),
 10   134 
 10   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 10   136       3 tsna,					/* Word 1 status */
 10   137         4 prn bit (3),				/* Word 1  PR  number */
 10   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 10   139       3 tsnb,					/* Word 2  status */
 10   140         4 prn bit (3),				/* Word 2  PR  number */
 10   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 10   142       3 tsnc,					/* Word 3  status */
 10   143         4 prn bit (3),				/* Word 3  PR  number */
 10   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 10   145 
 10   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 10   147 
 10   148 
 10   149 /* 	WORD (4)		*/
 10   150 
 10   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 10   152 
 10   153     2 ir,						/* INDICATOR  REGISTERS */
 10   154       3 zero bit (1),				/* zero indicator */
 10   155       3 neg bit (1),				/* negative indicator */
 10   156       3 carry bit (1),				/* carryry indicator */
 10   157       3 ovfl bit (1),				/* overflow indicator */
 10   158       3 eovf bit (1),				/* eponent overflow */
 10   159       3 eufl bit (1),				/* exponent underflow */
 10   160       3 oflm bit (1),				/* overflow mask */
 10   161       3 tro bit (1),				/* tally runout */
 10   162       3 par bit (1),				/* parity error */
 10   163       3 parm bit (1),				/* parity mask */
 10   164       3 bm bit (1),					/* ^bar mode */
 10   165       3 tru bit (1),				/* truncation mode */
 10   166       3 mif bit (1),				/* multi-word instruction mode */
 10   167       3 abs bit (1),				/* absolute mode */
 10   168       3 hex bit (1),				/* hexadecimal exponent mode */
 10   169       3 pad bit (3),
 10   170 
 10   171 
 10   172 /*	WORD (5)		*/
 10   173 
 10   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 10   175 
 10   176     2 cu,						/* CONTROL UNIT STATUS */
 10   177       3 rf bit (1),					/* on first cycle of repeat instr */
 10   178       3 rpt bit (1),				/* repeat instruction */
 10   179       3 rd bit (1),					/* repeat double instruction */
 10   180       3 rl bit (1),					/* repeat link instruciton */
 10   181       3 pot bit (1),				/* IT  modification */
 10   182       3 pon bit (1),				/* return type instruction */
 10   183       3 xde bit (1),				/* XDE from Even location */
 10   184       3 xdo bit (1),				/* XDE from Odd  location */
 10   185       3 poa bit (1),				/* operation preparation */
 10   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 10   187       3 its bit (1),				/* ITS modification */
 10   188       3 if bit (1),					/* fault occured during instruction fetch */
 10   189 
 10   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 10   191 
 10   192 
 10   193 /*	WORDS (6,7)	*/
 10   194 
 10   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 10   196 
 10   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 10   198 
 10   199 
 10   200 
 10   201 
 10   202 
 10   203 
 10   204 /*	ALTERNATE   SCU  DECLARATION		*/
 10   205 
 10   206 
 10   207 dcl 1 scux based (scup) aligned,
 10   208 
 10   209    (2 pad0 bit (36),
 10   210 
 10   211     2 fd,						/* GROUP II  FAULT DATA */
 10   212       3 isn bit (1),				/* illegal segment number */
 10   213       3 ioc bit (1),				/* illegal op  code  */
 10   214       3 ia_am bit (1),				/* illegal address - modifier */
 10   215       3 isp bit (1),				/* illegal slave  procedure */
 10   216       3 ipr bit (1),				/* illegal procedure */
 10   217       3 nea bit (1),				/* non existent address */
 10   218       3 oobb bit (1),				/* out of bounds */
 10   219       3 pad bit (29),
 10   220 
 10   221     2 pad2 bit (36),
 10   222 
 10   223     2 pad3a bit (18),
 10   224 
 10   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 10   226       3 prn bit (3),				/* PR  number */
 10   227       3 prv bit (1),				/* PR  valid bit */
 10   228 
 10   229     2 pad3b bit (6)) unaligned,
 10   230 
 10   231     2 pad45 (0:1) bit (36),
 10   232 
 10   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 10   234 
 10   235 
 10   236 
 10   237 /*  END INCLUDE FILE   mc.incl.pl1 */
  4   113 
  4   114 
  4   115 dcl 1 gcos_ext_stat_$gcos_gtss	ext
  4   116 ,     3 gcos_gtss_ext
  4   117 ,       4 u_state_ptr ptr
  4   118 ,       4 snumb_index fixed bin(24)
  4   119 ,       4 home_path char(168)
  4   120 ;
  4   121 
  4   122 /*   END INCLUDE FILE gcos_ext_stat_.incl.pl1 */
     1167 
     1168 
 11     1 /* BEGIN INCLUDE FILE gcos_dbs_names.incl.pl1   (Wardd Multics)  06/08/81 1626.9 mst Mon */
 11     2 
 11     3 dcl dbs_names (11)char(14)var static int options(constant)init(
 11     4   /*  1 */ "attach_file"
 11     5 , /*  2 */ "dollar"
 11     6 , /*  3 */ "filecode"
 11     7 , /*  4 */ "mme_call"
 11     8 , /*  5 */ "mme_inos_trace"
 11     9 , /*  6 */ "trace_mme"
 11    10 , /*  7 */ "nondollar"
 11    11 , /*  8 */ "open_file"
 11    12 , /*  9 */ "msf_test"
 11    13 , /* 10 */ "stop_mme"
 11    14 , /* 11 */ "mme_inos_stop"
 11    15 );
 11    16 
 11    17 dcl (
 11    18  dbs_attach_file	defined(gcos_ext_stat_$dbs(1))
 11    19 ,dbs_dollar	defined(gcos_ext_stat_$dbs(2))
 11    20 ,dbs_filecode	defined(gcos_ext_stat_$dbs(3))
 11    21 ,dbs_mme_call	defined(gcos_ext_stat_$dbs(4))
 11    22 ,dbs_mme_inos_trace	defined(gcos_ext_stat_$dbs(5))
 11    23 ,dbs_trace_mme	defined(gcos_ext_stat_$dbs(6))
 11    24 ,dbs_nondollar	defined(gcos_ext_stat_$dbs(7))
 11    25 ,dbs_open_file	defined(gcos_ext_stat_$dbs(8))
 11    26 ,dbs_msf_test	defined(gcos_ext_stat_$dbs(9))
 11    27 ,dbs_stop_mme	defined(gcos_ext_stat_$dbs(10))
 11    28 ,dbs_mme_inos_stop	defined(gcos_ext_stat_$dbs(11))
 11    29 		) bit(1);
 11    30 
 11    31 /*   END INCLUDE FILE gcos_dbs_names.incl.pl1 */
     1169 
     1170 
 12     1 /* BEGIN INCLUDE FILE gcos_dcl_ios_.incl.pl1   (Wardd Multics)  06/16/81 1040.9 mst Tue */
 12     2 
 12     3 dcl  ios_$attach		entry (
 12     4 			char(*)
 12     5 ,			char(*)
 12     6 ,			char(*)
 12     7 ,			char(*)
 12     8 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12     9 				);
 12    10 
 12    11 dcl  ios_$detach		entry (
 12    12 			char(*)
 12    13 ,			char(*)
 12    14 ,			char(*)
 12    15 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    16 				);
 12    17 
 12    18 dcl  ios_$order               entry (
 12    19 			char(*)
 12    20 ,			char(*)
 12    21 ,			ptr
 12    22 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    23 				);
 12    24 
 12    25 dcl  ios_$read                entry (
 12    26 			char(*)
 12    27 ,			ptr
 12    28 ,			fixed bin(21)
 12    29 ,			fixed bin(21)
 12    30 ,			fixed bin(21)
 12    31 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    32 				);
 12    33 
 12    34 dcl  ios_$read_ptr            entry (
 12    35 			ptr
 12    36 ,			fixed bin(21)
 12    37 ,			fixed bin(21)
 12    38 				);
 12    39 dcl  ios_$setsize		entry (
 12    40 			char(*)
 12    41 ,			fixed bin(21)
 12    42 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    43 				);
 12    44 
 12    45 dcl  ios_$seek                entry (
 12    46 			char(*)
 12    47 ,			char(*)
 12    48 ,			char(*)
 12    49 ,			fixed bin(21)
 12    50 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    51 				);
 12    52 
 12    53 dcl  ios_$tell		entry (
 12    54 			char(*)
 12    55 ,			char(*)
 12    56 ,			char(*)
 12    57 ,			fixed bin(21)
 12    58 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    59 				);
 12    60 
 12    61 dcl  ios_$write               entry (
 12    62 			char(*)
 12    63 ,			ptr
 12    64 ,			fixed bin(21)
 12    65 ,			fixed bin(21)
 12    66 ,			fixed bin(21)
 12    67 ,			1, 2 fixed bin(35) aligned, 2 bit(36) aligned
 12    68 				);
 12    69 
 12    70 dcl  ios_$write_ptr           entry (
 12    71 			ptr
 12    72 ,			fixed bin(21)
 12    73 ,			fixed bin(21)
 12    74 				);
 12    75 
 12    76 dcl 1 status			/* Return status code. */
 12    77 ,     2 code	fixed bin(35)aligned
 12    78 ,     2 word2	bit(36)aligned
 12    79 ;
 12    80 
 12    81 /*   END INCLUDE FILE gcos_dcl_ios_.incl.pl1 */
     1171 
     1172      end gcos_gein_pass1_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1946.2  gcos_gein_pass1_.pl1              >udd>sm>ds>w>ml>gcos_gein_pass1_.pl1
446          1    03/27/82  0524.8  gcos_canonicalizer.incl.pl1       >ldd>incl>gcos_canonicalizer.incl.pl1
1163         2    09/09/83  1814.3  gcos_control_tables_.incl.pl1     >ldd>incl>gcos_control_tables_.incl.pl1
1165         3    03/11/83  1304.3  query_info.incl.pl1               >ldd>incl>query_info.incl.pl1
1167         4    09/09/83  1814.4  gcos_ext_stat_.incl.pl1           >ldd>incl>gcos_ext_stat_.incl.pl1
4-100        5    03/27/82  0524.8  gcos_save_mc.incl.pl1             >ldd>incl>gcos_save_mc.incl.pl1
4-104        6    03/27/82  0524.8  gcos_fct_entry.incl.pl1           >ldd>incl>gcos_fct_entry.incl.pl1
4-108        7    03/27/82  0524.8  gcos_save_data_entry.incl.pl1     >ldd>incl>gcos_save_data_entry.incl.pl1
7-29         8    09/09/83  1814.4  gcos_flags.incl.pl1               >ldd>incl>gcos_flags.incl.pl1
4-110        9    03/27/82  0524.8  gcos_file_info_block_.incl.pl1    >ldd>incl>gcos_file_info_block_.incl.pl1
4-113       10    12/15/83  1200.4  mc.incl.pl1                       >ldd>incl>mc.incl.pl1
1169        11    03/27/82  0524.8  gcos_dbs_names.incl.pl1           >ldd>incl>gcos_dbs_names.incl.pl1
1171        12    03/27/82  0524.8  gcos_dcl_ios_.incl.pl1            >ldd>incl>gcos_dcl_ios_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LOWER_CASE                      000007 constant        char(26)                 initial packed unaligned dcl 1076 ref 266
SP                                     constant        char(1)                  initial packed unaligned dcl 1-173 ref 1-26
TAB                                    constant        char(1)                  initial packed unaligned dcl 1-174 ref 1-26 1-48
UPPER_CASE                      000000 constant        char(26)                 initial packed unaligned dcl 1091 ref 266
a_code                                 parameter       fixed bin(35,0)          dcl 993 set ref 379* 435 440*
act_flag                        001104 automatic       char(1)                  packed unaligned dcl 1041 set ref 262* 263* 265*
act_no                          001105 automatic       fixed bin(24,0)          dcl 1042 set ref 57* 207* 207 209 225
act_ptr                         000100 automatic       pointer                  dcl 985 set ref 217* 218* 218 221
act_table_entry                        based           structure                level 1 unaligned dcl 1153
addr                                                   builtin function         dcl 1043 ref 40 45 51 169 170 217 251 252 266 266
                                                                                  267 312 333 333 354 354 368 368 437 1-29 1-29 1-32
                                                                                  1-32 617 811 817 817 817 817 817 817 850 917 921
addrel                                                 builtin function         dcl 1044 ref 46 52 174 218 255 313 704 721 724 736
                                                                                  812 918 957 970
answer                          001106 automatic       varying char(4)          dcl 1045 set ref 354* 356
answer_iocbp              6     001462 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
ascii                    14            based           bit(1)                   level 2 dcl 1111 set ref 578 805* 916
ascii_backspace                 006641 constant        char(1)                  initial packed unaligned dcl 1046 ref 1-41 1-125
ascii_card                             based           char(80)                 dcl 986 set ref 130 134 141 148 149 177 179* 181 196
                                                                                  230 230 259* 271* 277* 289* 310* 457 462 470 483
                                                                                  520* 532 538 655* 671 673 765* 769 775*
ascii_card_ptr                  000102 automatic       pointer                  dcl 987 set ref 46* 49 130 134 141 148 149 177 179
                                                                                  181 196 230 230 259 271 277 289 310 457 462 470
                                                                                  483 520 532 538 636* 655 662* 671 673 765 766* 769
                                                                                  775
ascii_card_record_overlay              based           char(84)                 dcl 988 ref 265 265
ascii_len                       000104 automatic       fixed bin(24,0)          dcl 989 set ref 47* 233
ascii_newline                   006640 constant        char(1)                  initial packed unaligned dcl 1094 ref 49 1-21 602
                                                                                  629
ascii_ptr                       000106 automatic       pointer                  dcl 990 set ref 45* 46 48 233* 265 265
ascii_rcw                       000017 constant        bit(36)                  initial dcl 1047 ref 48
ascii_record                           based           structure                level 1 dcl 1131
ascii_report_card                      based           char(85)                 dcl 991 set ref 49*
ascii_sw                        001447 automatic       bit(1)                   initial dcl 1097 set ref 66* 72* 534* 535* 537 805
                                                                                  810 852 879 1097*
ascii_work_area                 000110 automatic       bit(36)                  array dcl 992 set ref 44* 45
backspace_count                 001514 automatic       fixed bin(24,0)          dcl 1-159 set ref 1-129* 1-138 1-139
baseno                                                 builtin function         dcl 1048 ref 560 560
bcd_blank                              constant        bit(6)                   initial packed unaligned dcl 1049 ref 270 755
bcd_card                               based           structure                level 1 dcl 1135
bcd_card_overlay                       based           char(60)                 dcl 994 set ref 171* 171 253* 253 336*
bcd_card_ptr                    000140 automatic       pointer                  dcl 995 set ref 174* 255* 258 270 313* 662* 736* 755
                                                                                  755 766* 812* 918*
bcd_dollar                             constant        bit(6)                   initial packed unaligned dcl 1050 ref 258 755
bcd_eof                                constant        bit(6)                   initial packed unaligned dcl 1051 ref 731
bcd_rcw                         000016 constant        bit(36)                  initial dcl 1055 ref 670
bcd_work_area                   000142 automatic       bit(36)                  array dcl 996 set ref 169 170 251 252 312 811 917
bcw                                    based           structure                level 1 dcl 1142
bit                                                    builtin function         dcl 1056 ref 958 967
bit_count                       001110 automatic       fixed bin(24,0)          dcl 1057 set ref 390* 415* 422 824* 830 869* 872 880
                                                                                  883
blank_count                     001515 automatic       fixed bin(24,0)          dcl 1-160 set ref 1-79* 1-83* 1-95* 1-108 1-109
                                                                                  1-110 1-111
brief                     0(15) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 195
                                                                                  1-154 651
bsn                                    based           bit(18)                  level 2 packed packed unaligned dcl 1142 set ref 54*
                                                                                  958* 958
buffer                  103            based           bit(36)                  array level 2 dcl 1111 set ref 850 921
buffer_ptr                      000162 automatic       pointer                  dcl 997 set ref 586* 601* 617 629 636* 648 655 666
                                                                                  681* 696* 710 721 850* 921*
ca                              001542 automatic       char(1)                  dcl 450 set ref 470* 472 477
canon_index               2            based           fixed bin(24,0)          level 2 dcl 1153 ref 221
canon_sw                        001450 automatic       bit(1)                   initial dcl 1097 set ref 66* 69* 71* 539* 540* 806
                                                                                  1097*
card_count                      001111 automatic       fixed bin(24,0)          initial dcl 1058 set ref 125* 125 264 327* 591 1058*
card_type                       001112 automatic       char(6)                  packed unaligned dcl 1059 set ref 130 135 140 154
                                                                                  165 189 225 225 230 307 493 673* 769*
char_addrel                            based           char(1)                  array packed unaligned dcl 999 set ref 333 617
char_buffer                            based           char                     packed unaligned dcl 1000 ref 629 648 655 666
character_count                 001516 automatic       fixed bin(24,0)          dcl 1-161 set ref 1-67* 1-71 1-91* 1-99 1-100 1-100
                                                                                  1-102 1-103 1-104 1-105 1-128* 1-129 1-134 1-135
chars_read                      000164 automatic       fixed bin(21,0)          dcl 998 set ref 586* 602* 604 604 604* 608 608* 611
                                                                                  617 623 629 629 636* 641 641* 641 643* 647 648 655
                                                                                  666
chase                           001114 automatic       fixed bin(1,0)           initial dcl 1060 set ref 390* 824* 1060*
cleanup                         001116 stack reference condition                dcl 1061 ref 75
code                            001500 automatic       fixed bin(35,0)          level 2 dcl 12-76 set ref 86 92 98 373 379 384* 390*
                                                                                  392 400 406 415* 427* 1-58* 1-149* 461* 497* 555*
                                                                                  588 624* 631* 646* 664* 682 687* 715* 779* 793*
                                                                                  817* 818 824* 825 831* 848 857 869* 874* 899 902*
                                                                                  903 931* 941 948*
column                                 based           bit(6)                   array level 2 packed packed unaligned dcl 1135 set
                                                                                  ref 258* 270* 755 755
com_err_                        000014 constant        entry                    external dcl 1002 ref 197
command_query_                  000012 constant        entry                    external dcl 1001 ref 354
continue                  0(33) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 350
                                                                                  1-152 649
copy_sw                         001455 automatic       bit(1)                   initial dcl 1097 set ref 130* 135 147* 1097*
cp_escape_control         1(02) 001462 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
current_file                           based           structure                level 1 dcl 1111 set ref 560 799 908
current_pointer                 000166 automatic       pointer                  initial dcl 1003 set ref 197 383 1003* 1-154 549*
                                                                                  550 552 552 555 555 560 560 572 572 578 579 586
                                                                                  595 601 602 602 608 608 611 611 614 614 617 636
                                                                                  651 679 680 681 683 685 696 697 699 699 701 701
                                                                                  704 704 710 712 712 716 721 722 724 724 724 733
                                                                                  733 740 740 743 747 747 802* 803 804 805 806 807
                                                                                  808 823 836 837 841 842 846 846 850 854 868 869
                                                                                  870 880 883 888 888 889 889 897 898 902 908 914*
                                                                                  916 921 921
current_segment                        based           char                     packed unaligned dcl 1004 ref 602
dbs_dollar                             defined         bit(1)                   packed unaligned dcl 11-17 ref 277
dbs_msf_test                           defined         bit(1)                   packed unaligned dcl 11-17 ref 397 827
dbs_nondollar                          defined         bit(1)                   packed unaligned dcl 11-17 ref 289 763 775
debug                     0(16) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 266
                                                                                  352
dirname                         001124 automatic       char(168)                packed unaligned dcl 1062 set ref 387* 390* 415* 817
                                                                                  817 823 824* 869*
divide                                                 builtin function         dcl 1063 ref 422 840 880 883
dollar_sw                       001451 automatic       bit(1)                   initial dcl 1097 set ref 108* 128 136* 289 490* 493
                                                                                  672* 755* 763 769 1097*
ename                           001176 automatic       char(32)                 packed unaligned dcl 1064 set ref 389* 390* 415* 817
                                                                                  817 823 824* 869*
endfc                           001206 automatic       char(2)                  packed unaligned dcl 1065 set ref 130 130 149* 150*
eob                      17            based           bit(1)                   level 2 dcl 1111 set ref 572 679 722* 733* 747* 808*
eof                      20            based           bit(1)                   level 2 in structure "current_file" dcl 1111
                                                                                  in procedure "gcos_gein_pass1_" set ref 572 595*
                                                                                  614* 683* 685 701* 733* 807*
eof                       0(18)        based           bit(6)                   level 2 in structure "rcw" packed packed unaligned
                                                                                  dcl 1146 in procedure "gcos_gein_pass1_" ref 731
eof_rcw                         000010 internal static bit(36)                  initial dcl 1066 set ref 368 368
eof_sw                          001452 automatic       bit(1)                   initial dcl 1097 set ref 108* 116 574* 732* 1097*
err_msg                         000170 automatic       varying char(200)        dcl 1005 set ref 87* 93* 99* 196* 197* 374* 384*
                                                                                  393* 401* 418* 429* 1-59* 1-151* 1-154* 462* 498*
                                                                                  589* 590* 590 625* 632* 648* 651* 666* 689* 717*
                                                                                  781* 795* 819* 832* 875* 904* 933* 942* 950*
err_num                         000253 automatic       fixed bin(24,0)          dcl 1006 set ref 329* 339* 339 342 345* 345 347 347
                                                                                  384* 428* 1-150* 1-154* 591* 647* 651* 665* 688*
                                                                                  716* 780* 794* 932* 949*
err_path                        000254 automatic       char(200)                packed unaligned dcl 1007 set ref 327* 333 342* 347
                                                                                  347 382* 383* 384*
etc_label                       001210 automatic       label variable           local dcl 1067 set ref 295 488*
etc_next_sw                     001456 automatic       bit(1)                   initial dcl 1097 set ref 295 454* 473* 479* 487
                                                                                  1097*
expand_path_                    000016 constant        entry                    external dcl 1008 ref 817
explanation_len          14     001462 automatic       fixed bin(21,0)          initial level 2 dcl 3-7 set ref 3-7*
explanation_ptr          12     001462 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
fct_entry                              based           structure                level 1 dcl 6-3
fib                                    based           structure                level 1 dcl 9-10
first_blank                     001517 automatic       fixed bin(24,0)          dcl 1-162 set ref 1-71* 1-73 1-79
fixed                                                  builtin function         dcl 1068 ref 710 724 738 780 958 958 967 967
flags                                  based           structure                level 1 dcl 8-8
flgs                            000114 external static structure                level 3 dcl 4-106
gcos                      0(12) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 66
gcos_control_tables_$activity_table
                                000054 external static fixed bin(17,0)          dcl 2-4 set ref 217
gcos_control_tables_$cardtable  000056 external static char(8)                  array packed unaligned dcl 2-5 ref 189
gcos_control_tables_$exc_offset 000060 external static fixed bin(17,0)          dcl 2-7 ref 202 218 262
gcos_control_tables_$nonact     000062 external static fixed bin(17,0)          dcl 2-9 ref 202 262
gcos_control_tables_$tablelen   000064 external static fixed bin(17,0)          dcl 2-10 ref 192
gcos_control_tables_$tabstops   000066 external static fixed bin(17,0)          dcl 2-11 set ref 1-29 1-32
gcos_control_tables_$totallen   000070 external static fixed bin(17,0)          dcl 2-12 ref 189 192
gcos_cv_ascii_gebcd_check_      000020 constant        entry                    external dcl 1009 ref 662
gcos_cv_gebcd_ascii_            000022 constant        entry                    external dcl 1010 ref 766
gcos_error_                     000024 constant        entry                    external dcl 1011 ref 209 358 384 744
gcos_et_$too_many_activs        000026 external static fixed bin(35,0)          dcl 1013 set ref 209*
gcos_ext_stat_$card_num         000072 external static picture(4)               packed unaligned dcl 4-18 set ref 264* 265*
gcos_ext_stat_$dbs              000074 external static bit(1)                   array packed unaligned dcl 4-19 ref 277 277 289 289
                                                                                  397 397 763 763 775 775 827 827
gcos_ext_stat_$er               000076 external static pointer                  dcl 4-25 set ref 267* 347*
gcos_ext_stat_$input_segment_path
                                000100 external static varying char(168)        dcl 4-32 ref 63 64
gcos_ext_stat_$job_id           000102 external static varying char(18)         dcl 4-35 ref 84 389 441
gcos_ext_stat_$max_activities   000104 external static fixed bin(24,0)          dcl 4-39 set ref 209 209*
gcos_ext_stat_$save_data        000114 external static structure                level 1 dcl 4-106
gcos_ext_stat_$save_dir         000106 external static varying char(168)        dcl 4-52 ref 84 387 441
gcos_ext_stat_$system_free_pointer
                                000110 external static pointer                  dcl 4-63 ref 560 560 799 908
gcos_ext_stat_$userid           000112 external static char(12)                 packed unaligned dcl 4-69 set ref 59*
gcos_interpret_file_string_     000030 constant        entry                    external dcl 1014 ref 520
gcos_len                        000336 automatic       fixed bin(24,0)          dcl 1015 set ref 286 314* 738* 740 758 760* 766 766
                                                                                  813* 919*
gcos_ptr                        000340 automatic       pointer                  dcl 1016 set ref 169 171 173* 174 236 251 253 254*
                                                                                  255 286* 312* 313 670 721* 724* 731 736 738 750
                                                                                  750 750 773 780 811* 812 917* 918
gcos_read_card_$read_init       000032 constant        entry                    external dcl 1017 ref 432
gcos_record                            based           structure                level 1 dcl 1138
gcos_write_$ascii_ptr           000034 constant        entry                    external dcl 1018 ref 267
gcos_write_$ptr                 000036 constant        entry                    external dcl 1019 ref 347
gtssflag                  1(05) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 750
hbound                                                 builtin function         dcl 1069 ref 1-73 1-79 550 792
hcs_$initiate_count             000040 constant        entry                    external dcl 1021 ref 415 869
hcs_$status_minf                000042 constant        entry                    external dcl 1022 ref 390 824
hcs_$terminate_noname           000044 constant        entry                    external dcl 1023 ref 555 902
i                               001214 automatic       fixed bin(24,0)          dcl 1070 set ref 141* 146 148* 149 177* 177* 179
                                                                                  181* 189* 189* 192 192 202 202 218 262 262 327*
                                                                                  329 333 336* 339 1-73* 1-73* 1-79 1-79 1-125*
                                                                                  1-125* 1-128 457* 458 458* 460 466* 466 470 483
                                                                                  530* 530 532 538 548* 549 550* 662* 663 665 839*
                                                                                  840 840* 840 841
in_password                     001460 automatic       bit(1)                   initial dcl 1097 set ref 167* 179 181* 1097*
index                                                  builtin function         dcl 1071 ref 141 148 1-41 1-48 457 505 509 532 538
                                                                                  602
init_len                  4            based           fixed bin(24,0)          level 2 dcl 1111 set ref 880* 883* 889
init_ptr                  2            based           pointer                  level 2 dcl 1111 set ref 555 555* 803* 869* 870 888
                                                                                  902*
initial_input_characters               parameter       fixed bin(21,0)          dcl 1-13 ref 1-2 1-18 1-21 1-26 1-26 1-26 1-26 1-41
                                                                                  1-48 1-59 1-100 1-125 1-125 1-150 1-151
initial_output_columns                 parameter       fixed bin(24,0)          dcl 1-14 ref 1-2 1-19 1-100 1-109
input_string                           based           char                     packed unaligned dcl 1-163 ref 1-21 1-26 1-26 1-26
                                                                                  1-26 1-41 1-48 1-59 1-100 1-125 1-151
input_string_ptr                       parameter       pointer                  dcl 1-15 ref 1-2 1-21 1-26 1-26 1-26 1-26 1-41 1-48
                                                                                  1-59 1-100 1-125 1-151
ioa_                            000046 constant        entry                    external dcl 1024 ref 230 277 289 1-154 651 759
ioa_$rs                         000050 constant        entry                    external dcl 1025 ref 265
ioa_$rsnnl                      000052 constant        entry                    external dcl 1026 ref 327 336
ioa_string                             based           char                     dcl 1072 set ref 266* 266 267*
ios_$attach                     000116 constant        entry                    external dcl 12-3 ref 85 399 846
ios_$detach                     000120 constant        entry                    external dcl 12-11 ref 372 552 564 898
ios_$read                       000122 constant        entry                    external dcl 12-25 ref 586 681
ios_$seek                       000126 constant        entry                    external dcl 12-45 ref 97
ios_$setsize                    000124 constant        entry                    external dcl 12-39 ref 91 405 854
ios_$write                      000130 constant        entry                    external dcl 12-61 ref 939
j                               001215 automatic       fixed bin(24,0)          dcl 1073 set ref 505* 506 509* 510 532* 534 538* 539
jd_size                 244     000114 external static fixed bin(24,0)          level 3 dcl 4-106 set ref 422*
job_deck                242     000114 external static pointer                  level 3 dcl 4-106 set ref 409* 415* 417
js_io_sw                        001457 automatic       bit(1)                   initial dcl 1097 set ref 82* 103* 370* 382 934* 943*
                                                                                  951* 1097*
js_path                         001216 automatic       char(168)                packed unaligned dcl 1074 set ref 84* 85* 382 399*
                                                                                  441*
last_block                      001674 automatic       bit(1)                   initial dcl 979 set ref 964 974* 979*
last_execute_act_no      25     000114 external static fixed bin(24,0)          level 3 dcl 4-106 set ref 57* 225*
length                    0(18)        based           bit(18)                  level 2 in structure "bcw" packed packed unaligned
                                                                                  dcl 1142 in procedure "gcos_gein_pass1_" set ref
                                                                                  55* 710 960* 967* 967
length                                                 builtin function         dcl 1075 in procedure "gcos_gein_pass1_" ref 64 1-26
                                                                                  524
length                                 based           bit(18)                  level 2 in structure "rcw" packed packed unaligned
                                                                                  dcl 1146 in procedure "gcos_gein_pass1_" ref 724
                                                                                  738
literal_sw                1(05) 001462 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
max                                                    builtin function         dcl 1077 ref 1-95
mc                                     based           structure                level 1 dcl 10-12
media_code                0(26)        based           bit(4)                   level 2 packed packed unaligned dcl 1146 ref 750 750
                                                                                  750 773 780
min                                                    builtin function         dcl 1078 ref 1-67 1-79 1-83 1-91 1-129 697 766 766
mod                                                    builtin function         dcl 1079 ref 264 842
more_backspaces                 001520 automatic       bit(1)                   dcl 1-164 set ref 1-20* 1-38 1-43* 1-53 1-119
more_tabs                       001521 automatic       bit(1)                   dcl 1-165 set ref 1-20* 1-46 1-50* 1-57 1-65 1-114
msf                      15            based           bit(1)                   level 2 dcl 1111 set ref 552 579 680 836* 868* 897
                                                                                  921
needs_canonicalization
                         16            based           bit(1)                   level 2 dcl 1111 set ref 636 806*
next_backspace                  001522 automatic       fixed bin(24,0)          dcl 1-166 set ref 1-41* 1-43 1-57
next_input_character            001523 automatic       fixed bin(24,0)          dcl 1-167 set ref 1-17* 1-41 1-48 1-100 1-103* 1-103
                                                                                  1-116* 1-116 1-125 1-128 1-135* 1-135
next_output_column              001524 automatic       fixed bin(24,0)          dcl 1-168 set ref 1-17* 1-71 1-100 1-105* 1-105
                                                                                  1-109 1-111* 1-111 1-129 1-139* 1-139
next_tab                        001525 automatic       fixed bin(24,0)          dcl 1-169 set ref 1-48* 1-50 1-57 1-67
no_canonicalize           0(17) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 69
nondollar_canon_index           001270 automatic       fixed bin(24,0)          dcl 1080 set ref 221* 1-32
null                                                   builtin function         dcl 1081 ref 409 417 1003 1032 3-7 3-7 3-7 550 555
                                                                                  803 870 909
output_card                            based           char                     packed unaligned dcl 1-170 set ref 1-100* 1-109*
output_card_ptr                        parameter       pointer                  dcl 1-16 ref 1-2 1-100 1-109
output_word_ptr                 000342 automatic       pointer                  dcl 1027 set ref 52* 957* 969 970* 970
overlay_ptr                     000344 automatic       pointer                  dcl 1028 set ref 170* 171 173 236* 252* 253 254 333*
                                                                                  336
padding                   1(07) 001462 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
path_type                       001543 automatic       fixed bin(24,0)          initial dcl 451 set ref 451* 474* 480* 504 506* 510*
                                                                                  512* 520
pathname                 21            based           char(200)                level 2 packed packed unaligned dcl 1111 set ref
                                                                                  197* 383 1-154* 651* 804* 823* 846*
prmfl_path                      001544 automatic       varying char(250)        initial dcl 452 set ref 452* 483* 483 498 505 509
                                                                                  520* 523 524
prompt_after_explanation
                          1(06) 001462 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
query_code                3     001462 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
query_info                      001462 automatic       structure                level 1 dcl 3-7 set ref 354 354
question_iocbp            4     001462 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
rcw                                    based           bit(36)                  level 2 in structure "ascii_record" dcl 1131
                                                                                  in procedure "gcos_gein_pass1_" set ref 48*
rcw                                    based           structure                level 1 dcl 1146 in procedure "gcos_gein_pass1_"
rcw                                    based           bit(36)                  level 2 in structure "gcos_record" dcl 1138
                                                                                  in procedure "gcos_gein_pass1_" set ref 670*
read_ptr                  6            based           pointer                  level 2 dcl 1111 set ref 601 602 617* 696 704* 704
                                                                                  888*
record_ptr               10            based           pointer                  level 2 dcl 1111 set ref 721* 724 724 724*
remaining_block_len      13            based           fixed bin(24,0)          level 2 dcl 1111 set ref 710* 712 712 716 740* 740
                                                                                  743 747
remaining_input_characters      001526 automatic       fixed bin(24,0)          dcl 1-171 set ref 1-18* 1-21 1-21* 1-21 1-41 1-48
                                                                                  1-91 1-95 1-102* 1-102 1-115* 1-115 1-134* 1-134
                                                                                  1-146
remaining_len            12            based           fixed bin(35,0)          level 2 dcl 1111 set ref 602 608 608 611* 611 614
                                                                                  697 699* 699 701 889*
remaining_output_columns        001527 automatic       fixed bin(24,0)          dcl 1-172 set ref 1-19* 1-37 1-67 1-79 1-83 1-91
                                                                                  1-95 1-104* 1-104 1-110* 1-110 1-138* 1-138
remaining_output_words          000346 automatic       fixed bin(24,0)          dcl 1029 set ref 53* 938 956* 971* 971
repeat_time              10     001462 automatic       fixed bin(71,0)          initial level 2 dcl 3-7 set ref 3-7*
restartsw                       001461 automatic       bit(1)                   initial dcl 1097 set ref 378 432* 439* 1097*
rtn_string                      001271 automatic       char(256)                dcl 1082 set ref 265* 266 266 267
rtn_string_len                  001371 automatic       fixed bin(24,0)          dcl 1083 set ref 265* 266 266 267 267
rtrim                                                  builtin function         dcl 1030 ref 823 823
save_data                       000114 external static structure                level 2 dcl 4-106
save_data_entry                        based           structure                level 1 dcl 7-5
save_machine_conditions                based           structure                level 1 packed packed unaligned dcl 5-6
select_card                     001453 automatic       bit(1)                   initial dcl 1097 set ref 108* 155* 286 1097*
select_path                     001373 automatic       char(168)                packed unaligned dcl 1085 set ref 63* 520* 523* 804
                                                                                  817 817
select_path_len                 001445 automatic       fixed bin(24,0)          dcl 1086 set ref 64* 520* 524* 817*
selected_card_count             001372 automatic       fixed bin(24,0)          initial dcl 1084 set ref 126* 126 332 336* 1084*
stack_level                     000376 automatic       fixed bin(24,0)          dcl 1033 set ref 62* 106 126 249 269 548 790* 790
                                                                                  792 794 799 802 839 842 842 909 910* 910 912 914
stacked_pointers                000350 automatic       pointer                  initial array dcl 1032 set ref 549 550 792 799* 802
                                                                                  909* 914 1032*
status                          001500 automatic       structure                level 1 unaligned dcl 12-76 set ref 85* 91* 97* 372*
                                                                                  399* 405* 552* 564* 586* 595 681* 683 846* 854*
                                                                                  898* 939*
status_code               2     001462 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
stream                                 based           char(8)                  level 2 packed packed unaligned dcl 1111 set ref
                                                                                  552* 586* 681* 837* 841* 842* 846* 854* 898*
substr                                                 builtin function         dcl 1087 set ref 49* 130 134 141 148 149 177 179*
                                                                                  181 189 230 230 259* 265 265 271* 342 347 347 1-21
                                                                                  1-26 1-26 1-26 1-41 1-48 1-100* 1-100 1-109* 1-125
                                                                                  457 470 483 532 538 595 629 671 673 683 769 841*
                                                                                  841 842* 842
suppress_name_sw          1(01) 001462 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
suppress_spacing          1(04) 001462 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
switches                  1     001462 automatic       structure                level 2 dcl 3-7
system_free_area                       based           area(1024)               dcl 1034 ref 560 799 908
tab                       1            based           structure                array level 2 dcl 1158 set ref 1-29 1-32
tab_ptr                         001530 automatic       pointer                  dcl 1-176 set ref 1-29* 1-32* 1-73 1-73 1-79 1-79
tabstop                                based           fixed bin(24,0)          array dcl 1-175 ref 1-73 1-73 1-79 1-79
tabstops                               based           structure                level 1 dcl 1158
translate                                              builtin function         dcl 1089 ref 266
truncate                  0(32) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 ref 1-146
                                                                                  643
type                            001446 automatic       fixed bin(2,0)           dcl 1090 set ref 390* 397 411 428 824* 827 865
unimp_sw                        001454 automatic       bit(1)                   initial dcl 1097 set ref 194* 350 1097*
unspec                                                 builtin function         dcl 1035 set ref 342* 595 683
userid                    0(21) 000114 external static bit(1)                   level 4 packed packed unaligned dcl 4-106 set ref
                                                                                  166*
word_count                             parameter       fixed bin(24,0)          dcl 928 ref 926 930 932 938 967 969 969 969 970 971
                                                                                  973
word_ptr                               parameter       pointer                  dcl 929 ref 926 969
words                                  based           bit(36)                  array packed unaligned dcl 980 set ref 969* 969
words_read                      000377 automatic       fixed bin(21,0)          dcl 1036 set ref 681* 685 688 697* 699 704
words_written                   000400 automatic       fixed bin(21,0)          dcl 1037 set ref 939* 947 949
write_buffer                    000401 automatic       bit(36)                  array dcl 1038 set ref 40 51 437
write_buffer_ptr                001102 automatic       pointer                  dcl 1039 set ref 40* 51* 52 54 55 437* 939* 957 958
                                                                                  958 960 967 967
yes_or_no_sw              1     001462 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 353* 3-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SP                                     internal static char(1)                  initial packed unaligned dcl 1031
TAB                                    internal static char(1)                  initial packed unaligned dcl 1088
VALID_FMS_CHARS                        internal static char(38)                 initial packed unaligned dcl 1092
abx                                    internal static fixed bin(17,0)          initial dcl 10-42
apx                                    internal static fixed bin(17,0)          initial dcl 10-42
bbx                                    internal static fixed bin(17,0)          initial dcl 10-42
bcd_newline_record                     internal static bit(72)                  initial dcl 1052
bcd_newline_record_overlay             based           char(8)                  dcl 1053
bcd_number_sign                        internal static bit(6)                   initial packed unaligned dcl 1054
bpx                                    internal static fixed bin(17,0)          initial dcl 10-42
dbs_attach_file                        defined         bit(1)                   packed unaligned dcl 11-17
dbs_filecode                           defined         bit(1)                   packed unaligned dcl 11-17
dbs_mme_call                           defined         bit(1)                   packed unaligned dcl 11-17
dbs_mme_inos_stop                      defined         bit(1)                   packed unaligned dcl 11-17
dbs_mme_inos_trace                     defined         bit(1)                   packed unaligned dcl 11-17
dbs_names                              internal static varying char(14)         initial array dcl 11-3
dbs_open_file                          defined         bit(1)                   packed unaligned dcl 11-17
dbs_stop_mme                           defined         bit(1)                   packed unaligned dcl 11-17
dbs_trace_mme                          defined         bit(1)                   packed unaligned dcl 11-17
fibptr                                 automatic       pointer                  dcl 9-84
gcos_control_tables_$                  external static fixed bin(17,0)          dcl 2-3
gcos_control_tables_$comp_offset       external static fixed bin(17,0)          dcl 2-6
gcos_control_tables_$filecard_count    external static fixed bin(17,0)          dcl 2-8
gcos_et_$cc_bad_field                  external static fixed bin(35,0)          dcl 1012
gcos_ext_stat_$abort_reason            external static varying char(128)        dcl 4-13
gcos_ext_stat_$abort_return            external static label variable           dcl 4-14
gcos_ext_stat_$activity_card_num       external static picture(4)               packed unaligned dcl 4-15
gcos_ext_stat_$activity_name           external static char(8)                  packed unaligned dcl 4-16
gcos_ext_stat_$activity_start_time     external static fixed bin(71,0)          dcl 4-17
gcos_ext_stat_$courtesy_call_control   external static structure                level 1 dcl 4-92
gcos_ext_stat_$default_nondollar       external static char(2)                  packed unaligned dcl 4-20
gcos_ext_stat_$dir_rings               external static fixed bin(3,0)           array dcl 4-21
gcos_ext_stat_$dpno                    external static varying char(100)        dcl 4-22
gcos_ext_stat_$dpo                     external static varying char(100)        dcl 4-23
gcos_ext_stat_$endfc                   external static char(2)                  packed unaligned dcl 4-24
gcos_ext_stat_$etc_filecode            external static char(2)                  packed unaligned dcl 4-26
gcos_ext_stat_$fct                     external static structure                level 1 dcl 4-102
gcos_ext_stat_$gcos_gtss               external static structure                level 1 unaligned dcl 4-115
gcos_ext_stat_$gcos_slave_area_seg     external static pointer                  dcl 4-27
gcos_ext_stat_$gf                      external static fixed bin(24,0)          dcl 4-28
gcos_ext_stat_$incode                  external static fixed bin(24,0)          dcl 4-29
gcos_ext_stat_$increment_hold          external static fixed bin(24,0)          dcl 4-30
gcos_ext_stat_$initial_cpu_time        external static fixed bin(71,0)          dcl 4-31
gcos_ext_stat_$jcl_warnings            external static fixed bin(24,0)          dcl 4-33
gcos_ext_stat_$job_cpu_time            external static fixed bin(71,0)          dcl 4-34
gcos_ext_stat_$job_real_time           external static fixed bin(71,0)          dcl 4-36
gcos_ext_stat_$last_mme                external static fixed bin(24,0)          dcl 4-37
gcos_ext_stat_$ldrss                   external static fixed bin(24,0)          dcl 4-38
gcos_ext_stat_$max_mem                 external static fixed bin(19,0)          dcl 4-40
gcos_ext_stat_$mc                      external static structure                level 1 unaligned dcl 4-112
gcos_ext_stat_$mme_rtrn                external static label variable           dcl 4-41
gcos_ext_stat_$nondollar               external static char(2)                  packed unaligned dcl 4-42
gcos_ext_stat_$nongcos                 external static char(2)                  packed unaligned dcl 4-43
gcos_ext_stat_$normal_return           external static label variable           dcl 4-44
gcos_ext_stat_$patchfile_ptr           external static pointer                  dcl 4-45
gcos_ext_stat_$pathname_prefix         external static varying char(168)        dcl 4-46
gcos_ext_stat_$pch                     external static pointer                  dcl 4-47
gcos_ext_stat_$pdir                    external static varying char(168)        dcl 4-48
gcos_ext_stat_$prt                     external static pointer                  dcl 4-49
gcos_ext_stat_$rs                      external static pointer                  dcl 4-50
gcos_ext_stat_$saveseg_ptr             external static pointer                  dcl 4-51
gcos_ext_stat_$seg_rings               external static fixed bin(3,0)           array dcl 4-53
gcos_ext_stat_$sig_ptr                 external static pointer                  dcl 4-54
gcos_ext_stat_$skip_umc                external static bit(1)                   packed unaligned dcl 4-55
gcos_ext_stat_$snumb                   external static bit(30)                  dcl 4-56
gcos_ext_stat_$sought_label            external static char(8)                  packed unaligned dcl 4-57
gcos_ext_stat_$statistics              external static fixed bin(24,0)          array dcl 4-58
gcos_ext_stat_$stop_code               external static fixed bin(24,0)          dcl 4-59
gcos_ext_stat_$storage_limit           external static fixed bin(19,0)          dcl 4-60
gcos_ext_stat_$sysout_limit            external static fixed bin(35,0)          dcl 4-61
gcos_ext_stat_$sysout_lines            external static fixed bin(35,0)          dcl 4-62
gcos_ext_stat_$tape_buffer_size        external static fixed bin(35,0)          dcl 4-64
gcos_ext_stat_$temp_dir                external static varying char(168)        dcl 4-65
gcos_ext_stat_$temp_seg_ptr            external static pointer                  dcl 4-66
gcos_ext_stat_$termination_code        external static bit(18)                  packed unaligned dcl 4-67
gcos_ext_stat_$time_limit              external static fixed bin(71,0)          dcl 4-68
gcos_ext_stat_$validation_level        external static fixed bin(3,0)           dcl 4-70
gcos_write_$record_ptr          000000 constant        entry                    external dcl 1020
ios_$order                      000000 constant        entry                    external dcl 12-18
ios_$read_ptr                   000000 constant        entry                    external dcl 12-34
ios_$tell                       000000 constant        entry                    external dcl 12-53
ios_$write_ptr                  000000 constant        entry                    external dcl 12-70
lbx                                    internal static fixed bin(17,0)          initial dcl 10-42
linked_file                            internal static bit(1)                   initial packed unaligned dcl 9-87
lpx                                    internal static fixed bin(17,0)          initial dcl 10-42
mcp                                    automatic       pointer                  dcl 10-10
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 3-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 3-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 3-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 3-36
random_file                            internal static bit(1)                   initial packed unaligned dcl 9-88
read_file                              internal static bit(1)                   initial packed unaligned dcl 9-89
sbx                                    internal static fixed bin(17,0)          initial dcl 10-42
scu                                    based           structure                level 1 dcl 10-56
scup                                   automatic       pointer                  dcl 10-54
scux                                   based           structure                level 1 dcl 10-207
spx                                    internal static fixed bin(17,0)          initial dcl 10-42
write_file                             internal static bit(1)                   initial packed unaligned dcl 9-90

NAMES DECLARED BY EXPLICIT CONTEXT.
attach_r_err                    003020 constant        label                    dcl 401 ref 848
canonicalizer                   003253 constant        entry                    internal dcl 1-2 ref 636
detach_err                      002601 constant        label                    dcl 374 ref 899
end_process_dollar_card         002233 constant        label                    dcl 280 ref 137
file_error                      002606 constant        label                    dcl 378 ref 88 94 100 394 402 419 430 1-60 1-152 463
                                                                                  499 592 649 667 690 718 782 796 820 833 876 905
                                                                                  935 944 952
find_next_tab                   003362 constant        label                    dcl 1-46
gcos_gein_pass1_                001020 constant        entry                    external dcl 6
get_bcd                         004705 constant        entry                    internal dcl 660 ref 317
initiate_err                    003135 constant        label                    dcl 418 ref 870
interpret_select_card           003726 constant        entry                    internal dcl 448 ref 157
job_stream_restart              003172 constant        entry                    external dcl 435
job_stream_write                002021 constant        label                    dcl 233 ref 186
pass1_cleanup                   004242 constant        entry                    internal dcl 546 ref 75
pick_up_pathname                003731 constant        label                    dcl 454 set ref 493
print_before_etc                002026 constant        label                    dcl 236 ref 489
process_card                    001410 constant        label                    dcl 122 ref 320
process_select_card             001523 constant        label                    dcl 155 ref 134
read_current_file               004402 constant        entry                    internal dcl 568 ref 110 492
read_err                        004457 constant        label                    dcl 589 set ref 682
restart_join                    002654 constant        label                    dcl 387 ref 442
select_etc                      004035 constant        label                    dcl 490 ref 488
selected                        003332 constant        label                    dcl 1-33 ref 1-30
setsize_err                     001314 constant        label                    dcl 93 ref 406 857
show_where                      004464 constant        label                    dcl 590 ref 626 633
stack_selected_file             005366 constant        entry                    internal dcl 788 ref 77 162
status_minf_err                 002740 constant        label                    dcl 393 ref 825
type_error                      003147 constant        label                    dcl 427 ref 865
unimp_continue                  002535 constant        label                    dcl 361 ref 356
unstack_current_file            006055 constant        entry                    internal dcl 895 ref 116
write_block                     006207 constant        label                    dcl 939 ref 975
write_job_stream                006165 constant        entry                    internal dcl 926 ref 233 286 368

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7330        7462    6647        7340
Length     10214    6647       132         515     460           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gcos_gein_pass1_                   1270 external procedure  is an external procedure.  
on unit on line 75                  108 on unit               
canonicalizer                           internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  
interpret_select_card                   internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  
pass1_cleanup                           internal procedure  shares stack frame of on unit on line 75.  
read_current_file                       internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  
stack_selected_file                     internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  
unstack_current_file                    internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  
write_job_stream                        internal procedure  shares stack frame of external procedure gcos_gein_pass1_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 eof_rcw                     gcos_gein_pass1_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
gcos_gein_pass1_         000100 act_ptr                     gcos_gein_pass1_
                         000102 ascii_card_ptr              gcos_gein_pass1_
                         000104 ascii_len                   gcos_gein_pass1_
                         000106 ascii_ptr                   gcos_gein_pass1_
                         000110 ascii_work_area             gcos_gein_pass1_
                         000140 bcd_card_ptr                gcos_gein_pass1_
                         000142 bcd_work_area               gcos_gein_pass1_
                         000162 buffer_ptr                  gcos_gein_pass1_
                         000164 chars_read                  gcos_gein_pass1_
                         000166 current_pointer             gcos_gein_pass1_
                         000170 err_msg                     gcos_gein_pass1_
                         000253 err_num                     gcos_gein_pass1_
                         000254 err_path                    gcos_gein_pass1_
                         000336 gcos_len                    gcos_gein_pass1_
                         000340 gcos_ptr                    gcos_gein_pass1_
                         000342 output_word_ptr             gcos_gein_pass1_
                         000344 overlay_ptr                 gcos_gein_pass1_
                         000346 remaining_output_words      gcos_gein_pass1_
                         000350 stacked_pointers            gcos_gein_pass1_
                         000376 stack_level                 gcos_gein_pass1_
                         000377 words_read                  gcos_gein_pass1_
                         000400 words_written               gcos_gein_pass1_
                         000401 write_buffer                gcos_gein_pass1_
                         001102 write_buffer_ptr            gcos_gein_pass1_
                         001104 act_flag                    gcos_gein_pass1_
                         001105 act_no                      gcos_gein_pass1_
                         001106 answer                      gcos_gein_pass1_
                         001110 bit_count                   gcos_gein_pass1_
                         001111 card_count                  gcos_gein_pass1_
                         001112 card_type                   gcos_gein_pass1_
                         001114 chase                       gcos_gein_pass1_
                         001124 dirname                     gcos_gein_pass1_
                         001176 ename                       gcos_gein_pass1_
                         001206 endfc                       gcos_gein_pass1_
                         001210 etc_label                   gcos_gein_pass1_
                         001214 i                           gcos_gein_pass1_
                         001215 j                           gcos_gein_pass1_
                         001216 js_path                     gcos_gein_pass1_
                         001270 nondollar_canon_index       gcos_gein_pass1_
                         001271 rtn_string                  gcos_gein_pass1_
                         001371 rtn_string_len              gcos_gein_pass1_
                         001372 selected_card_count         gcos_gein_pass1_
                         001373 select_path                 gcos_gein_pass1_
                         001445 select_path_len             gcos_gein_pass1_
                         001446 type                        gcos_gein_pass1_
                         001447 ascii_sw                    gcos_gein_pass1_
                         001450 canon_sw                    gcos_gein_pass1_
                         001451 dollar_sw                   gcos_gein_pass1_
                         001452 eof_sw                      gcos_gein_pass1_
                         001453 select_card                 gcos_gein_pass1_
                         001454 unimp_sw                    gcos_gein_pass1_
                         001455 copy_sw                     gcos_gein_pass1_
                         001456 etc_next_sw                 gcos_gein_pass1_
                         001457 js_io_sw                    gcos_gein_pass1_
                         001460 in_password                 gcos_gein_pass1_
                         001461 restartsw                   gcos_gein_pass1_
                         001462 query_info                  gcos_gein_pass1_
                         001500 status                      gcos_gein_pass1_
                         001514 backspace_count             canonicalizer
                         001515 blank_count                 canonicalizer
                         001516 character_count             canonicalizer
                         001517 first_blank                 canonicalizer
                         001520 more_backspaces             canonicalizer
                         001521 more_tabs                   canonicalizer
                         001522 next_backspace              canonicalizer
                         001523 next_input_character        canonicalizer
                         001524 next_output_column          canonicalizer
                         001525 next_tab                    canonicalizer
                         001526 remaining_input_characters  canonicalizer
                         001527 remaining_output_columns    canonicalizer
                         001530 tab_ptr                     canonicalizer
                         001542 ca                          interpret_select_card
                         001543 path_type                   interpret_select_card
                         001544 prmfl_path                  interpret_select_card
                         001674 last_block                  write_job_stream

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     alloc_temp          cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
mdfx1               enable_op           shorten_stack       ext_entry           int_entry           set_chars_eis
index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                expand_path_                  gcos_cv_ascii_gebcd_check_
gcos_cv_gebcd_ascii_          gcos_error_                   gcos_interpret_file_string_   gcos_read_card_$read_init
gcos_write_$ascii_ptr         gcos_write_$ptr               hcs_$initiate_count           hcs_$status_minf
hcs_$terminate_noname         ioa_                          ioa_$rs                       ioa_$rsnnl
ios_$attach                   ios_$detach                   ios_$read                     ios_$seek
ios_$setsize                  ios_$write

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
gcos_control_tables_$activity_table                         gcos_control_tables_$cardtable
gcos_control_tables_$exc_offset                             gcos_control_tables_$nonact   gcos_control_tables_$tablelen
gcos_control_tables_$tabstops gcos_control_tables_$totallen gcos_et_$too_many_activs      gcos_ext_stat_$card_num
gcos_ext_stat_$dbs            gcos_ext_stat_$er             gcos_ext_stat_$input_segment_path
gcos_ext_stat_$job_id         gcos_ext_stat_$max_activities gcos_ext_stat_$save_data      gcos_ext_stat_$save_dir
gcos_ext_stat_$system_free_pointer                          gcos_ext_stat_$userid




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   1003 000726      1032 000730      1058 000746      1060 000747      1084 000751      1097 000752    3    7 000765
      6 001017        40 001026        44 001030        45 001041        46 001043        47 001046        48 001050
     49 001052        51 001054        52 001056        53 001061        54 001063        55 001065        57 001067
     59 001073        62 001077        63 001100        64 001105        66 001107        69 001115        71 001122
     72 001124        75 001126        77 001144        82 001145        84 001147        85 001212        86 001253
     87 001255        88 001262        91 001263        92 001312        93 001314        94 001321        97 001322
     98 001364        99 001366       100 001373       103 001374       106 001375       108 001400       110 001403
    116 001404       125 001410       126 001411       128 001415       130 001417       134 001437       135 001444
    136 001453       137 001454       140 001455       141 001463       146 001474       147 001475       148 001477
    149 001507       150 001516       154 001520       155 001523       157 001525       162 001526       163 001527
    165 001530       166 001532       167 001535       169 001536       170 001544       171 001546       173 001552
    174 001553       177 001556       179 001570       181 001576       184 001604       186 001606       189 001607
    191 001627       192 001631       194 001637       195 001641       196 001644       197 001661       202 001712
    207 001720       209 001721       217 001747       218 001752       221 001757       225 001761       230 001771
    233 002021       236 002026       249 002030       251 002033       252 002041       253 002043       254 002046
    255 002047       258 002052       259 002055       262 002060       263 002071       264 002073       265 002107
    266 002150       267 002161       269 002206       270 002211       271 002214       277 002217       280 002233
    286 002234       289 002243       295 002261       302 002264       307 002265       310 002270       312 002274
    313 002276       314 002301       317 002303       320 002304       327 002305       329 002334       332 002337
    333 002341       336 002346       339 002375       342 002377       345 002404       347 002406       350 002440
    352 002447       353 002452       354 002454       356 002507       358 002514       361 002535       368 002536
    370 002545       372 002547       373 002577       374 002601       378 002606       379 002611       380 002614
    382 002615       383 002623       384 002627       387 002654       389 002662       390 002701       392 002736
    393 002740       394 002745       397 002746       399 002755       400 003016       401 003020       402 003025
    405 003026       406 003055       409 003057       410 003063       411 003064       415 003066       417 003127
    418 003135       419 003142       422 003143       425 003146       427 003147       428 003150       429 003152
    430 003157       432 003160       433 003166       435 003167       437 003200       439 003202       440 003204
    441 003206       442 003251    1    2 003253    1   17 003255    1   18 003260    1   19 003262    1   20 003264
 1   21 003267    1   26 003300    1   29 003317    1   30 003323    1   32 003324    1   33 003332    1   37 003333
 1   38 003336    1   41 003340    1   43 003356    1   46 003360    1   48 003362    1   50 003400    1   53 003402
 1   57 003404    1   58 003412    1   59 003413    1   60 003437    1   65 003441    1   67 003443    1   71 003451
 1   73 003453    1   77 003465    1   79 003467    1   83 003502    1   85 003507    1   91 003510    1   95 003515
 1   99 003523    1  100 003525    1  102 003543    1  103 003545    1  104 003547    1  105 003551    1  108 003553
 1  109 003555    1  110 003564    1  111 003566    1  114 003570    1  115 003572    1  116 003574    1  119 003575
 1  125 003577    1  127 003616    1  128 003620    1  129 003622    1  134 003630    1  135 003632    1  138 003634
 1  139 003636    1  142 003640    1  146 003641    1  149 003647    1  150 003650    1  151 003653    1  152 003675
 1  154 003701    1  157 003725       448 003726       451 003727       452 003730       454 003731       457 003732
    458 003744       460 003747       461 003751       462 003752       463 003766       466 003770       470 003772
    472 003777       473 004002       474 004004       475 004006       477 004007       479 004011       480 004013
    483 004015       487 004027       488 004031       489 004034       490 004035       492 004036       493 004037
    497 004047       498 004050       499 004071       504 004073       505 004075       506 004107       509 004113
    510 004125       512 004131       520 004133       523 004163       524 004167       530 004171       532 004173
    534 004213       535 004217       537 004220       538 004222       539 004234       540 004240       543 004241
    546 004242       548 004243       549 004252       550 004255       552 004264       555 004313       560 004330
    563 004345       564 004351       565 004401       568 004402       572 004403       574 004410       575 004412
    578 004413       579 004415       586 004417       588 004455       589 004457       590 004464       591 004476
    592 004500       595 004501       596 004506       601 004507       602 004511       604 004524       608 004531
    611 004535       614 004543       617 004546       623 004552       624 004554       625 004555       626 004562
    629 004563       631 004572       632 004573       633 004600       636 004601       641 004610       643 004615
    646 004624       647 004625       648 004626       649 004647       651 004653       655 004676       660 004704
    662 004706       663 004725       664 004727       665 004730       666 004731       667 004753       670 004755
    671 004757       672 004767       673 004771       675 004776       679 004777       680 005001       681 005003
    682 005041       683 005043       685 005050       687 005054       688 005055       689 005056       690 005063
    692 005064       696 005065       697 005067       699 005074       701 005102       704 005105       710 005111
    712 005115       715 005121       716 005122       717 005123       718 005130       721 005131       722 005136
    723 005137       724 005140       731 005150       732 005155       733 005157       734 005161       736 005162
    738 005165       740 005170       743 005174       744 005175       747 005216       750 005223       755 005242
    758 005255       759 005260       760 005274       763 005276       765 005304       766 005310       769 005330
    771 005337       773 005340       775 005343       777 005353       779 005354       780 005355       781 005357
    782 005364       785 005365       788 005366       790 005367       792 005370       793 005373       794 005374
    795 005375       796 005402       799 005403       802 005415       803 005421       804 005423       805 005426
    806 005430       807 005432       808 005433       810 005435       811 005437       812 005441       813 005444
    817 005446       818 005473       819 005475       820 005502       823 005503       824 005556       825 005614
    827 005616       830 005625       831 005627       832 005630       833 005635       836 005636       837 005641
    839 005644       840 005646       841 005652       842 005655       846 005665       848 005722       850 005724
    852 005727       854 005731       857 005754       864 005756       865 005757       868 005761       869 005763
    870 006023       872 006030       874 006032       875 006033       876 006040       879 006041       880 006043
    881 006045       883 006046       888 006050       889 006052       892 006054       895 006055       897 006056
    898 006061       899 006105       900 006107       902 006110       903 006121       904 006123       905 006130
    908 006131       909 006133       910 006140       912 006142       914 006144       916 006147       917 006151
    918 006153       919 006156       921 006160       923 006164       926 006165       979 006167       930 006170
    931 006173       932 006174       933 006175       934 006202       935 006204       938 006205       939 006207
    941 006251       942 006253       943 006260       944 006262       947 006263       948 006266       949 006267
    950 006270       951 006275       952 006277       956 006300       957 006302       958 006305       960 006316
    964 006320       967 006323       969 006336       970 006355       971 006363       973 006365       974 006370
    975 006372       977 006373


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
