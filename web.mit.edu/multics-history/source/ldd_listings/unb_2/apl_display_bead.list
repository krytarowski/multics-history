	COMPILATION LISTING OF SEGMENT apl_display_bead
	Compiled by: Experimental PL/I Compiler of Friday, July 31, 1981 at 13:16
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 08/08/81  1947.5 mst Sat
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* Utility command for Version 2 APL.
       11*   Dumps APL beads in a useful form.
       12*   Written by Dave Moon.
       13*   Modified 790316 by PG to change name and make minor changes.
       14**/
       15 
       16 apl_display_bead:
       17 adb:
       18      procedure options (variable);
       19 
       20 /* parameter */
       21 
       22 dcl	(
       23 	p_bead_ptr	ptr,
       24 	p_brief_mode	bit (1) aligned
       25 	)		parameter;
       26 
       27 /* automatic */
       28 
       29 dcl	arg_len		fixed bin (21),
       30 	arg_ptr		ptr,
       31 	brief		bit (1) aligned,
       32 	code		fixed bin (35),
       33 	command		bit (1) aligned,
       34 	data_elements	fixed bin (21),
       35 	n_args		fixed bin,
       36 	p2b		ptr,
       37 	tp		ptr,
       38 	vcs		char (100),
       39 	n		fixed bin;
       40 
       41 /* based */
       42 
       43 dcl	arg_string	char (arg_len) based (arg_ptr);
       44 
       45 /* builtins */
       46 
       47 dcl	(fixed, null, rel, string, substr, unspec)
       48 			builtin;
       49 
       50 /* entries */
       51 
       52 dcl	cu_$arg_count	entry (fixed bin),
       53 	cu_$arg_ptr	entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       54 	cv_ptr_		entry (char (*), fixed bin (35)) returns (ptr),
       55 	cv_ptr_$terminate	entry (ptr),
       56 	(ioa_, com_err_)	entry options (variable);
       57 
       58 /* external static */
       59 
       60 dcl	(error_table_$badopt, error_table_$noarg)
       61 			fixed bin (35) external static;
       62 
       63 /* internal static */
       64 
       65 dcl	function_classes	(0:4) char (8) int static options (constant)
       66 			init ("normal", "locked", "ext zfn", "ext mfn", "ext dfn");
       67 
       68 /* include files */
       69 
  1     1 /* ====== BEGIN INCLUDE SEGMENT	apl_number_data.incl.pl1 ================================== */
  1     2 
  1     3 /*
  1     4*   This include file contains information about the machine representation of numbers.
  1     5*   In all programs numbers should simply be declared 'float'.
  1     6*   All default statements should be in this include file.
  1     7*
  1     8*   This is the binary version.  The manifest constant Binary should be used by programs
  1     9*   that need to know whether we are using binary or decimal.
  1    10* */
  1    11 
  1    12 /* format: style3,initlm0,idind30 */
  1    13 
  1    14 default (float & ^decimal & ^binary & ^precision & ^constant) float binary (63);
  1    15 
  1    16 declare	(
  1    17 	TheBiggestNumberWeveGot	float initial (0.1701411834604692317e+39),
  1    18 	TheSmallestNumberWeveGot	float initial (.1469367938527859385e-38),
  1    19 	Binary			bit (1) aligned initial ("1"b)
  1    20 	)			internal static options (constant);
  1    21 
  1    22 /* Number of characters in a number datum entry; used for copying float number arrays as strings.
  1    23*   (Obsolete! use array copies!) */
  1    24 
  1    25 declare	NumberSize		fixed binary precision (4) internal static initial (8);
  1    26 
  1    27 /* ------ END INCLUDE SEGMENT		apl_number_data.incl.pl1 ---------------------------------- */
       70 
  2     1 /* ====== BEGIN INCLUDE SEGMENT	apl_bead_format.incl.pl1 ================================== */
  2     2 
  2     3 declare 1 general_bead  		aligned based,	/* The Venerable Bead		*/
  2     4 	2 type 			unaligned,
  2     5 	  3 bead_type		unaligned,
  2     6 	    4 operator		bit (1),		/* ON if operator bead		*/
  2     7 	    4 symbol		bit (1),		/* ON if symbol bead		*/
  2     8 	    4 value		bit (1),		/* ON if value bead			*/
  2     9 	    4 function		bit (1),		/* ON if function bead		*/
  2    10 	    4 group		bit (1),		/* ON if group bead			*/
  2    11 	    4 label		bit (1),		/* ON if label bead			*/
  2    12 	    4 shared_variable	bit (1),		/* ON if shared variable bead 	*/
  2    13 	    4 lexed_function	bit (1),		/* ON if lexed function bead  	*/
  2    14 	  3 data_type		unaligned,
  2    15 	    4 list_value		bit (1),		/* ON if a list value bead		*/
  2    16 	    4 character_value	bit (1),		/* ON if a character value bead	*/
  2    17 	    4 numeric_value		bit (1),		/* ON if a numeric value bead		*/
  2    18 	    4 integral_value	bit (1),		/* ON if an integral value bead	*/
  2    19 	    4 zero_or_one_value	bit (1),		/* ON if a boolean value bead		*/
  2    20 	    4 complex_value		bit (1),		/* ON if a complex, numeric value bead   */
  2    21 	  3 unused_bits		bit (4) unaligned,	/* pad to 18 bits (for future use)	*/
  2    22 	2 size			bit (18) unaligned,	/* Number of words this bead occupies
  2    23*						   (used by bead storage manager)	*/
  2    24 	2 reference_count 		fixed binary (29);	/* Number of pointers which point
  2    25*						   to this bead (used by bead manager)	*/
  2    26 
  2    27 
  2    28 /* constant strings for initing type field in various beads */
  2    29 
  2    30 declare (
  2    31 	operator_type		init("100000000000000000"b),
  2    32 	symbol_type		init("010000000000000000"b),
  2    33     	value_type		init("001000000000000000"b),
  2    34 	function_type		init("000100000000000000"b),
  2    35 	group_type		init("000010000000000000"b),
  2    36 	label_type		init("001001000011000000"b),
  2    37 	shared_variable_type	init("001000100000000000"b),
  2    38 	lexed_function_type		init("000000010000000000"b),
  2    39 
  2    40 	list_value_type		init("000000001000000000"b),
  2    41 	character_value_type 	init("001000000100000000"b),
  2    42 	numeric_value_type		init("001000000010000000"b),
  2    43 	integral_value_type		init("001000000011000000"b),
  2    44 	zero_or_one_value_type	init("001000000011100000"b),
  2    45 	complex_value_type		init("001000000000010000"b),
  2    46 
  2    47 	not_integer_mask		init("111111111110011111"b),		/* to clear integral, zero_or_one bits */
  2    48 	not_zero_or_one_mask	init("111111111111011111"b)		/* to clear zero_or_one bit */
  2    49         ) bit(18) internal static;
  2    50 
  2    51 /* ------ END INCLUDE SEGMENT		apl_bead_format.incl.pl1 ---------------------------------- */
       71 
  3     1 /* ====== BEGIN INCLUDE SEGMENT	apl_value_bead.incl.pl1 =================================== */
  3     2 
  3     3 declare
  3     4 	number_of_dimensions fixed bin,
  3     5 
  3     6 	1 value_bead		aligned based,
  3     7 	2 header			aligned like general_bead,
  3     8 	2 total_data_elements	fixed binary (21),	/* length of ,[value] in APL		*/
  3     9 	2 rhorho			fixed binary,	/* number of dimensions of value	*/
  3    10 	2 data_pointer		pointer unaligned,	/* packed pointer to the data in value	*/
  3    11 	2 rho			fixed binary (21) dimension (number_of_dimensions refer (value_bead.rhorho));
  3    12 						/* dimensions of value (zero-origin)	*/
  3    13 
  3    14 
  3    15 declare 1 character_data_structure	aligned based,	/* alignment trick for PL/I compiler	*/
  3    16 	2 character_datum		character (1) unaligned dimension (0:data_elements - 1);
  3    17 						/* actual elements of character array	*/
  3    18 
  3    19 declare   character_string_overlay	character (data_elements) aligned based;
  3    20 						/* to overlay on above structure	 */
  3    21 
  3    22 
  3    23 declare   numeric_datum		float aligned dimension (0:data_elements - 1) based;
  3    24 						/* actual elements of numeric array	*/
  3    25 
  3    26 declare	complex_datum		complex float aligned dimension (0:data_elements -1) based;
  3    27 
  3    28 declare	MAX_VALUE_BEAD_SIZE		fixed bin (19) init (261120) int static options (constant);
  3    29 
  3    30 /* ------ END INCLUDE SEGMENT		apl_value_bead.incl.pl1 ----------------------------------- */
       72 
  4     1 /* ====== BEGIN INCLUDE SEGMENT	apl_symbol_bead.incl.pl1 ================================== */
  4     2 
  4     3 /* Explanation of fields:
  4     4*   symbol_bead.hash_link_pointer	points to next symbol in same hash bucket in the symbol table.
  4     5*   symbol_bead.meaning_pointer	points to current "value" of this name:
  4     6*				   =  null	  => unused (e.g. undefined variable)
  4     7*				   -> group bead      => group name
  4     8*				   -> value bead      => variable with a value
  4     9*				   -> function bead   => function name
  4    10*				   -> label bead      => localized label value
  4    11*				   -> shared var bead => shared variable	*/
  4    12 
  4    13 declare 1 symbol_bead 		aligned based,
  4    14 	2 header	 		aligned like general_bead,
  4    15 	2 hash_link_pointer		pointer unaligned,
  4    16 	2 meaning_pointer		pointer unaligned,
  4    17 	2 name_length 		fixed binary,
  4    18 	2 name			character (0 refer (symbol_bead.name_length)) unaligned;
  4    19 
  4    20 /* ------ END INCLUDE SEGMENT		apl_symbol_bead.incl.pl1 ---------------------------------- */
       73 
  5     1 /*	BEGIN INCLUDE FILE:		apl_group_bead.incl.pl1			*/
  5     2 
  5     3 /* 		Initial Version:	1973.06.18
  5     4*		Typed in by:	Richard S. Lamson					*/
  5     5 
  5     6 
  5     7 declare 1 group_bead		aligned based,	/* Group:  bead_type.group = "1"b	*/
  5     8 
  5     9 	2 header			aligned like general_bead,
  5    10 
  5    11 	2 number_of_members		fixed binary,
  5    12 
  5    13 	2 member			pointer unaligned dimension (0 refer (group_bead.number_of_members));
  5    14 						/* Pointer to the symbol bead for each
  5    15*						    member of the group		*/
  5    16 
  5    17 /*	END INCLUDE FILE		apl_group_bead.incl.pl1				*/
       74 
  6     1 /* ====== BEGIN INCLUDE SEGMENT	apl_operator_bead.incl.pl1 ================================ */
  6     2 
  6     3 declare
  6     4 	1 operator_bead		aligned based,
  6     5 
  6     6 	  2 type			unaligned like general_bead.type,
  6     7 
  6     8 	  2 bits_for_lex		unaligned,
  6     9 	    3 allow_brackets	bit(1),		/* operator may have dimension info in brackets */
  6    10 	    3 allow_product		bit(1),		/* operator may be used in inner and outer product */
  6    11 	    3 allow_reduction	bit(1),		/* operator may be used in reduction and scan */
  6    12 	    3 special_assignment	bit(1),		/* doesn't use standard assignment operator */
  6    13 	    3 ignores_assignment	bit(1),		/* assignment has no effect */
  6    14 	    3 allow_subscripted_assignment
  6    15 				bit(1),		/* system variable that can be subscripted assigned */
  6    16 	    3 pad			bit(12),
  6    17 
  6    18 	  2 bits_for_parse		unaligned,
  6    19 	    3 stop_trace_control	bit(1),		/* next lexeme is function being stopped/traced
  6    20*						   (op1 tells which) */
  6    21 	    3 quad		bit(1),		/* this is a quad type */
  6    22 	    3 system_variable	bit(1),		/* this is a system variable, not an op */
  6    23 	    3 dyadic		bit(1),		/* operator may be dyadic */
  6    24 	    3 monadic		bit(1),		/* operator may be monadic */
  6    25 	    3 function		bit(1),		/* operator is a user defined function */
  6    26 	    3 semantics_valid	bit(1),		/* if semantics has been set */
  6    27 	    3 has_list		bit(1),		/* semantics is a list */
  6    28 	    3 inner_product		bit(1),		/* op2 is valid */
  6    29 	    3 semantics_on_stack	bit(1),		/* semantics points to value stack */
  6    30 	    3 is_external_function	bit(1),		/* semantics points to function bead for ext function */
  6    31 	    3 pad			bit(7),
  6    32 	    3 op2			fixed bin(8) unaligned,	/* secondary operator code */
  6    33 	    3 op1			fixed bin(8) unaligned,	/* primary operator code */
  6    34 	  2 type_code		fixed bin;	/* for parse */
  6    35 
  6    36 /* ------ END INCLUDE SEGMENT		apl_operator_bead.incl.pl1 -------------------------------- */
       75 
  7     1 /* ====== BEGIN INCLUDE SEGMENT	apl_function_bead.incl.pl1 ================================ */
  7     2 
  7     3 /* This bead is used by apl to store the source code for user-defined functions */
  7     4 
  7     5 declare	1 function_bead		aligned based,
  7     6 
  7     7 	  2 header		aligned like general_bead,
  7     8 
  7     9 	  2 lexed_function_bead_pointer unaligned pointer, /* null if unlexed or has errors, else -> lexed code */
  7    10 	  2 class			fixed bin,	/* 0=normal, 1=locked, 2=external zfn, 3=mfn, 4=dfn */
  7    11 	  2 stop_control_pointer	unaligned ptr,	/* points to stop value bead, or null (no stop control) */
  7    12 	  2 trace_control_pointer	unaligned ptr,	/* points to trace value bead, or null (no trace control) */
  7    13 	  2 text_length		fixed bin(21),	/* length of function text */
  7    14 	  2 text			aligned char(data_elements refer (function_bead.text_length));
  7    15 						/* the user's code exactly as typed in */
  7    16 
  7    17 /* ------ END INCLUDE SEGMENT		apl_function_bead.incl.pl1 -------------------------------- */
       76 
  8     1 /* ====== BEGIN INCLUDE SEGMENT	apl_lexed_function_bead.incl.pl1 ========================== */
  8     2 
  8     3 /* this is the format of a user-defined function after it has been run
  8     4*   through apl_lex_, the first (left to right) parsing phase. */
  8     5 
  8     6 dcl 1 lexed_function_bead based aligned,
  8     7     2 header like general_bead,			/* type bits, etc. */
  8     8 
  8     9     2 name pointer unaligned,				/* -> symbol bead which names the function */
  8    10     2 bits_for_parse unaligned like operator_bead.bits_for_parse,	/* so can treat like system function */
  8    11     2 number_of_statements fixed bin,
  8    12     2 number_of_localized_symbols fixed bin,		/* including labels and parameter variables, return var */
  8    13 						/* even if they aren't there, thus >_ 3 */
  8    14     2 number_of_labels fixed bin,
  8    15     2 label_values_ptr pointer unaligned,			/* -> label_values below */
  8    16     2 statement_map_ptr pointer unaligned,			/* -> statement_map below */
  8    17     2 lexeme_array_ptr pointer unaligned,			/* -> lexeme_array below */
  8    18 
  8    19 	/* the first 3 localized symbols are always reserved for ReturnSymbol, LeftArgSymbol, RighArgSymbol respectively.
  8    20*	   If some of these symbols are not present (e.g. monadic or value-less function), null pointers are used.
  8    21*	   So beware!, there can be null ptrs in the localized_symbols array. */
  8    22 
  8    23     2 localized_symbols(  (0) refer (lexed_function_bead.number_of_localized_symbols)) pointer unaligned,
  8    24 						/* first localized vars from header line, then labels */
  8    25     2 label_values ( (0) refer (lexed_function_bead.number_of_labels)) pointer unaligned,
  8    26 						/* ptrs to label-value beads for labels */
  8    27     2 statement_map ( (0) refer (lexed_function_bead.number_of_statements)) fixed bin(18),
  8    28 						/* index in lexeme_array of rightmost lexeme of each stmt */
  8    29     2 lexeme_array ( (0) refer (lexed_function_bead.number_of_labels)	/* not really, but fake out compiler */ ) pointer unaligned;
  8    30 			/* the actual lexemes.  Length of array is
  8    31*							statement_map(number_of_statements)   */
  8    32 
  8    33 
  8    34 /* manifest constants for first 3 localized symbols */
  8    35 
  8    36 dcl (ReturnSymbol	init(1),
  8    37      LeftArgSymbol	init(2),
  8    38      RightArgSymbol	init(3)
  8    39     ) fixed binary static;
  8    40 
  8    41 
  8    42 	/* the last three parts of this bead are referenced separately, though ptrs earlier in the bead.
  8    43*	   Here are declarations for them as level-1 structures */
  8    44 
  8    45 dcl 1 lexed_function_label_values_structure based aligned,
  8    46      2 lexed_function_label_values ( 500 /* or so */ ) pointer unaligned,
  8    47 
  8    48     statement_count fixed bin,
  8    49     lexed_function_statement_map (statement_count) fixed bin(18) aligned based,
  8    50 
  8    51     1 lexed_function_lexemes_structure based aligned,
  8    52      2 lexed_function_lexeme_array ( 500 /* or so */ ) pointer unaligned;
  8    53 
  8    54 /* ------ END INCLUDE SEGMENT		apl_lexed_function_bead.incl.pl1 -------------------------- */
       77 
  9     1 /* ====== BEGIN INCLUDE SEGMENT	apl_list_bead.incl.pl1 ==================================== */
  9     2 
  9     3 declare	n_members fixed bin,
  9     4 
  9     5 	1 list_bead		aligned based,
  9     6 	  2 header		aligned like general_bead,
  9     7 	  2 number_of_members	fixed bin,
  9     8 	  2 members		dimension (n_members refer (list_bead.number_of_members)) aligned,
  9     9 	    3 member_ptr		unaligned pointer,
  9    10 	    3 bits		unaligned like operator_bead.bits_for_parse;
  9    11 
  9    12 /* ------ END INCLUDE SEGMENT		apl_list_bead.incl.pl1 ------------------------------------ */
       78 
 10     1 /* ====== BEGIN INCLUDE SEGMENT	apl_ws_info.incl.pl1 ====================================== */
 10     2 
 10     3 /* This structure contains all of the global data (or pointers to it) for the APL subsystem */
 10     4 
 10     5 /* automatic */
 10     6 
 10     7 declare	ws_info_ptr ptr initial (apl_static_$ws_info_ptr.static_ws_info_ptr);
 10     8 
 10     9 /* external static */
 10    10 
 10    11 declare	1 apl_static_$ws_info_ptr	external static aligned structure,
 10    12 	  2 static_ws_info_ptr	unaligned pointer;
 10    13 
 10    14 /* based */
 10    15 
 10    16 declare	1 ws_info			aligned based (ws_info_ptr),
 10    17 	  2 version_number		fixed bin,	/* version of this structure (3) */
 10    18 	  2 switches		unaligned,	/* mainly ws parameters */
 10    19 	    3 long_error_mode	bit,		/* if 1, long Multics format, else APL/360 format */
 10    20 	    3 debug_mode		bit,		/* if 1, system error causes escape to command level */
 10    21 	    3 canonicalize_mode	bit,		/* if 1, the editor canonicalizes user input */
 10    22 	    3 restrict_exec_command	bit,		/* if 1, the )EXEC command may not be used */
 10    23 	    3 restrict_debug_command	bit,		/* if 1, the )DEBUG command may not be used */
 10    24 	    3 restrict_external_functions
 10    25 				bit,		/* if 1, the )ZFN, )MFN, and )DFN commands may not be used */
 10    26 	    3 restrict_load		bit,		/* if 1, the )LOAD and )COPY commands may not be used */
 10    27 	    3 restrict_load_directory	bit,		/* if 1, no directory allowed in )LOAD or )COPY pathnames */
 10    28 	    3 restrict_save		bit,		/* if 1, the )SAVE command may not be used */
 10    29 	    3 restrict_save_directory	bit,		/* if 1, no directory allowed in )SAVE pathnames */
 10    30 	    3 off_hold		bit,		/* if 1, )OFF HOLD was typed, else just )OFF */
 10    31 	    3 transparent_to_signals	bit,		/* if 1, any conditions slip right past APL */
 10    32 	    3 meter_mode		bit,		/* if 1, metering may be done, else speed is all-important */
 10    33 	    3 restrict_msg_command	bit,		/* if 1, the )MSG command may not be used. */
 10    34 	    3 compatibility_check_mode
 10    35 				bit,		/* if 1, check for incompatible operators */
 10    36 	    3 no_quit_handler	bit,		/* if 1, do not trap QUITs. */
 10    37 						/* remaining 20 bits not presently used */
 10    38 
 10    39 	  2 values,				/* attributes of the workspace */
 10    40 	    3 digits		fixed bin,	/* number of digits of precision printed on output */
 10    41 	    3 width		fixed bin,	/* line length for formatted output */
 10    42 	    3 index_origin		fixed bin,	/* the index origin (0 or 1) */
 10    43 	    3 random_link		fixed bin(35),	/* seed for random number generator */
 10    44 	    3 fuzz		float,		/* comparison tolerance (relative fuzz) */
 10    45 	    3 float_index_origin	float,		/* the index origin	in floating point */
 10    46 	    3 number_of_symbols	fixed bin,	/* the number of symbol_beads currently in existence */
 10    47 	    3 maximum_value_stack_size
 10    48 				fixed bin (18),	/* maximum number of words in one segment of value stack */
 10    49 
 10    50 	  2 pointers,				/* pointers to various internal tables */
 10    51 	    3 symbol_table_ptr	unaligned pointer,	/* -> symbol_table (apl_symbol_table.incl.pl1) */
 10    52 	    3 current_parse_frame_ptr	unaligned pointer,	/* -> topmost parse frame */
 10    53 	    3 value_stack_ptr	unaligned pointer,	/* -> next free location on value stack */
 10    54 	    3 alloc_free_info_ptr	unaligned pointer,	/* -> apl_storage_mngr_ data (apl_storage_system_data.incl.pl1) */
 10    55 
 10    56 	  2 time_invoked		fixed bin(71),	/* clock time that APL was entered */
 10    57 	  2 integer_fuzz		float,		/* the absolute fuzz used in checking for integers */
 10    58 	  2 user_number		fixed bin(35),	/* number under which the user is signed on */
 10    59 	  2 latent_expression	unaligned pointer,	/* -> value_bead for QuadLX */
 10    60 	  2 lock			char(32),		/* the lock currently set on this workspace (password) */
 10    61 	  2 wsid			char(100),	/* the workspace identification: name, number name, or clear ws */
 10    62 	  2 last_error_code		fixed bin(35),	/* last code passed to apl_error_ */
 10    63 	  2 signoff_lock		character (32),
 10    64 
 10    65 	  2 interrupt_info		aligned,		/* bits used by apl_interpreter_ to tell when to abort */
 10    66 	    3 dont_interrupt_parse	bit,		/* if 1, don't do a dirty stop because the parser is running */
 10    67 	    3 dont_interrupt_operator	bit,		/* if 1, don't do a dirty stop because an operator is running */
 10    68 	    3 dont_interrupt_storage_manager		/* if 1, don't stop because apl_storage_mngr_ is */
 10    69 				bit,		/*       munging his tables */
 10    70 	    3 unused_interrupt_bit	bit,		/* not presently used */
 10    71 	    3 dont_interrupt_command	bit,
 10    72 	    3 can_be_interrupted	bit,		/* if 1, OK to do a clean stop (we are between lines, reading) */
 10    73 	    3 clean_interrupt_pending	bit,		/* interrupt occured, break cleanly (between lines) */
 10    74 	    3 dirty_interrupt_pending	bit,		/* interrupt occured, break as soon as not inhibited */
 10    75 
 10    76 	  2 user_name		char (32),	/* process group id of user */
 10    77 	  2 immediate_input_prompt	char (32) varying,	/* normal input */
 10    78 	  2 evaluated_input_prompt	char (32) varying,	/* quad input */
 10    79 	  2 character_input_prompt	char (32) varying,	/* quad-quote input */
 10    80 	  2 vcpu_time		aligned,
 10    81 	    3 total		fixed bin (71),
 10    82 	    3 setup		fixed bin (71),
 10    83 	    3 parse		fixed bin (71),
 10    84 	    3 lex			fixed bin (71),
 10    85 	    3 operator		fixed bin (71),
 10    86 	    3 storage_manager	fixed bin (71),
 10    87 	  2 output_info		aligned,		/* data pertaining to output buffer */
 10    88 	    3 output_buffer_ptr	unal ptr,		/* ptr to output buffer */
 10    89 	    3 output_buffer_len	fixed bin (21),	/* length (bytes) of output buffer */
 10    90 	    3 output_buffer_pos	fixed bin (21),	/* index of next byte to write in */
 10    91 	    3 output_buffer_ll	fixed bin (21),	/* print positions used up so far */
 10    92 	  2 tab_width		fixed bin (21);	/* number of columns a tabs moves cursor */
 10    93 
 10    94 declare	output_buffer char (ws_info.output_buffer_len) based (ws_info.output_buffer_ptr);
 10    95 
 10    96 /* internal static */
 10    97 
 10    98 declare	max_parse_stack_depth fixed bin int static init(64536);
 10    99 
 10   100 /* ------ END INCLUDE SEGMENT		apl_ws_info.incl.pl1 -------------------------------------- */
       79 
       80 
       81 /* program */
       82 
       83 	call cu_$arg_count (n_args);
       84 
       85 	if (n_args = 0) | (n_args > 2)
       86 	then do;
       87 		call com_err_ (error_table_$noarg, "apl_display_bead", "Usage: adb virtual_ptr {-brief|-bf}");
       88 		return;
       89 	     end;
       90 
       91 	brief = "0"b;
       92 
       93 	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
       94 
       95 	p2b = cv_ptr_ (arg_string, code);
       96 	if code ^= 0
       97 	then do;
       98 		call com_err_ (code, "apl_display_bead", "^a", arg_string);
       99 		return;
      100 	     end;
      101 
      102 	call cu_$arg_ptr (2, arg_ptr, arg_len, code);
      103 	if code = 0
      104 	then if arg_string = "-bf" | arg_string = "-brief"
      105 	     then brief = "1"b;
      106 	     else do;
      107 		     call com_err_ (error_table_$badopt, "apl_display_bead", "^a", arg_string);
      108 		     return;
      109 		end;
      110 
      111 	command = "1"b;
      112 	go to rejoinder;
      113 
      114 apl_display_bead_:
      115      entry (p_bead_ptr, p_brief_mode);
      116 
      117 	p2b = p_bead_ptr;
      118 	brief = p_brief_mode;
      119 	command = "0"b;
      120 
      121 rejoinder:
      122 	if p2b = null ()
      123 	then do;
      124 		call ioa_ ("pointer is null.");
      125 		return;
      126 	     end;
      127 
      128 	if p2b -> general_bead.type.symbol
      129 	then call ioa_ (
      130 		"symbol bead ^p, reference_count = ^d, size = ^dd = ^oo^/^-named ^a^/^-hash link ^p^/^-meaning ^p^/", p2b,
      131 		p2b -> general_bead.reference_count, fixed (p2b -> general_bead.size, 18),
      132 		fixed (p2b -> general_bead.size, 18), /*once in decimal, once in octal */ p2b -> symbol_bead.name,
      133 		p2b -> symbol_bead.hash_link_pointer, p2b -> symbol_bead.meaning_pointer);
      134 
      135 	else if p2b -> general_bead.type.group
      136 	then do;
      137 		call ioa_ ("group bead ^p, reference_count = ^d, size = ^dd = ^oo^/^-with ^d members:", p2b,
      138 		     p2b -> general_bead.reference_count, fixed (p2b -> general_bead.size, 18),
      139 		     fixed (p2b -> general_bead.size, 18), p2b -> group_bead.number_of_members);
      140 		do n = 1 to p2b -> group_bead.number_of_members;
      141 		     call ioa_ ("^2-^p", p2b -> group_bead.member (n));
      142 		end;
      143 		call ioa_ ("");
      144 	     end;
      145 
      146 	else if p2b -> general_bead.type.operator
      147 	then call ioa_ (
      148 		"operator bead ^p^/^-bits_for_lex = ^o, bits_for_parse = ^o, op = ^dd, op2 = ^dd, type_code = ^dd^/", p2b,
      149 		fixed (string (p2b -> operator_bead.bits_for_lex), 18),
      150 		fixed (substr (unspec (p2b -> operator_bead.bits_for_parse), 1, 18), 18),
      151 		fixed (p2b -> operator_bead.op1, 9), fixed (p2b -> operator_bead.op2, 9), p2b -> operator_bead.type_code);
      152 
      153 	else if p2b -> general_bead.type.value
      154 	then do;
      155 		if p2b -> general_bead.type.list_value
      156 		then vcs = "list";
      157 		else if p2b -> general_bead.type.character_value
      158 		then vcs = "character";
      159 		else if p2b -> general_bead.type.zero_or_one_value
      160 		then vcs = "0 or 1";
      161 		else if p2b -> general_bead.type.integral_value
      162 		then vcs = "integral";
      163 		else if p2b -> general_bead.type.numeric_value
      164 		then vcs = "numeric";
      165 		else vcs = "??? no value_type bits on ???";
      166 		if p2b -> general_bead.type.label
      167 		then vcs = "(label) " || vcs;
      168 
      169 		call ioa_
      170 		     (
      171 		     "value bead ^p, reference_count = ^d, size = ^dd = ^oo^/^-data_type = ^a^/^-total_data_elements = ^d, rhorho = ^d, data_pointer = ^p"
      172 		     , p2b, p2b -> general_bead.reference_count, fixed (p2b -> general_bead.size, 18),
      173 		     fixed (p2b -> general_bead.size, 18), vcs, p2b -> value_bead.total_data_elements,
      174 		     p2b -> value_bead.rhorho, p2b -> value_bead.data_pointer);
      175 		if p2b -> value_bead.rhorho ^= 0
      176 		then do;
      177 			call ioa_ ("^-rho vector:");
      178 			do n = 1 to p2b -> value_bead.rhorho;
      179 			     call ioa_ ("^2-^d", p2b -> value_bead.rho (n));
      180 			end;
      181 		     end;
      182 
      183 		call check_ptr_alignment (p2b, "value_bead ptr");
      184 
      185 		if p2b -> value_bead.numeric_value
      186 		then call check_ptr_alignment ((p2b -> value_bead.data_pointer), "value_bead.data_pointer");
      187 
      188 /* now display the actual values (ugh) */
      189 
      190 		if ^brief & (p2b -> value_bead.total_data_elements > 0)
      191 		then do;
      192 			call ioa_ ("^-values:");
      193 			data_elements = p2b -> value_bead.total_data_elements;
      194 
      195 			if p2b -> value_bead.numeric_value
      196 			then do n = 1 to data_elements;
      197 				call ioa_ ("^2-^e", p2b -> value_bead.data_pointer -> numeric_datum (n - 1));
      198 			     end;
      199 			else call ioa_ ("^a", p2b -> value_bead.data_pointer -> character_string_overlay);
      200 		     end;
      201 		call display_value_stack_ptr;
      202 	     end;
      203 	else if p2b -> general_bead.type.lexed_function
      204 	then do;
      205 		call ioa_ ("lexed function bead ^p, reference_count = ^d, size = ^dd = ^oo", p2b,
      206 		     p2b -> general_bead.reference_count, fixed (p2b -> general_bead.size, 18),
      207 		     fixed (p2b -> general_bead.size, 18));
      208 		call ioa_ ("^5xname = ^p, bits_for_parse = ^w", p2b -> lexed_function_bead.name,
      209 		     unspec (p2b -> lexed_function_bead.bits_for_parse));
      210 		call ioa_ ("^5xstmts = ^d, locals = ^d, labels = ^d", p2b -> lexed_function_bead.number_of_statements,
      211 		     p2b -> lexed_function_bead.number_of_localized_symbols, p2b -> lexed_function_bead.number_of_labels);
      212 		call ioa_ ("^5xlabel_values_ptr = ^p^/^5xstatement_map_ptr =^p^/^5xlexeme_array_ptr = ^p",
      213 		     p2b -> lexed_function_bead.label_values_ptr, p2b -> lexed_function_bead.statement_map_ptr,
      214 		     p2b -> lexed_function_bead.lexeme_array_ptr);
      215 		call ioa_ ("^5xlocalized symbols:");
      216 		do n = 1 to p2b -> lexed_function_bead.number_of_localized_symbols;
      217 		     tp = p2b -> lexed_function_bead.localized_symbols (n);
      218 		     if tp = null
      219 		     then call ioa_ ("^-null");
      220 		     else if tp -> general_bead.symbol
      221 			then call ioa_ ("^-^10p ^a", tp, tp -> symbol_bead.name);
      222 			else call ioa_ ("^-^10p op1 = ^d (system var)", tp, tp -> operator_bead.op1);
      223 		end;
      224 		call ioa_ ("^5xlabel values:");
      225 		do n = 1 to p2b -> lexed_function_bead.number_of_labels;
      226 		     call ioa_ ("^-^p", p2b -> lexed_function_bead.label_values (n));
      227 		end;
      228 		call ioa_ ("^5xstatement map:");
      229 		do n = 1 to p2b -> lexed_function_bead.number_of_statements;
      230 		     call ioa_ ("^-^d^-^d", n, p2b -> lexed_function_bead.statement_map (n));
      231 		end;
      232 		if ^brief
      233 		then do;
      234 			call ioa_ ("^5xlexeme array:");
      235 			do n = 1
      236 			     to p2b
      237 			     -> lexed_function_bead.statement_map (p2b -> lexed_function_bead.number_of_statements);
      238 			     call ioa_ ("^-^d^-^p", n, p2b -> lexed_function_bead.lexeme_array (n));
      239 			end;
      240 		     end;
      241 		call ioa_ ("end of lexed_function_bead ^p", p2b);
      242 	     end;
      243 	else if p2b -> general_bead.type.function
      244 	then call ioa_
      245 		(
      246 		"function bead ^p, reference_count = ^d, size = ^dd = ^oo,^/^-l-f-b-p = ^p, class = ^a, stop_control = ^p, trace_control = ^p, text_length = ^d, text:^/^a^/"
      247 		, p2b, p2b -> function_bead.reference_count, fixed (p2b -> function_bead.size, 18),
      248 		fixed (p2b -> function_bead.size, 18), p2b -> function_bead.lexed_function_bead_pointer,
      249 		function_classes (p2b -> function_bead.class), p2b -> function_bead.stop_control_pointer,
      250 		p2b -> function_bead.trace_control_pointer, p2b -> function_bead.text_length, p2b -> function_bead.text);
      251 
      252 	else if p2b -> general_bead.type.list_value
      253 	then do;
      254 		call ioa_ ("list bead ^p, reference_count = ^d, size = ^dd = ^oo^/^d members:^2/", p2b,
      255 		     p2b -> general_bead.reference_count, fixed (p2b -> general_bead.size, 18),
      256 		     fixed (p2b -> general_bead.size, 18), p2b -> list_bead.number_of_members);
      257 		do n = 1 to p2b -> list_bead.number_of_members;
      258 		     call ioa_ ("^-member #^d at ^p, bits = ^w", n, p2b -> list_bead.member_ptr (n),
      259 			p2b -> list_bead.bits (n));
      260 		     call apl_display_bead_ ((p2b -> list_bead.member_ptr (n)), (brief));
      261 		end;
      262 		call ioa_ ("^/end list bead ^p^2/", p2b);
      263 		call display_value_stack_ptr;
      264 	     end;
      265 
      266 	else call ioa_ ("some random bead ^p, type field = ^o, reference_count = ^d, size = ^dd = ^oo", p2b,
      267 		fixed (string (p2b -> general_bead.type), 18), p2b -> general_bead.reference_count,
      268 		fixed (p2b -> general_bead.size, 18), fixed (p2b -> general_bead.size, 18));
      269 
      270 	if command
      271 	then call cv_ptr_$terminate (p2b);
      272 
      273 	return;
      274 
      275 check_ptr_alignment:
      276      procedure (p_ptr, p_msg);
      277 
      278 dcl	(
      279 	p_ptr		ptr,
      280 	p_msg		char (*)
      281 	)		parameter;
      282 
      283 /* program */
      284 
      285 	if substr (rel (p_ptr), 18, 1)
      286 	then call ioa_ ("^a (^p) is not even-word aligned!", p_msg, p_ptr);
      287 
      288      end /* check_ptr_alignment */;
      289 
      290 display_value_stack_ptr:
      291      procedure;
      292 
      293 	if ws_info_ptr ^= null
      294 	then call ioa_ ("ws_info.value_stack_ptr = ^p", ws_info.value_stack_ptr);
      295 
      296      end;
      297 
      298      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/08/81  1558.8  apl_display_bead.pl1              >dumps>old_dumps>on>MIB-073181>apl_display_bead.pl1
70           1    08/08/81  1935.2  apl_number_data.incl.pl1          >dumps>old_dumps>on>MIB-073181>apl_number_data.incl.pl1
71           2    08/08/81  1934.9  apl_bead_format.incl.pl1          >dumps>old_dumps>on>MIB-073181>apl_bead_format.incl.pl1
72           3    08/08/81  1935.4  apl_value_bead.incl.pl1           >dumps>old_dumps>on>MIB-073181>apl_value_bead.incl.pl1
73           4    08/08/81  1935.4  apl_symbol_bead.incl.pl1          >dumps>old_dumps>on>MIB-073181>apl_symbol_bead.incl.pl1
74           5    08/08/81  1935.1  apl_group_bead.incl.pl1           >dumps>old_dumps>on>MIB-073181>apl_group_bead.incl.pl1
75           6    08/08/81  1935.2  apl_operator_bead.incl.pl1        >dumps>old_dumps>on>MIB-073181>apl_operator_bead.incl.pl1
76           7    08/08/81  1935.0  apl_function_bead.incl.pl1        >dumps>old_dumps>on>MIB-073181>apl_function_bead.incl.pl1
77           8    08/08/81  1935.1  apl_lexed_function_bead.incl.pl1  >dumps>old_dumps>on>MIB-073181>apl_lexed_function_bead.incl.pl1
78           9    08/08/81  1935.1  apl_list_bead.incl.pl1            >dumps>old_dumps>on>MIB-073181>apl_list_bead.incl.pl1
79          10    08/08/81  1935.4  apl_ws_info.incl.pl1              >dumps>old_dumps>on>MIB-073181>apl_ws_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
apl_static_$ws_info_ptr         000030 external static structure                level 1 dcl 10-11
arg_len                         000100 automatic       fixed bin(21,0)          dcl 29 set ref 93* 95 95 98 98 102* 103 103 107 107
arg_ptr                         000102 automatic       pointer                  dcl 29 set ref 93* 95 98 102* 103 103 107
arg_string                             based           char                     unaligned dcl 43 set ref 95* 98* 103 103 107*
bead_type                              based           structure                level 3 packed unaligned dcl 2-3
bits                      4            based           structure                array level 3 packed unaligned dcl 9-3 set ref 258*
bits_for_lex              0(18)        based           structure                level 2 packed unaligned dcl 6-3 ref 146 146
bits_for_parse            1            based           structure                level 2 in structure "operator_bead" packed
                                                                                  unaligned dcl 6-3 in procedure "adb" set ref 146
                                                                                  146
bits_for_parse            3            based           structure                level 2 in structure "lexed_function_bead" packed
                                                                                  unaligned dcl 8-6 in procedure "adb" ref 208 208
brief                           000104 automatic       bit(1)                   dcl 29 set ref 91* 103* 118* 190 232 260
character_string_overlay               based           char                     dcl 3-19 set ref 199*
character_value           0(09)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 157
class                     3            based           fixed bin(17,0)          level 2 dcl 7-5 ref 243
code                            000105 automatic       fixed bin(35,0)          dcl 29 set ref 93* 95* 96 98* 102* 103
com_err_                        000022 constant        entry                    external dcl 52 ref 87 98 107
command                         000106 automatic       bit(1)                   dcl 29 set ref 111* 119* 270
cu_$arg_count                   000010 constant        entry                    external dcl 52 ref 83
cu_$arg_ptr                     000012 constant        entry                    external dcl 52 ref 93 102
cv_ptr_                         000014 constant        entry                    external dcl 52 ref 95
cv_ptr_$terminate               000016 constant        entry                    external dcl 52 ref 270
data_elements                   000107 automatic       fixed bin(21,0)          dcl 29 set ref 193* 195 199 199
data_pointer              4            based           pointer                  level 2 packed unaligned dcl 3-3 set ref 169* 185
                                                                                  197 199
data_type                 0(08)        based           structure                level 4 in structure "value_bead" packed unaligned
                                                                                  dcl 3-3 in procedure "adb"
data_type                 0(08)        based           structure                level 3 in structure "general_bead" packed unaligned
                                                                                  dcl 2-3 in procedure "adb"
error_table_$badopt             000024 external static fixed bin(35,0)          dcl 60 set ref 107*
error_table_$noarg              000026 external static fixed bin(35,0)          dcl 60 set ref 87*
fixed                                                  builtin function         dcl 47 ref 128 128 128 128 137 137 137 137 146 146
                                                                                  146 146 146 146 146 146 169 169 169 169 205 205
                                                                                  205 205 243 243 243 243 254 254 254 254 266 266
                                                                                  266 266 266 266
function                  0(03)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 243
function_bead                          based           structure                level 1 dcl 7-5
function_classes                000000 constant        char(8)                  initial array unaligned dcl 65 set ref 243*
general_bead                           based           structure                level 1 dcl 2-3
group                     0(04)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 135
group_bead                             based           structure                level 1 dcl 5-7
hash_link_pointer         2            based           pointer                  level 2 packed unaligned dcl 4-13 set ref 128*
header                                 based           structure                level 2 in structure "value_bead" dcl 3-3
                                                                                  in procedure "adb"
header                                 based           structure                level 2 in structure "function_bead" dcl 7-5
                                                                                  in procedure "adb"
integral_value            0(11)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 161
ioa_                            000020 constant        entry                    external dcl 52 ref 124 128 137 141 143 146 169 177
                                                                                  179 192 197 199 205 208 210 212 215 218 220 222
                                                                                  224 226 228 230 234 238 241 243 254 258 262 266
                                                                                  285 293
label                     0(05)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 166
label_values                           based           pointer                  array level 2 packed unaligned dcl 8-6 set ref 226*
label_values_ptr          7            based           pointer                  level 2 packed unaligned dcl 8-6 set ref 212*
lexed_function            0(07)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 203
lexed_function_bead                    based           structure                level 1 dcl 8-6
lexed_function_bead_pointer
                          2            based           pointer                  level 2 packed unaligned dcl 7-5 set ref 243*
lexeme_array                           based           pointer                  array level 2 packed unaligned dcl 8-6 set ref 238*
lexeme_array_ptr         11            based           pointer                  level 2 packed unaligned dcl 8-6 set ref 212*
list_bead                              based           structure                level 1 dcl 9-3
list_value                0(08)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 155 252
localized_symbols        12            based           pointer                  array level 2 packed unaligned dcl 8-6 ref 217
meaning_pointer           3            based           pointer                  level 2 packed unaligned dcl 4-13 set ref 128*
member                    3            based           pointer                  array level 2 packed unaligned dcl 5-7 set ref 141*
member_ptr                3            based           pointer                  array level 3 packed unaligned dcl 9-3 set ref 258*
                                                                                  260
members                   3            based           structure                array level 2 dcl 9-3
n                               000147 automatic       fixed bin(17,0)          dcl 29 set ref 140* 141* 178* 179* 195* 197* 216*
                                                                                  217* 225* 226* 229* 230* 230* 235* 238* 238* 257*
                                                                                  258* 258 258 260*
n_args                          000110 automatic       fixed bin(17,0)          dcl 29 set ref 83* 85 85
name                      2            based           pointer                  level 2 in structure "lexed_function_bead" packed
                                                                                  unaligned dcl 8-6 in procedure "adb" set ref 208*
name                      5            based           char                     level 2 in structure "symbol_bead" packed unaligned
                                                                                  dcl 4-13 in procedure "adb" set ref 128* 220*
name_length               4            based           fixed bin(17,0)          level 2 dcl 4-13 ref 128 128 220 220
null                                                   builtin function         dcl 47 ref 121 218 293
number_of_labels          6            based           fixed bin(17,0)          level 2 dcl 8-6 set ref 210* 225 230 235 238
number_of_localized_symbols
                          5            based           fixed bin(17,0)          level 2 dcl 8-6 set ref 210* 216 226 230 235 238
number_of_members         2            based           fixed bin(17,0)          level 2 in structure "list_bead" dcl 9-3
                                                                                  in procedure "adb" set ref 254* 257
number_of_members         2            based           fixed bin(17,0)          level 2 in structure "group_bead" dcl 5-7
                                                                                  in procedure "adb" set ref 137* 140
number_of_statements      4            based           fixed bin(17,0)          level 2 dcl 8-6 set ref 210* 229 235 238
numeric_datum                          based           float bin(63)            array dcl 3-23 set ref 197*
numeric_value             0(10)        based           bit(1)                   level 4 in structure "general_bead" packed unaligned
                                                                                  dcl 2-3 in procedure "adb" ref 163
numeric_value             0(10)        based           bit(1)                   level 5 in structure "value_bead" packed unaligned
                                                                                  dcl 3-3 in procedure "adb" ref 185 195
op1                       1(27)        based           fixed bin(8,0)           level 3 packed unaligned dcl 6-3 set ref 146 146
                                                                                  222*
op2                       1(18)        based           fixed bin(8,0)           level 3 packed unaligned dcl 6-3 ref 146 146
operator                               based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 146
operator_bead                          based           structure                level 1 dcl 6-3
p2b                             000112 automatic       pointer                  dcl 29 set ref 95* 117* 121 128 128* 128 128 128 128
                                                                                  128 128 128 128 135 137* 137 137 137 137 137 137
                                                                                  140 141 146 146* 146 146 146 146 146 146 146 146
                                                                                  146 153 155 157 159 161 163 166 169* 169 169 169
                                                                                  169 169 169 169 169 175 178 179 183* 185 185 190
                                                                                  193 195 197 199 203 205* 205 205 205 205 205 208
                                                                                  208 208 210 210 210 212 212 212 216 217 225 226
                                                                                  229 230 235 235 238 241* 243 243* 243 243 243 243
                                                                                  243 243 243 243 243 243 243 252 254* 254 254 254
                                                                                  254 254 254 257 258 258 260 262* 266* 266 266 266
                                                                                  266 266 266 266 270*
p_bead_ptr                             parameter       pointer                  dcl 22 ref 114 117
p_brief_mode                           parameter       bit(1)                   dcl 22 ref 114 118
p_msg                                  parameter       char                     unaligned dcl 278 set ref 275 285*
p_ptr                                  parameter       pointer                  dcl 278 set ref 275 285 285*
pointers                 14            based           structure                level 2 dcl 10-16
reference_count           1            based           fixed bin(29,0)          level 2 in structure "general_bead" dcl 2-3
                                                                                  in procedure "adb" set ref 128* 137* 169* 205*
                                                                                  254* 266*
reference_count           1            based           fixed bin(29,0)          level 3 in structure "function_bead" dcl 7-5
                                                                                  in procedure "adb" set ref 243*
rel                                                    builtin function         dcl 47 ref 285
rho                       5            based           fixed bin(21,0)          array level 2 dcl 3-3 set ref 179*
rhorho                    3            based           fixed bin(17,0)          level 2 dcl 3-3 set ref 169* 175 178
size                      0(18)        based           bit(18)                  level 2 in structure "general_bead" packed unaligned
                                                                                  dcl 2-3 in procedure "adb" ref 128 128 128 128 137
                                                                                  137 137 137 169 169 169 169 205 205 205 205 254
                                                                                  254 254 254 266 266 266 266
size                      0(18)        based           bit(18)                  level 3 in structure "function_bead" packed
                                                                                  unaligned dcl 7-5 in procedure "adb" ref 243 243
                                                                                  243 243
statement_map                          based           fixed bin(18,0)          array level 2 dcl 8-6 set ref 230* 235
statement_map_ptr        10            based           pointer                  level 2 packed unaligned dcl 8-6 set ref 212*
static_ws_info_ptr              000030 external static pointer                  level 2 packed unaligned dcl 10-11 ref 10-7
stop_control_pointer      4            based           pointer                  level 2 packed unaligned dcl 7-5 set ref 243*
string                                                 builtin function         dcl 47 ref 146 146 266 266
substr                                                 builtin function         dcl 47 ref 146 146 285
symbol                    0(01)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 128 220
symbol_bead                            based           structure                level 1 dcl 4-13
text                      7            based           char                     level 2 dcl 7-5 set ref 243*
text_length               6            based           fixed bin(21,0)          level 2 dcl 7-5 set ref 243* 243 243
total_data_elements       2            based           fixed bin(21,0)          level 2 dcl 3-3 set ref 169* 190 193
tp                              000114 automatic       pointer                  dcl 29 set ref 217* 218 220 220* 220 222* 222
trace_control_pointer
                          5            based           pointer                  level 2 packed unaligned dcl 7-5 set ref 243*
type                                   based           structure                level 3 in structure "value_bead" packed unaligned
                                                                                  dcl 3-3 in procedure "adb"
type                                   based           structure                level 3 in structure "list_bead" packed unaligned
                                                                                  dcl 9-3 in procedure "adb"
type                                   based           structure                level 3 in structure "function_bead" packed
                                                                                  unaligned dcl 7-5 in procedure "adb"
type                                   based           structure                level 3 in structure "group_bead" packed unaligned
                                                                                  dcl 5-7 in procedure "adb"
type                                   based           structure                level 3 in structure "lexed_function_bead" packed
                                                                                  unaligned dcl 8-6 in procedure "adb"
type                                   based           structure                level 2 in structure "general_bead" packed unaligned
                                                                                  dcl 2-3 in procedure "adb" ref 266 266
type                                   based           structure                level 3 in structure "symbol_bead" packed unaligned
                                                                                  dcl 4-13 in procedure "adb"
type_code                 2            based           fixed bin(17,0)          level 2 dcl 6-3 set ref 146*
unspec                                                 builtin function         dcl 47 ref 146 146 208 208
value                     0(02)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 153
value_bead                             based           structure                level 1 dcl 3-3
value_stack_ptr          16            based           pointer                  level 3 packed unaligned dcl 10-16 set ref 293*
vcs                             000116 automatic       char(100)                unaligned dcl 29 set ref 155* 157* 159* 161* 163*
                                                                                  165* 166* 166 169*
ws_info                                based           structure                level 1 dcl 10-16
ws_info_ptr                     000150 automatic       pointer                  initial dcl 10-7 set ref 10-7* 293 293
zero_or_one_value         0(12)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 159

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Binary                                 internal static bit(1)                   initial dcl 1-16
LeftArgSymbol                          internal static fixed bin(17,0)          initial dcl 8-36
MAX_VALUE_BEAD_SIZE                    internal static fixed bin(19,0)          initial dcl 3-28
NumberSize                             internal static fixed bin(4,0)           initial dcl 1-25
ReturnSymbol                           internal static fixed bin(17,0)          initial dcl 8-36
RightArgSymbol                         internal static fixed bin(17,0)          initial dcl 8-36
TheBiggestNumberWeveGot                internal static float bin(63)            initial dcl 1-16
TheSmallestNumberWeveGot               internal static float bin(63)            initial dcl 1-16
character_data_structure               based           structure                level 1 dcl 3-15
character_value_type                   internal static bit(18)                  initial unaligned dcl 2-30
complex_datum                          based           complex float bin(63)    array dcl 3-26
complex_value_type                     internal static bit(18)                  initial unaligned dcl 2-30
function_type                          internal static bit(18)                  initial unaligned dcl 2-30
group_type                             internal static bit(18)                  initial unaligned dcl 2-30
integral_value_type                    internal static bit(18)                  initial unaligned dcl 2-30
label_type                             internal static bit(18)                  initial unaligned dcl 2-30
lexed_function_label_values_structure  based           structure                level 1 dcl 8-45
lexed_function_lexemes_structure       based           structure                level 1 dcl 8-45
lexed_function_statement_map           based           fixed bin(18,0)          array dcl 8-45
lexed_function_type                    internal static bit(18)                  initial unaligned dcl 2-30
list_value_type                        internal static bit(18)                  initial unaligned dcl 2-30
max_parse_stack_depth                  internal static fixed bin(17,0)          initial dcl 10-98
n_members                              automatic       fixed bin(17,0)          dcl 9-3
not_integer_mask                       internal static bit(18)                  initial unaligned dcl 2-30
not_zero_or_one_mask                   internal static bit(18)                  initial unaligned dcl 2-30
number_of_dimensions                   automatic       fixed bin(17,0)          dcl 3-3
numeric_value_type                     internal static bit(18)                  initial unaligned dcl 2-30
operator_type                          internal static bit(18)                  initial unaligned dcl 2-30
output_buffer                          based           char                     unaligned dcl 10-94
shared_variable_type                   internal static bit(18)                  initial unaligned dcl 2-30
statement_count                        automatic       fixed bin(17,0)          dcl 8-45
symbol_type                            internal static bit(18)                  initial unaligned dcl 2-30
value_type                             internal static bit(18)                  initial unaligned dcl 2-30
zero_or_one_value_type                 internal static bit(18)                  initial unaligned dcl 2-30

NAMES DECLARED BY EXPLICIT CONTEXT.
adb                             000660 constant        entry                    external dcl 16
apl_display_bead                000670 constant        entry                    external dcl 16
apl_display_bead_               001161 constant        entry                    external dcl 114 ref 260
check_ptr_alignment             003301 constant        entry                    internal dcl 275 ref 183 185
display_value_stack_ptr         003347 constant        entry                    internal dcl 290 ref 201 263
rejoinder                       001177 constant        label                    dcl 121 ref 112

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3556        3610    3422        3566
Length      4314    3422        32         470     133           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
adb                                 406 external procedure  is an external procedure.  
check_ptr_alignment                     internal procedure  shares stack frame of external procedure adb.  
display_value_stack_ptr                 internal procedure  shares stack frame of external procedure adb.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
adb                      000100 arg_len                     adb
                         000102 arg_ptr                     adb
                         000104 brief                       adb
                         000105 code                        adb
                         000106 command                     adb
                         000107 data_elements               adb
                         000110 n_args                      adb
                         000112 p2b                         adb
                         000114 tp                          adb
                         000116 vcs                         adb
                         000147 n                           adb
                         000150 ws_info_ptr                 adb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_in         call_ext_out_desc   call_ext_out        return              shorten_stack
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_ptr_
cv_ptr_$terminate             ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
apl_static_$ws_info_ptr       error_table_$badopt           error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
10    7 000652        16 000657        83 000676        85 000705        87 000711        88 000743        91 000744
     93 000745        95 000764        96 001010        98 001012        99 001052       102 001053       103 001072
    107 001111       108 001151       111 001152       112 001154       114 001155       117 001167       118 001173
    119 001176       121 001177       124 001203       125 001222       128 001223       135 001311       137 001314
    140 001364       141 001374       142 001417       143 001421       144 001432       146 001433       153 001520
    155 001523       157 001532       159 001541       161 001550       163 001557       165 001566       166 001571
    169 001607       175 001674       177 001677       178 001716       179 001726       180 001751       183 001753
    185 001764       190 002003       192 002010       193 002026       195 002031       197 002042       198 002067
    199 002072       201 002114       202 002115       203 002116       205 002121       208 002165       210 002214
    212 002243       215 002272       216 002311       217 002321       218 002324       220 002344       222 002400
    223 002426       224 002430       225 002447       226 002457       227 002504       228 002506       229 002522
    230 002532       231 002564       232 002566       234 002570       235 002607       238 002623       239 002656
    241 002660       242 002700       243 002701       252 003004       254 003007       257 003057       258 003067
    260 003147       261 003166       262 003170       263 003213       264 003214       266 003215       270 003267
    273 003300       275 003301       285 003312       288 003346       290 003347       293 003350       296 003375


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
