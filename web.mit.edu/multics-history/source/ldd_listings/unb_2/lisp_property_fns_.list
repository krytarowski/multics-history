ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>lisp_property_fns_.alm          
ASSEMBLED ON:	11/05/86  1102.1 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
                                     6  "
                                     7  "	lisp_property_fns_ -- those primitives used by lisp programs
                                     8  "			  to manipulate property lists.
                                     9  "			   Also handles lists which are structured as
                                    10  "			   property lists, even if not associated with atoms.
                                    11  "
                                    12  
    000000                          13  get_plist:	" this routine sets bp to point at the plist of something.
                                    14  		" call by tsx0, following word has pdl cell number in du
                                    15  		" skip returns if this thing has a plist, else doesn't skip.
                                    16  		" caller may signal an error if he wants.
                                    17  		" NOTE:  this perhaps should be changed to try a user
                                    18  		" interrupt if the thing does not have a plist, or otherwise
                                    19  		" be user-replaceable so that numbers and lists can have
                                    20  		" properties associated with them in some strange way.
                                    21  
    000000  aa   000000 2210 10     22  	ldx1	0,x0		" pick up pdl cell number of arg
    000001  aa  0 00000 2371 11     23  	ldaq	ap|0,x1		" get thing whose plist is needed
    000002  aa  1 00012 1171 00     24  	cmpaq	ab|nil
    000003  aa   000005 6000 04     25  	tze	get_plist_of_nil-*,ic
    000004  aa   067500 3150 07     26  	cana	Unevalable,dl	" have a plist?
    000005  aa   000001 6010 10     27  	tnz	1,x0		" no, non_skip return
    000006  aa  0 00000 3521 31     28  	eppbp	ap|0,x1*		" yes, bp|2 contains it
    000007  aa   000002 7100 10     29  	tra	2,x0		" and skip return
                                    30  
    000010                          31  get_plist_of_nil:
    000010  4a  4 00010 3521 20     32  	eppbp	<lisp_static_vars_>|[property_list_of_nil]-2	" bp|2 contains plist
    000011  aa   000002 7100 10     33  	tra	2,x0
                                    34  
                                    35  
                                    36  
                        000012      37  	segdef	get_
    000012  aa   777766 7000 04     38  get_:	tsx0	get_plist-*,ic	" get the property list of first argument
    000013  aa   777774 0000 00     39  	arg	-4
    000014  aa   000017 7100 04     40  	tra	retrn_nil-*,ic	" if has no plist, don't err, just return nil
                                    41  
    000015  aa  2 00002 2371 00     42  get_loop:	ldaq	bp|2		" see if there is any more property list left.
    000016  aa  1 00012 1171 00     43  	cmpaq	ab|nil
    000017  aa   000007 6000 04     44  	tze	retrn_aq-*,ic	" if not, return nil.
    000020  aa  2 00002 3521 20     45  	eppbp	bp|2,*		" get next indicator cell.
    000021  aa  2 00000 2371 00     46  	ldaq	bp|0		" load the indicator.
    000022  aa  2 00002 3521 20     47  	eppbp	bp|2,*		" and get pointer to value cell for that indicator.
    000023  aa  0 77776 1171 00     48  	cmpaq	ap|-2		" see if desired indicator.
    000024  aa   777771 6010 04     49  	tnz	get_loop-*,ic	" if not, try next indicator on list.
    000025  aa  2 00000 2371 00     50  	ldaq	bp|0		" load value to return.
    000026  aa  0 77774 3501 00     51  retrn_aq:	eppap	ap|-4		" pop off two args
    000027  aa  1 77774 3701 37     52  retrn:	epplp	ab|-4,x7*
    000030  aa  1 77776 3521 37     53  	eppbp	ab|-2,x7*
    000031  aa   777774 6270 17     54  	eax7	-4,x7		" pop off save stuff.
    000032  aa  2 00000 7101 00     55  	tra	bp|0		" return.
                                    56  
    000033  aa  1 00012 2371 00     57  retrn_nil: ldaq	ab|nil		" any atom not having a pname has null property list.
    000034  aa   777772 7100 04     58  	tra	retrn_aq-*,ic	" so return nil...this used to be error.
                                    59  
                        000035      60  	segdef	getl_
    000035  aa  0 77776 2371 00     61  getl_:	ldaq	ap|-2
    000036  aa   077700 3150 07     62  	cana	Atomic,dl			" make sure it is a list.
    000037  aa   000006 6000 04     63  	tze	getl_ok-*,ic
    000040  aa  1 00012 1171 00     64  	cmpaq	ab|nil			" nil is ok too.
    000041  aa   000004 6000 04     65  	tze	getl_ok-*,ic
    000042  aa   000054 3360 07     66  	lcq	-fn_getl,dl
    000043  aa   000232 7060 04     67  	tsx6	error2-*,ic		" error in second of two args.
    000044  aa   777771 7100 04     68  	tra	getl_-*,ic
                                    69  
    000045  aa   777733 7000 04     70  getl_ok:	tsx0	get_plist-*,ic		" find atom whose property is to be gotten
    000046  aa   777774 0000 00     71  	arg	-4
    000047  aa   777764 7100 04     72  	tra	retrn_nil-*,ic		" no properties -> nil
    000050  aa  2 00002 2371 00     73  getl_lp:	ldaq	bp|2			" check to see if any properties
    000051  aa  1 00012 1171 00     74  	cmpaq	ab|nil			" left...if not return nil
    000052  aa   777754 6000 04     75  	tze	retrn_aq-*,ic
    000053  aa  0 77774 7571 00     76  	staq	ap|-4			" save as a possible return val
    000054  aa  2 00002 3521 20     77  	eppbp	bp|2,*
                                    78  
    000055  aa  0 77774 3701 00     79  	epplp	ap|-4			" see if cur indicator is member of list.
    000056  aa  4 00002 2371 00     80  getl_lp1:	ldaq	lp|2			" see if any more tings in list
    000057  aa  1 00012 1171 00     81  	cmpaq	ab|nil
    000060  aa   000007 6000 04     82  	tze	getl_next-*,ic
    000061  aa  4 00002 3701 20     83  	epplp	lp|2,*			" if so, check next element
    000062  aa  4 00000 2371 00     84  	ldaq	lp|0			" against current indicator
    000063  aa  2 00000 1171 00     85  	cmpaq	bp|0
    000064  aa   777772 6010 04     86  	tnz	getl_lp1-*,ic		" if not eq, then try next element.
                                    87  
    000065  aa  0 77774 2371 00     88  	ldaq	ap|-4			" load saved result.
    000066  aa   777740 7100 04     89  	tra	retrn_aq-*,ic
                                    90  
    000067  aa  2 00002 3521 20     91  getl_next:eppbp	bp|2,*			" get next property cell pointer.
    000070  aa   777760 7100 04     92  	tra	getl_lp-*,ic
                                    93  
                        000071      94  	segdef	plist_			" function to get the plist
    000071  aa   777707 7000 04     95  plist_:	tsx0	get_plist-*,ic
    000072  aa   777776 0000 00     96  	arg	-2
    000073  aa  1 00010 3521 00     97  	eppbp	ab|nil-2			" if doesn't have one, for now use nil
    000074  aa  2 00002 2371 00     98  	ldaq	bp|2			" pick up the plist
    000075  aa  0 77776 3501 00     99  	eppap	ap|-2
    000076  aa   777731 7100 04    100  	tra	retrn-*,ic
                                   101  
                        000077     102  	segdef	setplist_			" function to set a new plist
    000077  aa   777701 7000 04    103  setplist_:tsx0	get_plist-*,ic
    000100  aa   777774 0000 00    104  	arg	-4
    000101  aa   000005 7100 04    105  	tra	cant_set_plist-*,ic		" error to set plist of e.g. number.
    000102  aa  0 77776 2371 00    106  	ldaq	ap|-2			" get plist to set
    000103  aa  2 00002 7571 00    107  	staq	bp|2			" store it away
    000104  aa  0 77774 2371 00    108  	ldaq	ap|-4			" return first arg
    000105  aa   777721 7100 04    109  	tra	retrn_aq-*,ic
                                   110  
    000106                         111  cant_set_plist:
    000106  4a  4 00012 2351 20    112  	lda	<lisp_error_table_>|[cant_set_plist]
    000107  aa   777774 6200 00    113  	eax0	-4			" ap|-4 has the bad thing
    000110  aa   000127 7060 04    114  	tsx6	error00-*,ic		" go signal error
    000111  aa   777766 7100 04    115  	tra	setplist_-*,ic		" then try again
                                   116  
                        000114     117  	segdef	remprop_
    000112                         118  remprop_loses:
    000112  aa   000056 3360 07    119  	lcq	-fn_remprop,dl		" load error code
    000113  aa   000122 7060 04    120  	tsx6	error1-*,ic		" go complain to user
                                   121  					" and if reparations made, try again.
                                   122  
    000114  aa   777664 7000 04    123  remprop_:	tsx0	get_plist-*,ic		" get plist of first arg
    000115  aa   777774 0000 00    124  	arg	-4
    000116  aa   777774 7100 04    125  	tra	remprop_loses-*,ic		" can't get it, complain
    000117  aa  2 00000 3701 00    126  	epplp	bp|0			" lp will point at cell to rplacd
    000120  aa  4 00002 2371 00    127  rem_loop:	ldaq	lp|2			" check for end of plist.
    000121  aa  1 00012 1171 00    128  	cmpaq	ab|nil
    000122  aa   777704 6000 04    129  	tze	retrn_aq-*,ic		" if end, return nil.
    000123  aa  4 00002 3521 20    130  	eppbp	lp|2,*			" get pointer at property indicator cell.
    000124  aa  2 00000 2371 00    131  	ldaq	bp|0			" load the indicator
    000125  aa  0 77776 1171 00    132  	cmpaq	ap|-2			" cand see if the desired one.
    000126  aa   000003 6000 04    133  	tze	rem_property-*,ic		" if so remove the property.
    000127  aa  2 00002 3701 20    134  	epplp	bp|2,*			" look at next element
    000130  aa   777770 7100 04    135  	tra	rem_loop-*,ic		" and try again.
                                   136  
    000131                         137  rem_property:
    000131  aa  2 00002 3521 20    138  	eppbp	bp|2,*			" get pointer to second cell deleted.
    000132  aa  2 00002 2371 00    139  	ldaq	bp|2			" and rplacd its cdr into place
    000133  aa  4 00002 7571 00    140  	staq	lp|2			" pointed at by lp.
    000134  aa  0 77776 2521 00    141  	spribp	ap|-2			" result is second cell
    000135  aa  0 77776 2371 00    142  	ldaq	ap|-2			" return indicator of success.
    000136  aa   777670 7100 04    143  	tra	retrn_aq-*,ic
                                   144  
                        000141     145  	segdef	putprop_
    000137                         146  putprop_loses:
    000137  aa   000055 3360 07    147  	lcq	-fn_putprop,dl	" load our name
    000140  aa   000137 7060 04    148  	tsx6	error3-*,ic	" and call the error routine
                                   149  
    000141  aa   777637 7000 04    150  putprop_:	tsx0	get_plist-*,ic	" find plist of arg 1
    000142  aa   777772 0000 00    151  	arg	-6
    000143  aa   777774 7100 04    152  	tra	putprop_loses-*,ic	" if has none, barf
                                   153  
    000144  aa  2 00000 3715 00    154  	epplb	bp|0		" save address of start of plist
    000145  aa  2 00002 2371 00    155  put_loop:	ldaq	bp|2		" check to see if at end of plist.
    000146  aa  1 00012 1171 00    156  	cmpaq	ab|nil
    000147  aa   000012 6000 04    157  	tze	make_new_cells-*,ic	" if so, must make addition to plist at front.
    000150  aa  2 00002 3521 20    158  	eppbp	bp|2,*		" get pointer at indicator cell
    000151  aa  2 00000 2371 00    159  	ldaq	bp|0		" load indicator.
    000152  aa  2 00002 3521 20    160  	eppbp	bp|2,*		" get value cell pointer into bp
    000153  aa  0 77776 1171 00    161  	cmpaq	ap|-2		" if indicator eq to arg 3, rplacd
    000154  aa   777771 6010 04    162  	tnz	put_loop-*,ic	" oterwise jump down list to next indicator.
    000155  aa  0 77774 2371 00    163  	ldaq	ap|-4		" get new value to rplaca
    000156  aa  2 00000 7571 00    164  	staq	bp|0		" and do it.
    000157  aa  0 77772 3501 00    165  	eppap	ap|-6		" get rid of args...value to return is in aq
    000160  aa   777647 7100 04    166  	tra	retrn-*,ic
                                   167  
    000161                         168  make_new_cells:			" code to make two new list cells and splice tem in.
    000161  aa  0 00006 3501 00    169  	eppap	ap|6		" get arg list room
    000162  aa  5 00002 2371 00    170  	ldaq	lb|2		" load old cdr of arg 1
    000163  aa  0 77776 7571 00    171  	staq	ap|-2		" and set up call to cons.
    000164  aa  0 77766 2371 00    172  	ldaq	ap|-4-6		" load arg 2
    000165  aa  0 77774 7571 00    173  	staq	ap|-4
    000166  aa   000010 6270 17    174  	eax7	8,x7		" get room for two type 1 calls to cons.
    000167  aa  1 77770 6501 17    175  	sprilp	ab|-8,x7
    000170  aa  1 77774 6501 17    176  	sprilp	ab|-4,x7
    000171  aa  1 77776 3571 17    177  	stcd	ab|-2,x7		" save return address.
    000172  4a  4 00014 7101 20    178  	tra	<lisp_alloc_>|[cons_]
    000173  aa  0 77776 7571 00    179  	staq	ap|-2
    000174  aa  1 77776 3571 17    180  	stcd	ab|-2,x7		" call cons again to add indicator.
    000175  4a  4 00014 7101 20    181  	tra 	<lisp_alloc_>|[cons_]
    000176  aa  0 77776 7571 00    182  	staq	ap|-2		" save new property list
    000177  aa   777601 7000 04    183  	tsx0	get_plist-*,ic	" get where to put it
    000200  aa   777774 0000 00    184  	arg	-4
    000201  aa   000000 0020 00    185  	drl	0		" I don't know what to do here
    000202  aa  0 77776 2371 00    186  	ldaq	ap|-2		" get back result of consing
    000203  aa  2 00002 7571 00    187  	staq	bp|2		" store new property list
    000204  aa  2 00002 3521 20    188  	eppbp	bp|2,*
    000205  aa  2 00002 2371 20    189  	ldaq	bp|2,*		" load the value for return
    000206  aa   777620 7100 04    190  	tra	retrn_aq-*,ic
                                   191  
                                   192  
                                   193  "	The PL/I callable entries are here...
                                   194  
                        000215     195  	entry	get,putprop,getl,remprop
                                   196  
    000207  aa   000010 7060 04    197  get:	tsx6	pl1_to_lisp-*,ic
    000210  aa   777602 7100 04    198  	tra	get_-*,ic
    000211  aa   000006 7060 04    199  putprop:	tsx6	pl1_to_lisp-*,ic
    000212  aa   777727 7100 04    200  	tra	putprop_-*,ic
    000213  aa   000004 7060 04    201  getl:	tsx6	pl1_to_lisp-*,ic
    000214  aa   777621 7100 04    202  	tra	getl_-*,ic
    000215  aa   000002 7060 04    203  remprop:	tsx6	pl1_to_lisp-*,ic
    000216  aa   777676 7100 04    204  	tra	remprop_-*,ic
                                   205  
    000217                         206  pl1_to_lisp:
    000217  4a  4 00016 3511 20    207  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000220  4a  4 00020 3501 20    208  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000221  4a  4 00022 2271 20    209  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000222  aa  1 00016 4501 00    210  	stz	ab|in_pl1_code
    000223  aa   000004 6270 17    211  	eax7	4,x7
    000224  aa  1 77774 6501 17    212  	sprilp	ab|-4,x7		" save lp and return address.
    000225  aa  1 77776 3571 17    213  	stcd	ab|-2,x7
    000226  aa   000000 7100 16    214  	tra	0,x6		" and call the lisp routine.
    000227  aa  0 00002 3501 00    215  	eppap	ap|2		" now put result back on stack.
    000230  aa  0 77776 7571 00    216  	staq	ap|-2
    000231  4a  4 00024 2501 20    217  	spriap	<lisp_static_vars_>|[stack_ptr]
    000232  4a  4 00022 7471 20    218  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000233  aa  1 00016 5541 00    219  	stc1	ab|in_pl1_code
    000234  aa  7 00044 7101 20    220  	short_return
                                   221  
                                   222  
    000235  aa   777774 6200 00    223  error1:	eax0	-4		" offset of losing arg from stack top.
    000236  4a  4 00026 2351 20    224  error:	lda	<lisp_error_table_>|[bad_arg_correctable]
    000237  aa   000004 6270 17    225  error00:	eax7	4,x7		" save regs, error data on unmkd stack
    000240  aa  1 77776 7571 17    226  	staq	ab|-2,x7
    000241  aa  0 00002 3501 00    227  	eppap	ap|2		" get losing arg on stack top.
    000242  aa  0 77776 2371 10    228  	ldaq	ap|-2,x0
    000243  aa  0 77776 7571 00    229  	staq	ap|-2
    000244  aa  1 77774 7461 17    230  	stx6	ab|-4,x7		" save return address
    000245  aa  1 77775 7401 17    231  	stx0	ab|-3,x7		" and stack offset of bad arg.
    000246  4a  4 00024 2501 20    232  	spriap	<lisp_static_vars_>|[stack_ptr]
    000247  4a  4 00022 7471 20    233  	stx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000250  aa  1 00016 5541 00    234  	stc1	ab|in_pl1_code
    000251  aa   000060 6270 00    235  	push
    000252  aa  7 00040 2721 20
    000253  aa   000027 3500 04    236  	eppap	noargs-*,ic
    000254  4a  4 00030 3521 20    237  	short_call <lisp_error_>|[lisp_error_]
    000255  aa  7 00036 6701 20
    000256  aa  6 00030 3701 20
    000257  aa  6 00020 6351 20    238  	eaa	sp|16,*		" get back pointer from stack frame
    000260  aa  7 00024 6521 00    239  	sprisp	sb|stack_header.stack_end_ptr
    000261  aa  7 00000 3721 01    240  	eppsp	sb|0,au		" and pop off stack frame.
    000262  4a  4 00016 3511 20    241  	epbpab	<lisp_static_vars_>|[unmkd_ptr],*
    000263  4a  4 00020 3501 20    242  	eppap	<lisp_static_vars_>|[stack_ptr],*
    000264  4a  4 00022 2271 20    243  	ldx7	<lisp_static_vars_>|[unmkd_ptr]+1
    000265  aa  1 00016 4501 00    244  	stz	ab|in_pl1_code
    000266  aa  0 77776 2371 00    245  	ldaq	ap|-2		"load returnd value.
    000267  aa  0 77776 3501 00    246  	eppap	ap|-2
    000270  aa  1 77777 2201 17    247  	ldx0	ab|-1,x7
    000271  aa  1 77776 2261 17    248  	ldx6	ab|-2,x7
    000272  aa  0 00000 7571 10    249  	staq	ap|0,x0		" put value back in correct place.
    000273  aa   777776 6270 17    250  	eax7	-2,x7		" pop off saved index reg block.
    000274  aa   000000 7100 16    251  	tra	0,x6		" return to try again.
    000275  aa   777776 6200 00    252  error2:	eax0	-2		" offset of losing arg.
    000276  aa   777740 7100 04    253  	tra	error-*,ic
    000277  aa   777772 6200 00    254  error3:	eax0	-6	" offset of losing arg.
    000300  aa   777736 7100 04    255  	tra	error-*,ic
                                   256  
    000301  aa   000000 0110 03    257  	even
    000302  aa   000000 000004     258  noargs:	oct	4,0		" null arg list.
    000303  aa   000000 000000 
                                   259  	include 	stack_header
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   260  	include 	lisp_object_types
                                   2-1  
                                   2-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   2-3  "
                                   2-4  " D.A.Moon 14 July 72
                                   2-5  
                                   2-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   2-7  "they should be used with cana instructions in the dl mode.
                                   2-8  "
                                   2-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  2-10  
                                  2-11  
                                  2-12  
                        077700    2-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  2-14  
                        040000    2-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    2-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    2-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    2-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    2-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    2-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    2-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    2-22  	bool	String,004000		"points at a lisp character string
                        002000    2-23  	bool	Subr,002000		"points at subr link
                        000400    2-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    2-25  	bool	Array,000200		"points at an array,
                                  2-26  					" which is a special kind of subr
                        067500    2-27  	bool	Unevalable,067500		"any of these bits means
                                  2-28  					" does not have car and cdr
                        001000    2-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    2-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  2-31  
                                  2-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  2-33  
                        040047    2-34  	bool	fixnum_type,040047
                        020047    2-35  	bool	flonum_type,020047
                                  2-36  
                                  2-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                   261  	include	lisp_name_codes
                                   3-1  
                                   3-2  " BEGIN INCLUDE FILE lisp_name_codes.incl.alm
                                   3-3  
                                   3-4  " These are codes for the names of functions which are stored into ab|-1,x7 before
                                   3-5  " calling lisp_error_ for a bad_argument or bad_arg_correctable error. They
                                   3-6  " are used so that the name of the function which is rejecting its argument
                                   3-7  " can be printed.  Please note that all these codes are negative.
                                   3-8  
                 777777 777766     3-9  	equ	fn_do,-10
                 777777 777765    3-10  	equ	fn_arg,-11
                 777777 777764    3-11  	equ	fn_setarg,-12
                 777777 777763    3-12  	equ	fn_status,-13
                 777777 777762    3-13  	equ	fn_sstatus,-14
                 777777 777761    3-14  	equ	fn_errprint,-15
                 777777 777760    3-15  	equ	fn_errframe,-16
                 777777 777757    3-16  	equ	fn_evalframe,-17
                 777777 777756    3-17  	equ	fn_defaultf,-18
                 777777 777752    3-18  	equ	fn_tyo,-22
                 777777 777751    3-19  	equ	fn_ascii,-23
                 777777 777750    3-20  	equ	fn_rplaca,-24
                 777777 777747    3-21  	equ	fn_definedp,-25
                 777777 777746    3-22  	equ	fn_setq,-26
                 777777 777745    3-23  	equ	fn_set,-27
                 777777 777744    3-24  	equ	fn_delete,-28
                 777777 777743    3-25  	equ	fn_delq,-29
                 777777 777742    3-26  	equ	fn_stringlength,-30
                 777777 777741    3-27  	equ	fn_catenate,-31
                 777777 777740    3-28  	equ	fn_array,-32
                 777777 777737    3-29  	equ	fn_substr,-33
                 777777 777736    3-30  	equ	fn_index,-34
                 777777 777735    3-31  	equ	fn_get_pname,-35
                 777777 777734    3-32  	equ	fn_make_atom,-36
                 777777 777733    3-33  	equ	fn_ItoC,-37
                 777777 777732    3-34  	equ	fn_CtoI,-38
                 777777 777731    3-35  	equ	fn_defsubr,-39
                 777777 777730    3-36  	equ	fn_star_array,-40
                 777777 777727    3-37  	equ	fn_args,-41
                 777777 777726    3-38  	equ	fn_sysp,-42
                 777777 777725    3-39  	equ	fn_get,-43
                 777777 777724    3-40  	equ	fn_getl,-44
                 777777 777723    3-41  	equ	fn_putprop,-45
                 777777 777722    3-42  	equ	fn_remprop,-46
                 777777 777721    3-43  	equ	fn_save,-47
                 777777 777720    3-44  	equ	fn_add1,-48
                 777777 777717    3-45  	equ	fn_sub1,-49
                 777777 777716    3-46  	equ	fn_greaterp,-50
                 777777 777715    3-47  	equ	fn_lessp,-51
                 777777 777714    3-48  	equ	fn_minus,-52
                 777777 777713    3-49  	equ	fn_plus,-53
                 777777 777712    3-50  	equ	fn_times,-54
                 777777 777711    3-51  	equ	fn_difference,-55
                 777777 777710    3-52  	equ	fn_quotient,-56
                 777777 777707    3-53  	equ	fn_abs,-57
                 777777 777706    3-54  	equ	fn_expt,-58
                 777777 777705    3-55  	equ	fn_boole,-59
                 777777 777704    3-56  	equ	fn_rot,-60
                 777777 777703    3-57  	equ	fn_lsh,-61
                 777777 777702    3-58  	equ	fn_signp,-62
                 777777 777701    3-59  	equ	fn_fix,-63
                 777777 777700    3-60  	equ	fn_float,-64
                 777777 777677    3-61  	equ	fn_remainder,-65
                 777777 777676    3-62  	equ	fn_max,-66
                 777777 777675    3-63  	equ	fn_min,-67
                 777777 777674    3-64  	equ	fn_add1_fix,-68
                 777777 777673    3-65  	equ	fn_add1_flo,-69
                 777777 777672    3-66  	equ	fn_sub1_fix,-70
                 777777 777671    3-67  	equ	fn_sub1_flo,-71
                 777777 777670    3-68  	equ	fn_plus_fix,-72
                 777777 777667    3-69  	equ	fn_plus_flo,-73
                 777777 777666    3-70  	equ	fn_times_fix,-74
                 777777 777665    3-71  	equ	fn_times_flo,-75
                 777777 777664    3-72  	equ	fn_diff_fix,-76
                 777777 777663    3-73  	equ	fn_diff_flo,-77
                 777777 777662    3-74  	equ	fn_quot_fix,-78
                 777777 777661    3-75  	equ	fn_quot_flo,-79
                 777777 777660    3-76  	equ	fn_eval,-80
                 777777 777657    3-77  	equ	fn_apply,-81
                 777777 777656    3-78  	equ	fn_prog,-82
                 777777 777655    3-79  	equ	fn_errset,-83
                 777777 777654    3-80  	equ	fn_catch,-84
                 777777 777653    3-81  	equ	fn_throw,-85
                 777777 777652    3-82  	equ	fn_store,-86
                 777777 777651    3-83  	equ	fn_defun,-87
                 777777 777650    3-84  	equ	fn_baktrace,-88
                 777777 777647    3-85  	equ	fn_bltarray,-89
                 777777 777646    3-86  	equ	fn_star_rearray,-90
                 777777 777645    3-87  	equ	fn_gensym,-91
                 777777 777644    3-88  	equ	fn_makunbound,-92
                 777777 777643    3-89  	equ	fn_boundp,-93
                 777777 777642    3-90  	equ	fn_star_status,-94
                 777777 777641    3-91  	equ	fn_star_sstatus,-95
                 777777 777640    3-92  	equ	fn_freturn,-96
                 777777 777637    3-93  	equ	fn_cos,-97
                 777777 777636    3-94  	equ	fn_sin,-98
                 777777 777635    3-95  	equ	fn_exp,-99
                 777777 777634    3-96  	equ	fn_log,-100
                 777777 777633    3-97  	equ	fn_sqrt,-101
                 777777 777632    3-98  	equ	fn_isqrt,-102
                 777777 777631    3-99  	equ	fn_atan,-103
                 777777 777630   3-100  	equ	fn_sleep,-104
                 777777 777627   3-101  	equ	fn_oddp,-105
                 777777 777626   3-102  	equ	fn_tyipeek,-106
                 777777 777625   3-103  	equ	fn_alarmclock,-107
                 777777 777624   3-104  	equ	fn_plusp,-108
                 777777 777623   3-105  	equ	fn_minusp,-109
                 777777 777622   3-106  	equ	fn_ls,-110
                 777777 777621   3-107  	equ	fn_eql,-111
                 777777 777620   3-108  	equ	fn_gt,-112
                 777777 777617   3-109  	equ	fn_alphalessp,-113
                 777777 777616   3-110  	equ	fn_samepnamep,-114
                 777777 777615   3-111  	equ	fn_getchar,-115
                 777777 777614   3-112  	equ	fn_opena,-116
                 777777 777613   3-113  	equ	fn_sxhash,-117
                 777777 777612   3-114  	equ	fn_gcd,-118
                 777777 777611   3-115  	equ	fn_allfiles,-119
                 777777 777610   3-116  	equ	fn_chrct,-120
                 777777 777607   3-117  	equ	fn_close,-121
                 777777 777606   3-118  	equ	fn_deletef,-122
                 777777 777605   3-119  	equ	fn_eoffn,-123
                 777777 777604   3-120  	equ	fn_filepos,-124
                 777777 777603   3-121  	equ	fn_inpush,-125
                 777777 777602   3-122  	equ	fn_linel,-126
                 777777 777601   3-123  	equ	fn_mergef,-127
                 777777 777600   3-124  	equ	fn_namelist,-128
                 777777 777577   3-125  	equ	fn_names,-129
                 777777 777576   3-126  	equ	fn_namestring,-130
                 777777 777575   3-127  	equ	fn_openi,-131
                 777777 777574   3-128  	equ	fn_openo,-132
                 777777 777573   3-129  	equ	fn_prin1,-133
                 777777 777572   3-130  	equ	fn_princ,-134
                 777777 777571   3-131  	equ	fn_print,-135
                 777777 777570   3-132  	equ	fn_read,-136
                 777777 777567   3-133  	equ	fn_readch,-137
                 777777 777566   3-134  	equ	fn_readstring,-138
                 777777 777565   3-135  	equ	fn_rename,-139
                 777777 777564   3-136  	equ	fn_shortnamestring,-140
                 777777 777563   3-137  	equ	fn_tyi,-141
                 777777 777562   3-138  	equ	fn_setsyntax,-142
                 777777 777561   3-139  	equ	fn_cursorpos,-143
                 777777 777560   3-140  	equ	fn_force_output,-144
                 777777 777557   3-141  	equ	fn_clear_input,-145
                 777777 777556   3-142  	equ	fn_random,-146
                 777777 777555   3-143  	equ	fn_haulong,-147
                 777777 777554   3-144  	equ	fn_haipart,-148
                 777777 777553   3-145  	equ	fn_cline,-149
                 777777 777552   3-146  	equ	fn_fillarray,-150
                 777777 777551   3-147  	equ	fn_listarray,-151
                 777777 777550   3-148  	equ	fn_sort,-152
                 777777 777547   3-149  	equ	fn_sortcar,-153
                 777777 777546   3-150  	equ	fn_zerop,-154
                 777777 777545   3-151  	equ	fn_listify,-155
                 777777 777544   3-152  	equ	fn_charpos,-156
                 777777 777543   3-153  	equ	fn_pagel,-157
                 777777 777542   3-154  	equ	fn_linenum,-158
                 777777 777541   3-155  	equ	fn_pagenum,-159
                 777777 777540   3-156  	equ	fn_endpagefn,-160
                 777777 777537   3-157  	equ	fn_arraydims,-161
                 777777 777536   3-158  	equ	fn_loadarrays,-162
                 777777 777535   3-159  	equ	fn_dumparrays,-163
                 777777 777534   3-160  	equ	fn_expt_fix,-164
                 777777 777533   3-161  	equ	fn_expt_flo,-165
                 777777 777532   3-162  	equ	fn_nointerrupt,-166
                 777777 777531   3-163  	equ	fn_open,-167
                 777777 777530   3-164  	equ	fn_in,-168
                 777777 777527   3-165  	equ	fn_out,-169
                 777777 777526   3-166  	equ	fn_truename,-170
                 777777 777525   3-167  	equ	fn_ifix,-171
                 777777 777524   3-168  	equ	fn_fsc,-172
                 777777 777523   3-169  	equ	fn_progv,-173
                 777777 777522   3-170  	equ	fn_mapatoms,-174
                 777777 777521   3-171  	equ	fn_unwind_protect,-175
                 777777 777520   3-172  	equ	fn_eval_when,-176
                 777777 777517   3-173  	equ	fn_read_from_string,-177
                 777777 777516   3-174  	equ	fn_displace,-178
                 777777 777515   3-175  	equ	fn_nth,-179
                 777777 777514   3-176  	equ	fn_nthcdr,-180
                 777777 777513   3-177  	equ	fn_includef,-181
                                 3-178  
                                 3-179  " END INCLUDE FILE lisp_name_codes.incl.alm
                                   262  	include	lisp_stack_seg
                                   4-1  " BEGIN INCLUDE FILE lisp_stack_seg.incl.alm
                                   4-2  
                                   4-3  "	lisp stack segment header format
                                   4-4  "	Last modified by Reed 6/21/72
                                   4-5  "
                        000000     4-6  	equ	marked_stack_bottom,0	offset of ptr to bottom of marked stack
                        000002     4-7  	equ	unmkd_stack_bottom,2	offset of ptr to bottom of unmkd_stack
                        000004     4-8  	equ	stack_ptr_ptr,4		offset of ptr to lisp_static_vars_$stack_ptr
                        000006     4-9  	equ	unmkd_ptr_ptr,6		offset of ptr to lisp_static_vars_$unmkd_ptr's offset word
                        000010    4-10  	equ	array_pointer,8		points at cell of array most recently referenced
                        000012    4-11  	equ	nil,10			offset of cell containing pointer to nil...
                        000014    4-12  	equ	true,12			offset of cell containing pointer to t...
                        000016    4-13  	equ	in_pl1_code,14		offset of flag saying whether stack_ptr
                                  4-14  "					& unmkd_ptr or ap and ab|.,x7 are valid...if zero, ap,ab arevalid.
                                  4-15  " table of pointers to operators
                                  4-16  
                        000020    4-17  	equ	bind_op,16
                        000022    4-18  	equ	unbind_op,18
                        000024    4-19  	equ	errset1_op,20
                        000026    4-20  	equ	errset2_op,22
                        000030    4-21  	equ	unerrset_op,24
                        000032    4-22  	equ	call_op,26
                        000034    4-23  	equ	catch1_op,28
                        000036    4-24  	equ	catch2_op,30
                        000040    4-25  	equ	uncatch_op,32
                        000042    4-26  	equ	gensym_data,34	" data for gensym function
                                  4-27  
                        000044    4-28  	equ	system_lp,36		pointer to common linkage section for bound segment.
                        000046    4-29  	equ	iogbind_op,38		operator to help out with compiled iog.
                        000050    4-30  	equ	unseen_go_tag_op,40
                        000052    4-31  	equ	throw1_op,42
                        000054    4-32  	equ	throw2_op,44
                        000056    4-33  	equ	signp_op,46
                        000060    4-34  	equ	type_fields,48
                        000062    4-35  	equ	return_op,50
                        000064    4-36  	equ	err_op,52
                        000066    4-37  	equ	pl1_interface,54
                        000070    4-38  	equ	pl1_lsubr_interface,56
                        000072    4-39  	equ	cons_op,58		operator for compiled cons
                        000074    4-40  	equ	ncons_op,60		opeator for compiled cons with nil
                        000076    4-41  	equ	xcons_op,62		operator for compiled xcons
                        000100    4-42  	equ	begin_list_op,64		operator to begin compiled list code
                        000102    4-43  	equ	append_list_op,66		operator to get new list cell and hook on end
                        000104    4-44  	equ	terminate_list_op,68	operator to finish off list.
                        000106    4-45  	equ	compare_op,70
                        000110    4-46  	equ	link_opr,72
                        000112    4-47  	equ	array_operator,74
                        000114    4-48  	equ	dead_array_operator,76
                        000116    4-49  	equ	store_operator,78
                        000120    4-50  	equ	floating_store_operator,80
                        000122    4-51  	equ	array_info_for_store,82
                        000124    4-52  	equ	array_offset_for_store,84
                        000126    4-53  	equ	array_link_snap_opr,86
                        000130    4-54  	equ	create_string_desc_op,88	string desc for PL/I call
                        000132    4-55  	equ	create_array_desc_op,90	array desc for PL/I call
                        000134    4-56  	equ	pl1_call_op,92		PL/I call operator
                        000136    4-57  	equ	cons_string_op,94		operator to cons up a string
                        000140    4-58  	equ	create_varying_string_op,96
                        000142    4-59  	equ	unwp1_op,98		unwind-protect start
                        000144    4-60  	equ	unwp2_op,100		ditto, for compat.
                        000146    4-61  	equ	ununwp_op,102		End unwind-protect.
                        000150    4-62  	equ	irest_return_op,104 	Interrupt restore return
                        000152    4-63  	equ	pl1_call_nopop_op,106	PL1 call, dont pop PL1 frame
                        000154    4-64  	equ	rcv_char_star_op,108	Receive char * result, pop pl1frame
                                  4-65  	" spare 110
                        000174    4-66  	equ	begin_unmkd_stack,124	beginning of unmkd_stack
                                  4-67  
                                  4-68  " END INCLUDE FILE lisp_stack_seg.incl.alm
                                  4-69  
                                   263  	end
ENTRY SEQUENCES
     
    000304  5a   000032 0000 00
    000305  aa  7 00046 2721 20
    000306  0a   000207 7100 00
    000307  5a   000025 0000 00
    000310  aa  7 00046 2721 20
    000311  0a   000211 7100 00
    000312  5a   000020 0000 00
    000313  aa  7 00046 2721 20
    000314  0a   000213 7100 00
    000315  5a   000013 0000 00
    000316  aa  7 00046 2721 20
    000317  0a   000215 7100 00

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    000320  5a   000003 000000 
    000321  5a   000106 600000 
    000322  aa   000000 000000 
    000323  55   000013 000002 
    000324  5a   000002 400003 
    000325  55   000006 000013 
    000326  aa  022 154 151 163
    000327  aa  160 137 160 162
    000330  aa  157 160 145 162
    000331  aa  164 171 137 146
    000332  aa  156 163 137 000
    000333  55   000020 000003 
    000334  0a   000316 500000 
    000335  55   000016 000003 
    000336  aa  007 162 145 155         remprop
    000337  aa  160 162 157 160
    000340  55   000025 000013 
    000341  0a   000313 500000 
    000342  55   000023 000003 
    000343  aa  004 147 145 164         getl
    000344  aa  154 000 000 000
    000345  55   000032 000020 
    000346  0a   000310 500000 
    000347  55   000030 000003 
    000350  aa  007 160 165 164         putprop
    000351  aa  160 162 157 160
    000352  55   000036 000025 
    000353  0a   000305 500000 
    000354  55   000035 000003 
    000355  aa  003 147 145 164         get
    000356  55   000044 000032 
    000357  0a   000141 400000 
    000360  55   000041 000003 
    000361  aa  010 160 165 164         putprop_
    000362  aa  160 162 157 160
    000363  aa  137 000 000 000
    000364  55   000052 000036 
    000365  0a   000114 400000 
    000366  55   000047 000003 
    000367  aa  010 162 145 155         remprop_
    000370  aa  160 162 157 160
    000371  aa  137 000 000 000
    000372  55   000060 000044 
    000373  0a   000077 400000 
    000374  55   000055 000003 
    000375  aa  011 163 145 164         setplist_
    000376  aa  160 154 151 163
    000377  aa  164 137 000 000
    000400  55   000065 000052 
    000401  0a   000071 400000 
    000402  55   000063 000003 
    000403  aa  006 160 154 151         plist_
    000404  aa  163 164 137 000
    000405  55   000072 000060 
    000406  0a   000035 400000 
    000407  55   000070 000003 
    000410  aa  005 147 145 164         getl_
    000411  aa  154 137 000 000
    000412  55   000077 000065 
    000413  0a   000012 400000 
    000414  55   000075 000003 
    000415  aa  004 147 145 164         get_
    000416  aa  137 000 000 000
    000417  55   000002 000072 
    000420  6a   000000 400002 
    000421  55   000102 000003 
    000422  aa  014 163 171 155         symbol_table
    000423  aa  142 157 154 137
    000424  aa  164 141 142 154
    000425  aa  145 000 000 000

DEFINITIONS HASH TABLE

    000426  aa   000000 000015 
    000427  5a   000077 000000 
    000430  aa   000000 000000 
    000431  aa   000000 000000 
    000432  5a   000036 000000 
    000433  5a   000020 000000 
    000434  5a   000044 000000 
    000435  5a   000052 000000 
    000436  5a   000072 000000 
    000437  5a   000025 000000 
    000440  5a   000032 000000 
    000441  5a   000013 000000 
    000442  5a   000060 000000 
    000443  5a   000065 000000 

EXTERNAL NAMES

    000444  aa  013 154 151 163         lisp_error_
    000445  aa  160 137 145 162
    000446  aa  162 157 162 137
    000447  aa  023 142 141 144         bad_arg_correctable
    000450  aa  137 141 162 147
    000451  aa  137 143 157 162
    000452  aa  162 145 143 164
    000453  aa  141 142 154 145
    000454  aa  011 163 164 141         stack_ptr
    000455  aa  143 153 137 160
    000456  aa  164 162 000 000
    000457  aa  011 165 156 155         unmkd_ptr
    000460  aa  153 144 137 160
    000461  aa  164 162 000 000
    000462  aa  005 143 157 156         cons_
    000463  aa  163 137 000 000
    000464  aa  013 154 151 163         lisp_alloc_
    000465  aa  160 137 141 154
    000466  aa  154 157 143 137
    000467  aa  016 143 141 156         cant_set_plist
    000470  aa  164 137 163 145
    000471  aa  164 137 160 154
    000472  aa  151 163 164 000
    000473  aa  021 154 151 163         lisp_error_table_
    000474  aa  160 137 145 162
    000475  aa  162 157 162 137
    000476  aa  164 141 142 154
    000477  aa  145 137 000 000
    000500  aa  024 160 162 157         property_list_of_nil
    000501  aa  160 145 162 164
    000502  aa  171 137 154 151
    000503  aa  163 164 137 157
    000504  aa  146 137 156 151
    000505  aa  154 000 000 000
    000506  aa  021 154 151 163         lisp_static_vars_
    000507  aa  160 137 163 164
    000510  aa  141 164 151 143
    000511  aa  137 166 141 162
    000512  aa  163 137 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    000513  aa   000004 000000 
    000514  55   000124 000124 
    000515  aa   000004 000000 
    000516  55   000153 000127 
    000517  aa   000004 000000 
    000520  55   000166 000134 
    000521  aa   000004 000000 
    000522  55   000166 000137 
    000523  aa   000004 000000 
    000524  55   000144 000142 
    000525  aa   000004 000000 
    000526  55   000153 000147 
    000527  aa   000004 000000 
    000530  55   000166 000160 
    000531  aa   000001 000000 
    000532  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    000533  5a   000173 000000 
    000534  5a   000175 000000 
    000535  5a   000201 000001 
    000536  5a   000177 000000 
    000537  5a   000201 000000 
    000540  5a   000203 000000 
    000541  5a   000205 000000 
    000542  5a   000207 777776 
    000543  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   000320 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000032 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         lisp_static_vars_|property_list_of_nil
    000011  5a   000222 0000 00
    000012  9a   777766 0000 46         lisp_error_table_|cant_set_plist
    000013  5a   000221 0000 00
    000014  9a   777764 0000 46         lisp_alloc_|cons_
    000015  5a   000220 0000 00
    000016  9a   777762 0000 46         lisp_static_vars_|unmkd_ptr
    000017  5a   000217 0000 20
    000020  9a   777760 0000 46         lisp_static_vars_|stack_ptr
    000021  5a   000216 0000 20
    000022  9a   777756 0000 46         lisp_static_vars_|unmkd_ptr
    000023  5a   000215 0000 00
    000024  9a   777754 0000 46         lisp_static_vars_|stack_ptr
    000025  5a   000216 0000 00
    000026  9a   777752 0000 46         lisp_error_table_|bad_arg_correctable
    000027  5a   000214 0000 00
    000030  9a   777750 0000 46         lisp_error_|lisp_error_
    000031  5a   000213 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   677237 545132 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000244 
    000020  aa   000000 000203 
    000021  aa   000000 000224 
    000022  aa   000232 000203 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000005 
    000066  aa   000112 000067 
    000067  aa   147740 446330 
    000070  aa   000000 114774 
    000071  aa   461252 400000 
    000072  aa   000130 000066 
    000073  aa   147714 750316 
    000074  aa   000000 114774 
    000075  aa   453561 000000 
    000076  aa   000146 000047 
    000077  aa   106701 741731 
    000100  aa   000000 110670 
    000101  aa   211444 000000 
    000102  aa   000160 000045 
    000103  aa   120017 346602 
    000104  aa   000000 112002 
    000105  aa   404115 000000 
    000106  aa   000172 000044 
    000107  aa   120017 346605 
    000110  aa   000000 112002 
    000111  aa   404115 200000 
    000112  aa   076163 160145          >special_ldd>install>MR12.0-1206>lisp_property_fns_.alm
    000113  aa   143151 141154 
    000114  aa   137154 144144 
    000115  aa   076151 156163 
    000116  aa   164141 154154 
    000117  aa   076115 122061 
    000120  aa   062056 060055 
    000121  aa   061062 060066 
    000122  aa   076154 151163 
    000123  aa   160137 160162 
    000124  aa   157160 145162 
    000125  aa   164171 137146 
    000126  aa   156163 137056 
    000127  aa   141154 155040 
    000130  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000131  aa   143151 141154 
    000132  aa   137154 144144 
    000133  aa   076151 156163 
    000134  aa   164141 154154 
    000135  aa   076115 122061 
    000136  aa   062056 060055 
    000137  aa   061062 060066 
    000140  aa   076163 164141 
    000141  aa   143153 137150 
    000142  aa   145141 144145 
    000143  aa   162056 151156 
    000144  aa   143154 056141 
    000145  aa   154155 040040 
    000146  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000147  aa   076151 156143 
    000150  aa   154165 144145 
    000151  aa   076154 151163 
    000152  aa   160137 157142 
    000153  aa   152145 143164 
    000154  aa   137164 171160 
    000155  aa   145163 056151 
    000156  aa   156143 154056 
    000157  aa   141154 155040 
    000160  aa   076154 144144          >ldd>include>lisp_name_codes.incl.alm
    000161  aa   076151 156143 
    000162  aa   154165 144145 
    000163  aa   076154 151163 
    000164  aa   160137 156141 
    000165  aa   155145 137143 
    000166  aa   157144 145163 
    000167  aa   056151 156143 
    000170  aa   154056 141154 
    000171  aa   155040 040040 
    000172  aa   076154 144144          >ldd>include>lisp_stack_seg.incl.alm
    000173  aa   076151 156143 
    000174  aa   154165 144145 
    000175  aa   076154 151163 
    000176  aa   160137 163164 
    000177  aa   141143 153137 
    000200  aa   163145 147056 
    000201  aa   151156 143154 
    000202  aa   056141 154155 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         102    append_list_op           lisp_stack_seg:      43.
         200    Array                    lisp_object_types:   25.
         122    array_info_for_store     lisp_stack_seg:      51.
         126    array_link_snap_opr      lisp_stack_seg:      53.
         124    array_offset_for_store   lisp_stack_seg:      52.
         112    array_operator           lisp_stack_seg:      47.
          10    array_pointer            lisp_stack_seg:      10.
       77700    Atomic                   lisp_property_fns_:        62,
                                         lisp_object_types:   19.
       10000    Atsym                    lisp_object_types:   18.
                bad_arg_correctable      lisp_property_fns_:       224.
         100    begin_list_op            lisp_stack_seg:      42.
         174    begin_unmkd_stack        lisp_stack_seg:      66.
        1000    Bignum                   lisp_object_types:   20.
        1000    Big_fixed                lisp_object_types:   29.
          20    bind_op                  lisp_stack_seg:      17.
        1170    call_offset              stack_header:        80.
          32    call_op                  lisp_stack_seg:      22.
         106    cant_set_plist           lisp_property_fns_:       105,  111,  112.
          34    catch1_op                lisp_stack_seg:      23.
          36    catch2_op                lisp_stack_seg:      24.
         106    compare_op               lisp_stack_seg:      45.
                cons_                    lisp_property_fns_:       178,  181.
          72    cons_op                  lisp_stack_seg:      39.
         136    cons_string_op           lisp_stack_seg:      57.
         132    create_array_desc_op     lisp_stack_seg:      55.
         130    create_string_desc_op    lisp_stack_seg:      54.
         140    create_varying_string_op       lisp_stack_seg:      58.
         114    dead_array_operator      lisp_stack_seg:      48.
        1174    entry_offset             stack_header:        84.
         236    error                    lisp_property_fns_:       224,  253,  255.
         237    error00                  lisp_property_fns_:       114,  225.
         235    error1                   lisp_property_fns_:       120,  223.
         275    error2                   lisp_property_fns_:        67,  252.
         277    error3                   lisp_property_fns_:       148,  254.
          24    errset1_op               lisp_stack_seg:      19.
          26    errset2_op               lisp_stack_seg:      20.
          64    err_op                   lisp_stack_seg:      36.
         100    File                     lisp_object_types:   30.
       40000    Fixed                    lisp_object_types:   15.
       40047    fixnum_type              lisp_object_types:   34.
       20000    Float                    lisp_object_types:   16.
         120    floating_store_operator  lisp_stack_seg:      50.
       20047    flonum_type              lisp_object_types:   35.
      777707    fn_abs                   lisp_name_codes:     53.
      777720    fn_add1                  lisp_name_codes:     44.
      777674    fn_add1_fix              lisp_name_codes:     64.
      777673    fn_add1_flo              lisp_name_codes:     65.
      777625    fn_alarmclock            lisp_name_codes:    103.
      777611    fn_allfiles              lisp_name_codes:    115.
      777617    fn_alphalessp            lisp_name_codes:    109.
      777657    fn_apply                 lisp_name_codes:     77.
      777765    fn_arg                   lisp_name_codes:     10.
      777727    fn_args                  lisp_name_codes:     37.
      777740    fn_array                 lisp_name_codes:     28.
      777537    fn_arraydims             lisp_name_codes:    157.
      777751    fn_ascii                 lisp_name_codes:     19.
      777631    fn_atan                  lisp_name_codes:     99.
      777650    fn_baktrace              lisp_name_codes:     84.
      777647    fn_bltarray              lisp_name_codes:     85.
      777705    fn_boole                 lisp_name_codes:     55.
      777643    fn_boundp                lisp_name_codes:     89.
      777654    fn_catch                 lisp_name_codes:     80.
      777741    fn_catenate              lisp_name_codes:     27.
      777544    fn_charpos               lisp_name_codes:    152.
      777610    fn_chrct                 lisp_name_codes:    116.
      777557    fn_clear_input           lisp_name_codes:    141.
      777553    fn_cline                 lisp_name_codes:    145.
      777607    fn_close                 lisp_name_codes:    117.
      777637    fn_cos                   lisp_name_codes:     93.
      777732    fn_CtoI                  lisp_name_codes:     34.
      777561    fn_cursorpos             lisp_name_codes:    139.
      777756    fn_defaultf              lisp_name_codes:     17.
      777747    fn_definedp              lisp_name_codes:     21.
      777731    fn_defsubr               lisp_name_codes:     35.
      777651    fn_defun                 lisp_name_codes:     83.
      777744    fn_delete                lisp_name_codes:     24.
      777606    fn_deletef               lisp_name_codes:    118.
      777743    fn_delq                  lisp_name_codes:     25.
      777711    fn_difference            lisp_name_codes:     51.
      777664    fn_diff_fix              lisp_name_codes:     72.
      777663    fn_diff_flo              lisp_name_codes:     73.
      777516    fn_displace              lisp_name_codes:    174.
      777766    fn_do                    lisp_name_codes:      9.
      777535    fn_dumparrays            lisp_name_codes:    159.
      777540    fn_endpagefn             lisp_name_codes:    156.
      777605    fn_eoffn                 lisp_name_codes:    119.
      777621    fn_eql                   lisp_name_codes:    107.
      777760    fn_errframe              lisp_name_codes:     15.
      777761    fn_errprint              lisp_name_codes:     14.
      777655    fn_errset                lisp_name_codes:     79.
      777660    fn_eval                  lisp_name_codes:     76.
      777757    fn_evalframe             lisp_name_codes:     16.
      777520    fn_eval_when             lisp_name_codes:    172.
      777635    fn_exp                   lisp_name_codes:     95.
      777706    fn_expt                  lisp_name_codes:     54.
      777534    fn_expt_fix              lisp_name_codes:    160.
      777533    fn_expt_flo              lisp_name_codes:    161.
      777604    fn_filepos               lisp_name_codes:    120.
      777552    fn_fillarray             lisp_name_codes:    146.
      777701    fn_fix                   lisp_name_codes:     59.
      777700    fn_float                 lisp_name_codes:     60.
      777560    fn_force_output          lisp_name_codes:    140.
      777640    fn_freturn               lisp_name_codes:     92.
      777524    fn_fsc                   lisp_name_codes:    168.
      777612    fn_gcd                   lisp_name_codes:    114.
      777645    fn_gensym                lisp_name_codes:     87.
      777725    fn_get                   lisp_name_codes:     39.
      777615    fn_getchar               lisp_name_codes:    111.
      777724    fn_getl                  lisp_property_fns_:        66,
                                         lisp_name_codes:     40.
      777735    fn_get_pname             lisp_name_codes:     31.
      777716    fn_greaterp              lisp_name_codes:     46.
      777620    fn_gt                    lisp_name_codes:    108.
      777554    fn_haipart               lisp_name_codes:    144.
      777555    fn_haulong               lisp_name_codes:    143.
      777525    fn_ifix                  lisp_name_codes:    167.
      777530    fn_in                    lisp_name_codes:    164.
      777513    fn_includef              lisp_name_codes:    177.
      777736    fn_index                 lisp_name_codes:     30.
      777603    fn_inpush                lisp_name_codes:    121.
      777632    fn_isqrt                 lisp_name_codes:     98.
      777733    fn_ItoC                  lisp_name_codes:     33.
      777715    fn_lessp                 lisp_name_codes:     47.
      777602    fn_linel                 lisp_name_codes:    122.
      777542    fn_linenum               lisp_name_codes:    154.
      777551    fn_listarray             lisp_name_codes:    147.
      777545    fn_listify               lisp_name_codes:    151.
      777536    fn_loadarrays            lisp_name_codes:    158.
      777634    fn_log                   lisp_name_codes:     96.
      777622    fn_ls                    lisp_name_codes:    106.
      777703    fn_lsh                   lisp_name_codes:     57.
      777734    fn_make_atom             lisp_name_codes:     32.
      777644    fn_makunbound            lisp_name_codes:     88.
      777522    fn_mapatoms              lisp_name_codes:    170.
      777676    fn_max                   lisp_name_codes:     62.
      777601    fn_mergef                lisp_name_codes:    123.
      777675    fn_min                   lisp_name_codes:     63.
      777714    fn_minus                 lisp_name_codes:     48.
      777623    fn_minusp                lisp_name_codes:    105.
      777600    fn_namelist              lisp_name_codes:    124.
      777577    fn_names                 lisp_name_codes:    125.
      777576    fn_namestring            lisp_name_codes:    126.
      777532    fn_nointerrupt           lisp_name_codes:    162.
      777515    fn_nth                   lisp_name_codes:    175.
      777514    fn_nthcdr                lisp_name_codes:    176.
      777627    fn_oddp                  lisp_name_codes:    101.
      777531    fn_open                  lisp_name_codes:    163.
      777614    fn_opena                 lisp_name_codes:    112.
      777575    fn_openi                 lisp_name_codes:    127.
      777574    fn_openo                 lisp_name_codes:    128.
      777527    fn_out                   lisp_name_codes:    165.
      777543    fn_pagel                 lisp_name_codes:    153.
      777541    fn_pagenum               lisp_name_codes:    155.
      777713    fn_plus                  lisp_name_codes:     49.
      777624    fn_plusp                 lisp_name_codes:    104.
      777670    fn_plus_fix              lisp_name_codes:     68.
      777667    fn_plus_flo              lisp_name_codes:     69.
      777573    fn_prin1                 lisp_name_codes:    129.
      777572    fn_princ                 lisp_name_codes:    130.
      777571    fn_print                 lisp_name_codes:    131.
      777656    fn_prog                  lisp_name_codes:     78.
      777523    fn_progv                 lisp_name_codes:    169.
      777723    fn_putprop               lisp_property_fns_:       147,
                                         lisp_name_codes:     41.
      777710    fn_quotient              lisp_name_codes:     52.
      777662    fn_quot_fix              lisp_name_codes:     74.
      777661    fn_quot_flo              lisp_name_codes:     75.
      777556    fn_random                lisp_name_codes:    142.
      777570    fn_read                  lisp_name_codes:    132.
      777567    fn_readch                lisp_name_codes:    133.
      777566    fn_readstring            lisp_name_codes:    134.
      777517    fn_read_from_string      lisp_name_codes:    173.
      777677    fn_remainder             lisp_name_codes:     61.
      777722    fn_remprop               lisp_property_fns_:       119,
                                         lisp_name_codes:     42.
      777565    fn_rename                lisp_name_codes:    135.
      777704    fn_rot                   lisp_name_codes:     56.
      777750    fn_rplaca                lisp_name_codes:     20.
      777616    fn_samepnamep            lisp_name_codes:    110.
      777721    fn_save                  lisp_name_codes:     43.
      777745    fn_set                   lisp_name_codes:     23.
      777764    fn_setarg                lisp_name_codes:     11.
      777746    fn_setq                  lisp_name_codes:     22.
      777562    fn_setsyntax             lisp_name_codes:    138.
      777564    fn_shortnamestring       lisp_name_codes:    136.
      777702    fn_signp                 lisp_name_codes:     58.
      777636    fn_sin                   lisp_name_codes:     94.
      777630    fn_sleep                 lisp_name_codes:    100.
      777550    fn_sort                  lisp_name_codes:    148.
      777547    fn_sortcar               lisp_name_codes:    149.
      777633    fn_sqrt                  lisp_name_codes:     97.
      777762    fn_sstatus               lisp_name_codes:     13.
      777730    fn_star_array            lisp_name_codes:     36.
      777646    fn_star_rearray          lisp_name_codes:     86.
      777641    fn_star_sstatus          lisp_name_codes:     91.
      777642    fn_star_status           lisp_name_codes:     90.
      777763    fn_status                lisp_name_codes:     12.
      777652    fn_store                 lisp_name_codes:     82.
      777742    fn_stringlength          lisp_name_codes:     26.
      777717    fn_sub1                  lisp_name_codes:     45.
      777672    fn_sub1_fix              lisp_name_codes:     66.
      777671    fn_sub1_flo              lisp_name_codes:     67.
      777737    fn_substr                lisp_name_codes:     29.
      777613    fn_sxhash                lisp_name_codes:    113.
      777726    fn_sysp                  lisp_name_codes:     38.
      777653    fn_throw                 lisp_name_codes:     81.
      777712    fn_times                 lisp_name_codes:     50.
      777666    fn_times_fix             lisp_name_codes:     70.
      777665    fn_times_flo             lisp_name_codes:     71.
      777526    fn_truename              lisp_name_codes:    166.
      777563    fn_tyi                   lisp_name_codes:    137.
      777626    fn_tyipeek               lisp_name_codes:    102.
      777752    fn_tyo                   lisp_name_codes:     18.
      777521    fn_unwind_protect        lisp_name_codes:    171.
      777546    fn_zerop                 lisp_name_codes:    150.
          42    gensym_data              lisp_stack_seg:      26.
         207    get                      lisp_property_fns_:       195,  197.
         213    getl                     lisp_property_fns_:       195,  201.
          35    getl_                    lisp_property_fns_:        60,   61,   68,  202.
          50    getl_lp                  lisp_property_fns_:        73,   92.
          56    getl_lp1                 lisp_property_fns_:        80,   86.
          67    getl_next                lisp_property_fns_:        82,   91.
          45    getl_ok                  lisp_property_fns_:        63,   65,   70.
          12    get_                     lisp_property_fns_:        37,   38,  198.
          15    get_loop                 lisp_property_fns_:        42,   49.
           0    get_plist                lisp_property_fns_:        13,   38,   70,   95,  103,  123,  150,  183.
          10    get_plist_of_nil         lisp_property_fns_:        25,   31.
          16    in_pl1_code              lisp_property_fns_:       210,  219,  234,  244,
                                         lisp_stack_seg:      13.
          46    iogbind_op               lisp_stack_seg:      29.
         150    irest_return_op          lisp_stack_seg:      62.
         110    link_opr                 lisp_stack_seg:      46.
                lisp_alloc_              lisp_property_fns_:       178,  181.
                lisp_error_              lisp_property_fns_:       237.
                lisp_error_table_        lisp_property_fns_:       112,  224.
       77700    lisp_ptr.type            lisp_object_types:   13.
                lisp_static_vars_        lisp_property_fns_:        32,  207,  208,  209,  217,  218,  232,  233,  241,  242,  243.
         161    make_new_cells           lisp_property_fns_:       157,  168.
           0    marked_stack_bottom      lisp_stack_seg:       6.
          74    ncons_op                 lisp_stack_seg:      40.
          12    nil                      lisp_property_fns_:        24,   43,   57,   64,   74,   81,   97,  128,  156,
                                         lisp_stack_seg:      11.
         302    noargs                   lisp_property_fns_:       236,  258.
       61400    Numeric                  lisp_object_types:   17.
         152    pl1_call_nopop_op        lisp_stack_seg:      63.
         134    pl1_call_op              lisp_stack_seg:      56.
          66    pl1_interface            lisp_stack_seg:      37.
          70    pl1_lsubr_interface      lisp_stack_seg:      38.
         217    pl1_to_lisp              lisp_property_fns_:       197,  199,  201,  203,  206.
          71    plist_                   lisp_property_fns_:        94,   95.
                property_list_of_nil     lisp_property_fns_:        32.
        1171    push_offset              stack_header:        81.
         211    putprop                  lisp_property_fns_:       195,  199.
         141    putprop_                 lisp_property_fns_:       145,  150,  200.
         137    putprop_loses            lisp_property_fns_:       146,  152.
         145    put_loop                 lisp_property_fns_:       155,  162.
         154    rcv_char_star_op         lisp_stack_seg:      64.
         215    remprop                  lisp_property_fns_:       195,  203.
         114    remprop_                 lisp_property_fns_:       117,  123,  204.
         112    remprop_loses            lisp_property_fns_:       118,  125.
         120    rem_loop                 lisp_property_fns_:       127,  135.
         131    rem_property             lisp_property_fns_:       133,  137.
          27    retrn                    lisp_property_fns_:        52,  100,  166.
          26    retrn_aq                 lisp_property_fns_:        44,   51,   58,   75,   89,  109,  129,  143,  190.
          33    retrn_nil                lisp_property_fns_:        40,   57,   72.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          62    return_op                lisp_stack_seg:      35.
          77    setplist_                lisp_property_fns_:       102,  103,  115.
          56    signp_op                 lisp_stack_seg:      33.
          73    stach_header.trace_top_ptr     stack_header:        62.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     lisp_property_fns_:       239,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
                stack_ptr                lisp_property_fns_:       208,  217,  232,  242.
           4    stack_ptr_ptr            lisp_stack_seg:       8.
         116    store_operator           lisp_stack_seg:      49.
        4000    String                   lisp_object_types:   22.
        2000    Subr                     lisp_object_types:   23.
          44    system_lp                lisp_stack_seg:      28.
         400    System_Subr              lisp_object_types:   24.
         104    terminate_list_op        lisp_stack_seg:      44.
          52    throw1_op                lisp_stack_seg:      31.
          54    throw2_op                lisp_stack_seg:      32.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
          14    true                     lisp_stack_seg:      12.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
          60    type_fields              lisp_stack_seg:      34.
          22    unbind_op                lisp_stack_seg:      18.
          40    uncatch_op               lisp_stack_seg:      25.
       60000    Uncollectable            lisp_object_types:   21.
          30    unerrset_op              lisp_stack_seg:      21.
       67500    Unevalable               lisp_property_fns_:        26,
                                         lisp_object_types:   27.
                unmkd_ptr                lisp_property_fns_:       207,  209,  218,  233,  241,  243.
           6    unmkd_ptr_ptr            lisp_stack_seg:       9.
           2    unmkd_stack_bottom       lisp_stack_seg:       7.
          50    unseen_go_tag_op         lisp_stack_seg:      30.
         146    ununwp_op                lisp_stack_seg:      61.
         142    unwp1_op                 lisp_stack_seg:      59.
         144    unwp2_op                 lisp_stack_seg:      60.
          76    xcons_op                 lisp_stack_seg:      41.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
