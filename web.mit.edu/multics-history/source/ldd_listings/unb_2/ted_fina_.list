	COMPILATION LISTING OF SEGMENT ted_fina_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/23/82  1458.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
        7 /**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
        8 /**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
        9 /**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
       10 
       11 ted_fiad_:			/* fill/adjust a region	       */
       12    proc (ted_support_p, msg, code);
       13       adjust = "1"b;
       14       goto start;
       15 
       16 ted_fina_:			/* fill/adjust a region	       */
       17    entry (ted_support_p, msg, code);
       18       adjust = ""b;
       19       goto start;
       20 
       21 dcl (
       22     msg		char (168) var,	/* error message text	 [OUT] */
       23     code		fixed bin (35)	/* return code		       */
       24     )		parm;
       25 
       26 
       27 dcl ioa_$nnl	entry () options (variable);
       28 dcl ioa_		entry () options (variable);
       29 
       30 dcl (NL		init ("
       31 "),
       32      HT		init ("	")
       33     )		char (1) int static options (constant);
       34 
       35 
       36 start:
       37       if (ted_support.version ^= ted_support_version_2)
       38       then do;
       39          code = error_table_$unimplemented_version;
       40          return;
       41       end;
       42       req.nc = req.cc;		/* any request data after be used    */
       43       code = 0;
       44 
       45       req.cc = req.cc + verify (substr (rstr, req.cc), " ") - 1;
       46       if (inp.de = 0)
       47       then call error ("Abe) Buffer empty.");
       48 error: proc (err);
       49 
       50 dcl err		char (*);
       51 
       52          msg = err;
       53          req.nc = req.cc;
       54          if adjust
       55          then msg = msg || " |fiad";
       56          else msg = msg || " |fina";
       57          code = tederror_table_$Error_Msg;
       58          goto exit;
       59       end error;
       60       zsb = inp.sb;
       61       zse = inp.se;
       62 
       63       delim = rchr (req.cc);		/* pick up str delimiter	       */
       64       if (delim = " ")
       65       then call error ("Sd1) No 1st delimiter.");
       66       matchloc = req.cc + 1;		/* index of first char of str1       */
       67       matchleng = index (substr (rstr, req.cc + 1), delim);
       68       if (matchleng = 0)
       69       then call error ("Sd2) No 2nd delimiter.");
       70       req.cc = matchloc + matchleng;
       71       matchleng = matchleng - 1;
       72 
       73       call get_num ("Slm) No left margin.");
       74       lmarg (1), lmarg (2) = num;
       75 
       76       if (rchr (req.cc) ^= ",")
       77       then call error ("Smc) Missing comma.");
       78       req.cc = req.cc + 1;
       79       call get_num ("Srm) No right margin.");
       80       if (num < lmarg (1))
       81       then call error ("Srl) Right margin < left margin.");
       82       rmarg = num;
       83       if (rchr (req.cc) = ",")
       84       then do;
       85          req.cc = req.cc + 1;
       86          call get_num ("Sni) No indent.");
       87          if (num > rmarg)
       88          then call error ("Sir) Indent > right margin.");
       89          lmarg (1) = num;
       90       end;
       91       if (rchr (req.cc) ^= delim)
       92       then call error ("Sd3) No 3rd delimiter.");
       93       req.nc = req.cc + 1;
       94       putted = 0;
       95       marg = 1;
       96       left_set = "0"b;
       97       hole_ct = -1;
       98       visleng, wordleng = 0;
       99       firstime = "1"b;
      100       if (zsb < zse)
      101       then do;
      102          do while (zsb <= zse);
      103 	  if firstime
      104 	  then do;
      105 	     ch = NL;
      106 	     firstime = "0"b;
      107 	  end;
      108 	  else do;
      109 	     ch = ichr (zsb);
      110 	     zsb = zsb + 1;
      111 	  end;
      112 	  if (ch = NL)
      113 	  then do;
      114 	     call putword;
      115 	     if (zsb <= zse)
      116 	     then do;
      117 	        if (ichr (zsb) = NL)
      118 	        then do;
      119 		 visleng, wordleng = 9999;
      120 		 call putword;
      121 		 marg = 1;
      122 		 left_set = "0"b;
      123 	        end;
      124 	        else if (matchleng > 0)
      125 	        then if (substr (istr, zsb, matchleng)
      126 		      = substr (rstr, matchloc, matchleng))
      127 		   then do;
      128 		      zle = index (substr (istr, zsb, (zse - zsb + 1)), NL);
      129 				/* find end of next line	       */
      130 		      if (zle = 0)	/* worry about no NL	       */
      131 		      then zle = zse; /* ..at end of buffer	       */
      132 		      else zle = zsb + zle - 1;
      133 		      visleng, wordleng = 9999;
      134 		      call putword;
      135 		      wordloc = zsb;
      136 		      visleng, wordleng = zle - zsb;
      137 		      putted = -wordleng;
      138 		      if (out.de > 0)
      139 		      then out.de = out.de - 1;
      140 		      call putword;
      141 		      if db_sw then call ioa_$nnl ("!!^/");
      142 		      hole_ct = -1;
      143 		      putted = 0;
      144 		      zsb = zle;
      145 		   end;
      146 	     end;
      147 	  end;
      148 	  else if (ch = " ") | (ch = HT)
      149 	  then call putword;
      150 	  else do;
      151 	     if (wordleng = 0)
      152 	     then wordloc = zsb - 1;
      153 	     wordleng = wordleng + 1;
      154 	     if (ch ^= "")
      155 	     then visleng = visleng + 1;
      156 	     else visleng = visleng - 1;
      157 	  end;
      158          end;
      159          if wordleng > 0
      160          then call putword;
      161       end;
      162 
      163       if (out.de = 0)
      164       then out.de = 1;
      165       substr (ostr, out.de, 1) = NL;
      166       current = out.de;
      167       code = tederror_table_$Copy_Set;
      168 exit:
      169       return;
      170 
      171 putword: proc;
      172 
      173       if (wordleng > 0)
      174       then do;
      175          if (putted + visleng > rmarg)
      176          then do;
      177 	  if adjust
      178 	  then call fixup;
      179 	  hole_ct = -1;
      180 	  putted = 0;
      181 	  if (wordleng = 9999)
      182 	  then do;
      183 	     visleng, wordleng = 0;
      184 	     if (out.de > 0)
      185 	     then do;
      186 	        if db_sw then call ioa_$nnl ("!^/");
      187 	        substr (ostr, out.de, 1) = NL;
      188 	        out.de = out.de + 1;
      189 	     end;
      190 	     return;
      191 	  end;
      192          end;
      193          if (putted = 0)
      194          then do;
      195 	  if db_sw then call ioa_$nnl ("^/^vx", lmarg (marg));
      196 	  if (out.de > 0)
      197 	  then substr (ostr, out.de, lmarg (marg)) = NL;
      198 	  else substr (ostr, 1, lmarg (marg)) = " ";
      199 	  putted = lmarg (marg) - 1;
      200 	  out.de = out.de + lmarg (marg) - 1;
      201 	  lineloc = out.de + 1;
      202          end;
      203          virtleng = wordleng;
      204          if (marg = 1)
      205          then if (visleng < lmarg (2) - lmarg (1))
      206 	    then do;
      207 	       virtleng = wordleng + (lmarg (2) - lmarg (1)) - visleng - 1;
      208 	       visleng = lmarg (2) - lmarg (1) - 1;
      209 	       lineloc = out.de + virtleng + 2;
      210 	       hole_ct = hole_ct - 1;
      211 	    end;
      212          if db_sw then call ioa_$nnl ("^va ", virtleng,
      213 	       substr (istr, wordloc, wordleng));
      214          substr (ostr, out.de + 1, virtleng + 1)
      215 	  = substr (istr, wordloc, wordleng);
      216          out.de = out.de + virtleng + 1;
      217          putted = putted + visleng + 1;
      218          hole_ct = hole_ct + 1;
      219          visleng, wordleng = 0;
      220          marg = 2;
      221       end;
      222 
      223    end putword; 
      224 
      225 fixup: proc;			/* do the adjusting		       */
      226 
      227       if (putted ^= 0) & (hole_ct > 0) & (wordleng ^= 9999)
      228       then do;
      229          leftover = rmarg - putted + 1;
      230          temploc = 1;
      231          templeng = out.de - lineloc + 1;
      232          begin;
      233 dcl temp_area	char (templeng + 1);
      234 	  if db_sw
      235 	  then call ioa_$nnl ("^/***^d holes (temp,^d,^d)=(ostr,^d,^d)",
      236 		hole_ct, temploc, templeng + 1, lineloc, templeng);
      237 	  substr (temp_area, temploc, templeng + 1)
      238 	     = substr (ostr, lineloc, templeng);
      239 	  if db_sw
      240 	  then call ioa_$nnl ("^/");
      241 	  out.de = lineloc - 1;
      242 	  fill = divide (leftover, hole_ct, 17, 0);
      243 	  leftover = mod (leftover, hole_ct);
      244 	  if left_set
      245 	  then incr = -1;
      246 	  else do;
      247 	     incr = 1;
      248 	     leftover = leftover - hole_ct + 1;
      249 	  end;
      250 	  do i = 1 to hole_ct;
      251 	     j = index (substr (temp_area, temploc, templeng), " ");
      252 	     moveleng = j + fill + fixed ((leftover > 0), 17);
      253 	     leftover = leftover + incr;
      254 	     if db_sw then call ioa_$nnl ("^va", moveleng,
      255 		   substr (temp_area, temploc, j));
      256 	     substr (ostr, out.de + 1, moveleng)
      257 	        = substr (temp_area, temploc, j);
      258 	     out.de = out.de + moveleng;
      259 	     temploc = temploc + j;
      260 	     templeng = templeng - j;
      261 	  end;
      262 	  if (templeng > 0)
      263 	  then substr (ostr, out.de + 1, templeng)
      264 		= substr (temp_area, temploc, templeng);
      265 	  if db_sw then call ioa_$nnl ("^a|^/",
      266 		substr (ostr, out.de + 1, templeng));
      267 	  out.de = out.de + templeng;
      268          end;
      269       end;
      270       left_set = ^left_set;
      271    end fixup;
      272 dcl num		fixed bin (21);
      273 dcl num_sw	bit (1);
      274 
      275 get_num: proc (err);
      276 dcl err		char (*);
      277 
      278       i = verify (substr (rstr, req.cc), "0123456789");
      279       if (i > 1)
      280       then do;
      281          num = fixed (substr (rstr, req.cc, i - 1));
      282          req.cc = req.cc + i - 1;
      283          if (num = 0)
      284          then i = 1;
      285       end;
      286       if (i = 1)
      287       then call error (err);
      288 
      289    end get_num; 
      290 
      291 dcl zle		fixed bin (21);
      292 dcl zsb		fixed bin (21);
      293 dcl zse		fixed bin (21);
      294 dcl concealsw	bit (1);
      295 dcl delim		char (1);
      296 dcl i		fixed bin (21);
      297 dcl j		fixed bin (21);
      298 dcl scan_leng	fixed bin (21);
      299 dcl adjust	bit (1);
      300 dcl fill		fixed bin (21);
      301 dcl firstime	bit (1);
      302 dcl hole_ct	fixed bin (21);
      303 dcl incr		fixed bin (21);
      304 dcl left_set	bit (1);
      305 dcl leftover	fixed bin (21);
      306 dcl lineloc	fixed bin (21);
      307 dcl lmarg		(2) fixed bin (21);
      308 dcl marg		fixed bin (21);
      309 dcl matchleng	fixed bin (21);
      310 dcl matchloc	fixed bin (21);
      311 dcl moveleng	fixed bin (21);
      312 dcl pb		fixed bin (21);
      313 dcl putted	fixed bin (21);
      314 dcl rmarg		fixed bin (21);
      315 dcl templeng	fixed bin (21);
      316 dcl temploc	fixed bin (21);
      317 dcl wordleng	fixed bin (21);
      318 dcl wordloc	fixed bin (21);
      319 dcl virtleng	fixed bin (21);
      320 dcl visleng	fixed bin (21);
      321 dcl ch		char (1);
  1     1 /* BEGIN INCLUDE FILE ..... ted_support.incl.pl1 ..... 03/16/81	       */
  1     2 
  1     3 /* more information may be found in ted_support.gi.info		       */
  1     4 
  1     5 dcl  ted_support_p ptr;
  1     6 dcl ted_support_version_2 fixed bin int static init(2);
  1     7 dcl 1 ted_support based(ted_support_p),
  1     8     2 version fixed bin,	/* 1				       */
  1     9     2 addr_ct fixed bin,	/* number of addresses given: 0,1,2 	  (IN) */
  1    10     2 checkpoint entry (	/* routine to update "safe" status        (IN) */
  1    11 	fixed bin(21),	/* amount of input used up		       */
  1    12 	fixed bin(21)),	/* amount of output used up		       */
  1    13 
  1    14     2 inp,		/***** input string parameters	       */
  1    15 			/* The input data may NOT be modified.	       */
  1    16       3 pt ptr,		/* pointer to base of data string         (IN) */
  1    17       3 sb fixed bin(21),	/* index of addressed string begin        (IN) */
  1    18       3 lno fixed bin(21),	/* linenumber in data string of sb        (IN) */
  1    19       3 se fixed bin(21),	/* index of addressed string end      (IN/OUT) */
  1    20       3 de fixed bin(21),	/* index of data end		  (IN) */
  1    21 
  1    22     2 out,		/***** output string parameters	       */
  1    23       3 pt ptr,		/* pointer to base of output string       (IN) */
  1    24       3 de fixed bin(21),	/* index of data end (already copied) (IN/OUT) */
  1    25       3 ml fixed bin(21),	/* max length of output string	  (IN) */
  1    26 
  1    27     2 req,		/***** request string parameters	       */
  1    28       3 pt ptr,		/* pointer to base of request string	  (IN) */
  1    29       3 cc fixed bin(21),	/* index of current character		  (IN) */
  1    30       3 nc fixed bin(21),	/* index of next character	        (IN/OUT) */
  1    31       3 de fixed bin(21),	/* index of data end	        (IN/OUT) */
  1    32       3 ml fixed bin(21),	/* max length of requsest buffer 	  (IN) */
  1    33 
  1    34 /* req.nc is initialized to req.de, i.e.  request line used-up.  A routine   */
  1    35 /* can set req.nc to 1, put some data into req and set req.de	       */
  1    36 /* appropriately.  The data will be the next ted requests executed after     */
  1    37 /* the routine returns.					       */
  1    38 			
  1    39 /* Or if req.nc is set equal to req.cc then the rest of the request line     */
  1    40 /* will be executed after return.				       */
  1    41 
  1    42     2 string_mode bit(1),	/* 0- line mode, 1- string mode 	  (IN) */
  1    43     2 current fixed bin(21),	/* current location		        (IN/OUT) */
  1    44 			/* current is initialized to "undefined"       */
  1    45     2 get_req entry (),	/* fill the request string with the next line  */
  1    46 			/*  from ted's input stream. req.de will be    */
  1    47 			/*  updated to reflect the new length.	       */
  1    48 			/* req.cc and req.nc are not changed.	       */
  1    49     2 proc_expr entry	/* process the expression for global execution */
  1    50 	(ptr,		/* -> ted_support structure		  [IN] */
  1    51 	char (168) var,	/* message text			 [OUT] */
  1    52 	fixed bin (35)),	/* completion code			 [OUT] */
  1    53     2 do_global entry	/* globally execute some action	       */
  1    54 	(entry (),	/* worker procedure			  [IN] */
  1    55 	char (1),		/* which action, "g" or "v"		  [IN] */
  1    56 	ptr,		/* -> ted_support structure		  [IN] */
  1    57 	char (168) var,	/* message text			 [OUT] */
  1    58 	fixed bin (35)),	/* completion code			 [OUT] */
  1    59     2 reg_exp_p ptr,	/* -> the remembered regular expression area   */
  1    60     2 bcb_p ptr;		/* -> buffer control block		       */
  1    61 /* _________________________________________________________________________ */
  1    62 /*			 ENTRY CONDITIONS			       */
  1    63 /* _________________________________________________________________________ */
  1    64 /* Upon entering, three substructures describe the environment in which the  */
  1    65 /* request is to operate. (Refer to the INPUT diagram) Note that the	       */
  1    66 /* "normal" operational steps are:				       */
  1    67 /* 1) ted copies the string from 1:inp.sb-1 to the output string	       */
  1    68 /* 2) ted_xyz_ takes care of the data from inp.sb:inp.se		       */
  1    69 /* 3) ted copies the string from inp.se+1:inp.de to the output string	       */
  1    70 /* The following 3 diagrams represent conditions upon entering ted_xyz_:     */
  1    71 /* _________________________________________________________________________ */
  1    72 /*	       inp.pt		(\ represents NL)		       */
  1    73 /*		|					       */
  1    74 /* [INPUT]	now is\the time\for all\good men\to come.\.....	       */
  1    75 /*		       |               |                 |	       */
  1    76 /*		    inp.sb          inp.se            inp.de	       */
  1    77 /* _________________________________________________________________________ */
  1    78 /*	       out.pt		(\ represents NL)		       */
  1    79 /*    		|					       */
  1    80 /* [OUTPUT]  ?	now is\........................................	       */
  1    81 /*	   |	      |                                       |	       */
  1    82 /*	current	   out.de				   out.ml	       */
  1    83 /* _________________________________________________________________________ */
  1    84 /*	       req.pt		(\ represents NL)		       */
  1    85 /*    		|					       */
  1    86 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  1    87 /*		          |            |                      |	       */
  1    88 /*		       req.cc       req.de		   req.ml	       */
  1    89 /*				req.nc			       */
  1    90 
  1    91 /* _________________________________________________________________________ */
  1    92 /*			 EXIT CONDITIONS			       */
  1    93 /* _________________________________________________________________________ */
  1    94 /* Assume a request replaces the addressed lines with the string following   */
  1    95 /* it, (in this case "farfle") and leaves "." at the beginning of the range. */
  1    96 /*	       out.pt		(\ represents NL)		       */
  1    97 /*    		|					       */
  1    98 /* [OUTPUT]	now is\farfle\farfle\..........................	       */
  1    99 /*		       |            |                         |	       */
  1   100 /*		   current       out.de		   out.ml	       */
  1   101 /* _________________________________________________________________________ */
  1   102 /* 1) If the data after the string are to be treated as more ted requests,   */
  1   103 /*  the request data would be left like this.			       */
  1   104 /*	       req.pt		(\ represents NL)		       */
  1   105 /*    		|					       */
  1   106 /* [REQUEST]	x 2,3|req /farfle/ 1,$P\.......................	       */
  1   107 /*		                   |   |                      |	       */
  1   108 /*			    req.nc   req.de		   req.ml	       */
  1   109 /* _________________________________________________________________________ */
  1   110 /* 2) If the request is going to return a string to be executed, the request */
  1   111 /*  data (and buffer) would be left like this:			       */
  1   112 /*	       req.pt		(\ represents NL)		       */
  1   113 /*    		|        					       */
  1   114 /* [REQUEST]	-1,.1p w\ /farfle/ 1,$P\.......................	       */
  1   115 /*		|       |                                     |	       */
  1   116 /*	       req.nc  req.de			   req.ml	       */
  1   117 
  1   118 /* These return codes are expected				       */
  1   119 dcl (tederror_table_$Copy_Set,/* copy rest of input to output,	       */
  1   120 			/*   and set "." from current		       */
  1   121 			/* "rest of input" is the string which begins  */
  1   122 			/*  at char inp.se+1 and extends to inp.de.    */
  1   123 			/*  If the input has all been processed, then  */
  1   124 			/*  inp.se should be set to inp.de+1.	       */
  1   125      tederror_table_$NoChange,/* dont copy, dont set current	       */
  1   126      tederror_table_$Set,	/* dont copy, just set current	       */
  1   127 			/*   (in input buffer)		       */
  1   128      tederror_table_$Error_Msg,/* msg is being returned.		       */
  1   129 			/*  no copy or set is done		       */
  1   130      tederror_table_$No_Delim1,/* missing 1st delimiter		       */
  1   131      tederror_table_$No_Delim2,/* missing 2nd delimiter		       */
  1   132      tederror_table_$No_Delim3)/* missing 3nd delimiter		       */
  1   133 		fixed bin(35)ext static;
  1   134 dcl  error_table_$unimplemented_version fixed bin(35) ext static;
  1   135 
  1   136 dcl  istr char(inp.de) based(inp.pt);	/* the input string		       */
  1   137 dcl  ichr(inp.de) char(1) based(inp.pt);
  1   138 dcl  ostr char(out.ml) based(out.pt);	/* the output string	       */
  1   139 dcl  ochr(out.ml) char(1) based(out.pt);
  1   140 dcl  rstr char(req.ml) based(req.pt);	/* the request string	       */
  1   141 dcl  rchr(req.ml) char(1) based(req.pt);
  1   142 
  1   143 /* These declarations are used if the expression search is needed by the     */
  1   144 /* request. There are 2 parts to getting an expression search done:	       */
  1   145 /* 	1) compiling	2) searching			       */
  1   146 /* If a function uses the remembered expression, it does this:	       */
  1   147 /*	call tedsrch_$search (ted_support.reg_exp_p,		       */
  1   148 /*	  ted_support.bcbp, string_begin, string_end, match_begin,	       */
  1   149 /*	  match_end, search_end, msg, code);			       */
  1   150 
  1   151 /* If a function utilizes an expression the user supplies, it must first be  */
  1   152 /* compiled:
  1   153*/*	if (expression_length > 0)				       */
  1   154 /*	then call tedsrch_$compile (addr (ichr (expression_begin)),	       */
  1   155 /*	  expression_length, ted_support.reg_exp_p,		       */
  1   156 /*	  ted_support.string_mode, ""b, msg, code);		       */
  1   157 /* This results in the remembered expression being changed to the one just   */
  1   158 /* compiled.						       */
  1   159 
  1   160 /* If a function wishes to utilize a function without it being remembered    */
  1   161 /* by ted, it may declare an area of its own and compile into it. It first   */
  1   162 /* must be initialized:					       */
  1   163 /*	dcl expr_area (200) bit (36);				       */
  1   164 /*	call tedsrch_$init_exp (addr (expr_area), size (expr_area));       */
  2     1 /* BEGIN INCLUDE FILE ..... tedsrch_.incl.pl1 ..... 10/21/82 J Falksen */
  2     2 
  2     3 dcl tedsrch_$init_exp entry (		/* initialize an expression area     */
  2     4 		ptr,		/* -> compiled expression area  [IN] */
  2     5 		fixed bin (21));	/*   length of area in words	       */
  2     6 
  2     7 dcl tedsrch_$compile entry (		/* compile a regular expression      */
  2     8 		ptr,		/* -> regular expression to search   */
  2     9 		fixed bin (21),	/*   length thereof 	       */
  2    10 		ptr,		/* -> compiled expression area  [IN] */
  2    11 		bit (1)aligned,	/* 0- line mode	1- string mode   */
  2    12 		bit (1)aligned,	/* 0- reg expr	1- literal expr  */
  2    13 		char (168) var,	/* error message		 [OUT] */
  2    14 		fixed bin (35)	/* error status code	 [OUT] */
  2    15 		);
  2    16 
  2    17 dcl tedsrch_$search entry (		/* search for expression	       */
  2    18 		ptr,		/* -> compiled expression	       */
  2    19 		ptr,		/* -> buffer ctl block for file      */
  2    20 		fixed bin (21),	/* beginning of string to search     */
  2    21 		fixed bin (21),	/* end of string to search	       */
  2    22 		fixed bin (21),	/* beginning of match	       */
  2    23 		fixed bin (21),	/* end of match		       */
  2    24 		fixed bin (21),	/* end of string used for match      */
  2    25 		char (168)var,	/* error message return	 [OUT] */
  2    26 		fixed bin (35)	/* error status code	 [OUT] */
  2    27 		);
  2    28 
  2    29 
  2    30 /* END INCLUDE FILE ..... tedsrch_.incl.pl1 ..... */
  1   165 
  1   166 
  1   167 /* END INCLUDE FILE ..... ted_support.incl.pl1 .....		       */
      322 
      323 
      324 dcl (addr, bin, divide, index, mod, substr, unspec) builtin;
      325 
      326 dcl db_sw		bit (1) int static init (""b);
      327 dbn: entry; db_sw = "1"b; return;
      328 dbf: entry; db_sw = "0"b; return;
      329    end ted_fiad_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/23/82  1458.5  ted_fina_.pl1                     >spec>on>ted_fix>ted_fina_.pl1
322          1    11/23/82  1324.6  ted_support.incl.pl1              >ldd>include>ted_support.incl.pl1
1-165        2    11/23/82  1324.7  tedsrch_.incl.pl1                 >ldd>include>tedsrch_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HT                                     constant        char(1)                  initial unaligned dcl 30 ref 148
NL                              002372 constant        char(1)                  initial unaligned dcl 30 ref 105 112 117 128 165 187
                                                                                  196
adjust                          000107 automatic       bit(1)                   unaligned dcl 299 set ref 13* 18* 54 177
cc                       22            based           fixed bin(21,0)          level 3 dcl 1-7 set ref 42 45* 45 45 53 63 66 67 70*
                                                                                  76 78* 78 83 85* 85 91 93 278 281 282* 282
ch                              000136 automatic       char(1)                  unaligned dcl 321 set ref 105* 109* 112 148 148 154
code                                   parameter       fixed bin(35,0)          dcl 21 set ref 11 16 39* 43* 57* 167*
current                  27            based           fixed bin(21,0)          level 2 dcl 1-7 set ref 166*
db_sw                           000010 internal static bit(1)                   initial unaligned dcl 326 set ref 141 186 195 212
                                                                                  234 239 254 265 327* 328*
de                       13            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 46 124 128 212 212
                                                                                  214
de                       16            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" set ref 138 138* 138 163
                                                                                  163* 165 166 184 187 188* 188 196 196 200* 200 201
                                                                                  209 214 216* 216 231 241* 256 258* 258 262 265 265
                                                                                  267* 267
delim                           000104 automatic       char(1)                  unaligned dcl 295 set ref 63* 64 67 91
divide                                                 builtin function         dcl 324 ref 242
err                                    parameter       char                     unaligned dcl 276 in procedure "get_num" set ref 275
                                                                                  286*
err                                    parameter       char                     unaligned dcl 50 in procedure "error" ref 48 52
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 1-134 ref 39
fill                            000110 automatic       fixed bin(21,0)          dcl 300 set ref 242* 252
firstime                        000111 automatic       bit(1)                   unaligned dcl 301 set ref 99* 103 106*
hole_ct                         000112 automatic       fixed bin(21,0)          dcl 302 set ref 97* 142* 179* 210* 210 218* 218 227
                                                                                  234* 242 243 248 250
i                               000105 automatic       fixed bin(21,0)          dcl 296 set ref 250* 278* 279 281 282 283* 286
ichr                                   based           char(1)                  array unaligned dcl 1-137 ref 109 117
incr                            000113 automatic       fixed bin(21,0)          dcl 303 set ref 244* 247* 253
index                                                  builtin function         dcl 324 ref 67 128 251
inp                       6            based           structure                level 2 unaligned dcl 1-7
ioa_$nnl                        000012 constant        entry                    external dcl 27 ref 141 186 195 212 234 239 254 265
istr                                   based           char                     unaligned dcl 1-136 ref 124 128 212 212 214
j                               000106 automatic       fixed bin(21,0)          dcl 297 set ref 251* 252 254 254 256 259 260
left_set                        000114 automatic       bit(1)                   unaligned dcl 304 set ref 96* 122* 244 270* 270
leftover                        000115 automatic       fixed bin(21,0)          dcl 305 set ref 229* 242 243* 243 248* 248 252 253*
                                                                                  253
lineloc                         000116 automatic       fixed bin(21,0)          dcl 306 set ref 201* 209* 231 234* 237 241
lmarg                           000120 automatic       fixed bin(21,0)          array dcl 307 set ref 74* 74* 80 89* 195* 196 198
                                                                                  199 200 204 204 207 207 208 208
marg                            000122 automatic       fixed bin(21,0)          dcl 308 set ref 95* 121* 195 196 198 199 200 204
                                                                                  220*
matchleng                       000123 automatic       fixed bin(21,0)          dcl 309 set ref 67* 68 70 71* 71 124 124 124
matchloc                        000124 automatic       fixed bin(21,0)          dcl 310 set ref 66* 70 124
ml                       17            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 165 187 196 198 214
                                                                                  237 256 262 265 265
ml                       25            based           fixed bin(21,0)          level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 45 67 124 278 281
mod                                                    builtin function         dcl 324 ref 243
moveleng                        000125 automatic       fixed bin(21,0)          dcl 311 set ref 252* 254* 256 258
msg                                    parameter       varying char(168)        dcl 21 set ref 11 16 52* 54* 54 56* 56
nc                       23            based           fixed bin(21,0)          level 3 dcl 1-7 set ref 42* 53* 93*
num                             000100 automatic       fixed bin(21,0)          dcl 272 set ref 74 80 82 87 89 281* 283
ostr                                   based           char                     unaligned dcl 1-138 set ref 165* 187* 196* 198* 214*
                                                                                  237 256* 262* 265 265
out                      14            based           structure                level 2 unaligned dcl 1-7
pt                       20            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 45 63 67 76 83 91 124
                                                                                  278 281
pt                        6            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 109 117 124 128 212
                                                                                  212 214
pt                       14            based           pointer                  level 3 in structure "ted_support" dcl 1-7
                                                                                  in procedure "ted_fiad_" ref 165 187 196 198 214
                                                                                  237 256 262 265 265
putted                          000126 automatic       fixed bin(21,0)          dcl 313 set ref 94* 137* 143* 175 180* 193 199* 217*
                                                                                  217 227 229
rchr                                   based           char(1)                  array unaligned dcl 1-141 ref 63 76 83 91
req                      20            based           structure                level 2 unaligned dcl 1-7
rmarg                           000127 automatic       fixed bin(21,0)          dcl 314 set ref 82* 87 175 229
rstr                                   based           char                     unaligned dcl 1-140 ref 45 67 124 278 281
sb                       10            based           fixed bin(21,0)          level 3 dcl 1-7 ref 60
se                       12            based           fixed bin(21,0)          level 3 dcl 1-7 ref 61
substr                                                 builtin function         dcl 324 set ref 45 67 124 124 128 165* 187* 196*
                                                                                  198* 212 212 214* 214 237* 237 251 254 254 256*
                                                                                  256 262* 262 265 265 278 281
ted_support                            based           structure                level 1 unaligned dcl 1-7
ted_support_p                          parameter       pointer                  dcl 1-5 ref 11 16 36 42 42 45 45 45 45 45 46 53 53
                                                                                  60 61 63 63 66 67 67 67 70 76 76 78 78 83 83 85 85
                                                                                  91 91 93 93 109 117 124 124 124 124 128 128 138
                                                                                  138 138 163 163 165 165 165 166 166 184 187 187
                                                                                  187 188 188 196 196 196 196 198 198 200 200 201
                                                                                  209 212 212 212 212 214 214 214 214 214 216 216
                                                                                  231 237 237 241 256 256 256 258 258 262 262 262
                                                                                  265 265 265 265 265 265 267 267 278 278 278 281
                                                                                  281 281 282 282
ted_support_version_2                  constant        fixed bin(17,0)          initial dcl 1-6 ref 36
tederror_table_$Copy_Set        000014 external static fixed bin(35,0)          dcl 1-119 ref 167
tederror_table_$Error_Msg       000016 external static fixed bin(35,0)          dcl 1-119 ref 57
temp_area                       000100 automatic       char                     unaligned dcl 233 set ref 237* 251 254 254 256 262
templeng                        000130 automatic       fixed bin(21,0)          dcl 315 set ref 231* 233 234 234* 237 237 251 260*
                                                                                  260 262 262 262 265 265 267
temploc                         000131 automatic       fixed bin(21,0)          dcl 316 set ref 230* 234* 237 251 254 254 256 259*
                                                                                  259 262
version                                based           fixed bin(17,0)          level 2 dcl 1-7 ref 36
virtleng                        000134 automatic       fixed bin(21,0)          dcl 319 set ref 203* 207* 209 212* 214 216
visleng                         000135 automatic       fixed bin(21,0)          dcl 320 set ref 98* 119* 133* 136* 154* 154 156* 156
                                                                                  175 183* 204 207 208* 217 219*
wordleng                        000132 automatic       fixed bin(21,0)          dcl 317 set ref 98* 119* 133* 136* 137 151 153* 153
                                                                                  159 173 181 183* 203 207 212 212 214 219* 227
wordloc                         000133 automatic       fixed bin(21,0)          dcl 318 set ref 135* 151* 212 212 214
zle                             000101 automatic       fixed bin(21,0)          dcl 291 set ref 128* 130 130* 132* 132 136 144
zsb                             000102 automatic       fixed bin(21,0)          dcl 292 set ref 60* 100 102 109 110* 110 115 117 124
                                                                                  128 128 132 135 136 144* 151
zse                             000103 automatic       fixed bin(21,0)          dcl 293 set ref 61* 100 102 115 128 130

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addr                                                   builtin function         dcl 324
bin                                                    builtin function         dcl 324
concealsw                              automatic       bit(1)                   unaligned dcl 294
ioa_                            000000 constant        entry                    external dcl 28
num_sw                                 automatic       bit(1)                   unaligned dcl 273
ochr                                   based           char(1)                  array unaligned dcl 1-139
pb                                     automatic       fixed bin(21,0)          dcl 312
scan_leng                              automatic       fixed bin(21,0)          dcl 298
tederror_table_$NoChange               external static fixed bin(35,0)          dcl 1-119
tederror_table_$No_Delim1              external static fixed bin(35,0)          dcl 1-119
tederror_table_$No_Delim2              external static fixed bin(35,0)          dcl 1-119
tederror_table_$No_Delim3              external static fixed bin(35,0)          dcl 1-119
tederror_table_$Set                    external static fixed bin(35,0)          dcl 1-119
tedsrch_$compile                000000 constant        entry                    external dcl 2-7
tedsrch_$init_exp               000000 constant        entry                    external dcl 2-3
tedsrch_$search                 000000 constant        entry                    external dcl 2-17
unspec                                                 builtin function         dcl 324

NAMES DECLARED BY EXPLICIT CONTEXT.
dbf                             000774 constant        entry                    external dcl 328
dbn                             000762 constant        entry                    external dcl 327
error                           001004 constant        entry                    internal dcl 48 ref 46 64 68 76 80 87 91 286
exit                            000760 constant        label                    dcl 168 ref 58
fixup                           001364 constant        entry                    internal dcl 225 ref 177
get_num                         002005 constant        entry                    internal dcl 275 ref 73 79 86
putword                         001071 constant        entry                    internal dcl 171 ref 114 120 134 140 148 159
start                           000174 constant        label                    dcl 36 ref 14 19
ted_fiad_                       000153 constant        entry                    external dcl 11
ted_fina_                       000165 constant        entry                    external dcl 16

NAMES DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 252 281
verify                                                 builtin function         ref 45 278

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2502        2524    2374        2512
Length      2742    2374        22         202     105           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ted_fiad_                           354 external procedure  is an external procedure.  
error                                   internal procedure  shares stack frame of external procedure ted_fiad_.  
putword                                 internal procedure  shares stack frame of external procedure ted_fiad_.  
fixup                                   internal procedure  shares stack frame of external procedure ted_fiad_.  
begin block on line 232             112 begin block         uses auto adjustable storage.  
get_num                                 internal procedure  shares stack frame of external procedure ted_fiad_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 db_sw                       ted_fiad_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 232  000100 temp_area                   begin block on line 232
ted_fiad_                000100 num                         ted_fiad_
                         000101 zle                         ted_fiad_
                         000102 zsb                         ted_fiad_
                         000103 zse                         ted_fiad_
                         000104 delim                       ted_fiad_
                         000105 i                           ted_fiad_
                         000106 j                           ted_fiad_
                         000107 adjust                      ted_fiad_
                         000110 fill                        ted_fiad_
                         000111 firstime                    ted_fiad_
                         000112 hole_ct                     ted_fiad_
                         000113 incr                        ted_fiad_
                         000114 left_set                    ted_fiad_
                         000115 leftover                    ted_fiad_
                         000116 lineloc                     ted_fiad_
                         000120 lmarg                       ted_fiad_
                         000122 marg                        ted_fiad_
                         000123 matchleng                   ted_fiad_
                         000124 matchloc                    ted_fiad_
                         000125 moveleng                    ted_fiad_
                         000126 putted                      ted_fiad_
                         000127 rmarg                       ted_fiad_
                         000130 templeng                    ted_fiad_
                         000131 temploc                     ted_fiad_
                         000132 wordleng                    ted_fiad_
                         000133 wordloc                     ted_fiad_
                         000134 virtleng                    ted_fiad_
                         000135 visleng                     ted_fiad_
                         000136 ch                          ted_fiad_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_cs            enter_begin         leave_begin         call_ext_out_desc   return
alloc_auto_adj      mod_fx1             shorten_stack       ext_entry           any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$nnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          tederror_table_$Copy_Set      tederror_table_$Error_Msg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000147        13 000160        14 000162        16 000163        18 000172        19 000173        36 000174
     39 000201        40 000204        42 000205        43 000210        45 000211        46 000234        60 000244
     61 000251        63 000253        64 000261        66 000275        67 000303        68 000320        70 000332
     71 000340        73 000342        74 000353        76 000356        78 000375        79 000401        80 000412
     82 000423        83 000425        85 000436        86 000437        87 000450        89 000461        91 000463
     93 000505        94 000513        95 000514        96 000516        97 000517        98 000521        99 000523
    100 000525       102 000530       103 000533       105 000535       106 000537       107 000540       109 000541
    110 000551       112 000552       114 000555       115 000556       117 000561       119 000571       120 000574
    121 000575       122 000577       123 000600       124 000601       128 000616       130 000633       132 000637
    133 000642       134 000645       135 000646       136 000650       137 000654       138 000656       140 000665
    141 000666       142 000703       143 000705       144 000706       147 000710       148 000711       151 000717
    153 000724       154 000725       156 000731       158 000733       159 000734       163 000737       165 000746
    166 000753       167 000755       168 000760       327 000761       327 000767       327 000772       328 000773
    328 001001       328 001003        48 001004        52 001015        53 001030        54 001034        56 001052
     57 001065        58 001070       171 001071       173 001072       175 001074       177 001100       179 001103
    180 001105       181 001106       183 001111       184 001113       186 001120       187 001135       188 001145
    190 001146       193 001147       195 001151       196 001173       198 001207       199 001215       200 001220
    201 001224       203 001226       204 001230       207 001237       208 001243       209 001247       210 001256
    212 001260       214 001321       216 001346       217 001352       218 001356       219 001357       220 001361
    223 001363       225 001364       227 001365       229 001374       230 001400       231 001402       232 001411
    233 001414       234 001425       237 001467       239 001516       241 001533       242 001542       243 001545
    244 001551       247 001556       248 001560       250 001564       251 001574       252 001610       253 001620
    254 001622       256 001657       258 001703       259 001705       260 001707       261 001711       262 001713
    265 001733       267 001771       268 002000       270 002001       271 002004       275 002005       278 002016
    279 002042       281 002044       282 002061       283 002070       286 002074       289 002111


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
