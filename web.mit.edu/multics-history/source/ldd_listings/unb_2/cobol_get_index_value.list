	COMPILATION LISTING OF SEGMENT cobol_get_index_value
	Compiled by: Multics PL/I Compiler, Release 31b, of April 24, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 05/24/89  0950.3 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
       12*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
       13*     MCR8060 cobol_get_index_value.pl1 Added Trace statements.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 /* format: style3 */
       18 
       19 /* ******************************************************
       20*   *                                                    *
       21*   *                                                    *
       22*   * Copyright (c) 1972 by Massachusetts Institute of   *
       23*   * Technology and Honeywell Information Systems, Inc. *
       24*   *                                                    *
       25*   *                                                    *
       26*   ****************************************************** */
       27 
       28 /* Modified on 10/19/85 by FCH, [5.3-1], bug563(phx18381), new cobol_addr_tokens.incl.pl1 */
       29 /* Modified since Version 2.0 */
       30 
       31 /*{*/
       32 cobol_get_index_value:
       33      proc (return_value_code, input_token_ptr, output_token_ptr);
       34 
       35 /*
       36*This procedure generates code to convert the value of an index
       37*(which is stored as a fixed binary number in two bytes of storage)
       38*to a decimal format operand in a temporary in the run-time stack.
       39**/
       40 
       41 /*  DECLARATION OF THE PARAMETERS  */
       42 
       43 dcl	return_value_code	fixed bin;
       44 dcl	input_token_ptr	ptr;
       45 dcl	output_token_ptr	ptr;
       46 
       47 /*
       48*return_value_code	a code that indicates whether the
       49*		index occurrence number is to be returned as
       50*		a fixed bin (35) or decimal value. (input)
       51*		This code can have the following values:
       52*
       53*		return_value_code	meaning
       54*		1		return fixed bin
       55*		2 return decimal
       56*input_token_ptr	points to the input token: data name
       57*		(type 9, usage is index), or index name (type 10)
       58*		to be converted to decimal. (input)
       59*output_token_ptr	points to a buffer in the caller's program
       60*		in which the dataname (type 9) token,
       61*		describing the resultant converted decimal
       62*		value is built by this procedure.  (input)
       63*
       64**/
       65 
       66 
       67 /*  Declaration of external entries  */
       68 
       69 dcl	cobol_addr	ext entry (ptr, ptr, ptr);
       70 dcl	cobol_emit	ext entry (ptr, ptr, fixed bin);
       71 dcl	cobol_alloc$stack	ext entry (fixed bin, fixed bin, fixed bin);
       72 dcl	cobol_make_type9$copy
       73 			ext entry (ptr, ptr);
       74 dcl	cobol_register$load ext entry (ptr);
       75 dcl	cobol_register$release
       76 			ext entry (ptr);
       77 
       78 /*  DECLARATION OF BUILTIN FUNCTIONS  */
       79 
       80 dcl	addr		builtin;
       81 dcl	binary		builtin;
       82 dcl	bit		builtin;
       83 dcl	fixed		builtin;
       84 
       85 /*  Definition of internal static variables that contain op codes  */
       86 
       87 dcl	btd_op		bit (10) int static init ("0110000011"b /* 301(1) */);
       88 dcl	mlr_op		bit (10) int static init ("0010000001"b /* 100(1) */);
       89 dcl	lda_op		bit (10) int static init ("0100111010"b /* 235(0) */);
       90 dcl	ldq_op		bit (10) int static init ("0100111100"b /* 236(0) */);
       91 
       92 dcl	ldaq_op		bit (10) int static init ("0100111110"b /*237(0)*/);
       93 dcl	lls_op		bit (10) int static init ("1110111110"b /*737(0)*/);
       94 dcl	lrs_op		bit (10) int static init ("1110110110"b /*733(0)*/);
       95 dcl	ars_op		bit (10) int static init ("1110110010"b /*731(0)*/);
       96 dcl	stq_op		bit (10) int static init ("1111011100"b /*756(0)*/);
       97 
       98 /*  Buffer in which instructions and/or descriptors are returned by the addressability utility  */
       99 
      100 dcl	inst_buff		(1:5) fixed bin;
      101 
      102 /*  Buffer in which relocation information is returned by the addressability utility  */
      103 
      104 dcl	reloc_buff	(1:10) fixed bin;
      105 
      106 /*  Buffer in which input to the addressabiliyt utility is built  */
      107 
      108 dcl	input_buff	(1:30) ptr;
      109 
      110 /*  Work buffer in which a data name token (type 9) for the index value is built  */
      111 
      112 dcl	wkbuff1		(1:40) fixed bin;
      113 dcl	wkbuff1_ptr	ptr;
      114 
      115 /*  work buffer in which a data name token (type 9) for the occurence number in the stack is built  */
      116 
      117 dcl	wkbuff2		(1:40) fixed bin;
      118 dcl	wkbuff2_ptr	ptr;
      119 
      120 dcl	dn_ptr		ptr;
      121 dcl	byte_offset	bit (2);
      122 dcl	shift_val		fixed bin;
      123 dcl	return_decimal_value
      124 			bit (1);
      125 
      126 
      127 /*  Variables used to zero the descripiton bits of a data name token  */
      128 
      129 dcl	descrip_ptr	ptr;
      130 dcl	descrip		bit (72) based (descrip_ptr);
      131 
      132 dcl	t_offset		fixed bin;
      133 
      134 
      135 /*  Structure used to communicate with the register$load procedure.  */
      136 
      137 dcl	1 register_struc,
      138 	  2 what_reg	fixed bin,
      139 	  2 reg_no	bit (4),
      140 	  2 lock		fixed bin,
      141 	  2 already_there	fixed bin,
      142 	  2 contains	fixed bin,
      143 	  2 dname_ptr	ptr,
      144 	  2 literal	bit (36);
      145 
      146 /**************************************************/
      147 /*	START OF EXECUTION			*/
      148 /*	cobol_get_index_value			*/
      149 /**************************************************/
      150 
      151 start:
      152 	if return_value_code = 1			/*  return fixed binary  */
      153 	then return_decimal_value = "0"b;
      154 	else return_decimal_value = "1"b;
      155 
      156 
      157 /*  Set work pointers to point at the work buffers  */
      158 
      159 	inst_ptr = addr (inst_buff (1));
      160 	reloc_ptr = addr (reloc_buff (1));
      161 	input_ptr = addr (input_buff (1));
      162 	wkbuff1_ptr = addr (wkbuff1 (1));
      163 
      164 	if return_decimal_value
      165 	then dn_ptr = wkbuff1_ptr;			/*  build temporary output token  */
      166 	else dn_ptr = output_token_ptr;		/*  Build output token in the user's work buffer  */
      167 
      168 
      169 
      170 	if input_token_ptr -> data_name.type = rtc_dataname
      171 	then do;					/*  Input token is a dataname token (type 9) with usage index bit set  */
      172 
      173 		wkbuff2_ptr = addr (wkbuff2 (1));
      174 
      175 /*  Allocate  four bytes on a word boundary in the stack, to receive
      176*		the fixed binary occurrence number  */
      177 		call cobol_alloc$stack (4, 0, t_offset);
      178 
      179 /*  Make a data name token that describes the stack temporary to receive the
      180*			occurrence number  */
      181 		data_name.type = rtc_dataname;
      182 		data_name.seg_num = 1000;		/*  Stack  */
      183 		data_name.offset = t_offset;		/*  Offset returned by alloc$stack  */
      184 
      185 /*  Update the two data name tokens so that alphanumeric eis descriptors will
      186*		be built for them by the addressability utility.  */
      187 		input_token_ptr -> data_name.alphanum = "1"b;
      188 		input_token_ptr -> data_name.usage_index = "0"b;
      189 		wkbuff2_ptr -> data_name.alphanum = "1"b;
      190 		wkbuff2_ptr -> data_name.usage_index = "0"b;
      191 
      192 
      193 /*  Allocate six bytes on an even word boundary in the stack
      194*		to receive the six byte index data item.  */
      195 
      196 		call cobol_alloc$stack (6, 2, t_offset);
      197 
      198 /*  Convert the offset value from a word offset to a byte offset.  */
      199 		t_offset = t_offset * 4;
      200 
      201 /*  Make a copy of the input data name token.  */
      202 
      203 		call cobol_make_type9$copy (wkbuff2_ptr, input_token_ptr);
      204 
      205 /*  Modify the copy so that it describes the six byte temporary in the stack.  */
      206 		wkbuff2_ptr -> data_name.seg_num = 1000;/*  stack  */
      207 		wkbuff2_ptr -> data_name.offset = t_offset;
      208 						/*  Turn off the subscripted bit in the token that describes the temporary.  */
      209 		wkbuff2_ptr -> data_name.subscripted = "0"b;
      210 
      211 /*  Generate code to move the index data item to the 6 byte temporary in the stack.  */
      212 
      213 /*  Build the input structure to the addressability utility.  */
      214 
      215 		input_struc.type = 5;		/*  EIS,2 input operands, instruction and 2 descriptors returned.  */
      216 
      217 		input_struc.operand_no = 2;
      218 		input_struc.lock = 0;
      219 		input_struc.operand.token_ptr (1) = input_token_ptr;
      220 		input_struc.operand.send_receive (1) = 0;
      221 						/*  sending  */
      222 		input_struc.operand.size_sw (1) = 0;
      223 
      224 		input_struc.operand.token_ptr (2) = wkbuff2_ptr;
      225 		input_struc.operand.send_receive (2) = 1;
      226 						/*  receiving  */
      227 		input_struc.operand.size_sw (2) = 0;
      228 
      229 
      230 
      231 /*  Call the addressability utility.  */
      232 
      233 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      234 
      235 
      236 /*  Set the MLR opcode into the instruction  */
      237 		inst_struc.inst.fill1_op = mlr_op;
      238 
      239 /*  Emit the instruction and two descriptors.  */
      240 		call cobol_emit (inst_ptr, reloc_ptr, 3);
      241 
      242 /*  Get the basic address of the WORD containing the first byte of the index occurrence
      243*			number  */
      244 
      245 
      246 		input_struc_basic.type = 1;		/*  basic, non-eis  */
      247 		input_struc_basic.operand_no = 0;
      248 		input_struc_basic.segno = wkbuff2_ptr -> data_name.seg_num;
      249 		input_struc_basic.char_offset = wkbuff2_ptr -> data_name.offset + 4;
      250 
      251 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      252 						/*  Get the A and Q registers.  */
      253 
      254 		register_struc.what_reg = 3;		/*  Get the A and Q registers, please.  */
      255 		register_struc.lock = 0;		/*  No change to locks.  */
      256 		register_struc.contains = 0;		/*  Contents of A and Q are not meaningful
      257*			for register optimization .  ( because they will be shifted once they
      258*			are in the A-Q)  */
      259 
      260 		call cobol_register$load (addr (register_struc));
      261 
      262 
      263 /*  Build ldq instruction referencing the address of the WORD containing
      264*			the first byte of the index occurrence number  */
      265 
      266 		inst_struc_basic.fill1_op = ldq_op;
      267 
      268 /*  Emit the ldaq instruction  */
      269 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      270 
      271 /*  At this point, code has been generated to get the two bytes containing
      272*		the index data item occurrence number into the two most significant bytes
      273*		of the Q- register.  */
      274 
      275 /*  Build an instruction to load zero into the A register.  */
      276 
      277 		inst_buff (1) = 0;
      278 		inst_struc_basic.fill1_op = lda_op;
      279 		inst_struc_basic.tm = "00"b;		/*  ir modivication  */
      280 		inst_struc_basic.td = "0011"b;	/*  DU  */
      281 
      282 /*  Set relocation bytes  */
      283 		reloc_buff (1) = 0;
      284 		reloc_buff (2) = 0;			/*  Emit the lda 0,du instruction  */
      285 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      286 
      287 /*  Build a LLS instruction to get rid of the junk bit in the middle of the two 8 bit
      288*			pieces of meaningful data  */
      289 
      290 		inst_buff (1) = 0;
      291 		inst_struc_basic.fill1_op = lls_op;
      292 		inst_struc_basic.wd_offset = bit (binary (10, 15));
      293 						/*  Insert the shift value into the
      294*		instruction  */
      295 
      296 /*  Set relocation bytes  */
      297 		reloc_buff (1) = 0;
      298 		reloc_buff (2) = 0;			/*  Emit the lls instruction  */
      299 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      300 
      301 
      302 
      303 /*  Build ars instruction  */
      304 		inst_buff (1) = 0;
      305 		inst_struc_basic.fill1_op = ars_op;
      306 		inst_struc_basic.wd_offset = bit (binary (1, 15));
      307 
      308 /*  Emit the ars instruction  */
      309 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      310 
      311 /*  Build the lrs instruction  */
      312 		inst_buff (1) = 0;
      313 		inst_struc_basic.fill1_op = lrs_op;
      314 		inst_struc_basic.wd_offset = bit (binary (28, 15));
      315 
      316 /*  Emit the lrs instruction  */
      317 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      318 
      319 /*  Get the basic address of the temporary in the stack which is to receive the
      320*			occurrence number  */
      321 
      322 		input_struc_basic.type = 1;
      323 		input_struc_basic.operand_no = 0;
      324 		input_struc_basic.segno = data_name.seg_num;
      325 		input_struc_basic.char_offset = data_name.offset;
      326 
      327 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      328 
      329 /*  Emit the stq instruction  */
      330 		inst_struc_basic.fill1_op = stq_op;
      331 		call cobol_emit (inst_ptr, reloc_ptr, 1);
      332 
      333 /*  Set wkbuff1_ptr to point to the token for the temporary in the stack  */
      334 		wkbuff1_ptr = dn_ptr;		/*  Release the A and Q registers.  */
      335 		call cobol_register$release (addr (register_struc));
      336 
      337 
      338 	     end;					/*  Input token is data name (type 9) with usage index bit set  */
      339 
      340 	else do;					/*  an index name token (type 10)  */
      341 		data_name.type = rtc_dataname;
      342 		ind_ptr = input_token_ptr;
      343 		data_name.seg_num = index_name.seg_num; /*  set segment number of index name item  */
      344 		data_name.offset = index_name.offset + 4;
      345 						/*  set offset from index name item  */
      346 	     end;					/*  an index name token (type 10)  */
      347 
      348 
      349 /*  Complete the data name token in the work buffer  */
      350 	data_name.item_length = 4;
      351 	data_name.places_left = 4;
      352 	data_name.places_right = 0;
      353 
      354 /*  Zero the description bits in the data name token being built  */
      355 	descrip_ptr = addr (data_name.file_section);
      356 	descrip = "0"b;
      357 
      358 /*  Set description bits  */
      359 	data_name.display = "1"b;
      360 	data_name.numeric = "1"b;
      361 	data_name.elementary = "1"b;
      362 
      363 	if return_decimal_value
      364 	then do;					/*  convert the fixed binary occurrence value to decimal  */
      365 						/*  Allocate space on the stack to receive the decimal representation
      366*		of the binary index value  */
      367 		call cobol_alloc$stack (5, 0, t_offset);/*  5 bytes will hold maximum value that
      368*		can be held in two bytes of fixed binary information  */
      369 
      370 /*  Save the pointer to the token that describes the fixed binary occurrence number  */
      371 		wkbuff1_ptr = dn_ptr;
      372 
      373 /*  Build a data name token for the stack temporary just allocated  */
      374 		dn_ptr = output_token_ptr;
      375 		data_name.size = 116;		/*	12/24/75	bc	*/
      376 		data_name.type = rtc_dataname;
      377 		data_name.item_length = 5;
      378 		data_name.places_left = 5;
      379 		data_name.places_right = 0;
      380 		data_name.seg_num = 1000;		/*  stack  */
      381 		data_name.offset = t_offset;		/*  offset just returned by alloc$stack  */
      382 
      383 		descrip_ptr = addr (data_name.file_section);
      384 		descrip = "0"b;
      385 		data_name.numeric = "1"b;
      386 		data_name.elementary = "1"b;
      387 		data_name.display = "1"b;
      388 
      389 
      390 /*  Build the input to the addressability utility  */
      391 
      392 		input_struc.type = 5;		/*  eis, 2 operands input, instruction and 2 descriptors returned  */
      393 
      394 		input_struc.operand_no = 2;
      395 		input_struc.lock = 0;
      396 		input_struc.operand.token_ptr (1) = wkbuff1_ptr;
      397 		input_struc.operand.send_receive (1) = 0;
      398 						/*  sending  */
      399 		input_struc.operand.size_sw (1) = 0;
      400 
      401 		input_struc.token_ptr (2) = output_token_ptr;
      402 						/*  token for decimal representation to which
      403*		the fixed binary is converted  */
      404 		input_struc.operand.send_receive (2) = 1;
      405 						/*  receiving  */
      406 		input_struc.operand.size_sw (2) = 0;
      407 
      408 		call cobol_addr (input_ptr, inst_ptr, reloc_ptr);
      409 
      410 
      411 /*  Set the binary to decimal op code into the opcode field of the instruction  */
      412 		inst_struc.inst.fill1_op = btd_op;
      413 		desc_nn_ptr = addr (inst_buff (2));
      414 
      415 /*  Zero the MBZ bits in the first descriptor  */
      416 		desc_nn.desc_f.tn (1) = "0"b;		/*  type code bit  */
      417 		desc_nn.sign_type (1) = "0"b;		/*  sign type bits  */
      418 		desc_nn.scal (1) = "0"b;		/*  scale factor  */
      419 
      420 /*  Zero MBZ bits in the second descriptor  */
      421 		desc_nn.scal (2) = "0"b;		/*  scale factor  */
      422 
      423 
      424 /*  Emit the instruction and two descriptors  */
      425 		call cobol_emit (inst_ptr, reloc_ptr, 3);
      426 
      427 	     end;					/*  cconvert the fixed binary occurrence value to decimal  */
      428 
      429 /**************************************************/
      430 /*	END OF EXECUTABLE STATEMENTS	*/
      431 /*	cobol_get_index_value			*/
      432 /**************************************************/
      433 
      434 
      435 /*  INCLUDE FILES USED BY THIS PROCEDURE  */
      436 
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... cobol_type9.incl.pl1 */
  1     3 /* Last modified on 11/19/76 by ORN */
  1     4 
  1     5 /*
  1     6*A type 9 data name token is entered into the name table by the data
  1     7*division syntax phase for each data name described in the data division.
  1     8*The replacement phase subsequently replaces type 8 user word references
  1     9*to data names in the procedure division minpral file with the corresponding
  1    10*type 9 tokens from the name table.
  1    11**/
  1    12 
  1    13 /* dcl dn_ptr ptr; */
  1    14 
  1    15 /* BEGIN DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    16 dcl 1 data_name based (dn_ptr),
  2     1 
  2     2 /* begin include file ... cobol_TYPE9.incl.pl1 */
  2     3 /* Last modified on 06/19/77 by ORN */
  2     4 /* Last modified on 12/28/76 by FCH */
  2     5 
  2     6 		/* header */
  2     7 		2 size fixed bin,
  2     8 		2 line fixed bin,
  2     9 		2 column fixed bin,
  2    10 		2 type fixed bin,
  2    11 		/* body */
  2    12 		2 string_ptr ptr,
  2    13 		2 prev_rec ptr,
  2    14 		2 searched bit (1),
  2    15 		2 duplicate bit (1),
  2    16 		2 saved bit (1),
  2    17 		2 debug_ind bit (1),
  2    18 		2 filler2 bit (3),
  2    19 		2 used_as_sub bit (1),
  2    20 		2 def_line fixed bin,
  2    21 		2 level fixed bin,
  2    22 		2 linkage fixed bin,
  2    23 		2 file_num fixed bin,
  2    24 		2 size_rtn fixed bin,
  2    25 		2 item_length fixed bin(24),
  2    26 		2 places_left fixed bin,
  2    27 		2 places_right fixed bin,
  2    28 		/* description */
  2    29 		2 file_section bit (1),
  2    30 		2 working_storage bit (1),
  2    31 		2 constant_section bit (1),
  2    32 		2 linkage_section bit (1),
  2    33 		2 communication_section bit (1),
  2    34 		2 report_section bit (1),
  2    35 		2 level_77 bit (1),
  2    36 		2 level_01 bit (1),
  2    37 		2 non_elementary bit (1),
  2    38 		2 elementary bit (1),
  2    39 		2 filler_item bit (1),
  2    40 		2 s_of_rdf bit (1),
  2    41 		2 o_of_rdf bit (1),
  2    42 		2 bin_18 bit (1),
  2    43 		2 bin_36 bit (1),
  2    44 		2 pic_has_l bit (1),
  2    45 		2 pic_is_do bit (1),
  2    46 		2 numeric bit (1),
  2    47 		2 numeric_edited bit (1),
  2    48 		2 alphanum bit (1),
  2    49 		2 alphanum_edited bit (1),
  2    50 		2 alphabetic bit (1),
  2    51 		2 alphabetic_edited bit (1),
  2    52 		2 pic_has_p bit (1),
  2    53 		2 pic_has_ast bit (1),
  2    54 		2 item_signed bit(1),
  2    55 		2 sign_separate bit (1),
  2    56 		2 display bit (1),
  2    57 		2 comp bit (1),
  2    58 		2 ascii_packed_dec_h bit (1),	/* as of 8/16/76  this field used for comp8. */
  2    59 		2 ascii_packed_dec bit (1),
  2    60 		2 ebcdic_packed_dec bit (1),
  2    61 		2 bin_16 bit (1),
  2    62 		2 bin_32 bit (1),
  2    63 		2 usage_index bit (1),
  2    64 		2 just_right bit (1),
  2    65 		2 compare_argument bit (1),
  2    66 		2 sync bit (1),
  2    67 		2 temporary bit (1),
  2    68 		2 bwz bit (1),
  2    69 		2 variable_length bit (1),
  2    70 		2 subscripted bit (1),
  2    71 		2 occurs_do bit (1),
  2    72 		2 key_a bit (1),
  2    73 		2 key_d bit (1),
  2    74 		2 indexed_by bit (1),
  2    75 		2 value_numeric bit (1),
  2    76 		2 value_non_numeric bit (1),
  2    77 		2 value_signed bit (1),
  2    78 		2 sign_type bit (3),
  2    79 		2 pic_integer bit (1),
  2    80 		2 ast_when_zero bit (1),
  2    81 		2 label_record bit (1),
  2    82 		2 sign_clause_occurred bit (1),
  2    83 		2 okey_dn bit (1),
  2    84 		2 subject_of_keyis bit (1),
  2    85 		2 exp_redefining bit (1),
  2    86 		2 sync_in_rec bit (1),
  2    87 		2 rounded bit (1),
  2    88 		2 ad_bit bit (1),
  2    89 		2 debug_all bit (1),
  2    90 		2 overlap bit (1),
  2    91 		2 sum_counter bit (1),
  2    92 		2 exp_occurs bit (1),
  2    93 		2 linage_counter bit (1),
  2    94 		2 rnm_01 bit (1),
  2    95 		2 aligned bit (1),
  2    96 		2 not_user_writable bit (1),
  2    97 		2 database_key bit (1),
  2    98 		2 database_data_item bit (1),
  2    99 		2 seg_num fixed bin,
  2   100 		2 offset fixed bin(24),
  2   101 		2 initial_ptr fixed bin,
  2   102 		2 edit_ptr fixed bin,
  2   103 		2 occurs_ptr fixed bin,
  2   104 		2 do_rec char(5),
  2   105 		2 bitt bit (1),
  2   106 		2 byte bit (1),
  2   107 		2 half_word bit (1),
  2   108 		2 word bit (1),
  2   109 		2 double_word bit (1),
  2   110 		2 half_byte bit (1),
  2   111 		2 filler5 bit (1),
  2   112 		2 bit_offset bit (4),
  2   113 		2 son_cnt bit (16),
  2   114 		2 max_red_size fixed bin(24),
  2   115 		2 name_size fixed bin,
  2   116 		2 name char(0 refer(data_name.name_size));	
  2   117 
  2   118 
  2   119 
  2   120 /* end include file ... cobol_TYPE9.incl.pl1 */
  2   121 
  1    17 
  1    18 /* END DECLARATION OF TYPE9 (DATA NAME) TOKEN */
  1    19 
  1    20 /* END INCLUDE FILE ... cobol_type9.incl.pl1 */
  1    21 
      437 
      438 
  3     1 
  3     2 /* BEGIN INCLUDE FILE ... cobol_type10.incl.pl1 */
  3     3 /* Last modified on 11/19/76 by ORN */
  3     4 /*
  3     5*A type 10 index name token is entered into the name table by the data
  3     6*division syntax phase for each index name appearing in the data division.
  3     7*An index name is declared in the indexed by phrase of an occurs clause.
  3     8*maintain the binary byte offset, within the array, corresponding to the
  3     9*current setting of the index name.  The right-most two bytes contain the
  3    10*binary occurrence number to which the index name is set.
  3    11*When the replacement phase processes the procedure division minpral file,
  3    12*each reference to an index name is replaced with the type 10 token created
  3    13*for that index name.
  3    14**/
  3    15 
  3    16 dcl ind_ptr ptr;
  3    17 
  3    18 /* BEGIN DECLARATION OF TYPE10 (INDEX NAME) TOKEN */
  3    19 dcl	1 index_name based (ind_ptr),
  4     1 
  4     2 /* begin include file ... cobol_TYPE10.incl.pl1
  4     3*/* Last modified on 01/25/77 by ORN */
  4     4 
  4     5 	/* header */
  4     6 	2 size fixed bin,
  4     7 	2 line fixed bin,
  4     8 	2 column fixed bin,
  4     9 	2 type fixed bin,
  4    10 	/* body */
  4    11 	2 string_ptr ptr,
  4    12 	2 prev_rec ptr,
  4    13 	2 searched bit(1),
  4    14 	2 duplicate bit(1),
  4    15 	2 saved bit(1),
  4    16 	2 debug_ind bit(1),
  4    17 	2 filler1 bit(3),
  4    18 	2 subscript bit(1),
  4    19 	2 def_line fixed bin,
  4    20 	2 level fixed bin,
  4    21 	2 seg_num fixed bin,
  4    22 	2 offset fixed bin(24),
  4    23 	2 index_no fixed bin,
  4    24 	2 min fixed bin,
  4    25 	2 max fixed bin,
  4    26 	2 struc_length fixed bin,
  4    27 	2 cswd_seg fixed bin,
  4    28 	2 cswd_offset fixed bin(24),
  4    29 	2 name_size fixed bin,
  4    30 	2 name char(0 refer(index_name.name_size));
  4    31 
  4    32 
  4    33 
  4    34 /* end include file ... cobol_TYPE10.incl.pl1 */
  4    35 
  3    20 
  3    21 /* END DECLARATION OF TYPE10 (INDEX NAME) TOKEN */
  3    22 
  3    23 /* END INCLUDE FILE ... cobol_type10.incl.pl1 */
  3    24 
      439 
      440 
  5     1 
  5     2 /* BEGIN INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8058),
  5     7*     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
  5     8*     MCR8058 cobol_addr_tokens.incl.pl1 Change array extents to refer to
  5     9*     constants rather than variables.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 /* Last modified on 10/1/74 by tg */
  5    14 
  5    15 
  5    16 /* parameter list */
  5    17 
  5    18      dcl	   (input_ptr, inst_ptr, reloc_ptr) ptr;
  5    19 
  5    20 
  5    21 /* input_struc_basic is used for type 1 addressing */
  5    22 
  5    23      dcl	   1 input_struc_basic    based (input_ptr),
  5    24 	     2 type	      fixed bin,
  5    25 	     2 operand_no	      fixed bin,
  5    26 	     2 lock	      fixed bin,
  5    27 	     2 segno	      fixed bin,
  5    28 	     2 char_offset	      fixed bin (24),
  5    29 	     2 send_receive	      fixed bin;
  5    30 
  5    31 
  5    32      dcl	   1 input_struc	      based (input_ptr),
  5    33 	     2 type	      fixed bin,
  5    34 	     2 operand_no	      fixed bin,
  5    35 	     2 lock	      fixed bin,
  5    36 	     2 operand	      (0 refer (input_struc.operand_no)),
  5    37 	       3 token_ptr	      ptr,
  5    38 	       3 send_receive     fixed bin,
  5    39 	       3 ic_mod	      fixed bin,
  5    40 	       3 size_sw	      fixed bin;
  5    41 
  5    42 /* reloc_struc is used for all types of addressing * all types */
  5    43 
  5    44      dcl	   1 reloc_struc	      (input_struc.operand_no + 1) based (reloc_ptr),
  5    45 	     2 left_wd	      bit (5) aligned,
  5    46 	     2 right_wd	      bit (5) aligned;
  5    47 
  5    48 /* Instruction format for 1 word instruction */
  5    49 
  5    50 
  5    51      dcl	   1 inst_struc_basic     based (inst_ptr) aligned,
  5    52 	     2 y		      unaligned,
  5    53 	       3 pr	      bit (3) unaligned,
  5    54 	       3 wd_offset	      bit (15) unaligned,
  5    55 	     2 fill1_op	      bit (10) unaligned,
  5    56 	     2 zero1	      bit (1) unaligned,
  5    57 	     2 pr_spec	      bit (1) unaligned,
  5    58 	     2 tm		      bit (2) unaligned,
  5    59 	     2 td		      bit (4) unaligned;
  5    60 
  5    61 
  5    62 /* The detailed definitions of the fields in this structure
  5    63*   can be found in the GMAP manual section 8 */
  5    64 /* EIS instruction format for 2_4 word instructions */
  5    65 
  5    66      dcl	   1 inst_struc	      based (inst_ptr) aligned,
  5    67 	     2 inst	      unaligned,
  5    68 	       3 zero1	      bit (2) unaligned,
  5    69 	       3 mf3	      unaligned,
  5    70 	         4 pr_spec	      bit (1) unaligned,
  5    71 	         4 reg_or_length  bit (1) unaligned,
  5    72 	         4 zero2	      bit (1) unaligned,
  5    73 	         4 reg_mod	      bit (4) unaligned,
  5    74 	       3 zero3	      bit (2) unaligned,
  5    75 	       3 mf2	      unaligned,
  5    76 	         4 pr_spec	      bit (1) unaligned,
  5    77 	         4 reg_or_length  bit (1) unaligned,
  5    78 	         4 zero4	      bit (1) unaligned,
  5    79 	         4 reg_mod	      bit (4) unaligned,
  5    80 	       3 fill1_op	      bit (10) unaligned,
  5    81 	       3 zero5	      bit (1) unaligned,
  5    82 	       3 mf1	      unaligned,
  5    83 	         4 pr_spec	      bit (1) unaligned,
  5    84 	         4 reg_or_length  bit (1) unaligned,
  5    85 	         4 zero6	      bit (1) unaligned,
  5    86 	         4 reg_mod	      bit (4) unaligned,
  5    87 	     2 desc_ext	      unaligned,
  5    88 	       3 desc	      (512) unaligned,
  5    89 	         4 desc_od	      bit (36) unaligned;
  5    90 
  5    91 /* The detailed definitions of the fields in this structure
  5    92*   can be found in the GMAP manual section 8.
  5    93*   The desc_ext is the descriptor extension of this eis
  5    94*   instruction. The number of descriptors associated with
  5    95*   this instruction is equavalent to the operand number.
  5    96*   Depending on operand data type, the descriptor
  5    97*   can be alphanumeric or numeric.  The structures of the
  5    98*   alphanumeric and the numeric descriptors are defined
  5    99*   below. */
  5   100 
  5   101 /* alphanumeric descriptor format */
  5   102 
  5   103      dcl	   1 desc_an	      based (desc_an_ptr) unaligned,
  5   104 	     2 desc_f	      (512) unaligned,
  5   105 	       3 y	      unaligned,
  5   106 	         4 pr	      bit (3) unaligned,
  5   107 	         4 wd_offset      bit (15) unaligned,
  5   108 	       3 char_n	      bit (3) unaligned,
  5   109 	       3 zero1	      bit (1) unaligned,
  5   110 	       3 ta	      bit (2),
  5   111 	       3 n	      bit (12) unaligned;
  5   112 
  5   113 
  5   114 /* The detailed definitions of the fields in this structure can
  5   115*   be found in the GMAP manual section 8. */
  5   116 /* numeric descriptor format */
  5   117 
  5   118      dcl	   desc_nn_ptr	      ptr;
  5   119      dcl	   desc_an_ptr	      ptr;
  5   120 
  5   121 
  5   122      dcl	   1 desc_nn	      based (desc_nn_ptr) unaligned,
  5   123 	     2 desc_f	      (512) unaligned,
  5   124 	       3 y	      unaligned,
  5   125 	         4 pr	      bit (3) unaligned,
  5   126 	         4 wd_offset      bit (15) unaligned,
  5   127 	       3 digit_n	      bit (3) unaligned,
  5   128 	       3 tn	      bit (1) unaligned,
  5   129 	       3 sign_type	      bit (2) unaligned,
  5   130 	       3 scal	      bit (6) unaligned,
  5   131 	       3 n	      bit (6) unaligned;
  5   132 
  5   133 
  5   134 /* The detailed definitions of fields in this structure can
  5   135*   be found in the GMAP manual section 8. */
  5   136 /* END INCLUDE FILE ...   cobol_addr_tokens.incl.pl1 */
  5   137 
      441 
      442 
  6     1 
  6     2 /* BEGIN INCLUDE FILE ...   cobol_record_types.incl.pl1 */
  6     3 /*   <<<   LAST MODIFIED ON 09-09-75 by tlf   >>>   */
  6     4 
  6     5 dcl rtc_resword fixed bin (15) int static		init(1);
  6     6 dcl rtc_numlit fixed bin (15) int static		init(2);
  6     7 dcl rtc_alphalit fixed bin (15) int static		init(3);
  6     8 dcl rtc_picstring fixed bin (15) int static		init(4);
  6     9 dcl rtc_diag fixed bin (15) int static			init(5);
  6    10 dcl rtc_source fixed bin (15) int static		init(6);
  6    11 dcl rtc_procdef fixed bin (15) int static		init(7);
  6    12 dcl rtc_userwd fixed bin (15) int static		init(8);
  6    13 dcl rtc_dataname fixed bin (15) int static		init(9);
  6    14 dcl rtc_indexname fixed bin (15) int static		init(10);
  6    15 dcl rtc_condname fixed bin (15) int static 		init(11);
  6    16 dcl rtc_filedef fixed bin (15) int static 		init(12);
  6    17 dcl rtc_commdesc fixed bin (15) int static		init(13);
  6    18 dcl rtc_debugitems fixed bin (15) int static		init(14);
  6    19 dcl rtc_savedarea fixed bin (15) int static		init(15);
  6    20 dcl rtc_sortmerge fixed bin (15) int static		init(16);
  6    21 dcl rtc_mnemonic fixed bin (15) int static		init(17);
  6    22 dcl rtc_pararef fixed bin (15) int static		init(18);
  6    23 dcl rtc_eos fixed bin (15) int static 			init(19);
  6    24 dcl rtc_reportname fixed bin (15) int static		init(20);
  6    25 dcl rtc_groupname fixed bin (15) int static		init(21);
  6    26 dcl rtc_reportentry fixed bin (15) int static		init(22);
  6    27 dcl rtc_unknown1 fixed bin (15) int static		init(23);
  6    28 dcl rtc_debugenable fixed bin (15) int static		init(24);
  6    29 dcl rtc_unknown2 fixed bin (15) int static		init(25);
  6    30 dcl rtc_unknown3 fixed bin (15) int static		init(26);
  6    31 dcl rtc_unknown4 fixed bin (15) int static		init(27);
  6    32 dcl rtc_unknown5 fixed bin (15) int static		init(28);
  6    33 dcl rtc_unknown6 fixed bin (15) int static		init(29);
  6    34 dcl rtc_internal_tag fixed bin (15) int static		init(30);
  6    35 dcl rtc_equate_tag fixed bin (15) int static		init(31);
  6    36 dcl rtc_register fixed bin (15) int static		init(100);
  6    37 dcl rtc_fdec_temp fixed bin (15) int static		init(101);
  6    38 dcl rtc_immed_const fixed bin (15) int static		init(102);
  6    39 
  6    40 /* END INCLUDE FILE ...   cobol_record_types.incl.pl1 */
  6    41 
      443 
      444 
      445 /************************************************/
      446 /*	END OF OUTERMOST PROCEDURE		*/
      447 /*	cobol_get_index_value		*/
      448 /**************************************************/
      449 
      450 
      451 
      452      end cobol_get_index_value;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/24/89  0831.3  cobol_get_index_value.pl1         >spec>install>MR12.3-1048>cobol_get_index_value.pl1
437          1    03/27/82  0439.9  cobol_type9.incl.pl1              >ldd>include>cobol_type9.incl.pl1
1-17         2    11/11/82  1712.7  cobol_TYPE9.incl.pl1              >ldd>include>cobol_TYPE9.incl.pl1
439          3    03/27/82  0439.8  cobol_type10.incl.pl1             >ldd>include>cobol_type10.incl.pl1
3-20         4    11/11/82  1712.7  cobol_TYPE10.incl.pl1             >ldd>include>cobol_TYPE10.incl.pl1
441          5    05/24/89  0811.7  cobol_addr_tokens.incl.pl1        >spec>install>MR12.3-1048>cobol_addr_tokens.incl.pl1
443          6    03/27/82  0439.8  cobol_record_types.incl.pl1       >ldd>include>cobol_record_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 80 ref 159 160 161 162 173 260 260 335 335 355
                                                                                  383 413
alphanum                 21(19)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  187* 189*
ars_op                                 constant        bit(10)                  initial packed unaligned dcl 95 ref 305
binary                                                 builtin function         dcl 81 ref 292 306 314
bit                                                    builtin function         dcl 82 ref 292 306 314
btd_op                                 constant        bit(10)                  initial packed unaligned dcl 87 ref 412
char_offset               4            based           fixed bin(24,0)          level 2 dcl 5-23 set ref 249* 325*
cobol_addr                      000010 constant        entry                    external dcl 69 ref 233 251 327 408
cobol_alloc$stack               000014 constant        entry                    external dcl 71 ref 177 196 367
cobol_emit                      000012 constant        entry                    external dcl 70 ref 240 269 285 299 309 317 331 425
cobol_make_type9$copy           000016 constant        entry                    external dcl 72 ref 203
cobol_register$load             000020 constant        entry                    external dcl 74 ref 260
cobol_register$release          000022 constant        entry                    external dcl 75 ref 335
contains                  4     000350 automatic       fixed bin(17,0)          level 2 dcl 137 set ref 256*
data_name                              based           structure                level 1 unaligned dcl 1-16
desc_f                                 based           structure                array level 2 packed packed unaligned dcl 5-122
desc_nn                                based           structure                level 1 packed packed unaligned dcl 5-122
desc_nn_ptr                     000372 automatic       pointer                  dcl 5-118 set ref 413* 416 417 418 421
descrip                                based           bit(72)                  packed unaligned dcl 130 set ref 356* 384*
descrip_ptr                     000344 automatic       pointer                  dcl 129 set ref 355* 356 383* 384
display                  21(27)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  359* 387*
dn_ptr                          000340 automatic       pointer                  dcl 120 set ref 164* 166* 181 182 183 324 325 334
                                                                                  341 343 344 350 351 352 355 359 360 361 371 374*
                                                                                  375 376 377 378 379 380 381 383 385 386 387
elementary               21(09)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  361* 386*
file_section             21            based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref 355
                                                                                  383
fill1_op                  0(18)        based           bit(10)                  level 3 in structure "inst_struc" packed packed
                                                                                  unaligned dcl 5-66 in procedure
                                                                                  "cobol_get_index_value" set ref 237* 412*
fill1_op                  0(18)        based           bit(10)                  level 2 in structure "inst_struc_basic" packed
                                                                                  packed unaligned dcl 5-51 in procedure
                                                                                  "cobol_get_index_value" set ref 266* 278* 291*
                                                                                  305* 313* 330*
ind_ptr                         000362 automatic       pointer                  dcl 3-16 set ref 342* 343 344
index_name                             based           structure                level 1 unaligned dcl 3-19
input_buff                      000120 automatic       pointer                  array dcl 108 set ref 161
input_ptr                       000364 automatic       pointer                  dcl 5-18 set ref 161* 215 217 218 219 220 222 224
                                                                                  225 227 233* 246 247 248 249 251* 322 323 324 325
                                                                                  327* 392 394 395 396 397 399 401 404 406 408*
input_struc                            based           structure                level 1 unaligned dcl 5-32
input_struc_basic                      based           structure                level 1 unaligned dcl 5-23
input_token_ptr                        parameter       pointer                  dcl 44 set ref 32 170 187 188 203* 219 342
inst                                   based           structure                level 2 packed packed unaligned dcl 5-66
inst_buff                       000100 automatic       fixed bin(17,0)          array dcl 100 set ref 159 277* 290* 304* 312* 413
inst_ptr                        000366 automatic       pointer                  dcl 5-18 set ref 159* 233* 237 240* 251* 266 269*
                                                                                  278 279 280 285* 291 292 299* 305 306 309* 313 314
                                                                                  317* 327* 330 331* 408* 412 425*
inst_struc                             based           structure                level 1 dcl 5-66
inst_struc_basic                       based           structure                level 1 dcl 5-51
item_length              16            based           fixed bin(24,0)          level 2 dcl 1-16 set ref 350* 377*
lda_op                                 constant        bit(10)                  initial packed unaligned dcl 89 ref 278
ldq_op                                 constant        bit(10)                  initial packed unaligned dcl 90 ref 266
lls_op                                 constant        bit(10)                  initial packed unaligned dcl 93 ref 291
lock                      2     000350 automatic       fixed bin(17,0)          level 2 in structure "register_struc" dcl 137
                                                                                  in procedure "cobol_get_index_value" set ref 255*
lock                      2            based           fixed bin(17,0)          level 2 in structure "input_struc" dcl 5-32
                                                                                  in procedure "cobol_get_index_value" set ref 218*
                                                                                  395*
lrs_op                                 constant        bit(10)                  initial packed unaligned dcl 94 ref 313
mlr_op                                 constant        bit(10)                  initial packed unaligned dcl 88 ref 237
numeric                  21(17)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  360* 385*
offset                   24            based           fixed bin(24,0)          level 2 in structure "data_name" dcl 1-16
                                                                                  in procedure "cobol_get_index_value" set ref 183*
                                                                                  207* 249 325 344* 381*
offset                   14            based           fixed bin(24,0)          level 2 in structure "index_name" dcl 3-19
                                                                                  in procedure "cobol_get_index_value" ref 344
operand                   4            based           structure                array level 2 unaligned dcl 5-32
operand_no                1            based           fixed bin(17,0)          level 2 in structure "input_struc" dcl 5-32
                                                                                  in procedure "cobol_get_index_value" set ref 217*
                                                                                  394*
operand_no                1            based           fixed bin(17,0)          level 2 in structure "input_struc_basic" dcl 5-23
                                                                                  in procedure "cobol_get_index_value" set ref 247*
                                                                                  323*
output_token_ptr                       parameter       pointer                  dcl 45 ref 32 166 374 401
places_left              17            based           fixed bin(17,0)          level 2 dcl 1-16 set ref 351* 378*
places_right             20            based           fixed bin(17,0)          level 2 dcl 1-16 set ref 352* 379*
register_struc                  000350 automatic       structure                level 1 unaligned dcl 137 set ref 260 260 335 335
reloc_buff                      000105 automatic       fixed bin(17,0)          array dcl 104 set ref 160 283* 284* 297* 298*
reloc_ptr                       000370 automatic       pointer                  dcl 5-18 set ref 160* 233* 240* 251* 269* 285* 299*
                                                                                  309* 317* 327* 331* 408* 425*
return_decimal_value            000342 automatic       bit(1)                   packed unaligned dcl 123 set ref 151* 154* 164 363
return_value_code                      parameter       fixed bin(17,0)          dcl 43 ref 32 151
rtc_dataname                           constant        fixed bin(15,0)          initial dcl 6-13 ref 170 181 341 376
scal                      0(24)        based           bit(6)                   array level 3 packed packed unaligned dcl 5-122 set
                                                                                  ref 418* 421*
seg_num                  13            based           fixed bin(17,0)          level 2 in structure "index_name" dcl 3-19
                                                                                  in procedure "cobol_get_index_value" ref 343
seg_num                  23            based           fixed bin(17,0)          level 2 in structure "data_name" dcl 1-16
                                                                                  in procedure "cobol_get_index_value" set ref 182*
                                                                                  206* 248 324 343* 380*
segno                     3            based           fixed bin(17,0)          level 2 dcl 5-23 set ref 248* 324*
send_receive              6            based           fixed bin(17,0)          array level 3 dcl 5-32 set ref 220* 225* 397* 404*
sign_type                 0(22)        based           bit(2)                   array level 3 packed packed unaligned dcl 5-122 set
                                                                                  ref 417*
size                                   based           fixed bin(17,0)          level 2 dcl 1-16 set ref 375*
size_sw                  10            based           fixed bin(17,0)          array level 3 dcl 5-32 set ref 222* 227* 399* 406*
stq_op                                 constant        bit(10)                  initial packed unaligned dcl 96 ref 330
subscripted              22(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  209*
t_offset                        000346 automatic       fixed bin(17,0)          dcl 132 set ref 177* 183 196* 199* 199 207 367* 381
td                        0(32)        based           bit(4)                   level 2 packed packed unaligned dcl 5-51 set ref
                                                                                  280*
tm                        0(30)        based           bit(2)                   level 2 packed packed unaligned dcl 5-51 set ref
                                                                                  279*
tn                        0(21)        based           bit(1)                   array level 3 packed packed unaligned dcl 5-122 set
                                                                                  ref 416*
token_ptr                 4            based           pointer                  array level 3 dcl 5-32 set ref 219* 224* 396* 401*
type                                   based           fixed bin(17,0)          level 2 in structure "input_struc_basic" dcl 5-23
                                                                                  in procedure "cobol_get_index_value" set ref 246*
                                                                                  322*
type                      3            based           fixed bin(17,0)          level 2 in structure "data_name" dcl 1-16
                                                                                  in procedure "cobol_get_index_value" set ref 170
                                                                                  181* 341* 376*
type                                   based           fixed bin(17,0)          level 2 in structure "input_struc" dcl 5-32
                                                                                  in procedure "cobol_get_index_value" set ref 215*
                                                                                  392*
usage_index              21(34)        based           bit(1)                   level 2 packed packed unaligned dcl 1-16 set ref
                                                                                  188* 190*
wd_offset                 0(03)        based           bit(15)                  level 3 packed packed unaligned dcl 5-51 set ref
                                                                                  292* 306* 314*
what_reg                        000350 automatic       fixed bin(17,0)          level 2 dcl 137 set ref 254*
wkbuff1                         000214 automatic       fixed bin(17,0)          array dcl 112 set ref 162
wkbuff1_ptr                     000264 automatic       pointer                  dcl 113 set ref 162* 164 334* 371* 396
wkbuff2                         000266 automatic       fixed bin(17,0)          array dcl 117 set ref 173
wkbuff2_ptr                     000336 automatic       pointer                  dcl 118 set ref 173* 189 190 203* 206 207 209 224
                                                                                  248 249
y                                      based           structure                level 2 packed packed unaligned dcl 5-51

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
byte_offset                            automatic       bit(2)                   packed unaligned dcl 121
desc_an                                based           structure                level 1 packed packed unaligned dcl 5-103
desc_an_ptr                            automatic       pointer                  dcl 5-119
fixed                                                  builtin function         dcl 83
ldaq_op                                internal static bit(10)                  initial packed unaligned dcl 92
reloc_struc                            based           structure                array level 1 unaligned dcl 5-44
rtc_alphalit                           internal static fixed bin(15,0)          initial dcl 6-7
rtc_commdesc                           internal static fixed bin(15,0)          initial dcl 6-17
rtc_condname                           internal static fixed bin(15,0)          initial dcl 6-15
rtc_debugenable                        internal static fixed bin(15,0)          initial dcl 6-28
rtc_debugitems                         internal static fixed bin(15,0)          initial dcl 6-18
rtc_diag                               internal static fixed bin(15,0)          initial dcl 6-9
rtc_eos                                internal static fixed bin(15,0)          initial dcl 6-23
rtc_equate_tag                         internal static fixed bin(15,0)          initial dcl 6-35
rtc_fdec_temp                          internal static fixed bin(15,0)          initial dcl 6-37
rtc_filedef                            internal static fixed bin(15,0)          initial dcl 6-16
rtc_groupname                          internal static fixed bin(15,0)          initial dcl 6-25
rtc_immed_const                        internal static fixed bin(15,0)          initial dcl 6-38
rtc_indexname                          internal static fixed bin(15,0)          initial dcl 6-14
rtc_internal_tag                       internal static fixed bin(15,0)          initial dcl 6-34
rtc_mnemonic                           internal static fixed bin(15,0)          initial dcl 6-21
rtc_numlit                             internal static fixed bin(15,0)          initial dcl 6-6
rtc_pararef                            internal static fixed bin(15,0)          initial dcl 6-22
rtc_picstring                          internal static fixed bin(15,0)          initial dcl 6-8
rtc_procdef                            internal static fixed bin(15,0)          initial dcl 6-11
rtc_register                           internal static fixed bin(15,0)          initial dcl 6-36
rtc_reportentry                        internal static fixed bin(15,0)          initial dcl 6-26
rtc_reportname                         internal static fixed bin(15,0)          initial dcl 6-24
rtc_resword                            internal static fixed bin(15,0)          initial dcl 6-5
rtc_savedarea                          internal static fixed bin(15,0)          initial dcl 6-19
rtc_sortmerge                          internal static fixed bin(15,0)          initial dcl 6-20
rtc_source                             internal static fixed bin(15,0)          initial dcl 6-10
rtc_unknown1                           internal static fixed bin(15,0)          initial dcl 6-27
rtc_unknown2                           internal static fixed bin(15,0)          initial dcl 6-29
rtc_unknown3                           internal static fixed bin(15,0)          initial dcl 6-30
rtc_unknown4                           internal static fixed bin(15,0)          initial dcl 6-31
rtc_unknown5                           internal static fixed bin(15,0)          initial dcl 6-32
rtc_unknown6                           internal static fixed bin(15,0)          initial dcl 6-33
rtc_userwd                             internal static fixed bin(15,0)          initial dcl 6-12
shift_val                              automatic       fixed bin(17,0)          dcl 122

NAMES DECLARED BY EXPLICIT CONTEXT.
cobol_get_index_value           000010 constant        entry                    external dcl 32
start                           000015 constant        label                    dcl 151

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1062        1106     756        1072
Length      1420     756        24         276     103           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cobol_get_index_value               264 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cobol_get_index_value    000100 inst_buff                   cobol_get_index_value
                         000105 reloc_buff                  cobol_get_index_value
                         000120 input_buff                  cobol_get_index_value
                         000214 wkbuff1                     cobol_get_index_value
                         000264 wkbuff1_ptr                 cobol_get_index_value
                         000266 wkbuff2                     cobol_get_index_value
                         000336 wkbuff2_ptr                 cobol_get_index_value
                         000340 dn_ptr                      cobol_get_index_value
                         000342 return_decimal_value        cobol_get_index_value
                         000344 descrip_ptr                 cobol_get_index_value
                         000346 t_offset                    cobol_get_index_value
                         000350 register_struc              cobol_get_index_value
                         000362 ind_ptr                     cobol_get_index_value
                         000364 input_ptr                   cobol_get_index_value
                         000366 inst_ptr                    cobol_get_index_value
                         000370 reloc_ptr                   cobol_get_index_value
                         000372 desc_nn_ptr                 cobol_get_index_value

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cobol_addr                    cobol_alloc$stack             cobol_emit                    cobol_make_type9$copy
cobol_register$load           cobol_register$release

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000004       151 000015       154 000023       159 000025       160 000027       161 000031       162 000033
    164 000035       166 000041       170 000044       173 000051       177 000053       181 000070       182 000073
    183 000075       187 000077       188 000104       189 000106       190 000111       196 000113       199 000132
    203 000135       206 000147       207 000152       209 000154       215 000156       217 000160       218 000163
    219 000164       220 000170       222 000171       224 000172       225 000173       227 000175       233 000176
    237 000211       240 000215       246 000232       247 000234       248 000236       249 000241       251 000244
    254 000257       255 000261       256 000262       260 000263       266 000274       269 000300       277 000315
    278 000316       279 000322       280 000324       283 000330       284 000331       285 000332       290 000347
    291 000350       292 000354       297 000364       298 000365       299 000366       304 000403       305 000404
    306 000410       309 000420       312 000435       313 000436       314 000442       317 000452       322 000467
    323 000471       324 000473       325 000476       327 000500       330 000513       331 000517       334 000534
    335 000536       338 000547       341 000550       342 000553       343 000554       344 000556       350 000561
    351 000564       352 000566       355 000567       356 000571       359 000574       360 000576       361 000600
    363 000602       367 000604       371 000622       374 000624       375 000630       376 000632       377 000634
    378 000636       379 000640       380 000641       381 000643       383 000645       384 000647       385 000652
    386 000654       387 000656       392 000660       394 000662       395 000665       396 000666       397 000670
    399 000671       401 000672       404 000675       406 000677       408 000700       412 000713       413 000717
    416 000721       417 000724       418 000727       421 000732       425 000735       452 000752


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
