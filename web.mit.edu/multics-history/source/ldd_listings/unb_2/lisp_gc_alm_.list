ASSEMBLY LISTING OF SEGMENT >spec>on>06/27/83>lisp_gc_alm_.alm                
ASSEMBLED ON:	07/06/83  0927.3 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.4  April 1981    
ASSEMBLER CREATED:	11/03/82  1423.6 mst Wed

                                     1  " **************************************************************
                                     2  " *                                                            *
                                     3  " * Copyright, (C) Massachusetts Institute of Technology, 1973 *
                                     4  " *                                                            *
                                     5  " **************************************************************
                                     6  "
                                     7  " lisp_gc_alm_: ALM portion of lisp garbage collector
                                     8  " Its history is unknown by the current maintainers.
                                     9  "
                                    10  
                                    11  	tempd	args(2)
                                    12  	tempd	save_pr2
                                    13  	tempd	array_data_ptr_ptr
                                    14  	tempd	new_seg_ptr
                                    15  	tempd	vector_ret
                                    16  	tempd	cur_atom
                                    17  	tempd 	cur_bucket_cell
                                    18  	tempd	old_nil
                                    19  	temp	vector_left
                                    20  	temp	cur_vec_entry
                                    21  	temp	dope_vec_size
                                    22  	temp	mark_size
                                    23  	temp	copy_size
                                    24  	temp	vector_thread
                                    25  	temp	gctwa_flag
                                    26  	temp	gctwa_thread
                                    27  	temp	gctwa_final
                                    28  	include	lisp_iochan
                                   1-1  
                                   1-2  """ BEGIN INCLUDE FILE lisp_iochan.incl.alm
                                   1-3  
                                   1-4  """ This is the format of the iochan block, which is used to control i/o operations
                                   1-5  """ There is one iochan block for each logical channel.
                                   1-6  """ A logical channel converses with a sequence of blocks,
                                   1-7  """ which are buffers for a stream or segments for a(multi-seg)file.
                                   1-8  
                        000000     1-9  	equ	iochan.ioindex,0		current character position in buffer or segment
                        000001    1-10  	equ	iochan.iolength,1		number of characters in buffer or segment
                        000002    1-11  	equ	iochan.ioptr,2		-> buffer or base of segment
                        000004    1-12  	equ	iochan.thread,4		threaded list of all open iochans
                        000006    1-13  	equ	iochan.fcbp,6		for tssi_
                        000010    1-14  	equ	iochan.aclinfop,8		..
                        000012    1-15  	equ	iochan.component,10	0 for stream, comp no for msf
                        000013    1-16  	equ	iochan.charpos,11
                        000014    1-17  	equ	iochan.linel,12
                        000015    1-18  	equ	iochan.flags,13
                        400000    1-19  	bool	iochan.seg,400000		1 => msf, 0 => stream
                        200000    1-20  	bool	iochan.read,200000		0 => openi, 1 => not
                        100000    1-21  	bool	iochan.write,100000		0 => openo, 1 => not
                        040000    1-22  	bool	iochan.gc_mark,40000	for the garbage collector
                        020000    1-23  	bool	iochan.interactive,20000	1 => input => this is the tty
                                  1-24  "					     output => flush buff after each operation
                        010000    1-25  	bool	iochan.must_reopen,10000	1 => saved iochan, must re-open before use
                        004000    1-26  	bool	iochan.nlsync,4000		1 => there is a NL in the buffer.
                        002000    1-27  	bool	iochan.charmode,2000	enables "instant" ios_$write
                        001000    1-28  	bool	iochan.extra_nl_done,1000	last char output was extra NL for chrct
                        000400    1-29  	bool	iochan.fixnum_mode,400	for use with in and out functions
                        000200    1-30  	bool	iochan.image_mode,200	just suppress auto-nl
                        210400    1-31  	bool	not_ok_to_read,210400	mask for checking input chan
                        110400    1-32  	bool	not_ok_to_write,110400	mask for checking output chan
                                  1-33  
                        000016    1-34  	equ	iochan.function,14		** gc-able **  eoffn (input) or endpagefn (output)
                        000020    1-35  	equ	iochan.namelist,16		** gc-able **  list of names, car is directory pathname
                        000022    1-36  	equ	iochan.name,18		stream name or entry name
                        000032    1-37  	equ	iochan.pagel,26
                        000033    1-38  	equ	iochan.linenum,27
                        000034    1-39  	equ	iochan.pagenum,28
                        000035    1-40  	equ	iochan.End,29		size of this structure.
                                  1-41  
                        736777    1-42  	bool	flag_reset_mask,736777	anded into flags after each char
                                  1-43  
                                  1-44  """ END INCLUDE FILE lisp_iochan.incl.alm
                                    29  	include	lisp_object_types
                                   2-1  
                                   2-2  " BEGIN INCLUDE FILE lisp_object_types.incl.alm
                                   2-3  "
                                   2-4  " D.A.Moon 14 July 72
                                   2-5  
                                   2-6  "These are bit masks used to check or set the type bits in lisp pointers
                                   2-7  "they should be used with cana instructions in the dl mode.
                                   2-8  "
                                   2-9  " Modified 1 Oct 1972 by Dan Bricklin to add bignum types.
                                  2-10  
                                  2-11  
                                  2-12  
                        077700    2-13  	bool	lisp_ptr.type,077700	"the whole type field
                                  2-14  
                        040000    2-15  	bool	Fixed,040000		"fixed number, stored in second word of ptr
                        020000    2-16  	bool	Float,020000		"floating number, stored in second word of ptr
                        061400    2-17  	bool	Numeric,061400		"fixed or float, big or little
                        010000    2-18  	bool	Atsym,010000		"Atomic symbol pointed at by ptr
                        077700    2-19  	bool	Atomic,077700		"any of these bits indicates an atom (non-list)
                        001000    2-20  	bool	Bignum,001000		"points to a bignum - fixed
                        060000    2-21  	bool	Uncollectable,060000	"not a pointer, also both bits on = "pdl_ptr"
                        004000    2-22  	bool	String,004000		"points at a lisp character string
                        002000    2-23  	bool	Subr,002000		"points at subr link
                        000400    2-24  	bool	System_Subr,000400		"marks a subr as being in the text of lisp bound seg.
                        000200    2-25  	bool	Array,000200		"points at an array,
                                  2-26  					" which is a special kind of subr
                        067500    2-27  	bool	Unevalable,067500		"any of these bits means
                                  2-28  					" does not have car and cdr
                        001000    2-29  	bool	Big_fixed,001000		"points to fixed bignum
                        000100    2-30  	bool	File,000100		"points to a file object (i.e. an iochan)
                                  2-31  
                                  2-32  "fields for making numbers, a fault tag is included in case someone takes the car or cdr of it
                                  2-33  
                        040047    2-34  	bool	fixnum_type,040047
                        020047    2-35  	bool	flonum_type,020047
                                  2-36  
                                  2-37  " END INCLUDE FILE: lisp_object_types.incl.alm
                                    30  	even
    000000  aa   000000 000004      31  noargs:	zero	0,4
    000001  aa   000000 000000      32  	zero	0,0
    000002  aa   000002 000004      33  onearg:	zero	2,4
    000003  aa   000000 000000      34  	zero	0,0
    000004  aa   077777 000043      35  nullptr:	its	-1,1
    000005  aa   000001 000000 
                                    36  
                        000006      37  	entry	collect
    000006  aa   000120 6270 00     38  collect:	push
    000007  aa  7 00040 2721 20
    000010  aa  0 00002 2351 20     39  	lda	pr0|2,*		" test for gctwa mode.
    000011  aa  6 00100 7551 00     40  	sta	gctwa_flag
    000012  4a  4 00010 2371 20     41  	ldaq	<lisp_static_vars_>|[nil]
    000013  aa  6 00070 7571 00     42  	staq	old_nil			" copy for later use
    000014  4a  4 00012 3715 20     43  	epp5	<lisp_alloc_>|[cur_seg],*
    000015  aa  0 00004 6515 20     44  	spri5	pr0|4,*		" return value is list of old segment.
    000016  0a   000004 3714 20     45  	epp5	nullptr,*
    000017  0a   000753 7050 00     46  	tsx5	get_initial_segment	" this entry skips
    000020  aa   000000 0110 00     47  	nop
    000021  0a   001006 3734 00     48  	epp7	=0
    000022  aa  6 00077 5471 00     49  	sprp7	vector_thread
    000023  aa  6 00101 5471 00     50  	sprp7	gctwa_thread
    000024  aa  6 00102 5471 00     51  	sprp7	gctwa_final
                                    52  
    000025  4a  4 00014 2351 20     53  	lda	<lisp_static_vars_>|[number_gc_ptrs]
    000026  aa   000000 5310 00     54  	neg	0
    000027  aa  6 00072 7551 00     55  	sta	vector_left
    000030  4a  4 00016 3515 20     56  	epp1	<lisp_static_vars_>|[garbage_collected_ptrs]
    000031  aa  6 00062 3571 00     57  	stcd	vector_ret
    000032  0a   000054 7100 00     58  	tra	vector_loop
                                    59  
    000033  4a  4 00020 3515 20     60  	epp1	<lisp_static_vars_>|[stack_ptr],*
    000034  aa  1 00000 6351 00     61  	eaa	pr1|0
    000035  aa   000023 7710 00     62  	arl	18+1		"divide by 2
    000036  aa   000000 5310 00     63  	neg	0
    000037  aa  6 00072 7551 00     64  	sta	vector_left
    000040  aa  1 00000 3511 00     65  	epbp1	pr1|0		" start at base of stack
    000041  aa  6 00062 3571 00     66  	stcd	vector_ret
    000042  0a   000054 7100 00     67  	tra	vector_loop
                                    68  
    000043                          69  handle_vectors_encountered:		" this is now in vector_ret.
    000043  aa  6 00077 7601 00     70  	lprp0	vector_thread
    000044  aa  0 00000 2341 00     71  	szn	pr0|0	" end of vector thread is a zero word.
    000045  0a   000063 6000 00     72  	tze	gctwa_phs1
    000046  aa  0 00001 2351 00     73  	lda	pr0|1
    000047  aa   000000 5310 00     74  	neg
    000050  aa  6 00072 7551 00     75  	sta	vector_left
    000051  aa  0 00002 2351 00     76  	lda	pr0|2
    000052  aa  6 00077 7551 00     77  	sta	vector_thread
    000053  aa  0 00000 7611 00     78  	lprp1	pr0|0
                                    79  "	stcd	vector_ret
                                    80  "	tra	vector_loop
                                    81  "	tra	handle_vectors_encountered
    000054                          82  vector_loop:
    000054  aa  6 00073 5411 00     83  	sprp1	cur_vec_entry	"pr1 points to current slot in vector to ahndle.
    000055  0a   000632 7040 00     84  	tsx4	copylist
    000056  aa  6 00073 7611 00     85  	lprp1	cur_vec_entry
    000057  aa  1 00002 3515 00     86  	epp1	pr1|2		" move to next entry
    000060  aa  6 00072 0541 00     87  	aos	vector_left
    000061  0a   000054 6040 00     88  	tmi	vector_loop
    000062  aa  6 00062 6101 00     89  	rtcd	vector_ret
                                    90  
    000063                          91  gctwa_phs1:			" see if anything is on gctwa thread,
                                    92  				" process first element, then go back to
                                    93  				" handle any vectors encountered.
                                    94  				" this phase just collects all worthy atoms --
                                    95  				" those that have a value or non-nil plist.
    000063  aa  6 00101 7611 00     96  	lprp1	gctwa_thread
    000064  aa  1 00000 2341 00     97  	szn	pr1|0		" test for empty thread
    000065  0a   000126 6000 00     98  	tze	gctwa_phs2	" if no elements on list, handle rest of gctwa.
    000066  aa  1 00000 7601 00     99  	lprp0	pr1|0		" get pointer to obarray.
    000067  aa  1 00001 2351 00    100  	lda	pr1|1		" and number of elements in it (buckets)
    000070  aa   000000 5310 00    101  	neg
    000071  aa  6 00072 7551 00    102  	sta	vector_left
    000072  aa  1 00002 2361 00    103  	ldq	pr1|2		" move down gctwa_thread
    000073  aa  6 00101 7561 00    104  	stq	gctwa_thread
                                   105  
    000074  aa  6 00102 2361 00    106  	ldq	gctwa_final	" thread block onto phase 2 thread
    000075  aa  1 00002 7561 00    107  	stq	pr1|2
    000076  aa  6 00102 5411 00    108  	sprp1	gctwa_final
                                   109  
    000077                         110  ph1_vec_loop:			" loop over all buckets.
    000077  aa  6 00073 5401 00    111  	sprp0	cur_vec_entry
    000100  aa  0 00000 3515 20    112  	epp1	pr0|0,*		" get first bucket ptr.
    000101                         113  ph1_lst_loop:				" loop over list, until a cell already seen is encountered.
    000101  aa  1 00000 2371 00    114  	ldaq	pr1|0		" get car of first cell.
    000102  0a   000121 6040 00    115  	tmi	ph1_next_bucket
    000103  aa  6 00064 7571 00    116  	staq	cur_atom		" if not marked, must be atom (maybe worthwhile)
    000104  aa  1 00002 2371 00    117  	ldaq	pr1|2		" get ptr to next cell
    000105  aa  6 00066 7571 00    118  	staq	cur_bucket_cell
    000106  aa  6 00064 3501 20    119  	epp0	cur_atom,*		" get ptr to atom
    000107  aa  0 00000 2371 00    120  	ldaq	pr0|0		" and test its car.
    000110  0a   000117 6040 00    121  	tmi	ph1_next_atom	" already seen and marked,
    000111  0a   000115 6054 00    122  	tpnz	worthy_atom	" this is a worthy atom because it has a value.
    000112  aa  0 00002 2371 00    123  	ldaq	pr0|2		" load plist ptr
    000113  aa  6 00070 1171 00    124  	cmpaq	old_nil	" nil should have been collected already!
    000114  0a   000117 6000 00    125  	tze	ph1_next_atom
    000115                         126  worthy_atom:
    000115  aa  6 00064 3515 00    127  	epp1	cur_atom		" collect the atom. We know it has not already been seen.
    000116  0a   000634 7040 00    128  	tsx4	cplistlp		" SO, we call past the already_seen check.
    000117                         129  ph1_next_atom:
    000117  aa  6 00066 3515 20    130  	epp1	cur_bucket_cell,*	" get ptr to next bucket cell.
    000120  0a   000101 7100 00    131  	tra	ph1_lst_loop
    000121                         132  ph1_next_bucket:
    000121  aa  6 00073 7601 00    133  	lprp0	cur_vec_entry
    000122  aa  0 00002 3501 00    134  	epp0	pr0|2			" move to next bucket
    000123  aa  6 00072 0541 00    135  	aos	vector_left
    000124  0a   000077 6040 00    136  	tmi	ph1_vec_loop
                                   137  
    000125  0a   000043 7100 00    138  	tra	handle_vectors_encountered	" may have found new vectors or obarrays to collect.
                                   139  
    000126                         140  gctwa_phs2:
    000126  aa  6 00102 7611 00    141  	lprp1	gctwa_final
    000127  aa  1 00000 2341 00    142  	szn	pr1|0
    000130  0a   000166 6000 00    143  	tze	scan_maknum
    000131  aa  1 00000 7601 00    144  	lprp0	pr1|0		" get next element.
    000132  aa  1 00001 2351 00    145  	lda	pr1|1
    000133  aa   000000 5310 00    146  	neg
    000134  aa  6 00072 7551 00    147  	sta	vector_left
    000135  aa  1 00002 2361 00    148  	ldq	pr1|2
    000136  aa  6 00102 7561 00    149  	stq	gctwa_final		" thread off list.
                                   150  
    000137                         151  ph2_vec_loop:
    000137  aa  0 00000 3535 00    152  	epp3	pr0|0			" keep ptr to place to patch in next bucket cell
    000140  aa  0 00000 3515 20    153  	epp1	pr0|0,*			" get ptr to first cell in bucket.
    000141                         154  ph2_lst_loop:
    000141  aa  1 00000 2371 00    155  	ldaq	pr1|0			" check for end (a marked cell)
    000142  0a   000160 6040 00    156  	tmi	ph2_end_list
    000143  aa  1 00000 2371 20    157  	ldaq	pr1|0,*			" load car of atom to test if marked.
    000144  0a   000156 6050 00    158  	tpl	ph2_worthless		" if not seen yet, worthless.
    000145  aa   400000 6750 03    159  	era	=o400000,du		" clear mark bit, to get new location
    000146                         160  ph2_make_cell:
    000146  aa  5 00002 3521 53    161  	epp2	pr5|2,ad		" allocate a cons cell to append to bucket
    000147  0a   000153 6070 00    162  	ttf	ph2_made_cell
    000150  0a   000751 7050 00    163  	tsx5	tally_ran_out		" handle tally runout
    000151  0a   000153 7100 00    164  	tra	ph2_made_cell
    000152  0a   000146 7100 00    165  	tra	ph2_make_cell
    000153                         166  ph2_made_cell:
    000153  aa  2 00000 7571 00    167  	staq	pr2|0		" store worthy atom in car of cell
    000154  aa  3 00000 2521 00    168  	spri2	pr3|0		" patch new cell in at end of list
    000155  aa  2 00002 3535 00    169  	epp3	pr2|2		" and new place to patch is cdr of new cell.
    000156                         170  ph2_worthless:
    000156  aa  1 00002 3515 20    171  	epp1	pr1|2,*		" get ptr to next cell
    000157  0a   000141 7100 00    172  	tra	ph2_lst_loop
    000160                         173  ph2_end_list:
    000160  aa   400000 6750 03    174  	era	=o400000,du	" turn off mark bit to get ptr to tail of bucket list
    000161  aa  3 00000 7571 00    175  	staq	pr3|0		" patch it into end of new list.
    000162  aa  0 00002 3501 00    176  	epp0	pr0|2		" move to next bucket
    000163  aa  6 00072 0541 00    177  	aos	vector_left
    000164  0a   000137 6040 00    178  	tmi	ph2_vec_loop
                                   179  
    000165  0a   000126 7100 00    180  	tra	gctwa_phs2	" and go handle next obarray
                                   181  
                                   182  
    000166                         183  scan_maknum:
    000166  4a  4 00022 3515 20    184  	epp1	<lisp_static_vars_>|[maknum_table_ptr],*
    000167  4a  4 00024 2361 20    185  	ldq	<lisp_static_vars_>|[maknum_mask]
    000170  aa   000001 0760 07    186  	adq	1,dl
    000171  0a   000257 6000 00    187  	tze	retrn
    000172  4a  4 00026 4501 20    188  	stz	<lisp_static_vars_>|[maknum_left]
    000173  aa   000044 7370 00    189  	lls	36	divide by 8 and shift to negate
    000174  aa   000003 7710 00    190  	arl	3
    000175  aa   000000 5310 00    191  	neg
    000176  aa  6 00072 7551 00    192  	sta	vector_left	" number of entries in maknum hash table.
                                   193  
    000177                         194  maknum_scan_loop:
    000177  aa  1 00000 2361 00    195  	ldq	pr1|0		" type is in low-order 9 bits.
    000200  0a   000244 6000 00    196  	tze	next_entry
    000201  aa   000600 3160 07    197  	canq	(Fixed+Float)/64,dl	
    000202  0a   000216 6010 00    198  	tnz	ok_entry
    000203  aa  1 00001 7601 00    199  	lprp0	pr1|1
    000204  aa   000021 3160 07    200  	canq	(Subr+File)/64,dl	" check for subrs arrays and files.
    000205  0a   000220 6010 00    201  	tnz	ck_saf_maknum_entry
    000206  aa  0 00000 2371 00    202  	ldaq	pr0|0		" load word with mark bit.
    000207  0a   000243 6050 00    203  	tpl	not_ok_entry		" entry not otherwise protected.
    000210  aa   200000 3150 03    204  	cana	=o200000,du		" for bignums, have to check second bit,
    000211  0a   000243 6010 00    205  	tnz	not_ok_entry		" which should be off for ptrs, but may be on in negative bignums.
    000212  aa   400000 6750 03    206  	era	=o400000,du		" turn off mark bit.
    000213  aa  1 00001 7551 00    207  	sta	pr1|1		" store new address (segno part)
    000214  aa   000022 7720 00    208  	qrl	18
    000215  aa  1 00001 5521 14    209  	stbq	pr1|1,14		" and word part in lower two bytes.
    000216  4a  4 00026 0541 20    210  ok_entry:aos	<lisp_static_vars_>|[maknum_left]
    000217  0a   000244 7100 00    211  	tra	next_entry
    000220                         212  ck_saf_maknum_entry:
    000220  aa   000001 3160 07    213  	canq	File/64,dl
    000221  0a   000237 6010 00    214  	tnz	file_maknum_entry
    000222  aa   000002 3160 07    215  	canq	Array/64,dl
    000223  0a   000235 6010 00    216  	tnz	array_maknum_entry
    000224  aa  0 00001 7201 00    217  	lxl0	pr0|1			" check array type.
    000225  aa   700004 1000 03    218  	cmpx0	=o700004,du		" should be tsx0 ,ic if compiled subr.
    000226  0a   000216 6010 00    219  	tnz	ok_entry		" if not compiled, ok to keep in maknum table
    000227  aa  0 00001 2201 00    220  	ldx0	pr0|1			" otherwise check to see if already seen
    000230  aa  0 77776 3501 10    221  	epp0	pr0|-2,x0		" get subr header
    000231  aa  0 00007 2201 00    222  	ldx0	pr0|7			" get gc_mark halfword
    000232                         223  test_maknum_gc_mark:
    000232  4a  4 00030 3001 20    224  	canx0	<lisp_static_vars_>|[gc_mark_bits]
    000233  0a   000216 6010 00    225  	tnz	ok_entry
    000234  0a   000243 7100 00    226  	tra	not_ok_entry
    000235                         227  array_maknum_entry:
    000235  aa  0 00000 7201 00    228  	lxl0	pr0|0			" load gc_mark_ bits
    000236  0a   000232 7100 00    229  	tra	test_maknum_gc_mark
    000237                         230  file_maknum_entry:
    000237  aa  0 00015 2201 00    231  	ldx0	pr0|iochan.flags
    000240  aa   040000 3000 03    232  	canx0	iochan.gc_mark,du
    000241  0a   000216 6010 00    233  	tnz	ok_entry
    000242  0a   000243 7100 00    234  	tra	not_ok_entry
                                   235  
    000243                         236  not_ok_entry:
    000243  aa  1 00000 4501 00    237  	stz	pr1|0		" clear type and uid word of maknum table entry
    000244                         238  next_entry:
    000244  aa  1 00002 3515 00    239  	epp1	pr1|2
    000245  aa  6 00072 0541 00    240  	aos	vector_left
    000246  0a   000177 6040 00    241  	tmi	maknum_scan_loop
                                   242  
    000247                         243  done_maknum_scan:
    000247  aa   400000 2350 03    244  	lda	=o400000,du
    000250  4a  4 00032 7551 20    245  	sta	<lisp_static_vars_>|[garbage_collect_inhibit]
    000251  0a   000000 3500 00    246  	epp0	noargs
    000252  aa  6 00000 3731 00    247  	epbp7	pr6|0			" find stack base.
    000253  4a  4 00034 3521 20    248  	short_call <lisp_alloc_>|[rehash_maknum]
    000254  aa  7 00036 6701 20
    000255  aa  6 00030 3701 20
    000256  4a  4 00032 4501 20    249  	stz	<lisp_static_vars_>|[garbage_collect_inhibit]
                                   250  
    000257                         251  retrn:
    000257  aa  6 00000 3731 00    252  	epbp7	pr6|0		" make return know where stack base is.
    000260  aa  7 00042 7101 20    253  	return
                                   254  
    000261                         255  already_seen:			" called with pr1 pointing at object.
                                   256  				" call is tsx7.  routine returns to next
                                   257  				" instruction, having patched doubleword
                                   258  				" at pr1 if object has been moved already.
                                   259  				" if an Atsym or Cons, and not yet moved,
                                   260  				" then routine skips on return.
                                   261  
    000261  aa  1 00000 2371 00    262  	ldaq	pr1|0		" load object to test for 0
    000262  aa   000000 6000 17    263  	tze	0,x7		" (uninitialized atsym or stack entry)
                                   264  
    000263  aa   060077 3750 07    265  	ana	=o060077,dl	" mask out modifier
                                   266  				"exit on non-gc'able strings, too.
    000264  aa   000043 1150 07    267  	cmpa	=o43,dl		" and check for its.
    000265  aa   000000 6010 17    268  	tnz	0,x7		" must be number or error.
                                   269  
    000266  aa  1 00000 2351 00    270  	lda	pr1|0		" load type field again.
    000267  aa   067700 3150 07    271  	cana	Atomic-Atsym,dl	" see if atomic. (atsym is treated like cons)
    000270  0a   000276 6010 00    272  	tnz	seen_atoms
                                   273  
    000271                         274  test_cons:
    000271  aa  1 00000 2371 20    275  	ldaq	pr1|0,*		" load car of cons.
    000272  aa   000001 6050 17    276  	tpl	1,x7		" mark bit not set, so not seen yet.
    000273                         277  unmark_return:
    000273  aa   400000 6750 03    278  	era	=o400000,du		" clear mark bit.
    000274  aa  1 00000 7571 00    279  	staq	pr1|0			" store new location in argument.
    000275  aa   000000 7100 17    280  	tra	0,x7			" return as already seen.
                                   281  
    000276                         282  seen_atoms:
    000276  aa   002000 3150 07    283  	cana	Subr,dl
    000277  0a   000412 6010 00    284  	tnz	test_subr
                                   285  
    000300  aa   000100 3150 07    286  	cana	File,dl
    000301  0a   000365 6010 00    287  	tnz	test_file
                                   288  
    000302  aa   001000 3150 07    289  	cana	Bignum,dl
    000303  0a   000334 6010 00    290  	tnz	test_bignum
                                   291  
    000304  aa   004000 3150 07    292  	cana	String,dl
    000305  0a   000307 6010 00    293  	tnz	test_string
                                   294  
                                   295  	"ERROR IF GET HERE.
    000306  aa   000000 7100 17    296  	tra	0,x7
                                   297  
                                   298  
    000307                         299  test_string:
    000307  aa  1 00000 2371 20    300  	ldaq	pr1|0,*
    000310  0a   000273 6040 00    301  	tmi	unmark_return
    000311  aa   000044 7730 00    302  	lrl	36
    000312  aa   000003 0760 07    303  	adq	3,dl	" extra cells of 4 words (16 bytes to allocate)
    000313  aa   000004 7720 00    304  	qrl	4
    000314  0a   000726 7060 00    305  	tsx6	allocate_cells
    000315  aa  6 00054 2521 00    306  	spri2	save_pr2
    000316  aa  1 00000 3521 20    307  	epp2	pr1|0,*
    000317  aa  2 00000 2361 00    308  	ldq	pr2|0		"get length.
    000320  aa   000004 0760 07    309  	adq	4,dl
    000321  aa  0 00140 1005 40    310  	mlr	(pr,rl),(pr,rl)
    000322  aa   200000 000006     311  	desc9a	pr2|0,ql
    000323  aa   000000 000006     312  	desc9a	pr0|0,ql
    000324  aa  1 00000 2501 00    313  	spri0	pr1|0	" now store new address back.
    000325  aa  1 00000 2371 00    314  	ldaq	pr1|0	" and set type
    000326  aa   004000 2750 07    315  	ora	String,dl
    000327  aa  1 00000 7571 00    316  	staq	pr1|0
    000330  aa   400000 2750 03    317  	ora	=o400000,du	" and set mark bit.
    000331  aa  2 00000 7571 00    318  	staq	pr2|0
    000332  aa  6 00054 3521 20    319  	epp2	save_pr2,*	" get back pr2
    000333  aa   000000 7100 17    320  	tra	0,x7
                                   321  
    000334                         322  test_bignum:
                                   323  	" a bignum is marked by having the mark bit on, and the second
                                   324  	" bit off (normally the two high-order bits are on or off together).
    000334  aa  1 00000 2371 20    325  	ldaq	pr1|0,*		" load first double-word
    000335  0a   000340 6050 00    326  	tpl	unseen_bignum
    000336  aa   200000 3150 03    327  	cana	=o200000,du	" test second bit.
    000337  0a   000273 6000 00    328  	tze	unmark_return
    000340                         329  unseen_bignum:
    000340  aa   000044 7730 00    330  	lrl	36
    000341  aa   777777 3760 07    331  	anq	-1,dl	" mask out length.
    000342  aa   000002 7720 00    332  	qrl	2	" divide by 4 (alloc multiple of 4)
    000343  0a   000726 7060 00    333  	tsx6	allocate_cells
    000344  aa  6 00054 2521 00    334  	spri2	save_pr2
    000345  aa  1 00000 3521 20    335  	epp2	pr1|0,*
    000346  aa  2 00000 2361 00    336  	ldq	pr2|0
    000347  aa   777777 3760 07    337  	anq	-1,dl
    000350  aa   000002 7360 00    338  	qls	2
    000351  aa   000004 0760 07    339  	adq	4,dl
    000352  aa  0 00140 1005 40    340  	mlr	(pr,rl),(pr,rl)
    000353  aa   200000 000006     341  	desc9a	pr2|0,ql
    000354  aa   000000 000006     342  	desc9a	pr0|0,ql
    000355  aa  1 00000 2501 00    343  	spri0	pr1|0
    000356  aa  1 00000 2371 00    344  	ldaq	pr1|0
    000357  aa   001000 2750 07    345  	ora	Bignum,dl
    000360  aa  1 00000 7571 00    346  	staq	pr1|0
    000361  aa   400000 2750 03    347  	ora	=o400000,du
    000362  aa  2 00000 7571 00    348  	staq	pr2|0
    000363  aa  6 00054 3521 20    349  	epp2	save_pr2,*
    000364  aa   000000 7100 17    350  	tra	0,x7
                                   351  
    000365                         352  test_file:
    000365  aa  1 00000 3501 20    353  	epp0	pr1|0,*	get address of file block.
    000366  aa  0 00015 2351 00    354  	lda	pr0|iochan.flags
    000367  aa   040000 3150 03    355  	cana	iochan.gc_mark,du
    000370  aa   000000 6010 17    356  	tnz	0,x7			" return if marked already.
                                   357  
    000371  aa   040000 2750 03    358  	ora	iochan.gc_mark,du
    000372  aa  0 00015 7551 00    359  	sta	pr0|iochan.flags
                                   360  
    000373  aa  0 00016 3501 00    361  	epp0	pr0|iochan.function
    000374  aa  6 00054 2521 00    362  	spri2	save_pr2
    000375                         363  allocate_file_thread_block:
    000375  aa  5 00002 3521 53    364  	epp2	pr5|2,ad
    000376  0a   000402 6070 00    365  	ttf	file_thread_block_made
    000377  0a   000751 7050 00    366  	tsx5	tally_ran_out
    000400  0a   000402 7100 00    367  	tra	file_thread_block_made
    000401  0a   000375 7100 00    368  	tra 	allocate_file_thread_block
    000402                         369  file_thread_block_made:
    000402  aa  2 00000 5401 00    370  	sprp0	pr2|0
    000403  aa   000002 2360 07    371  	ldq	2,dl
    000404  aa  2 00001 7561 00    372  	stq	pr2|1
    000405  aa  6 00077 2361 00    373  	ldq	vector_thread
    000406  aa  2 00002 7561 00    374  	stq	pr2|2
    000407  aa  6 00077 5421 00    375  	sprp2	vector_thread
    000410  aa  6 00054 3521 20    376  	epp2	save_pr2,*
    000411  aa   000000 7100 17    377  	tra	0,x7
                                   378  
    000412                         379  test_subr:
    000412  aa  1 00000 3501 20    380  	epp0	pr1|0,*		" get what subr object points at.
    000413  aa   000001 3160 03    381  	canq	1,du		" fix odd address, which arises in subr links to subrs and arrays.
    000414  aa   000002 6000 04    382  	tze	2,ic
    000415  aa  0 77777 3501 00    383  	epp0	pr0|-1
                                   384  
    000416  aa   000200 3150 07    385  	cana	Array,dl		" screen out arrays.
    000417  0a   000451 6010 00    386  	tnz	test_array
                                   387  
    000420  aa  0 00001 7201 00    388  	lxl0	pr0|1	" load 2nd word of subr entry.
    000421  aa   700004 1000 03    389  	cmpx0	=o700004,du	" tsx0 ..,ic
    000422  aa   000000 6010 17    390  	tnz	0,x7		" if not this value, then nothing to do.
                                   391  
    000423  aa  0 00001 2201 00    392  	ldx0	pr0|1		" to get to header.
    000424  aa  0 77777 3501 10    393  	epp0	pr0|-1,x0
                                   394  
    000425  aa  0 00007 2201 00    395  	ldx0	pr0|7		" gc mark.
    000426  4a  4 00030 3001 20    396  	canx0	<lisp_static_vars_>|[gc_mark_bits]
    000427  aa   000000 6010 17    397  	tnz	0,x7
                                   398  	
                                   399  "	THREAD SUBR ONTO VECTOR THREAD
                                   400  "	AND MARK.
                                   401  
    000430  4a  4 00030 2201 20    402  	ldx0	<lisp_static_vars_>|[gc_mark_bits]
    000431  aa  0 00007 7401 00    403  	stx0	pr0|7
    000432  aa  6 00054 2521 00    404  	spri2	save_pr2
    000433                         405  retry_subr_block_thread:
    000433  aa  5 00002 3521 53    406  	epp2	pr5|2,ad
    000434  0a   000440 6070 00    407  	ttf	subr_thread_block_made
    000435  0a   000751 7050 00    408  	tsx5	tally_ran_out
    000436  0a   000440 7100 00    409  	tra	subr_thread_block_made
    000437  0a   000433 7100 00    410  	tra 	retry_subr_block_thread
    000440                         411  subr_thread_block_made:
    000440  aa  6 00077 2361 00    412  	ldq	vector_thread
    000441  aa  2 00002 7561 00    413  	stq	pr2|2
    000442  aa  0 00007 7201 00    414  	lxl0	pr0|7
    000443  aa  2 00001 4401 00    415  	sxl0	pr2|1
    000444  aa  0 00010 3501 00    416  	epp0	pr0|8
    000445  aa  2 00000 5401 00    417  	sprp0	pr2|0
    000446  aa  6 00077 5421 00    418  	sprp2	vector_thread
    000447  aa  6 00054 3521 20    419  	epp2	save_pr2,*
    000450  aa   000000 7100 17    420  	tra	0,x7
                                   421  
                                   422  
    000451                         423  test_array:
    000451  aa  0 00000 7201 00    424  	lxl0	pr0|0	"gc mark.
    000452  4a  4 00030 3001 20    425  	canx0	<lisp_static_vars_>|[gc_mark_bits]
    000453  aa   000000 6010 17    426  	tnz	0,x7
                                   427  
                                   428  " NOW COPY ARRAY BODY, PYT ARRAY ON LIST, AND MARK.
                                   429  
    000454  4a  4 00030 2201 20    430  	ldx0	<lisp_static_vars_>|[gc_mark_bits]
    000455  aa  0 00000 4401 00    431  	sxl0	pr0|0		"mark array.
                                   432  
    000456  aa  0 00007 2201 00    433  	ldx0	pr0|7		" get type.
    000457  0a   000460 7100 10    434  	tra	array_handlers,x0
    000460                         435  array_handlers:
    000460  0a   000621 7100 00    436  	tra	S_expr_array
    000461  0a   000621 7100 00    437  	tra	Un_gc_array
    000462  0a   000506 7100 00    438  	tra	number_array
    000463  0a   000506 7100 00    439  	tra	number_array
    000464  0a   000530 7100 00    440  	tra	readtable_array
    000465  0a   000576 7100 00    441  	tra	obarray_array
    000466  aa   000000 7100 17    442  	tra	0,x7		" dead array, nothing to do.
                                   443  
    000467                         444  compute_size:
    000467  aa  0 00007 7221 00    445  	lxl2	pr0|7	" offset to bounds array.
    000470  aa   000000 6350 12    446  	eaa	0,x2		" get size of dope vector in words.
    000471  aa   000000 5310 00    447  	neg
    000472  aa   000022 7710 00    448  	arl	18
    000473  aa  6 00074 7551 00    449  	sta	dope_vec_size
    000474  aa  6 00054 2521 00    450  	spri2	save_pr2
    000475  aa  0 00002 3521 00    451  	epp2	pr0|2	" get ptr to array_data_ptr
    000476  aa  6 00056 2521 00    452  	spri2	array_data_ptr_ptr
    000477  aa  2 00000 3521 20    453  	epp2	pr2|0,*
    000500  aa   000001 2360 07    454  	ldq	1,dl
    000501  aa  2 77776 3521 00    455  csizelp:	epp2	pr2|-2
    000502  aa  2 00000 4021 00    456  	mpy	pr2|0
    000503  aa   000002 6220 12    457  	eax2	2,x2
    000504  0a   000501 6040 00    458  	tmi	csizelp
    000505  aa   000000 7100 16    459  	tra	0,x6
                                   460  
    000506                         461  number_array:
    000506  aa  0 00007 7221 00    462  	lxl2	pr0|7		Check for external array
    000507  aa   000000 6000 17    463  	tze	0,7		Leave alone if so.
    000510  0a   000467 7060 00    464  	tsx6	compute_size
    000511  aa  6 00074 0761 00    465  	adq	dope_vec_size
    000512  aa  6 00076 7561 00    466  	stq	copy_size
    000513  aa   000001 1760 07    467  	sbq	1,dl		" to get number of additional blocks to allocate.
    000514  aa   000002 7710 00    468  	arl	2		" divide by 4.
    000515  0a   000726 7060 00    469  	tsx6	allocate_cells
    000516  aa  6 00076 2361 00    470  	ldq	copy_size
    000517  aa   000002 7360 00    471  	qls	2	" 4 bytes per word.
    000520  aa  0 00140 1005 40    472  	mlr 	(pr,rl),(pr,rl)
    000521  aa   200000 000006     473  	desc9a	pr2|0,ql
    000522  aa   000000 000006     474  	desc9a	pr0|0,ql
    000523  aa  6 00074 2361 00    475  	ldq	dope_vec_size
    000524  aa  0 00000 3501 06    476  	epp0	pr0|0,ql
    000525  aa  6 00056 2501 20    477  	spri0	array_data_ptr_ptr,*
    000526  aa  6 00054 3521 20    478  	epp2	save_pr2,*
    000527  aa   000000 7100 17    479  	tra	0,x7
                                   480  
                                   481  
    000530                         482  readtable_array:
    000530  aa  6 00054 2521 00    483  	spri2	save_pr2
    000531  aa  0 00002 3521 20    484  	epp2	pr0|2,*
    000532  aa  2 77776 3521 00    485  	epp2	pr2|-2
    000533  aa  0 00002 3501 00    486  	epp0	pr0|2
    000534  aa  6 00056 2501 00    487  	spri0	array_data_ptr_ptr
    000535  aa   000110 2360 07    488  	ldq	72,dl	" readtable size in 4 word blocks - 1
    000536  0a   000726 7060 00    489  	tsx6	allocate_cells
    000537  aa   002220 2360 07    490  	ldq	73*16,dl	" number of bytes to move.
    000540  aa  0 00140 1005 40    491  	mlr	(pr,rl),(pr,rl)
    000541  aa   200000 000006     492  	desc9a	pr2|0,ql
    000542  aa   000000 000006     493  	desc9a	pr0|0,ql
    000543  aa  0 00002 3501 00    494  	epp0	pr0|2		" offset of data part
    000544  aa  6 00056 2501 20    495  	spri0	array_data_ptr_ptr,*
                                   496  
    000545  aa  2 00000 5401 00    497  	sprp0	pr2|0		" thread of gc'able vectors.
    000546  aa   000011 2360 07    498  	ldq	9,dl		" number of markable-from words.
    000547  aa  2 00001 7561 00    499  	stq	pr2|1
    000550  aa  6 00077 2361 00    500  	ldq	vector_thread
    000551  aa  2 00002 7561 00    501  	stq	pr2|2		" thread in to vector list
    000552  aa  6 00077 5421 00    502  	sprp2	vector_thread
                                   503  
    000553  aa  6 00054 3521 20    504  	epp2	save_pr2,*
    000554  aa   000000 7100 17    505  	tra	0,x7
                                   506  
    000555                         507  copy_array:			" called with tsx3.
    000555  0a   000467 7060 00    508  	tsx6	compute_size
    000556  aa  6 00075 7561 00    509  	stq	mark_size
    000557  aa   000001 7360 00    510  	qls	1
    000560  aa  6 00074 0761 00    511  	adq	dope_vec_size
    000561  aa  6 00076 7561 00    512  	stq	copy_size
    000562  aa   000001 1760 07    513  	sbq	1,dl
    000563  aa   000002 7720 00    514  	qrl	2		" q now has 1 less than number of 4word blocks.
    000564  0a   000726 7060 00    515  	tsx6	allocate_cells
    000565  aa  6 00076 2361 00    516  	ldq	copy_size
    000566  aa   000002 7360 00    517  	qls	2
    000567  aa  0 00140 1005 40    518  	mlr	(pr,rl),(pr,rl)
    000570  aa   200000 000006     519  	desc9a	pr2|0,ql
    000571  aa   000000 000006     520  	desc9a	pr0|0,ql
    000572  aa  6 00074 2361 00    521  	ldq	dope_vec_size
    000573  aa  0 00000 3501 06    522  	epp0	pr0|0,ql
    000574  aa  6 00056 2501 20    523  	spri0	array_data_ptr_ptr,*
    000575  aa   000000 7100 13    524  	tra	0,x3
                                   525  
    000576                         526  obarray_array:
    000576  aa  6 00100 2341 00    527  	szn	gctwa_flag
    000577  0a   000621 6000 00    528  	tze	S_expr_array		" if not doing gctwa, treat as ordinary array
                                   529  
    000600  0a   000555 7030 00    530  	tsx3	copy_array
                                   531  
                                   532  	" now thread hash table part onto gctwa_thread, and single char atoms
                                   533  	" on vector_thread
                                   534  
    000601  aa  2 00000 5401 00    535  	sprp0	pr2|0
    000602  aa   000777 2360 07    536  	ldq	511,dl
    000603  aa  2 00001 7561 00    537  	stq	pr2|1
    000604  aa  6 00101 2361 00    538  	ldq	gctwa_thread
    000605  aa  2 00002 7561 00    539  	stq	pr2|2
    000606  aa  6 00101 5421 00    540  	sprp2	gctwa_thread
                                   541  
    000607  aa  0 01776 3501 00    542  	epp0	pr0|511*2
    000610  aa  2 00003 3521 00    543  	epp2	pr2|3	" gctwa list cell uses 3 words, get vector list cell
    000611  aa  2 00000 5401 00    544  	sprp0	pr2|0		" store ptr to singl char atom table.
    000612  aa   000200 2360 07    545  	ldq	128,dl		" size of single char atom table
    000613  aa  2 00001 7561 00    546  	stq	pr2|1
    000614  aa  6 00077 2361 00    547  	ldq	vector_thread
    000615  aa  2 00002 7561 00    548  	stq	pr2|2
    000616  aa  6 00077 5421 00    549  	sprp2	vector_thread
                                   550  
    000617  aa  6 00054 3521 20    551  	epp2	save_pr2,*
    000620  aa   000000 7100 17    552  	tra	0,x7
                                   553  
    000621                         554  Un_gc_array:
    000621                         555  S_expr_array:
    000621  0a   000555 7030 00    556  	tsx3	copy_array
    000622  aa  2 00000 5401 00    557  	sprp0	pr2|0
    000623  aa  6 00075 2361 00    558  	ldq	mark_size
    000624  aa  2 00001 7561 00    559  	stq	pr2|1
    000625  aa  6 00077 2361 00    560  	ldq	vector_thread
    000626  aa  2 00002 7561 00    561  	stq	pr2|2
    000627  aa  6 00077 5421 00    562  	sprp2	vector_thread
                                   563  
    000630  aa  6 00054 3521 20    564  	epp2	save_pr2,*
    000631  aa   000000 7100 17    565  	tra	0,x7
                                   566  
                                   567  
                                   568  " copylist is called by a tsx4, with pr1 pointing at a double-word containing
                                   569  " some lisp object.
                                   570  " copylist implements a modified version of Douglas Clark's linearizing
                                   571  " garbage collection algorithm.
                                   572  " Atomic symbols are treated as list cells for this algorithm.
                                   573  " Other types, such as arrays, files, subr blocks, etc. are copied
                                   574  " into the new segments, marked, and threaded onto a list called
                                   575  " "vector thread".  The lisp objects they contain are not
                                   576  " processed by copylist.
                                   577  
    000632  0a   000261 7070 00    578  copylist:	tsx7	already_seen
    000633  aa   000000 7100 14    579  	tra	0,x4
                                   580  
    000634                         581  cplistlp:
    000634  0a   000662 7070 00    582  	tsx7	copycell
                                   583  
    000635  aa  3 00002 3515 00    584  	epp1	pr3|2		"check cdr of currently copied cell.
    000636  0a   000261 7070 00    585  	tsx7	already_seen
    000637  0a   000647 7100 00    586  	tra	cdr_already_seen
                                   587  
    000640  aa  3 00000 3515 00    588  	epp1	pr3|0
    000641  0a   000261 7070 00    589  	tsx7	already_seen
    000642  0a   000645 7100 00    590  	tra	car_seen_but_not_cdr
                                   591  
                                   592  	" both car and cdr not seen yet. so thread old cell onto
                                   593  	" continuation list.
                                   594  
    000643  aa  2 00002 6535 00    595  	spri7	pr2|2
    000644  aa  2 00000 3735 00    596  	epp7	pr2|0
                                   597  
    000645                         598  car_seen_but_not_cdr:
    000645  aa  3 00002 3515 00    599  	epp1	pr3|2	" proceed with cdr.
    000646  0a   000634 7100 00    600  	tra	cplistlp
                                   601  
    000647                         602  cdr_already_seen:
    000647  aa  3 00000 3515 00    603  	epp1	pr3|0
    000650  0a   000261 7070 00    604  	tsx7	already_seen	"check car.
    000651  0a   000653 7100 00    605  	tra	ck_continuation	" both car and cdr have been seen, so stop with current list.
                                   606  
                                   607  "	epp1	pr3|0	not needed because done just above.
    000652  0a   000634 7100 00    608  	tra	cplistlp
                                   609  
    000653                         610  ck_continuation:
    000653  aa  7 00000 2341 00    611  	szn	pr7|0	" pr7 starts out pointing to a zero word.
    000654  aa   000000 6000 14    612  	tze	0,x4
                                   613  
                                   614  	" NOTE: following depends on hardware not looking at high order bits
                                   615  	" in indirecting through a double-word.
                                   616  
    000655  aa  7 00000 3515 20    617  	epp1	pr7|0,*
    000656  aa  7 00002 3735 20    618  	epp7	pr7|2,*		" advance through continuation list.
                                   619  
    000657  0a   000271 7070 00    620  	tsx7	test_cons	" we know it is a cons or atsym here.
    000660  0a   000653 7100 00    621  	tra	ck_continuation
    000661  0a   000634 7100 00    622  	tra	cplistlp
                                   623  
    000662                         624  copycell:
                                   625  	" Input: pr1 -> cons or atsym ptr to copy.
                                   626  	" Output: pr2 = old address from object.
                                   627  	"	pr3 = new object address.
                                   628  	"	new object's car and cdr have been copied from old.
                                   629  	"	pr1 -> copied address (new form of input object).
                                   630  	" 	old object's car points to new object, and mark bit (sign bit)
                                   631  	" 	is turned on.
                                   632  
    000662  aa  1 00000 3521 20    633  	epp2	pr1|0,*
                                   634  
    000663  aa  1 00000 7261 00    635  	lxl6	pr1|0		"check type (cons or atsym).
    000664  aa   010000 3060 03    636  	canx6	Atsym,du
    000665  0a   000701 6010 00    637  	tnz	copyatsym
    000666                         638  copycons:
    000666  aa  5 00002 3535 53    639  	epp3	pr5|2,ad	" allocate a cons cell.
    000667  0a   000740 6064 00    640  	ttn	tally_out_on_cons
    000670  aa  1 00000 2535 00    641  consalloc:spri3	pr1|0
                                   642  
    000671  aa  2 00000 2371 00    643  	ldaq	pr2|0
    000672  aa  3 00000 7571 00    644  	staq	pr3|0
    000673  aa  2 00002 2371 00    645  	ldaq	pr2|2
    000674  aa  3 00002 7571 00    646  	staq	pr3|2
                                   647  
    000675  aa  1 00000 2371 00    648  	ldaq	pr1|0	"store new address with mark bit on.
    000676  aa   400000 2750 03    649  	ora	=o400000,du
    000677  aa  2 00000 7571 00    650  	staq	pr2|0	" in old cell.
    000700  aa   000000 7100 17    651  	tra	0,x7
                                   652  
    000701                         653  copyatsym:
    000701  aa  2 00004 2361 00    654  	ldq	pr2|4	" get atsym pname length.
    000702  aa   000023 0760 07    655  	adq	19,dl	" 15+4 (number of bytes to allocate in addition to cons part)
    000703  aa   000004 7720 00    656  	qrl	4	"16 bytes per 4 words.
                                   657  
    000704  aa  5 00002 3535 53    658  	epp3	pr5|2,ad
    000705  0a   000743 6064 00    659  	ttn	tally_out_on_atsym
    000706                         660  atsymalloc:
    000706  aa  5 00002 6201 53    661  	eax0	pr5|2,ad	" NOTE: all atsyms require at least one loop.
    000707  0a   000746 6064 00    662  	ttn	tally_out_on_atsym_lp
    000710                         663  atsymalloc_lp:
    000710  aa   000001 1760 07    664  	sbq	1,dl
    000711  0a   000706 6054 00    665  	tpnz	atsymalloc
                                   666  
    000712  aa  2 00004 2361 00    667  	ldq	pr2|4		" determine size to copy.
    000713  aa   000024 0760 07    668  	adq	20,dl		" 20 bytes of stuff precede name.
    000714  aa  0 00140 1005 40    669  	mlr	(pr,rl),(pr,rl)
    000715  aa   200000 000006     670  	desc9a	pr2|0,ql
    000716  aa   300000 000006     671  	desc9a	pr3|0,ql
                                   672  
    000717  aa  1 00000 2535 00    673  	spri3	pr1|0
    000720  aa  1 00000 2371 00    674  	ldaq	pr1|0
    000721  aa   010000 2750 07    675  	ora	Atsym,dl
    000722  aa  1 00000 7571 00    676  	staq	pr1|0
    000723  aa   400000 2750 03    677  	ora	=o400000,du
    000724  aa  2 00000 7571 00    678  	staq	pr2|0
    000725  aa   000000 7100 17    679  	tra	0,x7
                                   680  
    000726                         681  allocate_cells:	"called with tsx6, ql contains number cells -1, returns with pr0
                                   682  		" pointing at allocated block.
    000726  aa   000000 6200 06    683  	eax0	0,ql
    000727  aa  5 00002 3501 53    684  	epp0	pr5|2,ad
    000730  0a   000735 6064 00    685  	ttn	tally_out_on_allocate
    000731  aa   777777 6200 10    686  alcellp:	eax0	-1,x0
    000732  aa   000000 6040 16    687  	tmi	0,x6
    000733  aa  5 00002 6211 53    688  	eax1	pr5|2,ad
    000734  0a   000731 6070 00    689  	ttf	alcellp
                                   690  
    000735                         691  tally_out_on_allocate:
    000735  0a   000751 7050 00    692  	tsx5	tally_ran_out
    000736  0a   000731 7100 00    693  	tra	alcellp
    000737  0a   000726 7100 00    694  	tra	allocate_cells
                                   695  
    000740                         696  tally_out_on_cons:
    000740  0a   000751 7050 00    697  	tsx5	tally_ran_out
    000741  0a   000670 7100 00    698  	tra	consalloc
    000742  0a   000666 7100 00    699  	tra	copycons
                                   700  
    000743                         701  tally_out_on_atsym:
    000743  0a   000751 7050 00    702  	tsx5	tally_ran_out
    000744  0a   000706 7100 00    703  	tra	atsymalloc
    000745  0a   000701 7100 00    704  	tra	copyatsym
    000746                         705  tally_out_on_atsym_lp:
    000746  0a   000751 7050 00    706  	tsx5	tally_ran_out
    000747  0a   000710 7100 00    707  	tra	atsymalloc_lp
    000750  0a   000701 7100 00    708  	tra	copyatsym
                                   709  
    000751                         710  tally_ran_out:			" skips if a new segment had to be made.
    000751  4a  4 00036 0541 20    711  	aos	<lisp_alloc_>|[seg_blk_cntr]
    000752  aa   000000 6040 15    712  	tmi	0,x5
    000753                         713  get_initial_segment:
    000753  aa  6 00000 2541 00    714  	spri	pr6|0
    000754  aa  6 00040 7531 00    715  	sreg	pr6|32
                                   716  
    000755  aa  6 00060 3501 00    717  	epp0	new_seg_ptr
    000756  aa  6 00052 2501 00    718  	spri0	args+2
    000757  0a   000002 2370 00    719  	ldaq	onearg
    000760  aa  6 00050 7571 00    720  	staq	args
    000761  aa  6 00050 3501 00    721  	epp0	args
    000762  aa  6 00000 3731 00    722  	epbp7	pr6|0
    000763  4a  4 00040 3521 20    723  	short_call	<lisp_segment_manager_>|[get_lists]
    000764  aa  7 00036 6701 20
    000765  aa  6 00030 3701 20
                                   724  
    000766  aa  6 00000 1731 00    725  	lpri	pr6|0
    000767  aa  6 00060 6515 20    726  	spri5	new_seg_ptr,*
    000770  aa  6 00060 3715 20    727  	epp5	new_seg_ptr,*
    000771  4a  4 00042 6515 20    728  	spri5	<lisp_alloc_>|[cur_seg]	" store away new allocation segment addresses.
    000772  4a  4 00044 6515 20    729  	spri5	<lisp_alloc_>|[consptr]
    000773  0a   001007 2350 00    730  	lda	=o2000053	" make consptr point up 2, and add in ad modifier.
    000774  4a  4 00046 7551 20    731  	sta	<lisp_alloc_>|[consptr]+1
    000775  0a   001010 2350 00    732  	lda	=o4740004
    000776  aa  5 00002 7551 00    733  	sta	pr5|2
    000777  aa   000020 3350 07    734  	lca	16,dl
    001000  4a  4 00036 7551 20    735  	sta	<lisp_alloc_>|[seg_blk_cntr]
    001001  aa  6 00040 0731 00    736  	lreg	pr6|32
    001002  aa   000001 7100 15    737  	tra	1,x5
                                   738  
                                   739  	end
ENTRY SEQUENCES
     
    001003  5a   000012 0000 00
    001004  aa  7 00046 2721 20
    001005  0a   000006 7100 00
LITERALS
     
    001006  aa   000000 000000 
    001007  aa   000002 000053 
    001010  aa   000004 740004 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001011  5a   000003 000000 
    001012  5a   000026 600000 
    001013  aa   000000 000000 
    001014  55   000012 000002 
    001015  5a   000002 400003 
    001016  55   000006 000012 
    001017  aa  014 154 151 163
    001020  aa  160 137 147 143
    001021  aa  137 141 154 155
    001022  aa  137 000 000 000
    001023  55   000017 000003 
    001024  0a   001004 500000 
    001025  55   000015 000003 
    001026  aa  007 143 157 154         collect
    001027  aa  154 145 143 164
    001030  55   000002 000012 
    001031  6a   000000 400002 
    001032  55   000022 000003 
    001033  aa  014 163 171 155         symbol_table
    001034  aa  142 157 154 137
    001035  aa  164 141 142 154
    001036  aa  145 000 000 000

DEFINITIONS HASH TABLE

    001037  aa   000000 000015 
    001040  aa   000000 000000 
    001041  aa   000000 000000 
    001042  aa   000000 000000 
    001043  aa   000000 000000 
    001044  aa   000000 000000 
    001045  aa   000000 000000 
    001046  5a   000017 000000 
    001047  aa   000000 000000 
    001050  aa   000000 000000 
    001051  5a   000012 000000 
    001052  aa   000000 000000 
    001053  aa   000000 000000 
    001054  aa   000000 000000 

EXTERNAL NAMES

    001055  aa  007 143 157 156         consptr
    001056  aa  163 160 164 162
    001057  aa  011 147 145 164         get_lists
    001060  aa  137 154 151 163
    001061  aa  164 163 000 000
    001062  aa  025 154 151 163         lisp_segment_manager_
    001063  aa  160 137 163 145
    001064  aa  147 155 145 156
    001065  aa  164 137 155 141
    001066  aa  156 141 147 145
    001067  aa  162 137 000 000
    001070  aa  014 163 145 147         seg_blk_cntr
    001071  aa  137 142 154 153
    001072  aa  137 143 156 164
    001073  aa  162 000 000 000
    001074  aa  015 162 145 150         rehash_maknum
    001075  aa  141 163 150 137
    001076  aa  155 141 153 156
    001077  aa  165 155 000 000
    001100  aa  027 147 141 162         garbage_collect_inhibit
    001101  aa  142 141 147 145
    001102  aa  137 143 157 154
    001103  aa  154 145 143 164
    001104  aa  137 151 156 150
    001105  aa  151 142 151 164
    001106  aa  014 147 143 137         gc_mark_bits
    001107  aa  155 141 162 153
    001110  aa  137 142 151 164
    001111  aa  163 000 000 000
    001112  aa  013 155 141 153         maknum_left
    001113  aa  156 165 155 137
    001114  aa  154 145 146 164
    001115  aa  013 155 141 153         maknum_mask
    001116  aa  156 165 155 137
    001117  aa  155 141 163 153
    001120  aa  020 155 141 153         maknum_table_ptr
    001121  aa  156 165 155 137
    001122  aa  164 141 142 154
    001123  aa  145 137 160 164
    001124  aa  162 000 000 000
    001125  aa  011 163 164 141         stack_ptr
    001126  aa  143 153 137 160
    001127  aa  164 162 000 000
    001130  aa  026 147 141 162         garbage_collected_ptrs
    001131  aa  142 141 147 145
    001132  aa  137 143 157 154
    001133  aa  154 145 143 164
    001134  aa  145 144 137 160
    001135  aa  164 162 163 000
    001136  aa  016 156 165 155         number_gc_ptrs
    001137  aa  142 145 162 137
    001140  aa  147 143 137 160
    001141  aa  164 162 163 000
    001142  aa  007 143 165 162         cur_seg
    001143  aa  137 163 145 147
    001144  aa  013 154 151 163         lisp_alloc_
    001145  aa  160 137 141 154
    001146  aa  154 157 143 137
    001147  aa  003 156 151 154         nil
    001150  aa  021 154 151 163         lisp_static_vars_
    001151  aa  160 137 163 164
    001152  aa  141 164 151 143
    001153  aa  137 166 141 162
    001154  aa  163 137 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    001155  aa   000004 000000 
    001156  55   000133 000044 
    001157  aa   000004 000000 
    001160  55   000051 000046 
    001161  aa   000004 000000 
    001162  55   000133 000057 
    001163  aa   000004 000000 
    001164  55   000133 000063 
    001165  aa   000004 000000 
    001166  55   000137 000067 
    001167  aa   000004 000000 
    001170  55   000137 000075 
    001171  aa   000004 000000 
    001172  55   000137 000101 
    001173  aa   000004 000000 
    001174  55   000137 000104 
    001175  aa   000004 000000 
    001176  55   000137 000107 
    001177  aa   000004 000000 
    001200  55   000137 000114 
    001201  aa   000004 000000 
    001202  55   000137 000117 
    001203  aa   000004 000000 
    001204  55   000137 000125 
    001205  aa   000004 000000 
    001206  55   000133 000131 
    001207  aa   000004 000000 
    001210  55   000137 000136 
    001211  aa   000001 000000 
    001212  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    001213  5a   000144 000001 
    001214  5a   000144 000000 
    001215  5a   000146 000000 
    001216  5a   000150 000000 
    001217  5a   000152 000000 
    001220  5a   000154 000000 
    001221  5a   000156 000000 
    001222  5a   000160 000000 
    001223  5a   000162 000000 
    001224  5a   000164 000000 
    001225  5a   000166 000000 
    001226  5a   000170 000000 
    001227  5a   000172 000000 
    001230  5a   000174 000000 
    001231  5a   000176 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001011 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000050 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         lisp_static_vars_|nil
    000011  5a   000220 0000 00
    000012  9a   777766 0000 46         lisp_alloc_|cur_seg
    000013  5a   000217 0000 20
    000014  9a   777764 0000 46         lisp_static_vars_|number_gc_ptrs
    000015  5a   000216 0000 00
    000016  9a   777762 0000 46         lisp_static_vars_|garbage_collected_ptrs
    000017  5a   000215 0000 00
    000020  9a   777760 0000 46         lisp_static_vars_|stack_ptr
    000021  5a   000214 0000 20
    000022  9a   777756 0000 46         lisp_static_vars_|maknum_table_ptr
    000023  5a   000213 0000 20
    000024  9a   777754 0000 46         lisp_static_vars_|maknum_mask
    000025  5a   000212 0000 00
    000026  9a   777752 0000 46         lisp_static_vars_|maknum_left
    000027  5a   000211 0000 00
    000030  9a   777750 0000 46         lisp_static_vars_|gc_mark_bits
    000031  5a   000210 0000 00
    000032  9a   777746 0000 46         lisp_static_vars_|garbage_collect_inhibit
    000033  5a   000207 0000 00
    000034  9a   777744 0000 46         lisp_alloc_|rehash_maknum
    000035  5a   000206 0000 00
    000036  9a   777742 0000 46         lisp_alloc_|seg_blk_cntr
    000037  5a   000205 0000 00
    000040  9a   777740 0000 46         lisp_segment_manager_|get_lists
    000041  5a   000204 0000 00
    000042  9a   777736 0000 46         lisp_alloc_|cur_seg
    000043  5a   000217 0000 00
    000044  9a   777734 0000 46         lisp_alloc_|consptr
    000045  5a   000203 0000 00
    000046  9a   777732 0000 46         lisp_alloc_|consptr
    000047  5a   000202 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 111316 
    000005  aa   510113 575622 
    000006  aa   000000 112002 
    000007  aa   325446 625737 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000236 
    000020  aa   000000 000136 
    000021  aa   000000 000215 
    000022  aa   000226 000136 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056064 
    000030  aa   040040 101160 
    000031  aa   162151 154040 
    000032  aa   061071 070061 
    000033  aa   040040 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000003 
    000066  aa   000102 000042 
    000067  aa   117710 106006 
    000070  aa   000000 111771 
    000071  aa   743241 200000 
    000072  aa   000113 000041 
    000073  aa   106701 741740 
    000074  aa   000000 110670 
    000075  aa   211446 200000 
    000076  aa   000124 000047 
    000077  aa   106701 741731 
    000100  aa   000000 110670 
    000101  aa   211444 000000 
    000102  aa   076163 160145          >spec>on>06/27/83>lisp_gc_alm_.alm
    000103  aa   143076 157156 
    000104  aa   076060 066057 
    000105  aa   062067 057070 
    000106  aa   063076 154151 
    000107  aa   163160 137147 
    000110  aa   143137 141154 
    000111  aa   155137 056141 
    000112  aa   154155 040040 
    000113  aa   076154 144144          >ldd>include>lisp_iochan.incl.alm
    000114  aa   076151 156143 
    000115  aa   154165 144145 
    000116  aa   076154 151163 
    000117  aa   160137 151157 
    000120  aa   143150 141156 
    000121  aa   056151 156143 
    000122  aa   154056 141154 
    000123  aa   155040 040040 
    000124  aa   076154 144144          >ldd>include>lisp_object_types.incl.alm
    000125  aa   076151 156143 
    000126  aa   154165 144145 
    000127  aa   076154 151163 
    000130  aa   160137 157142 
    000131  aa   152145 143164 
    000132  aa   137164 171160 
    000133  aa   145163 056151 
    000134  aa   156143 154056 
    000135  aa   141154 155040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         731    alcellp                  lisp_gc_alm_:       686,  689,  693.
         726    allocate_cells           lisp_gc_alm_:       305,  333,  469,  489,  515,  681,  694.
         375    allocate_file_thread_block     lisp_gc_alm_:       363,  368.
         261    already_seen             lisp_gc_alm_:       255,  578,  585,  589,  604.
          50    args                     lisp_gc_alm_:        11,  718,  720,  721.
         200    Array                    lisp_gc_alm_:       215,  385,
                                         lisp_object_types:   25.
          56    array_data_ptr_ptr       lisp_gc_alm_:        13,  452,  477,  487,  495,  523.
         460    array_handlers           lisp_gc_alm_:       434,  435.
         235    array_maknum_entry       lisp_gc_alm_:       216,  227.
       77700    Atomic                   lisp_gc_alm_:       271,
                                         lisp_object_types:   19.
       10000    Atsym                    lisp_gc_alm_:       271,  636,  675,
                                         lisp_object_types:   18.
         706    atsymalloc               lisp_gc_alm_:       660,  665,  703.
         710    atsymalloc_lp            lisp_gc_alm_:       663,  707.
        1000    Bignum                   lisp_gc_alm_:       289,  345,
                                         lisp_object_types:   20.
        1000    Big_fixed                lisp_object_types:   29.
         645    car_seen_but_not_cdr     lisp_gc_alm_:       590,  598.
         647    cdr_already_seen         lisp_gc_alm_:       586,  602.
         653    ck_continuation          lisp_gc_alm_:       605,  610,  621.
         220    ck_saf_maknum_entry      lisp_gc_alm_:       201,  212.
           6    collect                  lisp_gc_alm_:        37,   38.
         467    compute_size             lisp_gc_alm_:       444,  464,  508.
         670    consalloc                lisp_gc_alm_:       641,  698.
                consptr                  lisp_gc_alm_:       729,  731.
         701    copyatsym                lisp_gc_alm_:       637,  653,  704,  708.
         662    copycell                 lisp_gc_alm_:       582,  624.
         666    copycons                 lisp_gc_alm_:       638,  699.
         632    copylist                 lisp_gc_alm_:        84,  578.
         555    copy_array               lisp_gc_alm_:       507,  530,  556.
          76    copy_size                lisp_gc_alm_:        23,  466,  470,  512,  516.
         634    cplistlp                 lisp_gc_alm_:       128,  581,  600,  608,  622.
         501    csizelp                  lisp_gc_alm_:       455,  458.
          64    cur_atom                 lisp_gc_alm_:        16,  116,  119,  127.
          66    cur_bucket_cell          lisp_gc_alm_:        17,  118,  130.
                cur_seg                  lisp_gc_alm_:        43,  728.
          73    cur_vec_entry            lisp_gc_alm_:        20,   83,   85,  111,  133.
         247    done_maknum_scan         lisp_gc_alm_:       243.
          74    dope_vec_size            lisp_gc_alm_:        21,  449,  465,  475,  511,  521.
         100    File                     lisp_gc_alm_:       200,  213,  286,
                                         lisp_object_types:   30.
         237    file_maknum_entry        lisp_gc_alm_:       214,  230.
         402    file_thread_block_made   lisp_gc_alm_:       365,  367,  369.
       40000    Fixed                    lisp_gc_alm_:       197,
                                         lisp_object_types:   15.
       40047    fixnum_type              lisp_object_types:   34.
      736777    flag_reset_mask          lisp_iochan:   42.
       20000    Float                    lisp_gc_alm_:       197,
                                         lisp_object_types:   16.
       20047    flonum_type              lisp_object_types:   35.
                garbage_collected_ptrs   lisp_gc_alm_:        56.
                garbage_collect_inhibit  lisp_gc_alm_:       245,  249.
         102    gctwa_final              lisp_gc_alm_:        27,   51,  106,  108,  141,  149.
         100    gctwa_flag               lisp_gc_alm_:        25,   40,  527.
          63    gctwa_phs1               lisp_gc_alm_:        72,   91.
         126    gctwa_phs2               lisp_gc_alm_:        98,  140,  180.
         101    gctwa_thread             lisp_gc_alm_:        26,   50,   96,  104,  538,  540.
                gc_mark_bits             lisp_gc_alm_:       224,  396,  402,  425,  430.
         753    get_initial_segment      lisp_gc_alm_:        46,  713.
                get_lists                lisp_gc_alm_:       723.
          43    handle_vectors_encountered     lisp_gc_alm_:        69,  138.
          10    iochan.aclinfop          lisp_iochan:   14.
        2000    iochan.charmode          lisp_iochan:   27.
          13    iochan.charpos           lisp_iochan:   16.
          12    iochan.component         lisp_iochan:   15.
          35    iochan.End               lisp_iochan:   40.
        1000    iochan.extra_nl_done     lisp_iochan:   28.
           6    iochan.fcbp              lisp_iochan:   13.
         400    iochan.fixnum_mode       lisp_iochan:   29.
          15    iochan.flags             lisp_gc_alm_:       231,  354,  359,
                                         lisp_iochan:   18.
          16    iochan.function          lisp_gc_alm_:       361,
                                         lisp_iochan:   34.
       40000    iochan.gc_mark           lisp_gc_alm_:       232,  355,  358,
                                         lisp_iochan:   22.
         200    iochan.image_mode        lisp_iochan:   30.
       20000    iochan.interactive       lisp_iochan:   23.
           0    iochan.ioindex           lisp_iochan:    9.
           1    iochan.iolength          lisp_iochan:   10.
           2    iochan.ioptr             lisp_iochan:   11.
          14    iochan.linel             lisp_iochan:   17.
          33    iochan.linenum           lisp_iochan:   38.
       10000    iochan.must_reopen       lisp_iochan:   25.
          22    iochan.name              lisp_iochan:   36.
          20    iochan.namelist          lisp_iochan:   35.
        4000    iochan.nlsync            lisp_iochan:   26.
          32    iochan.pagel             lisp_iochan:   37.
          34    iochan.pagenum           lisp_iochan:   39.
      200000    iochan.read              lisp_iochan:   20.
      400000    iochan.seg               lisp_iochan:   19.
           4    iochan.thread            lisp_iochan:   12.
      100000    iochan.write             lisp_iochan:   21.
                lisp_alloc_              lisp_gc_alm_:        43,  248,  711,  728,  729,  731,  735.
       77700    lisp_ptr.type            lisp_object_types:   13.
                lisp_segment_manager_    lisp_gc_alm_:       723.
                lisp_static_vars_        lisp_gc_alm_:        41,   53,   56,   60,  184,  185,  188,  210,  224,  245,  249,
                                                             396,  402,  425,  430.
                maknum_left              lisp_gc_alm_:       188,  210.
                maknum_mask              lisp_gc_alm_:       185.
         177    maknum_scan_loop         lisp_gc_alm_:       194,  241.
                maknum_table_ptr         lisp_gc_alm_:       184.
          75    mark_size                lisp_gc_alm_:        22,  509,  558.
          60    new_seg_ptr              lisp_gc_alm_:        14,  717,  726,  727.
         244    next_entry               lisp_gc_alm_:       196,  211,  238.
                nil                      lisp_gc_alm_:        41.
           0    noargs                   lisp_gc_alm_:        31,  246.
         243    not_ok_entry             lisp_gc_alm_:       203,  205,  226,  234,  236.
      210400    not_ok_to_read           lisp_iochan:   31.
      110400    not_ok_to_write          lisp_iochan:   32.
           4    nullptr                  lisp_gc_alm_:        35,   45.
         506    number_array             lisp_gc_alm_:       438,  439,  461.
                number_gc_ptrs           lisp_gc_alm_:        53.
       61400    Numeric                  lisp_object_types:   17.
         576    obarray_array            lisp_gc_alm_:       441,  526.
         216    ok_entry                 lisp_gc_alm_:       198,  210,  219,  225,  233.
          70    old_nil                  lisp_gc_alm_:        18,   42,  124.
           2    onearg                   lisp_gc_alm_:        33,  719.
         101    ph1_lst_loop             lisp_gc_alm_:       113,  131.
         117    ph1_next_atom            lisp_gc_alm_:       121,  125,  129.
         121    ph1_next_bucket          lisp_gc_alm_:       115,  132.
          77    ph1_vec_loop             lisp_gc_alm_:       110,  136.
         160    ph2_end_list             lisp_gc_alm_:       156,  173.
         141    ph2_lst_loop             lisp_gc_alm_:       154,  172.
         153    ph2_made_cell            lisp_gc_alm_:       162,  164,  166.
         146    ph2_make_cell            lisp_gc_alm_:       160,  165.
         137    ph2_vec_loop             lisp_gc_alm_:       151,  178.
         156    ph2_worthless            lisp_gc_alm_:       158,  170.
         530    readtable_array          lisp_gc_alm_:       440,  482.
                rehash_maknum            lisp_gc_alm_:       248.
         257    retrn                    lisp_gc_alm_:       187,  251.
         433    retry_subr_block_thread  lisp_gc_alm_:       405,  410.
          54    save_pr2                 lisp_gc_alm_:        12,  306,  319,  334,  349,  362,  376,  404,  419,  450,  478,
                                                             483,  504,  551,  564.
         166    scan_maknum              lisp_gc_alm_:       143,  183.
         276    seen_atoms               lisp_gc_alm_:       272,  282.
                seg_blk_cntr             lisp_gc_alm_:       711,  735.
                stack_ptr                lisp_gc_alm_:        60.
        4000    String                   lisp_gc_alm_:       292,  315,
                                         lisp_object_types:   22.
        2000    Subr                     lisp_gc_alm_:       200,  283,
                                         lisp_object_types:   23.
         440    subr_thread_block_made   lisp_gc_alm_:       407,  409,  411.
         400    System_Subr              lisp_object_types:   24.
         621    S_expr_array             lisp_gc_alm_:       436,  528,  555.
         735    tally_out_on_allocate    lisp_gc_alm_:       685,  691.
         743    tally_out_on_atsym       lisp_gc_alm_:       659,  701.
         746    tally_out_on_atsym_lp    lisp_gc_alm_:       662,  705.
         740    tally_out_on_cons        lisp_gc_alm_:       640,  696.
         751    tally_ran_out            lisp_gc_alm_:       163,  366,  408,  692,  697,  702,  706,  710.
         451    test_array               lisp_gc_alm_:       386,  423.
         334    test_bignum              lisp_gc_alm_:       290,  322.
         271    test_cons                lisp_gc_alm_:       274,  620.
         365    test_file                lisp_gc_alm_:       287,  352.
         232    test_maknum_gc_mark      lisp_gc_alm_:       223,  229.
         307    test_string              lisp_gc_alm_:       293,  299.
         412    test_subr                lisp_gc_alm_:       284,  379.
       60000    Uncollectable            lisp_object_types:   21.
       67500    Unevalable               lisp_object_types:   27.
         273    unmark_return            lisp_gc_alm_:       277,  301,  328.
         340    unseen_bignum            lisp_gc_alm_:       326,  329.
         621    Un_gc_array              lisp_gc_alm_:       437,  554.
          72    vector_left              lisp_gc_alm_:        19,   55,   64,   75,   87,  102,  135,  147,  177,  192,  240.
          54    vector_loop              lisp_gc_alm_:        58,   67,   82,   88.
          62    vector_ret               lisp_gc_alm_:        15,   57,   66,   89.
          77    vector_thread            lisp_gc_alm_:        24,   49,   70,   77,  373,  375,  412,  418,  500,  502,  547,
                                                             549,  560,  562.
         115    worthy_atom              lisp_gc_alm_:       122,  126.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
