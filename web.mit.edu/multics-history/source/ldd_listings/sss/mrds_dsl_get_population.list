	COMPILATION LISTING OF SEGMENT mrds_dsl_get_population
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1331.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       21*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       22*     This entry is being made to cover the change made on 85-04-19 by Thanh
       23*     Nguyen. (see mrds #136)
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* HISTORY:
       27*
       28*   Originally written by Jim Gray - - March 1981
       29*
       30*   81-03-27 Jim Gray : added dbcb_ptr parameter to mu_get_rel_size
       31*   as part of getting rid of mus_ptr_man module.
       32*
       33*   81-06-01 Jim Gray : changed to use new resultant structure.
       34*
       35*   81-12-15 R. Lackey : Modified to correcly search rm_rel_array for rel_name. TR11887.
       36*
       37*   82-09-24 Davids: Modified to call mu_rel_statistics$return_tuple_count
       38*   instead of mu_get_rel_size. This required testing rm_rel_info.opening_id
       39*   and calling dbcb.relmgr_entries.open if the relation wasn't open yet,
       40*   and that required including the mdbm_rm_rel_info include file.
       41*
       42*   82-12-10 Davids: Modified the call to dbcb.relmgr_entries.open by
       43*   enclosing the db_path in ()s. This was needed because the declaration
       44*   of the relation manager entries in the dbcb was changed from options
       45*   variable to reality. The db_path is declared as character aligned in
       46*   the include file while the entry expects character unaligned.
       47*
       48*   83-02-01 Mike Kubicar : added an "error" procedure and removed the horrible
       49*   nestings used to handle error codes.  This was needed in order to insert
       50*   the transaction processing include files.  Transaction processing was
       51*   also added.
       52*
       53*   83-02-18 Bert Moberg : Added check for relation names greater than 30 chars
       54*
       55*   83-04-07 Davids: Explicitly declared the builtin function length.
       56*
       57*   83-05-23 Mike Kubicar : converted for new mu_rel_statistics calling
       58*   sequence.
       59*
       60*   85-01-23 Delight Hurst : Maked sure that get_population calls to
       61*   relmgr_entries.open with the model name and not to return as an error in
       62*   a submodel opening.
       63**/
       64 
       65 mrds_dsl_get_population: get_population: procedure ();
       66 
       67 /* DESCRIPTION:
       68*
       69*   This routine will return the current tuple count for either
       70*   permanent or temporary relations. If the relation identifier
       71*   given is numeric, or character and not starting with a letter,
       72*   then a temp rel index is assumed, and the temp rel population
       73*   routine is called, otherwise mu_rel_statistics$return_tuple_count
       74*   is called for the permanent relation name.
       75*
       76**/
       77 
       78 /* PARAMETERS:
       79*
       80*   db_index - - (input) fixed bin(35), is the integer returned from
       81*   a call to dsl_$open, for the desired opening of the database.
       82*
       83*   relation_identifier - - (input) char or fixed bin(35), if this argument
       84*   is fixed bin (35), or char and does not start with a letter, it is assumed
       85*   to be a temporary relation index. If it is char starting with a letter,
       86*   it is assumed to be a permanent relation name. In either case,
       87*   it indicates which relation in this opening view is to have it's current
       88*   tuple count returned.
       89*
       90*   tuple_count - - (output) fixed bin(35), is the current tuple count
       91*   of the relation specified by the relation_identifier
       92*
       93*   error_code - - (output) is the standard status code. It will be 0 unless
       94*   the relation or specified opening are unknown, or some other error occurs.
       95*
       96**/
       97 
       98 /* initialize */
       99 
      100 	error_code = 0;
      101 	tuple_count = 0;
      102 	mstxn_txn_id = "0"b;
      103 
      104 /* make sure that we were called with 4 args,   and that the entry was declared options (variable) */
      105 
      106 	call cu_$arg_list_ptr (al_ptr);
      107 	nargs = arg_list.desc_count / 2;
      108 	if nargs ^= 4 then do;
      109 		call sub_err_ (error_table_$wrong_no_of_args, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a^a",
      110 		     "The number of arguments =", nargs,
      111 		     "was not the required 4",
      112 		     ", or the entry was not declared ""options (variable)"".");
      113 		return;
      114 	     end;
      115 
      116 /* get the offset of the descriptors in the argument list */
      117 
      118 	if arg_list.code = SPECIAL then
      119 	     desc_index = nargs + 1;
      120 	else desc_index = nargs;
      121 	num_ptrs = desc_index + nargs;
      122 
      123 /* get the database index argument */
      124 
      125 	call mu_convert_parameter$convert_input_parameter (arg_list.arg_des_ptr (1),
      126 	     arg_list.arg_des_ptr (desc_index + 1),
      127 	     db_index_ptr, addr (fixed_bin_35_descr), addr (local_area), error_code);
      128 	if error_code ^= 0 then do;
      129 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a",
      130 		     "The database index argument could not be converted to ""fixed binary (35) aligned"".");
      131 		call error (error_code);
      132 	     end;
      133 
      134 /* check for a valid database index, and get the resultant model pointer */
      135 
      136 	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      137 	if dbcb_ptr = null () then do;
      138 		error_code = mrds_error_$invalid_db_index;
      139 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a",
      140 		     "The database index =", db_index,
      141 		     "does not refer to a database that is currently open by this process.");
      142 		call error (error_code);
      143 	     end;
      144 
      145 /* check that the database version is supported */
      146 
      147 	rdbi_ptr = dbcb.rdbi_ptr;
      148 	if rm_db_info.db_version < 4 then
      149 	     call error (mrds_error_$version_not_supported);
      150 
      151 
      152 /* Start transactions */
      153 	mstxn_transactions_needed = dbcb.transactions_needed;
      154 	on cleanup call mstxn_cleanup;
      155 	on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Äã    King                               €   ¶ô"vÌr´                        ¶ô"vÌr´                        King                                    NMLPROD         ¨                                                                                                                         QjIRæÝ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                r (error_code);
      198 		     end;
      199 	     end;
      200 
      201 /* assign the output values for the error code and the tuple count */
      202 
      203 	if arg_list.arg_des_ptr (desc_index + 3) -> bit_36_ovrly = fixed_bin_35_descr then
      204 	     arg_list.arg_des_ptr (3) -> output_tuple_count = tuple_count;
      205 	else do;
      206 		error_code = error_table_$badcall;
      207 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      208 		     "^/^a^/^a ^d",
      209 		     "The tuple_count variable was not declared ""fixed bin (35) aligned"".",
      210 		     "The tuple_count value is =", tuple_count);
      211 		call error (error_code);
      212 	     end;
      213 
      214 
      215 exit:
      216 	mftxn_code = error_code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      217 
      218 	if mftxn_code ^= 0
      219 	then error_code = mftxn_code;
      220 	if arg_list.arg_des_ptr (desc_index + 4) -> bit_36_ovrly = fixed_bin_35_descr then
      221 	     arg_list.arg_des_ptr (4) -> output_error_code = error_code;
      222 	else do;
      223 		call convert_status_code_ (error_code, short_info, long_info);
      224 		call sub_err_ (error_table_$badcall, caller_name, continue, info_ptr, return_value,
      225 		     "^/^a^/^a^/^a",
      226 		     "The error code (last) argument was not declared ""fixed bin (35) aligned"".",
      227 		     "The error_code expands to the following message:", long_info);
      228 	     end;
      229 
      230 error:
      231      proc (cd);
      232 
      233 	dcl     cd		 fixed bin (35);
      234 
      235 	error_code = cd;
      236 	goto exit;
      237      end error;
      238 
      239 
      240 get_perm_rel_population: procedure (dbi, dbcb_ptr, relation, count, err_code);
      241 
      242 /* routine to get the number of tuples currently stored in   a permanent relation, for the given opening
      243*   PARAMETERS:
      244*   dbi - - (input) fixed bin (35), the database opening index
      245*
      246*   dbcb_ptr - - (input) pointer, pointer to the resultant model
      247*
      248*   relation - - (input) char(*), the name of the permanent
      249*   relation in the users view of the database for this opening
      250*
      251*   count - - (output) fixed bin(35), the number of tuples currently
      252*   stored in the given relation
      253*
      254*   err_code - - (output) fixed bin(35), the error status encoding
      255**/
      256 
      257 /* first check for a legal relation name, known in this opening */
      258 
      259 	rmra_ptr = rm_db_info.ra_ptr;
      260 
      261 /* BEGIN CHANGE 81-12-15 RDL ********************************************* */
      262 
      263 	if length (rtrim (relation)) > 30 then call error (mrds_error_$rel_name_too_long);
      264 	rel_name_32 = rtrim (relation);		/* Used to seach rel_array */
      265 	i = index (string (rm_rel_array.name), "!" || rel_name_32);
      266 
      267 /* END   CHANGE 81-12-15 RDL ********************************************* */
      268 
      269 	if i = 0 then
      270 	     err_code = mrds_error_$unknown_relation_name;
      271 	else do;
      272 
      273 		i = ((i - 1) / 33) + 1;		/* convert from char to array index */
      274 
      275 /* good name, call to get the tuple count */
      276 
      277 /*make sure you have the model name, not the submodel name */
      278 		model_relation = rm_rel_array.rel_data.model_name (i);
      279 		rel_ptr = rm_rel_array.rel_data.ri_ptr (i);
      280 		if rel_ptr -> rm_rel_info.opening_id = "0"b
      281 		then call dbcb.relmgr_entries.open ((rm_db_info.db_path), model_relation, rel_ptr -> rm_rel_info.opening_id, err_code);
      282 		if err_code = 0
      283 		then call mu_rel_statistics$return_tuple_count (
      284 			db_index, dbcb.relmgr_entries.create_cursor,
      285 			dbcb.relmgr_entries.open,
      286 			dbcb.relmgr_entries.get_count,
      287 			dbcb.cursor_ptrs_storage_ptr,
      288 			dbcb.cursor_storage_area_ptr, rel_ptr,
      289 			count, err_code);
      290 
      291 	     end;
      292 
      293 	dcl     dbcb_ptr		 ptr;		/* points to resultant model for opening */
      294 	dcl     i			 fixed bin;	/* array index */
      295 	dcl     model_relation	 char (30);	/* name of relation in model */
      296 	dcl     mrds_error_$unknown_relation_name fixed bin (35) ext; /* name not in view */
      297 	dcl     mrds_error_$rel_name_too_long fixed bin (35) ext; /* name too long */
      298 	dcl     mu_rel_statistics$return_tuple_count entry (fixed bin (35), entry, entry, entry, ptr, ptr, ptr,
      299 				 fixed bin (35), fixed bin (35));
      300 	dcl     rel_ptr		 ptr;		/* points to rm_rel_info structure */
      301 	dcl     dbi		 fixed bin (35);	/* database opening index */
      302 	dcl     relation		 char (*);	/* name of relation in users view */
      303 	dcl     count		 fixed bin (35);	/* current tuple count */
      304 	dcl     err_code		 fixed bin (35);	/* error status encoding */
      305 
      306      end;
      307 
      308 /***********
      309**
      310**   These routines are used by the transaction processing include files.
      311**   Restore_significant_data is called to reinitialize variables in case
      312**   of a rollback.  Should_rollback determines whether a transaction should
      313**   be rolled back or aborted on error.  Currently, it is always aborted.
      314**
      315***********/
      316 
      317 
      318 restore_significant_data:
      319      proc;
      320      end restore_significant_data;
      321 
      322 
      323 
      324 should_rollback:
      325      proc returns (bit (1));
      326 	return ("0"b);
      327 						/* No intention of rolling back any transactions at this point. */
      328      end should_rollback;
      329 
      330 	dcl     SPECIAL		 fixed bin init (8);/* extra point in arg list */
      331 	dcl     (addrel, index, null, fixed, addr,
      332 	        rel, string, empty, length, rtrim) builtin;
      333 	dcl     any_other		 condition;
      334 	dcl     bit_36_ovrly	 bit (36) based;	/* overlay for looking at argument descriptors */
      335 	dcl     caller_name		 char (32) init ("mrds_dsl_get_population"); /* name of calling routine */
      336 	dcl     cleanup		 condition;
      337 	dcl     continue		 char (1) init ("c"); /* dont stop after printing mesg */
      338 	dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned, char (100) aligned); /* gets error code message */
      339 	dcl     cu_$arg_list_ptr	 entry (ptr);	/* gets pointer to arg list */
      340 	dcl     db_index		 fixed bin (35) based (db_index_ptr); /* database opening index */
      341 	dcl     db_index_ptr	 ptr;		/* points to database index arg */
      342 	dcl     desc_index		 fixed bin;	/* offset of descriptors in arg list array */
      343 	dcl     error_code		 fixed bin (35);	/* error status encoding */
      344 	dcl     error_table_$bad_arg	 fixed bin (35) ext;/* rel id not temp rel index or rel name */
      345 	dcl     error_table_$badcall	 fixed bin (35) ext;/* variables not fixed bin(35) */
      346 	dcl     error_table_$wrong_no_of_args fixed bin (35) ext; /* arg count ^= 4 */
      347 	dcl     fixed_bin_35_descr	 bit (36) init ("100000100000000000000000000000100011"b); /* descriptor for FB35 variable */
      348 	dcl     fixed_bin_35_ovrly	 fixed bin (35) based; /* overlay for 35 variable */
      349 	dcl     info_ptr		 ptr init (null ());/* unused */
      350 	dcl     local_area		 area (1024);	/* space for parameter conversion */
      351 	dcl     long_info		 char (100) aligned;/* long error code mesg */
      352 	dcl     mu_convert_parameter$convert_input_parameter entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)); /* gets user data */
      353 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr); /* checks for good db index */
      354 	dcl     mrds_dsl_define_temp_rel$get_temp_rel_population entry
      355 				 (fixed bin (35), fixed bin (35), fixed bin (35), fixed bin (35)); /* gets temp rel tuple count */
      356 	dcl     mrds_error_$invalid_db_index fixed bin (35) ext; /* index not to open db */
      357 	dcl     mrds_error_$version_not_supported fixed bin (35) ext; /* not version 4 db */
      358 	dcl     nargs		 fixed bin;	/* number of arguments */
      359 	dcl     output_error_code	 fixed bin (35) based; /* for assigning users error code */
      360 	dcl     output_tuple_count	 fixed bin (35) based; /* for assigning users tuple count */
      361 	dcl     rel_name		 char (rel_name_len) based (rel_name_ptr); /* perm rel name */
      362 	dcl     rel_name_len	 fixed bin (21);	/* length of perm rel name */
      363 	dcl     rel_name_len_ptr	 ptr;		/* points to count field of varyingf string */
      364 	dcl     rel_name_ptr	 ptr;		/* points to perm rel name arg */
      365 	dcl     rel_name_32		 char (32);	/* Used to search rm_rel_array */
      366 	dcl     return_value	 fixed bin (35) init (0); /* unused */
      367 	dcl     short_info		 char (8) aligned;	/* short error code mesg */
      368 	dcl     sub_err_		 entry options (variable); /* reports error details */
      369 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment size */
      370 	dcl     temp_rel_index	 fixed bin (35) based (temp_rel_index_ptr); /* temp rel indicator */
      371 	dcl     temp_rel_index_ptr	 ptr;		/* points to temp rel index */
      372 	dcl     tuple_count		 fixed bin (35);	/* number of tuples in perm or temp rel */
      373 
  5     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  5     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  5     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  5     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  5     5 
  5     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  5     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  5     8     2 type unsigned fixed bin (6) unal,			/* data type */
  5     9     2 packed bit (1) unal,				/* on if data item is packed */
  5    10     2 number_dims bit (4) unal,			/* dimensions */
  5    11     2 size,					/* size for string data */
  5    12       3 scale bit (12) unal,				/* scale for num. data */
  5    13       3 precision bit (12) unal,			/* prec. for num. data */
  5    14     2 array_info (num_dims),
  5    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  5    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  5    17       3 multiplier fixed bin (35);			/*  element separation */
  5    18 
  5    19 dcl  desc_ptr ptr;
  5    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  5    21 
  5    22 /* END mdbm_descriptor.incl.pl1 */
  5    23 
  5    24 
      374 
      375 
  6     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  6     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  6     3 
  6     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  6     5 
  6     6 dcl 1 arg_list based (al_ptr),
  6     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  6     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  6     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  6    10     2 pad fixed bin (17) unal,			/* must be 0 */
  6    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  6    12 
  6    13 dcl  al_ptr ptr;
  6    14 dcl  num_ptrs fixed bin;
  6    15 
  6    16 /* END mdbm_arg_list.incl.pl1  */
  6    17 
      376 
      377 
  7     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  7     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  7     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  7     9*     Nguyen. The scopes_changed flag was added to make checking for this
  7    10*     more efficient (mrds error list #137).
  7    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  7    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  7    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  7    14*     care if multiple txns use the same selection_expression. (mrds #156)
  7    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  7    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  7    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  7    18*                                                   END HISTORY COMMENTS */
  7    19 
  7    20 
  7    21 /* WARNING
  7    22*          If the dbcb structure is changed then the mrds_data_
  7    23*          item saved_res_version MUST be incremented to invalidate all
  7    24*          existing saved resultants
  7    25**/
  7    26 
  7    27 /* HISTORY :
  7    28*
  7    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  7    30*   tid_list management
  7    31*
  7    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  7    33*   phony resultant in mu_database_index, without having the area dcl
  7    34*   included.
  7    35*
  7    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  7    37*   mrds_dsl_store
  7    38*
  7    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  7    40*   switches
  7    41*
  7    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  7    43*   expression,  so  that relation statistics can be updated relative
  7    44*   to number of selection expressions seem. Also  removed  init  for
  7    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  7    46*   mrds_dsl_init_res.
  7    47*
  7    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  7    49*
  7    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  7    51*   for the conversion to the relation manager.
  7    52*
  7    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  7    54*   substructures so that the entries and costs can change
  7    55*   depending on the type of database that is opened.
  7    56*
  7    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  7    58*   since modify uses a different vector type (general) than does store.
  7    59*
  7    60*   82-09-20 Davids: changed names of (store modify)_vector to
  7    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  7    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  7    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  7    64*   during the first call.
  7    65*
  7    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  7    67*   since it deals with the pointers to the cursors and not the cursors
  7    68*   themelves and added the element cursor_storage_area_ptr which points
  7    69*   to the area where the cursors are kept.
  7    70*
  7    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  7    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  7    73*   anything.
  7    74*
  7    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  7    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  7    77*   by mrds_dsl_define_temp_rel.
  7    78*
  7    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  7    80*   is needed by mu_store.
  7    81*
  7    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  7    83*   bin to float bin since the values are not integers.
  7    84*
  7    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  7    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  7    87*   added to the end of the structure to allow modules that don't use
  7    88*   the element to continue to reference the dbcb structure without recompiling.
  7    89*
  7    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  7    91*   are needed so that temp rels can be created with the same file attributes
  7    92*   as the permanent relations.
  7    93*
  7    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  7    95*   added the resultant_in_pdir bit.
  7    96*
  7    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  7    98*   added the res_already_made element.
  7    99*
  7   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  7   101*
  7   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  7   103*   one of the unused pointers.
  7   104*
  7   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  7   106*
  7   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  7   108*   leaving unused_ptrs(1).
  7   109*
  7   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  7   111*   unused_ptrs (1).
  7   112*
  7   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  7   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  7   115*   spare ptrs, entries and reserved storages for future enhancement, since
  7   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  7   117*
  7   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  7   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  7   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  7   121**/
  7   122 
  7   123 
  7   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  7   125*   that constitutes the non-secure portion of the resultant model that is
  7   126*   created during the opening of a database. it contains variables that
  7   127*   are used during the runtime access of the database, and an area
  7   128*   for evaluation of requests. it points to four other
  7   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  7   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  7   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  7   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  7   133*   used in the elimination of duplicate tuples during a retrieve.
  7   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  7   135*   that is used when the database is using the file scope mechanism
  7   136*   for concurrency control over file readying. the segment overlayed via
  7   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  7   138*   across database openings. the pointer to this dbcb structure is kept in a table
  7   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  7   140*   opening instances of resultant models. (see mu_database_index routine) */
  7   141 
  7   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  7   143 	     2 data	      like dbcb_data,
  7   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  7   145 
  7   146      dcl	   dbcb_ptr	      ptr;
  7   147 
  7   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  7   149*						   like references can avoid getting the area declaration */
  7   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  7   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  7   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  7   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  7   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  7   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  7   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  7   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  7   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  7   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  7   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  7   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  7   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  7   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  7   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  7   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  7   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   167*						   for eliminating duplicate tuples. */
  7   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   169*						   for eliminating duplicate tuples. */
  7   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  7   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  7   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  7   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  7   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  7   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  7   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  7   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  7   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  7   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  7   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  7   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  7   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  7   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  7   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  7   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  7   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  7   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  7   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  7   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  7   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  7   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  7   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  7   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  7   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  7   195 	     2 val_del	      bit (1) unal,		/* for delete */
  7   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  7   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  7   198*                                                                     not imply that the database is of type page_file */
  7   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  7   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  7   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  7   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  7   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  7   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  7   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  7   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  7   207*						   inside a sequence of -another selection expression. */
  7   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  7   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  7   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  7   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  7   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  7   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  7   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  7   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  7   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  7   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  7   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  7   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  7   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  7   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  7   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  7   223 	     2 relmgr_entries,			/* relation manager entries */
  7   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  7   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  7   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  7   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  7   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  7   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  7   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  7   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  7   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  7   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  7   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  7   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  7   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  7   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  7   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  7   241 	       3 reserved_entries (5) entry (),
  7   242 	     2 access_costs,			/* access costs for permute */
  7   243 	       3 total_primary_key_cost float bin,
  7   244 	       3 access_cost      float bin,
  7   245 	       3 access_overhead  float bin,
  7   246 	       3 us_access_cost   float bin,
  7   247 	       3 os_access_cost   float bin,
  7   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  7   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  7   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  7   251 
  7   252 /* END mrds_dbcb.incl.pl1 */
  7   253 
  7   254 
      378 
      379 
  8     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_rel_array structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*
  8    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  8    12*   combining   funtions   of   file_array  and  rel_array  into  one
  8    13*   structure. This will only allow 1 relation per file model now.
  8    14*   Also changed structure to allow more efficient searching
  8    15*   via and index builtin, rather than a programmed loop.
  8    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  8    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  8    18*
  8    19**/
  8    20 
  8    21 
  8    22 /* this structure is allocated in the static are of the structure
  8    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  8    24*   resultant  model  upon  opening  the  database.  two  copies  are
  8    25*   allocated,  one for temporary relations, initially empty, and one
  8    26*   for relations known to the opener, which has a length  sufficient
  8    27*   for  all  relations known to the user, but whose names, etc. will
  8    28*   not be filled  in  until  the  file  containing  that  particular
  8    29*   relation  is readied. the rm_db_info structure contains a pointer
  8    30*   to the rel_arrays, and the array entries, when  "readied",  point
  8    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  8    32*   information about the relation, it's attributes, etc. */
  8    33 
  8    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  8    35     2 num_rels fixed bin,				/* no. rels in db. */
  8    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  8    37       3 mark char (1) unal,				/* separator character = "!" */
  8    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  8    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  8    40       3 model_name char (30),				/* name of relation in model */
  8    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  8    42 
  8    43 dcl  rmra_ptr ptr;
  8    44 dcl  rm_num_rels_init fixed bin;
  8    45 
  8    46 /* END mdbm_rm_rel_array.incl.pl1 */
  8    47 
  8    48 
      380 
      381 
  9     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  9     2 
  9     3 /* WARNING
  9     4*          If the rm_rel_info structure is changed then the mrds_data_
  9     5*          item saved_res_version MUST be incremented to invalidate all
  9     6*          existing saved resultants
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  9    12*   attributes,   and   varying  attributes,  so  that  partial  view
  9    13*   submodels will have the  info  needed  to  properly  set  up  the
  9    14*   varying length array headers in the tuple structure.
  9    15*
  9    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  9    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  9    18*   delete_tuple_perm, and make m_perm = unused_perm.
  9    19*
  9    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  9    21*   view attribute was varying character or bit, since a partial view
  9    22*   submodel will not have this information in the resultant, and  it
  9    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  9    24*   since with exact length storage  of  varying  length  attributes,
  9    25*   each  tuple  can  be  a  different  length,  which is can only be
  9    26*   determined by examining the tuple itself.
  9    27*
  9    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  9    29*   interface  to  allow  temp  rel  population  to  be known, and to
  9    30*   provide a more efficient means of finding an approx. current perm
  9    31*   relation population.
  9    32*
  9    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  9    34*   blocked  files, foreign keys, and ids procedures. Also set number
  9    35*   of files per rel to a constant of 1.
  9    36*
  9    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  9    38*   structure so that only one structure per relation is needed.
  9    39*
  9    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  9    41*   counts.   Also  added  number  of  operations  count  since  last
  9    42*   statistics update, and a time  since  the  statistics  were  last
  9    43*   updated.
  9    44*
  9    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  9    46*   identifier so that small relations could be updated on a per S.E.
  9    47*   basis
  9    48*
  9    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  9    50*   to end of structure   TR 12205 (Suggestion).
  9    51*   
  9    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  9    53*   the DMS conversion. 
  9    54*
  9    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  9    56*   array and the niocb element for DMS conversion. Also removed the
  9    57*   number_selected array (and ri_niocbs_init) since subsets are not
  9    58*   going to be used.
  9    59*
  9    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  9    61*   so that it can be used with relation manager.  Also added
  9    62*   rm_rel_info.primary_key_index_id for relation manager.
  9    63*
  9    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  9    65*   nvar_atts, model_nvar_atts.
  9    66*
  9    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  9    68*   since the duplicate key count for each secondary index is now being
  9    69*   kept in the attr_info structure and key_count was only needed to
  9    70*   help in calculating the average selectivity of each index which
  9    71*   can now be gotten directly from each index's dup key count. Also
  9    72*   removed the file_id element since it is no longer needed for
  9    73*   anything.
  9    74*
  9    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  9    76*   was removed.
  9    77*
  9    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  9    79*   used when retrieving tuples from this relation.
  9    80*
  9    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  9    82*   for the relation. Note that this structure is part of the resultant NOT
  9    83*   part of the db.control structure. The scopes are duplicated in the resultant
  9    84*   to reduce contention for the db.control structure. Note also that the pointer
  9    85*   will always point to a scope_flags structure even if no scopes have been
  9    86*   set on the relation, the structure is allocated when the db is opened.
  9    87**/
  9    88 
  9    89 
  9    90 /* DESCRIPTION:
  9    91*
  9    92*   This structure is allocated in the area part of the structure  in
  9    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  9    94*   at open  time  for  a  database.  There  will  be  one  of  these
  9    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  9    96*   database view (there may be less than the total in  the  database
  9    97*   for  a  submodel  openings).  There  will  also  be  one for each
  9    98*   temporary relation currently defined for that opening.
  9    99*
  9   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  9   101*   all  rm_rel_info  structures  allocated. It is used for searching
  9   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  9   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  9   104*   rels.
  9   105*
  9   106*   The      rm_rel_info      structure      points      to       the
  9   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  9   108*   appearing in this view of the relation. Each  of  these  in  turn
  9   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  9   110*   info for each attr.
  9   111*
  9   112*   Most of the other information here deals with  specifics  of  the
  9   113*   relation's  logical  definition,  such as key and secondary index
  9   114*   attribute inidicators, security permissions, and  tuple  physical
  9   115*   construction details.
  9   116*
  9   117**/
  9   118 
  9   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  9   120 	     2 name	      char (32),		/* from submodel */
  9   121 	     2 model_name	      char (30),		/* from model */
  9   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  9   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  9   124 	     2 modify	      bit (1) unal,
  9   125 	     2 delete	      bit (1) unal,
  9   126 	     2 store	      bit (1) unal,
  9   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  9   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  9   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  9   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  9   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  9   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  9   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  9   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  9   135 	     2 reserved	      bit (24) unal,	/* for future use */
  9   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  9   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  9   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  9   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  9   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  9   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  9   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  9   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  9   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  9   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  9   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  9   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  9   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  9   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  9   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  9   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  9   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  9   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  9   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  9   155 
  9   156      dcl	   rmri_ptr	      ptr;
  9   157      dcl	   (nkey_attr_init,
  9   158 	   natts_init,
  9   159 	   nvar_atts_init)	      fixed bin;
  9   160 
  9   161 /* END mdbm_rm_rel_info.incl.pl1 */
  9   162 
  9   163 
      382 
      383 
 10     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
 10     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 10     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
 10     9*                                                   END HISTORY COMMENTS */
 10    10 
 10    11 
 10    12 /* WARNING
 10    13*          If the rm_db_info structure is changed then the mrds_data_
 10    14*          item saved_res_version MUST be incremented to invalidate all
 10    15*          existing saved resultants
 10    16**/
 10    17 
 10    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
 10    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
 10    20*   resultant model that is created partially at database open  time,
 10    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
 10    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
 10    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
 10    24*   to  provide  an  efficient  means  of  accessing  database  model
 10    25*   information, as seen from the possibly submodel view of the user,
 10    26*   and his current state of "files readied". it is the  secure  part
 10    27*   because  it  contains  the  model  information  which needs to be
 10    28*   protected  from  general  knowledge,  and   this   segment   will
 10    29*   eventually  be  capable  of  being in a lower ring. the structure
 10    30*   itself points to four arrays that are  allocated  in  it's  area,
 10    31*   that  in  turn point to the other structures mentions above, also
 10    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
 10    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
 10    34*   relations,  initially  empty,  and  a  pair  for   normal   model
 10    35*   files/relations.  the  normal  rm_file_array  is initialized to a
 10    36*   list of all known file names, the rm_rel_array only gets relation
 10    37*   names   as   files  are  readied.  the  rm_file_array  points  to
 10    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
 10    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
 10    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
 10    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
 10    42*   file infos point to contained rel infos, the rel infos  point  to
 10    43*   contained  attr  infos,  and  those in turn to domain infos. (see
 10    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
 10    45*   foreign     keys    are    represented    by    the    structures
 10    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
 10    47*   pathnames  of the model and submodel, if any, are also maintained
 10    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
 10    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
 10    50*   individual include files for  further  organization  information,
 10    51*   and particular data structures.
 10    52*
 10    53*   HISTORY:
 10    54*
 10    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
 10    56*   so that define_area_ could be used to make it an extensible area
 10    57*
 10    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
 10    59*   resultant in mu_database_index easier to keep, since no reference
 10    60*   to the area is needed.
 10    61*
 10    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
 10    63*   resultant.
 10    64*
 10    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
 10    66*   structure.
 10    67*
 10    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
 10    69*   are  now  combined  into  the rel_array. Removed the control file
 10    70*   info which was unused. Added pointer  to  head  of  domain  list,
 10    71*   which is to be used to insure only one copy of each domain info.
 10    72*
 10    73*   83-05-19 Davids: Added the  saved_res_version element.
 10    74*
 10    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
 10    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
 10    77*   check, encode, or decode proc.
 10    78*
 10    79*   CAUTION: The structure entries from db_version to sm_path  should
 10    80*   not  be moved or have their declarations changed because they are
 10    81*   used in the handling of old version database openings.
 10    82*
 10    83*
 10    84**/
 10    85 
 10    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
 10    87 	     2 data	      like rm_db_info_data,
 10    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
 10    89 
 10    90      dcl	   rdbi_ptr	      ptr;
 10    91 
 10    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
 10    93*						   like reference to it without getting the area as well */
 10    94 	     2 db_version	      fixed bin,		/* version no. of db */
 10    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
 10    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
 10    97 	     2 db_path	      char (168),		/* abs. path of db. */
 10    98 	     2 sm_path	      char (168),		/* path of submodel or model */
 10    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
 10   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
 10   101 	     2 pad	      bit (34) unal,	/* for future use */
 10   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
 10   103*                                                               dbcb and rdbi segments in the db dir */
 10   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
 10   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
 10   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
 10   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
 10   108 
 10   109 /* END mdbm_rm_db_info.incl.pl1 */
 10   110 
 10   111 
      384 
      385 
      386 
      387      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1314.0  mrds_dsl_get_population.pl1       >special_ldd>install>MR12.2-1073>mrds_dsl_get_population.pl1
156          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
217          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
374          5    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
376          6    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
378          7    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
380          8    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
382          9    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
384         10    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SPECIAL                         000144 automatic       fixed bin(17,0)          initial dcl 330 set ref 118 330*
TM_NORMAL_MODE                  000035 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
addr                                                   builtin function         dcl 331 ref 125 125 125 125 166 166 166 166 1-123
                                                                                  1-123
addrel                                                 builtin function         dcl 331 ref 183
al_ptr                          002270 automatic       pointer                  dcl 6-13 set ref 106* 107 118 125 125 166 166 177
                                                                                  179 203 203 220 220
any_other                       000146 stack reference condition                dcl 333 ref 155
arg_des_ptr               2            based           pointer                  array level 2 dcl 6-6 set ref 125* 125* 166* 166*
                                                                                  177 179 203 203 220 220
arg_list                               based           structure                level 1 unaligned dcl 6-6
bit_36_ovrly                           based           bit(36)                  packed unaligned dcl 334 ref 203 220
caller_name                     000154 automatic       char(32)                 initial packed unaligned dcl 335 set ref 109* 129*
                                                                                  139* 194* 207* 224* 335*
cd                                     parameter       fixed bin(35,0)          dcl 233 ref 230 235
cleanup                         000164 stack reference condition                dcl 336 ref 154
code                      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-6 ref 118
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue                        000172 automatic       char(1)                  initial packed unaligned dcl 337 set ref 109* 129*
                                                                                  139* 194* 207* 224* 337*
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
convert_status_code_            000040 constant        entry                    external dcl 338 ref 223
count                                  parameter       fixed bin(35,0)          dcl 303 set ref 240 282*
create_cursor           156            based           entry variable           level 4 dcl 7-142 set ref 282*
cu_$arg_list_ptr                000042 constant        entry                    external dcl 339 ref 106
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 7-142 set ref 282*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 7-142 set ref 282*
data                                   based           structure                level 2 in structure "rm_db_info" dcl 10-86
                                                                                  in procedure "get_population"
data                                   based           structure                level 2 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "get_population"
db_index                               based           fixed bin(35,0)          dcl 340 set ref 136* 139* 169* 186* 282*
db_index_ptr                    000174 automatic       pointer                  dcl 341 set ref 125* 136 139 169 186 282
db_path                   2            based           char(168)                level 3 dcl 10-86 ref 280
db_version                             based           fixed bin(17,0)          level 3 dcl 10-86 ref 148
dbcb                                   based           structure                level 1 dcl 7-142
dbcb_data                              based           structure                level 1 unaligned dcl 7-148
dbcb_ptr                               parameter       pointer                  dcl 293 in procedure "get_perm_rel_population" ref
                                                                                  240
dbcb_ptr                        002274 automatic       pointer                  dcl 7-146 in procedure "get_population" set ref 136*
                                                                                  137 147 153 160 186* 280 282 282 282 282 282
dbi                                    parameter       fixed bin(35,0)          dcl 301 ref 240
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-6 ref 107
desc_index                      000176 automatic       fixed bin(17,0)          dcl 342 set ref 118* 120* 121 125 166 177 203 220
desc_ptr                        002264 automatic       pointer                  dcl 5-19 set ref 177* 178 178 180 180
descriptor                             based           structure                level 1 unaligned dcl 5-6
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
empty                                                  builtin function         dcl 331 ref 350
err_code                               parameter       fixed bin(35,0)          dcl 304 set ref 240 269* 280* 282 282*
error_code                      000177 automatic       fixed bin(35,0)          dcl 343 set ref 100* 125* 128 129* 131* 138* 139*
                                                                                  142* 166* 169 169* 176* 186* 193* 194* 197* 206*
                                                                                  207* 211* 215 4-115* 220 223* 235*
error_table_$bad_arg            000044 external static fixed bin(35,0)          dcl 344 ref 193
error_table_$badcall            000046 external static fixed bin(35,0)          dcl 345 set ref 206 224*
error_table_$wrong_no_of_args   000050 external static fixed bin(35,0)          dcl 346 set ref 109*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
fixed                                                  builtin function         dcl 331 ref 180
fixed_bin_35_descr              000200 automatic       bit(36)                  initial packed unaligned dcl 347 set ref 125 125 166
                                                                                  166 203 220 347*
fixed_bin_35_ovrly                     based           fixed bin(35,0)          dcl 348 ref 184
get_count               222            based           entry variable           level 4 dcl 7-142 set ref 282*
i                               002316 automatic       fixed bin(17,0)          dcl 294 set ref 265* 269 273* 273 278 279
index                                                  builtin function         dcl 331 ref 265
info_ptr                        000202 automatic       pointer                  initial dcl 349 set ref 109* 129* 139* 194* 207*
                                                                                  224* 349*
length                                                 builtin function         dcl 331 ref 263
local_area                      000204 automatic       area(1024)               dcl 350 set ref 125 125 166 166 350*
long_info                       002204 automatic       char(100)                dcl 351 set ref 223* 224*
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 215* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
model_name                             based           char(30)                 array level 3 dcl 8-34 ref 278
model_relation                  002317 automatic       char(30)                 packed unaligned dcl 295 set ref 278* 280*
mrds_dsl_define_temp_rel$get_temp_rel_population
                                000056 constant        entry                    external dcl 354 ref 169
mrds_error_$invalid_db_index    000060 external static fixed bin(35,0)          dcl 356 ref 138
mrds_error_$rel_name_too_long   000070 external static fixed bin(35,0)          dcl 297 set ref 263*
mrds_error_$unknown_relation_name
                                000066 external static fixed bin(35,0)          dcl 296 ref 269
mrds_error_$version_not_supported
                                000062 external static fixed bin(35,0)          dcl 357 set ref 148*
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 153* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 102* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_convert_parameter$convert_input_parameter
                                000052 constant        entry                    external dcl 352 ref 125 166
mu_database_index$get_resultant_model_pointer
                                000054 constant        entry                    external dcl 353 ref 136
mu_rel_statistics$return_tuple_count
                                000072 constant        entry                    external dcl 298 ref 282
name                      1            based           structure                array level 2 packed packed unaligned dcl 8-34 ref
                                                                                  265
nargs                           002235 automatic       fixed bin(17,0)          dcl 358 set ref 107* 108 109* 118 120 121
null                                                   builtin function         dcl 331 ref 137 349 1-123 1-123
num_dims                        002266 automatic       fixed bin(17,0)          initial dcl 5-20 set ref 5-20*
num_ptrs                        002272 automatic       fixed bin(17,0)          dcl 6-14 set ref 121*
num_rels                               based           fixed bin(17,0)          level 2 dcl 8-34 ref 265 278 279
open                    146            based           entry variable           level 4 dcl 7-142 set ref 280 282*
opening_id               42            based           bit(36)                  level 2 dcl 9-119 set ref 280 280*
output_error_code                      based           fixed bin(35,0)          dcl 359 set ref 220*
output_tuple_count                     based           fixed bin(35,0)          dcl 360 set ref 203*
ra_ptr                  134            based           pointer                  level 3 dcl 10-86 ref 259
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "get_population" ref 147
rdbi_ptr                        002300 automatic       pointer                  dcl 10-90 in procedure "get_population" set ref 147*
                                                                                  148 259 280
rel_data                               based           structure                array level 2 dcl 8-34
rel_name                               based           char                     packed unaligned dcl 361 set ref 186*
rel_name_32                     002244 automatic       char(32)                 packed unaligned dcl 365 set ref 264* 265
rel_name_len                    002236 automatic       fixed bin(21,0)          dcl 362 set ref 180* 184* 186 186
rel_name_len_ptr                002240 automatic       pointer                  dcl 363 set ref 183* 184
rel_name_ptr                    002242 automatic       pointer                  dcl 364 set ref 179* 183 186
rel_ptr                         002330 automatic       pointer                  dcl 300 set ref 279* 280 280 282*
relation                               parameter       char                     packed unaligned dcl 302 ref 240 263 264
relmgr_entries          146            based           structure                level 3 dcl 7-142
return_value                    002254 automatic       fixed bin(35,0)          initial dcl 366 set ref 109* 129* 139* 194* 207*
                                                                                  224* 366*
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 8-34 ref
                                                                                  279
rm_db_info                             based           structure                level 1 dcl 10-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 10-92
rm_rel_array                           based           structure                level 1 dcl 8-34
rm_rel_info                            based           structure                level 1 dcl 9-119
rmra_ptr                        002276 automatic       pointer                  dcl 8-43 set ref 259* 265 278 279
rtrim                                                  builtin function         dcl 331 ref 263 264
short_info                      002256 automatic       char(8)                  dcl 367 set ref 223*
size                      0(12)        based           structure                level 2 packed packed unaligned dcl 5-6 ref 180
string                                                 builtin function         dcl 331 ref 180 265
sub_err_                        000064 constant        entry                    external dcl 368 ref 109 129 139 194 207 224
temp_rel_index                         based           fixed bin(35,0)          dcl 370 set ref 169*
temp_rel_index_ptr              002260 automatic       pointer                  dcl 371 set ref 166* 169
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 7-142 ref 153
tuple_count                     002262 automatic       fixed bin(35,0)          dcl 372 set ref 101* 169* 186* 203 207*
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 5-6 ref
                                                                                  178 178 180
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "get_population" set ref 1-92*
                                                                                  1-98* 160 4-60
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 7-142 in procedure "get_population" set ref
                                                                                  160*
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
natts_init                             automatic       fixed bin(17,0)          dcl 9-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 9-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 9-157
rel                                                    builtin function         dcl 331
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 8-44
rmri_ptr                               automatic       pointer                  dcl 9-156
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 369

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           002122 constant        entry                    internal dcl 230 ref 131 142 148 1-140 197 211 263
exit                            001426 constant        label                    dcl 215 set ref 236
get_perm_rel_population         002127 constant        entry                    internal dcl 240 ref 186
get_population                  000370 constant        entry                    external dcl 65
mftxn_check_code                001437 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001657 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_get_population         000400 constant        entry                    external dcl 65
mstxn_any_other                 002025 constant        entry                    internal dcl 1-116 ref 155
mstxn_cleanup                   001773 constant        entry                    internal dcl 1-102 ref 154
mstxn_exit                      001076 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002362 constant        entry                    internal dcl 318 ref 4-77
should_rollback                 002364 constant        entry                    internal dcl 324 ref 4-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3042        3136    2413        3052
Length      3624    2413        74         451     427           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_population                     1446 external procedure  is an external procedure.  
on unit on line 154                  76 on unit               
on unit on line 155                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 154.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 155.  
error                                   internal procedure  shares stack frame of external procedure get_population.  
get_perm_rel_population                 internal procedure  shares stack frame of external procedure get_population.  
restore_significant_data                internal procedure  shares stack frame of external procedure get_population.  
should_rollback                         internal procedure  shares stack frame of external procedure get_population.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_population           000100 mstxn_code                  get_population
                         000101 mstxn_retries               get_population
                         000102 mstxn_temp_code             get_population
                         000103 mstxn_transactions_needed   get_population
                         000104 user_started_transaction    get_population
                         000105 mstxn_txn_id                get_population
                         000106 user_transaction_id         get_population
                         000110 mstxn_condition_info        get_population
                         000142 mftxn_code                  get_population
                         000143 mftxn_temp_code             get_population
                         000144 SPECIAL                     get_population
                         000154 caller_name                 get_population
                         000172 continue                    get_population
                         000174 db_index_ptr                get_population
                         000176 desc_index                  get_population
                         000177 error_code                  get_population
                         000200 fixed_bin_35_descr          get_population
                         000202 info_ptr                    get_population
                         000204 local_area                  get_population
                         002204 long_info                   get_population
                         002235 nargs                       get_population
                         002236 rel_name_len                get_population
                         002240 rel_name_len_ptr            get_population
                         002242 rel_name_ptr                get_population
                         002244 rel_name_32                 get_population
                         002254 return_value                get_population
                         002256 short_info                  get_population
                         002260 temp_rel_index_ptr          get_population
                         002262 tuple_count                 get_population
                         002264 desc_ptr                    get_population
                         002266 num_dims                    get_population
                         002270 al_ptr                      get_population
                         002272 num_ptrs                    get_population
                         002274 dbcb_ptr                    get_population
                         002276 rmra_ptr                    get_population
                         002300 rdbi_ptr                    get_population
                         002316 i                           get_perm_rel_population
                         002317 model_relation              get_perm_rel_population
                         002330 rel_ptr                     get_perm_rel_population

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           enable_op
ext_entry           int_entry           trunc_fx2           set_chars_eis       index_chars_eis     divide_fx1
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           convert_status_code_          cu_$arg_list_ptr              find_condition_info_
mrds_dsl_define_temp_rel$get_temp_rel_population            mu_convert_parameter$convert_input_parameter
mu_database_index$get_resultant_model_pointer               mu_rel_statistics$return_tuple_count
sub_err_                      transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$bad_arg          error_table_$badcall          error_table_$wrong_no_of_args mrds_error_$invalid_db_index
mrds_error_$rel_name_too_long mrds_error_$unknown_relation_name
mrds_error_$version_not_supported




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    330 000345       335 000347       337 000352       347 000354       349 000356       350 000360       366 000363
 5   20 000364        65 000367       100 000406       101 000407       102 000410       106 000411       107 000420
    108 000431       109 000433       113 000525       118 000526       120 000537       121 000541       125 000543
    128 000572       129 000574       131 000641       136 000643       137 000654       138 000660       139 000663
    142 000746       147 000750       148 000753       153 000765       154 000772       155 001010    1   83 001026
 1   84 001027    1   86 001030    1   88 001032    1   89 001033    1   90 001044    1   92 001050    1   93 001052
 1   94 001054    1   95 001055    1   98 001056    1   99 001057    1  100 001074    1  140 001076       160 001102
    166 001110       169 001140       176 001160       177 001161       178 001166       179 001176       180 001201
    183 001207       184 001212       186 001214       188 001244       193 001245       194 001250       197 001323
    203 001325       206 001340       207 001343       211 001424       215 001426    4   60 001430    4   62 001435
 4   63 001436    4   65 001437    4   68 001441    4   69 001452    4   71 001454    4   72 001465    4   75 001500
 4   77 001501    4   78 001502    4   81 001511    4   82 001512    4   83 001525    4   85 001527    4   86 001540
 4   88 001553    4   90 001554    4   91 001555    4   93 001556    4   94 001557    4   96 001564    4   97 001600
 4   99 001602    4  100 001613    4  102 001626    4  104 001627    4  105 001630    4  107 001631    4  109 001632
 4  110 001643    4  114 001656    4  115 001657       220 001662       223 001675       224 001710       387 001772
 1  102 001773    1  107 001774    1  109 001777    1  110 002010    1  114 002024    1  116 002025    1  121 002026
 1  123 002031    1  124 002050    1  126 002056    1  127 002061    1  129 002064    1  132 002076    1  133 002101
 1  135 002104    1  136 002111    1  137 002112    1  138 002121       230 002122       235 002124       236 002126
    240 002127       259 002140       263 002143       264 002167       265 002206       269 002231       273 002236
    278 002252       279 002266       280 002273       282 002326       306 002361       318 002362       320 002363
    324 002364       326 002366


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
