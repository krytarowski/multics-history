	COMPILATION LISTING OF SEGMENT plio2_recio_
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1421.8 mst Mon
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 plio2_recio_:
       11      procedure (pspp) options (support);
       12 
       13 /* Modified 780830 by RAB to fix bug 1755 (reads of lines > 848 chars fail) */
       14 /* Modified 780718 by RAB to make stream I/O slightly more quit-start proof */
       15 /* Modified 770825 by PG to implement read/write to stream files */
       16 /* 76-09-08:  changed to use the iox_$foo call forwarder	*/
       17 /* 75-07-01:  changed the error handling for rewrite statements
       18*   to fix bug 1378.			*/
       19 
       20 /* 75-05-08:  changed the keyto_assignment_made bit to the keyto_keyset bit
       21*   in the psr to support quick keyed record i/o and added code to
       22*   the error entry block.			*/
       23 
       24 /* 74-12-31:  changed the rewrite error codes from the incorrect "480", "481",
       25*   to the correct "280", "281".			*/
       26 
       27 /* 74-12-17: updated to support bit_string stringvalue io and rewrite
       28*   stringvalue io; to check that varying_array is off before
       29*   accepting that stringvalue is valid; error entry and associated
       30*   code added for use by quick record io.		*/
       31 
       32 /* 74-12-2: updated to support env(stringvalue) */
       33 
       34 /* 74-8-5: fixed for version-2 of compiler which sets ab-ret label
       35*   in the KEYTO case.   seereferences to keyto_keyset.  */
       36 
       37 /* fixed to perform the KEYTO copy before the SET/INTO copy
       38*   74-7-1  B U G :     if abnormal return to user, KEYTO post-copy may copy JUNK */
       39 
       40 
       41 /* 73-12-12: updated for change from File Manager to iox_
       42*   please note that the new KEY is char256v, the old KEY
       43*   is c32, both starting in the same place.  */
       44 
       45 /* 1-3-73:	removed all traces of locking.
       46*   corrected test for no-file to include no-dir
       47*   as well as noentry.  */
       48 
       49 /* parameters */
       50 
       51 dcl (error_status fixed bin (35),
       52      pspp ptr
       53      ) parameter;
       54 
       55 /* automatic */
       56 
       57 dcl  buffer_len fixed bin (21);
       58 dcl  bytes_read fixed bin(21);
       59 dcl  char_buffer bit (1) aligned;
       60 dcl  conname char (16);
       61 dcl  copy_len fixed bin (21);
       62 dcl (psp, fsbp, wptr, copyp, statep) ptr;
       63 dcl (i, erno init (975), code init (0), ballocn) fixed bin (17);
       64 dcl (wlen, release, copyn, rlength, xrlength, vlength) fixed bin (21);
       65 dcl  ends_in_NL bit (1) aligned;
       66 dcl  iocb_p ptr;
       67 dcl  iocb_status fixed bin (35);
       68 dcl  onkeyx char (256) varying;
       69 dcl 1 reciofab aligned,
       70     2 sw bit (36),
       71     2 name char (32);
       72 dcl  scan_index fixed bin (21);
       73 dcl  signal_record bit(1) aligned;
       74 dcl (test_18, job_18) bit (18) aligned;
       75 dcl  valid_stringvalue bit (1) aligned;
       76 dcl  vptr ptr;
       77 dcl  w_char_buffer bit (1) aligned;
       78 dcl 1 work aligned like psr.job;
       79 
       80 /* based */
       81 
       82 dcl  based_pointer ptr based;
       83 dcl 1 buffer_state based (statep) aligned,
       84     2 blen fixed bin (15),
       85     2 bmax fixed bin (15),
       86     2 bptr ptr,
       87     2 bsw aligned,
       88       3 (exists, pad, use) bit (1) unaligned;
       89 dcl  balloc char (ballocn) aligned based;		/* ballocn must be a byte-length */
       90 dcl  based_packedptr ptr unaligned based;
       91 dcl  bc32 char (32) aligned based;
       92 dcl  based_label label based;
       93 dcl  release_bits bit (36) aligned based (addr (release));
       94 dcl  string_len fixed bin (24) based;
       95 dcl  variable_overlay char (vlength) based (vptr);
       96 dcl 1 work_overlay aligned based (addr (work)),
       97     2 pad1 bit (27) unal,
       98     2 nofrom bit (1) unal,
       99     2 nokey bit (1) unal,
      100     2 nokeyfrom bit (1) unal,
      101     2 nolock bit (1) unal,
      102     2 close bit (1) unal,
      103     2 pad2 bit (4) unal;
      104 
      105 /* NOTE: the bits of "job" and, thus, of "work"
      106*   ending on the 34-th (six bits
      107*   are reserved) contain the "release-number" of
      108*   the io_semantics which produced the calling
      109*   program.  Since these bits are reused by
      110*   RECIO, the release number must be extracted
      111*   and its bits reset to zero.
      112*
      113*   release 1:     implements the 256-char var KEY
      114*   sets the not_bytebuffer bit.
      115*
      116*   release 2:	implements ab-return in KEYTO case.
      117*   */
      118 
      119 /* entries */
      120 
      121 dcl  iox_$delete_record entry (ptr, fixed bin (35)),
      122      iox_$get_chars entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      123      iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      124      iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      125 dcl  iox_$seek_key entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
      126 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      127 dcl  iox_$read_key entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
      128 dcl  iox_$read_length entry (ptr, fixed bin (21), fixed bin (35));
      129 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      130 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      131 dcl  iox_$rewrite_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      132 dcl  plio2_signal_$s_ ext entry (ptr, char (*), char (*), fixed bin (17));
      133 dcl  plio2_open_$open_implicit_ ext entry (ptr);
      134 
      135 /* builtins */
      136 
      137 dcl (addr, addrel, divide, fixed, index, length, min, mod, string, substr) builtin;
      138 
      139 /* external static */
      140 
      141 dcl (plio2_data_$pspstat,
      142      plio2_data_$fsbpstat) ptr external;
      143 dcl (error_table_$no_record,
      144      error_table_$long_record,
      145      error_table_$short_record,
      146      error_table_$key_order,
      147      error_table_$end_of_info
      148      ) fixed bin (35) external;
      149 
      150 /* internal static */
      151 
      152 dcl  NL char (1) internal static options(constant) init ("
      153 ");
      154 
      155 /* include files */
      156 
  1     1 /* BEGIN INCLUDE FILE ... pl1_file_value.incl.pl1 */
  1     2 
  1     3 dcl 1 file_value aligned based,
  1     4     2 fab_ptr ptr,					/* ptr to file attribute block (fab) */
  1     5     2 fsb_ptr ptr;					/* ptr to file state block (fsb) */
  1     6 
  1     7 /* END INCLUDE FILE ... pl1_file_value.incl.pl1 */
      157 
  2     1 /* BEGIN INCLUDE FILE ... plio2_fsb.incl.pl1 */
  2     2 /* format: style3,idind30 */
  2     3 
  2     4 declare	1 fsb			aligned based (fsbp),
  2     5 	  2 switch		aligned,
  2     6 	    3 zot			(2) bit (1) unaligned,
  2     7 	    3 version_2		bit (1) unaligned,
  2     8 	    3 open		bit (1) unaligned,
  2     9 	    3 print		bit (1) unaligned,
  2    10 	    3 input		bit (1) unaligned,
  2    11 	    3 output		bit (1) unaligned,
  2    12 	    3 update		bit (1) unaligned,
  2    13 	    3 stream		bit (1) unaligned,
  2    14 	    3 notkeyed		bit (1) unaligned,
  2    15 	    3 record		bit (1) unaligned,
  2    16 	    3 sequential		bit (1) unaligned,
  2    17 	    3 direct		bit (1) unaligned,
  2    18 	    3 interactive		bit (1) unaligned,
  2    19 	    3 not_used_1		bit (1) unaligned,
  2    20 	    3 not_used_2		bit (1) unaligned,
  2    21 	    3 stringvalue		bit (1) unaligned,
  2    22 	    3 keyed		bit (1) unaligned,
  2    23 	    3 namelist		bit (1) unaligned,
  2    24 	    3 implementation	bit (1) unaligned,
  2    25 	    3 not_used_4		bit (1) unaligned,	/* old get-input eof flag */
  2    26 	    3 transmit_error	bit (1) unaligned,
  2    27 	    3 buffer_in_use		bit (1) unaligned,
  2    28 	    3 copy		bit (1) unaligned,
  2    29 	    3 detach		bit (1) unaligned,
  2    30 	    3 te_hold		bit (1) unaligned,
  2    31 	    3 not_used_5		bit (1) unaligned,
  2    32 	    3 internal		bit (1) unaligned,
  2    33 	    3 threaded		bit (1) unaligned,
  2    34 	    3 fsb_in_use		bit (1) unaligned,
  2    35 	    3 console		bit (1) unaligned,
  2    36 	    3 emptyline		bit (1) unaligned,
  2    37 	    3 iox_close		bit (1) unaligned,
  2    38 	    3 xxx4		bit (1) unaligned,
  2    39 	    3 xxx5		bit (1) unaligned,
  2    40 	    3 xxx6		bit (1) unaligned,
  2    41 	  2 nono			aligned,
  2    42 	    3 bit_string		bit (1) unaligned,
  2    43 	    3 not_used_3		bit (1) unaligned,
  2    44 	    3 read		bit (1) unaligned,
  2    45 	    3 write		bit (1) unaligned,
  2    46 	    3 rewrite		bit (1) unaligned,
  2    47 	    3 delete		bit (1) unaligned,
  2    48 	    3 locate		bit (1) unaligned,
  2    49 	    3 key			bit (1) unaligned,
  2    50 	    3 keyto		bit (1) unaligned,
  2    51 	    3 keyfrom		bit (1) unaligned,
  2    52 	    3 set			bit (1) unaligned,
  2    53 	    3 into		bit (1) unaligned,
  2    54 	    3 ignore		bit (1) unaligned,
  2    55 	    3 from		bit (1) unaligned,
  2    56 	    3 nofrom		bit (1) unaligned,
  2    57 	    3 nokey		bit (1) unaligned,
  2    58 	    3 nokeyfrom		bit (1) unaligned,
  2    59 	    3 nolock		bit (1) unaligned,
  2    60 	  2 lsep			fixed bin (15),	/* (1,COMMA)(2,BL)(3,TAB)(4,NL)(5,SEMI) */
  2    61 	  2 iocb_p		ptr unaligned,	/* identifies data_set to iox_ */
  2    62 	  2 blc			fixed bin (21),	/* buffer's last character (input) */
  2    63 	  2 bsize			fixed bin (21),	/* size of buffer */
  2    64 	  2 bptr			ptr,		/* address of buffer */
  2    65 	  2 bnc			fixed bin (15),	/* next character in buffer */
  2    66 	  2 kol			fixed bin (15),	/* last column read from or written into */
  2    67 	  2 lsize			fixed bin (15),	/* line size (output) */
  2    68 	  2 lineno		fixed bin (15),	/* current line (output) - starts at 1 on each new page */
  2    69 	  2 psize			fixed bin (35),	/* page size (output) */
  2    70 	  2 pageno		fixed bin (15),	/* current page number, starts at 1 */
  2    71 	  2 limit			fixed bin (15),
  2    72 	  2 lnzc			fixed bin (35),
  2    73 	  2 filename		char (32) aligned,	/* declared file name */
  2    74 	  2 title			char (32) unaligned,/* Multics I/O switch */
  2    75 	  2 fsb_thread		ptr,
  2    76 	  2 buffer		(212) fixed bin (15),
  2    77 	  2 path_name		char (168) unal,	/* title option */
  2    78 	  2 declared_attributes	(2) bit (36) aligned;
  2    79 
  2    80 declare	xbuf			char (1000) unaligned based (fsb.bptr);
  2    81 
  2    82 /* END INCLUDE FILE ... plio2_fsb.incl.pl1 */
      158 
  3     1 /* BEGIN INCLUDE FILE ... plio2_fsbr.incl.pl1 */
  3     2 /* format: style3,idind30 */
  3     3 
  3     4 /* This declaration is used by record I/O runtime programs */
  3     5 
  3     6 declare	1 fsbr			aligned based (fsbp),
  3     7 	  2 switch		aligned,
  3     8 	    3 zot			(2) bit (1) unaligned,
  3     9 	    3 version_2		bit (1) unaligned,
  3    10 	    3 open		bit (1) unaligned,
  3    11 	    3 print		bit (1) unaligned,
  3    12 	    3 input		bit (1) unaligned,
  3    13 	    3 output		bit (1) unaligned,
  3    14 	    3 update		bit (1) unaligned,
  3    15 	    3 stream		bit (1) unaligned,
  3    16 	    3 notkeyed		bit (1) unaligned,
  3    17 	    3 record		bit (1) unaligned,
  3    18 	    3 sequential		bit (1) unaligned,
  3    19 	    3 direct		bit (1) unaligned,
  3    20 	    3 interactive		bit (1) unaligned,
  3    21 	    3 not_used_1		bit (1) unaligned,
  3    22 	    3 not_used_2		bit (1) unaligned,
  3    23 	    3 stringvalue		bit (1) unaligned,
  3    24 	    3 keyed		bit (1) unaligned,
  3    25 	    3 namelist		bit (1) unaligned,
  3    26 	    3 implementation	bit (1) unaligned,
  3    27 	    3 not_used_4		bit (1) unaligned,
  3    28 	    3 transmit_error	bit (1) unaligned,
  3    29 	    3 buffer_in_use		bit (1) unaligned,
  3    30 	    3 copy		bit (1) unaligned,
  3    31 	    3 detach		bit (1) unaligned,
  3    32 	    3 te_hold		bit (1) unaligned,
  3    33 	    3 not_used_5		bit (1) unaligned,
  3    34 	    3 internal		bit (1) unaligned,
  3    35 	    3 threaded		bit (1) unaligned,
  3    36 	    3 fsb_in_use		bit (1) unaligned,
  3    37 	    3 console		bit (1) unaligned,
  3    38 	    3 emptyline		bit (1) unaligned,
  3    39 	    3 iox_close		bit (1) unaligned,
  3    40 	    3 pad4		bit (1) unaligned,
  3    41 	    3 pad5		bit (1) unaligned,
  3    42 	    3 pad6		bit (1) unaligned,
  3    43 	  2 nono			aligned,
  3    44 	    3 bit_string		bit (1) unaligned,
  3    45 	    3 not_used_3		bit (1) unaligned,
  3    46 	    3 read		bit (1) unaligned,
  3    47 	    3 write		bit (1) unaligned,
  3    48 	    3 rewrite		bit (1) unaligned,
  3    49 	    3 delete		bit (1) unaligned,
  3    50 	    3 locate		bit (1) unaligned,
  3    51 	    3 key			bit (1) unaligned,
  3    52 	    3 keyto		bit (1) unaligned,
  3    53 	    3 keyfrom		bit (1) unaligned,
  3    54 	    3 set			bit (1) unaligned,
  3    55 	    3 into		bit (1) unaligned,
  3    56 	    3 ignore		bit (1) unaligned,
  3    57 	    3 from		bit (1) unaligned,
  3    58 	    3 nofrom		bit (1) unaligned,
  3    59 	    3 nokey		bit (1) unaligned,
  3    60 	    3 nokeyfrom		bit (1) unaligned,
  3    61 	    3 nolock		bit (1) unaligned,
  3    62 	  2 recio			aligned,
  3    63 	    3 rec_exists		bit (1) unal,
  3    64 	    3 rec_valid		bit (1) unal,
  3    65 	    3 buffer_used		bit (1) unal,
  3    66 	  2 iocb_p		ptr unal,
  3    67 	  2 inbuf_curlen		fixed bin (15),
  3    68 	  2 inbuf_maxlen		fixed bin (15),
  3    69 	  2 inbuf_ptr		ptr,
  3    70 	  2 inbuf_sw		aligned,
  3    71 	    3 exists		bit (1) unal,
  3    72 	    3 free		bit (1) unal,
  3    73 	    3 use			bit (1) unal,
  3    74 	  2 pad7			bit (36) aligned,
  3    75 	  2 outbuf_curlen		fixed bin (15),
  3    76 	  2 outbuf_maxlen		fixed bin (15),
  3    77 	  2 outbuf_ptr		ptr,
  3    78 	  2 outbuf_sw		aligned,
  3    79 	    3 exists		bit (1) unal,
  3    80 	    3 free		bit (1) unal,
  3    81 	    3 use			bit (1) unal,
  3    82 	    3 keyed		bit (1) unal,
  3    83 	  2 lnzc			fixed bin (35),	/* last nonzero code from iox_ */
  3    84 	  2 filename		char (32) aligned,	/* declared file name */
  3    85 	  2 title			char (32) unaligned,/* Multics I/O switch */
  3    86 	  2 fsb_thread		ptr,
  3    87 	  2 outbuf_key		char (256) varying, /* if file is keyed & output_sw.use then key is here */
  3    88 	  2 key_saved		char (256) varying, /* if file is keyed & recio.rec_valid then its key is here */
  3    89 	  2 buffer		(82) bit (36) aligned,
  3    90 	  2 path_name		char (168) unal,	/* title option */
  3    91 	  2 declared_attributes	(2) bit (36) aligned;
  3    92 
  3    93 /* END INCLUDE FILE ... plio2_fsbr.incl.pl1 */
      159 
  4     1 /* BEGIN INCLUDE FILE ... plio2_psr.incl.pl1 */
  4     2 /* Record I/O data block used by PL/I I/O runtime routines. */
  4     3 /* format: style3,idind30 */
  4     4 
  4     5 declare	1 psr			aligned based (psp),
  4     6 	  2 pad0			(5) ptr,		/* items set NORMALLY by compiled procedures */
  4     7 	  2 ab_return,				/* items set in prep call */
  4     8 	    3 abret		(3) ptr,
  4     9 	  2 source_p		ptr,		/* addr(file) for explicit file option */
  4    10 	  2 set_p_p		ptr,
  4    11 	  2 pad1			bit (36) aligned,
  4    12 	  2 variable_bitlen		fixed bin (35),
  4    13 	  2 job			aligned,
  4    14 	    3 explicit_file		bit (1) unal,
  4    15 	    3 string		bit (1) unal,
  4    16 	    3 varying_string	bit (1) unal,
  4    17 	    3 data		bit (1) unal,
  4    18 	    3 edit		bit (1) unal,
  4    19 	    3 list		bit (1) unal,
  4    20 	    3 get			bit (1) unal,
  4    21 	    3 put			bit (1) unal,
  4    22 	    3 page		bit (1) unal,
  4    23 	    3 line		bit (1) unal,
  4    24 	    3 skip		bit (1) unal,
  4    25 	    3 copy		bit (1) unal,
  4    26 	    3 p1p2		bit (1) unal,
  4    27 	    3 bit_string		bit (1) unal,	/* for environment(stringvalue) */
  4    28 	    3 char_string		bit (1) unal,
  4    29 	    3 read		bit (1) unal,
  4    30 	    3 write		bit (1) unal,
  4    31 	    3 rewrite		bit (1) unal,
  4    32 	    3 delete		bit (1) unal,
  4    33 	    3 locate		bit (1) unal,
  4    34 	    3 key			bit (1) unal,
  4    35 	    3 keyto		bit (1) unal,
  4    36 	    3 keyfrom		bit (1) unal,
  4    37 	    3 set			bit (1) unal,
  4    38 	    3 into		bit (1) unal,
  4    39 	    3 ignore		bit (1) unal,
  4    40 	    3 from		bit (1) unal,
  4    41 	    3 version		bit (6) unal,
  4    42 	    3 not_bytebuffer	bit (1) unal,
  4    43 	    3 varying_array		bit (1) unal,
  4    44 	    3 packedptr		bit (1) unal,
  4    45 	  2 number		fixed bin (21),
  4    46 	  2 variable_p		ptr,		/* items set NORMALLY by compiled procedures per transmission */
  4    47 	  2 pad2			bit (36) aligned,
  4    48 	  2 pad3			bit (36) aligned,
  4    49 	  2 pad4			bit (36) aligned,
  4    50 	  2 locking_switch		bit (36) aligned,	/* items treated ABNORMALLY, written by user and PLIO */
  4    51 						/* "prep" for stream I/O */
  4    52 	  2 new_format		fixed bin (15),	/* for stream I/O only */
  4    53 	  2 pad5			bit (36) aligned,	/* items used by PLIO and not touched by compiled procedures */
  4    54 	  2 file_p		ptr,
  4    55 	  2 fsbp			ptr,
  4    56 	  2 auxp			ptr,
  4    57 	  2 fabp			ptr,
  4    58 	  2 fab2p			ptr,
  4    59 	  2 pad6			bit (36) aligned,
  4    60 	  2 pad7			bit (36) aligned,
  4    61 	  2 pad8			bit (36) aligned,
  4    62 	  2 pad9			bit (36) aligned,
  4    63 	  2 pad10			bit (36) aligned,
  4    64 	  2 pl1_ops_flags		aligned,		/* for communication between pl1_operators_ and plio2 */
  4    65 	    3 keyto_keyset		bit (1) unal,	/* ON after keyto assignment done */
  4    66 	    3 pad11		bit (35) unal,
  4    67 	  2 keytemp		char (256) varying; /* used for key, keyto, and keyfrom */
  4    68 
  4    69 /* END INCLUDE FILE ... plio2_psr.incl.pl1 */
      160 
  5     1 /* BEGIN INCLUDE FILE its.incl.pl1
  5     2*   modified 27 July 79 by JRDavis to add its_unsigned
  5     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  5     4 
  5     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  5     6     2 pad1 bit (3) unaligned,
  5     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  5     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  5     9     2 pad2 bit (9) unaligned,
  5    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  5    11 
  5    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  5    13     2 pad3 bit (3) unaligned,
  5    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  5    15     2 pad4 bit (3) unaligned,
  5    16     2 mod bit (6) unaligned;				/* further modification */
  5    17 
  5    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  5    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  5    20     2 pad1 bit (27) unaligned,
  5    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  5    22 
  5    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  5    24     2 pad2 bit (3) unaligned,
  5    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  5    26     2 pad3 bit (3) unaligned,
  5    27     2 mod bit (6) unaligned;				/* further modification */
  5    28 
  5    29 
  5    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  5    31     2 pad1 bit (3) unaligned,
  5    32     2 segno fixed bin (15) unsigned unaligned,
  5    33     2 ringno fixed bin (3) unsigned unaligned,
  5    34     2 pad2 bit (9) unaligned,
  5    35     2 its_mod bit (6) unaligned,
  5    36 
  5    37     2 offset fixed bin (18) unsigned unaligned,
  5    38     2 pad3 bit (3) unaligned,
  5    39     2 bit_offset fixed bin (6) unsigned unaligned,
  5    40     2 pad4 bit (3) unaligned,
  5    41     2 mod bit (6) unaligned;
  5    42 
  5    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  5    44     2 pr_no fixed bin (3) unsigned unaligned,
  5    45     2 pad1 bit (27) unaligned,
  5    46     2 itp_mod bit (6) unaligned,
  5    47 
  5    48     2 offset fixed bin (18) unsigned unaligned,
  5    49     2 pad2 bit (3) unaligned,
  5    50     2 bit_offset fixed bin (6) unsigned unaligned,
  5    51     2 pad3 bit (3) unaligned,
  5    52     2 mod bit (6) unaligned;
  5    53 
  5    54 
  5    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  5    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  5    57 
  5    58 /* END INCLUDE FILE   its.incl.pl1 */
      161 
      162 
      163 /* program */
      164 
      165 	plio2_data_$pspstat,
      166 	     psp = pspp;
      167 
      168 	string (work) = string (psr.job);
      169 	release = 0;
      170 	substr (release_bits, 31, 6) = substr (string (work), 28, 6); /* release number of io_semantics */
      171 	substr (string (work), 28, 6) = "000000"b;	/* these bits are re-used by RECIO */
      172 
      173 	if work.keyto then psr.keyto_keyset = "0"b;
      174 	else addr (psr.ab_return) -> based_label = EXIT;
      175 						/* ab-ret label is set by compiler/runtime
      176*						   only for KEYTO, version 2 and later. */
      177 
      178 	psr.file_p = psr.source_p;
      179 	plio2_data_$fsbpstat,
      180 	     fsbp, psr.fsbp = psr.file_p -> file_value.fsb_ptr;
      181 
      182 	if ^fsbr.switch.open
      183 	then do;
      184 	     psr.fab2p = addr (reciofab);
      185 	     reciofab.name = " ";
      186 	     if work.read then reciofab.sw = "00000100001"b;
      187 	     if work.write then reciofab.sw = "00000010001"b;
      188 	     if work.rewrite then reciofab.sw = "00000001001"b;
      189 	     if work.delete then reciofab.sw = "0000000100101"b;
      190 	     if work.locate then reciofab.sw = "000000100011001"b;
      191 	     call plio2_open_$open_implicit_ (psp);
      192 	end;
      193 
      194 	valid_stringvalue = fsbr.switch.stringvalue & work.varying_string & ^work.varying_array;
      195 	iocb_p = fsbr.iocb_p;
      196 	vlength = psr.variable_bitlen;
      197 	if work.varying_string & ^valid_stringvalue then
      198 	     do;
      199 						/* special code inserted here to handle anomalous case
      200*						   of "into" or "from" option where "target" is a varying
      201*						   string.  For the compiler addresses the data portion
      202*						   of such a string only. */
      203 						/* More queer, an array of varying strings
      204*						   is given its correct length but the address
      205*						   of its second word - whereas a scalar varying string
      206*						   is given the length of its data portion and the
      207*						   address of its data portion. */
      208 	     if ^work.varying_array then vlength = vlength + 36;
      209 	     psr.variable_p = addrel (psr.variable_p, -1);
      210 	end;
      211 
      212 	onkeyx = "";
      213 
      214 	if work.read & substr (string (work), 24, 3) = "000"b /* (set, into, ignore) = 0 */
      215 	then do;
      216 	     work.ignore = "1"b;
      217 	     psr.number = 1;
      218 	end;
      219 
      220 	if (work.write | work.rewrite) & ^work.from
      221 	then work_overlay.nofrom = "1"b;
      222 
      223 	if work.write | work.locate
      224 	then if ^work.keyfrom
      225 	     then work_overlay.nokeyfrom = "1"b;
      226 	     else;
      227 	else if ^work.key
      228 	then work_overlay.nokey = "1"b;
      229 
      230 	if work_overlay.nokeyfrom & work_overlay.nokey
      231 	then psr.keytemp = "";
      232 
      233 /*	TESTING AND SIGNALLING */
      234 
      235 	job_18 = substr (string (work), 14, 18);
      236 	test_18 = job_18 & string (fsbr.nono);
      237 
      238 	if test_18 ^= "0"b then
      239 	     do;
      240 	     i = index (test_18, "1"b);
      241 	     erno = 251;				/* required option missing */
      242 	     if i<15 then erno = 250;			/* illegal option present or implied */
      243 	     if i<8 then erno = 249;			/* statement type conflicts with file attributes */
      244 
      245 signal_error:
      246 	     conname = "ERROR";
      247 	     goto sandr1;
      248 
      249 sandr:
      250 	     conname = "TRANSMIT";
      251 sandr1:
      252 	     if iocb_status ^= 0 then fsbr.lnzc = iocb_status;
      253 	     call plio2_signal_$s_ (psp, conname, substr (onkeyx, 1, length (onkeyx)), erno);
      254 
      255 	     if work.keyto then if ^psr.keyto_keyset then goto addr (psr.ab_return) -> based_label;
      256 
      257 /* The abnormal label is only different from the following return statement
      258*   if KEYTO is specified.  We take it whenever the assignment to the KEYTO-
      259*   TARGET has not been done.  */
      260 
      261 EXIT:
      262 						/* the label EXIT M_ U_ S_ T_ identify this return statement !! */
      263 
      264 	     return;
      265 
      266 sig_rec:
      267 	     conname = "RECORD";
      268 	     go to sandr1;
      269 
      270 sig_eof:
      271 	     conname = "ENDFILE";
      272 	     go to sandr1;
      273 
      274 sig_key:
      275 	     conname = "KEY";
      276 	     go to sandr1;
      277 	end;
      278 
      279 
      280 /*	CHECK FOR READ/WRITE TO A STREAM FILE */
      281 
      282 	if fsbr.switch.stream			/* A stream file... */
      283 	then do;
      284 
      285 	     if work.varying_string
      286 	     then vptr = addrel (psr.variable_p, 1);
      287 	     else vptr = psr.variable_p;
      288 
      289 	     if work.read				/* A READ STATEMENT */
      290 	     then do;
      291 
      292 		if ^fsb.switch.input
      293 		then do;
      294 		     erno = 289;			/* Stream file referenced by read statement isn't input */
      295 		     go to signal_error;
      296 		end;
      297 
      298 /* Fill input buffer, if necessary */
      299 
      300 		if fsb.bnc > fsb.blc		/* buffer is empty */
      301 		then do;
      302 		     fsb.blc = 0;
      303 		     call fill_stream_input_buffer ("0"b);
      304 		end;
      305 
      306 /* Now grab 1 line out of the buffer */
      307 
      308 		/* initialize loop for reading */
      309 
      310 		vlength = divide(vlength,9,21,0);
      311 
      312 		if work.varying_string
      313 		then vlength = vlength - 4;
      314 
      315 		bytes_read = 0;
      316 		signal_record = "0"b;
      317 		ends_in_NL = "0"b;
      318 
      319 		/* loop until line is read */
      320 
      321 		do while( ^ ends_in_NL & fsb.blc ^= 0);
      322 
      323 		     /* scan for a newline */
      324 
      325 		     buffer_len = fsb.blc - fsb.bnc + 1;
      326 		     scan_index = index(substr(xbuf, fsb.bnc, buffer_len), NL) - 1;
      327 
      328 		     /* remember if newline found */
      329 
      330 		     if scan_index >= 0
      331 		     then ends_in_NL = "1"b;
      332 		     else scan_index = buffer_len;
      333 
      334 		     /* check if buffer_load will fit in target */
      335 
      336 		     if scan_index > vlength - bytes_read
      337 		     then do;
      338 			signal_record = "1"b;
      339 			copy_len = vlength - bytes_read;
      340 			end;
      341 		     else copy_len = scan_index;
      342 
      343 		     /* move buffer_load into target */
      344 
      345 		     if copy_len > 0
      346 		     then do;
      347 			substr(variable_overlay, bytes_read + 1, copy_len) =
      348 			     substr(xbuf, fsb.bnc, copy_len);
      349 			bytes_read = bytes_read + copy_len;
      350 			end;
      351 
      352 		     /* if newline not found, get another buffer_load,
      353*		        otherwise, step past the newline */
      354 
      355 		     if ^  ends_in_NL
      356 		     then do;
      357 			fsb.blc = 0;
      358 			call fill_stream_input_buffer("1"b);
      359 			end;
      360 		     else fsb.bnc = fsb.bnc + (scan_index + 1);
      361 		     end;
      362 
      363 		fsb.kol = 0;
      364 
      365 		/* finish assignment */
      366 
      367 		if work.varying_string
      368 		then psr.variable_p -> string_len = bytes_read;
      369 		else if bytes_read < vlength
      370 		     then substr(variable_overlay, bytes_read + 1) = " ";
      371 
      372 		if signal_record
      373 		then call plio2_signal_$s_(psp,"RECORD","",294);	/* input line too long */
      374 	     end;
      375 	     else if work.write			/* A WRITE STATEMENT */
      376 	     then do;
      377 
      378 		if ^fsb.switch.output
      379 		then do;
      380 		     erno = 290;			/* Stream file referenced by write statement isn't output */
      381 		     go to signal_error;
      382 		end;
      383 
      384 		if work.varying_string
      385 		then vlength = psr.variable_p -> string_len;
      386 		else vlength = divide (vlength, 9, 21, 0);
      387 
      388 /* Check that the record will fit on the current line. */
      389 
      390 		if vlength > fsb.lsize - fsb.kol
      391 		then do;
      392 		     call plio2_signal_$s_ (psp, "RECORD", "", 288);
      393 		     vlength = fsb.lsize - kol;
      394 		     end;
      395 		call iox_$put_chars (iocb_p, vptr, vlength, iocb_status);
      396 		if iocb_status ^= 0 then go to write_error;
      397 
      398 		call iox_$put_chars (iocb_p, addr (NL), 1, iocb_status);
      399 		if iocb_status ^= 0 then go to write_error;
      400 
      401 		fsb.kol = 0;
      402 
      403 		if fsb.switch.print
      404 		then do;
      405 		     fsb.lineno = fsb.lineno + 1;
      406 
      407 		     if fsb.lineno = fsb.psize + 1
      408 		     then call plio2_signal_$s_ (psp, "ENDPAGE", "", 234);
      409 		end;
      410 	     end;
      411 	     return;
      412 	end;
      413 
      414 /* if FROM/INTO then prepare for buffer operations.
      415*   IOX_ wants to use aligned byte buffers but the program may
      416*   specify a buffer that is not byte aligned OR which is not byte-lengthed,
      417*   either of which necessitates use of bitcopies.   */
      418 
      419 	if (work.locate | work.from | work.into) then
      420 	     do;
      421 	     vlength = divide (vlength+8, 9, 21, 0);	/* must be in units of words AND must be tested !! */
      422 	     if release>0 then if ^work.not_bytebuffer then char_buffer = "1"b;
      423 		else do;
      424 		     if mod (psr.variable_bitlen, 9) ^= 0 then goto not_byteish;
      425 		     if mod (fixed (addr (psr.variable_p) -> its.bit_offset, 6), 9) = 0
      426 		     then char_buffer = "1"b; else
      427 not_byteish:	     char_buffer = "0"b;
      428 		end;
      429 	end;
      430 
      431 /* buffer is described as follows:
      432*   char_buffer="1"b		length in bytes given by _v_l_e_n_g_t_h
      433*   char_buffer="0"b		length in bits  given by _p_s_r.__v_a_r_i_a_b_l_e___b_i_t_l_e_n  */
      434 
      435 /*  	DISPATCH ....................DISPATCH */
      436 
      437 	if job_18 & "0001001"b then go to WL;		/* write and locate */
      438 	if job_18 & "000011"b then go to RD;		/* rewrite and delete */
      439 
      440 /*  READ  */
      441 
      442 free_inbuf:
      443 	if fsbr.inbuf_sw.exists then
      444 	     do;
      445 	     ballocn = fsbr.inbuf_maxlen;
      446 	     free fsbr.inbuf_ptr -> balloc;
      447 	     fsbr.switch.buffer_in_use,
      448 		fsbr.inbuf_sw.exists = "0"b;
      449 	end;
      450 
      451 	if work_overlay.close
      452 	then go to EXIT;
      453 
      454 	if work.key then
      455 	     do;
      456 	     if release>0 then onkeyx = psr.keytemp;
      457 	     else onkeyx = addr (psr.keytemp) -> bc32;
      458 						/* we can handle old as well as new KEYs */
      459 	     call iox_$seek_key (iocb_p, onkeyx, rlength, iocb_status);
      460 	     if iocb_status ^= 0 then goto read_error;
      461 	     fsbr.key_saved = onkeyx;
      462 	end;
      463 
      464 	if work.ignore then
      465 	     do;
      466 	     if psr.number<1 then goto EXIT;
      467 	     call iox_$position (iocb_p, 0, psr.number, iocb_status);
      468 	     if iocb_status ^= 0 then goto read_error;
      469 	     fsbr.rec_valid = "1"b;
      470 	     goto EXIT;
      471 	end;
      472 
      473 	if ^work.key & work.keyto then
      474 	     do;
      475 	     call iox_$read_key (iocb_p, fsbr.key_saved, rlength, iocb_status);
      476 	     if iocb_status ^= 0 then goto read_error;
      477 	end;
      478 	fsbr.rec_valid = "1"b;
      479 
      480 	if work.keyto then
      481 	     do;
      482 	     if release>0 then psr.keytemp = fsbr.key_saved;
      483 	     else addr (psr.keytemp) -> bc32 = fsbr.key_saved;
      484 	     keyto_keyset = "1"b;
      485 	end;
      486 
      487 
      488 	if work.set then
      489 	     do;
      490 	     statep = addr (fsbr.inbuf_curlen);
      491 	     if ^work.key & ^work.keyto		/* if either of these, rlength has been already set	*/
      492 	     then do;
      493 		call iox_$read_length (iocb_p, rlength, iocb_status);
      494 		if iocb_status ^= 0 then goto read_error;
      495 	     end;
      496 
      497 	     vlength = rlength;			/* keyed or not, rlength is the length of the record in the file */
      498 	     call obtain_buffer;
      499 	     copyp = buffer_state.bptr;
      500 
      501 	     if work.packedptr then psr.set_p_p -> based_packedptr = buffer_state.bptr;
      502 	     else psr.set_p_p -> based_pointer = buffer_state.bptr;
      503 	     char_buffer = "1"b;
      504 	end;
      505 
      506 	else /* INTO  */ if char_buffer then copyp = psr.variable_p; /* vlength having been set  above  */
      507 
      508 
      509 	if char_buffer
      510 	then do;
      511 	     call iox_$read_record (iocb_p, copyp, vlength, xrlength, iocb_status);
      512 	     if iocb_status ^= 0 then goto read_error;
      513 
      514 	     if valid_stringvalue
      515 	     then if work.bit_string
      516 		then addrel (copyp, -1) -> string_len = xrlength*9;
      517 		else addrel (copyp, -1) -> string_len = xrlength;
      518 	     else if vlength ^= xrlength then goto short_record;
      519 	end;
      520 
      521 	else					/* BEGIN BLOCK to allocate a temporary bit-buffer */
      522 	begin;					/* this is a READ INTO with a target which
      523*						   is either not byte-aligned or not an even
      524*						   number of bytes long.  */
      525 dcl  tempbuffer char (vlength) aligned;			/* vlength has been corrected, above */
      526 dcl  bitbuffer bit (nnn) unaligned based;
      527 dcl  nnn fixed bin (17);
      528 
      529 	     call iox_$read_record (iocb_p, addr (tempbuffer), vlength, xrlength, iocb_status);
      530 	     if iocb_status ^= 0 then if iocb_status ^= error_table_$long_record then goto read_error;
      531 	     nnn = 9*min (vlength, xrlength);
      532 	     psr.variable_p -> bitbuffer = addr (tempbuffer) -> bitbuffer;
      533 	     if iocb_status = error_table_$long_record then goto long_record;
      534 	     if vlength ^= xrlength then goto short_record;
      535 						/* ASSUMPTION: that record length equals variable length
      536*						   if variable_bitlen+8/9 = record_length  */
      537 	end;
      538 
      539 	return;
      540 
      541 read_error:
      542 	if iocb_status = error_table_$end_of_info then
      543 	     do;
      544 	     erno = 258;
      545 						/* unable to read beyond EOF in sequential file */
      546 	     goto sig_eof;
      547 	end;
      548 
      549 	if iocb_status = error_table_$no_record then
      550 	     do;
      551 	     erno = 292;
      552 						/* unable to perform keyed lookup - key not found */
      553 	     goto sig_key;
      554 	end;
      555 
      556 	if iocb_status = error_table_$long_record then
      557 	     do;
      558 long_record:
      559 	     erno = 253;
      560 						/* record in data set  larger than variable */
      561 	     goto sig_rec;
      562 	end;
      563 
      564 /* mysterious case:     */
      565 	erno = 293;
      566 						/* unable to perform sequential access */
      567 	goto sandr;
      568 
      569 short_record:
      570 	erno = 254;
      571 						/* record in data set smaller than variable */
      572 	iocb_status = error_table_$short_record;	/* this is so fsb.lnzc gets set, so dpe  gets good info */
      573 
      574 	goto sig_rec;
      575 
      576 /* 	WRITE and LOCATE                */
      577 
      578 WL:	if fsbr.outbuf_sw.use then
      579 	     do;
      580 	     w_char_buffer = "1"b;
      581 	     wptr = fsbr.outbuf_ptr;
      582 	     wlen = fsbr.outbuf_curlen;
      583 
      584 	     call write_x;
      585 
      586 	     ballocn = fsbr.outbuf_maxlen;
      587 	     free fsbr.outbuf_ptr -> balloc;
      588 	     fsbr.outbuf_sw.exists,
      589 		fsbr.outbuf_sw.use = "0"b;
      590 	end;
      591 
      592 	if work_overlay.close
      593 	then go to free_inbuf;
      594 
      595 	if work.locate then
      596 	     do;
      597 	     fsbr.outbuf_sw.use = "1"b;
      598 	     if fsbr.switch.keyed
      599 	     then do;
      600 		if release>0 then fsbr.outbuf_key = psr.keytemp;
      601 		else fsbr.outbuf_key = addr (psr.keytemp) -> bc32;
      602 	     end;
      603 	     statep = addr (fsbr.outbuf_curlen);
      604 	     call obtain_buffer;
      605 	     if work.packedptr then psr.set_p_p -> based_packedptr = buffer_state.bptr;
      606 	     else psr.set_p_p -> based_pointer = buffer_state.bptr;
      607 	end;
      608 	else do;
      609 	     fsbr.outbuf_sw.use = "0"b;
      610 	     w_char_buffer = char_buffer;
      611 	     wptr = psr.variable_p;
      612 	     if valid_stringvalue
      613 	     then if work.bit_string
      614 		then wlen = divide (addrel (psr.variable_p, -1) -> string_len+8, 9, 21, 0);
      615 		else wlen = addrel (psr.variable_p, -1) -> string_len;
      616 	     else wlen = vlength;
      617 
      618 	     call write_x;
      619 
      620 	end;
      621 	return;
      622 
      623 write_error:
      624 	if iocb_status = error_table_$key_order then
      625 	     do;
      626 	     erno = 282;
      627 						/* unable to add record to keyed sequential output
      628*						   file : keys must be distinct and ascending */
      629 	     goto sig_key;
      630 	end;
      631 
      632 	if iocb_status = 0 then
      633 	     do;
      634 	     erno = 296;
      635 						/* unable to create keyed record because the
      636*						   specified key has already been used. */
      637 	     goto sig_key;
      638 	end;
      639 
      640 	else do;
      641 	     erno = 284;
      642 						/* unable to create new record for write,
      643*						   locate, or close statement.  */
      644 	     goto sandr;
      645 	end;					/* mysterious */
      646 
      647 /*  		rewrite,delete . . . . . . . . . . . . . . . . .   */
      648 
      649 RD:
      650 	if work.key then
      651 	     do;
      652 	     onkeyx = psr.keytemp;
      653 	     call iox_$seek_key (iocb_p, onkeyx, rlength, iocb_status);
      654 	     if iocb_status ^= 0 then goto rewrite_error;
      655 	     fsbr.recio.rec_valid = "1"b;
      656 	end;
      657 	else if fsbr.switch.keyed then onkeyx = fsbr.key_saved;
      658 
      659 	if fsbr.recio.rec_valid = "0"b
      660 	then do;
      661 	     erno = 256;
      662 	     go to sandr;
      663 	end;
      664 						/* record to be rewritten or deleted has already
      665*						   been deleted.  */
      666 	if work.delete then
      667 	     do;
      668 	     call iox_$delete_record (iocb_p, iocb_status);
      669 	     if iocb_status ^= 0 then goto rewrite_error;
      670 						/* unable to delete designated record. */
      671 	     fsbr.recio.rec_valid = "0"b;		/* cannot be deleted, rewritten  */
      672 	     go to EXIT;
      673 	end;
      674 
      675 	if work.from then wptr = psr.variable_p;
      676 	else do;
      677 	     if fsbr.inbuf_sw.use = "0"b then
      678 		do; erno = 255; go to sandr; end;
      679 						/* There is no FROM OPTION or input buffer */
      680 	     vlength = fsbr.inbuf_curlen;
      681 	     wptr = fsbr.inbuf_ptr;
      682 	     char_buffer = "1"b;
      683 	end;
      684 
      685 	if valid_stringvalue
      686 	then if work.bit_string
      687 	     then vlength = divide (addrel (psr.variable_p, -1) -> string_len+8, 9, 21, 0);
      688 	     else vlength = addrel (psr.variable_p, -1) -> string_len;
      689 
      690 	if char_buffer then call iox_$rewrite_record (iocb_p, wptr, vlength, iocb_status);
      691 	else begin;
      692 
      693 dcl  tempbuffer_r char (vlength) aligned;
      694 dcl  bitbuffer_r bit (9*vlength) unaligned based;
      695 
      696 	     addr (tempbuffer_r) -> bitbuffer_r = wptr -> bitbuffer_r;
      697 	     call iox_$rewrite_record (iocb_p, addr (tempbuffer_r), vlength, iocb_status);
      698 	end;
      699 
      700 	if iocb_status ^= 0 then
      701 	     do;
      702 rewrite_error: if iocb_status = error_table_$long_record then
      703 		do;
      704 		erno = 280;
      705 		goto sig_rec;
      706 	     end;
      707 	     if iocb_status = error_table_$short_record then
      708 		do;
      709 		erno = 280;
      710 		goto sig_rec;
      711 	     end;
      712 	     if iocb_status = error_table_$no_record then
      713 		do;
      714 		erno = 292;
      715 		goto sig_key;
      716 	     end;
      717 						/* unable to rewrite record. */
      718 	     if psr.job.delete
      719 	     then erno = 285;
      720 	     else erno = 281;
      721 	     goto sandr;
      722 	end;
      723 	return;
      724 
      725 recio_close_: entry (pspp);
      726 	psp = pspp;
      727 	fsbp = psr.source_p -> file_value.fsb_ptr;
      728 	iocb_p = fsbr.iocb_p;
      729 	string (work) = "00000000000000000000000000000001"b; /* close */
      730 
      731 	go to WL;
      732 
      733 error:	entry (pspp, error_status);
      734 	psp = pspp;
      735 	string (work) = string (psr.job);
      736 	psr.file_p = psr.source_p;
      737 	plio2_data_$fsbpstat,
      738 	     fsbp, psr.fsbp = psr.file_p -> file_value.fsb_ptr;
      739 	if fsbr.switch.keyed
      740 	then onkeyx = psr.keytemp;
      741 	else onkeyx = "";
      742 	iocb_status = error_status;
      743 	if psp -> psr.job.read
      744 	then if iocb_status>0
      745 	     then goto read_error;
      746 	     else goto short_record;
      747 	if psp -> psr.job.write then goto write_error;
      748 	goto rewrite_error;
      749 
      750 /* INTERNAL PROCEDURES */
      751 
      752 fill_stream_input_buffer:
      753 	procedure (bv_ignore_eof);
      754 
      755 /* parameters */
      756 
      757 declare bv_ignore_eof bit (1) aligned parameter;
      758 
      759 /* automatic */
      760 
      761 declare  buffer_ptr ptr,
      762          max_read_len fixed bin (21),
      763          read_len fixed bin (21);
      764 
      765 /* based */
      766 
      767 declare  buffer_array_overlay char (1) dim (fsb.bsize) based (fsb.bptr);
      768 
      769 /* program */
      770 
      771 	     buffer_ptr = addr (buffer_array_overlay);
      772 	     max_read_len = fsb.bsize;
      773 
      774 	     fsb.bnc = 1;	/* redundant stmt protects us somewhat from quit-start */
      775 
      776 	     if fsb.console
      777 	     then call iox_$get_line (iocb_p, buffer_ptr, max_read_len, read_len, iocb_status);
      778 	     else call iox_$get_chars (iocb_p, buffer_ptr, max_read_len, read_len, iocb_status);
      779 
      780 	     fsb.bnc = 1;
      781 
      782 	     if iocb_status ^= 0
      783 	     then if iocb_status = error_table_$short_record | iocb_status = error_table_$long_record
      784 		then iocb_status = 0;
      785 		else if iocb_status = error_table_$end_of_info
      786 		then do;
      787 		     if bv_ignore_eof
      788 		     then do;
      789 			iocb_status = 0;
      790 			return;
      791 		     end;
      792 		     erno = 291;			/* EOF during read to stream file */
      793 		     go to sig_eof;
      794 		end;
      795 		else do;
      796 		     erno = 295;			/* transmit */
      797 		     go to sandr;
      798 		end;
      799 
      800 	     fsb.blc = fsb.blc + read_len;
      801 
      802 	end fill_stream_input_buffer;
      803 
      804 obtain_buffer:
      805 	procedure ();
      806 
      807 	     if ^bsw.exists | vlength > bmax
      808 	     then do;
      809 		if bsw.exists
      810 		then do;
      811 		     ballocn = bmax;
      812 		     free buffer_state.bptr -> balloc;
      813 		end;
      814 		ballocn = vlength;
      815 		allocate balloc set (buffer_state.bptr);
      816 		bmax = ballocn;
      817 		bsw.exists = "1"b;
      818 	     end;
      819 
      820 	     blen, copyn = vlength;
      821 	     fsbr.switch.buffer_in_use,
      822 		bsw.use = "1"b;
      823 
      824 	end obtain_buffer;
      825 
      826 write_x:	proc;
      827 	     if fsbr.switch.keyed then
      828 		do;
      829 		if fsbr.outbuf_sw.use then onkeyx = fsbr.outbuf_key;
      830 		else do;
      831 		     if release>0 then onkeyx = psr.keytemp;
      832 		     else onkeyx = addr (psr.keytemp) -> bc32;
      833 		end;
      834 		call iox_$seek_key (iocb_p, onkeyx, xrlength, iocb_status);
      835 		if iocb_status ^= error_table_$no_record then goto write_error;
      836 	     end;
      837 
      838 	     if w_char_buffer
      839 	     then call iox_$write_record (iocb_p, wptr, wlen, iocb_status);
      840 	     else begin;
      841 
      842 dcl  tempbuffer_w char (wlen) aligned;
      843 dcl  bitbuffer_w bit (9*vlength) unaligned based;
      844 
      845 		addr (tempbuffer_w) -> bitbuffer_w = psr.variable_p -> bitbuffer_w;
      846 		call iox_$write_record (iocb_p, addr (tempbuffer_w), wlen, iocb_status);
      847 	     end;
      848 	     if iocb_status ^= 0 then goto write_error;
      849 	     fsbr.switch.buffer_in_use = "0"b;
      850 	     if fsbr.switch.keyed then fsbr.key_saved = onkeyx;
      851 	     fsbr.recio.rec_valid = "1"b;
      852 	end write_x;
      853 
      854      end						/* plio2_recio_ */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1005.5  plio2_recio_.pl1                  >spec>on>pl128d>plio2_recio_.pl1
157          1    10/04/77  1919.3  pl1_file_value.incl.pl1           >ldd>include>pl1_file_value.incl.pl1
158          2    08/13/81  2043.5  plio2_fsb.incl.pl1                >ldd>include>plio2_fsb.incl.pl1
159          3    08/13/81  2043.5  plio2_fsbr.incl.pl1               >ldd>include>plio2_fsbr.incl.pl1
160          4    08/13/81  2043.5  plio2_psr.incl.pl1                >ldd>include>plio2_psr.incl.pl1
161          5    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              000000 constant        char(1)                  initial unaligned dcl 152 set ref 326 398 398
ab_return                12            based           structure                level 2 dcl 4-5 set ref 174 255
addr                                                   builtin function         dcl 137 ref 170 174 184 220 223 227 230 230 255 398
                                                                                  398 425 451 457 483 490 529 529 532 592 601 603
                                                                                  696 697 697 771 832 845 846 846
addrel                                                 builtin function         dcl 137 ref 209 285 514 517 612 615 685 688
balloc                                 based           char                     dcl 89 ref 446 587 812 815
ballocn                         000125 automatic       fixed bin(17,0)          dcl 63 set ref 445* 446 446 586* 587 587 811* 812
                                                                                  812 814* 815 815 816
based_label                            based           label variable           dcl 92 set ref 174* 255
based_packedptr                        based           pointer                  unaligned dcl 90 set ref 501* 605*
based_pointer                          based           pointer                  dcl 82 set ref 502* 606*
bc32                                   based           char(32)                 dcl 91 set ref 457 483* 601 832
bit_offset                1(21)        based           bit(6)                   level 2 packed unaligned dcl 5-5 ref 425
bit_string                0(13) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 514 612 685
bitbuffer                              based           bit                      unaligned dcl 526 set ref 532* 532
bitbuffer_r                            based           bit                      unaligned dcl 694 set ref 696* 696
bitbuffer_w                            based           bit                      unaligned dcl 843 set ref 845* 845
blc                       4            based           fixed bin(21,0)          level 2 dcl 2-4 set ref 300 302* 321 325 357* 800*
                                                                                  800
blen                                   based           fixed bin(15,0)          level 2 dcl 83 set ref 820*
bmax                      1            based           fixed bin(15,0)          level 2 dcl 83 set ref 807 811 816*
bnc                      10            based           fixed bin(15,0)          level 2 dcl 2-4 set ref 300 325 326 347 360* 360
                                                                                  774* 780*
bptr                      6            based           pointer                  level 2 in structure "fsb" dcl 2-4 in procedure
                                                                                  "plio2_recio_" ref 326 347 771
bptr                      2            based           pointer                  level 2 in structure "buffer_state" dcl 83
                                                                                  in procedure "plio2_recio_" set ref 499 501 502
                                                                                  605 606 812 815*
bsize                     5            based           fixed bin(21,0)          level 2 dcl 2-4 ref 772
bsw                       4            based           structure                level 2 dcl 83
buffer_array_overlay                   based           char(1)                  array unaligned dcl 767 set ref 771
buffer_in_use             0(22)        based           bit(1)                   level 3 packed unaligned dcl 3-6 set ref 447* 821*
                                                                                  849*
buffer_len                      000100 automatic       fixed bin(21,0)          dcl 57 set ref 325* 326 332
buffer_ptr                      000272 automatic       pointer                  dcl 761 set ref 771* 776* 778*
buffer_state                           based           structure                level 1 dcl 83
bv_ignore_eof                          parameter       bit(1)                   dcl 757 ref 752 787
bytes_read                      000101 automatic       fixed bin(21,0)          dcl 58 set ref 315* 336 339 347 349* 349 367 369 369
char_buffer                     000102 automatic       bit(1)                   dcl 59 set ref 422* 425* 426* 503* 506 509 610 682*
                                                                                  690
close                     0(31)        based           bit(1)                   level 2 packed unaligned dcl 96 ref 451 592
code                            000124 automatic       fixed bin(17,0)          initial dcl 63 set ref 63*
conname                         000103 automatic       char(16)                 unaligned dcl 60 set ref 245* 249* 253* 266* 270*
                                                                                  274*
console                   0(30)        based           bit(1)                   level 3 packed unaligned dcl 2-4 ref 776
copy_len                        000107 automatic       fixed bin(21,0)          dcl 61 set ref 339* 341* 345 347 347 349
copyn                           000130 automatic       fixed bin(21,0)          dcl 64 set ref 820*
copyp                           000116 automatic       pointer                  dcl 62 set ref 499* 506* 511* 514 517
delete                   26(18)        based           bit(1)                   level 3 in structure "psr" packed unaligned dcl 4-5
                                                                                  in procedure "plio2_recio_" ref 718
delete                    0(18) 000263 automatic       bit(1)                   level 2 in structure "work" packed unaligned dcl 78
                                                                                  in procedure "plio2_recio_" set ref 189 666
divide                                                 builtin function         dcl 137 ref 310 386 421 612 685
ends_in_NL                      000134 automatic       bit(1)                   dcl 65 set ref 317* 321 330* 355
erno                            000123 automatic       fixed bin(17,0)          initial dcl 63 set ref 63* 241* 242* 243* 253* 294*
                                                                                  380* 544* 551* 558* 565* 569* 626* 634* 641* 661*
                                                                                  678* 704* 709* 714* 718* 720* 792* 796*
error_status                           parameter       fixed bin(35,0)          dcl 51 ref 733 742
error_table_$end_of_info        000056 external static fixed bin(35,0)          dcl 143 ref 541 785
error_table_$key_order          000054 external static fixed bin(35,0)          dcl 143 ref 623
error_table_$long_record        000050 external static fixed bin(35,0)          dcl 143 ref 530 533 556 702 782
error_table_$no_record          000046 external static fixed bin(35,0)          dcl 143 ref 549 712 835
error_table_$short_record       000052 external static fixed bin(35,0)          dcl 143 ref 572 707 782
exists                   10            based           bit(1)                   level 3 in structure "fsbr" packed unaligned dcl 3-6
                                                                                  in procedure "plio2_recio_" set ref 442 447*
exists                   16            based           bit(1)                   level 3 in structure "fsbr" packed unaligned dcl 3-6
                                                                                  in procedure "plio2_recio_" set ref 588*
exists                    4            based           bit(1)                   level 3 in structure "buffer_state" packed unaligned
                                                                                  dcl 83 in procedure "plio2_recio_" set ref 807 809
                                                                                  817*
fab2p                    50            based           pointer                  level 2 dcl 4-5 set ref 184*
file_p                   40            based           pointer                  level 2 dcl 4-5 set ref 178* 179 736* 737
file_value                             based           structure                level 1 dcl 1-3
fixed                                                  builtin function         dcl 137 ref 425
from                      0(26) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 220 419 675
fsb                                    based           structure                level 1 dcl 2-4
fsb_ptr                   2            based           pointer                  level 2 dcl 1-3 ref 179 727 737
fsbp                            000112 automatic       pointer                  dcl 62 in procedure "plio2_recio_" set ref 179* 182
                                                                                  194 195 236 251 282 292 300 300 302 321 325 325
                                                                                  326 326 347 347 357 360 360 363 378 390 390 393
                                                                                  393 401 403 405 405 407 407 442 445 446 447 447
                                                                                  461 469 475 478 482 483 490 578 581 582 586 587
                                                                                  588 588 597 598 600 601 603 609 655 657 657 659
                                                                                  671 677 680 681 727* 728 737* 739 771 772 774 776
                                                                                  780 800 800 821 827 829 829 849 850 850 851
fsbp                     42            based           pointer                  level 2 in structure "psr" dcl 4-5 in procedure
                                                                                  "plio2_recio_" set ref 179* 737*
fsbr                                   based           structure                level 1 dcl 3-6
i                               000122 automatic       fixed bin(17,0)          dcl 63 set ref 240* 242 243
ignore                    0(25) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 216* 464
inbuf_curlen              4            based           fixed bin(15,0)          level 2 dcl 3-6 set ref 490 680
inbuf_maxlen              5            based           fixed bin(15,0)          level 2 dcl 3-6 ref 445
inbuf_ptr                 6            based           pointer                  level 2 dcl 3-6 ref 446 681
inbuf_sw                 10            based           structure                level 2 dcl 3-6
index                                                  builtin function         dcl 137 ref 240 326
input                     0(05)        based           bit(1)                   level 3 packed unaligned dcl 2-4 ref 292
into                      0(24) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 419
iocb_p                          000136 automatic       pointer                  dcl 66 in procedure "plio2_recio_" set ref 195* 395*
                                                                                  398* 459* 467* 475* 493* 511* 529* 653* 668* 690*
                                                                                  697* 728* 776* 778* 834* 838* 846*
iocb_p                    3            based           pointer                  level 2 in structure "fsbr" packed unaligned dcl 3-6
                                                                                  in procedure "plio2_recio_" ref 195 728
iocb_status                     000140 automatic       fixed bin(35,0)          dcl 67 set ref 251 251 395* 396 398* 399 459* 460
                                                                                  467* 468 475* 476 493* 494 511* 512 529* 530 530
                                                                                  533 541 549 556 572* 623 632 653* 654 668* 669
                                                                                  690* 697* 700 702 707 712 742* 743 776* 778* 782
                                                                                  782 782 782* 785 789* 834* 835 838* 846* 848
iox_$delete_record              000010 constant        entry                    external dcl 121 ref 668
iox_$get_chars                  000012 constant        entry                    external dcl 121 ref 778
iox_$get_line                   000014 constant        entry                    external dcl 121 ref 776
iox_$position                   000022 constant        entry                    external dcl 126 ref 467
iox_$put_chars                  000016 constant        entry                    external dcl 121 ref 395 398
iox_$read_key                   000024 constant        entry                    external dcl 127 ref 475
iox_$read_length                000026 constant        entry                    external dcl 128 ref 493
iox_$read_record                000030 constant        entry                    external dcl 129 ref 511 529
iox_$rewrite_record             000034 constant        entry                    external dcl 131 ref 690 697
iox_$seek_key                   000020 constant        entry                    external dcl 125 ref 459 653 834
iox_$write_record               000032 constant        entry                    external dcl 130 ref 838 846
its                                    based           structure                level 1 dcl 5-5
job                      26            based           structure                level 2 dcl 4-5 ref 168 735
job_18                          000256 automatic       bit(18)                  dcl 74 set ref 235* 236 437 438
key                       0(20) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 227 454 473
                                                                                  491 649
key_saved               143            based           varying char(256)        level 2 dcl 3-6 set ref 461* 475* 482 483 657 850*
keyed                     0(17)        based           bit(1)                   level 3 packed unaligned dcl 3-6 ref 598 657 739 827
                                                                                  850
keyfrom                   0(22) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 223
keytemp                  60            based           varying char(256)        level 2 dcl 4-5 set ref 230* 456 457 482* 483 600
                                                                                  601 652 739 831 832
keyto                     0(21) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 173 255 473
                                                                                  480 491
keyto_keyset             57            based           bit(1)                   level 3 packed unaligned dcl 4-5 set ref 173* 255
                                                                                  484*
kol                      11            based           fixed bin(15,0)          level 2 dcl 2-4 set ref 363* 390 393 401*
length                                                 builtin function         dcl 137 ref 253 253
lineno                   13            based           fixed bin(15,0)          level 2 dcl 2-4 set ref 405* 405 407
lnzc                     17            based           fixed bin(35,0)          level 2 dcl 3-6 set ref 251*
locate                    0(19) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 190 223 419
                                                                                  595
lsize                    12            based           fixed bin(15,0)          level 2 dcl 2-4 ref 390 393
max_read_len                    000274 automatic       fixed bin(21,0)          dcl 761 set ref 772* 776* 778*
min                                                    builtin function         dcl 137 ref 531
mod                                                    builtin function         dcl 137 ref 424 425
name                      1     000242 automatic       char(32)                 level 2 dcl 69 set ref 185*
nnn                             000100 automatic       fixed bin(17,0)          dcl 527 set ref 531* 532 532
nofrom                    0(27)        based           bit(1)                   level 2 packed unaligned dcl 96 set ref 220*
nokey                     0(28)        based           bit(1)                   level 2 packed unaligned dcl 96 set ref 227* 230
nokeyfrom                 0(29)        based           bit(1)                   level 2 packed unaligned dcl 96 set ref 223* 230
nono                      1            based           structure                level 2 dcl 3-6 ref 236
not_bytebuffer            0(33) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 422
number                   27            based           fixed bin(21,0)          level 2 dcl 4-5 set ref 217* 466 467*
onkeyx                          000141 automatic       varying char(256)        dcl 68 set ref 212* 253 253 253 253 456* 457* 459*
                                                                                  461 652* 653* 657* 739* 741* 829* 831* 832* 834*
                                                                                  850
open                      0(03)        based           bit(1)                   level 3 packed unaligned dcl 3-6 ref 182
outbuf_curlen            12            based           fixed bin(15,0)          level 2 dcl 3-6 set ref 582 603
outbuf_key               42            based           varying char(256)        level 2 dcl 3-6 set ref 600* 601* 829
outbuf_maxlen            13            based           fixed bin(15,0)          level 2 dcl 3-6 ref 586
outbuf_ptr               14            based           pointer                  level 2 dcl 3-6 ref 581 587
outbuf_sw                16            based           structure                level 2 dcl 3-6
output                    0(06)        based           bit(1)                   level 3 packed unaligned dcl 2-4 ref 378
packedptr                 0(35) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 501 605
pl1_ops_flags            57            based           structure                level 2 dcl 4-5
plio2_data_$fsbpstat            000044 external static pointer                  dcl 141 set ref 179* 737*
plio2_data_$pspstat             000042 external static pointer                  dcl 141 set ref 165*
plio2_open_$open_implicit_      000040 constant        entry                    external dcl 133 ref 191
plio2_signal_$s_                000036 constant        entry                    external dcl 132 ref 253 372 392 407
print                     0(04)        based           bit(1)                   level 3 packed unaligned dcl 2-4 ref 403
psize                    14            based           fixed bin(35,0)          level 2 dcl 2-4 ref 407
psp                             000110 automatic       pointer                  dcl 62 set ref 165* 168 173 174 178 178 179 179 184
                                                                                  191* 196 209 209 217 230 253* 255 255 285 287 367
                                                                                  372* 384 392* 407* 424 425 456 457 466 467 482 483
                                                                                  484 501 502 506 532 600 601 605 606 611 612 615
                                                                                  652 675 685 688 718 726* 727 734* 735 736 736 737
                                                                                  737 739 743 747 831 832 845
pspp                                   parameter       pointer                  dcl 51 ref 10 165 725 726 733 734
psr                                    based           structure                level 1 dcl 4-5
read                      0(15) 000263 automatic       bit(1)                   level 2 in structure "work" packed unaligned dcl 78
                                                                                  in procedure "plio2_recio_" set ref 186 214 289
read                     26(15)        based           bit(1)                   level 3 in structure "psr" packed unaligned dcl 4-5
                                                                                  in procedure "plio2_recio_" ref 743
read_len                        000275 automatic       fixed bin(21,0)          dcl 761 set ref 776* 778* 800
rec_valid                 2(01)        based           bit(1)                   level 3 packed unaligned dcl 3-6 set ref 469* 478*
                                                                                  655* 659 671* 851*
recio                     2            based           structure                level 2 dcl 3-6
reciofab                        000242 automatic       structure                level 1 dcl 69 set ref 184
release                         000127 automatic       fixed bin(21,0)          dcl 64 set ref 169* 170 422 456 482 600 831
release_bits                           based           bit(36)                  dcl 93 set ref 170*
rewrite                   0(17) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 188 220
rlength                         000131 automatic       fixed bin(21,0)          dcl 64 set ref 459* 475* 493* 497 653*
scan_index                      000253 automatic       fixed bin(21,0)          dcl 72 set ref 326* 330 332* 336 341 360
set                       0(23) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 488
set_p_p                  22            based           pointer                  level 2 dcl 4-5 ref 501 502 605 606
signal_record                   000254 automatic       bit(1)                   dcl 73 set ref 316* 338* 372
source_p                 20            based           pointer                  level 2 dcl 4-5 ref 178 727 736
statep                          000120 automatic       pointer                  dcl 62 set ref 490* 499 501 502 603* 605 606 807 807
                                                                                  809 811 812 815 816 817 820 821
stream                    0(08)        based           bit(1)                   level 3 packed unaligned dcl 3-6 ref 282
string                                                 builtin function         dcl 137 set ref 168* 168 170 171 214 235 236 729*
                                                                                  735* 735
string_len                             based           fixed bin(24,0)          dcl 94 set ref 367* 384 514* 517* 612 615 685 688
stringvalue               0(16)        based           bit(1)                   level 3 packed unaligned dcl 3-6 ref 194
substr                                                 builtin function         dcl 137 set ref 170* 170 171* 214 235 253 253 326
                                                                                  347* 347 369*
sw                              000242 automatic       bit(36)                  level 2 dcl 69 set ref 186* 187* 188* 189* 190*
switch                                 based           structure                level 2 in structure "fsb" dcl 2-4 in procedure
                                                                                  "plio2_recio_"
switch                                 based           structure                level 2 in structure "fsbr" dcl 3-6 in procedure
                                                                                  "plio2_recio_"
tempbuffer                      000100 automatic       char                     dcl 525 set ref 529 529 532
tempbuffer_r                    000100 automatic       char                     dcl 693 set ref 696 697 697
tempbuffer_w                    000100 automatic       char                     dcl 842 set ref 845 846 846
test_18                         000255 automatic       bit(18)                  dcl 74 set ref 236* 238 240
use                      10(02)        based           bit(1)                   level 3 in structure "fsbr" packed unaligned dcl 3-6
                                                                                  in procedure "plio2_recio_" ref 677
use                       4(02)        based           bit(1)                   level 3 in structure "buffer_state" packed unaligned
                                                                                  dcl 83 in procedure "plio2_recio_" set ref 821*
use                      16(02)        based           bit(1)                   level 3 in structure "fsbr" packed unaligned dcl 3-6
                                                                                  in procedure "plio2_recio_" set ref 578 588* 597*
                                                                                  609* 829
valid_stringvalue               000257 automatic       bit(1)                   dcl 75 set ref 194* 197 514 612 685
variable_bitlen          25            based           fixed bin(35,0)          level 2 dcl 4-5 ref 196 424
variable_overlay                       based           char                     unaligned dcl 95 set ref 347* 369*
variable_p               30            based           pointer                  level 2 dcl 4-5 set ref 209* 209 285 287 367 384 425
                                                                                  506 532 611 612 615 675 685 688 845
varying_array             0(34) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 194 208
varying_string            0(02) 000263 automatic       bit(1)                   level 2 packed unaligned dcl 78 set ref 194 197 285
                                                                                  312 367 384
vlength                         000133 automatic       fixed bin(21,0)          dcl 64 set ref 196* 208* 208 310* 310 312* 312 336
                                                                                  339 347 369 369 384* 386* 386 390 393* 395* 421*
                                                                                  421 497* 511* 518 525 529* 531 534 616 680* 685*
                                                                                  688* 690* 693 696 696 697* 807 814 820 845 845
vptr                            000260 automatic       pointer                  dcl 76 set ref 285* 287* 347 369 395*
w_char_buffer                   000262 automatic       bit(1)                   dcl 77 set ref 580* 610* 838
wlen                            000126 automatic       fixed bin(21,0)          dcl 64 set ref 582* 612* 615* 616* 838* 842 846*
work                            000263 automatic       structure                level 1 dcl 78 set ref 168* 170 171 214 220 223 227
                                                                                  230 230 235 451 592 729* 735*
work_overlay                           based           structure                level 1 dcl 96
wptr                            000114 automatic       pointer                  dcl 62 set ref 581* 611* 675* 681* 690* 696 838*
write                    26(16)        based           bit(1)                   level 3 in structure "psr" packed unaligned dcl 4-5
                                                                                  in procedure "plio2_recio_" ref 747
write                     0(16) 000263 automatic       bit(1)                   level 2 in structure "work" packed unaligned dcl 78
                                                                                  in procedure "plio2_recio_" set ref 187 220 223
                                                                                  375
xbuf                                   based           char(1000)               unaligned dcl 2-80 ref 326 347
xrlength                        000132 automatic       fixed bin(21,0)          dcl 64 set ref 511* 514 517 518 529* 531 534 834*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 5-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 5-55
itp                                    based           structure                level 1 dcl 5-18
itp_unsigned                           based           structure                level 1 dcl 5-43
its_unsigned                           based           structure                level 1 dcl 5-30

NAMES DECLARED BY EXPLICIT CONTEXT.
EXIT                            000374 constant        label                    dcl 261 ref 174 451 466 470 672
RD                              001727 constant        label                    dcl 649 ref 438
WL                              001550 constant        label                    dcl 578 ref 437 731
error                           002241 constant        entry                    external dcl 733
fill_stream_input_buffer        002313 constant        entry                    internal dcl 752 ref 303 358
free_inbuf                      001067 constant        label                    dcl 442 ref 592
long_record                     001534 constant        label                    dcl 558 ref 533
not_byteish                     001061 constant        label                    dcl 426 ref 424
obtain_buffer                   002423 constant        entry                    internal dcl 804 ref 498 604
plio2_recio_                    000035 constant        entry                    external dcl 10
read_error                      001516 constant        label                    dcl 541 ref 460 468 476 494 512 530 743
recio_close_                    002212 constant        entry                    external dcl 725
rewrite_error                   002154 constant        label                    dcl 702 ref 654 669 748
sandr                           000317 constant        label                    dcl 249 ref 567 644 662 678 721 797
sandr1                          000322 constant        label                    dcl 251 ref 247 268 272 276
short_record                    001542 constant        label                    dcl 569 ref 518 534 746
sig_eof                         000401 constant        label                    dcl 270 ref 546 793
sig_key                         000405 constant        label                    dcl 274 ref 553 629 637 715
sig_rec                         000375 constant        label                    dcl 266 set ref 561 574 705 710
signal_error                    000313 constant        label                    dcl 245 set ref 295 381
write_error                     001710 constant        label                    dcl 623 ref 396 399 747 835 848
write_x                         002471 constant        entry                    internal dcl 826 ref 584 618

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3142        3222    2666        3152
Length      3534    2666        60         275     253           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
plio2_recio_                        254 external procedure  is an external procedure.  
begin block on line 521              84 begin block         uses auto adjustable storage.  
begin block on line 691              80 begin block         uses auto adjustable storage.  
fill_stream_input_buffer                internal procedure  shares stack frame of external procedure plio2_recio_.  
obtain_buffer                           internal procedure  shares stack frame of external procedure plio2_recio_.  
write_x                                 internal procedure  shares stack frame of external procedure plio2_recio_.  
begin block on line 840              80 begin block         uses auto adjustable storage.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 521  000100 nnn                         begin block on line 521
                         000100 tempbuffer                  begin block on line 521
begin block on line 691  000100 tempbuffer_r                begin block on line 691
begin block on line 840  000100 tempbuffer_w                begin block on line 840
plio2_recio_             000100 buffer_len                  plio2_recio_
                         000101 bytes_read                  plio2_recio_
                         000102 char_buffer                 plio2_recio_
                         000103 conname                     plio2_recio_
                         000107 copy_len                    plio2_recio_
                         000110 psp                         plio2_recio_
                         000112 fsbp                        plio2_recio_
                         000114 wptr                        plio2_recio_
                         000116 copyp                       plio2_recio_
                         000120 statep                      plio2_recio_
                         000122 i                           plio2_recio_
                         000123 erno                        plio2_recio_
                         000124 code                        plio2_recio_
                         000125 ballocn                     plio2_recio_
                         000126 wlen                        plio2_recio_
                         000127 release                     plio2_recio_
                         000130 copyn                       plio2_recio_
                         000131 rlength                     plio2_recio_
                         000132 xrlength                    plio2_recio_
                         000133 vlength                     plio2_recio_
                         000134 ends_in_NL                  plio2_recio_
                         000136 iocb_p                      plio2_recio_
                         000140 iocb_status                 plio2_recio_
                         000141 onkeyx                      plio2_recio_
                         000242 reciofab                    plio2_recio_
                         000253 scan_index                  plio2_recio_
                         000254 signal_record               plio2_recio_
                         000255 test_18                     plio2_recio_
                         000256 job_18                      plio2_recio_
                         000257 valid_stringvalue           plio2_recio_
                         000260 vptr                        plio2_recio_
                         000262 w_char_buffer               plio2_recio_
                         000263 work                        plio2_recio_
                         000272 buffer_ptr                  fill_stream_input_buffer
                         000274 max_read_len                fill_stream_input_buffer
                         000275 read_len                    fill_stream_input_buffer

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            enter_begin         leave_begin         call_ext_out_desc   call_ext_out        return
tra_ext             tra_label_var       alloc_auto_adj      mod_fx1             shorten_stack       ext_entry
index_bs_1_eis      set_support         alloc_based_storage free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$delete_record            iox_$get_chars                iox_$get_line                 iox_$position
iox_$put_chars                iox_$read_key                 iox_$read_length              iox_$read_record
iox_$rewrite_record           iox_$seek_key                 iox_$write_record             plio2_open_$open_implicit_
plio2_signal_$s_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$key_order        error_table_$long_record      error_table_$no_record
error_table_$short_record     plio2_data_$fsbpstat          plio2_data_$pspstat




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     63 000025        10 000032       165 000044       168 000052       169 000054       170 000055       171 000060
    173 000062       174 000070       178 000073       179 000075       182 000101       184 000104       185 000106
    186 000111       187 000116       188 000123       189 000130       190 000135       191 000142       194 000150
    195 000167       196 000172       197 000175       208 000201       209 000205       212 000210       214 000211
    216 000217       217 000221       220 000223       223 000233       226 000243       227 000244       230 000251
    235 000260       236 000264       238 000271       240 000272       241 000277       242 000301       243 000306
    245 000313       247 000316       249 000317       251 000322       253 000326       255 000362       261 000374
    266 000375       268 000400       270 000401       272 000404       274 000405       276 000410       282 000411
    285 000414       287 000425       289 000427       292 000432       294 000435       295 000437       300 000440
    302 000443       303 000444       310 000450       312 000453       315 000460       316 000461       317 000462
    321 000463       325 000471       326 000474       330 000506       332 000512       336 000514       338 000520
    339 000522       340 000525       341 000526       345 000530       347 000531       349 000536       355 000537
    357 000541       358 000542       359 000546       360 000547       361 000552       363 000553       367 000555
    369 000564       372 000576       374 000631       375 000632       378 000635       380 000640       381 000642
    384 000643       386 000650       390 000653       392 000657       393 000710       395 000714       396 000731
    398 000733       399 000754       401 000756       403 000760       405 000763       407 000764       411 001025
    419 001026       421 001031       422 001035       424 001045       425 001051       426 001061       437 001062
    438 001065       442 001067       445 001073       446 001075       447 001101       451 001106       454 001111
    456 001114       457 001125       459 001133       460 001150       461 001152       464 001160       466 001163
    467 001167       468 001205       469 001207       470 001212       473 001213       475 001221       476 001236
    478 001240       480 001243       482 001246       483 001257       484 001264       488 001266       490 001271
    491 001273       493 001276       494 001311       497 001313       498 001315       499 001316       501 001321
    502 001333       503 001335       504 001337       506 001340       509 001345       511 001346       512 001365
    514 001367       517 001402       518 001407       519 001412       521 001413       525 001417       529 001427
    530 001450       531 001461       532 001470       533 001476       534 001505       537 001514       539 001515
    541 001516       544 001522       546 001524       549 001525       551 001527       553 001531       556 001532
    558 001534       561 001536       565 001537       567 001541       569 001542       572 001544       574 001547
    578 001550       580 001554       581 001556       582 001560       584 001562       586 001563       587 001566
    588 001572       592 001577       595 001602       597 001605       598 001607       600 001612       601 001623
    603 001631       604 001633       605 001634       606 001650       607 001654       609 001655       610 001657
    611 001661       612 001664       615 001700       616 001704       618 001706       621 001707       623 001710
    626 001714       629 001716       632 001717       634 001721       637 001723       641 001724       644 001726
    649 001727       652 001732       653 001737       654 001754       655 001756       656 001761       657 001762
    659 001772       661 001776       662 002000       666 002001       668 002004       669 002015       671 002017
    672 002022       675 002023       677 002032       678 002035       678 002037       680 002040       681 002042
    682 002044       685 002046       688 002063       690 002070       691 002110       693 002114       696 002124
    697 002132       698 002151       700 002152       702 002154       704 002160       705 002162       707 002163
    709 002165       710 002167       712 002170       714 002172       715 002174       718 002175       720 002204
    721 002206       723 002207       725 002210       726 002221       727 002225       728 002230       729 002232
    731 002234       733 002235       734 002250       735 002254       736 002256       737 002260       739 002265
    741 002276       742 002277       743 002301       746 002306       747 002307       748 002312       752 002313
    771 002315       772 002320       774 002322       776 002324       778 002347       780 002366       782 002371
    785 002402       787 002404       789 002410       790 002411       792 002412       793 002414       796 002415
    797 002417       800 002420       802 002422       804 002423       807 002424       809 002434       811 002436
    812 002440       814 002444       815 002446       816 002455       817 002457       820 002461       821 002464
    824 002470       826 002471       827 002472       829 002475       831 002507       832 002520       834 002526
    835 002543       838 002547       840 002567       842 002573       845 002603       846 002612       847 002631
    848 002632       849 002634       850 002636       851 002647       852 002652


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
