	COMPILATION LISTING OF SEGMENT db_parse
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1029.7 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 db_parse: procedure (input_buffer_ptr, input_line_len, arg_auto_ptr, arg_stat_ptr);
       12 
       13 
       14 /* Modified 10/ by S. Barr to recognize COBOL data types and the size field with the print request. */
       15 /* Modified 771116 by PG to add el & fl output modes */
       16 /* Changed "Version 1 symbol table" msg to say "this language not supported" 10/14/83 S. Herbst */
       17 
       18 /*	Parameters	*/
       19 
       20 dcl  input_buffer_ptr ptr,
       21 
       22      input_line_len fixed bin,
       23 
       24      arg_auto_ptr ptr,
       25 
       26      arg_stat_ptr ptr;
       27 
       28 
       29 /*	Default  variables.  	*/
       30 
       31 dcl (data_ptr ptr,
       32      offset fixed bin (18),
       33      stack_depth fixed bin,
       34      data_id char (1) aligned,			/* segment id corresponds to data_ptr (t, s, i, l) */
       35      input_type char (1) aligned,			/* type of input.  Used to decide what
       36*						   *  default to use for db_assign.
       37*						   *  v = variable
       38*						   *  a = address
       39*						   *  * = indirect
       40*						   *  % = temporary
       41*						   */
       42      data_format char (6) aligned) internal static;
       43 
       44 
       45 dcl  continue bit (1) unal;
       46 dcl  break_action_code fixed bin,
       47      break_data_len fixed bin,
       48      break_data_line char (236),
       49      break_return fixed bin,
       50      reg_val bit (72);
       51 
       52 dcl  temp_reg_val fixed bin (71);
       53 
       54 dcl  goto_label label;
       55 
       56 dcl 1 label_map based aligned,
       57     2 pp ptr,
       58     2 sp ptr;
       59 
       60 dcl  err_no_linkage fixed init (1);
       61 dcl  err_no_stack fixed init (2);
       62 dcl  err_no_sym_tab fixed init (3);
       63 dcl  err_no_static fixed init (4);
       64 dcl  err_mess (4) char (40) int static init (
       65      "no linkage section",				/* err_no_linkage */
       66      "no stack frame",				/* err_no_stack */
       67      "no symbol table",				/* err_no_sym_tab */
       68      "no internal static");				/* err_no_static */
       69 
       70 dcl
       71      com_err_ ext entry options (variable),
       72      cu_$cp ext entry (ptr, fixed bin, fixed bin),
       73      cu_$gen_call ext entry (ptr, ptr),
       74      cv_oct_check_ ext entry (char (*), fixed bin) returns (fixed bin (35)),
       75      db_assign ext entry (char (132) aligned, fixed bin, fixed bin, ptr, ptr, ptr, fixed bin,
       76      fixed bin, fixed bin, fixed bin, bit (1)),
       77      db_break$global ext entry (fixed bin, fixed bin, char (236), fixed bin),
       78      db_break$print_bseg ext entry (fixed bin),
       79      db_break$print_default ext entry,
       80      db_break$set_break ext entry (ptr, fixed bin, ptr, fixed bin),
       81      db_break$set_default ext entry (ptr),
       82      db_break$set_skips ext entry (fixed bin, fixed bin),
       83      db_break$sub_global ext entry (fixed bin, fixed bin, char (236), fixed bin),
       84      db_break$single ext entry (fixed bin, fixed bin, fixed bin, char (236), fixed bin),
       85      db_parse_condition$set ext entry (char (132) aligned, fixed bin, fixed bin, fixed bin, char (236), fixed bin),
       86      db_get_count ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
       87      db_get_count$dec ext entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin),
       88      db_get_count$double entry (char (132) aligned, fixed bin, fixed bin) returns (fixed bin (71)),
       89      db_get_sym ext entry (ptr),
       90      db_print ext entry (ptr, char (*) aligned, ptr, char (*) aligned, fixed bin, fixed bin, ptr,
       91      fixed bin, fixed bin),
       92      db_regs$get ext entry (ptr, char (4) aligned, bit (72), fixed bin),
       93      db_regs$print ext entry (ptr, char (4) aligned, fixed bin),
       94      db_regs$assign ext entry (ptr, char (4) aligned, bit (72), fixed bin),
       95      db_fill_snt ext entry (ptr, ptr),
       96      db_fill_snt$proc_ptr entry (ptr, ptr),
       97      db_sym ext entry (char (72) var, ptr, ptr, fixed bin (18), fixed bin, char (1) aligned, char (*) aligned,
       98      fixed bin, fixed bin, fixed bin),
       99      decode_descriptor_ entry (ptr, fixed bin, fixed bin, bit (1) aligned,
      100      fixed bin, fixed bin, fixed bin),
      101      expand_path_ ext entry (ptr, fixed bin, ptr, ptr, fixed bin),
      102      hcs_$fs_get_path_name ext entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin),
      103      hcs_$fs_get_seg_ptr entry (char (*), ptr, fixed bin),
      104      hcs_$initiate entry (char (*) aligned, char (*) aligned, char (*), fixed bin (1), fixed bin (2),
      105      ptr, fixed bin),
      106      hcs_$make_ptr ext entry (ptr, char (*) aligned, char (*) aligned, ptr, fixed bin),
      107      ioa_$ioa_stream entry options (variable),
      108      ioa_$rsnnl ext entry options (variable),
      109      iox_$close ext entry (ptr, fixed bin (35)),
      110      iox_$detach_iocb ext entry (ptr, fixed bin (35)),
      111      iox_$attach_ioname ext entry (char (*), ptr, char (*), fixed bin (35)),
      112      iox_$find_iocb ext entry (char (*), ptr, fixed bin (35)),
      113      iox_$open ext entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
      114      list_arg_ ext entry (fixed bin, char (1) aligned, ptr),
      115      db_parse_arg ext entry (char (132) aligned, fixed bin, fixed bin, ptr, fixed bin, fixed bin),
      116      stu_$get_location ext entry (ptr, fixed bin, fixed bin (18));
      117 
      118 dcl  is_condition_frame_ entry (ptr) returns (bit (1) aligned);
      119 
      120 dcl  db_find_mc entry (ptr, bit (1) aligned, ptr);
      121 
      122 dcl  find_condition_info_ entry (ptr, ptr, fixed bin);
      123 
      124 dcl  stu_$get_runtime_location entry (ptr, fixed bin) returns (fixed bin (18));
      125 
      126 dcl  db_parse_arg$ptr_offset entry (char (132) aligned, fixed bin, fixed bin, fixed bin,
      127      ptr, fixed bin, fixed bin);
      128 
      129 
      130 
      131 dcl  error_table_$segknown ext fixed bin;
      132 
      133 
      134 dcl  code35 fixed bin (35);
      135 dcl  fboff fixed bin (9),
      136      code fixed bin,
      137      d_type fixed bin,
      138      itemp fixed bin,
      139     (max_stack, new_type, line_number) fixed bin,
      140     (pc, i, j) fixed bin,
      141      temp1 fixed bin (18),
      142     (ct, nv) fixed bin,
      143     (lin, ill) fixed bin,
      144     (size, scale, ndims) fixed bin,
      145      exec fixed bin;
      146 dcl  offset_incr fixed bin;				/* increment to be added to offset and working pointer */
      147 
      148 dcl  dol fixed bin;
      149 dcl  max_size fixed bin;
      150 
      151 dcl  based_bit72 bit (72) based;
      152 
      153 dcl  based_fix fixed bin based aligned;
      154 
      155 
      156 dcl  arglist (21) ptr,
      157      based_ptr ptr based (sp),
      158      ptr_array (1) based ptr,
      159     (pp, ilp, tp, tpp) ptr;
      160 
      161 
      162 
      163 
      164 dcl  switch bit (1) aligned;
      165 
      166 
      167 dcl  new_line char (1) aligned static init ("
      168 "),
      169 
      170      il char (132) aligned,
      171      reg_name char (4) aligned,
      172      str char (exec) based aligned,
      173      str1 char (ill) based aligned,
      174      sym_name char (72) var,
      175     (c1, c2) char (1) aligned,
      176      dir_name char (168) aligned,
      177      pathname char (168),
      178     (ent_name, ref_name) char (32) aligned,
      179      cmc char (1) aligned;
      180 dcl  char char (1) aligned;				/* character being used for parse */
      181 
      182 dcl (attach,					/* 1 = switch_name attached */
      183      open) bit (1) unaligned;				/* 1 = switch_name opened */
      184 dcl  dec_default bit (1);				/* 1 = use dec_default for temporaries (%) */
      185 dcl  switch_name char (32);				/* switch_name for ".si" request */
      186 
      187 dcl  entry_name char (32) aligned;
      188 
      189 
      190 dcl  desc_area (11) bit (36) internal static
      191      init ((11) (1) "100000100000000000000000000000000001"b);
      192 
      193 dcl  desc_ptr ptr init (addr (desc_area));
      194 
      195 dcl 1 desc (11) aligned based (desc_ptr),
      196    (2 flag bit (1),
      197     2 type bit (6),
      198     2 packed bit (1),
      199     2 n_dims bit (4),
      200     2 size fixed bin (23)) unaligned;
      201 
      202 dcl  dummy_desc bit (36) aligned static init
      203     ("101010100000000000000000000000100000"b);		/* char(32) */
      204 
      205 dcl  return_desc bit (36) aligned static init
      206     ("100000100000000000000000000000000001"b);		/* fixed bin, 1 word */
      207 
      208 
      209 
      210 dcl (addr, addrel, baseno, baseptr, bit, max, null, ptr, rel, substr, index, search, verify) builtin;
      211 dcl (binary, divide, hbound, length, min, reverse) builtin;
      212 
      213 
      214 dcl 1 ff aligned based,
      215     2 (w0, w1) fixed bin;
      216 
      217 
      218 dcl 1 bi aligned based,
      219     2 ts (132) fixed bin (8) unaligned;			/* character codes used as subscripts to type array */
      220 
      221 
      222 dcl 1 lot (0: 1023) aligned based,
      223     2 segno bit (18) unaligned,
      224     2 offset bit (18) unaligned;
      225 
      226 /* constants */
      227 
      228 dcl  NUMBER char (11) int static init ("0123456789&");
      229 dcl  MODES (21) char (6) var int static init (
      230      "a",
      231      "b",
      232      "p",
      233      "P",
      234      "i",
      235      "I",
      236      "l",
      237      "s",
      238      "o",
      239      "h",
      240      "d",
      241      "el",
      242      "fl",
      243      "f",
      244      "e",
      245      "g",
      246      "x",
      247      "comp-5",
      248      "comp-6",
      249      "comp-7",
      250      "comp-8");
      251 
      252 dcl 1 cond_info aligned,
  1     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  1     2*	   coded by M. Weaver 12 July 1973 */
  1     3 
  1     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  1     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  1     6 	  2 condition_name char(32) var,		/* name of condition */
  1     7 	  2 infoptr ptr,				/* ptr to software info structure */
  1     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  1     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  1    10 	  2 flags aligned,
  1    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  1    12 	    3 pad1 bit(35) unal,
  1    13 	  2 pad_word bit(36) aligned,
  1    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  1    15 	  2 pad (4) bit(36) aligned;
  1    16 
  1    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      253 
  2     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  2     2*   *
  2     3*   *	This include file is used to reference the common data  that is passed from the
  2     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  2     5*   *
  2     6*   *	modified 7/75 by S.E. Barr for the break instructions
  2     7**/
  2     8 
  2     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  2    10 
  2    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  2    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  2    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  2    14*						   it was entered via a fault.  It will go to debug in
  2    15*						   another frame.  */
  2    16 
  2    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  2    18*						   1 = input switch iocb ptr
  2    19*						   2 = output switch iocb ptr      */
  2    20     2 flags aligned,
  2    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  2    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  2    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  2    24*						   condition on;  1 = use the debug condition handler */
  2    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  2    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  2    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  2    28 
  2    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
      254 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      255 
      256 /*  */
  4     1 /*	BEGIN INCLUDE FILE  ...  db_common_auto.incl.pl1
  4     2**
  4     3**	Written  Dec 72  for the  6180  by  Bill Silver.
  4     4**	Modified Dec 73 to add dummy_arg array by RObert S. Coren.
  4     5**
  4     6**	This include file is used to reference the common data that is passed from the
  4     7**	main debug procedure  "debug"  to other debug procedures.  This data is kept in
  4     8**	"debug's"  automatic storage.
  4     9**/
  4    10 
  4    11 
  4    12 
  4    13 dcl	com_auto_ptr	ptr;	/* The default pointer to the structure which contains
  4    14*				*  common automatic data.  */
  4    15 
  4    16 
  4    17 
  4    18 /*	The following declaration is an overlay of  data  found in the automatic storage
  4    19**	of the main debug procedure.  This data is re-initialixed each time the  "debug"  procedure
  4    20**	is entered - either called by a user  or  via  a  mme2 fault.
  4    21**/
  4    22 
  4    23 
  4    24 dcl    1	com_auto_data	based( com_auto_ptr )	aligned,
  4    25 
  4    26 
  4    27 	2 db_mc_ptr	ptr,		/* Pointer to the current copy of the machine
  4    28*					*  conditions.  They are found in the stack. */
  4    29 
  4    30 	2 snt_ptr		ptr,		/* Pointer to the area in automatic storage
  4    31*					*  where  "debug"  keeps its segment name table. */
  4    32 
  4    33 	2 max_sp_x	fixed bin,	/* Index of the last entry in the stack pointer
  4    34*					*  array which can be used in a stack trace. */
  4    35 
  4    36 	2 first_call_flag	fixed bin,	/* This flag is used by procedures called by  "debug"
  4    37*					*  to tell if this is the first time they have
  4    38*					*  been called since "debug" was entered.
  4    39*					*  0 => this is the first call out from "debug".
  4    40*					*  1 => procedure returned to db and was called again. */
  4    41 
  4    42 	2 db_action_code	fixed bin,	/* This code tells "debug" what it should do
  4    43*					*  after it is returned to by a parsing procedure.
  4    44*					*  0 => Read next command line - then parse it.
  4    45*					*  1 => Wipe out read ahead and then read the next
  4    46*					*       line  - then parse it.
  4    47*					*  2 => Quit debug, return to command level.
  4    48*					*  3 => Restart the procedure that was interrupted
  4    49*					*       by the mme2 break fault.  */
  4    50 
  4    51 	2 num_skips	fixed bin,	/* Number of times to skip the current break.  */
  4    52 
  4    53 	2 dummy_arg (10)	aligned,		/* Space for "%" arguments */
  4    54 	    3 (p1, p2, p3, p4)  ptr;
  4    55 
  4    56 
  4    57 
  4    58 /*	END OF INCLUDE FILE  ...  db_common_auto.incl.pl1	        */
      257 
      258 /*  */
  5     1 /*	BEGIN INCLUDE FILE  ...  db_common_static.incl.pl1
  5     2**
  5     3**	Written  Dec 72  for the  6180  by  Bill Silver.
  5     4**
  5     5**	This include file is used to reference the common data that is passed from the
  5     6**	main  debug procedure  "debug"  to other debug procedures.  This data is kept
  5     7**	in internal static storage.
  5     8**/
  5     9 
  5    10 
  5    11 
  5    12 dcl	com_stat_ptr	ptr;	/* The default pointer to the common internal static
  5    13*				*  structure.  */
  5    14 
  5    15 
  5    16 
  5    17 /*	The following declaration is an overlay of  data  found in static storage.
  5    18**	It is initialized by "debug" the first time it is called in a process.  A pointer
  5    19**	to this data is found in the external variable  "debug$common_static_ptr".
  5    20**/
  5    21 
  5    22 
  5    23 dcl    1	com_static_data	based ( com_stat_ptr ) 	aligned,
  5    24 
  5    25 
  5    26 	2 lotp		ptr,		/* Pointer to the base of the combined
  5    27*					*  linkage segment.  */
  5    28 
  5    29 	2 hcs_count	fixed bin,	/* Highest hard core segment number. */
  5    30 
  5    31 	2 print_mode	fixed bin,	/* This word is a flag which specifies the
  5    32*					*  volume of information to be printed.
  5    33*					*  0 => SHORT MODE:  Only error messages
  5    34*					*       and essential data will be printed.
  5    35*					*  1 => LONG  MODE: As much information as
  5    36*					*       possible will be printed.  */
  5    37 
  5    38 	2 stack_ptr_array (0:511)	ptr,	/* Pointers to the stack frames which make up
  5    39*					*  the stack history of the process.  */
  5    40 
  5    41 	2 temp_comd_len	fixed bin,	/* Length of temporary global break command line.
  5    42*					*  0 => there is no command line.  */
  5    43 
  5    44 	2 temp_comd_line	char(132),	/* The temporary global break command line.
  5    45*					*  This debug command will be executed each time
  5    46*					*  a break occurs.  It is temporary since it is
  5    47*					*  maintained in static storage and thus goes
  5    48*					*  away when the process terminates.  */
  5    49 
  5    50 	2 temp_break_mode	fixed bin;	/* This is a flag which indicates whether or
  5    51*					*  not we are in temporary break mode.
  5    52*					*  0 => regular break mode.
  5    53*					*  1 => temporary break mode.  */
  5    54 
  5    55 
  5    56 
  5    57 /*	END OF INCLUDE FILE  ...  db_common_static.incl.pl1	        */
      259 
      260 /*  */
  6     1 /*	BEGIN  INCLUDE  FILE ...  db_snt.incl.pl1  Last modified  Nov 1972.  WSS  */
  6     2 /*	Modified 8/75 to add internal static pointer by S.E. Barr */
  6     3 
  6     4 
  6     5 /*	Overlay of  segment name table.  */
  6     6 
  6     7 dcl	sntp	ptr;		/* Pointer to segment name table. */
  6     8 
  6     9 dcl     1	snt	based (sntp)  aligned,
  6    10 	2  ent_pt_name char(32),	/* Entry point name. */
  6    11 	2  ent_name    char(32),	/* Entry name of segment. */
  6    12 	2  dir_name    char(168),	/* Directory name. */
  6    13 	2  pp	     ptr,		/* Pointer to current procedure. */
  6    14 	2  sp          ptr,		/* Pointer to current stack frame. */
  6    15 	2  lp          ptr,		/* Pointer to linkage section. */
  6    16 	2  symp        ptr,		/* Pointer to current symbol table block. */
  6    17 	2  symflag     bit(1) unal,	/* ON => no symbol table defined. */
  6    18 	2  std	     bit(1) unal,	/* ON => standard symbol header.  */
  6    19 	2  headp	     ptr,		/* Pointer to current symbol header. */
  6    20 	2  static_ptr  ptr;		/* Pointer to current static section. */
  6    21 
  6    22 /*	END OF INCLUDE FILE...  db_snt.incl.pl1  */
      261 
      262 /*  */
  7     1 /*     BEGIN INCLUDE FILE ... db_arg_list.incl.pl1 ... last modified Dec. 1972 - WSS  */
  7     2 
  7     3 dcl 	ap		ptr;
  7     4 
  7     5 dcl    1	arg_list		based (ap)	aligned,
  7     6 
  7     7 	2 num_args	fixed bin(16)	unaligned,
  7     8 	2 code		bit (19)		unaligned,
  7     9 
  7    10 	2 num_desc	fixed bin(16)	unaligned,
  7    11 	2 fill		bit (19)		unaligned,
  7    12 
  7    13 	2 args (25)	ptr		aligned;
  7    14 
  7    15 /*    END INCLUDE FILE ... db_arg_list.incl.pl1 */
      263 
      264 /*  */
  8     1 /* BEGIN INCLUDE FILE its.incl.pl1
  8     2*   modified 27 July 79 by JRDavis to add its_unsigned
  8     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  8     4 
  8     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  8     6     2 pad1 bit (3) unaligned,
  8     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  8     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  8     9     2 pad2 bit (9) unaligned,
  8    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  8    11 
  8    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  8    13     2 pad3 bit (3) unaligned,
  8    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  8    15     2 pad4 bit (3) unaligned,
  8    16     2 mod bit (6) unaligned;				/* further modification */
  8    17 
  8    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  8    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  8    20     2 pad1 bit (27) unaligned,
  8    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  8    22 
  8    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  8    24     2 pad2 bit (3) unaligned,
  8    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  8    26     2 pad3 bit (3) unaligned,
  8    27     2 mod bit (6) unaligned;				/* further modification */
  8    28 
  8    29 
  8    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  8    31     2 pad1 bit (3) unaligned,
  8    32     2 segno fixed bin (15) unsigned unaligned,
  8    33     2 ringno fixed bin (3) unsigned unaligned,
  8    34     2 pad2 bit (9) unaligned,
  8    35     2 its_mod bit (6) unaligned,
  8    36 
  8    37     2 offset fixed bin (18) unsigned unaligned,
  8    38     2 pad3 bit (3) unaligned,
  8    39     2 bit_offset fixed bin (6) unsigned unaligned,
  8    40     2 pad4 bit (3) unaligned,
  8    41     2 mod bit (6) unaligned;
  8    42 
  8    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  8    44     2 pr_no fixed bin (3) unsigned unaligned,
  8    45     2 pad1 bit (27) unaligned,
  8    46     2 itp_mod bit (6) unaligned,
  8    47 
  8    48     2 offset fixed bin (18) unsigned unaligned,
  8    49     2 pad2 bit (3) unaligned,
  8    50     2 bit_offset fixed bin (6) unsigned unaligned,
  8    51     2 pad3 bit (3) unaligned,
  8    52     2 mod bit (6) unaligned;
  8    53 
  8    54 
  8    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  8    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  8    57 
  8    58 /* END INCLUDE FILE   its.incl.pl1 */
      265 
      266 /*  */
  9     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  9     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  9     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  9     4 /*	Modified April 1983 by C. Hornig for tasking */
  9     5 
  9     6 /****^  HISTORY COMMENTS:
  9     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  9     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  9     9*     added the heap_header_ptr definition.
  9    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  9    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  9    12*     Modified to support control point management.  These changes were actually
  9    13*     made in February 1985 by G. Palter.
  9    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  9    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  9    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  9    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  9    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  9    19*     (ITS pair).
  9    20*                                                   END HISTORY COMMENTS */
  9    21 
  9    22 /* format: style2 */
  9    23 
  9    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  9    25 
  9    26      dcl	   1 stack_header	      based (sb) aligned,
  9    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  9    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  9    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  9    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  9    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  9    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  9    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  9    34 	     2 pad4	      bit (2) unal,
  9    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  9    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  9    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  9    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  9    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  9    40 	     2 null_ptr	      ptr,		/*  (16)  */
  9    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  9    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  9    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  9    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  9    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  9    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  9    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  9    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  9    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  9    50 	     2 return_no_pop_op_ptr
  9    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  9    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  9    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  9    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  9    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  9    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  9    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  9    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  9    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  9    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  9    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  9    62 	     2 trace,
  9    63 	       3 frames,
  9    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  9    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  9    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  9    67 	     2 pad2	      bit (36),		/*  (61) */
  9    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  9    69 
  9    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  9    71 
  9    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  9    73 						/* (551) octal */
  9    74 
  9    75 
  9    76 /*	The following constants are offsets within this transfer vector table.  */
  9    77 
  9    78      dcl	   (
  9    79 	   call_offset	      fixed bin init (271),
  9    80 	   push_offset	      fixed bin init (272),
  9    81 	   return_offset	      fixed bin init (273),
  9    82 	   return_no_pop_offset   fixed bin init (274),
  9    83 	   entry_offset	      fixed bin init (275)
  9    84 	   )		      internal static;
  9    85 
  9    86 
  9    87 
  9    88 
  9    89 
  9    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  9    91*	move the whole stack header should use this overlay.
  9    92**/
  9    93 
  9    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  9    95 
  9    96 
  9    97 
  9    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      267 
 10     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 10     2 
 10     3 /* format: off */
 10     4 
 10     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 10     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 10     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 10     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 10     9 
 10    10 
 10    11 /****^  HISTORY COMMENTS:
 10    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 10    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 10    14*     Modified to add constants for the translator_id field in the stack_frame
 10    15*     structure.
 10    16*                                                   END HISTORY COMMENTS */
 10    17 
 10    18 
 10    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 10    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 10    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 10    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 10    23 
 10    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 10    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 10    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 10    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 10    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 10    29 
 10    30 
 10    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 10    32 
 10    33 dcl  stack_frame_min_length fixed bin static init(48);
 10    34 
 10    35 
 10    36 dcl 1 stack_frame based(sp) aligned,
 10    37     2 pointer_registers(0 : 7) ptr,
 10    38     2 prev_sp pointer,
 10    39     2 next_sp pointer,
 10    40     2 return_ptr pointer,
 10    41     2 entry_ptr pointer,
 10    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 10    43     2 arg_ptr pointer,
 10    44     2 static_ptr ptr unaligned,
 10    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 10    46     2 on_unit_relp1 bit(18) unaligned,
 10    47     2 on_unit_relp2 bit(18) unaligned,
 10    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 10    49*						   0 => PL/I version II
 10    50*						   1 => ALM
 10    51*						   2 => PL/I version I   
 10    52*						   3 => signal caller frame
 10    53*						   4 => signaller frame */
 10    54     2 operator_return_offset bit(18) unaligned,
 10    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 10    56     2 a bit(36),					/* accumulator */
 10    57     2 q bit(36),					/* q-register */
 10    58     2 e bit(36),					/* exponent */
 10    59     2 timer bit(27) unaligned,				/* timer */
 10    60     2 pad bit(6) unaligned,
 10    61     2 ring_alarm_reg bit(3) unaligned;
 10    62 
 10    63 
 10    64 dcl 1 stack_frame_flags based(sp) aligned,
 10    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 10    66     2 xx0 bit(22) unal,
 10    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 10    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 10    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 10    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 10    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 10    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 10    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 10    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 10    75     2 xx0a bit(6) unal,
 10    76     2 xx1 fixed bin,
 10    77     2 xx2 fixed bin,
 10    78     2 xx3 bit(25) unal,
 10    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 10    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 10    81     2 xx3a bit(9) unaligned,
 10    82     2 xx4(9) bit(72) aligned,
 10    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 10    84*						*  operator puts a pointer to the base of
 10    85*						*  the calling procedure here. (text base ptr)  */
 10    86     2 xx5 bit(72) aligned,
 10    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 10    88 
 10    89 /* format: on */
 10    90 
 10    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      268 
      269 /*
      270*   
      271*   use of big label arrays
      272*
      273*   label_1		label_2		label_3
      274*
      275*   0		syntax_error	syntax_error	syntax_error
      276*   1 (:)		colon0		colon		colon
      277*   2 (%)		per_cent		syntax_error	syntax_error
      278*   3 (/)		namel		syntax_error	syntax_error
      279*   4 ($)		reg		relative_offset	syntax_error
      280*   5 (n)		offset1		relative_offset	syntax_error
      281*   6 (+ -)	relative_offset	relative_offset	syntax_error
      282*   7 (,)		set_mode		set_mode		set_mode
      283*   8 (=)		assign		assign		assign
      284*   9 (<)		set		set		set
      285*   10 (>)		go		go		go
      286*   11 ( )		----		----		----
      287*   12 (;)		rskip		print		print
      288*   13 (&)		amper		amper		syntax_error
      289*   l4 (letter)	offsetl		offsetl		syntax_error
      290*   15 (nl)	print		print		print
      291*   16 (*)		star		star		syntax_error
      292*   17 (.)		com		syntax_error	syntax_error
      293*   */
      294 /*  */
      295 /*	Initialize data needed to parse the command line.	  */
      296 
      297 
      298      com_auto_ptr = arg_auto_ptr;
      299 
      300 	com_stat_ptr = arg_stat_ptr;
      301 
      302 
      303 	lin = 1;
      304 	ill = input_line_len;
      305 	ilp = addr (il);
      306 	ilp -> str1 = input_buffer_ptr -> str1;
      307 
      308 	if first_call_flag = 0
      309 
      310 	then do;
      311 	     data_ptr = stack_ptr_array (max_sp_x);
      312 	     offset = 0;
      313 	     stack_depth = max_sp_x;
      314 	     data_id = "s";
      315 	     data_format = "h";
      316 	     input_type = "";
      317 	     first_call_flag = 1;
      318 	end;
      319 
      320 	sntp = snt_ptr;
      321 	max_stack = max_sp_x;
      322 	sb = ptr (stack_ptr_array (max_stack), 0);
      323 
      324 
      325 depth_1:
      326 
      327 	if get_char (lin, lin, char) then do;
      328 	     d_type = 0;
      329 	     pc = 1;				/* default is print one item */
      330 	     go to label_1 (type (ilp -> bi.ts (lin)));
      331 	end;
      332 	else goto print;
      333 
      334 /* come here (depth 2) when the procedure name has been established
      335*   and associated defaults set up */
      336 
      337 depth_2:
      338 	if get_char (lin, lin, char) then do;		/* PL1 bug 1497 */
      339 	     goto label_2 (type (ilp -> bi.ts (lin)));
      340 	end;
      341 	else goto print;
      342 
      343 /* come here after the following have been set up
      344*   data_ptr
      345*   offset
      346*   output mode
      347*
      348*   must either print out a value (or values), set a break, restart execution,
      349*   or assign a value (or values) */
      350 
      351 depth_4:
      352 	if get_char (lin, lin, char) then do;		/* PL1 bug 1497 */
      353 	     goto label_3 (type (ilp -> bi.ts (lin)));
      354 	end;
      355 	else goto print;
      356 						/*  */
      357 						/* come here if we are at start of a symbolic name */
      358 
      359 label_1 (14):
      360 label_2 (14):
      361 offsetl:
      362 	nv = 0;					/* initialize depth count */
      363 	do i = lin to ill;				/* scan over variable name */
      364 	     cmc = substr (il, i, 1);			/* pick up current character */
      365 	     j = type (ilp -> bi.ts (i));		/* get type of current character */
      366 	     if j = 4 | j = 5 | j = 14 | j = 11 | cmc = "." then go to endl;
      367 	     if cmc = "(" then nv = nv + 1;
      368 	     else if cmc = ")" then do;
      369 		if nv > 0 then nv = nv - 1;
      370 	     end;
      371 	     else if cmc = "-" then do;
      372 		if substr (il, i+1, 1) = ">" then i = i+1; /* scan over arrow */
      373 		else if nv = 0 then go to donel;	/* done if not in parens */
      374 	     end;
      375 	     else if nv = 0 then go to donel;
      376 endl:	end;
      377 donel:
      378 	sym_name = substr (il, lin, i-lin);
      379 	lin = i;
      380 	new_type = 0;
      381 	call db_sym (sym_name, sntp, data_ptr, offset, d_type, data_id, data_format, pc, max_size, code);
      382 	if data_format ^= "a" & data_format ^= "b" then pc = 1;
      383 	if code = 0 then do;			/* continue if no error */
      384 	     input_type = "v";
      385 	     goto relative_offset;
      386 	end;
      387 	if code > 100 then do;
      388 	     i = code - 100;			/* a parameter */
      389 	     cmc = "?";
      390 	     go to list_arg;
      391 	end;
      392 	call sym_err;				/* print message and goto rskip */
      393 
      394 /*  */
      395 /* come here when a colon is encountered in the scan */
      396 
      397 label_1 (1):
      398 	ct = 0;					/* no return value */
      399 	go to colon_join;
      400 label_2 (1):
      401 label_3 (1):
      402 	ct = 1;					/* return value requested */
      403 colon_join:
      404 	if substr (il, lin+1, 1) ^= "=" then go to syntax_error; /* check for following = */
      405 	if ^get_char (lin + 2, lin, "") then goto syntax_error;
      406 	do i = lin to ill while (is_name (ilp -> bi.ts (i))); /* skip to end of procedure name */
      407 	end;
      408 	ent_name = substr (il, lin, i-lin);		/* pick up segment procedure name */
      409 	if substr (il, i, 1) = "$" then do;		/* secondary entry point given */
      410 	     do lin = i+1 to ill while (is_name (ilp -> bi.ts (lin))); /* skip to end of entry name */
      411 	     end;
      412 	     ref_name = substr (il, i+1, lin-1-i);	/* copy entry point name */
      413 	     end; else do;				/* if no entry point name, use same */
      414 	     ref_name = ent_name;
      415 	     lin = i;
      416 	end;
      417 	call hcs_$make_ptr (null, ent_name, ref_name, tp, code); /* get pointer to the entry */
      418 	if code ^= 0 | tp = null then do;
      419 	     call ioa_$rsnnl ("^a$^a", ent_name, i, ent_name, ref_name);
      420 	     call com_err_ (code, "debug", ent_name);
      421 	     go to rskip;
      422 	end;
      423 
      424 	if ^get_char (lin, lin, "") then goto make_call;
      425 	i = 0;
      426 	if substr (il, lin, 1) ^= "(" then go to make_call; /* check for no args */
      427 	lin = lin + 1;
      428 argl:	i = i + 1;				/* go to next arg */
      429 	if ct + i > 11 then do;			/* watch for too many args */
      430 	     call ioa_$ioa_stream (debug_output, "Too many arguments.");
      431 	     go to rskip;
      432 	end;
      433 
      434 	call db_parse_arg (il, lin, ill, addr (dummy_arg (i)), j, exec); /* pick up the next arg */
      435 	if substr (il, lin, 1) = "," then lin = lin + 1;	/* skip over "," */
      436 	arglist (i+1) = addr (dummy_arg (i));		/* set up default arglist pointer */
      437 	if j = 0 then do;				/* a variable as the argument */
      438 	     sym_name = addr (dummy_arg (i)) -> str;	/* get returned symbol name */
      439 	     call db_sym (sym_name, sntp, pp, temp1, j, c1, c2, pc, max_size, code);
      440 	     if code = 0 then do;			/* no error, variable */
      441 		arglist (i+1) = pp ;		/* stuff pointer to var in arglist */
      442 		exec = pc;
      443 		go to make_desc;
      444 	     end;
      445 	     if code > 100 then arglist (i+1) = snt.sp -> stack_frame.arg_ptr -> ptr_array (code - 99);
      446 	     else call sym_err;
      447 	end;
      448 	if j > 0 then do;
      449 make_desc:     desc (i).type = bit (binary (j, 6), 6);
      450 	     desc (i).size = binary (exec, 23);
      451 	     arglist (i + 11) = addr (desc (i));
      452 	end;
      453 	else if j = -1 then do;			/* no arg, all done */
      454 	     do j = 1 to i-1;			/* loop through all arguments */
      455 		arglist (j+i+ct) = arglist (11+j);	/* move descriptor pointers down */
      456 	     end;
      457 make_call:     addr (arglist) -> arg_list.num_args = binary (i+ct-1, 17);
      458 	     addr (arglist) -> arg_list.num_desc = binary (i+ct-1, 17);
      459 	     if ct ^= 0 then do;
      460 		arglist (i + 1) = data_ptr;
      461 		arglist (2*i + 1) = addr (return_desc);
      462 	     end;
      463 	     addr (arglist) -> arg_list.code = (16) "0"b || "100"b;
      464 	     addr (arglist) -> arg_list.fill = "0"b;
      465 
      466 	     in_debug = "0"b;			/* pass all conditions on */
      467 	     call cu_$gen_call (tp, addr (arglist));	/* call the specified procedure */
      468 	     in_debug = "1"b;			/* turn handler on */
      469 	     go to skip;
      470 	end;
      471 	else if j = -2 then do;			/* syntax error */
      472 	     call ioa_$ioa_stream (debug_output, "Syntax error in argument ^d.", i);
      473 	     go to rskip;
      474 	end;
      475 	else if j = -3 then arglist (i+11) = addr (dummy_desc); /* "%" in arg position */
      476 	else call ioa_$ioa_stream (debug_output, "??");
      477 	go to argl;
      478 
      479 /*  */
      480 /* come here to print out dummy args */
      481 
      482 label_1 (2):
      483 	input_type = "%";
      484 	nv = db_get_count$dec (il, lin+1, lin);		/* get correct dummy arg */
      485 	if nv < 1 | nv > 10 then go to syntax_error;	/* make sure it's valid */
      486 	data_ptr = addr (dummy_arg (nv));		/* set data ptr to point to the dummy arg */
      487 	data_format = "h";				/* set print default to octal */
      488 	go to star1;				/* merge with indirect code */
      489 
      490 
      491 /*  */
      492 /* come here if we are at start of a stack procedure name */
      493 
      494 label_1 (3):
      495 namel:
      496 	do i = lin+1 to ill while (substr (il, i, 1) ^= "/");
      497 	end;
      498 	if i = ill+1 then go to syntax_error;
      499 	nv = cv_oct_check_ (substr (il, lin+1, i-lin-1), code);
      500 	if code = 0 then do;
      501 	     if nv < hcs_count then do;		/* check for hardcore segment number */
      502 		call ioa_$ioa_stream (debug_output, "Hardcore segment number.");
      503 		go to rskip;
      504 	     end;
      505 	     pp = baseptr (nv);
      506 	     call hcs_$fs_get_path_name (pp, dir_name, itemp, ent_name, code);
      507 	     if code ^= 0 then do;			/* signaller if trouble */
      508 		ent_name = "signaller";
      509 		dir_name = "signaller_directory";
      510 	     end;
      511 	     pathname, entry_name = ent_name;		/* if given number use primary name */
      512 	end;
      513 	else do;
      514 	     pathname = substr (il, lin+1, i-lin-1);
      515 
      516 /* find out if it's of form seg$entry */
      517 
      518 	     dol = index (pathname, "$");
      519 	     if dol > 0 then do;			/* it is */
      520 		entry_name = substr (pathname, dol + 1);
      521 		pathname = substr (pathname, 1, dol - 1);
      522 	     end;
      523 	     else entry_name = pathname;
      524 
      525 	     j = index (reverse (entry_name), ">");
      526 	     if j > 0 then entry_name = substr (entry_name, 32 -j);
      527 
      528 	     if substr (pathname, 1, 2) = "&n" then do;
      529 		pathname = substr (pathname, 3);
      530 		lin = lin + 2;
      531 	     end;
      532 	     call expand_path_ (addr (pathname), i-lin-1, addr (dir_name), addr (ent_name), code);
      533 	     if code ^= 0 then do;
      534 com1:		call com_err_ (code, "debug", pathname);
      535 		go to rskip;
      536 	     end;
      537 	     call hcs_$fs_get_seg_ptr (pathname, pp, code); /* is segment already known ? */
      538 	     if pp ^= null then do;			/* yes, get real names for the segment */
      539 		call hcs_$fs_get_path_name (pp, dir_name, itemp, ent_name, code);
      540 		go to check1;
      541 	     end;
      542 	     call hcs_$initiate (dir_name, ent_name, "", 0, 0, pp, code); /* no, initiate it */
      543 	     if code ^= 0 then if code ^= error_table_$segknown then go to com1;
      544 	end;
      545 check1:
      546 	lin = i+1;
      547 	do i = max_stack to 0 by -1;			/* search the stack for the procedure pointer */
      548 	     sp = stack_ptr_array (i);		/* get current stack pointer */
      549 	     call db_fill_snt$proc_ptr (sp, tpp);
      550 	     if tpp ^= null ()
      551 	     then if baseno (pp) = baseno (tpp) then do;	/* we've found a good segment */
      552 		     stack_depth = i;		/* set index into stack */
      553 		     call db_fill_snt (sp, sntp);	/* Get data about working segment. */
      554 		     if snt.ent_pt_name = entry_name then do; /* make sure it's really right frame */
      555 			data_ptr = sp;		/* set defaults */
      556 			data_id = "s";
      557 found3:			offset = 0;
      558 			data_format = "h";
      559 
      560 			input_type = "a";
      561 			go to depth_2;
      562 		     end;
      563 		end;
      564 	end;
      565 
      566 	snt.symp = null;
      567 	snt.symflag = "1"b;				/* set flag saying we haven't got symp yet */
      568 	snt.pp = pp;
      569 	snt.sp = null;
      570 	snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (pp))).segno), stack_header.lot_ptr -> lot (binary (baseno (pp))).offset);
      571 	snt.ent_name = ent_name;
      572 	snt.dir_name = dir_name;
      573 	snt.ent_pt_name = entry_name;			/* use reference name for symbol table */
      574 	data_ptr = pp;
      575 	stack_depth = -1;				/* stack depth is undefined */
      576 	data_id = "t";
      577 	go to found3;
      578 						/*  */
      579 
      580 /* come here when a star is encountered */
      581 
      582 label_1 (16):
      583 label_2 (16):
      584 	lin = lin+1;
      585 	if data_ptr -> its.its_mod ^= "100011"b then do;
      586 	     call ioa_$ioa_stream (debug_output, "Cannot indirect through ^w ^w.", data_ptr -> ff.w0, data_ptr -> ff.w1);
      587 	     go to rskip;
      588 	end;
      589 	data_ptr = data_ptr -> based_ptr;		/* indirect once through ptr */
      590 	input_type = "*";
      591 star1:	offset = binary (rel (data_ptr), 17);		/* set up offset variable */
      592 	snt.symp = null;				/* fill in snt structure */
      593 	snt.symflag = "1"b;
      594 	snt.pp = ptr (data_ptr, 0);
      595 	snt.sp = null;
      596 	snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (data_ptr))).segno), stack_header.lot_ptr -> lot (binary (baseno (data_ptr))).offset);
      597 	call hcs_$fs_get_path_name (data_ptr, snt.dir_name, itemp, snt.ent_name, code);
      598 	snt.ent_pt_name = snt.ent_name;
      599 	stack_depth = -1;
      600 	data_id = "t";
      601 	go to relative_offset;
      602 
      603 /* come here if a syntax error is encountered while scanning the command line */
      604 
      605 label_1 (0): label_2 (0): label_3 (0): go to syntax_error;
      606 label_2 (2): label_3 (2): go to syntax_error;
      607 label_2 (3): label_3 (3): go to syntax_error;
      608 label_3 (16):
      609 label_2 (17): label_3 (17):
      610 label_3 (4):
      611 label_3 (14):
      612 label_3 (5): label_3 (6):
      613 label_3 (13):
      614 syntax_error: call ioa_$ioa_stream (debug_output, "Syntax error");
      615 
      616 
      617 label_1 (12):
      618 rskip:
      619 	db_action_code = 1;
      620 	return;
      621 
      622 skip:	i = index (substr (il, lin, ill-lin+1), ";");
      623 	if i > 0 then do;
      624 	     lin = lin + i;
      625 	     if lin < ill then go to depth_1;
      626 	end;
      627 	lin = ill;
      628 	return;
      629 
      630 
      631 /*  */
      632 /*  come here on "."   */
      633 
      634 
      635 label_1 (17):
      636 	if lin + 1 >= ill then go to no_comm;
      637 	cmc = substr (il, lin+1, 1);
      638 	if verify (cmc, "0123456789") = 0 then do;	/* no command name, set stack frame */
      639 	     stack_depth = db_get_count$dec (il, lin+1, lin); /* pick up desired stack depth */
      640 	     i = stack_depth;			/* in case error, set frame to 0 */
      641 	     go to set_stack;
      642 	end;
      643 	nv = type (ilp -> bi.ts (lin+2));		/* get type of character after command */
      644 	if cmc = "t" then call stack_trace;
      645 	else if cmc = "+" | cmc = "-" then do;		/* pop or push stack */
      646 	     i = db_get_count$dec (il, lin+1, lin);
      647 	     stack_depth = stack_depth + i;
      648 set_stack:     if stack_depth < 0 | stack_depth > max_stack then do;
      649 		call ioa_$ioa_stream (debug_output, "^d not in stack range.", stack_depth);
      650 		stack_depth = stack_depth - i;
      651 		go to rskip;
      652 	     end;
      653 	     call db_fill_snt (stack_ptr_array (stack_depth), sntp); /* get data for this new frame */
      654 	     if snt.pp = null () then call ioa_$ioa_stream (debug_output, "Cannot get text section for stack frame.");
      655 	     data_ptr = snt.sp;
      656 	     data_id = "s";
      657 	     data_format = "h";
      658 	     offset = 0;
      659 	end;
      660 	else if cmc = "|" | cmc = "." then do;
      661 	     substr (il, 1, lin+1) = " ";
      662 
      663 	     in_debug = "0"b;			/* pass all conditions on */
      664 	     call cu_$cp (ilp, ill, i);
      665 	     in_debug = "1"b;
      666 	     return;
      667 	end;
      668 	else if cmc = "d" then do;
      669 	     fboff = binary (addr (data_ptr) -> its.bit_offset, 9);
      670 	     call ioa_$ioa_stream (debug_output, "^d  /^a/^o(^d)&^a,^a  ^o", stack_depth, snt.ent_name, offset, fboff, data_id, data_format,
      671 		binary (baseno (snt.pp), 18));
      672 	end;
      673 	else if cmc = "D" then do;
      674 	     fboff = binary (addr (data_ptr) -> its.bit_offset, 9);
      675 	     call ioa_$ioa_stream (debug_output, "^d  /^a>^a/^o(^d)&^a,^a  ^o", stack_depth, snt.dir_name, snt.ent_name, offset, fboff,
      676 		data_id, data_format, binary (baseno (snt.pp), 18));
      677 	end;
      678 	else if cmc = "m" then do;			/* output mode */
      679 	     if substr (il, lin+2, 1) = "b" then print_mode = 0;
      680 	     else if substr (il, lin+2, 1) = "l" then print_mode = 1;
      681 	     else go to syntax_error;
      682 	end;
      683 
      684 	else if cmc = "c" then do;
      685 	     cmc = substr (il, lin+2, 1);		/* get next character */
      686 	     if cmc = "t" then do;			/* into temporary break mode */
      687 		lin = lin + 1;
      688 		temp_break_mode = 1;
      689 	     end;
      690 	     else if cmc = "r" then do;		/* regular break mode */
      691 		lin = lin + 1;
      692 		temp_break_mode = 0;
      693 	     end;
      694 	     if substr (il, lin+2, 1) = "," then num_skips = db_get_count$dec (il, lin+3, lin) + 1;
      695 	     else num_skips = 1;			/* num_skips is times to skip the break */
      696 
      697 	     db_action_code = 3;
      698 	     return;
      699 	end;
      700 	else if cmc = "q" then do;
      701 	     db_action_code = 2;
      702 	     return;
      703 	end;
      704 	else if cmc = "b" then do;			/* some type of break command */
      705 	     i = lin + 2;
      706 	     cmc = substr (il, i, 1);			/* get the particular break command name */
      707 	     if cmc = "g" then do;			/* global break request */
      708 		cmc = substr (il, i+1, 1);		/* get the command char */
      709 		if cmc = "t" then do;		/* .bge  set up global exec line */
      710 		     i = i + 2;			/* get index of first character of exec line */
      711 		     temp_comd_len = ill-i+1;
      712 		     if temp_comd_len = 1 then temp_comd_len = 0;
      713 		     else temp_comd_line = substr (il, i, temp_comd_len); /* copy string to execute into static */
      714 		     return;			/* read next request line */
      715 		end;
      716 		lin = i + 2;			/* point past request type */
      717 		call get_break_action_code;
      718 		if break_action_code = 0
      719 		then goto skip;
      720 		else call db_break$global (break_action_code, break_data_len, break_data_line, print_mode);
      721 		if break_return = 1 then lin = ill;
      722 		goto skip;
      723 	     end;
      724 	     if cmc = "d" then do;			/* change default break segment */
      725 		if ^get_char (i+1, lin, char) then do;
      726 		     call db_break$print_default;
      727 		     go to skip;
      728 		end;
      729 		pathname = substr (il, lin, ill-lin);	/* get name of segment */
      730 		nv = cv_oct_check_ (pathname, code);	/* see if number was given */
      731 		if code = 0 then do;
      732 		     tp = baseptr (nv);		/* get pointer to break seg */
      733 		end;
      734 		else do;
      735 		     if substr (pathname, 1, 2) = "&n" then do;
      736 			pathname = substr (pathname, 3);
      737 			lin = lin + 2;
      738 		     end;
      739 
      740 		     call expand_path_ (addr (pathname), ill-lin, addr (dir_name), addr (ent_name), code);
      741 		     call hcs_$fs_get_seg_ptr (pathname, tp, code);
      742 		     if tp ^= null then go to got_seg;	/* if refence name is known */
      743 		     call hcs_$initiate (dir_name, ent_name, "", 0, 0, tp, code);
      744 		     if tp = null then go to com1;
      745 		end;
      746 got_seg:		call db_break$set_default (tp);	/* set up default seg */
      747 		return;
      748 	     end;
      749 	     if cmc = "p" then do;			/* print break segs */
      750 		call db_break$print_bseg (print_mode);
      751 		go to skip;
      752 	     end;
      753 	     if ^get_char (i + 1, i, "") then do;
      754 		lin = i;
      755 		call get_break_action_code;
      756 		if break_action_code > 0 then do;
      757 		     call db_break$sub_global (break_action_code, break_data_len, break_data_line, print_mode);
      758 		     if break_return > 0 then lin = ill;
      759 		end;
      760 
      761 		goto skip;
      762 	     end;
      763 	     nv = db_get_count$dec (il, i, lin);	/* Get break number. */
      764 	     if nv <= 0 then do;			/* and make sure it's okay */
      765 		call ioa_$ioa_stream (debug_output, "Invalid break number.");
      766 		go to rskip;
      767 	     end;
      768 
      769 	     if cmc = "s" then do;
      770 		i = db_get_count$dec (il, lin+1, lin);
      771 		call db_break$set_skips (nv, i);
      772 		go to skip;
      773 	     end;
      774 	     call get_break_action_code;
      775 	     if break_action_code = 0
      776 	     then goto skip;
      777 	     else call db_break$single (nv, break_action_code, break_data_len, break_data_line, print_mode);
      778 	     if break_return = 1 then lin = ill;
      779 	     goto skip;
      780 	end;
      781 						/*  */
      782 	else if cmc = "a" then do;
      783 	     if snt.sp = null then do;		/* must have stack frame for arglist print out */
      784 nost:		call ioa_$ioa_stream (debug_output, "No argument list available.");
      785 		go to rskip;
      786 	     end;
      787 	     if snt.sp -> stack_frame.prev_sp -> stack_frame_flags.signaller then go to nost;
      788 	     if snt.sp -> stack_frame.arg_ptr = null () then go to nost;
      789 	     if nv = 7 then do;			/* if comma, use mode specified and do all args */
      790 		cmc = substr (il, lin+3, 1);
      791 		i = -1;
      792 	     end;
      793 	     else if nv = 5 | nv = 13 then do;
      794 		i = db_get_count$dec (il, lin+2, lin);
      795 		if substr (il, lin, 1) = "," then cmc = substr (il, lin+1, 1);
      796 		else cmc = "?";
      797 	     end;
      798 	     else if nv = 12 | nv = 15 then do;
      799 		i = -1;
      800 		cmc = "?";
      801 	     end;
      802 list_arg:	     call list_arg_ (i, cmc, snt.sp -> stack_frame.arg_ptr);
      803 	end;
      804 	else if cmc = "f"				/* get pointer to fault conditions */
      805 	then call db_find_mc (snt.sp, "0"b, db_mc_ptr);
      806 
      807 	else if cmc = "C"				/* get pointer to crawlout conditions */
      808 	then call db_find_mc (snt.sp, "1"b, db_mc_ptr);
      809 
      810 
      811 	else if cmc = "s" then do;
      812 	     attach, open = "0"b;
      813 	     if substr (il, lin+2, 1) = "i" then j = 1;
      814 	     else if substr (il, lin+2, 1) = "o" then j = 2;
      815 	     else go to skip;
      816 	     lin = lin + 3;
      817 	     i = verify (substr (il, lin, ill-lin+1), " ");
      818 	     if i > 1 then do;
      819 		lin = lin + i - 1;
      820 
      821 		i = search (substr (il, lin, ill-lin+1), " ;
      822 ");
      823 		if i = 0 then i = ill;
      824 		else i = lin + i -2;
      825 		switch_name = substr (il, lin, i-lin+1);
      826 		call check_switch;
      827 		call iox_$find_iocb (switch_name, pp, code35);
      828 		if code35 ^= 0 then goto switch_err;
      829 		if pp -> iocb.attach_descrip_ptr = null then do;
      830 		     call ioa_$ioa_stream (debug_output, "^a switch not attached", switch_name);
      831 		     goto skip;
      832 		end;
      833 		if pp -> iocb.open_descrip_ptr = null then do;
      834 		     call ioa_$ioa_stream (debug_output, "^a switch not open", switch_name);
      835 		     goto skip;
      836 		end;
      837 	     end;
      838 	     else do;
      839 		if j = 1 then switch_name = "debug_input";
      840 		else switch_name = "debug_output";
      841 		call check_switch;			/* Is this the same switch? */
      842 		call iox_$find_iocb (switch_name, pp, code35);
      843 		if code35 ^= 0 then go to switch_err;
      844 		if pp -> iocb.attach_descrip_ptr = null then do;
      845 		     call iox_$attach_ioname (switch_name, pp, "syn_ user_i/o", code35);
      846 		     if code35 ^= 0 then go to switch_err;
      847 		     attach = "1"b;
      848 		end;
      849 
      850 		if pp -> iocb.open_descrip_ptr = null then do;
      851 		     call iox_$open (pp, j, "0"b, code35);
      852 		     if code35 ^= 0 then go to switch_err;
      853 		     open = "1"b;
      854 		end;
      855 	     end;
      856 
      857 	     if debug_io_open (j) then call iox_$close (debug_io_ptr (j), code35);
      858 	     if debug_io_attach (j) then call iox_$detach_iocb (debug_io_ptr (j), code35);
      859 	     debug_io_ptr (j) = pp;
      860 	     debug_io_attach (j) = attach;
      861 	     debug_io_open (j) = open;
      862 	     if j = 1 then debug_input = switch_name;
      863 	     else debug_output = switch_name;
      864 
      865 	     go to skip;
      866 
      867 switch_err:    call com_err_ (code35, "debug");
      868 	     go to skip;
      869 	end;
      870 
      871 	else
      872 no_comm:	call ioa_$ioa_stream (debug_output, "db");
      873 
      874 	go to skip;
      875 
      876 /*  */
      877 /* come here if we are looking at a register command */
      878 
      879 label_1 (4):
      880 	do i = lin+1 to lin+4 while (is_name (ilp -> bi.ts (i)));
      881 	end;
      882 	reg_name = substr (il, lin+1, i-lin-1);
      883 	do i = lin+1 to ill while (substr (il, i, 1) ^= ";" & substr (il, i, 1) ^= "=");
      884 	end;
      885 	if i >= ill | substr (il, i, 1) ^= "=" then do;
      886 	     if ill = lin + 1 then if substr (il, ill, 1) = new_line then goto syntax_error; /* avoid "$(nl)" */
      887 	     call db_regs$print (db_mc_ptr, reg_name, print_mode);
      888 	     go to skip;
      889 	end;
      890 	if ^get_char (i + 1, i, "") then goto syntax_error;
      891 	temp_reg_val = db_get_count$double (il, i, lin);	/* is an assignment */
      892 	if i = lin then goto syntax_error;
      893 	if substr (il, lin, 1) = "|" then do;		/* pointer value, parse it */
      894 	     call db_parse_arg$ptr_offset (il, lin, ill, binary (temp_reg_val, 17),
      895 		addr (temp_reg_val), d_type, nv);
      896 	     if d_type ^= 13 then go to syntax_error;
      897 	end;
      898 
      899 	reg_val = addr (temp_reg_val) -> based_bit72;
      900 	call db_regs$assign (db_mc_ptr, reg_name, reg_val, print_mode); /* assign a value to the register */
      901 	go to skip;
      902 
      903 /*  */
      904 /* . handlers */
      905 
      906 label_1 (13): label_2 (13):
      907 	cmc = substr (il, lin+1, 1);
      908 	if lin >= ill then go to syntax_error;
      909 	if cmc = "d" | cmc = "o" then go to offset1;
      910 	if cmc = "n" then do;			/* next char escaped */
      911 	     lin = lin+2;
      912 	     go to offsetl;
      913 	end;
      914 	if cmc ^= data_id then new_type = 1; else new_type = 0;
      915 	goto relative_offset;
      916 
      917 
      918 /*  */
      919 /* come here to set a break point */
      920 
      921 label_1 (9): label_2 (9): label_3 (9):
      922 	if data_id = "s" then tp = ptr (snt.pp, binary (rel (data_ptr))-binary (rel (snt.sp)));
      923 	else tp = data_ptr;				/* force pointer to text if in stack */
      924 	call db_break$set_break (tp, 0, sntp, print_mode); /* set the break */
      925 	go to skip;
      926 
      927 /*  */
      928 /* come here when restarting a program */
      929 
      930 label_1 (10): label_2 (10): label_3 (10):
      931 	if stack_depth > max_stack | stack_depth < 0 then call ioa_$ioa_stream (debug_output, "No stack frame for given segment.");
      932 	else do;
      933 	     addr (goto_label) -> label_map.pp = data_ptr;
      934 	     addr (goto_label) -> label_map.sp = snt.sp;
      935 	     goto goto_label;
      936 	end;
      937 	go to rskip;
      938 
      939 
      940 /* come here if scanning a number in a type 1 command */
      941 
      942 label_1 (5):
      943 	input_type = "a";				/* user typed an offset */
      944 offset1:	offset = 0;
      945 	goto relative_offset;
      946 
      947 /*  */
      948 /* come here when 'offset' has been established.  Search for an optional relative offset */
      949 
      950 label_2 (4): label_2 (5):
      951 label_1 (6): label_2 (6):
      952 relative_offset:
      953 
      954 	code = 0;
      955 	continue = "1"b;
      956 	do while (code = 0 & continue);
      957 	     if ^get_char (lin, lin, char) then continue = "0"b;
      958 	     else do;
      959 
      960 		if char = "&" then do;
      961 		     char = substr (il, lin+1, 1);
      962 		     if char = "d" | char = "o" then do;
      963 			offset = offset + db_get_count (il, lin, lin);
      964 			call set_data_ptr (data_id);
      965 		     end;
      966 		     else do;
      967 			if char ^= data_id then new_type = 1;
      968 			else new_type = 0;
      969 			if new_type = 1 then data_format = "h";
      970 			if char = "p" then call parse_parameter (lin, code);
      971 			else if char = "a" then call parse_source (lin, code);
      972 			else if char = "n" then do;
      973 			     lin = lin +2;
      974 			     if lin >= ill then goto syntax_error;
      975 			     goto namel;
      976 			end;
      977 			else do;
      978 			     call set_data_ptr (char);
      979 			     if code = 0 then data_id = char;
      980 			     lin = lin +2;
      981 			end;
      982 		     end;
      983 		end;
      984 
      985 		else do;
      986 		     if char = "+" then offset_incr = db_get_count (il, lin + 1, lin);
      987 		     else if char = "-" then offset_incr = - db_get_count (il, lin + 1, lin);
      988 		     else if verify (char, NUMBER) = 0 then offset_incr = db_get_count (il, lin, lin);
      989 
      990 		     else if char = "$" then do;
      991 			do i = lin+1 to lin+4 while (is_name (ilp -> bi.ts (i)));
      992 			end;
      993 			reg_name = substr (il, lin+1, i-lin-1);
      994 			lin = i;
      995 			call db_regs$get (db_mc_ptr, reg_name, reg_val, print_mode);
      996 			offset_incr = binary (reg_val);
      997 		     end;
      998 
      999 		     else continue = "0"b;		/* must not be a relative offset */
     1000 		     if continue then do;
     1001 			offset = offset + offset_incr;
     1002 			call set_data_ptr (data_id);
     1003 		     end;
     1004 		end;
     1005 	     end;
     1006 	end;
     1007 
     1008 	if code ^= 0 then do;
     1009 	     if code > 0 then call ioa_$ioa_stream (debug_output, "^a for ^a", err_mess (code), snt.ent_name);
     1010 	     goto rskip;
     1011 	end;
     1012 
     1013 	go to depth_4;
     1014 
     1015 
     1016 /* come here if changing output mode :	, [print mode] [amount to print] */
     1017 
     1018 label_1 (7): label_2 (7): label_3 (7):
     1019 
     1020 	call parse_print;
     1021 	goto print;
     1022 
     1023 label_2 (12): label_3 (12):
     1024 label_1 (15): label_2 (15): label_3 (15):
     1025 print:
     1026 	if data_format = "n" then go to skip;
     1027 	pp = data_ptr;
     1028 	if data_id = "s" then nv = binary (rel (pp)) - binary (rel (snt.sp));
     1029 	else if data_id = "l" then nv = binary (rel (pp)) - binary (rel (snt.lp));
     1030 	else if data_id = "i" then nv = binary (rel (pp)) - binary (rel (snt.static_ptr));
     1031 	else nv = binary (rel (pp));
     1032 
     1033 	call db_print (debug_io_ptr (2), debug_output, pp, data_format, nv, pc, sntp, d_type, max_size);
     1034 	go to skip;
     1035 
     1036 /* come here when an equal sign is encountered */
     1037 
     1038 label_1 (8): label_2 (8): label_3 (8):
     1039 	lin = lin + 1;
     1040 	pp = data_ptr;
     1041 
     1042 /*	If the assignment is not to a program variable the default is octal.
     1043*   */
     1044 	if input_type = "v" then dec_default = "1"b;
     1045 	else dec_default = "0"b;
     1046 	call db_assign (il, lin, ill, pp, sntp, db_mc_ptr, d_type, pc, max_size, print_mode, dec_default);
     1047 	go to skip;
     1048 
     1049 
     1050 /*  INTERNAL PROCEDURES */
     1051 is_name:	proc (b9) returns (bit (1) aligned);
     1052 
     1053 dcl  b9 fixed bin (8) unal, t fixed bin;
     1054 
     1055 	     t = type (b9);
     1056 	     if t ^= 14 then if t ^= 5 then return ("0"b);
     1057 	     return ("1"b);
     1058 
     1059 	end;
     1060 						/*  */
     1061 get_break_action_code: proc;
     1062 
     1063 	     break_data_len,
     1064 		break_action_code,
     1065 		break_return = 0;
     1066 	     break_data_line = " ";
     1067 
     1068 
     1069 	     if cmc = "l" then break_action_code = 1;
     1070 
     1071 	     else if cmc = "r" then break_action_code = 2;
     1072 
     1073 	     else if cmc = "o" then break_action_code = 3;
     1074 
     1075 	     else if cmc = "n" then break_action_code = 4;
     1076 
     1077 	     else if cmc = "e"
     1078 	     then do;
     1079 		break_action_code = 5;
     1080 		break_data_len = ill-lin+1;
     1081 		if break_data_len = 1 then break_data_len = 0;
     1082 		else break_data_line = substr (il, lin, break_data_len);
     1083 		break_return = 1;
     1084 	     end;
     1085 
     1086 	     else if cmc = "c"
     1087 	     then do;
     1088 		break_action_code = 6;
     1089 		call db_parse_condition$set (il, lin, ill, break_data_len, break_data_line, code);
     1090 		if code = 100 then goto syntax_error;
     1091 		if code ^= 0 then call ioa_$ioa_stream (debug_output, "Symbol error in conditional break.");
     1092 	     end;
     1093 
     1094 	     else call ioa_$ioa_stream (debug_output, "Unknown break request");
     1095 	end get_break_action_code;
     1096 
     1097 type:	proc (n) returns (fixed bin);
     1098 
     1099 dcl  n fixed bin (8) unal;
     1100 dcl  table (0: 127) fixed bin static init
     1101     ((10)0, 15, (21)0, 11, 0, 14, 0, 4, 2, 13, (3)0, 16, 6, 7, 6, 17, 3, (10)5, 1,
     1102      12, 9, 8, 10, (2)0, (26)14, (4)0, 14, 0, (26)14, 0, 17, (3)0);
     1103 
     1104 /* The table array has the following meaning:
     1105*   0 = illegal
     1106*   1 = :
     1107*   2 = %
     1108*   3 = /
     1109*   4 = $
     1110*   5 = number
     1111*   6 = + or -
     1112*   7 = ,
     1113*   8 = =
     1114*   9 = <
     1115*   10 = >
     1116*   11 = blank
     1117*   12 = ;
     1118*   13 = &
     1119*   14 = letter
     1120*   15 = new-line
     1121*   16 = *
     1122*   17 = | or . */
     1123 
     1124 	     if n > -1 then if n < 128 then return (table (n)); /* legal ascii value */
     1125 	     call ioa_$ioa_stream (debug_output, "invalid character ""^a""", substr (il, n, 1));
     1126 	     go to rskip;				/* error return */
     1127 
     1128 	end type;
     1129 
     1130 
     1131 check_switch: proc;
     1132 
     1133 /* 	This procedure compares the old switch name and the new switch name.  If they are the same
     1134*   *	a message is printed and the procedure exits to skip which looks for the next request.
     1135*   */
     1136 		if j = 1 then if switch_name ^= debug_input then return; else;
     1137 	     else if switch_name ^= debug_output then return;
     1138 	     call ioa_$ioa_stream (debug_output, "Switch already set to ^a", switch_name);
     1139 	     goto skip;
     1140 
     1141 	end check_switch;
     1142 
     1143 /*  This procedure prints the error message for db_sym and exits to rskip to
     1144*   *   find the next db request.
     1145**/
     1146 
     1147 sym_err:	proc;
     1148 
     1149 dcl  mess char (80) var;
     1150 
     1151 	     mess = "";
     1152 	     if code = 1 then mess = "Symbol " || sym_name || " not found for " || snt.ent_name;
     1153 	     else if code = 2 then mess = "No symbol table for " || snt.ent_name;
     1154 	     else if code = 3 then mess = "No linkage section for " || snt.ent_name;
     1155 	     else if code = 4 then mess = "No stack frame for " || snt.ent_name;
     1156 	     else if code = 5 then mess = "Cannot get address of " || sym_name;
     1157 	     else if code = 6 then mess = "Cannot get size of " || sym_name;
     1158 	     else if code = 7 then go to syntax_error;
     1159 	     else if code = 8 then mess = "Subscripting error in " || sym_name;
     1160 	     else if code = 9 then mess = "Invalid subscript in " || sym_name;
     1161 	     else if code = 10 then mess = "Based variable error in " || sym_name;
     1162 	     else if code = 11 then mess = "Too many structure levels in " || sym_name;
     1163 	     else if code = 12 then mess = "Symbol is too long " || sym_name;
     1164 	     else if code = 13 then mess = "Reference is ambiguous " || sym_name;
     1165 	     else if code = 14 then mess = sym_name || " is entry constant; not supported";
     1166 	     else if code = 15 then mess = "Symbol table for this language is not supported by debug.";
     1167 
     1168 	     if mess ^= "" then call ioa_$ioa_stream (debug_output, mess);
     1169 	     go to rskip;
     1170 
     1171 	end sym_err;
     1172 
     1173 /*  This procedure searches for the next non-blank character in the line beginning with index.
     1174*   It returns "0"b if the rest of the line is blank.  Otherwise it returns "1"b, the index and the character
     1175*   found.
     1176**/
     1177 get_char:	proc (index_in, index_out, char_out) returns (bit (1));
     1178 
     1179 dcl  index_in fixed bin;
     1180 dcl  index_out fixed bin;
     1181 dcl  char_out char (1) aligned;
     1182 dcl  i fixed bin;
     1183 
     1184 	     index_out = index_in;
     1185 	     if index_out < ill then do;
     1186 		i = verify (substr (il, index_out, ill - index_out +1), " ");
     1187 
     1188 		if i > 0 then do;
     1189 		     index_out = index_out + i -1;
     1190 		     char_out = substr (il, index_out, 1);
     1191 		     if char_out ^= ";" & char_out ^= new_line then return ("1"b);
     1192 		end;
     1193 		else index_out = ill;
     1194 	     end;
     1195 
     1196 	     return ("0"b);
     1197 
     1198 	end get_char;
     1199 
     1200 /*  */
     1201 
     1202 parse_print: proc;
     1203 
     1204 dcl  i fixed bin;
     1205 dcl  size fixed bin;
     1206 dcl (have_mode, have_size, have_count) bit (1);
     1207 
     1208 	     have_mode, have_size, have_count = "0"b;
     1209 
     1210 	     do while (get_char (lin+1, lin, char));
     1211 
     1212 /* (<size>)  */
     1213 		if char = "(" then do;
     1214 		     if ^have_size then do;
     1215 			have_size = "1"b;
     1216 			i = db_get_count$dec (il, lin+1, lin);
     1217 			if i > 0 then do;
     1218 			     if get_char (lin, lin, char) then do;
     1219 				if char = ")" then do;
     1220 				     size = i;
     1221 				     goto next;
     1222 				end;
     1223 			     end;
     1224 			end;
     1225 		     end;
     1226 		     goto syntax_error;
     1227 		end;
     1228 
     1229 /* <amount to print>  */
     1230 		else if index (NUMBER, char) > 0 then do;
     1231 		     if have_count then goto syntax_error;
     1232 		     pc = db_get_count$dec (il, lin, lin);
     1233 		     pc = max (pc, 1);
     1234 		     have_count = "1"b;
     1235 		     lin = lin -1;
     1236 		end;
     1237 
     1238 /* <mode>   Set mode and default size.  A change in mode causes the amount to print to be set to 1 */
     1239 		else do;
     1240 		     if substr (il, lin, 1) = "n" then goto skip;
     1241 		     do i = 1 to hbound (MODES, 1)
     1242 			     while (substr (il, lin, length (MODES (i))) ^= MODES (i));
     1243 		     end;
     1244 		     if i > hbound (MODES, 1) then do;
     1245 			call ioa_$ioa_stream (debug_output, "Undefined output mode ""^a""", substr (il, lin, 1));
     1246 			goto rskip;
     1247 		     end;
     1248 		     data_format = MODES (i);
     1249 		     lin = lin + length (MODES (i)) -1;
     1250 		     if data_format = "p" then max_size = 72;
     1251 		     else if data_format = "comp-7" then max_size = 18;
     1252 		     else if data_format = "el" | data_format = "fl" then max_size = 72;
     1253 		     else max_size = 36;
     1254 		     if ^have_count then pc = 1;
     1255 		end;
     1256 next:
     1257 	     end;
     1258 
     1259 /* data_format and pc have been set.  Only set size if it is valid.  */
     1260 
     1261 	     if have_size then do;
     1262 		if data_format = "p" & ^(size = 36 | size = 72) then do;
     1263 		     call ioa_$ioa_stream (debug_output, "Invalid size for pointer.  Use 36 or 72");
     1264 		     goto rskip;
     1265 		end;
     1266 		else if data_format = "comp-8" | data_format = "comp-5" then max_size = divide (size*9, 2, 17, 0);
     1267 		else max_size = size;
     1268 	     end;
     1269 	end parse_print;
     1270 
     1271 /*  */
     1272 /*  This procedure parses &p requests and sets the data_ptr and offset and pc (data size).
     1273*   code = 0			Pointer was found to the argument.
     1274*   code = err_no_stack		No stack frame, so no parameter list.
     1275*   code = -1			Illegal number for argument poaition.
     1276*
     1277*   index			(input) Set to start of string "&p"
     1278*   (output) Set to first character not used in parse
     1279**/
     1280 parse_parameter: proc (index, code);
     1281 
     1282 dcl  index fixed bin;
     1283 dcl  code fixed bin;
     1284 
     1285 	     i = db_get_count$dec (il, index+2, index);
     1286 	     if snt.sp = null then code = err_no_stack;
     1287 	     else do;
     1288 		if snt.sp -> stack_frame.arg_ptr = null then code = err_no_stack;
     1289 		else do;
     1290 		     if i <= 0 | i > binary (snt.sp -> stack_frame.arg_ptr -> arg_list.num_args, 17) then do;
     1291 			call ioa_$ioa_stream (debug_output, "No parameter ^d.", i);
     1292 			code = -1;		/* no error message, but error return */
     1293 		     end;
     1294 		     else do;
     1295 			call decode_descriptor_ (snt.sp -> stack_frame.arg_ptr, i, code, switch, ndims, size, scale);
     1296 			data_ptr = snt.sp -> stack_frame.arg_ptr -> arg_list.args (i);
     1297 			offset = binary (rel (data_ptr), 18);
     1298 						/* COBOL data codes */
     1299 			if code = 38 | code = 39 | code = 41 then do;
     1300 			     pc = 1;
     1301 			     if code = 41 then data_format = "comp-8";
     1302 			     else data_format = "comp-5";
     1303 			     if code = 38 then size = divide (size*9, 2, 17, 0);
     1304 			     else size = divide ((size+1)*9, 2, 17, 0);
     1305 			end;
     1306 			else if code > 0 then do;
     1307 			     data_format = substr ("dhffdhfhhhhhphpphbbaah", code, 1); /* decode type into mode */
     1308 			     if code = 2 then pc = 2; /* if double precision fixed point */
     1309 			     else if code = 5 then pc = 2; /* complex fixed short */
     1310 			     else if code = 7 then pc = 2; /* complex float short */
     1311 			     else if code = 15 then pc = 2; /* label variable */
     1312 			     else if code = 16 then pc = 2; /* entry variable */
     1313 			     else if data_format = "a" then do;
     1314 				if code = 22 then pc = max (0, addrel (data_ptr, -1) -> based_fix);
     1315 				else pc = size;
     1316 			     end;
     1317 			     else if data_format = "b" then if code = 19 then pc = size;
     1318 				else pc = max (0, addrel (data_ptr, -1) -> based_fix);
     1319 			     data_id = "p";
     1320 			end;
     1321 			code = 0;
     1322 		     end;
     1323 		end;
     1324 	     end;
     1325 	     return;
     1326 
     1327 	end parse_parameter;
     1328 						/*  */
     1329 						/*  This procedure sets offset and data_ptr to the text beginning at a given source line.
     1330*						   code = 0		Was able to set the pointer to object code for line number.
     1331*
     1332*						   data_ptr  = location of first instruction on the line.
     1333*						   data_format = "s"   (db_print mode for source code )
     1334*						   data_id   = "t"   (segment_ID is &t for text )
     1335*
     1336*						   code = no_sym_tab	The procedure was not compiled with the table option.
     1337*						   code = -1		No code generated for 10 lines after the line number requested.
     1338*						   */
     1339 parse_source: proc (index, code);
     1340 
     1341 dcl  index fixed bin;
     1342 dcl  code fixed bin;
     1343 
     1344 	     line_number = db_get_count$dec (il, index+2, index);
     1345 	     if snt.symflag then call db_get_sym (sntp);
     1346 	     tp = snt.symp;				/* get pointer to symbol table */
     1347 	     if (^snt.std & tp = null) | snt.headp = null then code = err_no_sym_tab;
     1348 	     else do;
     1349 		switch = "0"b;
     1350 		do line_number = line_number to line_number + 10 while (code = 0);
     1351 		     if snt.std then offset = stu_$get_runtime_location (snt.headp, line_number);
     1352 		     else call stu_$get_location (snt.symp, line_number, offset);
     1353 		     if offset = -2 then code = err_no_sym_tab;
     1354 		     else do;
     1355 			if offset >= 0 then do;	/* if positive offset, ok */
     1356 			     data_id = "t";
     1357 			     data_ptr = ptr (snt.pp, offset);
     1358 			     data_format = "s";
     1359 			     if switch then call ioa_$ioa_stream (debug_output, "Using line number ^d.", line_number);
     1360 			     return;
     1361 			end;
     1362 			else switch = "1"b;
     1363 		     end;
     1364 		end;
     1365 		if code = 0 then do;
     1366 		     code = -1;
     1367 		     call ioa_$ioa_stream (debug_output, "debug: No code generated for 10 lines after ^d.", line_number - 11);
     1368 		end;
     1369 	     end;
     1370 
     1371 	     return;
     1372 
     1373 	end parse_source;
     1374 						/*  */
     1375 set_data_ptr: proc (segment_id);
     1376 
     1377 dcl  segment_id char (1) aligned;
     1378 
     1379 	     if segment_id = "t" then data_ptr = ptr (snt.pp, offset);
     1380 	     else if segment_id = "s" then do;
     1381 		if snt.sp = null then code = err_no_stack;
     1382 
     1383 		else do;
     1384 		     data_ptr = addrel (snt.sp, offset);
     1385 		end;
     1386 
     1387 	     end;
     1388 	     else if segment_id = "l" then do;
     1389 		if snt.pp = null () then code = err_no_linkage;
     1390 		else do;
     1391 		     snt.lp = ptr (baseptr (stack_header.lot_ptr -> lot (binary (baseno (snt.pp))).segno),
     1392 			stack_header.lot_ptr -> lot (binary (baseno (snt.pp))).offset);
     1393 		     if rel (snt.lp) = "0"b then code = err_no_linkage;
     1394 		     else do;
     1395 			data_ptr = addrel (snt.lp, offset);
     1396 		     end;
     1397 		end;
     1398 	     end;
     1399 
     1400 	     else if segment_id = "i" then do;
     1401 		if snt.pp = null () then code = err_no_static;
     1402 		else do;
     1403 		     snt.static_ptr = ptr (baseptr (stack_header.isot_ptr -> lot (binary (baseno (snt.pp))).segno),
     1404 			stack_header.isot_ptr -> lot (binary (baseno (snt.pp))).offset);
     1405 		     if rel (snt.static_ptr) = "0"b then code = err_no_static;
     1406 		     else do;
     1407 			data_ptr = addrel (snt.static_ptr, offset);
     1408 		     end;
     1409 		end;
     1410 	     end;
     1411 
     1412 	     else do;
     1413 		call ioa_$ioa_stream (debug_output, "bad segment ID ""^a""", segment_id);
     1414 		code = -1;
     1415 	     end;
     1416 	end set_data_ptr;
     1417 
     1418 /*  */
     1419 /* * This procedure parses the trace stack request.
     1420*   *	.tN,M	where N is the number of the first frame to print and M is the number of frames to be printed.
     1421*   *
     1422*   * It uses global variables:
     1423*   *	lin	input	= index of "." on line
     1424*   *		output	= index of last character used for trace stack request
     1425**/
     1426 stack_trace: proc ();
     1427 
     1428 dcl (i, start, last) fixed bin;
     1429 dcl  ent_name char (32) aligned;
     1430 dcl 1 trace_snt aligned like snt;
     1431 dcl  trace_snt_ptr ptr;
     1432 
     1433 	     trace_snt_ptr = addr (trace_snt);
     1434 	     start = 0;
     1435 	     last = max_stack;
     1436 
     1437 	     lin = lin + 2;
     1438 	     if verify (substr (il, lin, 1), NUMBER) = 0 then start = db_get_count$dec (il, lin, lin);
     1439 	     if substr (il, lin, 1) = "," then last = start + db_get_count$dec (il, lin+1, lin) -1;
     1440 	     start = max (0, start);
     1441 	     start = min (start, max_stack);
     1442 	     last = min (last, max_stack);
     1443 
     1444 	     if print_mode = 1
     1445 	     then call ioa_$ioa_stream (debug_output, "^/DEPTH  SEGNO  OFFSET  ^5xNAME^20xCONDITION^/");
     1446 
     1447 	     do i = start to last;
     1448 		call db_fill_snt (stack_ptr_array (i), trace_snt_ptr); /* get data for this stack frame */
     1449 		if is_condition_frame_ (trace_snt.sp) then do;
     1450 		     call find_condition_info_ (trace_snt.sp, addr (cond_info), code);
     1451 		     ent_name = cond_info.condition_name;
     1452 		end;
     1453 		else ent_name = "";
     1454 		call ioa_$ioa_stream (debug_output, " ^4d  ^5o  ^6o  ^a|^o^2-^a",
     1455 		     i, binary (baseno (trace_snt.pp), 15), binary (rel (trace_snt.sp), 18),
     1456 		     trace_snt.ent_pt_name, binary (rel (trace_snt.pp), 18), ent_name);
     1457 	     end;
     1458 
     1459 	end stack_trace;
     1460 
     1461      end db_parse;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1034.0  db_parse.pl1                      >special_ldd>install>MR12.0-1206>db_parse.pl1
253          1    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
254          2    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
255          3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
257          4    05/06/74  1741.6  db_common_auto.incl.pl1           >ldd>include>db_common_auto.incl.pl1
259          5    05/06/74  1741.6  db_common_static.incl.pl1         >ldd>include>db_common_static.incl.pl1
261          6    11/06/75  1110.0  db_snt.incl.pl1                   >ldd>include>db_snt.incl.pl1
263          7    05/06/74  1741.1  db_arg_list.incl.pl1              >ldd>include>db_arg_list.incl.pl1
265          8    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
267          9    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
268         10    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MODES                           000266 constant        varying char(6)          initial array dcl 229 ref 1241 1241 1241 1244 1248
                                                                                  1249
NUMBER                          000365 constant        char(11)                 initial unaligned dcl 228 ref 988 1230 1438
addr                                                   builtin function         dcl 210 ref 193 305 434 434 436 438 451 457 458 461
                                                                                  463 464 467 467 475 486 532 532 532 532 532 532
                                                                                  669 674 740 740 740 740 740 740 894 894 899 933
                                                                                  934 1433 1450 1450
addrel                                                 builtin function         dcl 210 ref 1314 1318 1384 1395 1407
arg_auto_ptr                           parameter       pointer                  dcl 20 ref 11 298
arg_list                               based           structure                level 1 dcl 7-5
arg_ptr                  32            based           pointer                  level 2 dcl 10-36 set ref 445 788 802* 1288 1290
                                                                                  1295* 1296
arg_stat_ptr                           parameter       pointer                  dcl 20 ref 11 300
arglist                         000244 automatic       pointer                  array dcl 156 set ref 436* 441* 445* 451* 455* 455
                                                                                  457 458 460* 461* 463 464 467 467 475*
args                      2            based           pointer                  array level 2 dcl 7-5 ref 1296
attach                          000564 automatic       bit(1)                   unaligned dcl 182 set ref 812* 847* 860
attach_descrip_ptr       14            based           pointer                  level 2 dcl 3-6 ref 829 844
b9                                     parameter       fixed bin(8,0)           unaligned dcl 1053 set ref 1051 1055*
based_bit72                            based           bit(72)                  unaligned dcl 151 ref 899
based_fix                              based           fixed bin(17,0)          dcl 153 ref 1314 1318
based_ptr                              based           pointer                  dcl 156 ref 589
baseno                                                 builtin function         dcl 210 ref 550 550 570 570 596 596 670 670 675 675
                                                                                  1391 1391 1403 1403 1454 1454
baseptr                                                builtin function         dcl 210 ref 505 570 596 732 1391 1403
bi                                     based           structure                level 1 dcl 218
binary                                                 builtin function         dcl 211 ref 449 450 457 458 570 570 591 596 596 669
                                                                                  670 670 674 675 675 894 894 921 921 996 1028 1028
                                                                                  1029 1029 1030 1030 1031 1290 1297 1391 1391 1403
                                                                                  1403 1454 1454 1454 1454 1454 1454
bit                                                    builtin function         dcl 210 ref 449
bit_offset                1(21)        based           bit(6)                   level 2 packed unaligned dcl 8-5 ref 669 674
break_action_code               000101 automatic       fixed bin(17,0)          dcl 46 set ref 718 720* 756 757* 775 777* 1063*
                                                                                  1069* 1071* 1073* 1075* 1079* 1088*
break_data_len                  000102 automatic       fixed bin(17,0)          dcl 46 set ref 720* 757* 777* 1063* 1080* 1081 1081*
                                                                                  1082 1089*
break_data_line                 000103 automatic       char(236)                unaligned dcl 46 set ref 720* 757* 777* 1066* 1082*
                                                                                  1089*
break_return                    000176 automatic       fixed bin(17,0)          dcl 46 set ref 721 758 778 1063* 1083*
c1                              000414 automatic       char(1)                  dcl 167 set ref 439*
c2                              000415 automatic       char(1)                  dcl 167 set ref 439*
char                            000563 automatic       char(1)                  dcl 180 set ref 325* 337* 351* 725* 957* 960 961*
                                                                                  962 962 967 970 971 972 978* 979 986 987 988 990
                                                                                  1210* 1213 1218* 1219 1230
char_out                               parameter       char(1)                  dcl 1181 set ref 1177 1190* 1191 1191
cmc                             000562 automatic       char(1)                  dcl 167 set ref 364* 366 367 368 371 389* 637* 638
                                                                                  644 645 645 660 660 668 673 678 684 685* 686 690
                                                                                  700 704 706* 707 708* 709 724 749 769 782 790*
                                                                                  795* 796* 800* 802* 804 807 811 906* 909 909 910
                                                                                  914 1069 1071 1073 1075 1077 1086
code                                   parameter       fixed bin(17,0)          dcl 1342 in procedure "parse_source" set ref 1339
                                                                                  1347* 1350 1353* 1365 1366*
code                      0(17)        based           bit(19)                  level 2 in structure "arg_list" packed unaligned
                                                                                  dcl 7-5 in procedure "db_parse" set ref 463*
code                            000216 automatic       fixed bin(17,0)          dcl 135 in procedure "db_parse" set ref 381* 383 387
                                                                                  388 417* 418 420* 439* 440 445 445 499* 500 506*
                                                                                  507 532* 533 534* 537* 539* 542* 543 543 597* 730*
                                                                                  731 740* 741* 743* 950* 956 970* 971* 979 1008
                                                                                  1009 1009 1089* 1090 1091 1152 1153 1154 1155 1156
                                                                                  1157 1158 1159 1160 1161 1162 1163 1164 1165 1166
                                                                                  1381* 1389* 1393* 1401* 1405* 1414* 1450*
code                                   parameter       fixed bin(17,0)          dcl 1283 in procedure "parse_parameter" set ref 1280
                                                                                  1286* 1288* 1292* 1295* 1299 1299 1299 1301 1303
                                                                                  1306 1307 1308 1309 1310 1311 1312 1314 1317 1321*
code35                          000214 automatic       fixed bin(35,0)          dcl 134 set ref 827* 828 842* 843 845* 846 851* 852
                                                                                  857* 858* 867*
com_auto_data                          based           structure                level 1 dcl 4-24
com_auto_ptr                    000644 automatic       pointer                  dcl 4-13 set ref 298* 308 311 313 317 320 321 434
                                                                                  434 436 438 486 617 694 695 697 701 804 807 887
                                                                                  900 995 1046
com_err_                        000106 constant        entry                    external dcl 70 ref 420 534 867
com_stat_ptr                    000646 automatic       pointer                  dcl 5-12 set ref 300* 311 322 501 548 653 679 680
                                                                                  688 692 711 712 712 713 713 720 750 757 777 887
                                                                                  900 924 995 1046 1444 1448
com_static_data                        based           structure                level 1 dcl 5-23
cond_info                       000612 automatic       structure                level 1 dcl 252 set ref 1450 1450
condition_name            3     000612 automatic       varying char(32)         level 2 dcl 252 set ref 1451
continue                        000100 automatic       bit(1)                   unaligned dcl 45 set ref 955* 956 957* 999* 1000
ct                              000230 automatic       fixed bin(17,0)          dcl 135 set ref 397* 400* 429 455 457 458 459
cu_$cp                          000110 constant        entry                    external dcl 70 ref 664
cu_$gen_call                    000112 constant        entry                    external dcl 70 ref 467
cv_oct_check_                   000114 constant        entry                    external dcl 70 ref 499 730
d_type                          000217 automatic       fixed bin(17,0)          dcl 135 set ref 328* 381* 894* 896 1033* 1046*
data_format                     000016 internal static char(6)                  dcl 31 set ref 315* 381* 382 382 487* 558* 657* 670*
                                                                                  675* 969* 1023 1033* 1248* 1250 1251 1252 1252
                                                                                  1262 1266 1266 1301* 1302* 1307* 1313 1317 1358*
data_id                         000014 internal static char(1)                  dcl 31 set ref 314* 381* 556* 576* 600* 656* 670*
                                                                                  675* 914 921 964* 967 979* 1002* 1028 1029 1030
                                                                                  1319* 1356*
data_ptr                        000010 internal static pointer                  dcl 31 set ref 311* 381* 460 486* 555* 574* 585 586
                                                                                  586 589* 589 591 594 596 596 597* 655* 669 674 921
                                                                                  923 933 1027 1040 1296* 1297 1314 1318 1357* 1379*
                                                                                  1384* 1395* 1407*
db_action_code            6            based           fixed bin(17,0)          level 2 dcl 4-24 set ref 617* 697* 701*
db_assign                       000116 constant        entry                    external dcl 70 ref 1046
db_break$global                 000120 constant        entry                    external dcl 70 ref 720
db_break$print_bseg             000122 constant        entry                    external dcl 70 ref 750
db_break$print_default          000124 constant        entry                    external dcl 70 ref 726
db_break$set_break              000126 constant        entry                    external dcl 70 ref 924
db_break$set_default            000130 constant        entry                    external dcl 70 ref 746
db_break$set_skips              000132 constant        entry                    external dcl 70 ref 771
db_break$single                 000136 constant        entry                    external dcl 70 ref 777
db_break$sub_global             000134 constant        entry                    external dcl 70 ref 757
db_ext_stat_$db_ext_stat_       000244 external static structure                level 1 dcl 2-9
db_fill_snt                     000162 constant        entry                    external dcl 70 ref 553 653 1448
db_fill_snt$proc_ptr            000164 constant        entry                    external dcl 70 ref 549
db_find_mc                      000232 constant        entry                    external dcl 120 ref 804 807
db_get_count                    000142 constant        entry                    external dcl 70 ref 963 986 987 988
db_get_count$dec                000144 constant        entry                    external dcl 70 ref 484 639 646 694 763 770 794 1216
                                                                                  1232 1285 1344 1438 1439
db_get_count$double             000146 constant        entry                    external dcl 70 ref 891
db_get_sym                      000150 constant        entry                    external dcl 70 ref 1345
db_mc_ptr                              based           pointer                  level 2 dcl 4-24 set ref 804* 807* 887* 900* 995*
                                                                                  1046*
db_parse_arg                    000224 constant        entry                    external dcl 70 ref 434
db_parse_arg$ptr_offset         000240 constant        entry                    external dcl 126 ref 894
db_parse_condition$set          000140 constant        entry                    external dcl 70 ref 1089
db_print                        000152 constant        entry                    external dcl 70 ref 1033
db_regs$assign                  000160 constant        entry                    external dcl 70 ref 900
db_regs$get                     000154 constant        entry                    external dcl 70 ref 995
db_regs$print                   000156 constant        entry                    external dcl 70 ref 887
db_sym                          000166 constant        entry                    external dcl 70 ref 381 439
debug_input                     000244 external static char(32)                 level 2 dcl 2-9 set ref 862* 1136
debug_io_attach          30     000244 external static bit(1)                   array level 3 packed unaligned dcl 2-9 set ref 858
                                                                                  860*
debug_io_open            30(02) 000244 external static bit(1)                   array level 3 packed unaligned dcl 2-9 set ref 857
                                                                                  861*
debug_io_ptr             24     000244 external static pointer                  array level 2 dcl 2-9 set ref 857* 858* 859* 1033*
debug_output             10     000244 external static char(32)                 level 2 dcl 2-9 set ref 430* 472* 476* 502* 586*
                                                                                  608* 649* 654* 670* 675* 765* 784* 830* 834* 863*
                                                                                  871* 930* 1009* 1033* 1091* 1094* 1125* 1137 1138*
                                                                                  1168* 1245* 1263* 1291* 1359* 1367* 1413* 1444*
                                                                                  1454*
dec_default                     000566 automatic       bit(1)                   unaligned dcl 184 set ref 1044* 1045* 1046*
decode_descriptor_              000170 constant        entry                    external dcl 70 ref 1295
desc                                   based           structure                array level 1 dcl 195 set ref 451
desc_area                       000070 internal static bit(36)                  initial array unaligned dcl 190 set ref 193
desc_ptr                        000610 automatic       pointer                  initial dcl 193 set ref 193* 449 450 451
dir_name                 20            based           char(168)                level 2 in structure "snt" dcl 6-9 in procedure
                                                                                  "db_parse" set ref 572* 597* 675*
dir_name                        000416 automatic       char(168)                dcl 167 in procedure "db_parse" set ref 506* 509*
                                                                                  532 532 539* 542* 572 740 740 743*
divide                                                 builtin function         dcl 211 ref 1266 1303 1304
dol                             000241 automatic       fixed bin(17,0)          dcl 148 set ref 518* 519 520 521
dummy_arg                10            based           structure                array level 2 dcl 4-24 set ref 434 434 436 438 486
dummy_desc                      000103 internal static bit(36)                  initial dcl 202 set ref 475
ent_name                 10            based           char(32)                 level 2 in structure "snt" dcl 6-9 in procedure
                                                                                  "db_parse" set ref 571* 597* 598 670* 675* 1009*
                                                                                  1152 1153 1154 1155
ent_name                        000542 automatic       char(32)                 dcl 167 in procedure "db_parse" set ref 408* 414
                                                                                  417* 419* 419* 420* 506* 508* 511 532 532 539*
                                                                                  542* 571 740 740 743*
ent_name                        001035 automatic       char(32)                 dcl 1429 in procedure "stack_trace" set ref 1451*
                                                                                  1453* 1454*
ent_pt_name                     001046 automatic       char(32)                 level 2 in structure "trace_snt" dcl 1430
                                                                                  in procedure "stack_trace" set ref 1454*
ent_pt_name                            based           char(32)                 level 2 in structure "snt" dcl 6-9 in procedure
                                                                                  "db_parse" set ref 554 573* 598*
entry_name                      000577 automatic       char(32)                 dcl 187 set ref 511* 520* 523* 525 526* 526 554 573
err_mess                        000020 internal static char(40)                 initial array unaligned dcl 64 set ref 1009*
err_no_linkage                  000210 automatic       fixed bin(17,0)          initial dcl 60 set ref 60* 1389 1393
err_no_stack                    000211 automatic       fixed bin(17,0)          initial dcl 61 set ref 61* 1286 1288 1381
err_no_static                   000213 automatic       fixed bin(17,0)          initial dcl 63 set ref 63* 1401 1405
err_no_sym_tab                  000212 automatic       fixed bin(17,0)          initial dcl 62 set ref 62* 1347 1353
error_table_$segknown           000242 external static fixed bin(17,0)          dcl 131 ref 543
exec                            000237 automatic       fixed bin(17,0)          dcl 135 set ref 434* 438 442* 450
expand_path_                    000172 constant        entry                    external dcl 70 ref 532 740
fboff                           000215 automatic       fixed bin(9,0)           dcl 135 set ref 669* 670* 674* 675*
ff                                     based           structure                level 1 dcl 214
fill                      1(17)        based           bit(19)                  level 2 packed unaligned dcl 7-5 set ref 464*
find_condition_info_            000234 constant        entry                    external dcl 122 ref 1450
first_call_flag           5            based           fixed bin(17,0)          level 2 dcl 4-24 set ref 308 317*
flags                    30     000244 external static structure                level 2 dcl 2-9
goto_label                      000204 automatic       label variable           dcl 54 set ref 933 934 935
have_count                      000776 automatic       bit(1)                   unaligned dcl 1206 set ref 1208* 1231 1234* 1254
have_mode                       000774 automatic       bit(1)                   unaligned dcl 1206 set ref 1208*
have_size                       000775 automatic       bit(1)                   unaligned dcl 1206 set ref 1208* 1214 1215* 1261
hbound                                                 builtin function         dcl 211 ref 1241 1244
hcs_$fs_get_path_name           000174 constant        entry                    external dcl 70 ref 506 539 597
hcs_$fs_get_seg_ptr             000176 constant        entry                    external dcl 70 ref 537 741
hcs_$initiate                   000200 constant        entry                    external dcl 70 ref 542 743
hcs_$make_ptr                   000202 constant        entry                    external dcl 70 ref 417
hcs_count                 2            based           fixed bin(17,0)          level 2 dcl 5-23 ref 501
headp                   104            based           pointer                  level 2 dcl 6-9 set ref 1347 1351*
i                               000225 automatic       fixed bin(17,0)          dcl 135 in procedure "db_parse" set ref 363* 364 365
                                                                                  372 372* 372* 377 379 388* 406* 406* 408 409 410
                                                                                  412 412 415 419* 425* 428* 428 429 434 434 436 436
                                                                                  438 441 445 449 450 451 451 454 455 457 458 460
                                                                                  461 472* 475 494* 494* 498 499 499 514 532 545
                                                                                  547* 548 552* 622* 623 624 640* 646* 647 650 664*
                                                                                  705* 706 708 710* 710 711 713 716 725 753 753* 754
                                                                                  763* 770* 771* 791* 794* 799* 802* 817* 818 819
                                                                                  821* 823 823* 824* 824 825 879* 879* 882 883* 883
                                                                                  883* 885 885 890 890* 891* 892 991* 991* 993 994
                                                                                  1285* 1290 1290 1291* 1295* 1296
i                               000772 automatic       fixed bin(17,0)          dcl 1204 in procedure "parse_print" set ref 1216*
                                                                                  1217 1220 1241* 1241 1241* 1244 1248 1249
i                               001032 automatic       fixed bin(17,0)          dcl 1428 in procedure "stack_trace" set ref 1447*
                                                                                  1448 1454*
i                               000762 automatic       fixed bin(17,0)          dcl 1182 in procedure "get_char" set ref 1186* 1188
                                                                                  1189
il                              000327 automatic       char(132)                dcl 167 set ref 305 364 372 377 403 408 409 412 426
                                                                                  434* 435 484* 494 499 499 514 622 637 639* 646*
                                                                                  661* 679 680 685 694 694* 706 708 713 729 763*
                                                                                  770* 790 794* 795 795 813 814 817 821 825 882 883
                                                                                  883 885 886 891* 893 894* 906 961 963* 986* 987*
                                                                                  988* 993 1046* 1082 1089* 1125 1125 1186 1190
                                                                                  1216* 1232* 1240 1241 1245 1245 1285* 1344* 1438
                                                                                  1438* 1439 1439*
ill                             000233 automatic       fixed bin(17,0)          dcl 135 set ref 304* 306 306 363 406 410 434* 494
                                                                                  498 622 625 627 635 664* 711 721 729 740 758 778
                                                                                  817 821 823 883 885 886 886 894* 908 974 1046*
                                                                                  1080 1089* 1185 1186 1193
ilp                             000320 automatic       pointer                  dcl 156 set ref 305* 306 330 339 353 365 406 410 643
                                                                                  664* 879 991
in_debug                 30(04) 000244 external static bit(1)                   level 3 packed unaligned dcl 2-9 set ref 466* 468*
                                                                                  663* 665*
index                                  parameter       fixed bin(17,0)          dcl 1282 in procedure "parse_parameter" set ref 1280
                                                                                  1285 1285*
index                                  parameter       fixed bin(17,0)          dcl 1341 in procedure "parse_source" set ref 1339
                                                                                  1344 1344*
index                                                  builtin function         dcl 210 in procedure "db_parse" ref 518 525 622 1230
index_in                               parameter       fixed bin(17,0)          dcl 1179 ref 1177 1184
index_out                              parameter       fixed bin(17,0)          dcl 1180 set ref 1177 1184* 1185 1186 1186 1189*
                                                                                  1189 1190 1193*
input_buffer_ptr                       parameter       pointer                  dcl 20 ref 11 306
input_line_len                         parameter       fixed bin(17,0)          dcl 20 ref 11 304
input_type                      000015 internal static char(1)                  dcl 31 set ref 316* 384* 482* 560* 590* 942* 1044
ioa_$ioa_stream                 000204 constant        entry                    external dcl 70 ref 430 472 476 502 586 608 649 654
                                                                                  670 675 765 784 830 834 871 930 1009 1091 1094
                                                                                  1125 1138 1168 1245 1263 1291 1359 1367 1413 1444
                                                                                  1454
ioa_$rsnnl                      000206 constant        entry                    external dcl 70 ref 419
iocb                                   based           structure                level 1 dcl 3-6
iox_$attach_ioname              000214 constant        entry                    external dcl 70 ref 845
iox_$close                      000210 constant        entry                    external dcl 70 ref 857
iox_$detach_iocb                000212 constant        entry                    external dcl 70 ref 858
iox_$find_iocb                  000216 constant        entry                    external dcl 70 ref 827 842
iox_$open                       000220 constant        entry                    external dcl 70 ref 851
is_condition_frame_             000230 constant        entry                    external dcl 118 ref 1449
isot_ptr                 52            based           pointer                  level 2 dcl 9-26 ref 1403 1403
itemp                           000220 automatic       fixed bin(17,0)          dcl 135 set ref 506* 539* 597*
its                                    based           structure                level 1 dcl 8-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 8-5 ref 585
j                               000226 automatic       fixed bin(17,0)          dcl 135 set ref 365* 366 366 366 366 434* 437 439*
                                                                                  448 449 453 454* 455 455* 471 475 525* 526 526
                                                                                  813* 814* 839 851* 857 857 858 858 859 860 861 862
                                                                                  1136
label_map                              based           structure                level 1 dcl 56
last                            001034 automatic       fixed bin(17,0)          dcl 1428 set ref 1435* 1439* 1442* 1442 1447
length                                                 builtin function         dcl 211 ref 1241 1249
lin                             000232 automatic       fixed bin(17,0)          dcl 135 set ref 303* 325* 325* 330 337* 337* 339
                                                                                  351* 351* 353 363 377 377 379* 403 405 405* 406
                                                                                  408 408 410* 410* 412 415* 424* 424* 426 427* 427
                                                                                  434* 435 435* 435 484 484* 494 499 499 499 499 514
                                                                                  514 530* 530 532 545* 582* 582 622 622 624* 624
                                                                                  625 627* 635 637 639 639* 643 646 646* 661 679 680
                                                                                  685 687* 687 691* 691 694 694 694* 705 716* 721*
                                                                                  725* 729 729 737* 737 740 754* 758* 763* 770 770*
                                                                                  778* 790 794 794* 795 795 813 814 816* 816 817 817
                                                                                  819* 819 821 821 824 825 825 879 879 882 882 883
                                                                                  886 891* 892 893 894* 906 908 911* 911 957* 957*
                                                                                  961 963* 963* 970* 971* 973* 973 974 980* 980 986
                                                                                  986* 987 987* 988* 988* 991 991 993 993 994* 1038*
                                                                                  1038 1046* 1080 1082 1089* 1210 1210* 1216 1216*
                                                                                  1218* 1218* 1232* 1232* 1235* 1235 1240 1241 1245
                                                                                  1245 1249* 1249 1437* 1437 1438 1438* 1438* 1439
                                                                                  1439 1439*
line_number                     000223 automatic       fixed bin(17,0)          dcl 135 set ref 1344* 1350* 1350 1350* 1351* 1352*
                                                                                  1359* 1367
list_arg_                       000222 constant        entry                    external dcl 70 ref 802
lot                                    based           structure                array level 1 dcl 222
lot_ptr                  26            based           pointer                  level 2 dcl 9-26 ref 570 570 596 596 1391 1391
lp                       76            based           pointer                  level 2 dcl 6-9 set ref 570* 596* 1029 1391* 1393
                                                                                  1395
max                                                    builtin function         dcl 210 ref 1233 1314 1318 1440
max_size                        000242 automatic       fixed bin(17,0)          dcl 149 set ref 381* 439* 1033* 1046* 1250* 1251*
                                                                                  1252* 1253* 1266* 1267*
max_sp_x                  4            based           fixed bin(17,0)          level 2 dcl 4-24 ref 311 313 321
max_stack                       000221 automatic       fixed bin(17,0)          dcl 135 set ref 321* 322 547 648 930 1435 1441 1442
mess                            000726 automatic       varying char(80)         dcl 1149 set ref 1151* 1152* 1153* 1154* 1155* 1156*
                                                                                  1157* 1159* 1160* 1161* 1162* 1163* 1164* 1165*
                                                                                  1166* 1168 1168*
min                                                    builtin function         dcl 211 ref 1441 1442
n                                      parameter       fixed bin(8,0)           unaligned dcl 1099 ref 1097 1124 1124 1124 1125 1125
ndims                           000236 automatic       fixed bin(17,0)          dcl 135 set ref 1295*
new_line                        012552 constant        char(1)                  initial dcl 167 ref 886 1191
new_type                        000222 automatic       fixed bin(17,0)          dcl 135 set ref 380* 914* 914* 967* 968* 969
null                                                   builtin function         dcl 210 ref 417 417 418 538 550 566 569 592 595 654
                                                                                  742 744 783 788 829 833 844 850 1286 1288 1347
                                                                                  1347 1381 1389 1401
num_args                               based           fixed bin(16,0)          level 2 packed unaligned dcl 7-5 set ref 457* 1290
num_desc                  1            based           fixed bin(16,0)          level 2 packed unaligned dcl 7-5 set ref 458*
num_skips                 7            based           fixed bin(17,0)          level 2 dcl 4-24 set ref 694* 695*
nv                              000231 automatic       fixed bin(17,0)          dcl 135 set ref 359* 367* 367 369 369* 369 373 375
                                                                                  484* 485 485 486 499* 501 505 643* 730* 732 763*
                                                                                  764 771* 777* 789 793 793 798 798 894* 1028* 1029*
                                                                                  1030* 1031* 1033*
offset                          000012 internal static fixed bin(18,0)          dcl 31 in procedure "db_parse" set ref 312* 381*
                                                                                  557* 591* 658* 670* 675* 944* 963* 963 1001* 1001
                                                                                  1297* 1351* 1352* 1353 1355 1357 1379 1384 1395
                                                                                  1407
offset                    0(18)        based           bit(18)                  array level 2 in structure "lot" packed unaligned
                                                                                  dcl 222 in procedure "db_parse" ref 570 596 1391
                                                                                  1403
offset_incr                     000240 automatic       fixed bin(17,0)          dcl 146 set ref 986* 987* 988* 996* 1001
open                            000565 automatic       bit(1)                   unaligned dcl 182 set ref 812* 853* 861
open_descrip_ptr         20            based           pointer                  level 2 dcl 3-6 ref 833 850
pathname                        000470 automatic       char(168)                unaligned dcl 167 set ref 511* 514* 518 520 521* 521
                                                                                  523 528 529* 529 532 532 534* 537* 729* 730* 735
                                                                                  736* 736 740 740 741*
pc                              000224 automatic       fixed bin(17,0)          dcl 135 set ref 329* 381* 382* 439* 442 1033* 1046*
                                                                                  1232* 1233* 1233 1254* 1300* 1308* 1309* 1310*
                                                                                  1311* 1312* 1314* 1315* 1317* 1318*
pp                              000316 automatic       pointer                  dcl 156 in procedure "db_parse" set ref 439* 441
                                                                                  505* 506* 537* 538 539* 542* 550 568 570 570 574
                                                                                  827* 829 833 842* 844 845* 850 851* 859 1027* 1028
                                                                                  1029 1030 1031 1033* 1040* 1046*
pp                       72     001046 automatic       pointer                  level 2 in structure "trace_snt" dcl 1430
                                                                                  in procedure "stack_trace" set ref 1454 1454 1454
                                                                                  1454
pp                                     based           pointer                  level 2 in structure "label_map" dcl 56 in procedure
                                                                                  "db_parse" set ref 933*
pp                       72            based           pointer                  level 2 in structure "snt" dcl 6-9 in procedure
                                                                                  "db_parse" set ref 568* 594* 654 670 670 675 675
                                                                                  921 1357 1379 1389 1391 1391 1401 1403 1403
prev_sp                  20            based           pointer                  level 2 dcl 10-36 ref 787
print_mode                3            based           fixed bin(17,0)          level 2 dcl 5-23 set ref 679* 680* 720* 750* 757*
                                                                                  777* 887* 900* 924* 995* 1046* 1444
ptr                                                    builtin function         dcl 210 ref 322 570 594 596 921 1357 1379 1391 1403
ptr_array                              based           pointer                  array dcl 156 ref 445
ref_name                        000552 automatic       char(32)                 dcl 167 set ref 412* 414* 417* 419*
reg_name                        000370 automatic       char(4)                  dcl 167 set ref 882* 887* 900* 993* 995*
reg_val                         000200 automatic       bit(72)                  unaligned dcl 46 set ref 899* 900* 995* 996
rel                                                    builtin function         dcl 210 ref 591 921 921 1028 1028 1029 1029 1030
                                                                                  1030 1031 1297 1393 1405 1454 1454 1454 1454
return_desc                     000104 internal static bit(36)                  initial dcl 205 set ref 461
reverse                                                builtin function         dcl 211 ref 525
sb                              000652 automatic       pointer                  dcl 9-24 set ref 322* 570 570 596 596 1391 1391 1403
                                                                                  1403
scale                           000235 automatic       fixed bin(17,0)          dcl 135 set ref 1295*
search                                                 builtin function         dcl 210 ref 821
segment_id                             parameter       char(1)                  dcl 1377 set ref 1375 1379 1380 1388 1400 1413*
segno                                  based           bit(18)                  array level 2 packed unaligned dcl 222 ref 570 596
                                                                                  1391 1403
signaller                20(26)        based           bit(1)                   level 2 packed unaligned dcl 10-64 ref 787
size                      0(12)        based           fixed bin(23,0)          array level 2 in structure "desc" packed unaligned
                                                                                  dcl 195 in procedure "db_parse" set ref 450*
size                            000234 automatic       fixed bin(17,0)          dcl 135 in procedure "db_parse" set ref 1295* 1303*
                                                                                  1303 1304* 1304 1315 1317
size                            000773 automatic       fixed bin(17,0)          dcl 1205 in procedure "parse_print" set ref 1220*
                                                                                  1262 1262 1266 1267
snt                                    based           structure                level 1 dcl 6-9
snt_ptr                   2            based           pointer                  level 2 dcl 4-24 ref 320
sntp                            000650 automatic       pointer                  dcl 6-7 set ref 320* 381* 439* 445 553* 554 566 567
                                                                                  568 569 570 571 572 573 592 593 594 595 596 597
                                                                                  597 598 598 653* 654 655 670 670 670 675 675 675
                                                                                  675 783 787 788 802 804 807 921 921 924* 934 1009
                                                                                  1028 1029 1030 1033* 1046* 1152 1153 1154 1155
                                                                                  1286 1288 1290 1295 1296 1345 1345* 1346 1347 1347
                                                                                  1351 1351 1352 1357 1379 1381 1384 1389 1391 1391
                                                                                  1391 1393 1395 1401 1403 1403 1403 1405 1407
sp                       74            based           pointer                  level 2 in structure "snt" dcl 6-9 in procedure
                                                                                  "db_parse" set ref 445 569* 595* 655 783 787 788
                                                                                  802 804* 807* 921 934 1028 1286 1288 1290 1295
                                                                                  1296 1381 1384
sp                       74     001046 automatic       pointer                  level 2 in structure "trace_snt" dcl 1430
                                                                                  in procedure "stack_trace" set ref 1449* 1450*
                                                                                  1454 1454
sp                        2            based           pointer                  level 2 in structure "label_map" dcl 56 in procedure
                                                                                  "db_parse" set ref 934*
sp                              000654 automatic       pointer                  dcl 10-31 in procedure "db_parse" set ref 548* 549*
                                                                                  553* 555
stack_depth                     000013 internal static fixed bin(17,0)          dcl 31 set ref 313* 552* 575* 599* 639* 640 647* 647
                                                                                  648 648 649* 650* 650 653 670* 675* 930 930
stack_frame                            based           structure                level 1 dcl 10-36
stack_frame_flags                      based           structure                level 1 dcl 10-64
stack_header                           based           structure                level 1 dcl 9-26
stack_ptr_array           4            based           pointer                  array level 2 dcl 5-23 set ref 311 322 548 653*
                                                                                  1448*
start                           001033 automatic       fixed bin(17,0)          dcl 1428 set ref 1434* 1438* 1439 1440* 1440 1441*
                                                                                  1441 1447
static_ptr              106            based           pointer                  level 2 dcl 6-9 set ref 1030 1403* 1405 1407
std                     102(01)        based           bit(1)                   level 2 packed unaligned dcl 6-9 ref 1347 1351
str                                    based           char                     dcl 167 ref 438
str1                                   based           char                     dcl 167 set ref 306* 306
stu_$get_location               000226 constant        entry                    external dcl 70 ref 1352
stu_$get_runtime_location       000236 constant        entry                    external dcl 124 ref 1351
substr                                                 builtin function         dcl 210 set ref 364 372 377 403 408 409 412 426 435
                                                                                  494 499 499 514 520 521 526 528 529 622 637 661*
                                                                                  679 680 685 694 706 708 713 729 735 736 790 795
                                                                                  795 813 814 817 821 825 882 883 883 885 886 893
                                                                                  906 961 993 1082 1125 1125 1186 1190 1240 1241
                                                                                  1245 1245 1307 1438 1439
switch                          000326 automatic       bit(1)                   dcl 164 set ref 1295* 1349* 1359 1362*
switch_name                     000567 automatic       char(32)                 unaligned dcl 185 set ref 825* 827* 830* 834* 839*
                                                                                  840* 842* 845* 862 863 1136 1137 1138*
sym_name                        000371 automatic       varying char(72)         dcl 167 set ref 377* 381* 438* 439* 1152 1156 1157
                                                                                  1159 1160 1161 1162 1163 1164 1165
symflag                 102            based           bit(1)                   level 2 packed unaligned dcl 6-9 set ref 567* 593*
                                                                                  1345
symp                    100            based           pointer                  level 2 dcl 6-9 set ref 566* 592* 1346 1352*
t                               000674 automatic       fixed bin(17,0)          dcl 1053 set ref 1055* 1056 1056
table                           000066 constant        fixed bin(17,0)          initial array dcl 1100 ref 1124
temp1                           000227 automatic       fixed bin(18,0)          dcl 135 set ref 439*
temp_break_mode        2046            based           fixed bin(17,0)          level 2 dcl 5-23 set ref 688* 692*
temp_comd_len          2004            based           fixed bin(17,0)          level 2 dcl 5-23 set ref 711* 712 712* 713
temp_comd_line         2005            based           char(132)                level 2 dcl 5-23 set ref 713*
temp_reg_val                    000202 automatic       fixed bin(71,0)          dcl 52 set ref 891* 894 894 894 894 899
tp                              000322 automatic       pointer                  dcl 156 set ref 417* 418 467* 732* 741* 742 743* 744
                                                                                  746* 921* 923* 924* 1346* 1347
tpp                             000324 automatic       pointer                  dcl 156 set ref 549* 550 550
trace_snt                       001046 automatic       structure                level 1 dcl 1430 set ref 1433
trace_snt_ptr                   001156 automatic       pointer                  dcl 1431 set ref 1433* 1448*
ts                                     based           fixed bin(8,0)           array level 2 packed unaligned dcl 218 set ref 330*
                                                                                  339* 353* 365* 406* 410* 643* 879* 991*
type                      0(01)        based           bit(6)                   array level 2 packed unaligned dcl 195 set ref 449*
verify                                                 builtin function         dcl 210 ref 638 817 988 1186 1438
w0                                     based           fixed bin(17,0)          level 2 dcl 214 set ref 586*
w1                        1            based           fixed bin(17,0)          level 2 dcl 214 set ref 586*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 8-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 8-55
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 10-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 10-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 10-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 10-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 10-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 10-27
ap                                     automatic       pointer                  dcl 7-3
call_offset                            internal static fixed bin(17,0)          initial dcl 9-78
db_ext_stat_$break_instructions        external static bit(36)                  array dcl 2-27
entry_offset                           internal static fixed bin(17,0)          initial dcl 9-78
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
itp                                    based           structure                level 1 dcl 8-18
itp_unsigned                           based           structure                level 1 dcl 8-43
its_unsigned                           based           structure                level 1 dcl 8-30
push_offset                            internal static fixed bin(17,0)          initial dcl 9-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 9-78
return_offset                          internal static fixed bin(17,0)          initial dcl 9-78
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 10-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 9-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 9-72

NAMES DECLARED BY EXPLICIT CONTEXT.
argl                            002057 constant        label                    dcl 428 ref 477
check1                          003220 constant        label                    dcl 545 ref 540
check_switch                    007517 constant        entry                    internal dcl 1131 ref 826 841
colon_join                      001575 constant        label                    dcl 403 ref 399
com1                            003046 constant        label                    dcl 534 ref 543 744
db_parse                        001147 constant        entry                    external dcl 11
depth_1                         001241 constant        label                    dcl 325 ref 625
depth_2                         001270 constant        label                    dcl 337 ref 561
depth_4                         001314 constant        label                    dcl 351 ref 1013
donel                           001441 constant        label                    dcl 377 ref 373 375
endl                            001437 constant        label                    dcl 376 ref 366
found3                          003305 constant        label                    dcl 557 ref 577
get_break_action_code           007265 constant        entry                    internal dcl 1061 ref 717 755 774
get_char                        010260 constant        entry                    internal dcl 1177 ref 325 337 351 405 424 725 753
                                                                                  890 957 1210 1218
got_seg                         004703 constant        label                    dcl 746 ref 742
is_name                         007237 constant        entry                    internal dcl 1051 ref 406 410 879 991
label_1                         000022 constant        label                    array(0:17) dcl 359 ref 330
label_2                         000000 constant        label                    array(0:17) dcl 359 ref 339
label_3                         000044 constant        label                    array(0:17) dcl 400 ref 353
list_arg                        005246 constant        label                    dcl 802 ref 390
make_call                       002331 constant        label                    dcl 457 ref 424 426
make_desc                       002263 constant        label                    dcl 449 ref 443
namel                           002530 constant        label                    dcl 494 ref 975
next                            010643 constant        label                    dcl 1256 ref 1221
no_comm                         006011 constant        label                    dcl 871 ref 635
nost                            005127 constant        label                    dcl 784 ref 787 788
offset1                         006425 constant        label                    dcl 944 ref 909
offsetl                         001340 constant        label                    dcl 359 ref 912
parse_parameter                 010724 constant        entry                    internal dcl 1280 ref 970
parse_print                     010342 constant        entry                    internal dcl 1202 ref 1018
parse_source                    011252 constant        entry                    internal dcl 1339 ref 971
print                           007040 constant        label                    dcl 1023 ref 325 337 351 1021
relative_offset                 006430 constant        label                    dcl 950 ref 385 601 915 945
rskip                           003556 constant        label                    dcl 617 ref 421 431 473 503 535 587 651 766 785 937
                                                                                  1010 1126 1169 1246 1264
set_data_ptr                    011517 constant        entry                    internal dcl 1375 ref 964 978 1002
set_stack                       003725 constant        label                    dcl 648 ref 641
skip                            003562 constant        label                    dcl 622 ref 469 718 722 727 751 761 772 775 779 814
                                                                                  831 835 865 868 874 888 901 925 1023 1034 1047
                                                                                  1139 1240
stack_trace                     011714 constant        entry                    internal dcl 1426 ref 644
star1                           003433 constant        label                    dcl 591 ref 488
switch_err                      005771 constant        label                    dcl 867 ref 828 843 846 852
sym_err                         007570 constant        entry                    internal dcl 1147 ref 392 446
syntax_error                    003533 constant        label                    dcl 608 ref 403 405 485 498 605 606 607 680 886 890
                                                                                  892 896 908 974 1090 1158 1226 1231
type                            007443 constant        entry                    internal dcl 1097 ref 330 339 353 365 643 1055

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13306       13554   12566       13316
Length     14404   12566       246         613     517          76

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_parse                            984 external procedure  is an external procedure.  
is_name                                 internal procedure  shares stack frame of external procedure db_parse.  
get_break_action_code                   internal procedure  shares stack frame of external procedure db_parse.  
type                                    internal procedure  shares stack frame of external procedure db_parse.  
check_switch                            internal procedure  shares stack frame of external procedure db_parse.  
sym_err                                 internal procedure  shares stack frame of external procedure db_parse.  
get_char                                internal procedure  shares stack frame of external procedure db_parse.  
parse_print                             internal procedure  shares stack frame of external procedure db_parse.  
parse_parameter                         internal procedure  shares stack frame of external procedure db_parse.  
parse_source                            internal procedure  shares stack frame of external procedure db_parse.  
set_data_ptr                            internal procedure  shares stack frame of external procedure db_parse.  
stack_trace                             internal procedure  shares stack frame of external procedure db_parse.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 data_ptr                    db_parse
000012 offset                      db_parse
000013 stack_depth                 db_parse
000014 data_id                     db_parse
000015 input_type                  db_parse
000016 data_format                 db_parse
000020 err_mess                    db_parse
000070 desc_area                   db_parse
000103 dummy_desc                  db_parse
000104 return_desc                 db_parse

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_parse                 000100 continue                    db_parse
                         000101 break_action_code           db_parse
                         000102 break_data_len              db_parse
                         000103 break_data_line             db_parse
                         000176 break_return                db_parse
                         000200 reg_val                     db_parse
                         000202 temp_reg_val                db_parse
                         000204 goto_label                  db_parse
                         000210 err_no_linkage              db_parse
                         000211 err_no_stack                db_parse
                         000212 err_no_sym_tab              db_parse
                         000213 err_no_static               db_parse
                         000214 code35                      db_parse
                         000215 fboff                       db_parse
                         000216 code                        db_parse
                         000217 d_type                      db_parse
                         000220 itemp                       db_parse
                         000221 max_stack                   db_parse
                         000222 new_type                    db_parse
                         000223 line_number                 db_parse
                         000224 pc                          db_parse
                         000225 i                           db_parse
                         000226 j                           db_parse
                         000227 temp1                       db_parse
                         000230 ct                          db_parse
                         000231 nv                          db_parse
                         000232 lin                         db_parse
                         000233 ill                         db_parse
                         000234 size                        db_parse
                         000235 scale                       db_parse
                         000236 ndims                       db_parse
                         000237 exec                        db_parse
                         000240 offset_incr                 db_parse
                         000241 dol                         db_parse
                         000242 max_size                    db_parse
                         000244 arglist                     db_parse
                         000316 pp                          db_parse
                         000320 ilp                         db_parse
                         000322 tp                          db_parse
                         000324 tpp                         db_parse
                         000326 switch                      db_parse
                         000327 il                          db_parse
                         000370 reg_name                    db_parse
                         000371 sym_name                    db_parse
                         000414 c1                          db_parse
                         000415 c2                          db_parse
                         000416 dir_name                    db_parse
                         000470 pathname                    db_parse
                         000542 ent_name                    db_parse
                         000552 ref_name                    db_parse
                         000562 cmc                         db_parse
                         000563 char                        db_parse
                         000564 attach                      db_parse
                         000565 open                        db_parse
                         000566 dec_default                 db_parse
                         000567 switch_name                 db_parse
                         000577 entry_name                  db_parse
                         000610 desc_ptr                    db_parse
                         000612 cond_info                   db_parse
                         000644 com_auto_ptr                db_parse
                         000646 com_stat_ptr                db_parse
                         000650 sntp                        db_parse
                         000652 sb                          db_parse
                         000654 sp                          db_parse
                         000674 t                           is_name
                         000726 mess                        sym_err
                         000762 i                           get_char
                         000772 i                           parse_print
                         000773 size                        parse_print
                         000774 have_mode                   parse_print
                         000775 have_size                   parse_print
                         000776 have_count                  parse_print
                         001032 i                           stack_trace
                         001033 start                       stack_trace
                         001034 last                        stack_trace
                         001035 ent_name                    stack_trace
                         001046 trace_snt                   stack_trace
                         001156 trace_snt_ptr               stack_trace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          tra_ext_2
shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$cp                        cu_$gen_call                  cv_oct_check_
db_assign                     db_break$global               db_break$print_bseg           db_break$print_default
db_break$set_break            db_break$set_default          db_break$set_skips            db_break$single
db_break$sub_global           db_fill_snt                   db_fill_snt$proc_ptr          db_find_mc
db_get_count                  db_get_count$dec              db_get_count$double           db_get_sym
db_parse_arg                  db_parse_arg$ptr_offset       db_parse_condition$set        db_print
db_regs$assign                db_regs$get                   db_regs$print                 db_sym
decode_descriptor_            expand_path_                  find_condition_info_          hcs_$fs_get_path_name
hcs_$fs_get_seg_ptr           hcs_$initiate                 hcs_$make_ptr                 ioa_$ioa_stream
ioa_$rsnnl                    iox_$attach_ioname            iox_$close                    iox_$detach_iocb
iox_$find_iocb                iox_$open                     is_condition_frame_           list_arg_
stu_$get_location             stu_$get_runtime_location

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_ext_stat_$db_ext_stat_     error_table_$segknown




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 001142        60 001154        61 001156        62 001160        63 001162       193 001164       298 001166
    300 001172       303 001175       304 001177       305 001201       306 001203       308 001210       311 001213
    312 001217       313 001220       314 001222       315 001224       316 001226       317 001230       320 001232
    321 001234       322 001236       325 001241       328 001246       329 001247       330 001251       337 001270
    339 001275       351 001314       353 001321       359 001340       363 001341       364 001351       365 001355
    366 001371       367 001406       368 001412       369 001414       370 001420       371 001421       372 001423
    373 001432       374 001434       375 001435       376 001437       377 001441       379 001453       380 001455
    381 001456       382 001527       383 001554       384 001556       385 001560       387 001561       388 001563
    389 001565       390 001567       392 001570       397 001571       399 001572       400 001573       403 001575
    405 001602       406 001614       407 001642       408 001644       409 001652       410 001657       411 001706
    412 001710       413 001717       414 001720       415 001723       417 001725       418 001756       419 001764
    420 002015       421 002040       424 002041       425 002050       426 002051       427 002056       428 002057
    429 002060       430 002064       431 002110       434 002111       435 002137       436 002145       437 002152
    438 002155       439 002166       440 002236       441 002240       442 002243       443 002245       445 002246
    446 002260       448 002261       449 002263       450 002275       451 002300       452 002304       453 002305
    454 002307       455 002317       456 002327       457 002331       458 002341       459 002346       460 002350
    461 002355       463 002360       464 002364       466 002366       467 002372       468 002404       469 002410
    471 002411       472 002413       473 002440       475 002441       476 002451       477 002471       482 002472
    484 002475       485 002514       486 002521       487 002525       488 002527       494 002530       497 002545
    498 002547       499 002553       500 002611       501 002614       502 002620       503 002641       505 002642
    506 002645       507 002675       508 002677       509 002702       511 002705       512 002716       514 002717
    518 002724       519 002735       520 002736       521 002744       522 002751       523 002752       525 002755
    526 002766       528 003002       529 003006       530 003011       532 003013       533 003044       534 003046
    535 003071       537 003072       538 003113       539 003117       540 003147       542 003150       543 003213
    545 003220       547 003223       548 003230       549 003234       550 003245       552 003260       553 003263
    554 003273       555 003300       556 003303       557 003305       558 003307       560 003311       561 003313
    564 003314       566 003317       567 003322       568 003324       569 003326       570 003330       571 003347
    572 003352       573 003355       574 003360       575 003362       576 003364       577 003366       582 003367
    585 003370       586 003375       587 003425       589 003426       590 003431       591 003433       592 003436
    593 003441       594 003443       595 003445       596 003447       597 003466       598 003516       599 003522
    600 003525       601 003527       605 003530       606 003531       607 003532       608 003533       617 003556
    620 003561       622 003562       623 003577       624 003600       625 003601       627 003604       628 003606
    635 003607       637 003613       638 003620       639 003630       640 003650       641 003653       643 003654
    644 003670       645 003676       646 003702       647 003722       648 003725       649 003731       650 003755
    651 003760       653 003761       654 003773       655 004021       656 004025       657 004027       658 004031
    659 004032       660 004033       661 004037       663 004044       664 004050       665 004062       666 004066
    668 004067       669 004071       670 004076       672 004155       673 004156       674 004160       675 004165
    677 004250       678 004251       679 004253       680 004265       682 004272       684 004273       685 004275
    686 004302       687 004306       688 004307       689 004312       690 004313       691 004315       692 004316
    694 004320       695 004352       697 004355       698 004357       700 004360       701 004362       702 004365
    704 004366       705 004370       706 004373       707 004377       708 004403       709 004410       710 004414
    711 004416       712 004423       713 004427       714 004433       716 004434       717 004437       718 004440
    720 004442       721 004460       722 004465       724 004466       725 004470       726 004500       727 004505
    729 004506       730 004514       731 004537       732 004541       733 004545       735 004546       736 004552
    737 004555       740 004557       741 004607       742 004630       743 004634       744 004677       746 004703
    747 004712       749 004713       750 004715       751 004725       753 004726       754 004740       755 004742
    756 004743       757 004745       758 004763       761 004767       763 004770       764 005005       765 005007
    766 005030       769 005031       770 005035       771 005055       772 005066       774 005067       775 005070
    777 005072       778 005112       779 005117       782 005120       783 005122       784 005127       785 005150
    787 005151       788 005156       789 005162       790 005165       791 005172       792 005174       793 005175
    794 005201       795 005221       796 005233       797 005235       798 005236       799 005242       800 005244
    802 005246       803 005263       804 005264       807 005305       811 005326       812 005330       813 005332
    814 005344       816 005350       817 005352       818 005370       819 005372       821 005375       823 005413
    824 005417       825 005422       826 005427       827 005430       828 005451       829 005453       830 005460
    831 005505       833 005506       834 005512       835 005542       837 005543       839 005544       840 005553
    841 005556       842 005557       843 005600       844 005602       845 005607       846 005642       847 005644
    850 005646       851 005653       852 005672       853 005674       857 005676       858 005717       859 005740
    860 005746       861 005752       862 005755       863 005765       865 005770       867 005771       868 006010
    871 006011       874 006031       879 006032       881 006062       882 006064       883 006073       884 006113
    885 006115       886 006123       887 006134       888 006150       890 006151       891 006162       892 006177
    893 006202       894 006207       896 006236       899 006241       900 006243       901 006261       906 006262
    908 006267       909 006272       910 006300       911 006302       912 006304       914 006305       914 006320
    915 006321       921 006322       923 006342       924 006344       925 006362       930 006363       933 006412
    934 006414       935 006417       937 006421       942 006422       944 006425       945 006427       950 006430
    955 006431       956 006433       957 006440       960 006447       961 006453       962 006460       963 006466
    964 006505       965 006513       967 006514       968 006527       969 006530       970 006535       971 006544
    972 006551       973 006553       974 006555       975 006560       978 006561       979 006563       980 006571
    983 006573       986 006574       987 006617       988 006644       990 006671       991 006673       992 006724
    993 006726       994 006735       995 006737       996 006755       997 006757       999 006760      1000 006761
   1001 006763      1002 006766      1006 006774      1008 006775      1009 006777      1010 007034      1013 007035
   1018 007036      1021 007037      1023 007040      1027 007052      1028 007054      1029 007071      1030 007104
   1031 007117      1033 007122      1034 007166      1038 007167      1040 007170      1044 007173      1045 007201
   1046 007203      1047 007236      1051 007237      1055 007241      1056 007251      1057 007261      1061 007265
   1063 007266      1066 007271      1069 007274      1071 007303      1073 007310      1075 007315      1077 007322
   1079 007324      1080 007326      1081 007332      1082 007336      1083 007342      1084 007344      1086 007345
   1088 007347      1089 007351      1090 007372      1091 007375      1092 007420      1094 007421      1095 007442
   1097 007443      1124 007445      1125 007464      1126 007516      1131 007517      1136 007520      1136 007532
   1137 007533      1138 007542      1139 007567      1147 007570      1151 007571      1152 007572      1153 007641
   1154 007662      1155 007703      1156 007724      1157 007751      1158 007776      1159 010001      1160 010025
   1161 010052      1162 010077      1163 010124      1164 010151      1165 010176      1166 010224      1168 010234
   1169 010257      1177 010260      1184 010262      1185 010264      1186 010266      1188 010304      1189 010305
   1190 010310      1191 010315      1192 010331      1193 010332      1196 010334      1202 010342      1208 010343
   1210 010346      1213 010356      1214 010362      1215 010364      1216 010366      1217 010406      1218 010410
   1219 010415      1220 010421      1221 010423      1226 010424      1230 010425      1231 010436      1232 010440
   1233 010454      1234 010461      1235 010463      1236 010465      1240 010466      1241 010473      1243 010512
   1244 010514      1245 010517      1246 010551      1248 010552      1249 010562      1250 010567      1251 010603
   1252 010612      1253 010635      1254 010637      1256 010643      1261 010644      1262 010646      1263 010665
   1264 010705      1266 010706      1267 010721      1269 010723      1280 010724      1285 010726      1286 010747
   1288 010760      1290 010771      1291 010777      1292 011027      1293 011032      1295 011033      1296 011057
   1297 011067      1299 011072      1300 011102      1301 011104      1302 011112      1303 011114      1304 011124
   1305 011131      1306 011132      1307 011134      1308 011140      1309 011145      1310 011152      1311 011157
   1312 011164      1313 011171      1314 011202      1315 011215      1316 011217      1317 011220      1318 011237
   1319 011246      1321 011250      1325 011251      1339 011252      1344 011254      1345 011275      1346 011310
   1347 011313      1349 011333      1350 011334      1351 011350      1352 011370      1353 011403      1355 011413
   1356 011415      1357 011417      1358 011423      1359 011425      1360 011454      1362 011455      1364 011457
   1365 011461      1366 011464      1367 011466      1371 011516      1375 011517      1379 011521      1380 011535
   1381 011537      1384 011547      1387 011554      1388 011555      1389 011557      1391 011567      1393 011606
   1395 011613      1398 011617      1400 011620      1401 011622      1403 011632      1405 011651      1407 011656
   1410 011662      1413 011663      1414 011711      1416 011713      1426 011714      1433 011715      1434 011717
   1435 011720      1437 011722      1438 011724      1439 011751      1440 012002      1441 012007      1442 012013
   1444 012020      1447 012045      1448 012055      1449 012070      1450 012104      1451 012121      1452 012125
   1453 012126      1454 012131      1457 012211      1459 012213


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
