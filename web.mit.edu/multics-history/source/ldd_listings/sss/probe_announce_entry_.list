	COMPILATION LISTING OF SEGMENT probe_announce_entry_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1233.5 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_announce_entry_:
       26   proc (P_probe_info_ptr);
       27 
       28   /* *	This procedure is used by the probe command and the breakpoint halt request
       29*   *	to announce why probe was entered, and what it all means. */
       30 
       31   /* Fixed halt message for already reset pause break 01/06/81 S. Herbst */
       32   /* Changed invocation banner to print full pathname 08/26/83 S. Herbst */
       33 
       34   dcl P_probe_info_ptr	pointer;
       35 
       36   dcl ilevel		fixed bin;
       37   dcl level_info		char (64) varying;
       38   dcl after_before_string	char (8);
       39   dcl block_name		char (256);
       40   dcl cond_name		char (32);
       41 
       42   dcl ioa_$ioa_switch	entry options (variable);
       43   dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
       44 			returns (char (256) varying);
       45   dcl probe_error_$malfunction
       46 			entry options (variable);
       47   dcl probe_line_number_	entry (pointer, 1 aligned like source_info)
       48 			returns (char (64));
       49   dcl probe_stack_trace_$condition_raised
       50 			entry (ptr, ptr, char (32));
       51   dcl probe_stack_trace_$where_source_info
       52 			entry (ptr, ptr, fixed bin, char (*));
       53 
       54   dcl BREAK_PLACE		(0:1) char (8) varying internal static
       55 			options (constant) init ("after", "before");
       56 
       57   dcl (character, fixed, ltrim, rel, rtrim)
       58 			builtin;
       59 				/*  */
       60   probe_info_ptr = P_probe_info_ptr;
       61 
       62   call probe_stack_trace_$where_source_info (probe_info_ptr,
       63        probe_info.ptr_to_initial_source,
       64        ilevel, block_name);
       65 
       66   if ilevel >= 0 then do;		/* make a description of our frame, if any */
       67       level_info = "(level ";
       68       level_info = level_info || ltrim (rtrim (character (ilevel)));
       69       level_info = level_info || ")";
       70     end;
       71 
       72     else level_info = "(no active frame)";
       73 
       74   if probe_info.return_method = RETURN_TO_FRAME then do;
       75       if ^probe_static_info.brief_sw then do;
       76 	if current_source.stmnt_map_entry_index >= 0
       77 	  then
       78 	       call ioa_$ioa_switch (probe_info.output_switch,
       79 		  "^a exited at ^a ^a.",
       80 		  block_name,
       81 		  probe_line_number_ (probe_info_ptr, current_source),
       82 		  level_info);
       83 	  else call ioa_$ioa_switch (probe_info.output_switch,
       84 		  "^a exited at offset ^o ^a.",
       85 		  block_name,
       86 		  fixed (rel (initial_source.instruction_ptr), 35, 0),
       87 		  level_info);
       88         end;
       89     end;
       90 
       91   else if probe_info.return_method = RETURN_TO_CONDITION then do;
       92       call probe_stack_trace_$condition_raised (probe_info_ptr,
       93 	 probe_info.ptr_to_initial_source, cond_name);
       94       if cond_name = ""
       95         then cond_name = "<<UNKNOWN>>";
       96 
       97       if current_source.stmnt_map_entry_index >= 0
       98         then
       99 	   call ioa_$ioa_switch (probe_info.output_switch,
      100 	        "Condition ^a raised at ^a of ^a ^a.",
      101 	        cond_name,
      102 	        probe_line_number_ (probe_info_ptr, current_source),
      103 	        block_name,
      104 	        level_info);
      105         else call ioa_$ioa_switch (probe_info.output_switch,
      106 	        "Condition ^a raised at ^a|^o ^a.",
      107 	        cond_name,
      108 	        block_name,
      109 	        fixed (rel (initial_source.instruction_ptr), 35, 0),
      110 	        level_info);
      111     end;
      112 
      113   else if probe_info.return_method = RETURN_TO_CALLER then do;
      114       if ^probe_static_info.brief_sw then do;
      115 	block_name =
      116 	     probe_block_name_ (probe_info_ptr,
      117 	     probe_info.ptr_to_initial_source,
      118 	     "1"b /* long: full pathname */);
      119 	call ioa_$ioa_switch (probe_info.output_switch, "Using ^a ^a.",
      120 	     block_name,
      121 	     level_info);
      122         end;
      123     end;
      124 
      125   else if probe_info.return_method = RETURN_TO_BREAK then do;
      126 
      127       if probe_info.break_slot_ptr -> break_slot.location = "0"b
      128         then /* pause, already reset */
      129 	   after_before_string = "before";
      130         else after_before_string =
      131 	        BREAK_PLACE (probe_info.break_slot_ptr -> break_slot.type);
      132 
      133       if probe_static_info.brief_sw
      134         then call ioa_$ioa_switch (probe_info.output_switch,
      135 	        "^[<<^;>>^]^a ^a",
      136 	        after_before_string = "before",
      137 	        block_name,
      138 	        probe_line_number_ (probe_info_ptr, initial_source));
      139         else call ioa_$ioa_switch (probe_info.output_switch,
      140 	        "Stopped ^a ^a of ^a. ^a",
      141 	        after_before_string,
      142 	        probe_line_number_ (probe_info_ptr, initial_source),
      143 	        block_name,
      144 	        level_info);
      145     end;
      146 
      147   else call probe_error_$malfunction (probe_info_ptr, 0,
      148 	  "Unusual return method ^d", probe_info.return_method);
      149   return;
      150 
      151   /*  */
      152 
      153   /*	INCLUDE FILES	*/
      154 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      155 
      156 
      157   /* ;;;;;;; */
      158 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      159 
      160 
      161   /* ;;;;;;; */
      162 
  3     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  3     2*
  3     3*  James R. Davis 2 July 79 */
  3     4 
  3     5 dcl 1 source_info based aligned,
  3     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  3     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  3     8       2 block_ptr ptr,				/* to runtime_block node */
  3     9       2 stack_ptr ptr,				/* to a stack frame */
  3    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  3    11       2 seg_info_ptr ptr;				/* to seg_info */
  3    12 
  3    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  3    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  3    15 
  3    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      163 
      164 
      165   /* ;;;;;;; */
      166 
  4     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  4     2*
  4     3*   25 June 79 JRDavis
  4     4*
  4     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  4     6*	correction per file.
  4     7**/
  4     8 
  4     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  4    10     2 language_type fixed bin,			/* language of source program */
  4    11     2 bits aligned,
  4    12       3 ignore_case bit (1) unal,
  4    13       3 bound_segment bit (1) unaligned,
  4    14       3 component bit (1) unaligned,
  4    15       3 pad bit (33) unal,
  4    16     2 names,					/* where to find it */
  4    17       3 directory_name character (168) unal,		/* what directory */
  4    18       3 entry_name character (32) unal,			/* what segment */
  4    19       3 segname character (32) unal,			/* procedure segname definition */
  4    20     2 identifier fixed bin (71),			/* time of object creation */
  4    21     2 pointers,					/* location of various parts of segment */
  4    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  4    23       3 original_source_ptr ptr unal,			/* to segment source map */
  4    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  4    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  4    26*						   bound ones, -> break_map !obsolete, I think! */
  4    27       3 chain ptr unal,				/* to entry for next component if bound */
  4    28       3 linkage_ptr ptr unal,				/* to linkage section */
  4    29     2 bounds aligned,				/* structure of bounds information */
  4    30       3 text_bounds,
  4    31         4 start fixed bin (35),
  4    32         4 end fixed bin (35),
  4    33       3 symbol_bounds,
  4    34         4 start fixed bin (35),
  4    35         4 end fixed bin (35),
  4    36     2 map_size fixed bin,				/* size of statement map */
  4    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  4    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  4    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  4    40     2 pad (1) fixed bin (35),
  4    41 
  4    42     2 nfiles fixed bin,
  4    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  4    44       3 file_pointers ptr unal,
  4    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  4    46 
  4    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      167 
      168 
      169   /* ;;;;;;; */
      170 
  5     1 /*	BEGIN INCLUDE FILE probe_info_constants.incl.pl1	*/
  5     2 /*	Created: 06/25/79 W. Olin Sibert		*/
  5     3 
  5     4 dcl (RETURN_TO_CALLER init (1),			/* return methods */
  5     5      RETURN_TO_FRAME init (2),
  5     6      RETURN_TO_CONDITION init (3),
  5     7      RETURN_TO_BREAK init (4)) fixed bin internal static options (constant);
  5     8 
  5     9 dcl (ENTRY_AT_CALL init (1),				/* entered by a call to probe */
  5    10      ENTRY_AT_BREAK init (2), 			/* entered by a call to probe$break */
  5    11      ENTRY_AT_HALT init (3)) fixed bin internal static options (constant); /* entered by a call to probe$halt */
  5    12 
  5    13 dcl (CONSOLE_INPUT init (1),
  5    14      BREAK_INPUT init (2),
  5    15      MACRO_INPUT init (3)) fixed bin internal static options (constant);
  5    16 
  5    17 /*	END INCLUDE FILE probe_info_constants.incl.pl1	*/
      171 
      172 
      173   /* ;;;;;;; */
      174 
  6     1 /* BEGIN INCLUDE FILE ...  probe_break_slot.incl.pl1
  6     2*
  6     3*   This is separate from probe_break_info.incl.pl1 because many programs
  6     4*   need to get at a break_slot, but don't deserve to see the rest of that information
  6     5*
  6     6**/
  6     7 
  6     8 dcl 1 break_slot based (bsp) aligned,			/* describes (and handles) each probe break */
  6     9     2 item_type fixed bin,				/* 0 -> break_slot type code */
  6    10     2 breakmap_header_offset bit (18) unal,		/* to break map header, chain is not used */
  6    11     2 statement_item_offset bit (18) unal,
  6    12     2 size fixed bin,				/* number of words in the break_slot */
  6    13     2 sequence (0:7),				/* "before" or "after" instructions to "trap" the break */
  6    14       3 offset bit (18) unaligned,			/* address portion, some patched */
  6    15       3 skip bit (18) unaligned,			/* op code portion */
  6    16     2 old_instruction bit (36) aligned,			/* instruction that was replaced by break */
  6    17     2 symbol_block_offset bit (18) unal,		/*  for containing block */
  6    18     2 location bit (18) unal,				/* offset of instruction that was replaced by break */
  6    19     2 type fixed bin,				/* 0 -> after, 1 -> before */
  6    20     2 count fixed bin,				/* number of characters in command list */
  6    21     2 command_list character (0 refer (break_slot.count));	/* command list associated with break */
  6    22 
  6    23 dcl bsp ptr;
  6    24 
  6    25 dcl (BREAK_AFTER init (0),
  6    26      BREAK_BEFORE init (1),
  6    27      BREAK_AT init (2)) fixed bin internal static options (constant);
  6    28 
  6    29 dcl  PLACE (0:2) char (8) aligned internal static options (constant) init ("after", "before", "at");
  6    30 
  6    31 /* END INCLUDE FILE ... probe_break_slot.incl.pl1 */
      175 
      176 
      177   /* ;;;;;;; */
      178 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  7     2 
  7     3 /* format: off */
  7     4 
  7     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  7     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  7     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  7     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  7    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to add constants for the translator_id field in the stack_frame
  7    15*     structure.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  7    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  7    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  7    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  7    23 
  7    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  7    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  7    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  7    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  7    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  7    29 
  7    30 
  7    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  7    32 
  7    33 dcl  stack_frame_min_length fixed bin static init(48);
  7    34 
  7    35 
  7    36 dcl 1 stack_frame based(sp) aligned,
  7    37     2 pointer_registers(0 : 7) ptr,
  7    38     2 prev_sp pointer,
  7    39     2 next_sp pointer,
  7    40     2 return_ptr pointer,
  7    41     2 entry_ptr pointer,
  7    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  7    43     2 arg_ptr pointer,
  7    44     2 static_ptr ptr unaligned,
  7    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  7    46     2 on_unit_relp1 bit(18) unaligned,
  7    47     2 on_unit_relp2 bit(18) unaligned,
  7    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  7    49*						   0 => PL/I version II
  7    50*						   1 => ALM
  7    51*						   2 => PL/I version I   
  7    52*						   3 => signal caller frame
  7    53*						   4 => signaller frame */
  7    54     2 operator_return_offset bit(18) unaligned,
  7    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  7    56     2 a bit(36),					/* accumulator */
  7    57     2 q bit(36),					/* q-register */
  7    58     2 e bit(36),					/* exponent */
  7    59     2 timer bit(27) unaligned,				/* timer */
  7    60     2 pad bit(6) unaligned,
  7    61     2 ring_alarm_reg bit(3) unaligned;
  7    62 
  7    63 
  7    64 dcl 1 stack_frame_flags based(sp) aligned,
  7    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  7    66     2 xx0 bit(22) unal,
  7    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  7    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  7    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  7    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  7    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  7    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  7    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  7    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  7    75     2 xx0a bit(6) unal,
  7    76     2 xx1 fixed bin,
  7    77     2 xx2 fixed bin,
  7    78     2 xx3 bit(25) unal,
  7    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  7    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  7    81     2 xx3a bit(9) unaligned,
  7    82     2 xx4(9) bit(72) aligned,
  7    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  7    84*						*  operator puts a pointer to the base of
  7    85*						*  the calling procedure here. (text base ptr)  */
  7    86     2 xx5 bit(72) aligned,
  7    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  7    88 
  7    89 /* format: on */
  7    90 
  7    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      179 
      180 
      181   end;				/* external procedure probe_announce_entry_ */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1225.3  probe_announce_entry_.pl1         >spec>install>MR12.2-1194>probe_announce_entry_.pl1
155          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
159          2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
163          3    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
167          4    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
171          5    11/26/79  1320.9  probe_info_constants.incl.pl1     >ldd>include>probe_info_constants.incl.pl1
175          6    07/15/80  1728.8  probe_break_slot.incl.pl1         >ldd>include>probe_break_slot.incl.pl1
179          7    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAK_PLACE                     000000 constant        varying char(8)          initial array dcl 54 ref 130
P_probe_info_ptr                       parameter       pointer                  dcl 34 ref 25 60
RETURN_TO_BREAK                        constant        fixed bin(17,0)          initial dcl 5-4 ref 125
RETURN_TO_CALLER                       constant        fixed bin(17,0)          initial dcl 5-4 ref 113
RETURN_TO_CONDITION                    constant        fixed bin(17,0)          initial dcl 5-4 ref 91
RETURN_TO_FRAME                        constant        fixed bin(17,0)          initial dcl 5-4 ref 74
after_before_string             000122 automatic       char(8)                  packed unaligned dcl 38 set ref 127* 130* 133 139*
block_name                      000124 automatic       char(256)                packed unaligned dcl 39 set ref 62* 76* 83* 97* 105*
                                                                                  115* 119* 133* 139*
break_info               50            based           structure                level 2 dcl 1-18
break_slot                             based           structure                level 1 dcl 6-8
break_slot_ptr           50            based           pointer                  level 3 dcl 1-18 ref 127 130
brief_sw                 36            based           bit(1)                   level 3 packed packed unaligned dcl 2-8 ref 75 114
                                                                                  133
character                                              builtin function         dcl 57 ref 68
cond_name                       000224 automatic       char(32)                 packed unaligned dcl 40 set ref 92* 94 94* 97* 105*
current_source                         based           structure                level 1 dcl 3-13 set ref 76* 76* 97* 97*
fixed                                                  builtin function         dcl 57 ref 83 83 105 105
ilevel                          000100 automatic       fixed bin(17,0)          dcl 36 set ref 62* 66 68
initial_source                         based           structure                level 1 dcl 3-14 set ref 133* 133* 139* 139*
instruction_ptr           2            based           pointer                  level 2 dcl 3-14 set ref 83 83 105 105
io_switches              66            based           structure                level 2 dcl 1-18
ioa_$ioa_switch                 000010 constant        entry                    external dcl 42 ref 76 83 97 105 119 133 139
level_info                      000101 automatic       varying char(64)         dcl 37 set ref 67* 68* 68 69* 69 72* 76* 83* 97*
                                                                                  105* 119* 139*
location                 14(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-8 ref 127
ltrim                                                  builtin function         dcl 57 ref 68
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 76* 83* 97* 105* 119* 133*
                                                                                  139*
probe_block_name_               000012 constant        entry                    external dcl 43 ref 115
probe_error_$malfunction        000014 constant        entry                    external dcl 45 ref 147
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000234 automatic       pointer                  dcl 1-86 set ref 60* 62* 62 74 75 76 76 76* 76 76*
                                                                                  76 83 83 83 91 92* 92 97 97 97* 97 97* 97 105 105
                                                                                  105 113 114 115* 115 119 125 127 130 133 133 133*
                                                                                  133 133* 133 139 139* 139 139* 139 147* 147
probe_line_number_              000016 constant        entry                    external dcl 47 ref 76 76 97 97 133 133 139 139
probe_stack_trace_$condition_raised
                                000020 constant        entry                    external dcl 49 ref 92
probe_stack_trace_$where_source_info
                                000022 constant        entry                    external dcl 51 ref 62
probe_static_info                      based           structure                level 1 dcl 2-8
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 76 76 76 97 97 97
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 set ref 62* 83 83 92* 105 105 115*
                                                                                  133 133 139 139
random_info              17            based           structure                level 2 dcl 1-18
rel                                                    builtin function         dcl 57 ref 83 83 105 105
return_method            22            based           fixed bin(17,0)          level 3 dcl 1-18 set ref 74 91 113 125 147*
rtrim                                                  builtin function         dcl 57 ref 68
source_info                            based           structure                level 1 dcl 3-5
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 75 114
                                                                                  133
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 3-13 set ref 76 97
switches                 36            based           structure                level 2 dcl 2-8
type                     15            based           fixed bin(17,0)          level 2 dcl 6-8 ref 130

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BREAK_AFTER                            internal static fixed bin(17,0)          initial dcl 6-25
BREAK_AT                               internal static fixed bin(17,0)          initial dcl 6-25
BREAK_BEFORE                           internal static fixed bin(17,0)          initial dcl 6-25
BREAK_INPUT                            internal static fixed bin(17,0)          initial dcl 5-13
CONSOLE_INPUT                          internal static fixed bin(17,0)          initial dcl 5-13
ENTRY_AT_BREAK                         internal static fixed bin(17,0)          initial dcl 5-9
ENTRY_AT_CALL                          internal static fixed bin(17,0)          initial dcl 5-9
ENTRY_AT_HALT                          internal static fixed bin(17,0)          initial dcl 5-9
MACRO_INPUT                            internal static fixed bin(17,0)          initial dcl 5-13
PLACE                                  internal static char(8)                  initial array dcl 6-29
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 7-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 7-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 7-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 7-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 7-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 7-27
bsp                                    automatic       pointer                  dcl 6-23
expression_area                        based           area(1024)               dcl 1-95
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
scratch_area                           based           area(1024)               dcl 1-92
seg_info                               based           structure                level 1 dcl 4-9
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 4-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 7-31
stack_frame                            based           structure                level 1 dcl 7-36
stack_frame_flags                      based           structure                level 1 dcl 7-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 7-33
work_area                              based           area(1024)               dcl 1-94

NAME DECLARED BY EXPLICIT CONTEXT.
probe_announce_entry_           000133 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1206        1232    1067        1216
Length      1564    1067        24         315     116           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_announce_entry_               317 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_announce_entry_    000100 ilevel                      probe_announce_entry_
                         000101 level_info                  probe_announce_entry_
                         000122 after_before_string         probe_announce_entry_
                         000124 block_name                  probe_announce_entry_
                         000224 cond_name                   probe_announce_entry_
                         000234 probe_info_ptr              probe_announce_entry_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$ioa_switch               probe_block_name_             probe_error_$malfunction      probe_line_number_
probe_stack_trace_$condition_raised                         probe_stack_trace_$where_source_info

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000130        60 000140        62 000144        66 000167        67 000171        68 000175        69 000243
     70 000252        72 000253        74 000260        75 000264        76 000270        83 000346        89 000406
     91 000407        92 000411        94 000424        97 000433       105 000513       111 000557       113 000560
    114 000562       115 000566       119 000611       123 000643       125 000644       127 000646       130 000655
    133 000664       139 000747       145 001026       147 001027       149 001063


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
