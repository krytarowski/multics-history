	COMPILATION LISTING OF SEGMENT rcm_put_record_by_id
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0959.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*        This module stores records in a record collection. The location to 
       10*   put the record is specified explicitly using the p_related_record_id.
       11*   The caller supplies a pointer to a simple_typed_vector or an array of
       12*   pointers to simple_typed_vectors. These vectors are converted into bit
       13*   strings for storage by collection_manager_$allocate_element. Multiple
       14*   records are stored adjacently if possible. The cursor defines the page
       15*   file and collection into which the record(s) are to be stored, and the
       16*   cursor is positioned to the last record put, if successful; otherwise
       17*   the position is left unchanged. If an error occurs while storing a
       18*   record, records which have already been stored are deleted.
       19*        The p_related_record_id identifies an existing record or a canonical
       20*   null location ("0"b). If null, the record(s) is placed at the end of the 
       21*   collection. Otherwise, the control interval that p_related_record_id 
       22*   identifies is used to store the new record(s). If there is no room, the
       23*   new record(s) is placed at the end of the collection.
       24**/
       25 
       26 /* HISTORY:
       27*Written by Matthew Pierret.
       28*Modified:
       29*04/15/82 by Matthew Pierret: Added array_by_* entries.
       30*04/23/82 by Matthew Pierret: Changed dmu_* calls to data_mgmt_util_$* calls.
       31*09/07/82 by Matthew Pierret: Changed to use rm_get_opening_info.
       32*12/22/82 by Lindsey Spratt:  Changed to handle large records.
       33*01/04/83 by Lindsey Spratt:  Fixed to cleanup allocated records and storage.
       34*03/16/83 by Matthew Pierret: Changed to receive record_collection_opening_info
       35*            structure from rm_get_opening_info. Changed to get work area from
       36*            get_dm_free_area_ instead of dm_data_$area_ptr.
       37*            Changed to not attempt to roll back. Moved record_cursor type check
       38*            before version check.
       39*03/24/83 by Lindsey Spratt:  Removed the field_table include file, added local
       40*	  dcl of field_table_ptr.
       41*03/28/83 by Lindsey Spratt:  Fixed test to set dm_work_area_ptr to test for "=
       42*	  null" rather than "^= null".
       43*03/29/83 by Lindsey Spratt:  Changed to always call ERROR_RETURN on errors.
       44*07/28/83 by Matthew Pierret: Changed name from rm_put_record_by_id to
       45*            rcm_put_record_by_id, and all rm_ prefixes to rcm_.
       46*04/12/84 by Lee Baldwin:  Renamed the parameters to coincide with all the other
       47*            rcm_XX routines.
       48*06/12/84 by Matthew Pierret: Renamed cm_$allocate_element to cm_$put and
       49*            data_mgmt_util_ to data_format_util_.
       50*09/27/84 by Maggie Sharpe:  Cleaned up dcls; changed the call to CHECK_VERSION
       51*            on line 164 to pass parameters by reference instead of value.
       52**/
       53 /* format: style2,ind3 */
       54 
       55 /* format: style2,ind3 */
       56 
       57 rcm_put_record_by_id:
       58    proc ();
       59 
       60       call
       61          sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0, "^/^a$^a is not a valid entrypoint",
       62          myname, myname);
       63 
       64 
       65 /* START OF DECLARATIONS */
       66 /* Parameter */
       67 
       68       dcl	    p_related_record_id    bit (36) aligned;
       69       dcl	    p_simple_typed_vector_ptr
       70 			       ptr;
       71       dcl	    p_typed_vector_array_ptr
       72 			       ptr;
       73       dcl	    p_minimum_free_space   fixed bin (35);	/* not implemented */
       74       dcl	    p_record_cursor_ptr    ptr;
       75       dcl	    p_element_id_list_ptr  ptr;
       76       dcl	    p_record_id	       bit (36) aligned;
       77       dcl	    p_code	       fixed bin (35);
       78 
       79 /* Automatic */
       80 
       81       dcl	    returned_buffer_length fixed bin (35);
       82       dcl	    local_record_string_buffer
       83 			       char (4096);
       84       dcl	    put_array_of_records   bit (1) aligned init ("0"b);
       85       dcl	    put_only_a_single_record
       86 			       bit (1) aligned;
       87       dcl	    record_id	       bit (36) aligned;
       88       dcl	    record_idx	       fixed bin;
       89       dcl	    field_table_ptr	       ptr init (null);
       90       dcl	    record_string_ptr      ptr;
       91       dcl	    record_string_buffer_ptr
       92 			       ptr init (null);
       93       dcl	    record_string_buffer_length
       94 			       fixed bin (35) init (0);
       95 
       96 /* Based */
       97 
       98       dcl	    dm_work_area	       area based (dm_work_area_ptr);
       99 
      100       dcl	    1 record_string	       based (record_string_ptr),
      101 	      2 length	       fixed bin (35),
      102 	      2 contents	       bit (0 refer (record_string.length));
      103 
      104       dcl	    record_string_buffer   bit (record_string_buffer_length) based (record_string_buffer_ptr);
      105 
      106 /* Builtin */
      107 
      108       dcl	    (null, length, addr, unspec, hbound)
      109 			       builtin;
      110 
      111 /* Condition */
      112 
      113       dcl	    cleanup	       condition;
      114 
      115 
      116 /* Constant */
      117 
      118       dcl	    myname	       init ("rcm_put_record_by_id") char (32) varying int static options (constant);
      119 
      120 
      121 /* Entry */
      122 
      123       dcl	    rcm_get_opening_info   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      124       dcl	    sub_err_	       entry () options (variable);
      125       dcl	    data_format_util_$cv_vector_to_string
      126 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35), fixed bin (35));
      127       dcl	    get_dm_free_area_      entry () returns (ptr);
      128 
      129 /* External */
      130 
      131       dcl	    (
      132 	    error_table_$unimplemented_version,
      133 	    dm_error_$programming_error,
      134 	    dm_error_$wrong_cursor_type
      135 	    )		       ext fixed bin (35);
      136 
      137 /* Static */
      138 
      139       dcl	    dm_work_area_ptr       ptr internal static init (null);
      140 
      141 /* END OF DECLARATIONS */
      142 
      143 single:
      144    entry (p_related_record_id, p_simple_typed_vector_ptr, p_minimum_free_space, p_record_cursor_ptr, p_record_id, p_code);
      145 
      146       put_only_a_single_record = "1"b;
      147       simple_typed_vector_ptr = p_simple_typed_vector_ptr;
      148       record_id = p_related_record_id;
      149       p_record_id = "0"b;
      150       goto JOIN;
      151 
      152 
      153 array:
      154    entry (p_related_record_id, p_typed_vector_array_ptr, p_minimum_free_space, p_record_cursor_ptr, p_element_id_list_ptr,
      155       p_code);
      156 
      157       typed_vector_array_ptr = p_typed_vector_array_ptr;
      158       call CHECK_VERSION ((typed_vector_array.version), (TYPED_VECTOR_ARRAY_VERSION_2), "typed_vector_array");
      159 
      160       simple_typed_vector_ptr = typed_vector_array.vector_slot (1);
      161       record_id = p_related_record_id;
      162       put_array_of_records = "1"b;
      163       element_id_list_ptr = p_element_id_list_ptr;
      164       call CHECK_VERSION (element_id_list.version, ELEMENT_ID_LIST_VERSION_1, "element_id_list");
      165 
      166       goto JOIN;
      167 
      168 JOIN:
      169       p_code = 0;
      170 
      171       record_cursor_ptr = p_record_cursor_ptr;
      172 
      173       if record_cursor.type ^= RECORD_CURSOR_TYPE
      174       then call
      175 	    sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      176 	    "^/Expected record cursor, type ^d; received type ^d.", RECORD_CURSOR_TYPE, record_cursor.type);
      177       call CHECK_VERSION ((record_cursor.version), (RECORD_CURSOR_VERSION_2), "record_cursor");
      178 
      179       call
      180          rcm_get_opening_info (record_cursor.file_opening_id, record_cursor.collection_id,
      181          record_collection_opening_info_ptr, p_code);
      182       if p_code ^= 0
      183       then call ERROR_RETURN;
      184 
      185       call
      186          CHECK_VERSION_CHAR_8 (record_collection_opening_info.version, RECORD_COLLECTION_OPENING_INFO_VERSION_1,
      187          "record_collection_opening_info");
      188 
      189       field_table_ptr = record_collection_opening_info.field_table_ptr;
      190 
      191       record_string_buffer_ptr = addr (local_record_string_buffer);
      192       record_string_buffer_length = length (unspec (local_record_string_buffer));
      193 
      194       if dm_work_area_ptr = null
      195       then dm_work_area_ptr = get_dm_free_area_ ();
      196 
      197       on cleanup call FINISH ();
      198 
      199       call
      200          data_format_util_$cv_vector_to_string (field_table_ptr, simple_typed_vector_ptr, record_string_buffer_ptr,
      201          record_string_buffer_length, dm_work_area_ptr, record_string_ptr, returned_buffer_length, p_code);
      202       if p_code ^= 0
      203       then call ERROR_RETURN;
      204 
      205       call
      206          collection_manager_$put (record_cursor.file_opening_id, record_cursor.collection_id,
      207          addr (record_string.contents), record_string.length, record_id, (0), p_code);
      208       if p_code ^= 0
      209       then call ERROR_RETURN ();
      210 
      211 
      212       if record_string_ptr ^= record_string_buffer_ptr
      213       then
      214          do;
      215 	  if record_string_buffer_ptr ^= addr (local_record_string_buffer)
      216 	  then free record_string_buffer in (dm_work_area);
      217 	  record_string_buffer_ptr = record_string_ptr;
      218 	  record_string_buffer_length = returned_buffer_length;
      219          end;
      220 
      221       if put_only_a_single_record
      222       then p_record_id = record_id;
      223       else
      224          do;
      225 	  element_id_list.id (record_idx) = record_id;
      226 	  do record_idx = 2 to hbound (element_id_list.id, 1);
      227 
      228 	     call
      229 	        data_format_util_$cv_vector_to_string (field_table_ptr, typed_vector_array.vector_slot (record_idx),
      230 	        record_string_buffer_ptr, record_string_buffer_length, dm_work_area_ptr, record_string_ptr,
      231 	        returned_buffer_length, p_code);
      232 	     if p_code ^= 0
      233 	     then call ERROR_RETURN ();
      234 
      235 	     call
      236 	        collection_manager_$put (record_cursor.file_opening_id, record_cursor.collection_id,
      237 	        addr (record_string.contents), record_string.length, record_id, (0), p_code);
      238 	     if p_code = 0
      239 	     then element_id_list.id (record_idx) = record_id;
      240 	     else call ERROR_RETURN ();
      241 
      242 	     if record_string_ptr ^= record_string_buffer_ptr
      243 	     then
      244 	        do;
      245 		 if record_string_buffer_ptr ^= addr (local_record_string_buffer)
      246 		 then free record_string_buffer in (dm_work_area);
      247 		 record_string_buffer_ptr = record_string_ptr;
      248 		 record_string_buffer_length = returned_buffer_length;
      249 	        end;
      250 	  end;
      251          end;
      252 
      253       record_cursor.record_id = record_id;
      254       record_cursor.flags.position_is_valid = "1"b;
      255 
      256       call FINISH ();
      257 RETURN:
      258       return;
      259 
      260 
      261 CHECK_VERSION:
      262    proc (p_received_version, p_expected_version, p_structure_name);
      263 
      264       dcl	    p_received_version     fixed bin (35);
      265       dcl	    p_expected_version     fixed bin (35);
      266       dcl	    p_structure_name       char (*);
      267 
      268       if p_received_version ^= p_expected_version
      269       then call
      270 	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      271 	    "^/Expected version ^d of the ^a structure.
      272 Received version ^d, instead.", p_expected_version, p_structure_name, p_received_version);
      273 
      274    end CHECK_VERSION;
      275 
      276 
      277 CHECK_VERSION_CHAR_8:
      278    proc (p_given_version, p_correct_version, p_structure_name);
      279 
      280       dcl	    p_structure_name       char (*);
      281       dcl	    p_given_version	       char (8) aligned;
      282       dcl	    p_correct_version      char (8) aligned;
      283 
      284       if p_given_version ^= p_correct_version
      285       then call
      286 	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      287 	    "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      288 	    p_given_version);
      289 
      290       return;
      291 
      292    end CHECK_VERSION_CHAR_8;
      293 
      294 FINISH:
      295    proc ();
      296 
      297       if record_string_buffer_ptr ^= null
      298       then if record_string_buffer_ptr ^= addr (local_record_string_buffer)
      299 	 then free record_string_buffer in (dm_work_area);
      300 
      301    end FINISH;
      302 
      303 
      304 ERROR_RETURN:
      305    proc ();
      306 
      307       call FINISH ();
      308       goto RETURN;
      309 
      310    end ERROR_RETURN;
      311 
  1     1 /* BEGIN INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*Written by Matthew Pierret, 04/05/82.
  1     5*Modified:
  1     6*08/19/82 by Matthew Pierret:  Version 2. Changed collection_id to 
  1     7*            bit (36) aligned.
  1     8*07/28/83 by Matthew Pierret: Changed name from dm_rm_cursor.incl.pl1 to
  1     9*            dm_rcm_cursor.incl.pl1.
  1    10*04/13/84 by Lee Baldwin:  Renamed pf_opening_id to file_opening_id to coincide
  1    11*            with the naming conventions used in the rcm_XX routines.
  1    12**/
  1    13 
  1    14 /* format: style2,ind3 */
  1    15      dcl	   1 record_cursor	      aligned based (record_cursor_ptr),
  1    16 	     2 type	      fixed bin (17) unaligned,
  1    17 	     2 version	      fixed bin (17) unaligned,
  1    18 	     2 flags,
  1    19 	       3 position_is_valid
  1    20 			      bit (1) unal,
  1    21 	       3 pad	      bit (35) unal,
  1    22 	     2 area_ptr	      ptr,
  1    23 	     2 file_opening_id    bit (36) aligned,
  1    24 	     2 collection_id      bit (36) aligned,
  1    25 	     2 record_id	      bit (36) aligned,
  1    26 	     2 record_check_value bit (36) aligned;
  1    27 
  1    28      dcl	   record_cursor_ptr      ptr;
  1    29      dcl	   RECORD_CURSOR_VERSION_2
  1    30 			      init (2) fixed bin int static options (constant);
  1    31      dcl	   RECORD_CURSOR_TYPE     init (1) fixed bin int static options (constant);
  1    32      dcl	   BEGINNING_OF_COLLECTION_RECORD_ID
  1    33 			      init ("0"b) bit (36) aligned int static options (constant);
  1    34 
  1    35 /* END INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
      312 
      313 
      314 
  2     1 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 03/15/83. 
  2     5*Modified:
  2     6*07/28/83 by Matthew Pierret: Changed name from dm_rm_opening_info.incl.pl1 to
  2     7*            dm_rcm_opening_info.incl.pl1.
  2     8**/
  2     9 
  2    10 /* format: style2,ind3 */
  2    11      dcl	   1 record_collection_opening_info
  2    12 			      aligned based (record_collection_opening_info_ptr),
  2    13 	     2 version	      char (8) aligned init (RECORD_COLLECTION_OPENING_INFO_VERSION_1),
  2    14 	     2 current_transaction_id
  2    15 			      bit (36) aligned init ("0"b),
  2    16 	     2 current_rollback_count
  2    17 			      fixed bin (35) init (0),
  2    18 	     2 file_opening_id    bit (36) aligned init ("0"b),
  2    19 	     2 collection_id      bit (36) aligned init ("0"b),
  2    20 	     2 field_table_ptr    ptr init (null);
  2    21 
  2    22      dcl	   record_collection_opening_info_ptr
  2    23 			      ptr init (null);
  2    24      dcl	   RECORD_COLLECTION_OPENING_INFO_VERSION_1
  2    25 			      char (8) aligned init ("rc_open1") internal static options (constant);
  2    26 
  2    27 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
      315 
      316 
  3     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*          The element_id_list structure contains an array of element 
  3     5*     identifiers.  These identifiers are used as tuple, record or 
  3     6*     element identifiers.  This structure is used across the relation_manager_,
  3     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  3     8*     version should be changed to be char(8)aligned, when such a conversion
  3     9*     can be coordinated with the other structures used at these interfaces.
  3    10**/
  3    11 
  3    12 /* HISTORY:
  3    13*Written by Matthew Pierret, 06/06/82.
  3    14*Modified:
  3    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  3    16*            Did not change version.
  3    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  3    22 	     2 version	      fixed bin (35),
  3    23 	     2 number_of_elements fixed bin (35),
  3    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  3    25 
  3    26      dcl	   element_id_list_ptr    ptr;
  3    27      dcl	   eil_number_of_elements fixed bin (35);
  3    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  3    29 			      init (1) fixed bin (35);
  3    30 
  3    31 
  3    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      317 
      318 
  4     1 /* ***********************************************************
  4     2*   *                                                         *
  4     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  4     4*   *                                                         *
  4     5*   *********************************************************** */
  4     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  4     7 
  4     8 /* Written by Lindsey Spratt, 04/02/82.
  4     9*Modified:
  4    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  4    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  4    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  4    13*	  type.
  4    14**/
  4    15 
  4    16 /* format: style2,ind3 */
  4    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  4    18 	     2 type	      fixed bin (17) unal,
  4    19 	     2 number_of_dimensions
  4    20 			      fixed bin (17) unal,
  4    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  4    22 	       3 value_ptr	      ptr unaligned;
  4    23 
  4    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  4    25 	     2 type	      fixed bin (17) unal,
  4    26 	     2 number_of_dimensions
  4    27 			      fixed bin (17) unal,
  4    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  4    29 	       3 identifier	      fixed bin (17) unal,
  4    30 	       3 pad	      bit (18) unal,
  4    31 	       3 value_ptr	      ptr unal;
  4    32 
  4    33      dcl	   simple_typed_vector_ptr
  4    34 			      ptr;
  4    35      dcl	   stv_number_of_dimensions
  4    36 			      fixed bin (17);
  4    37 
  4    38      dcl	   general_typed_vector_ptr
  4    39 			      ptr;
  4    40      dcl	   gtv_number_of_dimensions
  4    41 			      fixed bin (17);
  4    42 
  4    43      dcl	   (
  4    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  4    45 			      init (1),		/* value_ptr was aligned. */
  4    46 	   GENERAL_TYPED_VECTOR_TYPE
  4    47 			      init (2),
  4    48 	   SIMPLE_TYPED_VECTOR_TYPE
  4    49 			      init (3)
  4    50 	   )		      fixed bin (17) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      319 
      320 
  5     1 /* ***********************************************************
  5     2*   *                                                         *
  5     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  5     4*   *                                                         *
  5     5*   *********************************************************** */
  5     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  5     7 
  5     8 /* Written by Lindsey Spratt, 03/04/82.
  5     9*Modified:
  5    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  5    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  5    12*	  the print_vector value (char varying), ptr to the typed_vector
  5    13*	  value location, and a code. cv_to_print now takes ptr to the
  5    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  5    15*	  (char(*) varying), the maximum allowed length for the print_vector
  5    16*	  value, a temp_seg to put the value in if its to big to fit into
  5    17*	  the print_vector, and a code.
  5    18**/
  5    19 
  5    20 /* format: style2,ind3 */
  5    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  5    22 	     2 version	      fixed bin (35),
  5    23 	     2 number_of_dimensions
  5    24 			      fixed bin (17),
  5    25 	     2 number_of_vectors  fixed bin (17),
  5    26 	     2 number_of_vector_slots
  5    27 			      fixed bin (17),
  5    28 	     2 maximum_dimension_name_length
  5    29 			      fixed bin (17),
  5    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  5    31 	       3 name	      char (tva_maximum_dimension_name_length
  5    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  5    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  5    34 						/* temp_seg_ptr, max_length_for_print_value, */
  5    35 						/* print_value, code) */
  5    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  5    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  5    38 						/* print_value_ptr, typed_value_ptr, code) */
  5    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  5    41 			      pointer;
  5    42 
  5    43      dcl	   typed_vector_array_ptr ptr;
  5    44      dcl	   tva_number_of_vector_slots
  5    45 			      fixed bin;
  5    46      dcl	   tva_number_of_dimensions
  5    47 			      fixed bin;
  5    48      dcl	   tva_maximum_dimension_name_length
  5    49 			      fixed bin;
  5    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  5    51 			      fixed bin (35) int static options (constant) init (2);
  5    52 
  5    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      321 
      322 
  6     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*     This include file contains declarations of all collection_manager_ 
  6     5*     entrypoints.
  6     6**/
  6     7 
  6     8 /* HISTORY:
  6     9*Written by Matthew Pierret 
  6    10*Modified:
  6    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  6    12*	  allocate_control_interval operation to be unaligned, as well as
  6    13*	  unsigned.
  6    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  6    15*            removed the beginning_location parameter from the put_element
  6    16*            operation. Added the create_page_file_operation.
  6    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  6    18*            wherever collection_id was required.
  6    19*            Also changed the control_interval_id parameter of the 
  6    20*            allocate_control_interval operation back to be aligned. So there.
  6    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  6    22*            added the argument file_create_info_ptr to $create_file.
  6    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  6    24*	  include the zero_on_free bit.
  6    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  6    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  6    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  6    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  6    29*            cm_$put_unprotected_header.
  6    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  6    31*             $simple_get_buffered_element.
  6    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  6    33*            parameter for specifying absolute/relative nature of search.
  6    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  6    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  6    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  6    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  6    38*            delete_from_ci_buffer.
  6    39*            Re-named *_buffered_ci to =_ci_buffer.
  6    40*            get entries.
  6    41*            modify entries.
  6    42*            Changed calling sequence of modify entries to have a ptr/length
  6    43*            instead of length/ptr parameter pair.
  6    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  6    45**/
  6    46 
  6    47 /* This include file contains declarations of collection_manager_ entrypoints */
  6    48 
  6    49 /* format: style2,ind3 */
  6    50      dcl	   collection_manager_$allocate_control_interval
  6    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  6    52      dcl	   collection_manager_$compact_control_interval
  6    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  6    54      dcl	   collection_manager_$create_collection
  6    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6    56      dcl	   collection_manager_$create_file
  6    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  6    58      dcl	   collection_manager_$destroy_collection
  6    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  6    60      dcl	   collection_manager_$free_control_interval
  6    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  6    62 			      fixed bin (35));
  6    63 
  6    64      dcl	   collection_manager_$delete
  6    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    66 			      fixed bin (35));
  6    67      dcl	   collection_manager_$delete_from_ci_buffer
  6    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    69 			      fixed bin (35));
  6    70 
  6    71      dcl	   collection_manager_$get
  6    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6    74      dcl	   collection_manager_$get_control_interval_ptr
  6    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  6    76 			      fixed bin (35));
  6    77      dcl	   collection_manager_$get_from_ci_buffer
  6    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6    80      dcl	   collection_manager_$get_by_ci_ptr
  6    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  6    83      dcl	   collection_manager_$get_header
  6    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  6    85 			      ptr, fixed bin (35), fixed bin (35));
  6    86      dcl	   collection_manager_$get_id
  6    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  6    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    89      dcl	   collection_manager_$get_portion
  6    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6    92 			      fixed bin (35), fixed bin (35));
  6    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  6    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  6    96 			      fixed bin (35));
  6    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  6    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  6   100 			      fixed bin (35));
  6   101      dcl	   collection_manager_$modify
  6   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   103 			      fixed bin (35), fixed bin (35));
  6   104      dcl	   collection_manager_$modify_unprotected
  6   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   106 			      fixed bin (35), fixed bin (35));
  6   107      dcl	   collection_manager_$modify_in_ci_buffer
  6   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   109 			      fixed bin (35), fixed bin (35));
  6   110      dcl	   collection_manager_$modify_portion
  6   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  6   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   113      dcl	   collection_manager_$postcommit_increments
  6   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   115      dcl	   collection_manager_$put
  6   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   117 			      fixed bin (35), fixed bin (35));
  6   118      dcl	   collection_manager_$put_in_ci_buffer
  6   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   120 			      fixed bin (35), fixed bin (35));
  6   121      dcl	   collection_manager_$put_header
  6   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  6   123      dcl	   collection_manager_$put_unprotected_header
  6   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  6   125 
  6   126      dcl	   collection_manager_$replace_ci_buffer
  6   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  6   128 			      fixed bin (35));
  6   129      dcl	   collection_manager_$setup_ci_buffer
  6   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  6   131 			      fixed bin (35));
  6   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  6   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  6   134 			      fixed bin (35));
  6   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  6   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  6   137 			      fixed bin (35));
  6   138 
  6   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      323 
      324 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      325 
      326 
      327    end rcm_put_record_by_id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0913.8  rcm_put_record_by_id.pl1          >spec>on>7192.pbf-04/04/85>rcm_put_record_by_id.pl1
312          1    01/07/85  0859.4  dm_rcm_cursor.incl.pl1            >ldd>include>dm_rcm_cursor.incl.pl1
315          2    01/07/85  0859.4  dm_rcm_opening_info.incl.pl1      >ldd>include>dm_rcm_opening_info.incl.pl1
317          3    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
319          4    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
321          5    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
323          6    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
325          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000026 constant        bit(36)                  initial dcl 7-7 set ref 60* 173* 268* 284*
ELEMENT_ID_LIST_VERSION_1       002132 automatic       fixed bin(35,0)          initial dcl 3-28 set ref 164* 3-28*
RECORD_COLLECTION_OPENING_INFO_VERSION_1
                                000000 constant        char(8)                  initial dcl 2-24 set ref 185*
RECORD_CURSOR_TYPE              000034 constant        fixed bin(17,0)          initial dcl 1-31 set ref 173 173*
RECORD_CURSOR_VERSION_2                constant        fixed bin(17,0)          initial dcl 1-29 ref 177
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 5-50 ref 158
addr                                                   builtin function         dcl 108 ref 191 205 205 215 235 235 245 297
cleanup                         002116 stack reference condition                dcl 113 ref 197
collection_id             5            based           bit(36)                  level 2 dcl 1-15 set ref 179* 205* 235*
collection_manager_$put         000030 constant        entry                    external dcl 6-115 ref 205 235
contents                  1            based           bit                      level 2 packed unaligned dcl 100 set ref 205 205 235
                                                                                  235
data_format_util_$cv_vector_to_string
                                000016 constant        entry                    external dcl 125 ref 199 228
dm_error_$programming_error     000024 external static fixed bin(35,0)          dcl 131 set ref 60*
dm_error_$wrong_cursor_type     000026 external static fixed bin(35,0)          dcl 131 set ref 173*
dm_work_area                           based           area(1024)               dcl 98 ref 215 245 297
dm_work_area_ptr                000010 internal static pointer                  initial dcl 139 set ref 194 194* 199* 215 228* 245
                                                                                  297
element_id_list                        based           structure                level 1 dcl 3-21
element_id_list_ptr             002130 automatic       pointer                  dcl 3-26 set ref 163* 164 225 226 238
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 131 set ref 268* 284*
field_table_ptr                 002106 automatic       pointer                  initial dcl 89 in procedure "rcm_put_record_by_id"
                                                                                  set ref 89* 189* 199* 228*
field_table_ptr           6            based           pointer                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 2-11
                                                                                  in procedure "rcm_put_record_by_id" ref 189
file_opening_id           4            based           bit(36)                  level 2 dcl 1-15 set ref 179* 205* 235*
flags                     1            based           structure                level 2 dcl 1-15
get_dm_free_area_               000020 constant        entry                    external dcl 127 ref 194
hbound                                                 builtin function         dcl 108 ref 226
id                        2            based           bit(36)                  array level 2 dcl 3-21 set ref 225* 226 238*
length                                                 builtin function         dcl 108 in procedure "rcm_put_record_by_id" ref 192
length                                 based           fixed bin(35,0)          level 2 in structure "record_string" dcl 100
                                                                                  in procedure "rcm_put_record_by_id" set ref 205
                                                                                  205 205* 235 235 235*
local_record_string_buffer      000101 automatic       char(4096)               unaligned dcl 82 set ref 191 192 215 245 297
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 5-21 ref 160 228
myname                          000002 constant        varying char(32)         initial dcl 118 set ref 60* 60* 60* 173* 268* 284*
null                                                   builtin function         dcl 108 ref 60 60 89 91 173 173 194 2-22 268 268 284
                                                                                  284 297
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 5-21 ref 160 228
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 3-21 ref 226
p_code                                 parameter       fixed bin(35,0)          dcl 77 set ref 143 153 168* 179* 182 199* 202 205*
                                                                                  208 228* 232 235* 238
p_correct_version                      parameter       char(8)                  dcl 282 set ref 277 284 284*
p_element_id_list_ptr                  parameter       pointer                  dcl 75 ref 153 163
p_expected_version                     parameter       fixed bin(35,0)          dcl 265 set ref 261 268 268*
p_given_version                        parameter       char(8)                  dcl 281 set ref 277 284 284*
p_minimum_free_space                   parameter       fixed bin(35,0)          dcl 73 ref 143 153
p_received_version                     parameter       fixed bin(35,0)          dcl 264 set ref 261 268 268*
p_record_cursor_ptr                    parameter       pointer                  dcl 74 ref 143 153 171
p_record_id                            parameter       bit(36)                  dcl 76 set ref 143 149* 221*
p_related_record_id                    parameter       bit(36)                  dcl 68 ref 143 148 153 161
p_simple_typed_vector_ptr              parameter       pointer                  dcl 69 ref 143 147
p_structure_name                       parameter       char                     unaligned dcl 280 in procedure
                                                                                  "CHECK_VERSION_CHAR_8" set ref 277 284*
p_structure_name                       parameter       char                     unaligned dcl 266 in procedure "CHECK_VERSION" set
                                                                                  ref 261 268*
p_typed_vector_array_ptr               parameter       pointer                  dcl 71 ref 153 157
position_is_valid         1            based           bit(1)                   level 3 packed unaligned dcl 1-15 set ref 254*
put_array_of_records            002101 automatic       bit(1)                   initial dcl 84 set ref 84* 162*
put_only_a_single_record        002102 automatic       bit(1)                   dcl 85 set ref 146* 221
rcm_get_opening_info            000012 constant        entry                    external dcl 123 ref 179
record_collection_opening_info         based           structure                level 1 dcl 2-11
record_collection_opening_info_ptr
                                002126 automatic       pointer                  initial dcl 2-22 set ref 179* 185 189 2-22*
record_cursor                          based           structure                level 1 dcl 1-15
record_cursor_ptr               002124 automatic       pointer                  dcl 1-28 set ref 171* 173 173 177 179 179 205 205
                                                                                  235 235 253 254
record_id                       002103 automatic       bit(36)                  dcl 87 in procedure "rcm_put_record_by_id" set ref
                                                                                  148* 161* 205* 221 225 235* 238 253
record_id                 6            based           bit(36)                  level 2 in structure "record_cursor" dcl 1-15
                                                                                  in procedure "rcm_put_record_by_id" set ref 253*
record_idx                      002104 automatic       fixed bin(17,0)          dcl 88 set ref 225 226* 228 238*
record_string                          based           structure                level 1 unaligned dcl 100
record_string_buffer                   based           bit                      unaligned dcl 104 ref 215 245 297
record_string_buffer_length     002114 automatic       fixed bin(35,0)          initial dcl 93 set ref 93* 192* 199* 215 215 218*
                                                                                  228* 245 245 248* 297 297
record_string_buffer_ptr        002112 automatic       pointer                  initial dcl 91 set ref 91* 191* 199* 212 215 215
                                                                                  217* 228* 242 245 245 247* 297 297 297
record_string_ptr               002110 automatic       pointer                  dcl 90 set ref 199* 205 205 205 212 217 228* 235 235
                                                                                  235 242 247
returned_buffer_length          000100 automatic       fixed bin(35,0)          dcl 81 set ref 199* 218 228* 248
simple_typed_vector_ptr         002134 automatic       pointer                  dcl 4-33 set ref 147* 160* 199*
sub_err_                        000014 constant        entry                    external dcl 124 ref 60 173 268 284
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-15 set ref 173 173*
typed_vector_array                     based           structure                level 1 dcl 5-21
typed_vector_array_ptr          002136 automatic       pointer                  dcl 5-43 set ref 157* 158 160 228
unspec                                                 builtin function         dcl 108 ref 192
vector_slot                            based           pointer                  array level 2 dcl 5-21 set ref 160 228*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 3-21
                                                                                  in procedure "rcm_put_record_by_id" set ref 164*
version                                based           char(8)                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 2-11
                                                                                  in procedure "rcm_put_record_by_id" set ref 185*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "record_cursor" packed
                                                                                  unaligned dcl 1-15 in procedure
                                                                                  "rcm_put_record_by_id" ref 177
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 5-21
                                                                                  in procedure "rcm_put_record_by_id" ref 158

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BEGINNING_OF_COLLECTION_RECORD_ID      internal static bit(36)                  initial dcl 1-32
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 4-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 4-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 4-43
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 6-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 6-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 6-54
collection_manager_$create_file 000000 constant        entry                    external dcl 6-56
collection_manager_$delete      000000 constant        entry                    external dcl 6-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 6-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 6-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 6-60
collection_manager_$get         000000 constant        entry                    external dcl 6-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 6-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 6-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 6-77
collection_manager_$get_header  000000 constant        entry                    external dcl 6-83
collection_manager_$get_id      000000 constant        entry                    external dcl 6-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 6-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 6-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 6-93
collection_manager_$modify      000000 constant        entry                    external dcl 6-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 6-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 6-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 6-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 6-113
collection_manager_$put_header  000000 constant        entry                    external dcl 6-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 6-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 6-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 6-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 6-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 6-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 6-135
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 3-27
general_typed_vector                   based           structure                level 1 packed unaligned dcl 4-24
general_typed_vector_ptr               automatic       pointer                  dcl 4-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 4-40
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 4-17
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 4-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 5-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 5-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 5-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001125 constant        entry                    internal dcl 261 ref 158 164 177
CHECK_VERSION_CHAR_8            001221 constant        entry                    internal dcl 277 ref 185
ERROR_RETURN                    001352 constant        entry                    internal dcl 304 ref 182 202 208 232 240
FINISH                          001324 constant        entry                    internal dcl 294 ref 197 256 307
JOIN                            000405 constant        label                    dcl 168 ref 150 166
RETURN                          001124 constant        label                    dcl 257 set ref 308
array                           000305 constant        entry                    external dcl 153
rcm_put_record_by_id            000172 constant        entry                    external dcl 57
single                          000257 constant        entry                    external dcl 143

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1606        1640    1414        1616
Length      2210    1414        32         333     171           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcm_put_record_by_id               1342 external procedure  is an external procedure.  
on unit on line 197                  64 on unit               
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rcm_put_record_by_id.  
CHECK_VERSION_CHAR_8                    internal procedure  shares stack frame of external procedure rcm_put_record_by_id.  
FINISH                               66 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rcm_put_record_by_id.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dm_work_area_ptr            rcm_put_record_by_id

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcm_put_record_by_id     000100 returned_buffer_length      rcm_put_record_by_id
                         000101 local_record_string_buffer  rcm_put_record_by_id
                         002101 put_array_of_records        rcm_put_record_by_id
                         002102 put_only_a_single_record    rcm_put_record_by_id
                         002103 record_id                   rcm_put_record_by_id
                         002104 record_idx                  rcm_put_record_by_id
                         002106 field_table_ptr             rcm_put_record_by_id
                         002110 record_string_ptr           rcm_put_record_by_id
                         002112 record_string_buffer_ptr    rcm_put_record_by_id
                         002114 record_string_buffer_length rcm_put_record_by_id
                         002124 record_cursor_ptr           rcm_put_record_by_id
                         002126 record_collection_opening_info_ptr
                                                            rcm_put_record_by_id
                         002130 element_id_list_ptr         rcm_put_record_by_id
                         002132 ELEMENT_ID_LIST_VERSION_1   rcm_put_record_by_id
                         002134 simple_typed_vector_ptr     rcm_put_record_by_id
                         002136 typed_vector_array_ptr      rcm_put_record_by_id

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$put       data_format_util_$cv_vector_to_string                       get_dm_free_area_
rcm_get_opening_info          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error   dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     84 000157        89 000160        91 000162        93 000163    2   22 000164    3   28 000165        57 000171
     60 000200       143 000250       146 000265       147 000267       148 000273       149 000275       150 000276
    153 000277       157 000313       158 000317       160 000334       161 000351       162 000354       163 000356
    164 000361       166 000404       168 000405       171 000407       173 000412       177 000471       179 000506
    182 000525       185 000531       189 000553       191 000556       192 000560       194 000562       197 000575
    199 000617       202 000645       205 000651       208 000702       212 000706       215 000712       217 000725
    218 000727       221 000731       225 000737       226 000743       228 000753       232 001020       235 001024
    238 001055       240 001065       242 001066       245 001072       247 001105       248 001107       250 001111
    253 001113       254 001116       256 001120       257 001124       261 001125       268 001136       274 001220
    277 001221       284 001232       290 001322       294 001323       297 001331       301 001351       304 001352
    307 001353       308 001357


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
