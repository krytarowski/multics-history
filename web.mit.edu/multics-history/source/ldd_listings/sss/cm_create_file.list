	COMPILATION LISTING OF SEGMENT cm_create_file
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1632.1 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          This routine creates a file and formats control interval zero
       11*     for maintenance by collection_manager_. Creating the file consists
       12*     solely of calling file_manager_$create_open. The format of control
       13*     interval zero is a basic_control_interval (see dm_cm_basic_ci.incl.pl1)
       14*     with the collection_header of collection zero (the header collection)
       15*     taking up slot one, and the header for all collections, collmgr_header,
       16*     taking up slot two.
       17*     */
       18 
       19 /* HISTORY:
       20*
       21*Written by Matthew Pierret 08/04/82.
       22*Modified:
       23*11/03/82 by Matthew Pierret:  Changed to use cm_file_header (instead of 
       24*            collmgr_header), new format CI (BASIC_CI_LAYOUT_1) which does
       25*            not use datum headers.
       26*12/01/82 by Lindsey Spratt:  Changed to set the storage_record_element_id in
       27*	  the collection_header.
       28*02/23/83 by Matthew Pierret: Changed to use file_reservation_map instead of
       29*            block_map_array.
       30*05/21/84 by Matthew Pierret: Renamed include files dm_cm_(esm cism)_info to
       31*            dm_(esm cism)_info.  Added ERROR_RETURN procedure.
       32*09/26/84 by Matthew Pierret: Changed to use file_manger_$simple_put.
       33*            Removed unused variable declarations.  Changed to use addcharno
       34*            instead of addr(substr()).
       35**/
       36 
       37 
       38 /* format: style2,ind3 */
       39 
       40 cm_create_file:
       41    proc (p_file_dir, p_file_name, p_file_create_info_ptr, p_file_opening_id, p_code);
       42 
       43 
       44 /* START OF DECLARATIONS */
       45 /* Parameter */
       46 
       47       dcl	    p_file_dir	       char (*);
       48       dcl	    p_file_name	       char (*);
       49       dcl	    p_file_create_info_ptr ptr;
       50       dcl	    p_file_opening_id      bit (36) aligned;
       51       dcl	    p_code	       fixed bin (35);
       52 
       53 /* Automatic */
       54 
       55       dcl	    code		       fixed bin (35) init (0);
       56       dcl	    file_opening_id	       bit (36) aligned init ("0"b);
       57       dcl	    control_interval_zero  char (CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES) aligned;
       58       dcl	    control_interval_one   char (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES) aligned;
       59       dcl	    collection_header_length_in_bytes
       60 			       fixed bin (17);
       61       dcl	    cm_file_header_length_in_bytes
       62 			       fixed bin (17);
       63       dcl	    based_byte_string_ptr  ptr;
       64       dcl	    bbs_length	       fixed bin (17);
       65 
       66       dcl	    1 initial_file_reservation_map
       67 			       aligned like file_reservation_map;
       68 
       69 /* Based */
       70 
       71       dcl	    datum_header_string    bit (9) unaligned based;
       72       dcl	    based_byte_string      char (bbs_length) unaligned based (based_byte_string_ptr);
       73 
       74 /* Builtin */
       75 
       76       dcl	    (addcharno, addr, size, substr, unspec)
       77 			       builtin;
       78 
       79 /* Controlled */
       80 /* Constant */
       81 
       82       dcl	    BYTES_PER_WORD	       fixed bin init (4) int static options (constant);
       83       dcl	    BITS_PER_BYTE	       fixed bin init (9) int static options (constant);
       84       dcl	    BITS_PER_WORD	       fixed bin init (36) int static options (constant);
       85       dcl	    myname	       init ("cm_create_file") char (32) varying int static options (constant);
       86       dcl	    MAX_ELEMENT_SIZE       fixed bin (35) init (999999) int static options (constant);
       87       dcl	    ALLOCATION_MAP_ELEMENT_ID
       88 			       bit (36) aligned init ("000000010001"b3) int static options (constant);
       89       dcl	    COLLECTION_ID_TABLE_ELEMENT_ID
       90 			       bit (36) aligned init ("000000000004"b3) int static options (constant);
       91       dcl	    BLOCK_MAP_ARRAY_ELEMENT_ID
       92 			       bit (36) aligned init ("000000000005"b3) int static options (constant);
       93 
       94       dcl	    INITIAL_ALLOCATION_MAP_LENGTH_IN_BYTES
       95 			       fixed bin (17) init (116) int static options (constant);
       96       dcl	    DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK
       97 			       fixed bin (17) init (1024) int static options (constant);
       98       dcl	    DEFAULT_STORAGE_RECORD_ELEMENT_ID
       99 			       init ("000000000006"b3) bit (36) aligned internal static options (constant);
      100       dcl	    START_OF_CI_OFFSET     init (0) fixed bin (21) internal static options (constant);
      101 
      102 /* Entry */
      103 
      104       dcl	    file_manager_$create_open
      105 			       entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
      106       dcl	    file_manager_$delete_close
      107 			       entry (bit (36) aligned, fixed bin (35));
      108       dcl	    file_manager_$simple_put
      109 			       entry (bit (36) aligned, fixed bin (27), fixed bin (21), ptr, fixed bin (21),
      110 			       fixed bin (35));
      111 
      112 /* External */
      113 
      114       dcl	    (
      115 	    dm_error_$file_already_exists,
      116 	    dm_error_$file_already_open
      117 	    )		       fixed bin (35) ext;
      118 
      119 /* END OF DECLARATIONS */
      120 
      121       p_code, code = 0;
      122       p_file_opening_id = "0"b;
      123       frm_number_of_fragments = 0;			/* To silence the compiler */
      124 
      125       call file_manager_$create_open (p_file_dir, p_file_name, p_file_create_info_ptr, file_opening_id, code);
      126       if code ^= 0
      127       then
      128          do;
      129 	  if code = dm_error_$file_already_exists | code = dm_error_$file_already_open
      130 	  then p_file_opening_id = file_opening_id;
      131 	  call ERROR_RETURN (code);
      132          end;
      133 
      134       collection_header_length_in_bytes = size (collection_header) * BYTES_PER_WORD;
      135       cm_file_header_length_in_bytes = size (cm_file_header) * BYTES_PER_WORD;
      136 
      137 /* Initialize the first control interval - control interval 0. */
      138 
      139       unspec (control_interval_zero) = "0"b;
      140       basic_control_interval_ptr = addr (control_interval_zero);
      141 
      142       basic_control_interval.header.layout_type = BASIC_CI_LAYOUT_1;
      143       basic_control_interval.header.collection_id = HEADER_COLLECTION_ID;
      144       basic_control_interval.header.number_of_datums = 6;
      145 
      146 /*
      147*    Initialize the datum slots of the following elements:
      148*     Slot 1 - collection_header of the "header collection"
      149*     Slot 2 - cm_file_header (collection_manager_ info about entire file)
      150*     Slot 3 - Reserved for user
      151*     Slot 4 - collection_id_table (containing no collection ids)
      152*     Slot 5 - file_reservation_map (containing one fragment)
      153*     Slot 6 - storage record for header collection (unblocked_storage_record)
      154**/
      155 
      156       basic_control_interval.datum_position_table (1).offset_in_bytes =
      157 	 CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES - collection_header_length_in_bytes;
      158       basic_control_interval.datum_position_table (1).length_in_bits = collection_header_length_in_bytes * BITS_PER_BYTE;
      159 
      160       basic_control_interval.datum_position_table (2).offset_in_bytes =
      161 	 basic_control_interval.datum_position_table (1).offset_in_bytes - cm_file_header_length_in_bytes;
      162       basic_control_interval.datum_position_table (2).length_in_bits = cm_file_header_length_in_bytes * BITS_PER_BYTE;
      163 
      164       basic_control_interval.datum_position_table (3).offset_in_bytes =
      165 	 basic_control_interval.datum_position_table (2).offset_in_bytes;
      166       basic_control_interval.datum_position_table (3).length_in_bits = 0;
      167 
      168       basic_control_interval.datum_position_table (4).offset_in_bytes =
      169 	 basic_control_interval.datum_position_table (2).offset_in_bytes - BYTES_PER_WORD;
      170       basic_control_interval.datum_position_table (4).length_in_bits = BITS_PER_WORD;
      171 
      172       basic_control_interval.datum_position_table (5).offset_in_bytes =
      173 	 basic_control_interval.datum_position_table (4).offset_in_bytes
      174 	 - size (initial_file_reservation_map) * BYTES_PER_WORD;
      175       basic_control_interval.datum_position_table (5).length_in_bits =
      176 	 size (initial_file_reservation_map) * BITS_PER_WORD;
      177 
      178       basic_control_interval.datum_position_table (6).offset_in_bytes =
      179 	 basic_control_interval.datum_position_table (5).offset_in_bytes
      180 	 - size (unblocked_storage_record) * BYTES_PER_WORD;
      181       basic_control_interval.datum_position_table (6).length_in_bits = size (unblocked_storage_record) * BITS_PER_WORD;
      182 
      183       basic_control_interval.header.start_of_used_space = basic_control_interval.datum_position_table (6).offset_in_bytes;
      184 
      185 /* 
      186*     Directly insert the values of the six elements by overlaying based
      187*     structures on control_interval_zero.  Each element is on a word boundary,
      188*     so there are no alignment problems.
      189*
      190*     Set value of collection zero's collection_header 
      191**/
      192 
      193       collection_header_ptr =
      194 	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (1).offset_in_bytes);
      195 
      196       collection_header.version = COLLECTION_HEADER_VERSION_2;
      197       collection_header.flags.thread_control_intervals = "1"b;
      198       collection_header.maximum_element_size = MAX_ELEMENT_SIZE;
      199       collection_header.control_interval_storage_method = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD;
      200       collection_header.element_storage_method = BASIC_ELEMENT_STORAGE_METHOD;
      201       collection_header.storage_record_element_id = DEFAULT_STORAGE_RECORD_ELEMENT_ID;
      202 
      203 /* Set value for collection_manager_'s file header (cm_file_header) */
      204 
      205       cm_file_header_ptr =
      206 	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (2).offset_in_bytes);
      207 
      208       cm_file_header.version = CM_FILE_HEADER_VERSION_1;
      209       cm_file_header.allocation_map_element_id = BLOCK_MAP_ARRAY_ELEMENT_ID;
      210       cm_file_header.collection_id_table_element_id = COLLECTION_ID_TABLE_ELEMENT_ID;
      211       cm_file_header.number_of_control_intervals_per_block = DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK;
      212       cm_file_header.number_of_blocks = 1;
      213 
      214 /*
      215*    Since the initial value for the collection_id_table is "0"b,
      216*    it need not be inserted.
      217*
      218*    Insert the file_reservation_map, which at this time consists of one entry. 
      219**/
      220 
      221       based_byte_string_ptr =
      222 	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (5).offset_in_bytes);
      223       bbs_length = size (initial_file_reservation_map) * BYTES_PER_WORD;
      224 
      225       unspec (initial_file_reservation_map) = "0"b;
      226       initial_file_reservation_map.lowest_numbered_control_interval = 1;
      227       initial_file_reservation_map.element_id = ALLOCATION_MAP_ELEMENT_ID;
      228 
      229       based_byte_string = addr (initial_file_reservation_map) -> based_byte_string;
      230 
      231 /*
      232*     Set the value of the unblocked_storage_record. 
      233**/
      234 
      235       unblocked_storage_record_ptr =
      236 	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (6).offset_in_bytes);
      237 
      238       unblocked_storage_record.first_control_interval = 0;
      239       unblocked_storage_record.last_control_interval = 1;
      240 
      241 /*
      242*     Put the whole control interval into the file.
      243**/
      244 
      245       call file_manager_$simple_put (file_opening_id, 0, START_OF_CI_OFFSET, basic_control_interval_ptr,
      246 	 (CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES), code);
      247       if code ^= 0
      248       then call ERROR_RETURN (code);
      249 
      250 /*
      251*     Insert the reservation map.  It consists of a single fragment in control
      252*     interval one, which is also part of the header collection (collection
      253*     zero).
      254**/
      255 
      256       unspec (control_interval_one) = "0"b;
      257       basic_control_interval_ptr = addr (control_interval_one);
      258 
      259       basic_control_interval.layout_type = BASIC_CI_LAYOUT_1;
      260       basic_control_interval.header.collection_id = HEADER_COLLECTION_ID;
      261       basic_control_interval.number_of_datums = 1;
      262 
      263       frmf_number_of_control_intervals = DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK;
      264 
      265       basic_control_interval.datum_position_table (1).offset_in_bytes =
      266 	 CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES - INITIAL_ALLOCATION_MAP_LENGTH_IN_BYTES;
      267       basic_control_interval.datum_position_table (1).length_in_bits = frmf_number_of_control_intervals;
      268 
      269       file_reservation_map_fragment_ptr =
      270 	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (1).offset_in_bytes);
      271 
      272       substr (file_reservation_map_fragment, 1, 1) = "1"b;	/* To mark that control interval one has been allocated */
      273 
      274       call file_manager_$simple_put (file_opening_id, 1, START_OF_CI_OFFSET, basic_control_interval_ptr,
      275 	 (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES), code);
      276       if code ^= 0
      277       then call ERROR_RETURN (code);
      278 
      279 
      280       p_file_opening_id = file_opening_id;
      281 MAIN_RETURN:
      282       return;
      283 
      284 ERROR_RETURN:
      285    proc (er_p_code);
      286 
      287       dcl	    er_p_code	       fixed bin (35);
      288 
      289       p_code = er_p_code;
      290       call FINISH ();
      291       go to MAIN_RETURN;
      292 
      293    end ERROR_RETURN;
      294 
      295 
      296 FINISH:
      297    proc ();
      298 
      299 /* This can go when protected file creation is implemented */
      300       if p_file_opening_id = "0"b & file_opening_id ^= "0"b
      301       then call file_manager_$delete_close (file_opening_id, (0));
      302 
      303    end FINISH;
      304 
  1     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the identifier of the Header Collection for a file
  1     6*   managed by the collection_manager_.  This is used by callers of 
  1     7*   collection_manager who wish to maintain their own file header or who wish
  1     8*   to maintain their own collection header information beyond the caller
  1     9*   collection header provided by colleciton_manager_$(get put)_header.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 09/24/84.
  1    14*Modified:
  1    15**/
  1    16 
  1    17 /* format: style2,ind3,ll79 */
  1    18 
  1    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  1    20 			      aligned internal static options (constant);
  1    21 
  1    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      305 
      306 
  2     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains element identifiers of some elements in the Header Collection.
  2     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  2     7*   which the collection_header for the Header Collection is stored (see
  2     8*   dm_cm_collection_header.incl.pl1).
  2     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    10*   caller's file header is stored.
  2    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  2    13**/
  2    14 
  2    15 /* HISTORY:
  2    16*Written by Matthew Pierret, 09/24/84.
  2    17*Modified:
  2    18**/
  2    19 
  2    20 /* format: style2,ind3,ll79 */
  2    21      dcl	   (
  2    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  2    23 			      init ("000000000001"b3),
  2    24 	   CM_FILE_HEADER_ELEMENT_ID
  2    25 			      init ("000000000002"b3),
  2    26 	   CALLER_HEADER_ELEMENT_ID
  2    27 			      init ("000000000003"b3)
  2    28 	   )		      bit (36) aligned int static
  2    29 			      options (constant);
  2    30 
  2    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      307 
      308 
  3     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        The collection_manager_ manages the structure of the addressable
  3     6*   portion of a control interval.  The addressable portion is that portion of
  3     7*   a control interval which the file_manager_ will allow the
  3     8*   collection_manager_ to address.  In this description control interval will
  3     9*   be used to mean the addressable portion of a control interval.
  3    10*   
  3    11*        A control interval is divided into four parts: the header, the datum
  3    12*   position table (also known as the slot table or slots), un-used space and
  3    13*   used space.  The beginning of the header is at offset 0, and the end of the
  3    14*   used space is at the end of the control interval (curently offset 4072).
  3    15*   Pictoriarly, a control interval is structured as follows:
  3    16*   
  3    17*   ----------------------------------------------------------------------
  3    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  3    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  3    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  3    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  3    22*   ----------------------------------------------------------------------
  3    23*                                           ^ ^    ^      ^    ^  ^   ^
  3    24*                                           | |    |      |    |  |   |
  3    25*                                           | |...........|.......|...|
  3    26*                        start of used space|      |           |      |
  3    27*                                                  |           |  each|
  3    28*                                          scattered free space|  is a used
  3    29*                                                                 datum
  3    30*   
  3    31*      The basic_control_interval structure describes the header
  3    32*   (basic_control_interval.header, bci_header) and the slots
  3    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  3    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  3    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  3    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  3    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  3    38**/
  3    39 
  3    40 /* HISTORY:
  3    41*Written by Matthew Pierret, 02/07/82.
  3    42*Modified:
  3    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  3    44*            and its sub-structures.
  3    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  3    46*            basic_ci_header to bci_header. Added previous_control_interval.
  3    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  3    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  3    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  3    50*            is not used.
  3    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  3    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  3    53**/
  3    54 
  3    55 /* format: style2 */
  3    56      dcl	   1 basic_control_interval
  3    57 			      aligned based (basic_control_interval_ptr),
  3    58 	     2 header	      like bci_header,
  3    59 	     2 datum_position_table
  3    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  3    61 
  3    62 
  3    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  3    64 	     2 layout_type	      char (4) aligned,
  3    65 	     2 collection_id      bit (36) aligned,
  3    66 	     2 next_control_interval
  3    67 			      fixed bin (24) uns unal,
  3    68 	     2 previous_control_interval
  3    69 			      fixed bin (24) uns unal,
  3    70 	     2 flags	      unal,
  3    71 	       3 continuation_datum_is_present
  3    72 			      bit (1) unal,
  3    73 	       3 free_slot_is_present
  3    74 			      bit (1) unal,
  3    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  3    76 	     2 scattered_free_space
  3    77 			      fixed bin (17) unal,
  3    78 	     2 start_of_used_space
  3    79 			      fixed bin (17) unal,
  3    80 	     2 number_of_datums   fixed bin (17) unal;
  3    81 
  3    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  3    83 	     2 flags	      unal,
  3    84 	       3 special_format_datum
  3    85 			      bit (1) unal,		/* reserved */
  3    86 	       3 is_continued     bit (1) unal,
  3    87 	       3 is_continuation  bit (1) unal,
  3    88 	       3 mbz	      bit (1) unal,		/* reserved */
  3    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  3    90 	     2 length_in_bits     fixed bin (17) uns unal;
  3    91 
  3    92      dcl	   basic_control_interval_ptr
  3    93 			      ptr;
  3    94      dcl	   bci_header_ptr	      ptr;
  3    95      dcl	   datum_slot_ptr	      ptr;
  3    96 
  3    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  3    98 
  3    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      309 
      310 
  4     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        This include file contains the cm_file_header and collection_id_table 
  4     6*   structure.  These structures are stored as elements in the Header Collection
  4     7*   of a file and contain per-file, as opposed to per-collection, information.
  4     8*   
  4     9*        The cm_file_header structure is always stored in the element whose
  4    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  4    11*   dm_cm_hdr_col_ids.incl.pl1.  
  4    12*   
  4    13*        The collection_id_table is an array of identifiers of each collection 
  4    14*   in the file, excepting the Header Collection.  The identifier of a 
  4    15*   collection is the same as the identifier of the element which holds that
  4    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  4    17*   The identifier of the element in which the collection_id_table is
  4    18*   stored is cm_file_header.collection_id_table_element_id.
  4    19*   
  4    20*      A file also has a reservation map for determining which controls 
  4    21*   intervals have been reserved by a collection.  It is divided into
  4    22*   several blocks, or fragments.  The file_reservation_map is actually an
  4    23*   array of element identifiers of the fragments of the map.  The 
  4    24*   file_reservation_map is stored in the element whose identifier is 
  4    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  4    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  4    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  4    28*   bits long, representing equally as many control intervals.  The
  4    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  4    30*   cm_file_header.highest_numbered_ci is the number of the control
  4    31*   interval in the file with the highest control interval number.  It is not 
  4    32*   yet used or maintained.
  4    33*
  4    34**/
  4    35 
  4    36 /* HISTORY:
  4    37*Written by Matthew Pierret, 03/23/82.
  4    38*Modified:
  4    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  4    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  4    41*            ids referring to collection_header's. Reduced buffer length to 120,
  4    42*            enough bytes to hold the collmgr_header with 25 collection header
  4    43*            element ids.
  4    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  4    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  4    46*            made fixed length, split off array of collection_ids (also known as
  4    47*            element_ids of collection_headers).
  4    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  4    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  4    50*            dm_cm_hdr_col_ids.incl.pl1.  
  4    51**/
  4    52 
  4    53 /* format: style2,ind3,ll79 */
  4    54 
  4    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  4    56 	     2 version	      char (8),
  4    57 	     2 highest_numbered_ci
  4    58 			      fixed bin (24) uns,
  4    59 	     2 number_of_collections
  4    60 			      fixed bin (17) unal,
  4    61 	     2 number_of_blocks   fixed bin (17) unal,
  4    62 	     2 number_of_control_intervals_per_block
  4    63 			      fixed bin (17),
  4    64 	     2 allocation_map_element_id
  4    65 			      bit (36) aligned,
  4    66 	     2 collection_id_table_element_id
  4    67 			      bit (36) aligned;
  4    68 
  4    69      dcl	   cm_file_header_ptr     ptr;
  4    70      dcl	   CM_FILE_HEADER_VERSION_1
  4    71 			      char (8) aligned init ("cm_fhdr1")
  4    72 			      int static options (constant);
  4    73 
  4    74 
  4    75      dcl	   collection_id_table    (cit_number_of_collections)
  4    76 			      bit (36) aligned
  4    77 			      based (collection_id_table_ptr);
  4    78 
  4    79      dcl	   collection_id_table_ptr
  4    80 			      ptr;
  4    81      dcl	   cit_number_of_collections
  4    82 			      fixed bin (17);
  4    83 
  4    84 
  4    85 
  4    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  4    87 
      311 
      312 
  5     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*       Associated with each collection is the following collection_header
  5     5*   structure stored as an element in the Header Collection of the file.
  5     6*   The identifier of this element is also the idenfifier of the collection.
  5     7*   Even the Header Collection has a collection_header stored in the Header
  5     8*   Collection itself in the element identified by the constant
  5     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  5    10*   The information in collection_header is expected to be stable information.
  5    11*   The structure elements are described as follows:
  5    12*   
  5    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  5    14*   
  5    15*   flags.fixed_size_elements indicates, if on that all elements in the
  5    16*   collection are of a fixed length.
  5    17*   
  5    18*   flags.thread_elements indicates that elements in a collection are to be
  5    19*   threaded in a linked list.  This is currrently unupported.
  5    20*   
  5    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  5    22*   a collection are to be threaded in a linked list.  This is only useful if
  5    23*   the control interval storage method is blocked.
  5    24*   
  5    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  5    26*   
  5    27*   control_interval_storage_method is the method of storage management of
  5    28*   control intervals for this collection, either
  5    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  5    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  5    31*   dm_cism_info.incl.pl1.
  5    32*   
  5    33*   element_storage_method is the method of storage management of elements in
  5    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  5    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  5    36*   
  5    37*   maximum_element_size is the maximum size of an element in bits in this
  5    38*   collection.
  5    39*   
  5    40*   header_record_element_id is the identifier of an element containing a
  5    41*   caller-defined header for this collection.  If equal to "0"b, no
  5    42*   caller-defined header yet exists.  The put_header collection_manager_
  5    43*   operation stores such a header.
  5    44*   
  5    45*   storage_record_element_id is the identifier of the element containing the
  5    46*   storage_record for this collection.  The storage_record contains
  5    47*   information expected to be dynamic, such as the identifier of the last
  5    48*   control interval of the collection.  Its format is also dependent upon the
  5    49*   storage methods in effect for this collection.  storage_record structures
  5    50*   are declared in dm_cm_storage_record.incl.pl1.
  5    51*
  5    52**/
  5    53 
  5    54 /* HISTORY:
  5    55*Written by Matthew Pierret, 04/01/82.
  5    56*Modified:
  5    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  5    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  5    59*            storage_record_area out, leaving storage_record_element_id behind.
  5    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  5    61**/
  5    62 
  5    63 /* format: style2,ind3,ll79 */
  5    64 
  5    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  5    66 	     2 version	      char (8),
  5    67 	     2 flags	      unaligned,
  5    68 	       3 fixed_size_elements
  5    69 			      bit (1),
  5    70 	       3 thread_elements  bit (1),
  5    71 	       3 thread_control_intervals
  5    72 			      bit (1),
  5    73 	       3 must_be_zero1    bit (15),
  5    74 	     2 control_interval_storage_method
  5    75 			      fixed bin (17) unal,
  5    76 	     2 element_storage_method
  5    77 			      fixed bin (17),
  5    78 	     2 maximum_element_size
  5    79 			      fixed bin (35),
  5    80 	     2 header_record_element_id
  5    81 			      bit (36) aligned,
  5    82 	     2 storage_record_element_id
  5    83 			      bit (36) aligned;
  5    84 
  5    85      dcl	   collection_header_ptr  ptr;
  5    86      dcl	   COLLECTION_HEADER_VERSION_2
  5    87 			      init ("col_hdr2") char (8) aligned
  5    88 			      int static options (constant);
  5    89 
  5    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      313 
      314 
  6     1 /* BEGIN INCLUDE FILE dm_esm_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*     This include file contains the basic_esm_info and ordered_esm_info
  6     6*     structures, as well as constants used to distinguish element storage
  6     7*     methods.  They are used by several managers to describe the type of
  6     8*     element storage management to be used in a collection.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*Written 02/07/82 by Matthew Pierret.
  6    13*Modified:
  6    14*05/17/84 by Matthew Pierret:  Changed name from dm_cm_esm_info (the cm_
  6    15*            dropped because the include file is used by multiple managers),
  6    16*            to align structure elements and to add a version string.
  6    17**/
  6    18 
  6    19 /* format: style2 */
  6    20 
  6    21      dcl	   1 basic_esm_info	      based (basic_esm_info_ptr) aligned,
  6    22 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  6    23 	     2 type	      fixed bin (17) init (BASIC_ELEMENT_STORAGE_METHOD),
  6    24 	     2 flags	      aligned,
  6    25 	       3 threaded	      bit (1) unal,
  6    26 	       3 fixed_length     bit (1) unal,
  6    27 	       3 pad	      bit (34) unal,
  6    28 	     2 maximum_element_length
  6    29 			      fixed bin (35);
  6    30 
  6    31      dcl	   1 ordered_esm_info     based (ordered_esm_info_ptr) aligned,
  6    32 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  6    33 	     2 type	      fixed bin (17) init (ORDERED_ELEMENT_STORAGE_METHOD),
  6    34 	     2 flags	      aligned,
  6    35 	       3 fixed_length     bit (1) unal,
  6    36 	       3 pad	      bit (35) unal,
  6    37 	     2 maximum_element_length
  6    38 			      fixed bin (35);
  6    39 
  6    40      dcl	   basic_esm_info_ptr     ptr;
  6    41      dcl	   ordered_esm_info_ptr   ptr;
  6    42 
  6    43      dcl	   ESM_INFO_VERSION_1     init ("ESMinfo1") char (8) aligned internal static options (constant);
  6    44      dcl	   BASIC_ELEMENT_STORAGE_METHOD
  6    45 			      fixed bin init (1) internal static options (constant);
  6    46      dcl	   ORDERED_ELEMENT_STORAGE_METHOD
  6    47 			      fixed bin init (2) internal static options (constant);
  6    48 
  6    49 
  6    50 /* END INCLUDE FILE dm_esm_info.incl.pl1 */
      315 
      316 
  7     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  7     6*     structures, as well as constants relevant to control interval storage
  7     7*     management.  These structures and constants are used by several managers.
  7     8*     The structures each describe a method of control interval storage 
  7     9*     management.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*
  7    14*Written 02/07/82 by Matthew Pierret.
  7    15*Modified:
  7    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  7    17*            a version string.
  7    18**/
  7    19 
  7    20 /* format: style2 */
  7    21 
  7    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  7    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    25 	     2 number_of_control_intervals_per_block
  7    26 			      fixed bin (17);
  7    27 
  7    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  7    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    31 	     2 must_be_zero	      fixed bin (17);
  7    32 
  7    33      dcl	   blocked_cism_info_ptr  ptr;
  7    34      dcl	   unblocked_cism_info_ptr
  7    35 			      ptr;
  7    36 
  7    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  7    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    39 			      fixed bin init (1) internal static options (constant);
  7    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    41 			      fixed bin init (2) internal static options (constant);
  7    42 
  7    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      317 
      318 
  8     1 /* BEGIN INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*        The collection_manager_'s file reservation map is used to keep track of
  8     6*   those control intervals which have been reserved by a collection so that
  8     7*   more than one collection in a file do not attempt to use the same control 
  8     8*   interval.  Logically the file reservation map is one long bit string
  8     9*   containing a bit for each control interval of the file.  If the bit for
  8    10*   a control interval is "1"b, that control interval has been reserved.
  8    11*   Actually the map is divided into several fragments represented by 
  8    12*   file_reservation_map_fragment structures, each a bit string of uniform
  8    13*   length and each stored as an element in the Header Collection.  Ideally,
  8    14*   each fragment is stored in a different control interval of the Header 
  8    15*   Collection for enhanced concurrent access to the map.
  8    16*   
  8    17*        To increase speed of reference and concurrent throughput the fragments
  8    18*   are not chained together, but are kept track of by the file_reservation_map
  8    19*   structure.  This structure is an array with each entry describing the
  8    20*   location of a fragment, the number of the control interval for which the
  8    21*   first bit in the fragment represents, and a flag which, if on, indicates 
  8    22*   that there are no unreserved control intervals in the fragment.  This flag
  8    23*   allows for skipping looking at fragments which are already full.
  8    24**/
  8    25 
  8    26 /* HISTORY:
  8    27*Written by Matthew Pierret, 2/23/83.
  8    28*Modified:
  8    29*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  8    30**/
  8    31 
  8    32 /* format: style2,ind3,ll79 */
  8    33 
  8    34      dcl	   1 file_reservation_map (frm_number_of_fragments) aligned
  8    35 			      based (file_reservation_map_ptr),
  8    36 	     2 flags	      unal,
  8    37 	       3 no_control_intervals_are_available
  8    38 			      bit (1) unal,
  8    39 	       3 must_be_zero     bit (11) unal,
  8    40 	     2 lowest_numbered_control_interval
  8    41 			      fixed bin (24) uns unal,
  8    42 	     2 element_id	      bit (36) aligned;
  8    43 
  8    44      dcl	   file_reservation_map_fragment
  8    45 			      aligned
  8    46 			      based (file_reservation_map_fragment_ptr)
  8    47 			      bit (frmf_number_of_control_intervals);
  8    48 
  8    49 
  8    50      dcl	   file_reservation_map_ptr
  8    51 			      ptr;
  8    52      dcl	   frm_number_of_fragments
  8    53 			      fixed bin (17);
  8    54 
  8    55      dcl	   file_reservation_map_fragment_ptr
  8    56 			      ptr;
  8    57      dcl	   frmf_number_of_control_intervals
  8    58 			      fixed bin (17);
  8    59 
  8    60 
  8    61 /* END INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
      319 
      320 
  9     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        A storage record is an extension to the collection_header structure.
  9     6*   It is expected to be more volatile than collection_header and has a 
  9     7*   different format depending on the control interval storage method in use
  9     8*   for the collection.  A storage record is stored as an element in the 
  9     9*   file's Header Collection with the element identifier 
  9    10*   collection_header.storage_record_element_id.
  9    11*   
  9    12*        The unblocked_storage_record contains the control interval numbers
  9    13*   of the first and last control intervals of a collection.  Unblocked
  9    14*   control intervals are chained together, so all control intervals can be 
  9    15*   found by starting at one end and following the chain forward or backward.
  9    16*   
  9    17*        The blocked_storage_record is not yet used, as the Blocked Control
  9    18*   Interval Storage Method is not yet implemented.
  9    19**/
  9    20 
  9    21 /* HISTORY:
  9    22*Written by Matthew Pierret, 09/24/84.
  9    23*Modified:
  9    24**/
  9    25 
  9    26 /* format: style2,ind3,ll79 */
  9    27 
  9    28      dcl	   1 unblocked_storage_record
  9    29 			      aligned
  9    30 			      based (unblocked_storage_record_ptr),
  9    31 	     2 first_control_interval
  9    32 			      fixed bin (24) uns,
  9    33 	     2 last_control_interval
  9    34 			      fixed bin (24) uns;
  9    35 
  9    36      dcl	   1 blocked_storage_record
  9    37 			      aligned based (blocked_storage_record_ptr),
  9    38 	     2 last_control_interval
  9    39 			      fixed bin (24) uns,
  9    40 	     2 number_of_blocks   fixed bin (17) unal,
  9    41 	     2 number_of_control_intervals_per_block
  9    42 			      fixed bin (17) unal,
  9    43 	     2 allocation_map_element_id
  9    44 			      bit (36) aligned;
  9    45 
  9    46      dcl	   unblocked_storage_record_ptr
  9    47 			      ptr init (null ());
  9    48      dcl	   blocked_storage_record_ptr
  9    49 			      ptr init (null ());
  9    50 
  9    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      321 
      322 
 10     1 /* BEGIN INCLUDE FILE:  dm_ci_header.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*        This include file contains various structures which make up the
 10     6*   header and trailer of a control interval.
 10     7*   
 10     8*   ****  NOTE:  The include file dm_ci.incl.pl1 is heavily dependent ****
 10     9*   ****  on this include file.  When changing this include file,     ****
 10    10*   ****  check dm_ci.incl.pl1 to see if it is affected.              ****
 10    11**/
 10    12 
 10    13 /* HISTORY:
 10    14*Written by Jeffrey D. Ives, 03/02/82.
 10    15*  (Design by Andre Bensoussan and Jeffrey D. Ives)
 10    16*Modified:
 10    17*11/02/84 by Matthew Pierret:  Re-organized so that dm_ci.incl.pl1 and
 10    18*            dm_ci_header.incl.pl1 do not duplicate structures or constants.
 10    19**/
 10    20 
 10    21 /* format: style2,ind3 */
 10    22 
 10    23 /* ci_header is the first four words of a control interval. Its contents
 10    24*   are used to verify that a control interval is in an expected format,
 10    25*   to identify the control interval and the file to which the control
 10    26*   interval belongs, and to maintain information for the synchronization
 10    27*   of disk I/O between DM file control intervals and associated before
 10    28*   journal control intervals.  The first two words are the time stamp for
 10    29*   synchronization; the latter two identify the control interval. */
 10    30 
 10    31      dcl	   ci_header_ptr	      ptr;
 10    32      dcl	   1 ci_header	      aligned based (ci_header_ptr),
 10    33 	     2 stamp	      like ci_stamp,
 10    34 	     2 id		      like ci_id;
 10    35 
 10    36 /* ci_trailer is the last two words of a control interval and must match
 10    37*   the first two words (ci_header.stamp). */
 10    38 
 10    39      dcl	   ci_trailer_ptr	      ptr;
 10    40      dcl	   1 ci_trailer	      like ci_header.stamp aligned based (ci_trailer_ptr);
 10    41 
 10    42 
 10    43 /* ci_stamp is a two-word date/time modified stamp, consisting of:
 10    44*     version: a 9-bit version string for the structure
 10    45*     bj_idx:  before journal index for I/O synchronization
 10    46*     time_modified:  Multics clock time of last modification */
 10    47 
 10    48      dcl	   1 ci_stamp	      aligned based,
 10    49 	     3 version	      bit (9) unal,
 10    50 	     3 bj_idx	      fixed bin (9) uns unal,
 10    51 	     3 time_modified      fixed bin (53) unal;
 10    52 
 10    53      dcl	   CI_HEADER_STAMP_VERSION_1
 10    54 			      bit (9) aligned static options (constant) init ("641"b3);
 10    55 
 10    56 /* ci_id is a two-word identification of the control interval, which
 10    57*   rarely changes and consists of:
 10    58*     uid:   DM file unique identifier
 10    59*     size_code:  the control interval size in bytes, in an encoded
 10    60*                 form (see ci_size_code below).
 10    61*     num:   the control interval number.  0 is the number of the first
 10    62*            control interval of a file. */
 10    63 
 10    64      dcl	   1 ci_id	      aligned based,
 10    65 	     3 uid	      bit (36),
 10    66 	     3 size_code	      bit (9) unal,
 10    67 	     3 num	      fixed bin (27) uns unal;
 10    68 
 10    69 /* ci_size_code is the structure which defines the content of ci_id.size_code.
 10    70*   The size in bytes of a control interval is equal to 
 10    71*   (2 ** ci_size_code.exponent * (64 + 8 * ci_size_code.addon)).  */
 10    72 
 10    73      dcl	   1 ci_size_code	      aligned based,
 10    74 	     2 exponent	      fixed bin (6) uns unal,
 10    75 	     2 addon	      fixed bin (3) uns unal;
 10    76 
 10    77 /* ci_header_chunks is a structure which can be used to update the
 10    78*   ci_stamp or ci_id in one memory cycle. */
 10    79 
 10    80      dcl	   1 ci_header_chunks     aligned based (ci_header_ptr),
 10    81 	     2 stamp	      fixed bin (71),
 10    82 	     2 id		      fixed bin (71);
 10    83 
 10    84 /* ci_trailer_chunk is a structure which can e used to update the
 10    85*   ci_trailer in one memory cycle. */
 10    86 
 10    87      dcl	   1 ci_trailer_chunk     aligned based,
 10    88 	     2 stamp	      fixed bin (71);
 10    89 
 10    90 
 10    91 /*  END INCLUDE FILE:  dm_ci_header.incl.pl1  */
      323 
      324 
 11     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*       This include file contains constants which are the length in bytes
 11     5*   of the addressable portion of a control interval.  The addressable portion
 11     6*   is that part of the control interval which callers of file_manager_
 11     7*   may access, specifically, everything between the end of the control
 11     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
 11     9*   Control interval 0 is slightly different, as it also contains an 
 11    10*   unaddressable portion in which it maintains the file attributes.  For
 11    11*   control interval 0 the addressable portion is everything between the end
 11    12*   of the control interval header and the beginning of the file attributes.
 11    13**/
 11    14 
 11    15 /* HISTORY:
 11    16*Written by Matthew Pierret, 11/02/84.
 11    17*Modified:
 11    18**/
 11    19 
 11    20 /* format: style2,ind3 */
 11    21 
 11    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
 11    23 			      fixed bin (17) init (4072) int static options (constant);
 11    24 
 11    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
 11    26 			      fixed bin (17) init (3176) int static options (constant);
 11    27 
 11    28 
 11    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
 11    30 
 11    31      dcl	   CI_0_ADDRESSABLE_LENGTH
 11    32 			      fixed bin (17) init (3176) int static options (constant);
 11    33 
 11    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      325 
      326 
      327    end cm_create_file;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1148.3  cm_create_file.pl1                >spec>temp>famis1>cm_create_file.pl1
305          1    01/03/85  1003.4  dm_hdr_collection_id.incl.pl1     >spec>temp>famis1>dm_hdr_collection_id.incl.pl1
307          2    01/03/85  1003.1  dm_cm_hdr_col_ids.incl.pl1        >spec>temp>famis1>dm_cm_hdr_col_ids.incl.pl1
309          3    01/03/85  1003.0  dm_cm_basic_ci.incl.pl1           >spec>temp>famis1>dm_cm_basic_ci.incl.pl1
311          4    01/03/85  1003.1  dm_cm_file_header.incl.pl1        >spec>temp>famis1>dm_cm_file_header.incl.pl1
313          5    01/03/85  1003.1  dm_cm_collection_header.incl.pl1  >spec>temp>famis1>dm_cm_collection_header.incl.pl1
315          6    01/03/85  1003.2  dm_esm_info.incl.pl1              >spec>temp>famis1>dm_esm_info.incl.pl1
317          7    01/03/85  1003.0  dm_cism_info.incl.pl1             >spec>temp>famis1>dm_cism_info.incl.pl1
319          8    01/03/85  1003.1  dm_cm_reservation_map.incl.pl1    >spec>temp>famis1>dm_cm_reservation_map.incl.pl1
321          9    01/03/85  1003.1  dm_cm_storage_record.incl.pl1     >spec>temp>famis1>dm_cm_storage_record.incl.pl1
323         10    01/03/85  1005.2  dm_ci_header.incl.pl1             >spec>temp>famis1>dm_ci_header.incl.pl1
325         11    01/03/85  1005.2  dm_ci_lengths.incl.pl1            >spec>temp>famis1>dm_ci_lengths.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALLOCATION_MAP_ELEMENT_ID              constant        bit(36)                  initial dcl 87 ref 227
BASIC_CI_LAYOUT_1               000004 constant        char(4)                  initial dcl 3-97 ref 142 259
BASIC_ELEMENT_STORAGE_METHOD           constant        fixed bin(17,0)          initial dcl 6-44 ref 200
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 83 ref 158 162
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 84 ref 170 175 181
BLOCK_MAP_ARRAY_ELEMENT_ID             constant        bit(36)                  initial dcl 91 ref 209
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 82 ref 134 135 168 172 178 223
CM_FILE_HEADER_VERSION_1        000002 constant        char(8)                  initial dcl 4-70 ref 208
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 5-86 ref 196
COLLECTION_ID_TABLE_ELEMENT_ID         constant        bit(36)                  initial dcl 89 ref 210
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 11-22 ref 58 265 274
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 11-25 ref 57 156 245
DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK
                                       constant        fixed bin(17,0)          initial dcl 96 ref 211 263
DEFAULT_STORAGE_RECORD_ELEMENT_ID      constant        bit(36)                  initial dcl 98 ref 201
HEADER_COLLECTION_ID                   constant        bit(36)                  initial dcl 1-19 ref 143 260
INITIAL_ALLOCATION_MAP_LENGTH_IN_BYTES constant        fixed bin(17,0)          initial dcl 94 ref 265
MAX_ELEMENT_SIZE                000005 constant        fixed bin(35,0)          initial dcl 86 ref 198
START_OF_CI_OFFSET              000006 constant        fixed bin(21,0)          initial dcl 100 set ref 245* 274*
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 7-40 ref 199
addcharno                                              builtin function         dcl 76 ref 193 205 221 235 269
addr                                                   builtin function         dcl 76 ref 140 229 257
allocation_map_element_id
                          5            based           bit(36)                  level 2 dcl 4-55 set ref 209*
based_byte_string                      based           char                     unaligned dcl 72 set ref 229* 229
based_byte_string_ptr           000104 automatic       pointer                  dcl 63 set ref 221* 229
basic_control_interval                 based           structure                level 1 dcl 3-56
basic_control_interval_ptr      000112 automatic       pointer                  dcl 3-92 set ref 140* 142 143 144 156 158 160 160
                                                                                  162 164 164 166 168 168 170 172 172 175 178 178
                                                                                  181 183 183 193 193 205 205 221 221 235 235 245*
                                                                                  257* 259 260 261 265 267 269 269 274*
bbs_length                      000106 automatic       fixed bin(17,0)          dcl 64 set ref 223* 229 229
bci_header                             based           structure                level 1 dcl 3-63
blocked_storage_record_ptr      000130 automatic       pointer                  initial dcl 9-48 set ref 9-48*
ci_header                              based           structure                level 1 dcl 10-32
ci_id                                  based           structure                level 1 dcl 10-64
ci_stamp                               based           structure                level 1 dcl 10-48
cm_file_header                         based           structure                level 1 dcl 4-55 set ref 135
cm_file_header_length_in_bytes  000103 automatic       fixed bin(17,0)          dcl 61 set ref 135* 160 162
cm_file_header_ptr              000114 automatic       pointer                  dcl 4-69 set ref 135 205* 208 209 210 211 212
code                            000100 automatic       fixed bin(35,0)          initial dcl 55 set ref 55* 121* 125* 126 129 129
                                                                                  131* 245* 247 247* 274* 276 276*
collection_header                      based           structure                level 1 dcl 5-65 set ref 134
collection_header_length_in_bytes
                                000102 automatic       fixed bin(17,0)          dcl 59 set ref 134* 156 158
collection_header_ptr           000116 automatic       pointer                  dcl 5-85 set ref 134 193* 196 197 198 199 200 201
collection_id             1            based           bit(36)                  level 3 dcl 3-56 set ref 143* 260*
collection_id_table_element_id
                          6            based           bit(36)                  level 2 dcl 4-55 set ref 210*
control_interval_one            000102 automatic       char                     dcl 58 set ref 256* 257
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-65 set ref 199*
control_interval_zero           000102 automatic       char                     dcl 57 set ref 139* 140
datum_position_table      5            based           structure                array level 2 dcl 3-56
datum_slot                             based           structure                level 1 dcl 3-82
dm_error_$file_already_exists   000016 external static fixed bin(35,0)          dcl 114 ref 129
dm_error_$file_already_open     000020 external static fixed bin(35,0)          dcl 114 ref 129
element_id                1     000110 automatic       bit(36)                  level 2 dcl 66 set ref 227*
element_storage_method
                          3            based           fixed bin(17,0)          level 2 dcl 5-65 set ref 200*
er_p_code                              parameter       fixed bin(35,0)          dcl 287 ref 284 289
file_manager_$create_open       000010 constant        entry                    external dcl 104 ref 125
file_manager_$delete_close      000012 constant        entry                    external dcl 106 ref 300
file_manager_$simple_put        000014 constant        entry                    external dcl 108 ref 245 274
file_opening_id                 000101 automatic       bit(36)                  initial dcl 56 set ref 56* 125* 129 245* 274* 280
                                                                                  300 300*
file_reservation_map                   based           structure                array level 1 dcl 8-34
file_reservation_map_fragment          based           bit                      dcl 8-44 set ref 272*
file_reservation_map_fragment_ptr
                                000122 automatic       pointer                  dcl 8-55 set ref 269* 272
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 9-28 set ref 238*
flags                     2            based           structure                level 2 packed unaligned dcl 5-65
frm_number_of_fragments         000120 automatic       fixed bin(17,0)          dcl 8-52 set ref 123*
frmf_number_of_control_intervals
                                000124 automatic       fixed bin(17,0)          dcl 8-57 set ref 263* 267 272
header                                 based           structure                level 2 dcl 3-56
initial_file_reservation_map    000110 automatic       structure                level 1 dcl 66 set ref 172 175 223 225* 229
last_control_interval
                          1            based           fixed bin(24,0)          level 2 unsigned dcl 9-28 set ref 239*
layout_type                            based           char(4)                  level 3 dcl 3-56 set ref 142* 259*
length_in_bits            5(19)        based           fixed bin(17,0)          array level 3 packed unsigned unaligned dcl 3-56 set
                                                                                  ref 158* 162* 166* 170* 175* 181* 267*
lowest_numbered_control_interval
                          0(12) 000110 automatic       fixed bin(24,0)          level 2 packed unsigned unaligned dcl 66 set ref
                                                                                  226*
maximum_element_size      4            based           fixed bin(35,0)          level 2 dcl 5-65 set ref 198*
number_of_blocks          3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-55 set ref 212*
number_of_control_intervals_per_block
                          4            based           fixed bin(17,0)          level 2 dcl 4-55 set ref 211*
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 3-56 set ref 144* 261*
offset_in_bytes           5(04)        based           fixed bin(15,0)          array level 3 packed unsigned unaligned dcl 3-56 set
                                                                                  ref 156* 160* 160 164* 164 168* 168 172* 172 178*
                                                                                  178 183 193 205 221 235 265* 269
p_code                                 parameter       fixed bin(35,0)          dcl 51 set ref 40 121* 289*
p_file_create_info_ptr                 parameter       pointer                  dcl 49 set ref 40 125*
p_file_dir                             parameter       char                     unaligned dcl 47 set ref 40 125*
p_file_name                            parameter       char                     unaligned dcl 48 set ref 40 125*
p_file_opening_id                      parameter       bit(36)                  dcl 50 set ref 40 122* 129* 280* 300
size                                                   builtin function         dcl 76 ref 134 135 172 175 178 181 223
stamp                                  based           structure                level 2 dcl 10-32
start_of_used_space       4            based           fixed bin(17,0)          level 3 packed unaligned dcl 3-56 set ref 183*
storage_record_element_id
                          6            based           bit(36)                  level 2 dcl 5-65 set ref 201*
substr                                                 builtin function         dcl 76 set ref 272*
thread_control_intervals
                          2(02)        based           bit(1)                   level 3 packed unaligned dcl 5-65 set ref 197*
unblocked_storage_record               based           structure                level 1 dcl 9-28 set ref 178 181
unblocked_storage_record_ptr    000126 automatic       pointer                  initial dcl 9-46 set ref 178 181 235* 238 239 9-46*
unspec                                                 builtin function         dcl 76 set ref 139* 225* 256*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 5-65
                                                                                  in procedure "cm_create_file" set ref 196*
version                                based           char(8)                  level 2 in structure "cm_file_header" dcl 4-55
                                                                                  in procedure "cm_create_file" set ref 208*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 7-38
CALLER_HEADER_ELEMENT_ID               internal static bit(36)                  initial dcl 2-21
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 7-37
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 11-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 11-29
CI_HEADER_STAMP_VERSION_1              internal static bit(9)                   initial dcl 10-53
CM_FILE_HEADER_ELEMENT_ID              internal static bit(36)                  initial dcl 2-21
ESM_INFO_VERSION_1                     internal static char(8)                  initial dcl 6-43
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 2-21
ORDERED_ELEMENT_STORAGE_METHOD         internal static fixed bin(17,0)          initial dcl 6-46
basic_esm_info                         based           structure                level 1 dcl 6-21
basic_esm_info_ptr                     automatic       pointer                  dcl 6-40
bci_header_ptr                         automatic       pointer                  dcl 3-94
blocked_cism_info                      based           structure                level 1 dcl 7-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 7-33
blocked_storage_record                 based           structure                level 1 dcl 9-36
ci_header_chunks                       based           structure                level 1 dcl 10-80
ci_header_ptr                          automatic       pointer                  dcl 10-31
ci_size_code                           based           structure                level 1 dcl 10-73
ci_trailer                             based           structure                level 1 dcl 10-40
ci_trailer_chunk                       based           structure                level 1 dcl 10-87
ci_trailer_ptr                         automatic       pointer                  dcl 10-39
cit_number_of_collections              automatic       fixed bin(17,0)          dcl 4-81
collection_id_table                    based           bit(36)                  array dcl 4-75
collection_id_table_ptr                automatic       pointer                  dcl 4-79
datum_header_string                    based           bit(9)                   unaligned dcl 71
datum_slot_ptr                         automatic       pointer                  dcl 3-95
file_reservation_map_ptr               automatic       pointer                  dcl 8-50
myname                                 internal static varying char(32)         initial dcl 85
ordered_esm_info                       based           structure                level 1 dcl 6-31
ordered_esm_info_ptr                   automatic       pointer                  dcl 6-41
unblocked_cism_info                    based           structure                level 1 dcl 7-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 7-34

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    000535 constant        entry                    internal dcl 284 ref 131 247 276
FINISH                          000544 constant        entry                    internal dcl 296 ref 290
MAIN_RETURN                     000534 constant        label                    dcl 281 ref 291
cm_create_file                  000025 constant        entry                    external dcl 40

NAME DECLARED BY CONTEXT OR IMPLICATION.
null                                                   builtin function         ref 9-46 9-48

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       672         714     572         702
Length      1336     572        22         405      77           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_create_file                      148 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_create_file.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_create_file.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_create_file           000100 code                        cm_create_file
                         000101 file_opening_id             cm_create_file
                         000102 control_interval_one        cm_create_file
                         000102 control_interval_zero       cm_create_file
                         000102 collection_header_length_in_bytes
                                                            cm_create_file
                         000103 cm_file_header_length_in_bytes
                                                            cm_create_file
                         000104 based_byte_string_ptr       cm_create_file
                         000106 bbs_length                  cm_create_file
                         000110 initial_file_reservation_map
                                                            cm_create_file
                         000112 basic_control_interval_ptr  cm_create_file
                         000114 cm_file_header_ptr          cm_create_file
                         000116 collection_header_ptr       cm_create_file
                         000120 frm_number_of_fragments     cm_create_file
                         000122 file_reservation_map_fragment_ptr
                                                            cm_create_file
                         000124 frmf_number_of_control_intervals
                                                            cm_create_file
                         000126 unblocked_storage_record_ptr
                                                            cm_create_file
                         000130 blocked_storage_record_ptr  cm_create_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              alloc_auto_adj      ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
file_manager_$create_open     file_manager_$delete_close    file_manager_$simple_put

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$file_already_exists dm_error_$file_already_open


CONSTANTS
000565  aa     037777400000

000566  aa     000002000000
000567  aa     000000000000
000570  aa     600000000041
000571  aa     000100000000

000000  aa  143 157 154 137	col_
000001  aa  150 144 162 062	hdr2

000002  aa  143 155 137 146	cm_f
000003  aa  150 144 162 061	hdr1

000004  aa  142 143 151 061	bci1

000005  aa     000003641077

000006  aa     000000000000

000007  aa     404000000043

000010  aa     514000000044

000011  aa     464000000000

000012  aa     526077777777

000014  aa     077777000043
000015  aa     000001000000

000016  aa     000000000000
000017  aa     000000000000

BEGIN PROCEDURE cm_create_file
ENTRY TO cm_create_file                                     STATEMENT 1 ON LINE 40
cm_create_file:
   proc (p_file_dir, p_file_name, p_file_create_info_ptr, p_file_opening_id, p_code);

000020  at     000005000012
000021  tt     000012000011
000022  tt     000010000007
000023  ta     000020000000
000024  da     000073300000
000025  aa   000240 6270 00	eax7 	160
000026  aa  7 00034 3521 20	epp2 	pr7|28,*
000027  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000030  aa     000012000000
000031  aa     000000000000
000032  aa  6 00042 3735 20	epp7 	pr6|34,*
000033  aa  7 00000 2361 20	ldq  	pr7|0,*
000034  aa   000002 6040 04	tmi  	2,ic		000036
000035  aa   777777 3760 07	anq  	262143,dl
000036  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000037  aa  6 00156 7561 00	stq  	pr6|110
000040  aa  7 00002 2361 20	ldq  	pr7|2,*
000041  aa   000002 6040 04	tmi  	2,ic		000043
000042  aa   777777 3760 07	anq  	262143,dl
000043  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000044  aa  6 00157 7561 00	stq  	pr6|111
						STATEMENT 1 ON LINE 55
000045  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 56
000046  aa  6 00101 4501 00	stz  	pr6|65		file_opening_id
						STATEMENT 1 ON LINE 57
000047  aa   006150 2360 07	ldq  	3176,dl
000050  aa  6 00132 7561 00	stq  	pr6|90
000051  aa   000003 0760 07	adq  	3,dl
000052  aa   000002 7320 00	qrs  	2
000053  aa  6 00133 7561 00	stq  	pr6|91
000054  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
000055  aa  6 00134 2521 00	spri2	pr6|92
						STATEMENT 1 ON LINE 58
000056  aa   007750 2360 07	ldq  	4072,dl
000057  aa  6 00136 7561 00	stq  	pr6|94
000060  aa   000003 0760 07	adq  	3,dl
000061  aa   000002 7320 00	qrs  	2
000062  aa  6 00137 7561 00	stq  	pr6|95
000063  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
000064  aa  6 00140 2521 00	spri2	pr6|96
						STATEMENT 1 ON LINE 46 OF FILE 9
000065  aa   777727 2370 04	ldaq 	-41,ic		000014 = 077777000043 000001000000
000066  aa  6 00126 7571 00	staq 	pr6|86		unblocked_storage_record_ptr
						STATEMENT 1 ON LINE 48 OF FILE 9
000067  aa  6 00130 7571 00	staq 	pr6|88		blocked_storage_record_ptr
						STATEMENT 1 ON LINE 121
      p_code, code = 0;

000070  aa  6 00032 3715 20	epp5 	pr6|26,*
000071  aa  5 00012 4501 20	stz  	pr5|10,*		p_code
000072  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 122
      p_file_opening_id = "0"b;

000073  aa  5 00010 4501 20	stz  	pr5|8,*		p_file_opening_id
						STATEMENT 1 ON LINE 123
      frm_number_of_fragments = 0;

000074  aa  6 00120 4501 00	stz  	pr6|80		frm_number_of_fragments
						STATEMENT 1 ON LINE 125
      call file_manager_$create_open (p_file_dir, p_file_name, p_file_create_info_ptr, file_opening_id, code);

000075  aa  5 00002 3521 20	epp2 	pr5|2,*		p_file_dir
000076  aa  6 00162 2521 00	spri2	pr6|114
000077  aa  5 00004 3521 20	epp2 	pr5|4,*		p_file_name
000100  aa  6 00164 2521 00	spri2	pr6|116
000101  aa  5 00006 3521 20	epp2 	pr5|6,*		p_file_create_info_ptr
000102  aa  6 00166 2521 00	spri2	pr6|118
000103  aa  6 00101 3521 00	epp2 	pr6|65		file_opening_id
000104  aa  6 00170 2521 00	spri2	pr6|120
000105  aa  6 00100 3521 00	epp2 	pr6|64		code
000106  aa  6 00172 2521 00	spri2	pr6|122
000107  aa  7 00000 3521 20	epp2 	pr7|0,*
000110  aa  6 00174 2521 00	spri2	pr6|124
000111  aa  7 00002 3521 20	epp2 	pr7|2,*
000112  aa  6 00176 2521 00	spri2	pr6|126
000113  aa   777676 3520 04	epp2 	-66,ic		000011 = 464000000000
000114  aa  6 00200 2521 00	spri2	pr6|128
000115  aa   777673 3520 04	epp2 	-69,ic		000010 = 514000000044
000116  aa  6 00202 2521 00	spri2	pr6|130
000117  aa   777670 3520 04	epp2 	-72,ic		000007 = 404000000043
000120  aa  6 00204 2521 00	spri2	pr6|132
000121  aa  6 00160 6211 00	eax1 	pr6|112
000122  aa   024000 4310 07	fld  	10240,dl
000123  la  4 00010 3521 20	epp2 	pr4|8,*		file_manager_$create_open
000124  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 126
      if code ^= 0
      then
         do;

000125  aa  6 00100 2361 00	ldq  	pr6|64		code
000126  aa   000013 6000 04	tze  	11,ic		000141
						STATEMENT 1 ON LINE 129
	  if code = dm_error_$file_already_exists | code = dm_error_$file_already_open
	  then p_file_opening_id = file_opening_id;

000127  aa  6 00044 3701 20	epp4 	pr6|36,*
000130  la  4 00016 1161 20	cmpq 	pr4|14,*		dm_error_$file_already_exists
000131  aa   000003 6000 04	tze  	3,ic		000134
000132  la  4 00020 1161 20	cmpq 	pr4|16,*		dm_error_$file_already_open
000133  aa   000004 6010 04	tnz  	4,ic		000137
000134  aa  6 00101 2351 00	lda  	pr6|65		file_opening_id
000135  aa  6 00032 3735 20	epp7 	pr6|26,*
000136  aa  7 00010 7551 20	sta  	pr7|8,*		p_file_opening_id
						STATEMENT 1 ON LINE 131
	  call ERROR_RETURN (code);

000137  aa   000427 3520 04	epp2 	279,ic		000566 = 000002000000
000140  aa   000375 6700 04	tsp4 	253,ic		000535
						STATEMENT 1 ON LINE 132
         end;

						STATEMENT 1 ON LINE 134
      collection_header_length_in_bytes = size (collection_header) * BYTES_PER_WORD;

000141  aa   000007 2360 07	ldq  	7,dl
000142  aa   000004 4020 07	mpy  	4,dl
000143  aa  6 00102 7561 00	stq  	pr6|66		collection_header_length_in_bytes
						STATEMENT 1 ON LINE 135
      cm_file_header_length_in_bytes = size (cm_file_header) * BYTES_PER_WORD;

000144  aa  6 00103 7561 00	stq  	pr6|67		cm_file_header_length_in_bytes
						STATEMENT 1 ON LINE 139
      unspec (control_interval_zero) = "0"b;

000145  aa  6 00132 2361 00	ldq  	pr6|90
000146  aa   000011 4020 07	mpy  	9,dl
000147  aa   000010 0760 07	adq  	8,dl
000150  aa   000011 5060 07	div  	9,dl
000151  aa  6 00134 3735 20	epp7 	pr6|92,*
000152  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000153  aa   000000 00 0000	desc9a	0,0
000154  aa  7 00000 00 0006	desc9a	pr7|0,ql
						STATEMENT 1 ON LINE 140
      basic_control_interval_ptr = addr (control_interval_zero);

000155  aa  7 00000 3715 00	epp5 	pr7|0		control_interval_zero
000156  aa  6 00112 6515 00	spri5	pr6|74		basic_control_interval_ptr
						STATEMENT 1 ON LINE 142
      basic_control_interval.header.layout_type = BASIC_CI_LAYOUT_1;

000157  aa   777625 2350 04	lda  	-107,ic		000004 = 142143151061
000160  aa  5 00000 7551 00	sta  	pr5|0		basic_control_interval.layout_type
						STATEMENT 1 ON LINE 143
      basic_control_interval.header.collection_id = HEADER_COLLECTION_ID;

000161  aa   000001 2350 07	lda  	1,dl
000162  aa  5 00001 7551 00	sta  	pr5|1		basic_control_interval.collection_id
						STATEMENT 1 ON LINE 144
      basic_control_interval.header.number_of_datums = 6;

000163  aa   000006 2350 07	lda  	6,dl
000164  aa  5 00004 5511 14	stba 	pr5|4,14		basic_control_interval.number_of_datums
						STATEMENT 1 ON LINE 156
      basic_control_interval.datum_position_table (1).offset_in_bytes =
	 CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES - collection_header_length_in_bytes;

000165  aa   006150 2360 07	ldq  	3176,dl
000166  aa  6 00102 1761 00	sbq  	pr6|66		collection_header_length_in_bytes
000167  aa   000065 7370 00	lls  	53
000170  aa  5 00005 6751 00	era  	pr5|5		basic_control_interval.offset_in_bytes
000171  aa   000374 3750 04	ana  	252,ic		000565 = 037777400000
000172  aa  5 00005 6551 00	ersa 	pr5|5		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 158
      basic_control_interval.datum_position_table (1).length_in_bits = collection_header_length_in_bytes * BITS_PER_BYTE;

000173  aa  6 00102 2361 00	ldq  	pr6|66		collection_header_length_in_bytes
000174  aa   000011 4020 07	mpy  	9,dl
000175  aa  5 00005 6761 00	erq  	pr5|5		basic_control_interval.length_in_bits
000176  aa   377777 3760 07	anq  	131071,dl
000177  aa  5 00005 6561 00	ersq 	pr5|5		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 160
      basic_control_interval.datum_position_table (2).offset_in_bytes =
	 basic_control_interval.datum_position_table (1).offset_in_bytes - cm_file_header_length_in_bytes;

000200  aa  5 00005 2351 00	lda  	pr5|5		basic_control_interval.offset_in_bytes
000201  aa   000004 7350 00	als  	4
000202  aa   000071 7730 00	lrl  	57
000203  aa  6 00103 1761 00	sbq  	pr6|67		cm_file_header_length_in_bytes
000204  aa   000065 7370 00	lls  	53
000205  aa  5 00006 6751 00	era  	pr5|6		basic_control_interval.offset_in_bytes
000206  aa   000357 3750 04	ana  	239,ic		000565 = 037777400000
000207  aa  5 00006 6551 00	ersa 	pr5|6		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 162
      basic_control_interval.datum_position_table (2).length_in_bits = cm_file_header_length_in_bytes * BITS_PER_BYTE;

000210  aa  6 00103 2361 00	ldq  	pr6|67		cm_file_header_length_in_bytes
000211  aa   000011 4020 07	mpy  	9,dl
000212  aa  5 00006 6761 00	erq  	pr5|6		basic_control_interval.length_in_bits
000213  aa   377777 3760 07	anq  	131071,dl
000214  aa  5 00006 6561 00	ersq 	pr5|6		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 164
      basic_control_interval.datum_position_table (3).offset_in_bytes =
	 basic_control_interval.datum_position_table (2).offset_in_bytes;

000215  aa  5 00006 2351 00	lda  	pr5|6		basic_control_interval.offset_in_bytes
000216  aa  5 00007 6751 00	era  	pr5|7		basic_control_interval.offset_in_bytes
000217  aa   000346 3750 04	ana  	230,ic		000565 = 037777400000
000220  aa  5 00007 6551 00	ersa 	pr5|7		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 166
      basic_control_interval.datum_position_table (3).length_in_bits = 0;

000221  aa   000000 2350 03	lda  	0,du
000222  aa  5 00007 6751 00	era  	pr5|7		basic_control_interval.length_in_bits
000223  aa   377777 3750 07	ana  	131071,dl
000224  aa  5 00007 6551 00	ersa 	pr5|7		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 168
      basic_control_interval.datum_position_table (4).offset_in_bytes =
	 basic_control_interval.datum_position_table (2).offset_in_bytes - BYTES_PER_WORD;

000225  aa  5 00006 2351 00	lda  	pr5|6		basic_control_interval.offset_in_bytes
000226  aa   000004 7350 00	als  	4
000227  aa   000071 7730 00	lrl  	57
000230  aa   000004 1760 07	sbq  	4,dl
000231  aa   000065 7370 00	lls  	53
000232  aa  5 00010 6751 00	era  	pr5|8		basic_control_interval.offset_in_bytes
000233  aa   000332 3750 04	ana  	218,ic		000565 = 037777400000
000234  aa  5 00010 6551 00	ersa 	pr5|8		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 170
      basic_control_interval.datum_position_table (4).length_in_bits = BITS_PER_WORD;

000235  aa   000044 2350 07	lda  	36,dl
000236  aa  5 00010 6751 00	era  	pr5|8		basic_control_interval.length_in_bits
000237  aa   377777 3750 07	ana  	131071,dl
000240  aa  5 00010 6551 00	ersa 	pr5|8		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 172
      basic_control_interval.datum_position_table (5).offset_in_bytes =
	 basic_control_interval.datum_position_table (4).offset_in_bytes
	 - size (initial_file_reservation_map) * BYTES_PER_WORD;

000241  aa  5 00010 2351 00	lda  	pr5|8		basic_control_interval.offset_in_bytes
000242  aa   000004 7350 00	als  	4
000243  aa   000071 7730 00	lrl  	57
000244  aa  6 00206 7561 00	stq  	pr6|134		basic_control_interval.offset_in_bytes
000245  aa   000002 2360 07	ldq  	2,dl
000246  aa   000004 4020 07	mpy  	4,dl
000247  aa  6 00210 7571 00	staq 	pr6|136
000250  aa   000000 5330 00	negl 	0
000251  aa  6 00206 0331 00	adl  	pr6|134		basic_control_interval.offset_in_bytes
000252  aa   000065 7370 00	lls  	53
000253  aa  5 00011 6751 00	era  	pr5|9		basic_control_interval.offset_in_bytes
000254  aa   000311 3750 04	ana  	201,ic		000565 = 037777400000
000255  aa  5 00011 6551 00	ersa 	pr5|9		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 175
      basic_control_interval.datum_position_table (5).length_in_bits =
	 size (initial_file_reservation_map) * BITS_PER_WORD;

000256  aa   000002 2360 07	ldq  	2,dl
000257  aa   000044 4020 07	mpy  	36,dl
000260  aa  6 00212 7571 00	staq 	pr6|138
000261  aa  5 00011 6761 00	erq  	pr5|9		basic_control_interval.length_in_bits
000262  aa   377777 3760 07	anq  	131071,dl
000263  aa  5 00011 6561 00	ersq 	pr5|9		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 178
      basic_control_interval.datum_position_table (6).offset_in_bytes =
	 basic_control_interval.datum_position_table (5).offset_in_bytes
	 - size (unblocked_storage_record) * BYTES_PER_WORD;

000264  aa  5 00011 2351 00	lda  	pr5|9		basic_control_interval.offset_in_bytes
000265  aa   000004 7350 00	als  	4
000266  aa   000071 7730 00	lrl  	57
000267  aa  6 00206 7561 00	stq  	pr6|134		basic_control_interval.offset_in_bytes
000270  aa  6 00210 3371 00	lcaq 	pr6|136
000271  aa  6 00206 0331 00	adl  	pr6|134		basic_control_interval.offset_in_bytes
000272  aa   000065 7370 00	lls  	53
000273  aa  5 00012 6751 00	era  	pr5|10		basic_control_interval.offset_in_bytes
000274  aa   000271 3750 04	ana  	185,ic		000565 = 037777400000
000275  aa  5 00012 6551 00	ersa 	pr5|10		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 181
      basic_control_interval.datum_position_table (6).length_in_bits = size (unblocked_storage_record) * BITS_PER_WORD;

000276  aa  6 00212 2371 00	ldaq 	pr6|138
000277  aa  5 00012 6761 00	erq  	pr5|10		basic_control_interval.length_in_bits
000300  aa   377777 3760 07	anq  	131071,dl
000301  aa  5 00012 6561 00	ersq 	pr5|10		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 183
      basic_control_interval.header.start_of_used_space = basic_control_interval.datum_position_table (6).offset_in_bytes;

000302  aa  5 00012 2351 00	lda  	pr5|10		basic_control_interval.offset_in_bytes
000303  aa   000004 7350 00	als  	4
000304  aa   000071 7730 00	lrl  	57
000305  aa  6 00206 7561 00	stq  	pr6|134		basic_control_interval.offset_in_bytes
000306  aa   000066 7370 00	lls  	54
000307  aa  5 00004 5511 60	stba 	pr5|4,60		basic_control_interval.start_of_used_space
						STATEMENT 1 ON LINE 193
      collection_header_ptr =
	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (1).offset_in_bytes);

000310  aa  5 00000 3521 00	epp2 	pr5|0
000311  aa  2 00005 2351 00	lda  	pr2|5		basic_control_interval.offset_in_bytes
000312  aa   000004 7350 00	als  	4
000313  aa   000071 7730 00	lrl  	57
000314  aa  2 00000 5005 06	a9bd 	pr2|0,ql
000315  aa  6 00116 2521 00	spri2	pr6|78		collection_header_ptr
						STATEMENT 1 ON LINE 196
      collection_header.version = COLLECTION_HEADER_VERSION_2;

000316  aa   777462 2370 04	ldaq 	-206,ic		000000 = 143157154137 150144162062
000317  aa  2 00000 7551 00	sta  	pr2|0		collection_header.version
000320  aa  2 00001 7561 00	stq  	pr2|1		collection_header.version
						STATEMENT 1 ON LINE 197
      collection_header.flags.thread_control_intervals = "1"b;

000321  aa   100000 2350 03	lda  	32768,du
000322  aa  2 00002 2551 00	orsa 	pr2|2		collection_header.thread_control_intervals
						STATEMENT 1 ON LINE 198
      collection_header.maximum_element_size = MAX_ELEMENT_SIZE;

000323  aa   777462 2360 04	ldq  	-206,ic		000005 = 000003641077
000324  aa  2 00004 7561 00	stq  	pr2|4		collection_header.maximum_element_size
						STATEMENT 1 ON LINE 199
      collection_header.control_interval_storage_method = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD;

000325  aa   000002 2350 07	lda  	2,dl
000326  aa  2 00002 5511 14	stba 	pr2|2,14		collection_header.control_interval_storage_method
						STATEMENT 1 ON LINE 200
      collection_header.element_storage_method = BASIC_ELEMENT_STORAGE_METHOD;

000327  aa   000001 2360 07	ldq  	1,dl
000330  aa  2 00003 7561 00	stq  	pr2|3		collection_header.element_storage_method
						STATEMENT 1 ON LINE 201
      collection_header.storage_record_element_id = DEFAULT_STORAGE_RECORD_ELEMENT_ID;

000331  aa   000006 2350 07	lda  	6,dl
000332  aa  2 00006 7551 00	sta  	pr2|6		collection_header.storage_record_element_id
						STATEMENT 1 ON LINE 205
      cm_file_header_ptr =
	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (2).offset_in_bytes);

000333  aa  5 00000 3515 00	epp1 	pr5|0
000334  aa  1 00006 2351 00	lda  	pr1|6		basic_control_interval.offset_in_bytes
000335  aa   000004 7350 00	als  	4
000336  aa   000071 7730 00	lrl  	57
000337  aa  1 00000 5005 06	a9bd 	pr1|0,ql
000340  aa  6 00114 2515 00	spri1	pr6|76		cm_file_header_ptr
						STATEMENT 1 ON LINE 208
      cm_file_header.version = CM_FILE_HEADER_VERSION_1;

000341  aa   777441 2370 04	ldaq 	-223,ic		000002 = 143155137146 150144162061
000342  aa  1 00000 7551 00	sta  	pr1|0		cm_file_header.version
000343  aa  1 00001 7561 00	stq  	pr1|1		cm_file_header.version
						STATEMENT 1 ON LINE 209
      cm_file_header.allocation_map_element_id = BLOCK_MAP_ARRAY_ELEMENT_ID;

000344  aa   000005 2350 07	lda  	5,dl
000345  aa  1 00005 7551 00	sta  	pr1|5		cm_file_header.allocation_map_element_id
						STATEMENT 1 ON LINE 210
      cm_file_header.collection_id_table_element_id = COLLECTION_ID_TABLE_ELEMENT_ID;

000346  aa   000004 2350 07	lda  	4,dl
000347  aa  1 00006 7551 00	sta  	pr1|6		cm_file_header.collection_id_table_element_id
						STATEMENT 1 ON LINE 211
      cm_file_header.number_of_control_intervals_per_block = DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK;

000350  aa   002000 2360 07	ldq  	1024,dl
000351  aa  1 00004 7561 00	stq  	pr1|4		cm_file_header.number_of_control_intervals_per_block
						STATEMENT 1 ON LINE 212
      cm_file_header.number_of_blocks = 1;

000352  aa   000001 2350 07	lda  	1,dl
000353  aa  1 00003 5511 14	stba 	pr1|3,14		cm_file_header.number_of_blocks
						STATEMENT 1 ON LINE 221
      based_byte_string_ptr =
	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (5).offset_in_bytes);

000354  aa  5 00000 3535 00	epp3 	pr5|0
000355  aa  3 00011 2351 00	lda  	pr3|9		basic_control_interval.offset_in_bytes
000356  aa   000004 7350 00	als  	4
000357  aa   000071 7730 00	lrl  	57
000360  aa  3 00000 5005 06	a9bd 	pr3|0,ql
000361  aa  6 00104 2535 00	spri3	pr6|68		based_byte_string_ptr
						STATEMENT 1 ON LINE 223
      bbs_length = size (initial_file_reservation_map) * BYTES_PER_WORD;

000362  aa  6 00210 2371 00	ldaq 	pr6|136
000363  aa  6 00106 7561 00	stq  	pr6|70		bbs_length
						STATEMENT 1 ON LINE 225
      unspec (initial_file_reservation_map) = "0"b;

000364  aa   777432 2370 04	ldaq 	-230,ic		000016 = 000000000000 000000000000
000365  aa  6 00110 7571 00	staq 	pr6|72
						STATEMENT 1 ON LINE 226
      initial_file_reservation_map.lowest_numbered_control_interval = 1;

000366  aa   000001 2350 07	lda  	1,dl
000367  aa  6 00110 7511 17	stca 	pr6|72,17		initial_file_reservation_map.lowest_numbered_control_interval
						STATEMENT 1 ON LINE 227
      initial_file_reservation_map.element_id = ALLOCATION_MAP_ELEMENT_ID;

000370  aa   010001 2350 07	lda  	4097,dl
000371  aa  6 00111 7551 00	sta  	pr6|73		initial_file_reservation_map.element_id
						STATEMENT 1 ON LINE 229
      based_byte_string = addr (initial_file_reservation_map) -> based_byte_string;

000372  aa  6 00106 7271 00	lxl7 	pr6|70		bbs_length
000373  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000374  aa  6 00110 00 0017	desc9a	pr6|72,x7		based_byte_string
000375  aa  3 00000 00 0017	desc9a	pr3|0,x7		based_byte_string
						STATEMENT 1 ON LINE 235
      unblocked_storage_record_ptr =
	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (6).offset_in_bytes);

000376  aa  5 00000 3521 00	epp2 	pr5|0
000377  aa  6 00206 2361 00	ldq  	pr6|134		basic_control_interval.offset_in_bytes
000400  aa  2 00000 5005 06	a9bd 	pr2|0,ql
000401  aa  6 00126 2521 00	spri2	pr6|86		unblocked_storage_record_ptr
						STATEMENT 1 ON LINE 238
      unblocked_storage_record.first_control_interval = 0;

000402  aa  2 00000 4501 00	stz  	pr2|0		unblocked_storage_record.first_control_interval
						STATEMENT 1 ON LINE 239
      unblocked_storage_record.last_control_interval = 1;

000403  aa   000001 2360 07	ldq  	1,dl
000404  aa  2 00001 7561 00	stq  	pr2|1		unblocked_storage_record.last_control_interval
						STATEMENT 1 ON LINE 245
      call file_manager_$simple_put (file_opening_id, 0, START_OF_CI_OFFSET, basic_control_interval_ptr,
	 (CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES), code);

000405  aa  6 00206 4501 00	stz  	pr6|134
000406  aa   006150 2360 07	ldq  	3176,dl
000407  aa  6 00207 7561 00	stq  	pr6|135
000410  aa  6 00101 3521 00	epp2 	pr6|65		file_opening_id
000411  aa  6 00162 2521 00	spri2	pr6|114
000412  aa  6 00206 3521 00	epp2 	pr6|134
000413  aa  6 00164 2521 00	spri2	pr6|116
000414  aa   777372 3520 04	epp2 	-262,ic		000006 = 000000000000
000415  aa  6 00166 2521 00	spri2	pr6|118
000416  aa  6 00112 3521 00	epp2 	pr6|74		basic_control_interval_ptr
000417  aa  6 00170 2521 00	spri2	pr6|120
000420  aa  6 00207 3521 00	epp2 	pr6|135
000421  aa  6 00172 2521 00	spri2	pr6|122
000422  aa  6 00100 3521 00	epp2 	pr6|64		code
000423  aa  6 00174 2521 00	spri2	pr6|124
000424  aa  6 00160 6211 00	eax1 	pr6|112
000425  aa   030000 4310 07	fld  	12288,dl
000426  aa  6 00044 3701 20	epp4 	pr6|36,*
000427  la  4 00014 3521 20	epp2 	pr4|12,*		file_manager_$simple_put
000430  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 247
      if code ^= 0
      then call ERROR_RETURN (code);

000431  aa  6 00100 2361 00	ldq  	pr6|64		code
000432  aa   000003 6000 04	tze  	3,ic		000435
000433  aa   000133 3520 04	epp2 	91,ic		000566 = 000002000000
000434  aa   000101 6700 04	tsp4 	65,ic		000535
						STATEMENT 1 ON LINE 256
      unspec (control_interval_one) = "0"b;

000435  aa  6 00136 2361 00	ldq  	pr6|94
000436  aa   000011 4020 07	mpy  	9,dl
000437  aa   000010 0760 07	adq  	8,dl
000440  aa   000011 5060 07	div  	9,dl
000441  aa  6 00140 3735 20	epp7 	pr6|96,*
000442  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000443  aa   000000 00 0000	desc9a	0,0
000444  aa  7 00000 00 0006	desc9a	pr7|0,ql
						STATEMENT 1 ON LINE 257
      basic_control_interval_ptr = addr (control_interval_one);

000445  aa  7 00000 3715 00	epp5 	pr7|0		control_interval_one
000446  aa  6 00112 6515 00	spri5	pr6|74		basic_control_interval_ptr
						STATEMENT 1 ON LINE 259
      basic_control_interval.layout_type = BASIC_CI_LAYOUT_1;

000447  aa   777335 2350 04	lda  	-291,ic		000004 = 142143151061
000450  aa  5 00000 7551 00	sta  	pr5|0		basic_control_interval.layout_type
						STATEMENT 1 ON LINE 260
      basic_control_interval.header.collection_id = HEADER_COLLECTION_ID;

000451  aa   000001 2350 07	lda  	1,dl
000452  aa  5 00001 7551 00	sta  	pr5|1		basic_control_interval.collection_id
						STATEMENT 1 ON LINE 261
      basic_control_interval.number_of_datums = 1;

000453  aa   000001 2350 07	lda  	1,dl
000454  aa  5 00004 5511 14	stba 	pr5|4,14		basic_control_interval.number_of_datums
						STATEMENT 1 ON LINE 263
      frmf_number_of_control_intervals = DEFAULT_NUMBER_OF_CONTROL_INTERVALS_PER_BLOCK;

000455  aa   002000 2360 07	ldq  	1024,dl
000456  aa  6 00124 7561 00	stq  	pr6|84		frmf_number_of_control_intervals
						STATEMENT 1 ON LINE 265
      basic_control_interval.datum_position_table (1).offset_in_bytes =
	 CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES - INITIAL_ALLOCATION_MAP_LENGTH_IN_BYTES;

000457  aa   007564 2360 07	ldq  	3956,dl
000460  aa   000065 7370 00	lls  	53
000461  aa  5 00005 6751 00	era  	pr5|5		basic_control_interval.offset_in_bytes
000462  aa   000103 3750 04	ana  	67,ic		000565 = 037777400000
000463  aa  5 00005 6551 00	ersa 	pr5|5		basic_control_interval.offset_in_bytes
						STATEMENT 1 ON LINE 267
      basic_control_interval.datum_position_table (1).length_in_bits = frmf_number_of_control_intervals;

000464  aa  6 00124 2361 00	ldq  	pr6|84		frmf_number_of_control_intervals
000465  aa  5 00005 6761 00	erq  	pr5|5		basic_control_interval.length_in_bits
000466  aa   377777 3760 07	anq  	131071,dl
000467  aa  5 00005 6561 00	ersq 	pr5|5		basic_control_interval.length_in_bits
						STATEMENT 1 ON LINE 269
      file_reservation_map_fragment_ptr =
	 addcharno (basic_control_interval_ptr, basic_control_interval.datum_position_table (1).offset_in_bytes);

000470  aa  5 00000 3521 00	epp2 	pr5|0
000471  aa  2 00005 2351 00	lda  	pr2|5		basic_control_interval.offset_in_bytes
000472  aa   000004 7350 00	als  	4
000473  aa   000071 7730 00	lrl  	57
000474  aa  2 00000 5005 06	a9bd 	pr2|0,ql
000475  aa  6 00122 2521 00	spri2	pr6|82		file_reservation_map_fragment_ptr
						STATEMENT 1 ON LINE 272
      substr (file_reservation_map_fragment, 1, 1) = "1"b;

000476  aa   400000 2350 03	lda  	131072,du
000477  aa  2 00000 2551 00	orsa 	pr2|0		file_reservation_map_fragment
						STATEMENT 1 ON LINE 274
      call file_manager_$simple_put (file_opening_id, 1, START_OF_CI_OFFSET, basic_control_interval_ptr,
	 (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES), code);

000500  aa   000001 2360 07	ldq  	1,dl
000501  aa  6 00207 7561 00	stq  	pr6|135
000502  aa   007750 2360 07	ldq  	4072,dl
000503  aa  6 00206 7561 00	stq  	pr6|134
000504  aa  6 00101 3521 00	epp2 	pr6|65		file_opening_id
000505  aa  6 00162 2521 00	spri2	pr6|114
000506  aa  6 00207 3521 00	epp2 	pr6|135
000507  aa  6 00164 2521 00	spri2	pr6|116
000510  aa   777276 3520 04	epp2 	-322,ic		000006 = 000000000000
000511  aa  6 00166 2521 00	spri2	pr6|118
000512  aa  6 00112 3521 00	epp2 	pr6|74		basic_control_interval_ptr
000513  aa  6 00170 2521 00	spri2	pr6|120
000514  aa  6 00206 3521 00	epp2 	pr6|134
000515  aa  6 00172 2521 00	spri2	pr6|122
000516  aa  6 00100 3521 00	epp2 	pr6|64		code
000517  aa  6 00174 2521 00	spri2	pr6|124
000520  aa  6 00160 6211 00	eax1 	pr6|112
000521  aa   030000 4310 07	fld  	12288,dl
000522  aa  6 00044 3701 20	epp4 	pr6|36,*
000523  la  4 00014 3521 20	epp2 	pr4|12,*		file_manager_$simple_put
000524  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 276
      if code ^= 0
      then call ERROR_RETURN (code);

000525  aa  6 00100 2361 00	ldq  	pr6|64		code
000526  aa   000003 6000 04	tze  	3,ic		000531
000527  aa   000037 3520 04	epp2 	31,ic		000566 = 000002000000
000530  aa   000005 6700 04	tsp4 	5,ic		000535
						STATEMENT 1 ON LINE 280
      p_file_opening_id = file_opening_id;

000531  aa  6 00101 2351 00	lda  	pr6|65		file_opening_id
000532  aa  6 00032 3735 20	epp7 	pr6|26,*
000533  aa  7 00010 7551 20	sta  	pr7|8,*		p_file_opening_id
						STATEMENT 1 ON LINE 281
MAIN_RETURN:
      return;

000534  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 327
   end cm_create_file;

BEGIN PROCEDURE ERROR_RETURN
ENTRY TO ERROR_RETURN                                       STATEMENT 1 ON LINE 284
ERROR_RETURN:
   proc (er_p_code);

000535  aa  6 00142 6501 00	spri4	pr6|98
000536  aa  6 00144 2521 00	spri2	pr6|100
						STATEMENT 1 ON LINE 289
      p_code = er_p_code;

000537  aa  2 00002 2361 20	ldq  	pr2|2,*		er_p_code
000540  aa  6 00032 3735 20	epp7 	pr6|26,*
000541  aa  7 00012 7561 20	stq  	pr7|10,*		p_code
						STATEMENT 1 ON LINE 290
      call FINISH ();

000542  aa   000002 6700 04	tsp4 	2,ic		000544
						STATEMENT 1 ON LINE 291
      go to MAIN_RETURN;

000543  aa   777771 7100 04	tra  	-7,ic		000534
						STATEMENT 1 ON LINE 293
   end ERROR_RETURN;

  END PROCEDURE ERROR_RETURN
BEGIN PROCEDURE FINISH
ENTRY TO FINISH                                             STATEMENT 1 ON LINE 296
FINISH:
   proc ();

000544  aa  6 00150 6501 00	spri4	pr6|104
						STATEMENT 1 ON LINE 300
      if p_file_opening_id = "0"b & file_opening_id ^= "0"b
      then call file_manager_$delete_close (file_opening_id, (0));

000545  aa  6 00032 3735 20	epp7 	pr6|26,*
000546  aa  7 00010 2351 20	lda  	pr7|8,*		p_file_opening_id
000547  aa   000015 6010 04	tnz  	13,ic		000564
000550  aa  6 00101 2351 00	lda  	pr6|65		file_opening_id
000551  aa   000013 6000 04	tze  	11,ic		000564
000552  aa  6 00214 4501 00	stz  	pr6|140
000553  aa  6 00101 3521 00	epp2 	pr6|65		file_opening_id
000554  aa  6 00220 2521 00	spri2	pr6|144
000555  aa  6 00214 3521 00	epp2 	pr6|140
000556  aa  6 00222 2521 00	spri2	pr6|146
000557  aa  6 00216 6211 00	eax1 	pr6|142
000560  aa   010000 4310 07	fld  	4096,dl
000561  aa  6 00044 3701 20	epp4 	pr6|36,*
000562  la  4 00012 3521 20	epp2 	pr4|10,*		file_manager_$delete_close
000563  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 303
   end FINISH;

000564  aa  6 00150 6101 00	rtcd 	pr6|104
  END PROCEDURE FINISH
  END PROCEDURE cm_create_file


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
