	COMPILATION LISTING OF SEGMENT mrds_dsl_optimize
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1114.54_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-06-14 by Thanh
       17*     Nguyen. (see mrds #137, #139 (phx19906)
       18*  2) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       19*     audit(88-07-06,Dupuis), install(88-08-01,MR12.2-1073):
       20*     For the new parser, modified the way that the range and select list
       21*     pointers are set.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 mrds_dsl_optimize: proc (dbcb_ptr, pred_ptr, so_ptr, code);
       26 
       27 /*
       28*   .                        BEGIN_DESCRIPTION
       29*   This  procedure performs final processing and optimization of the predicate
       30*   tree  resulting  from  the -where clause.  All "not" nodes are removed, and
       31*   all  "or" node are moved so that none appears subordinate to an "and" node.
       32*   At  this point, the usefulness of the tree structure disappears, and so the
       33*   tree  is  converted  into a list of "and groups".  After the predicate tree
       34*   optimization, a "program" for mrds_dsl_search is generated.
       35*
       36*
       37*
       38*   INPUT CONDITIONS:
       39*
       40*   dbcb_ptr  points  to  a valid DBCB and pred_ptr points to a valid
       41*   predicate tree.
       42*
       43*
       44*
       45*   OUTPUT DEFINITIONS:
       46*
       47*   dbcb.pred_ptr will point to an array of "and groups".
       48*
       49*   code = 0;  if no errors are detected.
       50*
       51*   code  = mrds_error_$node_stack_ovfl; if one of the internal stacks used for
       52*   traversing the tree overflows.
       53*
       54*   code = mrds_error_$max_and_groups;  if there are too many and groups.
       55*
       56*   code  =  mrds_error_$max_and_terms; if there are too many terms to fit into
       57*   an and group;
       58*
       59*   code  = mrds_error_$var_stack_ovfl; if the variable stack used for ordering
       60*   terms within an and group overflows.
       61*
       62*   code  = mrds_error_$no_tuple_effect; if there are tuple variables that have
       63*   no effect on the select set.
       64*
       65*  HIGH LEVEL VIEW:
       66*       a. If no predicate tree (no where clause)
       67*	do  cross	 product	over  all	 tuple  variables,	if  a
       68*	relation	has  no tuples  the search  program generated
       69*	will  cause the  tuple not  found error	 to be returned
       70*	with out causing any i/o to the database
       71*       b. else
       72*	  1. convert predicate  tree to disjuctive  normal form
       73*	     and go from a tree to a list.
       74*	  2. loop
       75*	       a. determine	 optimium	 search	path  for	 each
       76*		and-group (mrds_dsl_permute)
       77*	       b. generate	search  program for	 each and-group
       78*		(mrds_dsl_gen_srch_prog)
       79*	  3. build  global	search program  over  all and-group
       80*	     search programs.   Done by sorting	 each and-group
       81*	     search  program  and building  the global  list by
       82*	     putting  the  ones with	the smallest  cost first,
       83*	     and-groups with zero cost are removed.
       84*
       85*  NOTES:
       86*       1. if  no-optimize is	set than	and-group search programs
       87*	are not sorted  by cost or if cross  product not sorted
       88*	by relation size.
       89*       2. output from print_search_order is done from optimize.
       90*   .                        END_DESCRIPTION
       91*
       92*   MRDS_DEBUG_TOOL SWITCH DEFINITIONS:
       93*
       94*   bit 1 = perdicate tree display switch
       95*
       96*   bit 2 = search paths display switch
       97*
       98*   bit 3 = use calc_cost in addition to permute to determine search paths
       99*
      100*   bits 4 thru 9 = not used
      101*
      102*
      103*
      104*   HISTORY:
      105*
      106*   76-03-01 J. A. Weeldreyer: Initially written.
      107*
      108*   76-08-01 J. A. Weeldreyer: Modified to create  pseudo  terms  for
      109*   undetermined free terms.
      110*
      111*   76-09-01 J.  A.  Weeldreyer:  Modified  to  fix  and_group  shift
      112*   problem.
      113*
      114*   77-04-01 J. A. Weeldreyer: Modified  to  fix  a  term  reordering
      115*   problem.
      116*
      117*   77-09-01 J. A. Weeldreyer:  Modified  to  fix  yet  another  term
      118*   reordering problem.
      119*
      120*   77-04-01 J. A. Weeldreyer: Modified to incorporate MR6.0 changes.
      121*
      122*   77-09-01 J. A. Weeldreyer: Modified to eliminate concept of bound
      123*   variables.
      124*
      125*   78-03-01 J. A. Weeldreyer: Modified to  fix  more  bugs  in  term
      126*   reordering and copying.
      127*
      128*   78-11-01 J. A. Weeldreyer: Modified for MR7.0.
      129*
      130*   79-04-24  Al  Kepner:  Modified  to  (1)   initialize   cost   in
      131*   path_array, (2) to rewrite combining of all search op tables into
      132*   one in create_search_lists.
      133*
      134*   79-06-01 Al Kepner: Modified by to use select_area.
      135*
      136*   79-07-16 NSDavids: Modified to build  a  search  path  using  all
      137*   tuple  variables  in  range  clause.  also  to  check for a tuple
      138*   variable that has no effect on  the  select  set  and  return  an
      139*   error.
      140*
      141*   79-10-22 Rickie E. Brinegar: Modified to call mrds_dsl_permute to
      142*   get  the  absolute  minmum  cost  path,  and  to  make use of the
      143*   mrds_debug_tool with mrds_debug_names.
      144*
      145*   80-01-21 Rickie E. Brinegar: Modified  to  properly  account  for
      146*   range variables not used in a particular and group.
      147*
      148*   80-01-23 Davids: modified determine_min_cost_segment so  that  if
      149*   all  paths  have  already  been  looked  at it returns a null pvp
      150*   pointer   rather   than   just   returning   what   was    given.
      151*   create_search_lists  has  been modifed to work with the case of a
      152*   returned null pointer.
      153*
      154*   80-01-24  Davids:  path_var_flags  is  reset  to  "0"  for   each
      155*   and-group rather than retaining flag values from last and group.
      156*
      157*   80-04-11 Rickie E. Brinegar: Modified  to  make  mdb_calc_cost  a
      158*   debug tool using debug switch number 3.
      159*
      160*   80-09-23 Jim Gray: Modified to capture max_and_groups overflow in
      161*   the routine cannonize_pred in one case that was overlooked.
      162*
      163*   81-03-27 Jim Gray : added dbcb_ptr parameter  to  mu_get_rel_size
      164*   as part of getting rid of mus_ptr_man module.
      165*
      166*   81-03-30 Jim Gray : for TR 9457, moved a check for  only  a  left
      167*   branch  "or",  in the canonize_pred routine, to handle both right
      168*   and left branches. Problem  symptom  was  that  (a|b)&(c|d)&(e|f)
      169*   type queries would not return all matching tuples.
      170*
      171*   01-06-01 Jim Gray : changed to use new resultant structure.  Also
      172*   renamed rmds_dsl_calc_cost to mdb_calc_cost.
      173*
      174*   81-06-17  Jim  Gray  :  added  call  to  mu_open_iocb_manager  to
      175*   implement attach/open of iocbs on an as needed basis.
      176*
      177*   81-06-23 Jim  Gray  :  changed  sort  order  for  the  cross_prod
      178*   routine,  so  that  search program generated is to do the smaller
      179*   relations first.
      180*
      181*
      182*   81-06-24 Jim Gray : added capture of case when cross product will
      183*   be  empty, so that no retrieves have to be done to find this out.
      184*   This  can  only  be  done  for  non   set   operation   selection
      185*   expressions.
      186*
      187*   81-06-26 Roger Lackey : added  code  to  handle  no_optimize  and
      188*   print_search_order
      189*
      190*   81-07-01 Jim Gray : modified  print_search_order  for  the  cross
      191*   product case to use the real search order, not the tuple variable
      192*   order.
      193*
      194*   81-07-02 Jim Gray : changed method  of  getting  tuple  count  in
      195*   cross_prod,  to  get  it from rm_rel_info statistics, rather than
      196*   calling mu_get_rel_size. Also changed -no_optimize, to only avoid
      197*   sorting, noptimize the getting of rel sizes.
      198*
      199*   81-07-09 Jim Gray  :  removed  code  dealing  with  mdb_calc_cost
      200*   logic,  as  this  routine  does  not  support  the  new  path_var
      201*   structure and constants.
      202*
      203*   81-07-14 Jim Gray : changed -print_search_order display to output
      204*   additional  info  now  available  in  path_var  structure, and to
      205*   separate and group info.  Also  added  logic  to  display  access
      206*   method  as  indexed  attr  if  the  user  is  a peon on a secured
      207*   database and actually has  a  key  access  method.  Added  proper
      208*   handling  of  temp rel names, and changed internal form of access
      209*   method names to better user visible ones. Revamped output format.
      210*
      211*   81-07-15 Jim Gray : changed method of determining whether a tuple
      212*   variable  has an effect on the select set for the case of a where
      213*   clause.  The  previous  method  relied  on   mdb_calc_cost.   Now
      214*   existance of conditions in the where clause is determined as well
      215*   as use in the select clause. One or the other must exist. If only
      216*   present in the select clause we have a cross product effect. Also
      217*   removed all  use  of  the  path_array  which  was  only  used  by
      218*   mdb_cal_cost.
      219*
      220*   81-07-16 Jim Gray : changed cross product print search order  ioa
      221*   parameters  so that the order in the array was used for the ORDER
      222*   output, and also so that the size  was  gotten  from  the  proper
      223*   place  in  the  array. Also changed tuple_no_effect logic for the
      224*   where clause case, so that tuple variables appearing last in  the
      225*   list with no conditions, but really used are properly handled.
      226*
      227*   81-07-17 Jim Gray : modified method by  which  several  and_group
      228*   search  programs  were  made into a single search_op program. The
      229*   individual and_group search_op programs are now sorted  based  on
      230*   their cost. This will help improve the performance of getting the
      231*   first tuple from a multiple and group select expr.
      232*
      233*   81-07-18 Jim Gray : added logic to make a phony search program of
      234*   just  return_null  for  the  case where all and groups contain an
      235*   unpopulated  relation,  and  thus  can  not  be  satistied.  Also
      236*   extended  the  fix to the cross product case, to make it work for
      237*   set S.E.'s, and allow display of the -pso  output  regardless  of
      238*   the situation.
      239*
      240*   81-07-19 Jim Gray : extended  the  fix  for  the  no_tuple_effect
      241*   detection  so it could handle the case -select A -where (A & B) |
      242*   (A & C) or the case -select A -where A | B.
      243*
      244*   81-07-21 Jim Gray : modified -pso output, where clause  case,  to
      245*   show both conditions when permute used a range against a key head
      246*   or indexed attr.
      247*
      248*   81-07-23  Roger  Lackey  :   set   dbcb.pred_ptr   for   use   by
      249*   mrds_dsl_retrieve auto dup
      250*
      251*   81-07-24 Jim Gray : changed setting of  dbcb.pred_ptr  to  handle
      252*   case  of  where  clause. The input pred_ptr is to the root of the
      253*   predicate tree. This value is changed in cannonize_pred to  point
      254*   to the pred_array.
      255*
      256*   81-09-10  Rickie E.  Brinegar: Removed (no-subrg) prefix that was
      257*   buried in the code as (subrg) is not on except in the development.
      258*
      259*   81-09-11 Davids: enclosed both target and source of two assigment
      260*   statements  with  unspec.  This  was done to get around a pl1 bug
      261*   which causes the subscriptrange condition to be signaled when the
      262*   module  is  compiled  with the subscriptrange prefix. The pl1 bug
      263*   was reported as tr11508.
      264*
      265*   81-09-19  Davids:  changed  the  lowest  index   reference   into
      266*   path_var_pointer_array  to 1 from 0. The reference to index 0 was
      267*   causing a subscriptrange condition to occur.
      268*
      269*   81-09-29 Davids: modified section of code dealing with zero  cost
      270*   and-groups. moved the setting of the err_xfer within the scope of
      271*   the if cost ^= 0 statement, it was just outside the scope,  which
      272*   resulted  in  subscriptrange  conditions when begin_and_group was
      273*   not set.
      274*
      275*   82-06-14 Davids: added high level view and notes.
      276*
      277*   82-09-01 Mike Kubicar : converted from using the tuple structure to
      278*   using the vector structure.  In this module, this means using an index
      279*   into the tuple structure (select_info.tuple_info_index) instead of
      280*   a pointer to where a tuple will be place (select_info.t_ptr).
      281*
      282*   82-09-23 Davids: removed references to the file_io_array and the 
      283*   rm_rel_info.iocb_ptr array and mu_open_iocb_manager and replaced
      284*   them with a call to mu_cursor_manager_$get.
      285*
      286*   82-10-26 Davids: Modified so the cursor set up in the cross_prod
      287*   internal proc always uses the record collection (rel_id). It was
      288*   using the record collection if the ready_mode was retrieval and the
      289*   primary key collection if the ready mode was update.
      290*
      291*   82-11-12 Mike Kubicar : Due to problems with vrm_relmgr_, the previous
      292*   change had to be backed out.
      293*
      294*   82-11-29 Davids: Modified so name of a temp rel dispalyed by the -pso
      295*   option is the temp rel index. This was inadvertently changed when the
      296*   use of the rm_rel_info.rel_id element changed to be a relation manager
      297*   identifier.
      298*
      299*   83-04-04 Mike Kubicar : Removed distinction between unordered and ordered
      300*   sequential searches.  -pso should only print out sequential search.
      301*   Also, for cross products, only generate a record collection cursor ptr.
      302*
      303*   83-04-22 Mike Kubicar : If there is no where clause, cross_product must
      304*   generate a search specification that will select the entire relation.
      305*   Also, removed all references to the obsolete structure init_info.
      306*
      307*   83-05-03 Mike Kubicar : Added initialization of rtrv_info (or its alias)
      308*   .maxtids.
      309*
      310*   83-05-25 Ron Harvey : Added the build_vectors routine to support the 
      311*   shortened simple_typed_vector changes.
      312*
      313*   83-05-31 Mike Kubicar : Updated to use the new (version 4) search
      314*   specification.
      315*
      316*   83-08-04 Mike Kubicar : Added code to set up all the element id lists
      317*   needed by the search program.  The element_id_list_segment is evenly
      318*   divided among all the tuple variables.
      319*
      320*   83-08-05 Ron Harvey : Modified the build_vectors routine to back out the
      321*   shortened simple_typed_vector changes.
      322*
      323*   83-10-24 Mike Kubicar - Changed to only request
      324*   mrds_data_$max_tids_returned_per_call tuple ids be returned in the element
      325*   id list instead of as many as possible.  This is due to a customer request
      326*   that mrds be more interactive (i.e. they liked it the old way).
      327*
      328*   85-04-08 Thanh Nguyen - Added code to set the max_tids to be either 
      329*   max_tids_returned_per_call or max_safe_tids_returned_per_call depending on 
      330*   the scope of the relation is shared or not.
      331*
      332*   85-06-14 Thanh Nguyen - Added code to check if the relation is temporary
      333*   (rm_rel_info.file_type = 3) then set max_tids to be 
      334*   max_tids_returned_per_call and not validate the scopes.  Also rewrote
      335*   the calculation method for the size of element_id_list structure.
      336**/
      337 
      338 
      339 	display_predicate_tree = substr (db_mrds_dsl_optimize, 1, 1);
      340 	display_search_paths = substr (db_mrds_dsl_optimize, 2, 1);
      341 	num_ptrs = 0;
      342 	rdbi_ptr = dbcb.rdbi_ptr;
      343           range_ptr = dbcb.range_ptr;
      344 	select_list_ptr = dbcb.select_ptr;
      345 	ti_ptr = dbcb.ti_ptr;
      346 
      347 	select_area_ptr = dbcb.select_area_ptr;
      348 	sa_alloc = "0"b;
      349 	sap = null ();
      350 	or_top = 0;
      351 	if pred_ptr = null then do;			/* if no pred. */
      352 		dbcb.pred_ptr = null ();		/* no and groups */
      353 		call cross_prod;			/* either rel dump, or cross prod. */
      354 	     end;
      355 
      356 	else do;					/* if pred. specified */
      357 		call canonize_pred;			/* put in disjunctive normal form */
      358 
      359 		dbcb.pred_ptr = pred_ptr;		/* to pred_array */
      360 
      361 		call create_search_lists;		/* generate the program for search */
      362 
      363 	     end;
      364 
      365 	code = 0;					/* tell caller the good news */
      366 
      367 exit:	return;
      368 
      369 cross_prod: proc;
      370 
      371 /* Procedure to build search info for select block with no where clause.  THis
      372*   implies either a relation dump or a cross product. */
      373 
      374 	dcl     (i,
      375 	        j,
      376 	        ii,
      377 	        si,
      378 	        vi,
      379 	        rvi,
      380 	        rni)		 fixed bin;
      381 	dcl     sz		 fixed bin (35);
      382 	dcl     next_element_id_list_ptr ptr;
      383 
      384 	dcl     sub_err_		 entry options (variable);
      385 	dcl     retval		 fixed bin (35);	/* to make sub_err_ happy */
      386 
      387 	sa_nvars = range.num_vars;			/* init */
      388 	if sa_nvars < 4				/* try to use stack space */
      389 	then sa_ptr = addr (wkspc1);
      390 	else do;					/* if must allocate */
      391 		allocate size_array in (select_area);	/* Allocations in select_area are never freed.  This area
      392*						   is reinitialized at the beginning
      393*						   of each new selection expression. */
      394 		sa_alloc = "1"b;
      395 	     end;
      396 
      397 	code = 0;
      398 	do i = 1 to sa_nvars;			/*  get size of each relation */
      399 
      400 	     size_array.var_index (i) = i;
      401 	     size_array.size (i) = range.tup_var (i).ri_ptr -> rm_rel_info.current_tuple_population;
      402 	     if size_array.size (i) = 0 then
      403 		icode = mrds_error_$tuple_not_found;
      404 	end;
      405 
      406 	if ^dbcb.no_optimize then do;			/* don't sort if -no_optimize specified */
      407 
      408 		nxchng = sa_nvars;
      409 		do i = sa_nvars by -1 to 2 while (nxchng > 0); /* sort by size */
      410 		     nxchng = 0;
      411 		     do j = 2 to i;
      412 
      413 
      414 /* do the smaller relations first in the cross product */
      415 
      416 			if size_array.size (j) < size_array.size (j - 1) then do; /* must exchange */
      417 				sz = size_array.size (j);
      418 				vi = size_array.var_index (j);
      419 				size_array.size (j) = size_array.size (j - 1);
      420 				size_array.var_index (j) = size_array.var_index (j - 1);
      421 				size_array.var_index (j - 1) = vi;
      422 				size_array.size (j - 1) = sz;
      423 				nxchng = nxchng + 1;
      424 			     end;			/* exchanging */
      425 		     end;				/* j loop */
      426 		end;				/* i loop */
      427 	     end;					/* END of else do   to optimize */
      428 
      429 
      430 /* if a 0 size relation was detected, we can not ever return
      431*   any tuples from a cross product involving it. Thus we can improve
      432*   performance by generating a search program that does not do I/O,
      433*   but simply does the return_null operation instead. */
      434 
      435 	if icode = mrds_error_$tuple_not_found then do;
      436 
      437 /* null cross product becuase of 0 size relation,
      438*   force a dummy search program that will work with set S.E.'s
      439*   and not do any I/O, just return the tuple_not_found error */
      440 
      441 		so_nops_init = 1;
      442 		allocate search_ops in (select_area);
      443 
      444 		search_ops.ic = 1;
      445 		search_ops.nops = 1;
      446 		search_ops.op.code (1) = RETNUL;
      447 		icode,				/* reset to not really error at this point */
      448 		     search_ops.op.var_ind (1),
      449 		     search_ops.op.good_xfer (1),
      450 		     search_ops.op.err_xfer (1) = 0;
      451 		search_ops.op.info_ptr (1) = null ();
      452 
      453 	     end;
      454 	else do;
      455 	          /* We start on a new select expression, so turn scopes_changed flag and shared mode flag off. */
      456 	          dbcb.non_shared_to_shared = "0"b;
      457 	          dbcb.scopes_changed = "0"b;
      458 		sv_nvars_init = sa_nvars;		/* init. search tables */
      459 		so_nops_init = 2 * sa_nvars + 3;
      460 		allocate search_vars in (select_area);	/* Allocations in select_area are never freed.  This area
      461*						   is reinitialized at the beginning
      462*						   of each new selection expression. */
      463 		string (search_vars.new_val) = "0"b;
      464 		allocate search_ops in (select_area);	/* Allocations in select_area are never freed.  This area
      465*						   is reinitialized at the beginning
      466*						   of each new selection expression. */
      467 
      468 
      469 
      470 		search_ops.ic = 1;
      471 		search_ops.op.code (1) = PICKUP_SVP;	/* init to pick up sv ptr */
      472 		search_ops.op.info_ptr (1) = sv_ptr;
      473 		search_ops.op.var_ind (1) = 0;
      474 		search_ops.op.good_xfer (1) = 1;
      475 		search_ops.op.err_xfer = 0;
      476 		next_element_id_list_ptr = dbcb.element_id_list_segment_ptr;
      477 
      478 		do i = 1 to sa_nvars;		/* fill in search tables for each var. */
      479 
      480 		     if ^range.tup_var (i).used	/* if ^a tuple variable has been defined */
      481 		     then do;			/* but is not used in the select set */
      482 			     call sub_err_ (mrds_error_$no_tuple_effect, "mrds_dsl_optimize", "c", null (), retval,
      483 				"A Useless tuple variable is ^a", range.tup_var (i).name);
      484 
      485 			     call error (mrds_error_$no_tuple_effect);
      486 			end;
      487 		     rmri_ptr,
      488 			search_vars.info.ri_ptr (i) = range.tup_var.ri_ptr (i); /* fill search vars info */
      489 
      490 		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (i), rm_rel_info.rel_id,
      491 			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open, dbcb.cursor_ptrs_storage_ptr,
      492 			dbcb.cursor_storage_area_ptr, search_vars.info.relation_cursor_ptr (i), icode);
      493 		     if icode ^= 0
      494 		     then call error (icode);
      495 		     search_vars.info.ntids (i),
      496 			search_vars.info.ctid (i) = 0;
      497 		     current_max_tids_per_call = mrds_data_$max_tids_returned_per_call;
      498 		     if rm_rel_info.file_type ^= 3 then do;
      499 			/* we have a real relation here. */
      500 			current_scope_ptr = rm_rel_info.scope_flags_ptr;
      501 			if current_scope_flags.permits.read_attr |
      502 			   current_scope_flags.permits.delete_tuple |
      503 			   current_scope_flags.permits.modify_attr then
      504 			   if ^current_scope_flags.prevents.modify_attr |
      505 			     (^current_scope_flags.prevents.append_tuple &
      506 			     ^current_scope_flags.prevents.delete_tuple) then
      507 			     current_max_tids_per_call = mrds_data_$max_safe_tids_returned_per_call;
      508 		     end;
      509 		     search_vars.info.maxtids (i) = current_max_tids_per_call;
      510 		     search_vars.info.ta_ptr (i) = next_element_id_list_ptr;
      511 		     next_element_id_list_ptr = addrel (search_vars.info.ta_ptr (i),
      512 			current_max_tids_per_call + 2);
      513 		     /* There are two words of header in an element id list */
      514 		     element_id_list_ptr = search_vars.info.ta_ptr (i);
      515 		     element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      516 		     element_id_list.number_of_elements = 0;
      517 		     ii = 2 * i;
      518 		     si = 2 * i + 1;
      519 						/* fill in search op items */
      520 
      521 		     search_ops.op.info_ptr (ii) = null ();
      522 		     allocate select_info in (select_area); /* Allocations in select_area are never freed.  This area
      523*						   is reinitialized at the beginning
      524*						   of each new selection expression. */
      525 		     search_ops.op.info_ptr (si) = seli_ptr;
      526 		     select_info.cvla_ptr = null;
      527 		     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= size_array.var_index (i));
      528 		     end;
      529 		     select_info.tuple_info_index = j;
      530 		     select_info.tid_ptr = addr (tuple_info.tuple.tuple_id (j));
      531 		     rss_number_of_and_groups = 0;
      532 		     rss_maximum_number_of_constraints = 0;
      533 		     allocate relation_search_specification in (select_area);
      534 		     relation_search_specification.head.version = SPECIFICATION_VERSION_4;
      535 		     relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
      536 		     relation_search_specification.head.pad = "0"b;
      537 		     relation_search_specification.head.subset_specification_ptr = null ();
      538 		     relation_search_specification.maximum_number_of_constraints =
      539 			rss_maximum_number_of_constraints;
      540 		     relation_search_specification.number_of_and_groups =
      541 			rss_number_of_and_groups;
      542 		     relation_search_specification.range.type = LOW_RANGE_TYPE;
      543 		     relation_search_specification.range.size = current_max_tids_per_call;
      544 		     relation_search_specification.flags.return_unique_tuples = "0"b;
      545 		     relation_search_specification.flags.mbz = "0"b;
      546 		     select_info.relation_search_specification_ptr = relation_search_specification_ptr;
      547 		     search_ops.op.code (ii) = INIT;
      548 		     search_ops.op.code (si) = SEL;
      549 		     search_ops.op.var_ind (ii),
      550 			search_ops.op.var_ind (si) = size_array.var_index (i);
      551 		     search_ops.op.good_xfer (ii) = 1;
      552 		     search_ops.op.good_xfer (si) = 1;
      553 		     if i = 1 then do;		/* if first set of ops */
      554 			     search_ops.op.err_xfer (ii) = 2 * sa_nvars + 1;
      555 			     search_ops.op.err_xfer (si) = 2 * sa_nvars;
      556 			end;
      557 		     else do;
      558 			     search_ops.op.err_xfer (ii) = -1;
      559 			     search_ops.op.err_xfer (si) = -2;
      560 			end;
      561 
      562 		end;				/* fill ing in var and op info */
      563 		rvi = 2 * sa_nvars + 2;
      564 		rni = 2 * sa_nvars + 3;
      565 		search_ops.op.code (rvi) = RETVAL;	/* fill in return search ops */
      566 		search_ops.op.code (rni) = RETNUL;
      567 		search_ops.op.var_ind (rvi),
      568 		     search_ops.op.var_ind (rni),
      569 		     search_ops.op.good_xfer (rni),
      570 		     search_ops.op.err_xfer (rni),
      571 		     search_ops.op.err_xfer (rvi) = 0;
      572 		search_ops.op.good_xfer (rvi) = -1;
      573 		search_ops.op.info_ptr (rvi),
      574 		     search_ops.op.info_ptr (rni) = null;
      575 
      576 	     end;
      577 
      578 /* Set up the simple typed vector  and id list ptrs */
      579 
      580 	call build_vectors;
      581 
      582 	if dbcb.print_search_order then do;		/* Print the order tuple variable are used  */
      583 
      584 		call ioa_ ("^/Tuple variables listed in search order - - all accessed sequentially.");
      585 		do z = 1 to sa_nvars;
      586 
      587 		     i = size_array.var_index (z);
      588 
      589 		     if range.tup_var.temp_rel (i) then
      590 			rel_name = ltrim (before (after (range.tup_var.ri_ptr (i) -> rm_rel_info.model_name, "."), "."), "0")
      591 			     || " (temp rel index)";
      592 		     else rel_name = range.tup_var.ri_ptr (i) -> rm_rel_info.name;
      593 
      594 		     call ioa_ ("^/Order: ^d  Tuple variable: ""^a""^5xRelation name: ""^a""^/^11xRelation size: ^d",
      595 			z, range.tup_var.name (i), rel_name, size_array.size (z));
      596 		end;
      597 		call ioa_ ("");			/* give um a line feed */
      598 
      599 	     end;					/* END if print_search_order */
      600      end cross_prod;
      601 
      602 canonize_pred: proc;
      603 
      604 /* Procedure to convert predicate tree to disjunctive normal form. */
      605 
      606 /* This first section eliminates not nodes from the tree by negating the operator of the descendent node */
      607 
      608 	top = 1;					/* init. the node stack */
      609 	node_stack (top) = pred_ptr;
      610 
      611 	do while (top > 0);				/* while we have not exhausted the stack */
      612 
      613 	     pn_ptr = node_stack (top);		/* look at top node in stack */
      614 	     top = top - 1;
      615 
      616 	     if pred_node.id.op_code = AND_OP /* if and node or or node */
      617 		| pred_node.id.op_code = OR_OP then do;
      618 
      619 		     if top + 2 > mrds_data_$max_pred_depth then
      620 			call error (mrds_error_$node_stack_ovfl); /* if we would overflow the stack */
      621 		     node_stack (top + 1) = pred_node.rbr; /* add branches to stack */
      622 		     node_stack (top + 2) = pred_node.lbr;
      623 		     top = top + 2;
      624 
      625 		end;				/* and or or node */
      626 
      627 	     else if pred_node.id.op_code = NOT_OP then do; /* if a not node */
      628 
      629 		     c_ptr = pred_node.lbr;		/* point to child */
      630 		     if c_ptr -> pred_node.term then /* if child is term */
      631 			c_ptr -> pred_node.id.op_code = neg_op (fixed (c_ptr -> pred_node.id.op_code));
      632 						/* negate the opcode of child */
      633 		     else if c_ptr -> pred_node.id.op_code = AND_OP /* if child is and or or */
      634 			| c_ptr -> pred_node.id.op_code = OR_OP then do;
      635 
      636 /* ^(a & b) => ^a | ^b, ^(a | b) => ^a & ^b */
      637 
      638 			     if c_ptr -> pred_node.id.op_code = AND_OP then /* reverse the op code */
      639 				c_ptr -> pred_node.id.op_code = OR_OP;
      640 			     else c_ptr -> pred_node.id.op_code = AND_OP;
      641 
      642 			     allocate pred_node in (select_area) set (notr_ptr);
      643 						/* alloc. temp not nodes */ /* Allocations in select_area are never freed.  This area
      644*						   is reinitialized at the beginning
      645*						   of each new selection expression. */
      646 			     allocate pred_node in (select_area) set (notl_ptr);
      647 						/* Allocations in select_area are never freed.  This area
      648*						   is reinitialized at the beginning
      649*						   of each new selection expression. */
      650 
      651 /* it is not necessary to completely fill in these nodes, since they will exist only through the next iteration */
      652 
      653 			     notl_ptr -> pred_node.type,
      654 				notr_ptr -> pred_node.type = NODE;
      655 			     notl_ptr -> pred_node.id.op_code,
      656 				notr_ptr -> pred_node.id.op_code = NOT_OP;
      657 			     string (notl_ptr -> pred_node.id.lleaf_id),
      658 				string (notl_ptr -> pred_node.id.rleaf_id),
      659 				string (notr_ptr -> pred_node.id.lleaf_id),
      660 				string (notr_ptr -> pred_node.id.rleaf_id),
      661 				notl_ptr -> pred_node.root,
      662 				notr_ptr -> pred_node.root,
      663 				notl_ptr -> pred_node.term,
      664 				notr_ptr -> pred_node.term = "0"b;
      665 			     notl_ptr -> pred_node.lbr = c_ptr -> pred_node.lbr; /* splice new not nodes between
      666*						   child & his branches */
      667 			     notr_ptr -> pred_node.lbr = c_ptr -> pred_node.rbr;
      668 			     notl_ptr -> pred_node.parent,
      669 				notr_ptr -> pred_node.parent = c_ptr;
      670 			     c_ptr -> pred_node.lbr = notl_ptr;
      671 			     c_ptr -> pred_node.rbr = notr_ptr;
      672 
      673 			     if top + 2 > mrds_data_$max_pred_depth then /* if we would overflow stack */
      674 				call error (mrds_error_$node_stack_ovfl);
      675 
      676 			     node_stack (top + 1) = notr_ptr; /* add new nodes to stack */
      677 			     node_stack (top + 2) = notl_ptr;
      678 			     top = top + 2;
      679 
      680 			end;			/* if & or | node */
      681 
      682 		     else if c_ptr -> pred_node.id.op_code = NOT_OP then do; /* if child is not */
      683 
      684 /* ^^a => a */
      685 
      686 			     pred_node.lbr = c_ptr -> pred_node.lbr; /* remove lower ^ node */
      687 			     if top + 1 > mrds_data_$max_pred_depth then /* if we would overflow stack */
      688 				call error (mrds_error_$node_stack_ovfl);
      689 
      690 			     node_stack (top + 1) = pred_node.lbr;
      691 			     top = top + 1;
      692 
      693 			end;			/* if ^ node */
      694 
      695 		     if pred_node.root then do;	/* if current is root, have no parent */
      696 			     pred_ptr = c_ptr;	/* child now becomes root */
      697 			     c_ptr -> pred_node.root = "1"b;
      698 			end;
      699 		     else /* if not root then have parent */
      700 			if pred_node.parent -> pred_node.lbr = pn_ptr then /* if current is left br. */
      701 			pred_node.parent -> pred_node.lbr = c_ptr; /* remove current node */
      702 		     else /* current is right br. */
      703 			pred_node.parent -> pred_node.rbr = c_ptr;
      704 
      705 		end;				/* if current was ^ node */
      706 
      707 	end;					/* loop to remove not nodes */
      708 
      709 /* Have now eliminated all not nodes from the tree.  Now we rearrange the
      710*   remainder of the tree so that no | nodes are subordinate to any & nodes (disjunctive normal form). */
      711 
      712 	top = 1;					/* init node stack */
      713 	node_stack (top) = pred_ptr;
      714 
      715 	do while (top > 0);				/* while stack is not exhausted */
      716 
      717 	     pn_ptr = node_stack (top);		/* pick up top node from stack */
      718 	     top = top - 1;
      719 
      720 	     if ^pred_node.term then do;		/* if and or or */
      721 		     if top + 2 > mrds_data_$max_pred_depth then /* if we would overflow the stack */
      722 			call error (mrds_error_$node_stack_ovfl);
      723 		     node_stack (top + 1) = pred_node.rbr; /* add branches to stack */
      724 		     node_stack (top + 2) = pred_node.lbr;
      725 		     top = top + 2;
      726 		end;				/* if & or | */
      727 
      728 	     if pred_node.id.op_code = OR_OP & ^pred_node.root then /* if or which may need moving */
      729 		if pred_node.parent -> pred_node.id.op_code = AND_OP then do;
      730 
      731 			p_ptr = pred_node.parent;	/* pick up parent pointer */
      732 			c_ptr = pn_ptr;		/* current node becomes child */
      733 			done = "0"b;		/* init compl. flag */
      734 
      735 			do while (^done);		/* while the or needs to  be moved upward in the tree */
      736 
      737 			     allocate pred_node in (select_area) set (and_ptr);
      738 						/* alloc. new and node */ /* Allocations in select_area are never freed.  This area
      739*						   is reinitialized at the beginning
      740*						   of each new selection expression. */
      741 			     and_ptr -> pred_node.type = NODE; /* and fill it in */
      742 			     and_ptr -> pred_node.id.op_code = AND_OP;
      743 			     and_ptr -> pred_node.root = "0"b;
      744 			     and_ptr -> pred_node.term = "0"b;
      745 			     string (and_ptr -> pred_node.id.lleaf_id) = "0"b;
      746 			     string (and_ptr -> pred_node.id.rleaf_id) = "0"b;
      747 			     and_ptr -> pred_node.parent = p_ptr;
      748 
      749 			     if c_ptr = p_ptr -> pred_node.lbr then do; /* if the | is a left branch */
      750 
      751 				     call copy_subtree (p_ptr -> pred_node.rbr, copy_ptr, and_ptr);
      752 						/* make a copy of right branch */
      753 				     call move_subtree (c_ptr -> pred_node.rbr, and_ptr -> pred_node.lbr, and_ptr);
      754 				     and_ptr -> pred_node.rbr = copy_ptr;
      755 				     call move_subtree (p_ptr -> pred_node.rbr, c_ptr -> pred_node.rbr, c_ptr);
      756 				     p_ptr -> pred_node.rbr = and_ptr;
      757 
      758 				end;		/* if the | was a left branch */
      759 
      760 			     else do;		/* if the | is a right branch */
      761 
      762 				     call copy_subtree (p_ptr -> pred_node.lbr, copy_ptr, and_ptr);
      763 						/* copy the left branch */
      764 				     call move_subtree (c_ptr -> pred_node.lbr, and_ptr -> pred_node.rbr, and_ptr);
      765 				     and_ptr -> pred_node.lbr = copy_ptr;
      766 				     call move_subtree (p_ptr -> pred_node.lbr, c_ptr -> pred_node.lbr, c_ptr);
      767 				     p_ptr -> pred_node.lbr = and_ptr;
      768 
      769 
      770 				end;		/*  if | is right branch */
      771 
      772 
      773 /* for either a right or left branch */
      774 
      775 			     if top + 1 > mrds_data_$max_pred_depth then /* if stack is overflowing */
      776 				call error (mrds_error_$node_stack_ovfl);
      777 
      778 /* In this case, we can guarantee that all nodes will be looked at by placing copy_ptr in stack */
      779 
      780 			     top = top + 1;
      781 			     node_stack (top) = copy_ptr;
      782 			     p_ptr -> pred_node.id.op_code = OR_OP; /* parent is now an | node */
      783 			     c_ptr -> pred_node.id.op_code = AND_OP; /* and the current is now an & node */
      784 
      785 			     c_ptr = p_ptr;		/* go up one level */
      786 			     p_ptr = p_ptr -> pred_node.parent;
      787 
      788 			     if c_ptr -> pred_node.root then done = "1"b; /* if no farther to go */
      789 			     else if p_ptr -> pred_node.id.op_code ^= AND_OP then done = "1"b; /* or we have hit ors */
      790 
      791 			end;			/* bubbling this or */
      792 
      793 		     end;				/* if or node */
      794 
      795 	end;					/* search for ors */
      796 
      797 /* Have now eliminated all not nodes from the tree, and have rearranged the tree so that no and nodes have
      798*   subordinate or nodes.  Hence, the tree has now degenerated into a set of "and groups", i.e. a set
      799*   of requirements lists which must be met for tuple to be selected.  Thus, in order to facilitate further
      800*   manipulation, we first discard the tree structure in favor of a list of and groups.  For each and group, we
      801*   then group all terms in like variables together */
      802 
      803 	if display_predicate_tree then
      804 	     call mdb_display_pred_tree$display_pred_tree_ (pred_ptr, /* ptr to root of tree */
      805 		"0"b,				/* ^brief mode */
      806 		"1"b,				/* long mode */
      807 		10,				/* maximum depth */
      808 		1,				/* => inorder */
      809 		dbcb_ptr);
      810 	or_top = 1;				/* init. or stack */
      811 	or_stack (or_top) = pred_ptr;
      812 
      813 	num_ands_init = mrds_data_$max_and_groups;
      814 	allocate pred_array in (select_area);
      815 						/* alloc. array for and groups */ /* Allocations in select_area are never freed.  This area
      816*						   is reinitialized at the beginning
      817*						   of each new selection expression. */
      818 	pred_array.type = ARRAY;			/* init. it */
      819 	pred_array.num_ands = 0;
      820 
      821 	do while (or_top > 0);			/* for every and group */
      822 
      823 	     pn_ptr = or_stack (or_top);		/* pick up top node from or_stack */
      824 	     or_top = or_top - 1;
      825 
      826 	     if pred_node.term then do;		/* and_group consists of single term */
      827 		     if pred_array.num_ands + 1 > num_ands_init then /* if we will exceed list size */
      828 			call error (mrds_error_$max_and_groups);
      829 		     pred_array.num_ands = pred_array.num_ands + 1;
      830 		     num_terms_init = 1;
      831 		     allocate and_group in (select_area);
      832 						/* alloc. and group of single or double term */
      833 						/* Allocations in select_area are never freed.  It
      834*						   is reinitialized at the beginning
      835*						   of each new selection expression. */
      836 		     and_group.num_terms = num_terms_init;
      837 		     and_group.term_ptr (1) = pn_ptr;	/* fill it in */
      838 		     pred_array.and_ptr (pred_array.num_ands) = ag_ptr; /* add it to  and group array */
      839 		end;				/* if node was a term */
      840 
      841 	     else if pred_node.id.op_code = OR_OP then do;/* if this is an or node */
      842 		     if or_top + 2 > mrds_data_$max_pred_depth then /* if we would overflow the stack */
      843 			call error (mrds_error_$node_stack_ovfl);
      844 		     or_stack (or_top + 1) = pred_node.rbr; /* just add the two branches to the stack */
      845 		     or_stack (or_top + 2) = pred_node.lbr;
      846 		     or_top = or_top + 2;
      847 		end;				/* if was or node */
      848 
      849 	     else do;				/* if node is an and node, => top of and group */
      850 
      851 		     num_terms_init = mrds_data_$max_and_terms;
      852 		     allocate and_group in (select_area);
      853 						/* alloc. max sized and group */ /* Allocations in select_area are never freed.  This area
      854*						   is reinitialized at the beginning
      855*						   of each new selection expression. */
      856 		     and_group.num_terms = 0;		/* init it */
      857 
      858 		     pred_array.num_ands = pred_array.num_ands + 1; /* and add it to group array */
      859 		     if pred_array.num_ands > num_ands_init then
      860 			call error (mrds_error_$max_and_groups);
      861 		     pred_array.and_ptr (pred_array.num_ands) = ag_ptr;
      862 
      863 		     and_top = 2;
      864 		     and_stack (1) = pred_node.rbr;	/* init. and stack */
      865 		     and_stack (2) = pred_node.lbr;
      866 
      867 		     do while (and_top > 0);		/* look through every node in the and group */
      868 
      869 			pn_ptr = and_stack (and_top); /* pick off top stack element */
      870 			and_top = and_top - 1;
      871 
      872 			if pred_node.term then do;	/* if this is a term */
      873 				if and_group.num_terms + 1 > num_terms_init then /* if we will overflow list */
      874 				     call error (mrds_error_$max_and_terms);
      875 				and_group.num_terms = and_group.num_terms + 1; /* increment number of terms */
      876 				and_group.term_ptr (and_group.num_terms) = pn_ptr; /* add this term to and group */
      877 			     end;			/* if this is term */
      878 
      879 			else do;			/* is another and node */
      880 
      881 				if and_top + 2 > mrds_data_$max_pred_depth then /* if we will overflow the and stack */
      882 				     call error (mrds_error_$node_stack_ovfl);
      883 				and_top = and_top + 2;
      884 				and_stack (and_top - 1) = pred_node.rbr; /* add branches to and stack */
      885 				and_stack (and_top) = pred_node.lbr;
      886 			     end;			/* if internsl and node */
      887 		     end;				/*  converting and group to list form */
      888 		end;				/* loop for and group */
      889 	end;					/* loop for tree */
      890      end canonize_pred;
      891 
      892 create_search_lists: proc;
      893 
      894 /* Procedure to create the "program" for mrds_dsl_search */
      895 
      896 	dcl     (i, j, k)		 fixed bin;
      897 
      898 	allocate path_var_flags in (select_area);
      899 
      900 	search_array.num_and_groups = pred_array.num_ands;
      901 
      902 	do i = 1 to pred_array.num_ands;		/* process each and group */
      903 
      904 	     var_count = 0;				/* so far there are no tuple variables in the search path */
      905 	     ag_ptr = pred_array.and_ptr (i);
      906 	     done = "0"b;
      907 
      908 /*           Call the permutatuions program. */
      909 
      910 
      911 	     call mrds_dsl_permute (dbcb_ptr, ag_ptr, search_array (i).path_ptr, search_array (i).cost, icode);
      912 	     if icode ^= 0 then call error (icode);
      913 
      914 	     pvp = search_array (i).path_ptr;
      915 	     unspec (path_var_flags) = "0"b;
      916 
      917 	     call count_path_len_and_set_flags (pvp, var_count, last_el_ptr, path_var_flags);
      918 
      919 	     min_path_first_el_ptr = pvp;
      920 						/* save pointer to fist element in mim cost partial path */
      921 	     min_path_last_el_ptr = last_el_ptr;	/* last element in path also */
      922 
      923 
      924 	     if display_search_paths then do;
      925 		     call ioa_ ("^/^/The minimum cost search path^/^/");
      926 		     call mdb_display_path_$path (min_path_first_el_ptr, dbcb_ptr);
      927 		     call ioa_ ("^/^/End minimum costr search path^/^/");
      928 		end;
      929 	     if dbcb.print_search_order then do;
      930 
      931 /* -print_search_order specified in selection expression,
      932*   output info for each and_group search path */
      933 
      934 		     if i = 1 then /* first and_group */
      935 			call ioa_ ("^/Tuple variables listed in search order");
      936 		     else call ioa_ ("^/***** New and group.");
      937 
      938 /* put the path variable pointers into an array, so they can be
      939*   printed out in reverse of the list linking for search order */
      940 
      941 		     x = 1;			/* CHANGE 81-09-19 */
      942 		     do temp_pvp = pvp repeat temp_pvp -> path_var.fwd_thd
      943 			while (temp_pvp ^= null ());
      944 
      945 			path_var_pointer_array (x) = temp_pvp;
      946 			x = x + 1;
      947 
      948 		     end;
      949 
      950 /* now print out the array using the reverse order
      951*   that is actually the search path order */
      952 
      953 		     x = x - 1;			/* last increment not needed */
      954 		     do z = x by -1 to 1;		/* CHANGE 81-09-19 */
      955 
      956 			temp_pvp = path_var_pointer_array (z);
      957 
      958 			if temp_pvp -> path_var.in_and_group | temp_pvp -> path_var.in_select_clause then do;
      959 
      960 /* only do tuple variables that hve an effect on the select set */
      961 
      962 				y = temp_pvp -> path_var.var_index;
      963 				temp_rmri_ptr = range.tup_var.ri_ptr (y);
      964 
      965 				if range.tup_var.temp_rel (y) then
      966 				     rel_name = ltrim (before (after (range.tup_var.ri_ptr (i) -> rm_rel_info.model_name, "."), "."), "0")
      967 					|| " (temp rel index)";
      968 				else rel_name = temp_rmri_ptr -> rm_rel_info.name;
      969 
      970 /* on a secure database, a non-DBA will only see indexed attr,
      971*   never any type of key access method */
      972 
      973 				saved_access_method = 0;
      974 				if rm_db_info.mdbm_secured & ^rm_db_info.administrator then do;
      975 					if temp_pvp -> path_var.access_method < INDEXED_ATTR then do;
      976 						saved_access_method =
      977 						     temp_pvp -> path_var.access_method; /* remember real access method */
      978 						temp_pvp -> path_var.access_method =
      979 						     INDEXED_ATTR; /* make the peon see index, rather than key */
      980 					     end;
      981 				     end;
      982 
      983 				call ioa_ ("^/Order: ^d  Tuple variable: ""^a""     Relation: ""^a""",
      984 				     x - z + 1, range.tup_var.name (y), rel_name);
      985 
      986 				call ioa_ ("^11xAccess method: ""^a""",
      987 				     access_method_name (temp_pvp -> path_var.access_method));
      988 
      989 /* addition detail depends on access method used,
      990*   they can't be show to a peon on a secure db,
      991*   because he can infer key info from them. */
      992 
      993 				if rm_db_info.administrator | ^rm_db_info.mdbm_secured then do;
      994 
      995 					call ioa_ ("^11xEstimate of tuples selected: ^d",
      996 					     temp_pvp -> path_var.number_tuples_selected);
      997 
      998 					if temp_pvp -> path_var.access_method = LONG_KEY_HEAD |
      999 					     temp_pvp -> path_var.access_method = TOTAL_PRIMARY_KEY then
     1000 
     1001 					     call ioa_ ("^11xNumber of key attributes involved: ^d",
     1002 						temp_pvp -> path_var.attr_index);
     1003 
     1004 					else if temp_pvp -> path_var.access_method = SHORT_KEY_HEAD |
     1005 					     temp_pvp -> path_var.access_method = INDEXED_ATTR then do;
     1006 
     1007 						attr_name = temp_rmri_ptr ->
     1008 						     rm_rel_info.attr_ptrs (temp_pvp -> path_var.attr_index) ->
     1009 						     rm_attr_info.name;
     1010 
     1011 						if temp_pvp -> path_var.second_cond_ptr = null () then
     1012 						     call ioa_ ("^15xCondition: ""^a""     Attribute: ""^a""",
     1013 							condition_name (temp_pvp -> path_var.cond_ptr -> cond.op_code), attr_name);
     1014 						else call ioa_ ("^14xConditions:  ""^a"" & ""^a""    Attribute:  ""^a""",
     1015 							condition_name (temp_pvp -> path_var.cond_ptr -> cond.op_code),
     1016 							condition_name (temp_pvp -> path_var.second_cond_ptr -> cond.op_code),
     1017 							attr_name);
     1018 					     end;
     1019 				     end;
     1020 
     1021 				if saved_access_method ^= 0 then
     1022 				     temp_pvp -> path_var.access_method =
     1023 					saved_access_method; /* put back real access method for peon */
     1024 			     end;
     1025 		     end;
     1026 		end;
     1027 	     call mrds_dsl_gen_srch_prog (dbcb_ptr, min_path_first_el_ptr, search_array.sv_ptr (i),
     1028 		search_array.so_ptr (i), icode);
     1029 	     if icode ^= 0 then call error (icode);
     1030 
     1031 	end;					/* creating search lists for each and group */
     1032 
     1033 	if dbcb.print_search_order then
     1034 	     call ioa_ ("^/");			/* addition line feed for formating */
     1035 	call check_no_tuple_effect ();
     1036 	if ^dbcb.no_optimize then do;
     1037 
     1038 /* sort the and groups to get lowest cost and group first,
     1039*   so that the first tuple in a series of "or"'s is found faster. */
     1040 
     1041 		sorted = "0"b;
     1042 		i = search_array.num_and_groups;
     1043 		spare_element = mrds_data_$max_and_groups + 1;
     1044 		do while (^sorted);			/* bubble sort */
     1045 
     1046 		     exchanged = "0"b;
     1047 
     1048 		     do j = 2 to i;			/* bubble highest cost element to position "i" */
     1049 
     1050 			if search_array.cost (j) < search_array.cost (j - 1) then do;
     1051 
     1052 				search_array.and_group (spare_element) = search_array.and_group (j);
     1053 				search_array.and_group (j) = search_array.and_group (j - 1);
     1054 				search_array.and_group (j - 1) = search_array.and_group (spare_element);
     1055 
     1056 				exchanged = "1"b;
     1057 			     end;
     1058 		     end;
     1059 
     1060 		     if ^exchanged then
     1061 			sorted = "1"b;
     1062 		     else if i > 2 then
     1063 			i = i - 1;
     1064 		     else sorted = "1"b;
     1065 		end;
     1066 	     end;
     1067 
     1068 
     1069 /* skip over and groups that have 0 cost, and thus can not
     1070*   possiblly return any tuples. (they got 0 cost from permute
     1071*   by one of the involved relations being empty)
     1072*   This will reduce the search program to just those non-null and groups.
     1073*   In the extreme, will no non-null and groups, the search program
     1074*   degenerates to just a simple reutnr_null action */
     1075 
     1076 	non_null_and_groups = 0;
     1077 	so_nops_init = 0;				/* combine all search op tables into onetable */
     1078 	do i = 1 to pred_array.num_ands;
     1079 	     if search_array.cost (i) ^= 0.0 then do;
     1080 		     so_nops_init = so_nops_init + search_array.so_ptr (i) -> search_ops.nops - 1;
     1081 		     non_null_and_groups = non_null_and_groups + 1;
     1082 		end;
     1083 	end;
     1084 	so_nops_init = so_nops_init + 1;		/* for RETNUL */
     1085 	allocate search_ops in (select_area);		/* Allocations in select_area are never freed.  This area
     1086*						   is reinitialized at the beginning
     1087*						   of each new selection expression. */
     1088 	search_ops.ic = 1;
     1089 	k = 0;
     1090 	do i = 1 to pred_array.num_ands;
     1091 	     if search_array.cost (i) ^= 0.0 then do;
     1092 		     begin_and_group = k;
     1093 		     do j = 1 to search_array.so_ptr (i) -> search_ops.nops - 1;
     1094 			k = k + 1;
     1095 			unspec (search_ops.op (k)) =
     1096 			     unspec (search_array.so_ptr (i) -> search_ops.op (j));
     1097 		     end;
     1098 		     search_ops.op.err_xfer (begin_and_group + 3) = k - begin_and_group - 2;
     1099 						/* special case first init and select in each and_group */
     1100 		     search_ops.op.err_xfer (begin_and_group + 4) = k - begin_and_group - 3;
     1101 		end;
     1102 	end;
     1103 	k = k + 1;
     1104 	unspec (search_ops.op (k)) = unspec (search_array.so_ptr (pred_array.num_ands) ->
     1105 	     search_ops.op (search_array.so_ptr (pred_array.num_ands) ->
     1106 	     search_ops.nops));			/* Pick up last RETNUL */
     1107 
     1108 	return;
     1109 
     1110 count_path_len_and_set_flags: proc (top_of_path, var_count, last_el_ptr, path_var_flags);
     1111 
     1112 /* This routine counts the number  of  tuple  variables  used  in  a
     1113*   section  of  the  minimum  cost path and sets a bit flag for each
     1114*   variable used. It also returns a pointer to the last  element  in
     1115*   the path.
     1116**/
     1117 
     1118 /* PARAMETERS */
     1119 
     1120 	dcl     top_of_path		 ptr;		/* (input) first element in path */
     1121 	dcl     last_el_ptr		 ptr;		/* (output) pointer to last element in path */
     1122 	dcl     var_count		 fixed bin;
     1123 						/* (input/output) total number of tuple variables
     1124*						   used in all path segments */
     1125 	dcl     path_var_flags	 (*) bit (1) unaligned;
     1126 						/* (input/output) true is tuple variable used in minimum path */
     1127 
     1128 /* AUTOMATIC */
     1129 
     1130 	dcl     path_var_ptr	 ptr;		/* pointer to an element in path_var list */
     1131 
     1132 	path_var_ptr = top_of_path;
     1133 
     1134 	do while (path_var_ptr ^= null ());		/* loop through path list */
     1135 	     var_count = var_count + 1;
     1136 	     path_var_flags (path_var_ptr -> path_var.var_index) = "1"b;
     1137 
     1138 	     last_el_ptr = path_var_ptr;		/* save incase this is the last element */
     1139 	     path_var_ptr = path_var_ptr -> path_var.fwd_thd;
     1140 	end;
     1141 
     1142 
     1143 	return;
     1144 
     1145      end /* count_path_len_and_set_flags */;
     1146 
     1147 
     1148 
     1149 
     1150 
     1151      end create_search_lists;
     1152 
     1153 check_no_tuple_effect: procedure ();
     1154 
     1155 /* this routine decides if the tuple variables given
     1156*   in the range clause are usefull in this selection expression.
     1157*   If a tuple variable appears in the select clause it is OK,
     1158*   because it either also appears in the where clause,
     1159*   or it will be used to form a cross product with the results
     1160*   of the where clause. If a tuple variable does not appear in the select clause
     1161*   it must appear in some and group in the where clause. */
     1162 
     1163 	message = "";
     1164 	do i = 1 to range.num_vars;
     1165 
     1166 	     if ^range.tup_var (i).used then do;
     1167 
     1168 /* this tuple variable does not appear in the select clause,
     1169*   see if it is some and group in the where clause */
     1170 
     1171 		     good_use_found = "0"b;
     1172 		     do j = 1 to search_array.num_and_groups while (^good_use_found);
     1173 
     1174 			do pvp = search_array.and_group (j).path_ptr
     1175 			     repeat path_var.fwd_thd
     1176 			     while (pvp ^= null () & ^good_use_found);
     1177 
     1178 			     if i = path_var.var_index & path_var.in_and_group then
     1179 
     1180 /* we found an instance of the use of this tuple variable in an and group */
     1181 
     1182 				good_use_found = "1"b;
     1183 
     1184 			end;
     1185 
     1186 		     end;
     1187 
     1188 /* see if the tuple variable was used properly
     1189*   add it to the error list if not */
     1190 
     1191 		     if ^good_use_found then do;
     1192 
     1193 			     if message = "" then
     1194 				message = "Useless tuple variables are: ";
     1195 
     1196 			     message = message || rtrim (range.tup_var (i).name) || " ";
     1197 
     1198 			end;
     1199 
     1200 		end;
     1201 
     1202 	end;
     1203 
     1204 /* see if any bad T.V.'s were found */
     1205 
     1206 	if message ^= "" then do;
     1207 
     1208 		call sub_err_ (mrds_error_$no_tuple_effect, "mrds_dsl_optimize", "c", null (), return_value, message);
     1209 		call error (mrds_error_$no_tuple_effect);
     1210 
     1211 	     end;
     1212 
     1213 
     1214 
     1215 
     1216 	dcl     (i, j)		 fixed bin;	/* loop indexes */
     1217 	dcl     good_use_found	 bit (1);		/* on => this T.V. OK */
     1218 	dcl     message		 char (100) varying;/* error message being built */
     1219 	dcl     sub_err_		 entry options (variable);
     1220 	dcl     return_value	 fixed bin (35) init (0); /* dummy arg */
     1221 
     1222      end;
     1223 
     1224 move_subtree: proc (s_ptr, t_ptr, p_ptr);
     1225 
     1226 /* procedure to relocate a subtree */
     1227 
     1228 	dcl     (s_ptr,				/* pointer to source location */
     1229 	        t_ptr,				/* pointer to target location */
     1230 	        p_ptr)		 ptr;		/* new parent pointer */
     1231 
     1232 	t_ptr = s_ptr;
     1233 	if s_ptr -> pred_node.type = NODE then
     1234 	     s_ptr -> pred_node.parent = p_ptr;
     1235 	else s_ptr -> pred_leaf.parent = p_ptr;
     1236 
     1237      end move_subtree;
     1238 
     1239 copy_subtree: proc (s_ptr, c_ptr, p_ptr);
     1240 
     1241 /* Internal procedure to copy a portion of the pred tree */
     1242 
     1243 	dcl     (s_ptr,				/* ptr to source subtree */
     1244 	        c_ptr,				/* ptr to copy subtree */
     1245 	        sr_ptr,				/* ptr to current source node */
     1246 	        cp_ptr,				/* ptr to current copy node */
     1247 	        p_ptr,				/* ptr to parent of copy */
     1248 	        p_hold)		 ptr;		/* temp parent pointer holder */
     1249 
     1250 	dcl     1 node_stack	 (mrds_data_$max_pred_depth), /* copy node stack */
     1251 		2 s_ptr		 ptr,		/* source node */
     1252 		2 c_ptr		 ptr;		/* copy node */
     1253 
     1254 	dcl     top		 fixed bin;	/* index to node stack */
     1255 
     1256 	top = 1;					/* initialize */
     1257 	allocate pred_node in (select_area) set (c_ptr);	/* Allocations in select_area are never freed.  This area
     1258*						   is reinitialized at the beginning
     1259*						   of each new selection expression. */
     1260 	c_ptr -> pred_node.parent = p_ptr;		/* preset parent */
     1261 	node_stack.s_ptr (top) = s_ptr;
     1262 	node_stack.c_ptr (top) = c_ptr;
     1263 
     1264 	do while (top > 0);				/* while there are nodes to copy */
     1265 
     1266 	     sr_ptr = node_stack.s_ptr (top);		/* pick off node to be copied */
     1267 	     cp_ptr = node_stack.c_ptr (top);
     1268 	     top = top - 1;
     1269 
     1270 	     if sr_ptr -> pred_node.type = NODE then do;	/* if copying a node */
     1271 		     p_hold = cp_ptr -> pred_node.parent; /* save parent ptr which has been set */
     1272 		     cp_ptr -> pred_node = sr_ptr -> pred_node; /* copy the node */
     1273 		     cp_ptr -> pred_node.parent = p_hold; /* reinsert parent pointer */
     1274 
     1275 		     if cp_ptr -> pred_node.term then do; /* if this is a term */
     1276 			     allocate pred_leaf in (select_area) set (cp_ptr -> pred_node.lbr);
     1277 						/* alloc. left leaf */ /* Allocations in select_area are never freed.  This area
     1278*						   is reinitialized at the beginning
     1279*						   of each new selection expression. */
     1280 			     cp_ptr -> pred_node.lbr -> pred_leaf.parent = cp_ptr; /* set parent */
     1281 			     allocate pred_leaf in (select_area) set (cp_ptr -> pred_node.rbr);
     1282 						/* same for right lf */ /* Allocations in select_area are never freed.  This area
     1283*						   is reinitialized at the beginning
     1284*						   of each new selection expression. */
     1285 			     cp_ptr -> pred_node.rbr -> pred_leaf.parent = cp_ptr;
     1286 			end;			/* if was term */
     1287 
     1288 		     else do;			/* if children are nodes */
     1289 
     1290 			     allocate pred_node in (select_area) set (cp_ptr -> pred_node.lbr);
     1291 						/* alloc. left node */ /* Allocations in select_area are never freed.  This area
     1292*						   is reinitialized at the beginning
     1293*						   of each new selection expression. */
     1294 			     cp_ptr -> pred_node.lbr -> pred_node.parent = cp_ptr; /* set parent */
     1295 			     allocate pred_node in (select_area) set (cp_ptr -> pred_node.rbr);
     1296 						/* same for right */ /* Allocations in select_area are never freed.  This area
     1297*						   is reinitialized at the beginning
     1298*						   of each new selection expression. */
     1299 			     cp_ptr -> pred_node.rbr -> pred_node.parent = cp_ptr;
     1300 
     1301 			end;			/* if children are nodes */
     1302 
     1303 		     top = top + 2;
     1304 		     if top > mrds_data_$max_pred_depth then /* if we will overflow the stack */
     1305 			call error (mrds_error_$node_stack_ovfl);
     1306 		     node_stack.s_ptr (top - 1) = sr_ptr -> pred_node.rbr; /* add branches to stack */
     1307 		     node_stack.c_ptr (top - 1) = cp_ptr -> pred_node.rbr;
     1308 		     node_stack.s_ptr (top) = sr_ptr -> pred_node.lbr;
     1309 		     node_stack.c_ptr (top) = cp_ptr -> pred_node.lbr;
     1310 
     1311 		end;				/* if we had a node */
     1312 
     1313 	     else do;				/* we have a leaf */
     1314 
     1315 		     p_hold = cp_ptr -> pred_leaf.parent; /* save parent pointer */
     1316 		     cp_ptr -> pred_leaf = sr_ptr -> pred_leaf; /* copy the leaf */
     1317 		     if cp_ptr -> pred_leaf.expr_ptr ^= null then /* if expr leaf */
     1318 			call copy_expr (cp_ptr -> pred_leaf.expr_ptr); /* then must copy expr tables */
     1319 		     cp_ptr -> pred_leaf.parent = p_hold; /* sestore parent pointer */
     1320 
     1321 		end;				/* if leaf */
     1322 
     1323 	end;					/* copy loop */
     1324 
     1325      end copy_subtree;
     1326 
     1327 copy_expr: proc (e_ptr);
     1328 
     1329 /* Procedure to copy and expr and modify e_ptr to point to the new tables */
     1330 
     1331 	dcl     e_ptr		 ptr;
     1332 	dcl     i			 fixed bin;
     1333 
     1334 	nexp_items_init = e_ptr -> expr.nitems;		/* copy expr struct. */
     1335 	allocate expr in (select_area);		/* Allocations in select_area are never freed.  This area
     1336*						   is reinitialized at the beginning
     1337*						   of each new selection expression. */
     1338 	expr = e_ptr -> expr;
     1339 	e_ptr = expr_ptr;
     1340 
     1341 	do i = 1 to e_ptr -> expr.nitems;		/* copy all contained functions */
     1342 	     if e_ptr -> expr.item.type (i) = SCAL_FUN then
     1343 		call copy_fun (e_ptr -> expr.item.fn_ptr (i));
     1344 	end;
     1345 
     1346      end copy_expr;
     1347 
     1348 copy_fun: proc (f_ptr);
     1349 
     1350 /* Procedure to copy a function */
     1351 
     1352 	dcl     f_ptr		 ptr;
     1353 	dcl     i			 fixed bin;
     1354 
     1355 	nsf_args_init = f_ptr -> scalfn.nargs;		/* copy scafn struct. */
     1356 	allocate scalfn in (select_area);		/* Allocations in select_area are never freed.  This area
     1357*						   is reinitialized at the beginning
     1358*						   of each new selection expression. */
     1359 	scalfn = f_ptr -> scalfn;
     1360 	f_ptr = sfn_ptr;
     1361 
     1362 	do i = 1 to f_ptr -> scalfn.nargs;
     1363 	     if f_ptr -> scalfn.arg.type (i) = EXPR then
     1364 		call copy_expr (f_ptr -> scalfn.arg.ef_ptr (i));
     1365 	     else if f_ptr -> scalfn.arg.type (i) = SCAL_FUN then
     1366 		call copy_fun (f_ptr -> scalfn.arg.ef_ptr (i));
     1367 	end;
     1368 
     1369      end copy_fun;
     1370  build_vectors: proc;
     1371 
     1372 /* Here is where we build the 'shortened' simple_typed_vector for each tuple variable.
     1373*   If the whole tuple has been selected, the 'whole' one in the resultant is used. */
     1374 
     1375 	do i = 1 to range.num_vars;
     1376 	     bv_stv_ptr = tuple_info.tuple (i).tuple_ptr; /* simple_typed_veector for whole 'view' */
     1377 	     bv_ri_ptr = range.tup_var (i).ri_ptr;	/* rm_rel_info ptr */
     1378 	     bv_idl_ptr = bv_ri_ptr -> rm_rel_info.id_list_ptr; /* id_list for whole 'view' */
     1379 	     if range.tup_var (i).whole_tuple_selected
     1380 	     then do;				/* just grab what's already available */
     1381 		     range.tup_var (i).stv_ptr = bv_stv_ptr;
     1382 		     range.tup_var (i).idl_ptr = bv_idl_ptr;
     1383 		end;
     1384 	     else do;				/* Build a simple_typed_vector and an id_list */
     1385 		     il_number_of_ids = bv_ri_ptr -> rm_rel_info.num_attr; /* Build it oversize */
     1386 		     allocate id_list in (select_area) set (id_list_ptr);
     1387 		     id_list.version = ID_LIST_VERSION_1;
     1388 		     range.tup_var (i).idl_ptr = id_list_ptr;
     1389 
     1390 		     id_list.number_of_ids = 0;
     1391 		     do k = 1 to il_number_of_ids;
     1392 			if range.tup_var (i).needed_bits.attr (k)
     1393 			then do;			/* get the proper id for relation */
     1394 				id_list.number_of_ids = id_list.number_of_ids + 1;
     1395 				id_list.id (id_list.number_of_ids) = bv_idl_ptr -> id_list.id (k);
     1396 			     end;
     1397 		     end;
     1398 		     if id_list.number_of_ids ^= 0
     1399 		     then do;
     1400 			     stv_number_of_dimensions = id_list.number_of_ids;
     1401 			     allocate simple_typed_vector in (select_area) set (simple_typed_vector_ptr);
     1402 			     simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
     1403 			     range.tup_var (i).stv_ptr = simple_typed_vector_ptr;
     1404 
     1405 			     stv_number_of_dimensions = 0; /* use for walking through the vector */
     1406 			     do k = 1 to il_number_of_ids; /* walk the WHOLE relation */
     1407 				if range.tup_var (i).needed_bits.attr (k)
     1408 				then do;
     1409 					stv_number_of_dimensions = stv_number_of_dimensions + 1;
     1410 					simple_typed_vector.dimension (stv_number_of_dimensions).value_ptr =
     1411 					     bv_stv_ptr -> simple_typed_vector.dimension (k).value_ptr;
     1412 				     end;
     1413 			     end;
     1414 			end;			/* ids to move */
     1415 		     else do;			/* no ids to move */
     1416 			     range.tup_var (i).stv_ptr = null ();
     1417 			end;
     1418 		end;				/* build simple_typec_vector */
     1419 	end;					/* walk through tuple vars */
     1420 
     1421 
     1422 	dcl     bv_idl_ptr		 ptr;
     1423 	dcl     bv_stv_ptr		 ptr;
     1424 	dcl     bv_ri_ptr		 ptr;
     1425 	dcl     i			 fixed bin;
     1426 	dcl     k			 fixed bin;
     1427 
     1428      end build_vectors;
     1429 
     1430 error: proc (cd);
     1431 
     1432 /* Internal error procedure */
     1433 
     1434 	dcl     cd		 fixed bin (35);	/* statuc code */
     1435 
     1436 	code = cd;
     1437 	go to exit;
     1438 
     1439      end error;
     1440 
     1441 	dcl     code		 fixed bin (35);	/* Output -- return code */
     1442 	dcl     icode		 fixed bin (35);	/* internal status code */
     1443 
     1444 	dcl     (top,				/* index to top of node stack */
     1445 	        or_top,				/* index to top of or node stack */
     1446 	        and_top,				/* index to top of and node stack */
     1447 	        sa_nvars,				/* no. of vars for size_array. */
     1448 	        nxchng,				/* no. of exchanges for bubble sort */
     1449 	        begin_and_group)	 fixed bin;	/* index just before the beginning of the
     1450*						   current and_group in the combined search ops list. */
     1451 
     1452 
     1453 	dcl     (c_ptr,				/* pointer to child node */
     1454 	        notl_ptr,				/* ptr to temp not node */
     1455 	        notr_ptr,				/* ptr to temp not node */
     1456 	        p_ptr,				/* pointer to parent node */
     1457 	        and_ptr,				/* ptr to new and node */
     1458 	        copy_ptr,				/* ptr to top of copied subtree */
     1459 	        sa_ptr,				/* to size_array */
     1460 	        sap)		 ptr;
     1461 
     1462 	dcl     (done,				/* internal flag */
     1463 	        display_predicate_tree,
     1464 	        display_search_paths,
     1465 	        sa_alloc)		 bit (1) unal;	/* internal flag */
     1466 
     1467 	dcl     node_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of tree nodes */
     1468 	dcl     or_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of or nodes */
     1469 	dcl     and_stack		 (mrds_data_$max_pred_depth) ptr; /* stack of and nodes */
     1470 	dcl     1 size_array	 (sa_nvars) based (sa_ptr),
     1471 		2 var_index	 fixed bin,
     1472 		2 size		 fixed bin (35);
     1473 	dcl     wkspc1		 (4) fixed bin (71);
     1474 	dcl     1 search_array	 aligned,		/* to hold search info from each and group */
     1475 		2 num_and_groups	 fixed bin,	/* number of and groups used */
     1476 		2 and_group	 (mrds_data_$max_and_groups + 1),
     1477 		  3 cost		 float bin (63),	/* cost of this and group */
     1478 		  3 path_ptr	 ptr,		/* to low cost path for this and group */
     1479 		  3 sv_ptr	 ptr,		/* to search_vars for and group */
     1480 		  3 so_ptr	 ptr;		/* to search_ops for and group */
     1481 
     1482 	dcl     sorted		 bit (1);		/* on => search array has been sorted by cost */
     1483 	dcl     exchanged		 bit (1);		/* on => no more bubbling needed, since none done last pass */
     1484 	dcl     spare_element	 fixed bin;	/* address of last unused element in array */
     1485 	dcl     neg_op		 (10) bit (6) int static options (constant) init (/* table of negating operators */
     1486 				 "0"b, "0"b, "0"b, "0"b, /* first four are not applic. */
     1487 				 "000110"b,	/* EQ -> NE */
     1488 				 "000101"b,	/* NE -> EQ */
     1489 				 "001010"b,	/* LT -> GE */
     1490 				 "001001"b,	/* GT -> LE */
     1491 				 "001000"b,	/* LE -> GT */
     1492 				 "000111"b);	/* GE -> LT */
     1493 
     1494 	dcl     (mrds_error_$node_stack_ovfl,
     1495 	        mrds_error_$no_tuple_effect,
     1496 	        mrds_error_$max_and_groups,
     1497 	        mrds_error_$max_and_terms,
     1498 	        mrds_data_$max_attributes,
     1499 	        mrds_data_$max_id_len,
     1500 	        mrds_data_$max_pred_depth,
     1501 	        mrds_data_$max_and_groups,
     1502 	        mrds_data_$max_and_terms,
     1503 	        mrds_data_$max_safe_tids_returned_per_call,
     1504 	        mrds_data_$max_tids_returned_per_call,
     1505 	        mrds_data_$max_tup_var) fixed bin (35) ext;
     1506 
     1507 	dcl     var_count		 fixed bin;	/* number of tuple variables used in search path */
     1508 	dcl     min_path_first_el_ptr	 ptr;		/* pointrer to first element in minimum cost search path */
     1509 	dcl     min_path_last_el_ptr	 ptr;		/* ditto last element */
     1510 	dcl     last_el_ptr		 ptr;		/* pointer to last element in minimum cost parstial path */
     1511 	dcl     path_var_flags	 (range.num_vars) bit (1) based (pvf_ptr); /* if tuple variable has been used in search path */
     1512 	dcl     pvf_ptr		 ptr;		/* pointer to the path_var_flags */
     1513 						/* corresponding bit is true */
     1514 	dcl     ioa_		 entry options (variable);
     1515 
     1516 	dcl     (addr,
     1517                   addrel,
     1518 	        after,
     1519 	        before,
     1520 	        fixed,
     1521 	        ltrim,
     1522 	        null,
     1523 	        rel,
     1524 	        rtrim,
     1525 	        string,
     1526 	        substr,
     1527 	        unspec)		 builtin;
     1528 
     1529 	dcl     mdb_display_path_$path entry (ptr, ptr);
     1530 	dcl     mdb_display_pred_tree$display_pred_tree_ entry (ptr, bit (1), bit (1), fixed bin, fixed bin, ptr);
     1531 	dcl     mrds_dsl_gen_srch_prog entry (ptr, ptr, ptr, ptr, fixed bin (35));
     1532 	dcl     mrds_dsl_permute	 entry (ptr, ptr, ptr, float bin (63), fixed bin (35));
     1533 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr,
     1534 				 ptr, ptr, fixed bin (35));
     1535 	dcl     info_ptr		 ptr init (null ());/* dummy arg */
     1536 	dcl     return_value	 fixed bin (35) init (0); /* dummy arg */
     1537 	dcl     mrds_error_$tuple_not_found fixed bin (35) ext; /* no data to be found */
     1538 	dcl     temp_pvp		 ptr;		/* temp for displaying path_var structure info */
     1539 	dcl     temp_rmri_ptr	 ptr;		/* temp for rm_rel_info pointer for pso display */
     1540 	dcl     (x, y, z)		 fixed bin;	/* array/loop indexes */
     1541 	dcl     path_var_pointer_array (mrds_data_$max_tup_var) ptr; /* array of pointers to path_var structures for pso display */
     1542 	dcl     condition_name	 (1:6) char (2) init ("=", "^=", "<", "<=", ">", ">=")
     1543 				 int static options (constant); /* char versions of comparison ops */
     1544 	dcl     access_method_name	 (1:6) char (32) int static options (constant) init
     1545 				 ("Primary key equality",
     1546 				 "Key head equality",
     1547 				 "Key or key head range",
     1548 				 "Indexed attribute",
     1549 				 "Sequential",
     1550 				 "Sequential");
     1551 	dcl     (rel_name, attr_name)	 char (32);	/* temps for display for -pso */
     1552 	dcl     saved_access_method	 fixed bin;	/* for changing peons displayed access method */
     1553 	dcl     non_null_and_groups	 fixed bin;	/* and groups without a 0 size rel */
     1554 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
     1555 	dcl     current_max_tids_per_call fixed bin (35);
     1556 	dcl     1 current_scope_flags	aligned based (current_scope_ptr) like scope_flags;
     1557           dcl     current_scope_ptr      ptr;
     1558 
  1     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
  1     2 
  1     3 /* WARNING
  1     4*          If the scope_info or scope_flags structure is changed then the
  1     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
  1     6*          all existing saved resultants
  1     7**/
  1     8 
  1     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
  1    10 
  1    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
  1    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
  1    13*   qualifiers for permit/prevent modes and to put pads in standard format */
  1    14 
  1    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
  1    16 
  1    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
  1    18*   could make use of it for compatibility. */
  1    19 
  1    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
  1    21*   the fact that null scope has been set can be displayed */
  1    22 
  1    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
  1    24*   prevent flags from any pointer which directly pointed to scope_flags itself
  1    25*   (i.e rm_rel_info.scope_flags_ptr). */
  1    26 
  1    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
  1    28*   and is used to maintain the scope mechanism for file access.
  1    29*   It contains the scope permit/prevent operations that this user
  1    30*   has set in his view for this opening instance. */
  1    31 
  1    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
  1    33     2 mbz1 bit (144),				/* Reserved for future use */
  1    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
  1    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
  1    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
  1    37       3 name char (30) aligned,			/* filename */
  1    38       3 sm_name char (32),				/* name of file(rel) in submodel */
  1    39       3 flags like scope_flags ;
  1    40 
  1    41 
  1    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
  1    43         2 permits,					/* modes to permit this user */
  1    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
  1    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
  1    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
  1    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
  1    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
  1    49         2 prevents,					/* modes to be denyed to other users */
  1    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
  1    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
  1    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
  1    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
  1    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
  1    55         2 touched bit (1) unal,			/* on => scope set for this relation */
  1    56         2 mbz4 bit (7) unal ;				/* for future flags */
  1    57 
  1    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
  1    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
  1    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
  1    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
  1    62 
  1    63 /* END mdbm_scope_info.incl.pl1 */
     1559 
     1560 
  2     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*          The element_id_list structure contains an array of element 
  2     5*     identifiers.  These identifiers are used as tuple, record or 
  2     6*     element identifiers.  This structure is used across the relation_manager_,
  2     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  2     8*     version should be changed to be char(8)aligned, when such a conversion
  2     9*     can be coordinated with the other structures used at these interfaces.
  2    10**/
  2    11 
  2    12 /* HISTORY:
  2    13*Written by Matthew Pierret, 06/06/82.
  2    14*Modified:
  2    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  2    16*            Did not change version.
  2    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_elements fixed bin (35),
  2    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  2    25 
  2    26      dcl	   element_id_list_ptr    ptr;
  2    27      dcl	   eil_number_of_elements fixed bin (35);
  2    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  2    29 			      init (1) fixed bin (35);
  2    30 
  2    31 
  2    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
     1561 
     1562 
  3     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 05/27/83.
  3     5*Modified:
  3     6**/
  3     7 
  3     8      dcl	   (
  3     9 	   ALL_RANGE_TYPE	      init (1),
  3    10 	   LOW_RANGE_TYPE	      init (2),
  3    11 	   HIGH_RANGE_TYPE	      init (3)
  3    12 	   )		      fixed bin internal static options (constant);
  3    13 
  3    14 
  3    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
     1563 
     1564 
  4     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
  4     2 
  4     3 /* HISTORY:
  4     4*Written by Matthew Pierret, 05/10/83.
  4     5*Modified:
  4     6**/
  4     7 
  4     8 /* format: style2,ind3 */
  4     9      dcl	   1 relation_search_specification
  4    10 			      aligned based (relation_search_specification_ptr),
  4    11 	     2 head	      like specification_head,
  4    12 	     2 maximum_number_of_constraints
  4    13 			      fixed bin (17) unal,
  4    14 	     2 number_of_and_groups
  4    15 			      fixed bin (17) unal,
  4    16 	     2 flags	      unal,
  4    17 	       3 return_unique_tuples
  4    18 			      bit (1) unal,
  4    19 	       3 mbz	      bit (35) unal,
  4    20 	     2 range,
  4    21 	       3 type	      fixed bin (17),
  4    22 	       3 size	      fixed bin (17),
  4    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
  4    24 	       3 search_collection_id
  4    25 			      bit (36) aligned,
  4    26 	       3 flags	      unal,
  4    27 	         4 collection_id_supplied
  4    28 			      bit (1) unal,
  4    29 	         4 mbz	      bit (17) unal,
  4    30 	       3 number_of_constraints
  4    31 			      fixed bin (17) unal,
  4    32 	       3 constraint	      (rss_maximum_number_of_constraints
  4    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
  4    34 	         4 field_id	      fixed bin (17) unal,
  4    35 	         4 operator_code  fixed bin (17) unal,
  4    36 	         4 value_field_id fixed bin (17) unal,
  4    37 	         4 mbz	      bit (18) unal,
  4    38 	         4 value_ptr      ptr;
  4    39 
  4    40 
  4    41      dcl	   1 relation_numeric_specification
  4    42 			      aligned based (relation_numeric_specification_ptr),
  4    43 	     2 head	      like specification_head,
  4    44 	     2 collection_id      bit (36) aligned,
  4    45 	     2 range_size	      fixed bin (35),
  4    46 	     2 position_number    fixed bin (17) unal,
  4    47 	     2 pad	      bit (18) unal;
  4    48 
  4    49 
  4    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
  4    51 			      ptr init (null);
  4    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
  4    53 			      fixed bin (17) init (0);
  4    54 
  4    55 
  4    56 
  4    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
     1565 
     1566 
  5     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  5     5*Modified:
  5     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  5     7**/
  5     8 
  5     9 /* format: style2,ind3 */
  5    10      dcl	   1 specification_head   based (specification_head_ptr),
  5    11 	     2 version	      fixed bin (35),
  5    12 	     2 type	      fixed bin (17) unal,
  5    13 	     2 pad	      bit (18) unal,
  5    14 	     2 subset_specification_ptr
  5    15 			      ptr;
  5    16 
  5    17 
  5    18      dcl	   specification_head_ptr ptr;
  5    19      dcl	   SPECIFICATION_VERSION_4
  5    20 			      init (4) fixed bin (35) internal static options (constant);
  5    21 
  5    22      dcl	   (
  5    23 	   SEARCH_SPECIFICATION_TYPE
  5    24 			      init (1),
  5    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  5    26 			      init (1),
  5    27 	   NUMERIC_SPECIFICATION_TYPE
  5    28 			      init (2),
  5    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  5    30 			      init (2),
  5    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  5    32 			      init (3),
  5    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  5    34 			      init (4),
  5    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  5    36 			      init (5),
  5    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  5    38 			      init (6),
  5    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  5    40 			      init (7),
  5    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  5    42 			      init (8)
  5    43 	   )		      fixed bin (17) internal static options (constant);
  5    44 
  5    45 
  5    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
     1567 
     1568 
  6     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  6     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  6     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  6     9*     Nguyen. The scopes_changed flag was added to make checking for this
  6    10*     more efficient (mrds error list #137).
  6    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  6    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  6    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  6    14*     care if multiple txns use the same selection_expression. (mrds #156)
  6    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  6    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  6    18*                                                   END HISTORY COMMENTS */
  6    19 
  6    20 
  6    21 /* WARNING
  6    22*          If the dbcb structure is changed then the mrds_data_
  6    23*          item saved_res_version MUST be incremented to invalidate all
  6    24*          existing saved resultants
  6    25**/
  6    26 
  6    27 /* HISTORY :
  6    28*
  6    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  6    30*   tid_list management
  6    31*
  6    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  6    33*   phony resultant in mu_database_index, without having the area dcl
  6    34*   included.
  6    35*
  6    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  6    37*   mrds_dsl_store
  6    38*
  6    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  6    40*   switches
  6    41*
  6    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  6    43*   expression,  so  that relation statistics can be updated relative
  6    44*   to number of selection expressions seem. Also  removed  init  for
  6    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  6    46*   mrds_dsl_init_res.
  6    47*
  6    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  6    49*
  6    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  6    51*   for the conversion to the relation manager.
  6    52*
  6    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  6    54*   substructures so that the entries and costs can change
  6    55*   depending on the type of database that is opened.
  6    56*
  6    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  6    58*   since modify uses a different vector type (general) than does store.
  6    59*
  6    60*   82-09-20 Davids: changed names of (store modify)_vector to
  6    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  6    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  6    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  6    64*   during the first call.
  6    65*
  6    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  6    67*   since it deals with the pointers to the cursors and not the cursors
  6    68*   themelves and added the element cursor_storage_area_ptr which points
  6    69*   to the area where the cursors are kept.
  6    70*
  6    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  6    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  6    73*   anything.
  6    74*
  6    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  6    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  6    77*   by mrds_dsl_define_temp_rel.
  6    78*
  6    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  6    80*   is needed by mu_store.
  6    81*
  6    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  6    83*   bin to float bin since the values are not integers.
  6    84*
  6    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  6    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  6    87*   added to the end of the structure to allow modules that don't use
  6    88*   the element to continue to reference the dbcb structure without recompiling.
  6    89*
  6    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  6    91*   are needed so that temp rels can be created with the same file attributes
  6    92*   as the permanent relations.
  6    93*
  6    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  6    95*   added the resultant_in_pdir bit.
  6    96*
  6    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  6    98*   added the res_already_made element.
  6    99*
  6   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  6   101*
  6   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  6   103*   one of the unused pointers.
  6   104*
  6   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  6   106*
  6   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  6   108*   leaving unused_ptrs(1).
  6   109*
  6   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  6   111*   unused_ptrs (1).
  6   112*
  6   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  6   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  6   115*   spare ptrs, entries and reserved storages for future enhancement, since
  6   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  6   117*
  6   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  6   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  6   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  6   121**/
  6   122 
  6   123 
  6   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  6   125*   that constitutes the non-secure portion of the resultant model that is
  6   126*   created during the opening of a database. it contains variables that
  6   127*   are used during the runtime access of the database, and an area
  6   128*   for evaluation of requests. it points to four other
  6   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  6   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  6   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  6   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  6   133*   used in the elimination of duplicate tuples during a retrieve.
  6   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  6   135*   that is used when the database is using the file scope mechanism
  6   136*   for concurrency control over file readying. the segment overlayed via
  6   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  6   138*   across database openings. the pointer to this dbcb structure is kept in a table
  6   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  6   140*   opening instances of resultant models. (see mu_database_index routine) */
  6   141 
  6   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  6   143 	     2 data	      like dbcb_data,
  6   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  6   145 
  6   146      dcl	   dbcb_ptr	      ptr;
  6   147 
  6   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  6   149*						   like references can avoid getting the area declaration */
  6   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  6   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  6   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  6   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  6   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  6   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  6   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  6   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  6   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  6   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  6   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  6   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  6   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  6   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  6   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  6   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  6   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  6   167*						   for eliminating duplicate tuples. */
  6   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  6   169*						   for eliminating duplicate tuples. */
  6   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  6   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  6   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  6   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  6   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  6   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  6   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  6   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  6   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  6   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  6   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  6   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  6   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  6   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  6   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  6   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  6   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  6   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  6   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  6   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  6   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  6   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  6   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  6   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  6   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  6   195 	     2 val_del	      bit (1) unal,		/* for delete */
  6   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  6   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  6   198*                                                                     not imply that the database is of type page_file */
  6   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  6   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  6   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  6   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  6   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  6   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  6   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  6   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  6   207*						   inside a sequence of -another selection expression. */
  6   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  6   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  6   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  6   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  6   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  6   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  6   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  6   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  6   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  6   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  6   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  6   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  6   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  6   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  6   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  6   223 	     2 relmgr_entries,			/* relation manager entries */
  6   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  6   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  6   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  6   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  6   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  6   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  6   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  6   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  6   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  6   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  6   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  6   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  6   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  6   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  6   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  6   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  6   241 	       3 reserved_entries (5) entry (),
  6   242 	     2 access_costs,			/* access costs for permute */
  6   243 	       3 total_primary_key_cost float bin,
  6   244 	       3 access_cost      float bin,
  6   245 	       3 access_overhead  float bin,
  6   246 	       3 us_access_cost   float bin,
  6   247 	       3 os_access_cost   float bin,
  6   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  6   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  6   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  6   251 
  6   252 /* END mrds_dbcb.incl.pl1 */
  6   253 
  6   254 
     1569 
     1570 
  7     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  7     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  7     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 /* WARNING
  7    13*          If the rm_db_info structure is changed then the mrds_data_
  7    14*          item saved_res_version MUST be incremented to invalidate all
  7    15*          existing saved resultants
  7    16**/
  7    17 
  7    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  7    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  7    20*   resultant model that is created partially at database open  time,
  7    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  7    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  7    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  7    24*   to  provide  an  efficient  means  of  accessing  database  model
  7    25*   information, as seen from the possibly submodel view of the user,
  7    26*   and his current state of "files readied". it is the  secure  part
  7    27*   because  it  contains  the  model  information  which needs to be
  7    28*   protected  from  general  knowledge,  and   this   segment   will
  7    29*   eventually  be  capable  of  being in a lower ring. the structure
  7    30*   itself points to four arrays that are  allocated  in  it's  area,
  7    31*   that  in  turn point to the other structures mentions above, also
  7    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  7    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  7    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  7    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  7    36*   list of all known file names, the rm_rel_array only gets relation
  7    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  7    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  7    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  7    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  7    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  7    42*   file infos point to contained rel infos, the rel infos  point  to
  7    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  7    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  7    45*   foreign     keys    are    represented    by    the    structures
  7    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  7    47*   pathnames  of the model and submodel, if any, are also maintained
  7    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  7    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  7    50*   individual include files for  further  organization  information,
  7    51*   and particular data structures.
  7    52*
  7    53*   HISTORY:
  7    54*
  7    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  7    56*   so that define_area_ could be used to make it an extensible area
  7    57*
  7    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  7    59*   resultant in mu_database_index easier to keep, since no reference
  7    60*   to the area is needed.
  7    61*
  7    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  7    63*   resultant.
  7    64*
  7    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  7    66*   structure.
  7    67*
  7    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  7    69*   are  now  combined  into  the rel_array. Removed the control file
  7    70*   info which was unused. Added pointer  to  head  of  domain  list,
  7    71*   which is to be used to insure only one copy of each domain info.
  7    72*
  7    73*   83-05-19 Davids: Added the  saved_res_version element.
  7    74*
  7    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  7    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  7    77*   check, encode, or decode proc.
  7    78*
  7    79*   CAUTION: The structure entries from db_version to sm_path  should
  7    80*   not  be moved or have their declarations changed because they are
  7    81*   used in the handling of old version database openings.
  7    82*
  7    83*
  7    84**/
  7    85 
  7    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  7    87 	     2 data	      like rm_db_info_data,
  7    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  7    89 
  7    90      dcl	   rdbi_ptr	      ptr;
  7    91 
  7    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  7    93*						   like reference to it without getting the area as well */
  7    94 	     2 db_version	      fixed bin,		/* version no. of db */
  7    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  7    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  7    97 	     2 db_path	      char (168),		/* abs. path of db. */
  7    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  7    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  7   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  7   101 	     2 pad	      bit (34) unal,	/* for future use */
  7   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  7   103*                                                               dbcb and rdbi segments in the db dir */
  7   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  7   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  7   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  7   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  7   108 
  7   109 /* END mdbm_rm_db_info.incl.pl1 */
  7   110 
  7   111 
     1571 
     1572 
  8     1 /* BEGIN mrds_predicate_tree.incl.pl1 -- jaw, 2/14/79 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*   81-06-01 Jim Gray : removed assn type and len, now that
  8     6*   mu_convert is being used.
  8     7*
  8     8*
  8     9**/
  8    10 
  8    11 
  8    12 dcl 1 pred_node based (pn_ptr),			/*  structure of predicate tree node */
  8    13     2 type fixed bin,				/*  indicates if node or leaf */
  8    14     2 id unal,					/* id for node */
  8    15       3 lleaf_id like pred_leaf.id,			/* id for left leaf */
  8    16       3 op_code bit (6) unal,				/* operator code for this node */
  8    17       3 rleaf_id like pred_leaf.id,			/* id for right leaf */
  8    18     2 term_type fixed bin (5) unal,			/* if term, indicates type of term */
  8    19     2 root bit (1) unal,				/* on if root node */
  8    20     2 term bit (1) unal,				/* on if node is term */
  8    21     2 determined bit (1) unal,			/* on if term is "determined" independent of other terms */
  8    22     2 reserved bit (21) unal,				/* reserved for future use */
  8    23     2 parent ptr,					/* pointer to parent node */
  8    24     2 lbr ptr,					/* pointer to left branch */
  8    25     2 rbr ptr;					/* pointer to right branch */
  8    26 
  8    27 dcl  pn_ptr ptr;
  8    28 
  8    29 dcl 1 pred_array based (pred_ptr),			/* list representation of pred. */
  8    30     2 type fixed bin,				/*  indicates array, rather than node or leaf */
  8    31     2 num_ands fixed bin,				/* is the number of and groups */
  8    32     2 and_ptr (num_ands_init refer (pred_array.num_ands)) ptr; /* pointers to the and groups */
  8    33 
  8    34 dcl  pred_ptr ptr;
  8    35 
  8    36 dcl 1 and_group based (ag_ptr),			/* list of pointers to all terms in and group */
  8    37     2 num_terms fixed bin,				/* number of terms in list */
  8    38     2 term_ptr (num_terms_init refer (and_group.num_terms)) ptr; /* point to terms in this and group */
  8    39 
  8    40 dcl  ag_ptr ptr;
  8    41 dcl (num_ands_init,
  8    42      num_terms_init) fixed bin;
  8    43 
  8    44 dcl ((CURRENT_OP init ("000001"b)),			/* pred_node op_codes */
  8    45     (AND_OP init ("000010"b)),
  8    46     (OR_OP init ("000011"b)),
  8    47     (NOT_OP init ("000100"b)),
  8    48     (EQ_OP init ("000101"b)),
  8    49     (NE_OP init ("000110"b)),
  8    50     (LT_OP init ("000111"b)),
  8    51     (GT_OP init ("001000"b)),
  8    52     (LE_OP init ("001001"b)),
  8    53     (GE_OP init ("001010"b)),
  8    54     (ALL_OP init ("001011"b))) bit (6) int static options (constant);
  8    55 
  8    56 dcl ((CONST init (1)),				/* pred leaf data types */
  8    57     (ATTR init (2)),
  8    58     (EXPRES init (3))) fixed bin int static options (constant);
  8    59 
  8    60 dcl ((NODE init (0)),				/* type indicators */
  8    61     (LEAF init (1)),
  8    62     (ARRAY init (2))) fixed bin int static options (constant);
  8    63 
  8    64 dcl ((V_C init (1)),				/* pred_node term_types */
  8    65     (V_V init (2))) fixed bin (5) int static options (constant);
  8    66 
  8    67 dcl 1 pred_leaf based (pl_ptr),			/* structure for a predicate tree leaf */
  8    68     2 type fixed bin,				/* indicates if node or leaf */
  8    69     2 id,						/* leaf id */
  8    70       3 var_id bit (18) unal,				/* index of tuple var. */
  8    71       3 attr_id bit (18) unal,			/* defn order of attr. */
  8    72     2 dummy bit (1) unal,				/* on if dummy leaf for ALL_OP */
  8    73     2 reserved bit (35) unal,				/* reserved for future use */
  8    74     2 data_type fixed bin,				/* whether const, attr, or expr */
  8    75     2 lit_offset fixed bin (35),			/* bit offset of literal or expr. result */
  8    76     2 lit_length fixed bin (35),			/* bit length of literal or expr. result */
  8    77     2 rslt_desc bit (36),				/* descriptor of expr. result */
  8    78     2 lit_ptr ptr,					/* ptr to literal or expr. result value */
  8    79     2 lit_desc_ptr ptr,				/* ptr to literal or expr. result desc. */
  8    80     2 ai_ptr ptr,					/* to rm_attr_info for attribute */
  8    81     2 expr_ptr ptr,					/* pointer to expr. structure if expr. leaf */
  8    82     2 parent ptr;					/* pointer to parent node */
  8    83 
  8    84 dcl  pl_ptr ptr;
  8    85 
  8    86 /* END mrds_predicate_tree.incl.pl1 */
  8    87 
     1573 
     1574 
  9     1 /* BEGIN INCLUDE FILE mrds_expressions.incl.pl1 -- jaw 2/15/79 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*   81-06-01 Jim Gray : removed assn len and type elements
  9     6*   since mu_covnert is now being used.
  9     7*
  9     8**/
  9     9 
  9    10 
  9    11 dcl 1 expr aligned based (expr_ptr),			/* internal representation of an expression,
  9    12*						   expression is stored in postfix polish form */
  9    13     2 nitems fixed bin,				/* no. items in expression */
  9    14     2 item (nexp_items_init refer (expr.nitems)),
  9    15       3 type fixed bin (3) unal,			/* 1 => data item
  9    16*						   2 => operator
  9    17*						   3 => scalar function */
  9    18       3 op_code fixed bin (3) unal,			/* 1 => add
  9    19*						   2 => subtract
  9    20*						   3 => multiply
  9    21*						   4 => divide */
  9    22       3 data_type fixed bin (2) unal,			/* 1 => literal
  9    23*						   2 => database */
  9    24       3 reserved bit (25) unal,
  9    25       3 desc bit (36),				/* data descriptor of data item or fun. result */
  9    26       3 loc_index fixed bin (18),			/* location index of data item or fun. result */
  9    27       3 bit_length fixed bin (18),			/* bit length of data item or fun. result */
  9    28       3 assn_ptr ptr,				/* pointer to item storage loc. */
  9    29       3 ai_ptr ptr,					/* to attr info if database item */
  9    30       3 fn_ptr ptr;					/* pointer to function structure if scalar function */
  9    31 
  9    32 dcl  expr_ptr ptr;
  9    33 dcl  nexp_items_init fixed bin;
  9    34 
  9    35 dcl 1 scalfn aligned based (sfn_ptr),			/* internal representation of a scalar function */
  9    36     2 entry_ptr ptr,				/* pointer to entry to be called */
  9    37     2 arg_list_ptr ptr,				/* pointer to arg list to be used for calling function */
  9    38     2 rslt_desc bit (36),				/* descriptor for result */
  9    39     2 nargs fixed bin,				/* number of input args */
  9    40     2 arg (nsf_args_init refer (scalfn.nargs)),		/* arg info */
  9    41       3 type fixed bin (3) unal,			/* 1 => literal
  9    42*						   2 => database
  9    43*						   3 => scalar function
  9    44*						   4 => expression */
  9    45       3 must_convert bit (1) unal,			/* on if arg must be converted to match requirements */
  9    46       3 reserved bit (31) unal,
  9    47       3 desc bit (36),				/* descriptor of data or result */
  9    48       3 loc_index fixed bin (18),			/* location index of data item or result */
  9    49       3 bit_length fixed bin (18),			/* bit length of data item or result */
  9    50       3 assn_ptr ptr,				/* pointer to item storage loc. */
  9    51       3 arg_desc bit (36),				/* descriptor for arg if must convert */
  9    52       3 arg_assn_ptr ptr,				/* assign_ ptr for arg in must convert */
  9    53       3 ai_ptr ptr,					/* to attr info if database item */
  9    54       3 ef_ptr ptr;					/* pointer to expression or function structure, or null */
  9    55 
  9    56 dcl  sfn_ptr ptr;
  9    57 dcl  nsf_args_init fixed bin;
  9    58 
  9    59 dcl ((DATA init (1)),
  9    60     (OPERATOR init (2)),
  9    61     (SCAL_FUN init (3)),
  9    62     (EXPR init (4)),
  9    63     (ADD init (1)),
  9    64     (SUBT init (2)),
  9    65     (MULT init (3)),
  9    66     (DIV init (4)),
  9    67     (LITERAL init (1)),
  9    68     (DATABASE init (2))) fixed bin int static options (constant);
  9    69 
  9    70 dcl  CFLTD59 bit (36) aligned int static options (constant)
  9    71      init ("100110000000000000000000000000111011"b);
  9    72 dcl  RFLTD59 bit (36) aligned int static options (constant)
  9    73      init ("100101000000000000000000000000111011"b);
  9    74 
  9    75 /* END INCLUDE FILE mrds_expressions.incl.pl1 */
  9    76 
     1575 
     1576 
 10     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
 10     2 
 10     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
 10     4 
 10     5 dcl 1 range aligned based (range_ptr),
 10     6     2 num_vars fixed bin,				/* number of tuple variables */
 10     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
 10     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
 10     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
 10    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
 10    11*						   a -select clause. */
 10    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
 10    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
 10    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
 10    15       3 reserved bit (31) unal,			/* reserved for future use */
 10    16       3 rel_index fixed bin,				/* index to assoc. relation */
 10    17       3 stv_ptr ptr,				/* simple typed vector */
 10    18       3 idl_ptr ptr,				/* id_list ptr */
 10    19       3 needed_bits aligned,
 10    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
 10    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
 10    22 
 10    23 dcl  range_ptr ptr;
 10    24 
 10    25 /* END mrds_range.incl.pl1 */
 10    26 
     1577 
     1578 
 11     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*   81-06-01 Jim Gray : removed user len and type elements,
 11     6*   since mu_convert rather than assign_ is now used.
 11     7*
 11     8*   84-11-22 John Hergert: added fr_ptr
 11     9*
 11    10*/****^  HISTORY COMMENTS:
 11    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
 11    12*     install(86-08-15,MR12.0-1127):
 11    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
 11    14*     around per select expression (in sets) and when compiling. (mrds #158)
 11    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 11    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 11    17*     For new parser, (and general readability) renamed sel_ptr to
 11    18*     select_list_ptr.
 11    19*                                                   END HISTORY COMMENTS */
 11    20 
 11    21 
 11    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
 11    23     2 num_vars fixed bin,				/* number of free variables */
 11    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
 11    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
 11    26     2 num_items fixed bin,				/* number of attributes specified in select list */
 11    27     2 var_exists (36) bit(1),
 11    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
 11    29       3 must_convert bit (1) unal,			/* on if conversion required */
 11    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
 11    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
 11    32       3 reserved bit (33) unal,			/* reserved for future use */
 11    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
 11    34       3 ai_ptr ptr,					/* ptr to attr_info */
 11    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
 11    36       3 user_ptr ptr ;				/* pointer to user's area */
 11    37 
 11    38 dcl  select_list_ptr ptr int automatic init (null ());
 11    39 
 11    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
 11    41     2 var_index fixed bin,
 11    42     2 ml_ptr ptr;
 11    43 
 11    44 /* END mrds_select_list.incl.pl1 */
 11    45 
     1579 
     1580 
 12     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
 12     2 
 12     3 /* HISTORY:
 12     4*
 12     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
 12     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
 12     7*
 12     8**/
 12     9  
 12    10 dcl 1 tuple_info aligned based (ti_ptr),
 12    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
 12    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
 12    13       3 tuple_ptr ptr,				/* pointer to found tuple */
 12    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
 12    15       3 var_index fixed bin;				/* index to tuple variable  */
 12    16 
 12    17 dcl  ti_ptr ptr;
 12    18 dcl  ti_ntuples_init fixed bin;
 12    19 
 12    20 /* END mrds_tuple_info.incl.pl1 */
 12    21 
     1581 
     1582 
 13     1 /* BEGIN mrds_search_vars.incl.pl1 -- jaw, 2/26/79 */
 13     2 
 13     3 dcl 1 search_vars aligned based (sv_ptr),		/* info on all variables */
 13     4     2 nvars fixed bin,				/* number of variables */
 13     5     2 new_val (sv_nvars_init refer (search_vars.nvars),	/* indicates new values to be moved */
 13     6      sv_nvars_init refer (search_vars.nvars)) bit (1) unal,
 13     7     2 info (sv_nvars_init refer (search_vars.nvars)) like rtrv_info; /* data for each var. */
 13     8 
 13     9 dcl  sv_ptr ptr;
 13    10 dcl  sv_nvars_init fixed bin;
 13    11 
 13    12 /* END mrds_search_vars.incl.pl1 */
 13    13 
     1583 
     1584 
 14     1 /* BEGIN mdbm_rtrv_info.incl.pl1 -- jaw, 3/15/79 */
 14     2 
 14     3 /*
 14     4*   HISTORY
 14     5*
 14     6*   82-09-21 Davids: removed reference to the iocb_ind element which was the
 14     7*   index in the rm_rel_info.iocb_ptr array of the iocb to be used and added
 14     8*   the cursor_ptr element.
 14     9*   
 14    10*   82-10-1  Woodka: changed tid_array to be bit (36) aligned instead of 
 14    11*   bit (36) unaligned. 
 14    12*
 14    13*   82-10-22 Woodka : added first_seq_io bit and changed reserved to bit 32.
 14    14*
 14    15*   82-10-26 Davids: added the record_collection_cursor_ptr element. This is
 14    16*   needed because the relation manager get_tuple_by_id entry requires a 
 14    17*   record collection cursor.
 14    18*
 14    19*   83-05-03 Mike Kubicar : deleted the unused fields: thd_type, seq_io,
 14    20*   seed_id, link_io, free_array and thd_ptr.  Added the maxtids field.
 14    21*
 14    22*   83-05-31 Mike Kubicar : got rid of cursor_ptr and
 14    23*   record_collection_cursor_ptr.  Inserted the field relation_cursor_ptr.
 14    24*
 14    25**/
 14    26 
 14    27 dcl 1 rtrv_info aligned based (rti_ptr),		/* info needed to retrieve a tuple */
 14    28     2 ri_ptr ptr,					/* to rel_info */
 14    29     2 relation_cursor_ptr ptr,                              /* pointer to cursor to use */
 14    30     2 ntids fixed bin,				/* no of tuple ids in list */
 14    31     2 ctid fixed bin,				/* current position in list */
 14    32     2 maxtids fixed bin,				/* Maximum number of tids to search for */
 14    33     2 first_seq_io bit (1) unal,			/* on if first sequential i/o is to be done */
 14    34     2 reserved bit (35) unal,
 14    35     2 ta_ptr ptr;					/* to array of tuple ids */
 14    36 
 14    37 dcl  rti_ptr ptr;
 14    38 
 14    39 dcl  tid_array (ta_nids) bit (36) aligned  based (ta_ptr);	/* array of tuple ids */
 14    40 
 14    41 dcl  ta_nids fixed bin;
 14    42 dcl  ta_ptr ptr;
 14    43 
 14    44 /* END mdbm_rtrv_info.incl.pl1 */
 14    45 
     1585 
     1586 
 15     1 /* BEGIN mrds_search_ops.incl.pl1 -- 2/23/79 */
 15     2 
 15     3 /* HISTORY:
 15     4*
 15     5*   81-06-01 Jim Gray : removed assn_type and len from the  move_info
 15     6*   structure, since these are not used with the advent of mu_covert.
 15     7*
 15     8*   81-06-30 Jim Gray : added range_val_ptr to  init_info  structure,
 15     9*   so  that  ranges  (10  <  x < 20) could be handled in one call to
 15    10*   vfile select, instead of two. Also added range bit to  show  when
 15    11*   usable.
 15    12*
 15    13*   81-07-06 Jim Gray : changed init_info op type encodings for those
 15    14*   access  methods  currently available in mrds, plus added bits for
 15    15*   whether mrds or vfile needs to  do  tid  list  intersection,  and
 15    16*   whether an unordered, faster sequential search can be done.
 15    17*
 15    18*   81-07-18 Jim Gray : added many comments, after changing the named
 15    19*   constants to refer to the new access methods.
 15    20*
 15    21*   82-09-01 Mike Kubicar : converted from tuple structure to vector
 15    22*   structure.  This meant changing fields which pointed directly to
 15    23*   tuple space to use indices into the tuple_info structure instead.
 15    24*
 15    25*   82-10-01 Davids: removed the encd_hash flag from move_info since it
 15    26*   is never used and removed the encd_index flag from move_info since
 15    27*   changes to mrds_dsl_gen_srch_prog have rendered it obsolute. Increased
 15    28*   size of the reserved element from 28 to 30 bits.
 15    29*
 15    30*   83-04-04 Mike Kubicar : Removed init_info.unordered.  It is no longer
 15    31*   used.
 15    32*
 15    33*   83-04-22 Mike Kubicar : Added search_specification_ptr to select_info.
 15    34*   This is the search spec to be used when retrieving tuple from a relation.
 15    35*   Also deleted the init_info strucuture and associated constants.  It is no
 15    36*   longer used.
 15    37*
 15    38*   83-05-31 Mike Kubicar : Renamed search_specification_ptr to
 15    39*   relation_search_specification_ptr.
 15    40*
 15    41**/
 15    42 
 15    43 
 15    44 /* DESCRIPTION:
 15    45*
 15    46*		      BEGIN_DESCRIPTION
 15    47*
 15    48*   The search ops structure holds the  operations  to  be  performed
 15    49*   during   a   search   of  the  database.  It  is  a  step-by-step
 15    50*   actuallization of the selection expression specified by the user.
 15    51*   For each tuple variable, there will be an move-init-select set of
 15    52*   operations. The first operations is always an initizization~  one
 15    53*   called  PICKUP_SVP,  The  last  operation  is always a case for a
 15    54*   failure condition called RETNUL, to return  tuple_not_found.  The
 15    55*   move_init_select groups each have their own RETVAl step to return
 15    56*   a tuple, if they succeed in finding an acceptable tuple. If there
 15    57*   are multiple tuple variables, each T.V. group calls the move step
 15    58*   of the next group once it has found an acceptable tuple in  order
 15    59*   to  satisfy  all conditions of the and group. Multiple and groups
 15    60*   are processed until they exhaust all  possible  tuple  variables,
 15    61*   before the mini-search for the next and group is called.
 15    62*
 15    63*		       END_DESCRIPTION
 15    64**/
 15    65 
 15    66 dcl 1 search_ops aligned based (so_ptr),		/* the search "program" */
 15    67     2 ic fixed bin,					/* index to next instruction */
 15    68     2 nops fixed bin,				/* no. of operations in list */
 15    69     2 op (so_nops_init refer (search_ops.nops)),
 15    70       3 code fixed bin,				/* op code
 15    71*						   1 => init. range
 15    72*						   2 => move values
 15    73*						   3 => select tuple
 15    74*						   4 => return value
 15    75*						   5 => return null
 15    76*						   6 => pick up new search vars ptr */
 15    77       3 var_ind fixed bin,				/* index of tuple variable */
 15    78       3 good_xfer fixed bin,				/* rel. index of instr. if this op. successful */
 15    79       3 err_xfer fixed bin,				/* rel. index of instr. if this op is unsuccess. */
 15    80       3 info_ptr ptr;				/* pointer to op. dependent info. */
 15    81 
 15    82 dcl  so_ptr ptr;
 15    83 dcl  so_nops_init fixed bin;
 15    84 
 15    85 dcl ((INIT init (1)),
 15    86     (MOVE init (2)),
 15    87     (SEL init (3)),
 15    88     (RETVAL init (4)),
 15    89     (RETNUL init (5)),
 15    90     (PICKUP_SVP init (6))) fixed bin int static options (constant);
 15    91 
 15    92 /* the move info structure is used to obtain needed information
 15    93*   for the next database access specified by the init_info.
 15    94*   This may involve moving data from tuples in other tuple variable relations
 15    95*   in the database, doing a data conversion to a needed data type,
 15    96*   encoding the data for key usage, or evaluating an expression */
 15    97 
 15    98 dcl 1 move_info aligned based (mi_ptr),			/* info for move op. */
 15    99 						/* note: items must be processed in order since
 15   100*						   items may depend on prior items in list */
 15   101     2 bit_move bit (1) unal,				/* if just straight move */
 15   102     2 var_move bit (1) unal,				/* if straignt move of var len attr. */
 15   103     2 thread bit (1) unal,				/* on if moving thread */
 15   104     2 expr bit (1) unal,				/* if evaluating an expr. */
 15   105     2 encd_attr bit (1) unal,				/* if encoding a comparison value */
 15   106     2 extr_attr bit (1) unal,				/* if the value must be extracted from a tuple */
 15   107     2 reserved bit (30) unal,
 15   108     2 var_ind fixed bin,				/* index of source var, or 0 */
 15   109     2 tuple_var_index fixed bin,			/* index of tuple variable (tuple_info.tuple) to use */
 15   110     2 tuple_attr_index fixed bin,			/* index of attribute to extract */
 15   111     2 s_ptr ptr,					/* to source (tuple.data if var., ksl_ptr if key */
 15   112     2 t_ptr ptr,					/* target, (encoded key value if encode) tuple ptr if expr */
 15   113     2 sbit_len fixed bin (35),			/* bit length (bit offset if var.) thd type if thd */
 15   114     2 tbit_len fixed bin (35),			/* target length */
 15   115     2 s_desc bit (36),				/* descriptor for source */
 15   116     2 t_desc bit (36),				/* descriptor for target */
 15   117     2 encd_desc bit (36),				/* descriptor for encd attr */
 15   118     2 fwd_thd ptr;					/* to next move info */
 15   119 
 15   120 dcl  mi_ptr ptr;
 15   121 dcl  mi_nitems_init fixed bin;
 15   122 
 15   123 
 15   124 /* the select info structure is used to hold info about
 15   125*   where to put a tuple that satisfies all conditions,
 15   126*   and to point to a list of comparisons to be made against
 15   127*   the tuple, before it is considered acceptable */
 15   128 
 15   129 dcl 1 select_info aligned based (seli_ptr),		/* info for select op. */
 15   130     2 tuple_info_index fixed bin,			/* to output tuple */
 15   131     2 tid_ptr ptr,					/* to place to store tuple id */
 15   132     2 relation_search_specification_ptr ptr,		/* Search spec for relation manager gets */
 15   133     2 cvla_ptr ptr;					/* pointer to cvl_array */
 15   134 
 15   135 dcl  seli_ptr ptr;
 15   136 
 15   137 /* END mrds_search_ops.incl.pl1 */
 15   138 
     1587 
     1588 
 16     1 /* BEGIN mrds_optimize_tables.incl.pl1 -- jaw, 2/23/79 */
 16     2 
 16     3 /* HISTORY:
 16     4*
 16     5*   81-07-06 Jim Gray : added number  of  tuples  selected,  and  the
 16     6*   access  methods currently available to the path_var structure, to
 16     7*   allow the cost of a search path to be properly calculated.
 16     8*
 16     9*   81-07-07 Jim Gray : added in_and_group and cost to  path_var  for
 16    10*   handling not in and_group tuple variables.
 16    11*
 16    12*   81-07-13 Jim Gray : removed calc_cost related structures that are
 16    13*   no  longer  used.  Also  commented  the access methods available.
 16    14*   Added cond_ptr and attr_index to path_var to  make  gen_srch_prog
 16    15*   use access specified by permute.
 16    16*
 16    17*   81-07-14 Jim Gray : added  condition_selected  and  attr_selected
 16    18*   bits  to  the cond and attr_list structures respectively, so that
 16    19*   the permute logic in gen_srch_prog  could  be  removed,  and  the
 16    20*   desires  of  permute could be passed to gen_srch_prog. Also added
 16    21*   description of structures in this include file.
 16    22*
 16    23*   81-07-17 Jim Gray : removed unused path_array structure once used
 16    24*   by the discarded calc_cost routine, now replaced by permute.
 16    25*
 16    26*   81-07-19 Jim Gray : added in_select_clause bit  to  path_var  for
 16    27*   use  by  optimize,  gen_srch_prog  and  the  permute  display for
 16    28*   properly  handling  no_tuple_effect  tuple  variables,  and   not
 16    29*   producing cross products not specified by the user.
 16    30*
 16    31*   81-07-21 Jim Gray : added a second condition pointer to the  path
 16    32*   var  structure,  so  that  permute could detect, make use of, and
 16    33*   pass on the info for  doing  range  searches  on  key  heads  and
 16    34*   secondary indexes.
 16    35*
 16    36*   83-04-22 Mike Kubicar : removed attr_list.info.used.  It is no
 16    37*   longer needed.
 16    38*
 16    39**/
 16    40 
 16    41 
 16    42 /* DESCRIPTION:
 16    43*
 16    44*   The  major  structure  of  this  include  file  is  the  path_var
 16    45*   structure.  It is used to hold an ordered list of tuple variables
 16    46*   from the selection expression range clause, in the order in which
 16    47*   they  will  be  used  for  doing  I/O on the database in order to
 16    48*   retrieve the data necessary to evaluate the selection expression.
 16    49*
 16    50*   The alp in this structure points to the attr_list structure which
 16    51*   contains  a  list of all attributes referenced by this particular
 16    52*   tuple variable in the selection expression.
 16    53*
 16    54*   The elp in  this  path_var  structure  for  this  tuple  variable
 16    55*   similarly  points  to  the  expr_list  structure,  which contains
 16    56*   information on all expressions in the selection expression  which
 16    57*   reference the tuple variable.
 16    58*
 16    59*   The attr_list structure in turn has  a  list  of  all  conditions
 16    60*   (comparisons  involving  it)  against  that attribute in a linked
 16    61*   list of cond structures pointed to by the cond_ptr.
 16    62*
 16    63*   The op_code encoding for thecond and expr_list structures is that
 16    64*   used  in the pred_node structures of the predicate tree, and that
 16    65*   given by the named constants starting OTT_...
 16    66*
 16    67*   The path_array structure  was  originally  intended  for  use  by
 16    68*   mrds_dsl_calc_cost,  which  is  obsolete. Now only one element is
 16    69*   used to point to the path returned by permute.
 16    70*
 16    71**/
 16    72 
 16    73 dcl 1 path_var aligned based (pvp),			/* info on one path through and group */
 16    74     2 var_index fixed bin,				/* index of this var */
 16    75     2 in_and_group bit (1) unal,			/* on => this tuple variable participates in the and group */
 16    76     2 in_select_clause bit (1),			/* on => this tuple variable selected */
 16    77     2 pad bit (34) unal,				/* for future use */
 16    78     2 cost float bin (63),				/* partial sub path cost, or total for not in and_group */
 16    79     2 number_tuples_selected fixed bin (35),		/* estimate of tuples selected by access method */
 16    80     2 access_method fixed bin,			/* encoding for the method of access to this tuple variable:
 16    81*						   1 => unique key search
 16    82*						   2 => long key head search, only "=" conditions
 16    83*						   3 => short key head, other than "=" conditions
 16    84*						   4 => indexed attr
 16    85*						   5 => unordered sequential search
 16    86*						   6 => ordered sequential search */
 16    87     2 cond_ptr ptr,					/* to condition on this T.V. to be used for accessing it */
 16    88     2 second_cond_ptr ptr,				/* to second condition when a range is specified */
 16    89     2 attr_index fixed bin,				/* attr_ptr array definition order index
 16    90*						   of attr to be used for accessing this T.V. */
 16    91     2 lk_key_ind fixed bin,				/* link index or key id */
 16    92     2 alp ptr,					/* to attribute list */
 16    93     2 elp ptr,					/* to expr list */
 16    94     2 fwd_thd ptr;					/* to next in path */
 16    95 
 16    96 dcl  pvp ptr;
 16    97 
 16    98 
 16    99 /* ACCESS METHODS AVAILABLE TO MRDS:
 16   100*
 16   101*   1) any number of key attributes making up a  total  primary  key,
 16   102*   with  at  least  one  "="  condition against each allows use of a
 16   103*   vfile seek_key, to find the 1 unique tuple referenced
 16   104*
 16   105*   2) any number of key  head  attributes  with  at  least  one  "="
 16   106*   condition  against  each  allows  use of vfile select, to find >1
 16   107*   tuples whose key has this prefix value
 16   108*
 16   109*   3)  the  first  key  head  attribute  having  other  than  a  "="
 16   110*   condition,  or  any number of conditions against it allows use of
 16   111*   vfile select, to find >1 tuples whose key has this prefix
 16   112*
 16   113*   4) a single secondarily indexed attribute with any  condition  or
 16   114*   number  of  conditions  against it allows use of vfile select, to
 16   115*   find the >= 1 tuples whose values match  that  of  the  value  or
 16   116*   range of values given
 16   117*
 16   118*   5) an unordered sequential search, where no updates  against  the
 16   119*   database  relation  will  be  done allows use of mu_scan_records,
 16   120*   which goes through the records without touching the vfile keys
 16   121*
 16   122*   6) an ordered sequential search, which must touch the vfile  keys
 16   123*   in  order  to  get  the tuple records, thus producing an in-order
 16   124*   retrieval
 16   125*
 16   126**/
 16   127 
 16   128 dcl ((TOTAL_PRIMARY_KEY init (1)),
 16   129     (LONG_KEY_HEAD init (2)),
 16   130     (SHORT_KEY_HEAD init (3)),
 16   131     (INDEXED_ATTR init (4)),
 16   132     (UNORDERED_SEQUENTIAL init (5)),
 16   133     (ORDERED_SEQUENTIAL init (6))) fixed bin int static options (constant);
 16   134 
 16   135 dcl 1 attr_list aligned based (alp),			/* info on all ref. attr. for a t.v. */
 16   136     2 nattr fixed bin,				/* number of attrs in rel */
 16   137     2 info (al_nattr_init refer (attr_list.nattr)),	/* definition order array */
 16   138       3 attr_selected bit (1) unal,			/* on => this attr used by access method chosed */
 16   139       3 pad bit (35) unal,
 16   140       3 index fixed bin,				/* definition order, same as array element number  */
 16   141       3 cond_ptr ptr ;				/* to list of conditions on attr. */
 16   142 
 16   143 dcl  alp ptr;
 16   144 dcl  al_nattr_init fixed bin;
 16   145 
 16   146 dcl 1 cond aligned based (condp),			/* info on attr condition */
 16   147     2 op_code fixed bin,				/* op code translated from pred_node */
 16   148     2 condition_selected bit (1) unal,			/* on => this condition used by access method chosen */
 16   149     2 pad bit (35) unal,
 16   150     2 pl_ptr ptr,					/* to pred leaf of other attr */
 16   151     2 fwd_thd ptr;					/* to next condition */
 16   152 
 16   153 dcl  condp ptr;
 16   154 
 16   155 dcl 1 expr_list aligned based (elp),			/* info for expr in this var */
 16   156     2 nexprs fixed bin,
 16   157     2 info (el_nexprs_init refer (expr_list.nexprs)),
 16   158       3 epl_ptr ptr,				/* to pred leaf for this expr */
 16   159       3 op_code fixed bin,
 16   160       3 reserved bit (36) unal,			/* for future use */
 16   161       3 pl_ptr ptr;					/* to pred leaf of other var */
 16   162 
 16   163 dcl  elp ptr;
 16   164 dcl  el_nexprs_init fixed bin;
 16   165 
 16   166 /* COMPARISON OPERATOR NAMED CONSTANTS:
 16   167*
 16   168*   The following named constants represent the comparison  operators
 16   169*   "=", "^=", "<", "<=", ">", ">=".
 16   170*
 16   171*   They are used in the predicate tree nodes, the cond and expr_list
 16   172*   structure, and in gen_srch_prog structures. */
 16   173 
 16   174 dcl ((OTT_EQ init (1)),
 16   175     (OTT_NE init (2)),
 16   176     (OTT_LT init (3)),
 16   177     (OTT_LE init (4)),
 16   178     (OTT_GT init (5)),
 16   179     (OTT_GE init (6))) fixed bin int static options (constant);
 16   180 
 16   181 /* END mrds_optimize_tables.incl.pl1 */
 16   182 
     1589 
     1590 
 17     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
 17     2 
 17     3 /* WARNING
 17     4*          If the rm_rel_info structure is changed then the mrds_data_
 17     5*          item saved_res_version MUST be incremented to invalidate all
 17     6*          existing saved resultants
 17     7**/
 17     8 
 17     9 /* HISTORY:
 17    10*
 17    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
 17    12*   attributes,   and   varying  attributes,  so  that  partial  view
 17    13*   submodels will have the  info  needed  to  properly  set  up  the
 17    14*   varying length array headers in the tuple structure.
 17    15*
 17    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
 17    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
 17    18*   delete_tuple_perm, and make m_perm = unused_perm.
 17    19*
 17    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
 17    21*   view attribute was varying character or bit, since a partial view
 17    22*   submodel will not have this information in the resultant, and  it
 17    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
 17    24*   since with exact length storage  of  varying  length  attributes,
 17    25*   each  tuple  can  be  a  different  length,  which is can only be
 17    26*   determined by examining the tuple itself.
 17    27*
 17    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
 17    29*   interface  to  allow  temp  rel  population  to  be known, and to
 17    30*   provide a more efficient means of finding an approx. current perm
 17    31*   relation population.
 17    32*
 17    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 17    34*   blocked  files, foreign keys, and ids procedures. Also set number
 17    35*   of files per rel to a constant of 1.
 17    36*
 17    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
 17    38*   structure so that only one structure per relation is needed.
 17    39*
 17    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
 17    41*   counts.   Also  added  number  of  operations  count  since  last
 17    42*   statistics update, and a time  since  the  statistics  were  last
 17    43*   updated.
 17    44*
 17    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
 17    46*   identifier so that small relations could be updated on a per S.E.
 17    47*   basis
 17    48*
 17    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
 17    50*   to end of structure   TR 12205 (Suggestion).
 17    51*   
 17    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
 17    53*   the DMS conversion. 
 17    54*
 17    55*   82-08-30 Davids: added the opening_id element and removed the iocb
 17    56*   array and the niocb element for DMS conversion. Also removed the
 17    57*   number_selected array (and ri_niocbs_init) since subsets are not
 17    58*   going to be used.
 17    59*
 17    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
 17    61*   so that it can be used with relation manager.  Also added
 17    62*   rm_rel_info.primary_key_index_id for relation manager.
 17    63*
 17    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
 17    65*   nvar_atts, model_nvar_atts.
 17    66*
 17    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
 17    68*   since the duplicate key count for each secondary index is now being
 17    69*   kept in the attr_info structure and key_count was only needed to
 17    70*   help in calculating the average selectivity of each index which
 17    71*   can now be gotten directly from each index's dup key count. Also
 17    72*   removed the file_id element since it is no longer needed for
 17    73*   anything.
 17    74*
 17    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
 17    76*   was removed.
 17    77*
 17    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
 17    79*   used when retrieving tuples from this relation.
 17    80*
 17    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
 17    82*   for the relation. Note that this structure is part of the resultant NOT
 17    83*   part of the db.control structure. The scopes are duplicated in the resultant
 17    84*   to reduce contention for the db.control structure. Note also that the pointer
 17    85*   will always point to a scope_flags structure even if no scopes have been
 17    86*   set on the relation, the structure is allocated when the db is opened.
 17    87**/
 17    88 
 17    89 
 17    90 /* DESCRIPTION:
 17    91*
 17    92*   This structure is allocated in the area part of the structure  in
 17    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
 17    94*   at open  time  for  a  database.  There  will  be  one  of  these
 17    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
 17    96*   database view (there may be less than the total in  the  database
 17    97*   for  a  submodel  openings).  There  will  also  be  one for each
 17    98*   temporary relation currently defined for that opening.
 17    99*
 17   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
 17   101*   all  rm_rel_info  structures  allocated. It is used for searching
 17   102*   for the appropriate  structure.  This  array  is  pointed  to  by
 17   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
 17   104*   rels.
 17   105*
 17   106*   The      rm_rel_info      structure      points      to       the
 17   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
 17   108*   appearing in this view of the relation. Each  of  these  in  turn
 17   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
 17   110*   info for each attr.
 17   111*
 17   112*   Most of the other information here deals with  specifics  of  the
 17   113*   relation's  logical  definition,  such as key and secondary index
 17   114*   attribute inidicators, security permissions, and  tuple  physical
 17   115*   construction details.
 17   116*
 17   117**/
 17   118 
 17   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
 17   120 	     2 name	      char (32),		/* from submodel */
 17   121 	     2 model_name	      char (30),		/* from model */
 17   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
 17   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
 17   124 	     2 modify	      bit (1) unal,
 17   125 	     2 delete	      bit (1) unal,
 17   126 	     2 store	      bit (1) unal,
 17   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
 17   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
 17   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
 17   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
 17   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
 17   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
 17   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
 17   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
 17   135 	     2 reserved	      bit (24) unal,	/* for future use */
 17   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
 17   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
 17   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
 17   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
 17   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
 17   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
 17   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
 17   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
 17   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
 17   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
 17   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
 17   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
 17   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
 17   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
 17   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
 17   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
 17   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
 17   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
 17   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
 17   155 
 17   156      dcl	   rmri_ptr	      ptr;
 17   157      dcl	   (nkey_attr_init,
 17   158 	   natts_init,
 17   159 	   nvar_atts_init)	      fixed bin;
 17   160 
 17   161 /* END mdbm_rm_rel_info.incl.pl1 */
 17   162 
 17   163 
     1591 
     1592 
 18     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 18     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 18     3 
 18     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 18     5 
 18     6 dcl 1 arg_list based (al_ptr),
 18     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 18     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 18     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 18    10     2 pad fixed bin (17) unal,			/* must be 0 */
 18    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 18    12 
 18    13 dcl  al_ptr ptr;
 18    14 dcl  num_ptrs fixed bin;
 18    15 
 18    16 /* END mdbm_arg_list.incl.pl1  */
 18    17 
     1593 
     1594 
 19     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 19     2 
 19     3 /* these structures provide a standard for
 19     4*   1) using an entire segment as an area, managed by the area manager
 19     5*   2) a constant header, that has an offset to the major common structure in the area
 19     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 19     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 19     8 
 19     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 19    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 19    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 19    12 
 19    13 declare  model_seg_ptr ptr int automatic init (null ());
 19    14 
 19    15 
 19    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 19    17 
 19    18 declare  model_area_ptr ptr int automatic init (null ());
 19    19 
 19    20 dcl size builtin;
 19    21 
 19    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 19    23 
     1595 
     1596 
 20     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 20     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 20     3     2 version fixed bin,
 20     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 20     5 
 20     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 20     7 
 20     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 20     9 
 20    10 dcl  select_area_ptr ptr int automatic init (null ());
 20    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 20    12 
     1597 
     1598 
 21     1 /* ***********************************************************
 21     2*   *                                                         *
 21     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 21     4*   *                                                         *
 21     5*   *********************************************************** */
 21     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 21     7 
 21     8 /* Written by Lindsey Spratt, 04/02/82.
 21     9*Modified:
 21    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 21    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 21    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 21    13*	  type.
 21    14**/
 21    15 
 21    16 /* format: style2,ind3 */
 21    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 21    18 	     2 type	      fixed bin (17) unal,
 21    19 	     2 number_of_dimensions
 21    20 			      fixed bin (17) unal,
 21    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 21    22 	       3 value_ptr	      ptr unaligned;
 21    23 
 21    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 21    25 	     2 type	      fixed bin (17) unal,
 21    26 	     2 number_of_dimensions
 21    27 			      fixed bin (17) unal,
 21    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 21    29 	       3 identifier	      fixed bin (17) unal,
 21    30 	       3 pad	      bit (18) unal,
 21    31 	       3 value_ptr	      ptr unal;
 21    32 
 21    33      dcl	   simple_typed_vector_ptr
 21    34 			      ptr;
 21    35      dcl	   stv_number_of_dimensions
 21    36 			      fixed bin (17);
 21    37 
 21    38      dcl	   general_typed_vector_ptr
 21    39 			      ptr;
 21    40      dcl	   gtv_number_of_dimensions
 21    41 			      fixed bin (17);
 21    42 
 21    43      dcl	   (
 21    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 21    45 			      init (1),		/* value_ptr was aligned. */
 21    46 	   GENERAL_TYPED_VECTOR_TYPE
 21    47 			      init (2),
 21    48 	   SIMPLE_TYPED_VECTOR_TYPE
 21    49 			      init (3)
 21    50 	   )		      fixed bin (17) internal static options (constant);
 21    51 
 21    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1599 
     1600 
 22     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
 22     2 
 22     3 /* DESCRIPTION
 22     4*        The id_list structure is used to identify attributes, fields and
 22     5*   dimensions by various modules of the Data Management System.
 22     6**/
 22     7 
 22     8 /* HISTORY:
 22     9*Written by Matthew Pierret, '82.
 22    10*Modified:
 22    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
 22    12*            (constant)' and to initialize automatic variables.
 22    13**/
 22    14 
 22    15 /* format: style2,ind3 */
 22    16      dcl	   1 id_list	      aligned based (id_list_ptr),
 22    17 	     2 version	      fixed bin (35),
 22    18 	     2 number_of_ids      fixed bin (17),
 22    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
 22    20 
 22    21      dcl	   id_list_ptr	      ptr init (null);
 22    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
 22    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
 22    24 
 22    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
     1601 
     1602 
 23     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 23     2 
 23     3 /* this include file associates module names with debug switches
 23     4*   that are stored in the data segment mrds_debug_
 23     5*   each module has it's own bit(9) debug switch, to define for various
 23     6*   debug actions, with new module names to be added to the end
 23     7*   of this list using the next in order array index in mrds_debug_
 23     8*   the convention for naming is db_{module's full name}
 23     9*   for the defined declaration over mrds_debug_$switch.
 23    10*   module.name array is then changed to reflect the new
 23    11*   number of modules, with the full module name added to the bottom
 23    12*   of the initialize list for the name array.
 23    13*   the module name array is used by the command level interface that sets/resets
 23    14*   the current status of the debug switches for each module.
 23    15*   the modules themselves use the db_{module name} declared variable for
 23    16*   that module to interagate the bits for proper debug action to take.
 23    17*   the definition of the meaning of the 9-bits is up to each individual module's
 23    18*   designer. */
 23    19 
 23    20 
 23    21 /*
 23    22*   HISTORY
 23    23*
 23    24*   80-11-12 Davids: added db_mus_mod_ubtup
 23    25*
 23    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 23    27*
 23    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 23    29*   error  info  about  being queued, and request being granted after
 23    30*   being queued.
 23    31*
 23    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 23    33*   running  MR8  and  MR9 mrds against the same database at the same
 23    34*   time.
 23    35*
 23    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 23    37*   displaying internal tuple format bit offset, rather than the user
 23    38*   view.
 23    39*
 23    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 23    41*   dump  an  element  from  the  list, when display_open_names entry
 23    42*   called with switch set.
 23    43*
 23    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 23    45*   of sub_err_ messages, when cross domain compare occurs.
 23    46*
 23    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 23    48*   iocb slot and rel name.
 23    49*
 23    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 23    51*
 23    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 23    53*
 23    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 23    55*   allows  key  searches, other than than specified by permute to be
 23    56*   done as comparisons instead.
 23    57*
 23    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 23    59*   mrds_dsl_gen_srch_prog
 23    60**/
 23    61 
 23    62 declare (
 23    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 23    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 23    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 23    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 23    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 23    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 23    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 23    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 23    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 23    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 23    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 23    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 23    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 23    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 23    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 23    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 23    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 23    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 23    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 23    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 23    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 23    84          ) ;
 23    85 
 23    86 /* list of known module names, with index into name array
 23    87*   the same as that into mrds_debug_$switch,
 23    88*   number is the current count of defined module names,
 23    89*   name is the modules full name. */
 23    90 
 23    91 declare 1 module options (constant) internal static,
 23    92         2 number fixed bin init (21),
 23    93         2 name char (32) dimension (21) init (
 23    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 23    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 23    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 23    97*						   2 => reverse partial path
 23    98*						   3 => use range order for path
 23    99*						   4 => display access method costs
 23   100*						   5 => display details of final low cost path */
 23   101          "mrds_dsl_optimize",				/* 1 => pred tree,
 23   102*						   2 => paths to consider, 3 => calc_cost on */
 23   103          "mrds_dsl_search",				/* 1 => display each tuple located */
 23   104          "mrds_dsl_translate",			/* 1 => display the search program */
 23   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
 23   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
 23   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
 23   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
 23   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
 23   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
 23   111*						   and new tuple during modifies will be done */
 23   112          "mu_sec_get_tuple",				/* 1 => attribute values
 23   113*						   will be zeroed in the tuple structure
 23   114*						   is don't have read permission. */
 23   115          "mu_sec_get_tid",				/* 1 => read permission to the key
 23   116*						   is checked (if db is secured) */
 23   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
 23   118*						   and request granted from queue messages */
 23   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
 23   120*						   so can test both MR8 and MR9 mrds
 23   121*						   against the same database at the same time */
 23   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
 23   123*						   for attributes to be displayed, rather than user view */
 23   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
 23   125*						   when display_open_names entry called */
 23   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
 23   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
 23   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
 23   129*						   when the original access was a key,
 23   130*						   and the additional conditions can be done as key also
 23   131*						   2 => force key searches, regardless of strategy
 23   132*						   used to decide between compare or key search */
 23   133          ) ;
 23   134 
 23   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
 23   136 
 23   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
 23   138 
     1603 
     1604 
 24     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 24     2 
 24     3 /* WARNING
 24     4*          If the rm_attr_info structure is changed then the mrds_data_
 24     5*          item saved_res_version MUST be incremented to invalidate all
 24     6*          existing saved resultants
 24     7**/
 24     8 
 24     9 /*
 24    10*
 24    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 24    12*   that rm_rel_info does not have to be checked
 24    13*
 24    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 24    15*   foreign keys.
 24    16*
 24    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 24    18*   conversion.
 24    19*
 24    20*   82-09-15 Davids: added the number_of_dups field.
 24    21*
 24    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 24    23*   aligned.  This is to conform with the new definition in the database
 24    24*   model.  Also removed the now useless field varying.
 24    25*
 24    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 24    27*   comment for the field defn_order.
 24    28*
 24    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 24    30*   that's what relation manager returns.
 24    31*
 24    32**/
 24    33 
 24    34 
 24    35 /*
 24    36*   this   structure   is   allocated   in   the   static   area   of
 24    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 24    38*   a     readied     file.      it     in     turn     points     to
 24    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 24    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 24    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 24    42*   position  within  a  tuple as stored in the data file are kept in
 24    43*   this resultant model of the attribute.
 24    44* */
 24    45 
 24    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 24    47     2 name char (32),				/* from submodel */
 24    48     2 model_name char (32),				/* from model */
 24    49     2 key_attr bit (1) unal,				/* if key attribute */
 24    50     2 index_attr bit (1) unal,			/* if secondary index */
 24    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 24    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 24    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 24    54     2 reserved bit (30) unal,				/* for future use */
 24    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 24    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 24    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 24    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 24    59     2 domain_ptr ptr,				/* to domain info */
 24    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 24    61*                                                               be the number of duplicate values, exact
 24    62*                                                               for a page_file database, an estimate for a vfile type */
 24    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 24    64 
 24    65 dcl  rai_ptr ptr int automatic init (null ());
 24    66 
 24    67 /* END mdbm_rm_attr_info.incl.pl1 */
 24    68 
 24    69 
     1605 
     1606 
     1607 
     1608      end mrds_dsl_optimize;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1114.5  mrds_dsl_optimize.pl1             >udd>sm>ds>w>ml>mrds_dsl_optimize.pl1
1559         1    04/18/85  1728.1  mdbm_scope_info.incl.pl1          >ldd>incl>mdbm_scope_info.incl.pl1
1561         2    03/06/85  1131.5  dm_element_id_list.incl.pl1       >ldd>incl>dm_element_id_list.incl.pl1
1563         3    10/14/83  1709.1  dm_range_constants.incl.pl1       >ldd>incl>dm_range_constants.incl.pl1
1565         4    10/14/83  1709.1  dm_relation_spec.incl.pl1         >ldd>incl>dm_relation_spec.incl.pl1
1567         5    10/14/83  1709.1  dm_specification_head.incl.pl1    >ldd>incl>dm_specification_head.incl.pl1
1569         6    08/04/88  2143.3  mrds_dbcb.incl.pl1                >ldd>incl>mrds_dbcb.incl.pl1
1571         7    08/04/88  2143.3  mdbm_rm_db_info.incl.pl1          >ldd>incl>mdbm_rm_db_info.incl.pl1
1573         8    10/14/83  1708.9  mrds_predicate_tree.incl.pl1      >ldd>incl>mrds_predicate_tree.incl.pl1
1575         9    10/14/83  1708.9  mrds_expressions.incl.pl1         >ldd>incl>mrds_expressions.incl.pl1
1577        10    10/14/83  1709.1  mrds_range.incl.pl1               >ldd>incl>mrds_range.incl.pl1
1579        11    08/04/88  2143.3  mrds_select_list.incl.pl1         >ldd>incl>mrds_select_list.incl.pl1
1581        12    10/14/83  1709.0  mrds_tuple_info.incl.pl1          >ldd>incl>mrds_tuple_info.incl.pl1
1583        13    10/14/83  1708.9  mrds_search_vars.incl.pl1         >ldd>incl>mrds_search_vars.incl.pl1
1585        14    10/14/83  1709.1  mdbm_rtrv_info.incl.pl1           >ldd>incl>mdbm_rtrv_info.incl.pl1
1587        15    10/14/83  1709.1  mrds_search_ops.incl.pl1          >ldd>incl>mrds_search_ops.incl.pl1
1589        16    10/14/83  1709.1  mrds_optimize_tables.incl.pl1     >ldd>incl>mrds_optimize_tables.incl.pl1
1591        17    10/14/83  1709.1  mdbm_rm_rel_info.incl.pl1         >ldd>incl>mdbm_rm_rel_info.incl.pl1
1593        18    10/14/83  1709.0  mdbm_arg_list.incl.pl1            >ldd>incl>mdbm_arg_list.incl.pl1
1595        19    10/14/83  1708.6  mdbm_seg_area.incl.pl1            >ldd>incl>mdbm_seg_area.incl.pl1
1597        20    10/14/83  1708.6  mrds_select_area.incl.pl1         >ldd>incl>mrds_select_area.incl.pl1
1599        21    10/14/83  1709.1  vu_typed_vector.incl.pl1          >ldd>incl>vu_typed_vector.incl.pl1
1601        22    10/14/83  1709.1  dm_id_list.incl.pl1               >ldd>incl>dm_id_list.incl.pl1
1603        23    10/14/83  1709.0  mrds_debug_names.incl.pl1         >ldd>incl>mrds_debug_names.incl.pl1
1605        24    10/14/83  1709.1  mdbm_rm_attr_info.incl.pl1        >ldd>incl>mdbm_rm_attr_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 5-22 ref 535
AND_OP                                 constant        bit(6)                   initial packed unaligned dcl 8-44 ref 616 633 638
                                                                                  640 728 742 783 789
ARRAY                                  constant        fixed bin(17,0)          initial dcl 8-60 ref 818
ELEMENT_ID_LIST_VERSION_1       000226 automatic       fixed bin(35,0)          initial dcl 2-28 set ref 2-28* 515
EXPR                                   constant        fixed bin(17,0)          initial dcl 9-59 ref 1363
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 22-23 ref 1387
INDEXED_ATTR                           constant        fixed bin(17,0)          initial dcl 16-128 ref 975 978 1004
INIT                                   constant        fixed bin(17,0)          initial dcl 15-85 ref 547
LONG_KEY_HEAD                          constant        fixed bin(17,0)          initial dcl 16-128 ref 998
LOW_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 3-8 ref 542
NODE                                   constant        fixed bin(17,0)          initial dcl 8-60 ref 653 741 1233 1270
NOT_OP                                 constant        bit(6)                   initial packed unaligned dcl 8-44 ref 627 655 682
OR_OP                                  constant        bit(6)                   initial packed unaligned dcl 8-44 ref 616 633 638
                                                                                  728 782 841
PICKUP_SVP                             constant        fixed bin(17,0)          initial dcl 15-85 ref 471
RETNUL                                 constant        fixed bin(17,0)          initial dcl 15-85 ref 446 566
RETVAL                                 constant        fixed bin(17,0)          initial dcl 15-85 ref 565
SCAL_FUN                               constant        fixed bin(17,0)          initial dcl 9-59 ref 1342 1365
SEL                                    constant        fixed bin(17,0)          initial dcl 15-85 ref 548
SHORT_KEY_HEAD                         constant        fixed bin(17,0)          initial dcl 16-128 ref 1004
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 21-43 ref 1402
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 5-19 ref 534
TOTAL_PRIMARY_KEY                      constant        fixed bin(17,0)          initial dcl 16-128 ref 998
access_method             7            based           fixed bin(17,0)          level 2 dcl 16-73 set ref 975 976 978* 986 998 998
                                                                                  1004 1004 1021*
access_method_name              000000 constant        char(32)                 initial array packed unaligned dcl 1544 set ref 986*
addr                                                   builtin function         dcl 1516 ref 388 530
addrel                                                 builtin function         dcl 1516 ref 511
administrator           126(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-86 ref 974 993
after                                                  builtin function         dcl 1516 ref 589 965
ag_ptr                          000242 automatic       pointer                  dcl 8-40 set ref 831* 836 837 838 852* 856 861 873
                                                                                  875 875 876 876 905* 911*
and_group                 2     000144 automatic       structure                array level 2 in structure "search_array" dcl 1474
                                                                                  in procedure "mrds_dsl_optimize" set ref 1052*
                                                                                  1052 1053* 1053 1054* 1054
and_group                              based           structure                level 1 unaligned dcl 8-36 in procedure
                                                                                  "mrds_dsl_optimize" set ref 831 852
and_ptr                         000120 automatic       pointer                  dcl 1453 in procedure "mrds_dsl_optimize" set ref
                                                                                  737* 741 742 743 744 745 746 747 751* 753 753* 754
                                                                                  756 762* 764 764* 765 767
and_ptr                   2            based           pointer                  array level 2 in structure "pred_array" dcl 8-29
                                                                                  in procedure "mrds_dsl_optimize" set ref 838* 861*
                                                                                  905
and_stack                       000134 automatic       pointer                  array dcl 1469 set ref 864* 865* 869 884* 885*
and_top                         000103 automatic       fixed bin(17,0)          dcl 1444 set ref 863* 867 869 870* 870 881 883* 883
                                                                                  884 885
append_tuple              1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1556 ref 501
arg                       6            based           structure                array level 2 dcl 9-35
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 10-5 ref
                                                                                  1392 1407
attr_index               14            based           fixed bin(17,0)          level 2 dcl 16-73 set ref 998* 1007
attr_name                       000204 automatic       char(32)                 packed unaligned dcl 1551 set ref 1007* 1011* 1014*
attr_ptrs                              based           pointer                  array level 2 dcl 17-119 ref 1007
before                                                 builtin function         dcl 1516 ref 589 965
begin_and_group                 000106 automatic       fixed bin(17,0)          dcl 1444 set ref 1092* 1098 1098 1100 1100
bv_idl_ptr                      000514 automatic       pointer                  dcl 1422 set ref 1378* 1382 1395
bv_ri_ptr                       000520 automatic       pointer                  dcl 1424 set ref 1377* 1378 1385
bv_stv_ptr                      000516 automatic       pointer                  dcl 1423 set ref 1376* 1381 1410
c_ptr                           000110 automatic       pointer                  dcl 1453 in procedure "mrds_dsl_optimize" set ref
                                                                                  629* 630 630 630 633 633 638 638 640 665 667 668
                                                                                  670 671 682 686 696 697 699 702 732* 749 753 755
                                                                                  755* 764 766 766* 783 785* 788
c_ptr                                  parameter       pointer                  dcl 1243 in procedure "copy_subtree" set ref 1239
                                                                                  1257* 1260 1262
c_ptr                     2     000106 automatic       pointer                  array level 2 in structure "node_stack" dcl 1250
                                                                                  in procedure "copy_subtree" set ref 1262* 1267
                                                                                  1307* 1309*
cd                                     parameter       fixed bin(35,0)          dcl 1434 ref 1430 1436
code                                   parameter       fixed bin(35,0)          dcl 1441 in procedure "mrds_dsl_optimize" set ref 25
                                                                                  365* 397* 1436*
code                      2            based           fixed bin(17,0)          array level 3 in structure "search_ops" dcl 15-66
                                                                                  in procedure "mrds_dsl_optimize" set ref 446* 471*
                                                                                  547* 548* 565* 566*
cond                                   based           structure                level 1 dcl 16-146
cond_ptr                 10            based           pointer                  level 2 dcl 16-73 ref 1011 1014
condition_name                  000060 constant        char(2)                  initial array packed unaligned dcl 1542 set ref
                                                                                  1011* 1014* 1014*
copy_ptr                        000122 automatic       pointer                  dcl 1453 set ref 751* 754 762* 765 781
cost                      2     000144 automatic       float bin(63)            array level 3 dcl 1474 set ref 911* 1050 1050 1079
                                                                                  1091
cp_ptr                          000102 automatic       pointer                  dcl 1243 set ref 1267* 1271 1272 1273 1275 1276 1280
                                                                                  1280 1281 1285 1285 1290 1294 1294 1295 1299 1299
                                                                                  1307 1309 1315 1316 1317 1317 1319
create_cursor           156            based           entry variable           level 4 dcl 6-142 set ref 490*
ctid                                   based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 495*
current_max_tids_per_call       000216 automatic       fixed bin(35,0)          dcl 1555 set ref 497* 501* 509 511 543
current_scope_flags                    based           structure                level 1 dcl 1556
current_scope_ptr               000220 automatic       pointer                  dcl 1557 set ref 500* 501 501 501 501 501 501
current_tuple_population
                         31            based           fixed bin(35,0)          level 2 dcl 17-119 ref 401
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 6-142 set ref 490*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 6-142 set ref 490*
cvla_ptr                  6            based           pointer                  level 2 dcl 15-129 set ref 526*
data                                   based           structure                level 2 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize"
data                                   based           structure                level 2 in structure "rm_db_info" dcl 7-86
                                                                                  in procedure "mrds_dsl_optimize"
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 23-62 ref 339 340
dbcb                                   based           structure                level 1 dcl 6-142
dbcb_data                              based           structure                level 1 unaligned dcl 6-148
dbcb_ptr                               parameter       pointer                  dcl 6-146 set ref 25 342 343 344 345 347 352 359 406
                                                                                  456 457 476 490 490 490 490 490 582 803* 911* 926*
                                                                                  929 1027* 1033 1036
dbi                     114            based           fixed bin(35,0)          level 3 dcl 6-142 set ref 490*
delete_tuple              0(02)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 1556 in procedure
                                                                                  "mrds_dsl_optimize" ref 501
delete_tuple              1(02)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 1556 in procedure
                                                                                  "mrds_dsl_optimize" ref 501
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 21-17
display_predicate_tree          000131 automatic       bit(1)                   packed unaligned dcl 1462 set ref 339* 803
display_search_paths            000132 automatic       bit(1)                   packed unaligned dcl 1462 set ref 340* 924
done                            000130 automatic       bit(1)                   packed unaligned dcl 1462 set ref 733* 735 788* 789*
                                                                                  906*
e_ptr                                  parameter       pointer                  dcl 1331 set ref 1327 1334 1338 1339* 1341 1342 1342
ef_ptr                   22            based           pointer                  array level 3 dcl 9-35 set ref 1363* 1365*
element_id_list                        based           structure                level 1 dcl 2-21
element_id_list_ptr             000224 automatic       pointer                  dcl 2-26 set ref 514* 515 516
element_id_list_segment_ptr
                         64            based           pointer                  level 3 dcl 6-142 ref 476
err_xfer                  5            based           fixed bin(17,0)          array level 3 dcl 15-66 set ref 447* 475* 554* 555*
                                                                                  558* 559* 567* 567* 1098* 1100*
exchanged                       000145 automatic       bit(1)                   packed unaligned dcl 1483 set ref 1046* 1056* 1060
expr                                   based           structure                level 1 dcl 9-11 set ref 1335 1338* 1338
expr_ptr                        000246 automatic       pointer                  dcl 9-32 in procedure "mrds_dsl_optimize" set ref
                                                                                  1335* 1338 1339
expr_ptr                 16            based           pointer                  level 2 in structure "pred_leaf" dcl 8-67
                                                                                  in procedure "mrds_dsl_optimize" set ref 1317
                                                                                  1317*
f_ptr                                  parameter       pointer                  dcl 1352 set ref 1348 1355 1359 1360* 1362 1363 1363
                                                                                  1365 1365
file_type                40            based           fixed bin(17,0)          level 2 dcl 17-119 ref 498
fixed                                                  builtin function         dcl 1516 ref 630
flags                     5            based           structure                level 2 packed packed unaligned dcl 4-9
fn_ptr                   12            based           pointer                  array level 3 dcl 9-11 set ref 1342*
fwd_thd                  22            based           pointer                  level 2 dcl 16-73 ref 948 1139 1184
good_use_found                  000442 automatic       bit(1)                   packed unaligned dcl 1217 set ref 1171* 1172 1174
                                                                                  1178* 1191
good_xfer                 4            based           fixed bin(17,0)          array level 3 dcl 15-66 set ref 447* 474* 551* 552*
                                                                                  567* 572*
head                                   based           structure                level 2 dcl 4-9
i                               000522 automatic       fixed bin(17,0)          dcl 1425 in procedure "build_vectors" set ref 1375*
                                                                                  1376 1377 1379 1381 1382 1388 1392 1403 1407 1416*
i                               000100 automatic       fixed bin(17,0)          dcl 1353 in procedure "copy_fun" set ref 1362* 1363
                                                                                  1363 1365 1365*
i                               000440 automatic       fixed bin(17,0)          dcl 1216 in procedure "check_no_tuple_effect" set
                                                                                  ref 1164* 1166 1178 1196*
i                               000412 automatic       fixed bin(17,0)          dcl 896 in procedure "create_search_lists" set ref
                                                                                  902* 905 911 911 914 934 965 1027 1027* 1042* 1048
                                                                                  1062 1062* 1062 1078* 1079 1080* 1090* 1091 1093
                                                                                  1095*
i                               000100 automatic       fixed bin(17,0)          dcl 1332 in procedure "copy_expr" set ref 1341* 1342
                                                                                  1342*
i                               000354 automatic       fixed bin(17,0)          dcl 374 in procedure "cross_prod" set ref 398* 400
                                                                                  400 401 401 402* 409* 411* 478* 480 482 487 487
                                                                                  490 490 495 495 509 510 511 514 517 518 527 549
                                                                                  553* 587* 589 589 592 594
ic                                     based           fixed bin(17,0)          level 2 dcl 15-66 set ref 444* 470* 1088*
icode                           000100 automatic       fixed bin(35,0)          dcl 1442 set ref 402* 435 447* 490* 493 493* 911*
                                                                                  912 912* 1027* 1029 1029*
id                        1            based           structure                level 2 in structure "pred_leaf" packed packed
                                                                                  unaligned dcl 8-67 in procedure
                                                                                  "mrds_dsl_optimize"
id                        1            based           structure                level 2 in structure "pred_node" packed packed
                                                                                  unaligned dcl 8-12 in procedure
                                                                                  "mrds_dsl_optimize"
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 22-16
                                                                                  in procedure "mrds_dsl_optimize" set ref 1395*
                                                                                  1395
id_list                                based           structure                level 1 dcl 22-16 set ref 1386
id_list_ptr                     000314 automatic       pointer                  initial dcl 22-21 in procedure "mrds_dsl_optimize"
                                                                                  set ref 22-21* 1386* 1387 1388 1390 1394 1394 1395
                                                                                  1395 1398 1400
id_list_ptr                            based           pointer                  level 2 in structure "rm_rel_info" dcl 17-119
                                                                                  in procedure "mrds_dsl_optimize" ref 1378
idl_ptr                                based           pointer                  array level 3 dcl 10-5 set ref 1382* 1388*
ii                              000356 automatic       fixed bin(17,0)          dcl 374 set ref 517* 521 547 549 551 554 558
il_number_of_ids                000316 automatic       fixed bin(17,0)          initial dcl 22-22 set ref 22-22* 1385* 1386 1386
                                                                                  1391 1406
in_and_group              1            based           bit(1)                   level 2 packed packed unaligned dcl 16-73 ref 958
                                                                                  1178
in_select_clause          2            based           bit(1)                   level 2 dcl 16-73 ref 958
info                                   based           structure                array level 2 dcl 13-3
info_ptr                        000160 automatic       pointer                  initial dcl 1535 in procedure "mrds_dsl_optimize"
                                                                                  set ref 1535*
info_ptr                  6            based           pointer                  array level 3 in structure "search_ops" dcl 15-66
                                                                                  in procedure "mrds_dsl_optimize" set ref 451* 472*
                                                                                  521* 525* 573* 573*
ioa_                            000040 constant        entry                    external dcl 1514 ref 584 594 597 925 927 934 936
                                                                                  983 986 995 998 1011 1014 1033
item                      2            based           structure                array level 2 dcl 9-11
j                               000355 automatic       fixed bin(17,0)          dcl 374 in procedure "cross_prod" set ref 411* 416
                                                                                  416 417 418 419 419 420 420 421 422* 527* 527* 529
                                                                                  530
j                               000413 automatic       fixed bin(17,0)          dcl 896 in procedure "create_search_lists" set ref
                                                                                  1048* 1050 1050 1052 1053 1053 1054* 1093* 1095*
j                               000441 automatic       fixed bin(17,0)          dcl 1216 in procedure "check_no_tuple_effect" set
                                                                                  ref 1172* 1174*
k                               000523 automatic       fixed bin(17,0)          dcl 1426 in procedure "build_vectors" set ref 1391*
                                                                                  1392 1395* 1406* 1407 1410*
k                               000414 automatic       fixed bin(17,0)          dcl 896 in procedure "create_search_lists" set ref
                                                                                  1089* 1092 1094* 1094 1095 1098 1100 1103* 1103
                                                                                  1104
last_el_ptr                            parameter       pointer                  dcl 1121 in procedure "count_path_len_and_set_flags"
                                                                                  set ref 1110 1138*
last_el_ptr                     000154 automatic       pointer                  dcl 1510 in procedure "mrds_dsl_optimize" set ref
                                                                                  917* 921
lbr                       6            based           pointer                  level 2 dcl 8-12 set ref 622 629 665* 665 667* 670*
                                                                                  686* 686 690 699 699* 724 749 753* 762* 764* 765*
                                                                                  766* 766* 767* 845 865 885 1276* 1280 1290* 1294
                                                                                  1308 1309
lleaf_id                  1            based           structure                level 3 packed packed unaligned dcl 8-12 set ref
                                                                                  657* 657* 745*
ltrim                                                  builtin function         dcl 1516 ref 589 965
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-9 set ref 533*
                                                                                  538*
maxtids                                based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 509*
mbz                       5(01)        based           bit(35)                  level 3 packed packed unaligned dcl 4-9 set ref 545*
mdb_display_path_$path          000042 constant        entry                    external dcl 1529 ref 926
mdb_display_pred_tree$display_pred_tree_
                                000044 constant        entry                    external dcl 1530 ref 803
mdbm_secured            126            based           bit(1)                   level 3 packed packed unaligned dcl 7-86 ref 974 993
message                         000443 automatic       varying char(100)        dcl 1218 set ref 1163* 1193 1193* 1196* 1196 1206
                                                                                  1208*
min_path_first_el_ptr           000150 automatic       pointer                  dcl 1508 set ref 919* 926* 1027*
min_path_last_el_ptr            000152 automatic       pointer                  dcl 1509 set ref 921*
model_area_ptr                  000302 automatic       pointer                  initial dcl 19-18 set ref 19-18*
model_name               10            based           char(30)                 level 2 dcl 17-119 ref 589 965
model_seg_ptr                   000300 automatic       pointer                  initial dcl 19-13 set ref 19-13*
modify_attr               0(03)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 1556 in procedure
                                                                                  "mrds_dsl_optimize" ref 501
modify_attr               1(03)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 1556 in procedure
                                                                                  "mrds_dsl_optimize" ref 501
mrds_data_$max_and_groups       000026 external static fixed bin(35,0)          dcl 1494 ref 813 1043 1474
mrds_data_$max_and_terms        000030 external static fixed bin(35,0)          dcl 1494 ref 851
mrds_data_$max_attributes       000020 external static fixed bin(35,0)          dcl 1494 ref 401 401 401 480 480 482 482 487 487 487
                                                                                  589 589 589 589 589 592 592 592 594 594 963 963
                                                                                  963 965 965 965 965 965 983 983 1166 1166 1196
                                                                                  1196 1377 1377 1377 1379 1379 1381 1381 1382 1382
                                                                                  1388 1388 1392 1392 1403 1403 1407 1407 1416 1416
mrds_data_$max_id_len           000022 external static fixed bin(35,0)          dcl 1494 ref 401 401 401 480 480 480 482 482 482 482
                                                                                  487 487 487 589 589 589 589 589 589 592 592 592
                                                                                  594 594 594 594 963 963 963 965 965 965 965 965
                                                                                  965 983 983 983 983 1166 1166 1166 1196 1196 1196
                                                                                  1377 1377 1377 1379 1379 1379 1381 1381 1381 1382
                                                                                  1382 1382 1388 1388 1388 1392 1392 1392 1403 1403
                                                                                  1403 1407 1407 1407 1416 1416 1416
mrds_data_$max_pred_depth       000024 external static fixed bin(35,0)          dcl 1494 ref 619 673 687 721 775 842 881 1250 1304
                                                                                  1467 1468 1469
mrds_data_$max_safe_tids_returned_per_call
                                000032 external static fixed bin(35,0)          dcl 1494 ref 501
mrds_data_$max_tids_returned_per_call
                                000034 external static fixed bin(35,0)          dcl 1494 ref 497
mrds_data_$max_tup_var          000036 external static fixed bin(35,0)          dcl 1494 ref 1541
mrds_debug_$switch              000056 external static bit(9)                   array packed unaligned dcl 23-135 ref 339 339 340
                                                                                  340
mrds_dsl_gen_srch_prog          000046 constant        entry                    external dcl 1531 ref 1027
mrds_dsl_permute                000050 constant        entry                    external dcl 1532 ref 911
mrds_error_$max_and_groups      000014 external static fixed bin(35,0)          dcl 1494 set ref 827* 859*
mrds_error_$max_and_terms       000016 external static fixed bin(35,0)          dcl 1494 set ref 873*
mrds_error_$no_tuple_effect     000012 external static fixed bin(35,0)          dcl 1494 set ref 482* 485* 1208* 1209*
mrds_error_$node_stack_ovfl     000010 external static fixed bin(35,0)          dcl 1494 set ref 619* 673* 687* 721* 775* 842* 881*
                                                                                  1304*
mrds_error_$tuple_not_found     000054 external static fixed bin(35,0)          dcl 1537 ref 402 435
mu_cursor_manager_$get          000052 constant        entry                    external dcl 1533 ref 490
name                      2            based           char                     array level 3 in structure "range" dcl 10-5
                                                                                  in procedure "mrds_dsl_optimize" set ref 482* 594*
                                                                                  983* 1196
name                                   based           char(32)                 level 2 in structure "rm_attr_info" dcl 24-46
                                                                                  in procedure "mrds_dsl_optimize" ref 1007
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 17-119
                                                                                  in procedure "mrds_dsl_optimize" ref 592 968
nargs                     5            based           fixed bin(17,0)          level 2 dcl 9-35 set ref 1355 1356* 1359 1362
needed_bits                            based           structure                array level 3 dcl 10-5
neg_op                          000064 constant        bit(6)                   initial array packed unaligned dcl 1485 ref 630
new_val                   1            based           bit(1)                   array level 2 packed packed unaligned dcl 13-3 set
                                                                                  ref 463*
nexp_items_init                 000250 automatic       fixed bin(17,0)          dcl 9-33 set ref 1334* 1335 1335
next_element_id_list_ptr        000364 automatic       pointer                  dcl 382 set ref 476* 510 511*
nitems                                 based           fixed bin(17,0)          level 2 dcl 9-11 set ref 1334 1335* 1338 1341
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 17-119 ref 500 1007 1378
no_optimize             106(18)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 ref 406
                                                                                  1036
node_stack                      000106 automatic       structure                array level 1 unaligned dcl 1250 in procedure
                                                                                  "copy_subtree"
node_stack                      000134 automatic       pointer                  array dcl 1467 in procedure "mrds_dsl_optimize" set
                                                                                  ref 609* 613 621* 622* 676* 677* 690* 713* 717
                                                                                  723* 724* 781*
non_null_and_groups             000215 automatic       fixed bin(17,0)          dcl 1553 set ref 1076* 1081* 1081
non_shared_to_shared    106(23)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 set ref
                                                                                  456*
nops                      1            based           fixed bin(17,0)          level 2 dcl 15-66 set ref 442* 445* 464* 475 1080
                                                                                  1085* 1093 1104
notl_ptr                        000112 automatic       pointer                  dcl 1453 set ref 646* 653 655 657 657 657 657 665
                                                                                  668 670 677
notr_ptr                        000114 automatic       pointer                  dcl 1453 set ref 642* 653 655 657 657 657 657 667
                                                                                  668 671 676
nsf_args_init                   000254 automatic       fixed bin(17,0)          dcl 9-57 set ref 1355* 1356 1356
ntids                                  based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 495*
null                                                   builtin function         dcl 1516 ref 349 351 352 1535 1-59 4-50 4-50 11-38
                                                                                  19-13 19-18 20-6 20-10 22-21 24-65 451 482 482 521
                                                                                  526 537 573 942 1011 1134 1174 1208 1208 1317 1416
num_and_groups                  000144 automatic       fixed bin(17,0)          level 2 dcl 1474 set ref 900* 1042 1172
num_ands                  1            based           fixed bin(17,0)          level 2 dcl 8-29 set ref 814* 819* 827 829* 829 838
                                                                                  858* 858 859 861 900 902 1078 1090 1104 1104
num_ands_init                   000244 automatic       fixed bin(17,0)          dcl 8-41 set ref 813* 814 814 827 859
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 17-119 ref 500 1378 1385
num_ptrs                        000276 automatic       fixed bin(17,0)          dcl 18-14 set ref 341*
num_terms                              based           fixed bin(17,0)          level 2 dcl 8-36 set ref 831* 836* 852* 856* 873
                                                                                  875* 875 876
num_terms_init                  000245 automatic       fixed bin(17,0)          dcl 8-41 set ref 830* 831 831 836 851* 852 852 873
num_tuples                             based           fixed bin(17,0)          level 2 dcl 12-10 ref 527
num_vars                               based           fixed bin(17,0)          level 2 dcl 10-5 ref 387 898 915 917 1164 1375
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-9 set ref 533*
                                                                                  540*
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 21-17 set ref
                                                                                  1401*
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 2-21 set ref 516*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 22-16 set ref 1386* 1390* 1394* 1394
                                                                                  1395 1398 1400
number_tuples_selected
                          6            based           fixed bin(35,0)          level 2 dcl 16-73 set ref 995*
nvars                                  based           fixed bin(17,0)          level 2 dcl 13-3 set ref 460* 463 463 487 487 490
                                                                                  490 495 495 495 495 509 509 510 510 511 511 514
                                                                                  514
nxchng                          000105 automatic       fixed bin(17,0)          dcl 1444 set ref 408* 409 410* 423* 423
op                        2            based           structure                array level 2 dcl 15-66 set ref 1095* 1095 1104*
                                                                                  1104
op_code                   2            based           bit(6)                   level 3 in structure "pred_node" packed packed
                                                                                  unaligned dcl 8-12 in procedure
                                                                                  "mrds_dsl_optimize" set ref 616 616 627 630* 630
                                                                                  633 633 638 638* 640* 655* 655* 682 728 728 742*
                                                                                  782* 783* 789 841
op_code                                based           fixed bin(17,0)          level 2 in structure "cond" dcl 16-146 in procedure
                                                                                  "mrds_dsl_optimize" ref 1011 1014 1014
open                    146            based           entry variable           level 4 dcl 6-142 set ref 490*
or_stack                        000134 automatic       pointer                  array dcl 1468 set ref 811* 823 844* 845*
or_top                          000102 automatic       fixed bin(17,0)          dcl 1444 set ref 350* 810* 811 821 823 824* 824 842
                                                                                  844 845 846* 846
p_hold                          000104 automatic       pointer                  dcl 1243 set ref 1271* 1273 1315* 1319
p_ptr                                  parameter       pointer                  dcl 1243 in procedure "copy_subtree" ref 1239 1260
p_ptr                           000116 automatic       pointer                  dcl 1453 in procedure "mrds_dsl_optimize" set ref
                                                                                  731* 747 749 751 755 756 762 766 767 782 785 786*
                                                                                  786 789
p_ptr                                  parameter       pointer                  dcl 1228 in procedure "move_subtree" ref 1224 1233
                                                                                  1235
pad                       1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 4-9 set ref 536*
parent                   20            based           pointer                  level 2 in structure "pred_leaf" dcl 8-67
                                                                                  in procedure "mrds_dsl_optimize" set ref 1235*
                                                                                  1280* 1285* 1315 1319*
parent                    4            based           pointer                  level 2 in structure "pred_node" dcl 8-12
                                                                                  in procedure "mrds_dsl_optimize" set ref 668* 668*
                                                                                  699 699 702 728 731 747* 786 1233* 1260* 1271
                                                                                  1273* 1294* 1299*
path_ptr                  4     000144 automatic       pointer                  array level 3 dcl 1474 set ref 911* 914 1174
path_var                               based           structure                level 1 dcl 16-73
path_var_flags                         parameter       bit(1)                   array packed unaligned dcl 1125 in procedure
                                                                                  "count_path_len_and_set_flags" set ref 1110 1136*
path_var_flags                         based           bit(1)                   array packed unaligned dcl 1511 in procedure
                                                                                  "mrds_dsl_optimize" set ref 898 915* 917*
path_var_pointer_array          000174 automatic       pointer                  array dcl 1541 set ref 945* 956
path_var_ptr                    000430 automatic       pointer                  dcl 1130 set ref 1132* 1134 1136 1138 1139* 1139
permits                                based           structure                level 2 dcl 1556
pn_ptr                          000240 automatic       pointer                  dcl 8-27 set ref 613* 616 616 621 622 627 629 686
                                                                                  690 695 699 699 699 702 717* 720 723 724 728 728
                                                                                  728 731 732 823* 826 837 841 844 845 864 865 869*
                                                                                  872 876 884 885
pred_array                             based           structure                level 1 unaligned dcl 8-29 set ref 814
pred_leaf                              based           structure                level 1 unaligned dcl 8-67 set ref 1276 1281 1316*
                                                                                  1316
pred_node                              based           structure                level 1 unaligned dcl 8-12 set ref 642 646 737 1257
                                                                                  1272* 1272 1290 1295
pred_ptr                 56            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize" set ref 352* 359*
pred_ptr                               parameter       pointer                  dcl 8-34 in procedure "mrds_dsl_optimize" set ref 25
                                                                                  351 359 609 696* 713 803* 811 814* 818 819 827 829
                                                                                  829 838 838 858 858 859 861 861 900 902 905 1078
                                                                                  1090 1104 1104
prevents                  1            based           structure                level 2 dcl 1556
print_search_order      106(19)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 ref 582
                                                                                  929 1033
pvf_ptr                         000156 automatic       pointer                  dcl 1512 set ref 898* 915 917
pvp                             000272 automatic       pointer                  dcl 16-96 set ref 914* 917* 919 942 1174* 1174* 1178
                                                                                  1178* 1184
rai_ptr                         000320 automatic       pointer                  initial dcl 24-65 set ref 24-65*
range                                  based           structure                level 1 dcl 10-5 in procedure "mrds_dsl_optimize"
range                     6            based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 4-9 in procedure "mrds_dsl_optimize"
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize" ref 343
range_ptr                       000256 automatic       pointer                  dcl 10-23 in procedure "mrds_dsl_optimize" set ref
                                                                                  343* 387 401 480 482 487 589 589 592 594 898 915
                                                                                  917 963 965 965 983 1164 1166 1196 1375 1377 1379
                                                                                  1381 1382 1388 1392 1403 1407 1416
rbr                      10            based           pointer                  level 2 dcl 8-12 set ref 621 667 671* 702* 723 751*
                                                                                  753* 754* 755* 755* 756* 764* 844 864 884 1281*
                                                                                  1285 1295* 1299 1306 1307
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize" ref 342
rdbi_ptr                        000236 automatic       pointer                  dcl 7-90 in procedure "mrds_dsl_optimize" set ref
                                                                                  342* 974 974 993 993
read_attr                              based           bit(1)                   level 3 packed packed unaligned dcl 1556 ref 501
rel_id                   20            based           bit(36)                  level 2 dcl 17-119 set ref 490*
rel_name                        000174 automatic       char(32)                 packed unaligned dcl 1551 set ref 589* 592* 594*
                                                                                  965* 968* 983*
relation_cursor_ptr                    based           pointer                  array level 3 dcl 13-3 set ref 490*
relation_numeric_specification_ptr
                                000232 automatic       pointer                  initial dcl 4-50 set ref 4-50*
relation_search_specification          based           structure                level 1 dcl 4-9 set ref 533
relation_search_specification_ptr
                                000230 automatic       pointer                  initial dcl 4-50 in procedure "mrds_dsl_optimize"
                                                                                  set ref 4-50* 533* 534 535 536 537 538 540 542 543
                                                                                  544 545 546
relation_search_specification_ptr
                          4            based           pointer                  level 2 in structure "select_info" dcl 15-129
                                                                                  in procedure "mrds_dsl_optimize" set ref 546*
relmgr_entries          146            based           structure                level 3 dcl 6-142
return_unique_tuples      5            based           bit(1)                   level 3 packed packed unaligned dcl 4-9 set ref 544*
return_value                    000475 automatic       fixed bin(35,0)          initial dcl 1220 in procedure
                                                                                  "check_no_tuple_effect" set ref 1208* 1220*
return_value                    000162 automatic       fixed bin(35,0)          initial dcl 1536 in procedure "mrds_dsl_optimize"
                                                                                  set ref 1536*
retval                          000366 automatic       fixed bin(35,0)          dcl 385 set ref 482*
ri_ptr                                 based           pointer                  array level 3 in structure "search_vars" dcl 13-3
                                                                                  in procedure "mrds_dsl_optimize" set ref 487*
ri_ptr                                 based           pointer                  array level 3 in structure "range" dcl 10-5
                                                                                  in procedure "mrds_dsl_optimize" ref 401 487 589
                                                                                  592 963 965 1377
rleaf_id                  2(06)        based           structure                level 3 packed packed unaligned dcl 8-12 set ref
                                                                                  657* 657* 746*
rm_attr_info                           based           structure                level 1 dcl 24-46
rm_db_info                             based           structure                level 1 dcl 7-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 7-92
rm_rel_info                            based           structure                level 1 dcl 17-119
rmri_ptr                        000274 automatic       pointer                  dcl 17-156 set ref 487* 490* 490 498 500
rni                             000362 automatic       fixed bin(17,0)          dcl 374 set ref 564* 566 567 567 567 573
root                      3(12)        based           bit(1)                   level 2 packed packed unaligned dcl 8-12 set ref
                                                                                  657* 657* 695 697* 728 743* 788
rss_maximum_number_of_constraints
                                000235 automatic       fixed bin(17,0)          initial dcl 4-52 set ref 4-52* 532* 533 533 538
rss_number_of_and_groups        000234 automatic       fixed bin(17,0)          initial dcl 4-52 set ref 4-52* 531* 533 533 540
rtrim                                                  builtin function         dcl 1516 ref 1196
rtrv_info                              based           structure                level 1 dcl 14-27
rvi                             000361 automatic       fixed bin(17,0)          dcl 374 set ref 563* 565 567 567 572 573
s_ptr                           000106 automatic       pointer                  array level 2 in structure "node_stack" dcl 1250
                                                                                  in procedure "copy_subtree" set ref 1261* 1266
                                                                                  1306* 1308*
s_ptr                                  parameter       pointer                  dcl 1228 in procedure "move_subtree" ref 1224 1232
                                                                                  1233 1233 1235
s_ptr                                  parameter       pointer                  dcl 1243 in procedure "copy_subtree" ref 1239 1261
sa_alloc                        000133 automatic       bit(1)                   packed unaligned dcl 1462 set ref 348* 394*
sa_nvars                        000104 automatic       fixed bin(17,0)          dcl 1444 set ref 387* 388 391 398 408 409 458 459
                                                                                  478 554 555 563 564 585
sa_ptr                          000124 automatic       pointer                  dcl 1453 set ref 388* 391* 400 401 402 416 416 417
                                                                                  418 419 419 420 420 421 422 527 549 587 594
sap                             000126 automatic       pointer                  dcl 1453 set ref 349*
saved_access_method             000214 automatic       fixed bin(17,0)          dcl 1552 set ref 973* 976* 1021 1021
scalfn                                 based           structure                level 1 dcl 9-35 set ref 1356 1359* 1359
scope_flags                            based           structure                level 1 dcl 1-42
scope_flags_ptr                        based           pointer                  level 2 dcl 17-119 ref 500
scope_ptr                       000222 automatic       pointer                  initial dcl 1-59 set ref 1-59*
scopes_changed          106(24)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 set ref
                                                                                  457*
search_array                    000144 automatic       structure                level 1 dcl 1474
search_ops                             based           structure                level 1 dcl 15-66 set ref 442 464 1085
search_vars                            based           structure                level 1 dcl 13-3 set ref 460
second_cond_ptr          12            based           pointer                  level 2 dcl 16-73 ref 1011 1014
select_area                            based           area                     dcl 20-8 ref 391 442 460 464 522 533 642 646 737 814
                                                                                  831 852 898 1085 1257 1276 1281 1290 1295 1335
                                                                                  1356 1386 1401
select_area_ptr                 000306 automatic       pointer                  initial dcl 20-10 in procedure "mrds_dsl_optimize"
                                                                                  set ref 347* 20-10* 391 442 460 464 522 533 642
                                                                                  646 737 814 831 852 898 1085 1257 1276 1281 1290
                                                                                  1295 1335 1356 1386 1401
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize" ref 347
select_area_struct_ptr          000304 automatic       pointer                  initial dcl 20-6 set ref 20-6*
select_info                            based           structure                level 1 dcl 15-129 set ref 522
select_list_ptr                 000260 automatic       pointer                  initial dcl 11-38 set ref 344* 11-38*
select_ptr                4            based           pointer                  level 3 dcl 6-142 ref 344
seli_ptr                        000270 automatic       pointer                  dcl 15-135 set ref 522* 525 526 529 530 546
sfn_ptr                         000252 automatic       pointer                  dcl 9-56 set ref 1356* 1359 1360
si                              000357 automatic       fixed bin(17,0)          dcl 374 set ref 518* 525 548 549 552 555 559
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 21-17 set ref
                                                                                  1401
simple_typed_vector_ptr         000310 automatic       pointer                  dcl 21-33 set ref 1401* 1402 1403 1410
size                      1            based           fixed bin(35,0)          array level 2 in structure "size_array" dcl 1470
                                                                                  in procedure "mrds_dsl_optimize" set ref 401* 402
                                                                                  416 416 417 419* 419 422* 594*
size                      7            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 4-9 in procedure "mrds_dsl_optimize" set ref
                                                                                  543*
size_array                             based           structure                array level 1 unaligned dcl 1470 set ref 391
so_nops_init                    000267 automatic       fixed bin(17,0)          dcl 15-83 set ref 441* 442 442 459* 464 464 1077*
                                                                                  1080* 1080 1084* 1084 1085 1085
so_ptr                   10     000144 automatic       pointer                  array level 3 in structure "search_array" dcl 1474
                                                                                  in procedure "mrds_dsl_optimize" set ref 1027*
                                                                                  1080 1093 1095 1104 1104
so_ptr                                 parameter       pointer                  dcl 15-82 in procedure "mrds_dsl_optimize" set ref
                                                                                  25 442* 444 445 446 447 447 447 451 464* 470 471
                                                                                  472 473 474 475 521 525 547 548 549 549 551 552
                                                                                  554 555 558 559 565 566 567 567 567 567 567 572
                                                                                  573 573 1085* 1088 1095 1098 1100 1104
sorted                          000144 automatic       bit(1)                   packed unaligned dcl 1482 set ref 1041* 1044 1060*
                                                                                  1064*
spare_element                   000146 automatic       fixed bin(17,0)          dcl 1484 set ref 1043* 1052 1054
specification_head                     based           structure                level 1 unaligned dcl 5-10
sr_ptr                          000100 automatic       pointer                  dcl 1243 set ref 1266* 1270 1272 1306 1308 1316
string                                                 builtin function         dcl 1516 set ref 463* 657* 657* 657* 657* 745* 746*
stv_number_of_dimensions        000312 automatic       fixed bin(17,0)          dcl 21-35 set ref 1400* 1401 1401 1405* 1409* 1409
                                                                                  1410
stv_ptr                                based           pointer                  array level 3 dcl 10-5 set ref 1381* 1403* 1416*
sub_err_                        000062 constant        entry                    external dcl 1219 in procedure
                                                                                  "check_no_tuple_effect" ref 1208
sub_err_                        000060 constant        entry                    external dcl 384 in procedure "cross_prod" ref 482
subset_specification_ptr
                          2            based           pointer                  level 3 dcl 4-9 set ref 537*
substr                                                 builtin function         dcl 1516 ref 339 340
sv_nvars_init                   000266 automatic       fixed bin(17,0)          dcl 13-10 set ref 458* 460 460 460 460
sv_ptr                    6     000144 automatic       pointer                  array level 3 in structure "search_array" dcl 1474
                                                                                  in procedure "mrds_dsl_optimize" set ref 1027*
sv_ptr                          000264 automatic       pointer                  dcl 13-9 in procedure "mrds_dsl_optimize" set ref
                                                                                  460* 463 472 487 490 495 495 509 510 511 514
sz                              000363 automatic       fixed bin(35,0)          dcl 381 set ref 417* 422
t_ptr                                  parameter       pointer                  dcl 1228 set ref 1224 1232*
ta_ptr                                 based           pointer                  array level 3 dcl 13-3 set ref 510* 511 514
temp_pvp                        000164 automatic       pointer                  dcl 1538 set ref 942* 942* 945* 948 956* 958 958 962
                                                                                  975 976 978 986 995 998 998 998 1004 1004 1007
                                                                                  1011 1011 1014 1014 1021
temp_rel                               based           bit(1)                   array level 3 packed packed unaligned dcl 10-5 ref
                                                                                  589 965
temp_rmri_ptr                   000166 automatic       pointer                  dcl 1539 set ref 963* 968 1007
term                      3(13)        based           bit(1)                   level 2 packed packed unaligned dcl 8-12 set ref 630
                                                                                  657* 657* 720 744* 826 872 1275
term_ptr                  2            based           pointer                  array level 2 dcl 8-36 set ref 837* 876*
ti_ptr                          000262 automatic       pointer                  dcl 12-17 in procedure "mrds_dsl_optimize" set ref
                                                                                  345* 527 527 530 1376
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "mrds_dsl_optimize" ref 345
tid_ptr                   2            based           pointer                  level 2 dcl 15-129 set ref 530*
top                             000106 automatic       fixed bin(17,0)          dcl 1254 in procedure "copy_subtree" set ref 1256*
                                                                                  1261 1262 1264 1266 1267 1268* 1268 1303* 1303
                                                                                  1304 1306 1307 1308 1309
top                             000101 automatic       fixed bin(17,0)          dcl 1444 in procedure "mrds_dsl_optimize" set ref
                                                                                  608* 609 611 613 614* 614 619 621 622 623* 623 673
                                                                                  676 677 678* 678 687 690 691* 691 712* 713 715 717
                                                                                  718* 718 721 723 724 725* 725 775 780* 780 781
top_of_path                            parameter       pointer                  dcl 1120 ref 1110 1132
tup_var                   2            based           structure                array level 2 dcl 10-5
tuple                     2            based           structure                array level 2 dcl 12-10
tuple_id                  4            based           bit(36)                  array level 3 dcl 12-10 set ref 530
tuple_info                             based           structure                level 1 dcl 12-10
tuple_info_index                       based           fixed bin(17,0)          level 2 dcl 15-129 set ref 529*
tuple_ptr                 2            based           pointer                  array level 3 dcl 12-10 ref 1376
type                      6            based           fixed bin(3,0)           array level 3 in structure "scalfn" packed packed
                                                                                  unaligned dcl 9-35 in procedure
                                                                                  "mrds_dsl_optimize" set ref 1363 1365
type                                   based           fixed bin(17,0)          level 2 in structure "pred_array" dcl 8-29
                                                                                  in procedure "mrds_dsl_optimize" set ref 818*
type                      2            based           fixed bin(3,0)           array level 3 in structure "expr" packed packed
                                                                                  unaligned dcl 9-11 in procedure
                                                                                  "mrds_dsl_optimize" set ref 1342
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 21-17 in procedure
                                                                                  "mrds_dsl_optimize" set ref 1402*
type                                   based           fixed bin(17,0)          level 2 in structure "pred_node" dcl 8-12
                                                                                  in procedure "mrds_dsl_optimize" set ref 653* 653*
                                                                                  741* 1233 1270
type                      1            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 4-9 in procedure
                                                                                  "mrds_dsl_optimize" set ref 535*
type                      6            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 4-9 in procedure "mrds_dsl_optimize" set ref
                                                                                  542*
unspec                                                 builtin function         dcl 1516 set ref 915* 1095* 1095 1104* 1104
used                                   based           bit(1)                   array level 3 packed packed unaligned dcl 10-5 ref
                                                                                  480 1166
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 21-17 set
                                                                                  ref 1410* 1410
var_count                              parameter       fixed bin(17,0)          dcl 1122 in procedure "count_path_len_and_set_flags"
                                                                                  set ref 1110 1135* 1135
var_count                       000147 automatic       fixed bin(17,0)          dcl 1507 in procedure "mrds_dsl_optimize" set ref
                                                                                  904* 917*
var_ind                   3            based           fixed bin(17,0)          array level 3 dcl 15-66 set ref 447* 473* 549* 549*
                                                                                  567* 567*
var_index                 5            based           fixed bin(17,0)          array level 3 in structure "tuple_info" dcl 12-10
                                                                                  in procedure "mrds_dsl_optimize" ref 527
var_index                              based           fixed bin(17,0)          array level 2 in structure "size_array" dcl 1470
                                                                                  in procedure "mrds_dsl_optimize" set ref 400* 418
                                                                                  420* 420 421* 527 549 587
var_index                              based           fixed bin(17,0)          level 2 in structure "path_var" dcl 16-73
                                                                                  in procedure "mrds_dsl_optimize" ref 962 1136 1178
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 2-21
                                                                                  in procedure "mrds_dsl_optimize" set ref 515*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 22-16
                                                                                  in procedure "mrds_dsl_optimize" set ref 1387*
version                                based           fixed bin(35,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 4-9 in procedure "mrds_dsl_optimize" set ref
                                                                                  534*
vi                              000360 automatic       fixed bin(17,0)          dcl 374 set ref 418* 421
whole_tuple_selected                   based           bit(1)                   array level 3 packed packed unaligned dcl 10-5 ref
                                                                                  1379
wkspc1                          000134 automatic       fixed bin(71,0)          array dcl 1473 set ref 388
x                               000170 automatic       fixed bin(17,0)          dcl 1540 set ref 941* 945 946* 946 953* 953 954 983
y                               000171 automatic       fixed bin(17,0)          dcl 1540 set ref 962* 963 965 983
z                               000172 automatic       fixed bin(17,0)          dcl 1540 set ref 585* 587 594* 594* 954* 956 983*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 5-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 5-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 5-22
ADD                                    internal static fixed bin(17,0)          initial dcl 9-59
ALL_OP                                 internal static bit(6)                   initial packed unaligned dcl 8-44
ALL_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 3-8
ATTR                                   internal static fixed bin(17,0)          initial dcl 8-56
CFLTD59                                internal static bit(36)                  initial dcl 9-70
CONST                                  internal static fixed bin(17,0)          initial dcl 8-56
CURRENT_OP                             internal static bit(6)                   initial packed unaligned dcl 8-44
DATA                                   internal static fixed bin(17,0)          initial dcl 9-59
DATABASE                               internal static fixed bin(17,0)          initial dcl 9-59
DIV                                    internal static fixed bin(17,0)          initial dcl 9-59
EQ_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
EXPRES                                 internal static fixed bin(17,0)          initial dcl 8-56
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 21-43
GE_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
GT_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 3-8
LEAF                                   internal static fixed bin(17,0)          initial dcl 8-60
LE_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
LITERAL                                internal static fixed bin(17,0)          initial dcl 9-59
LT_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
MOVE                                   internal static fixed bin(17,0)          initial dcl 15-85
MULT                                   internal static fixed bin(17,0)          initial dcl 9-59
NE_OP                                  internal static bit(6)                   initial packed unaligned dcl 8-44
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 5-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 21-43
OPERATOR                               internal static fixed bin(17,0)          initial dcl 9-59
ORDERED_SEQUENTIAL                     internal static fixed bin(17,0)          initial dcl 16-128
OTT_EQ                                 internal static fixed bin(17,0)          initial dcl 16-174
OTT_GE                                 internal static fixed bin(17,0)          initial dcl 16-174
OTT_GT                                 internal static fixed bin(17,0)          initial dcl 16-174
OTT_LE                                 internal static fixed bin(17,0)          initial dcl 16-174
OTT_LT                                 internal static fixed bin(17,0)          initial dcl 16-174
OTT_NE                                 internal static fixed bin(17,0)          initial dcl 16-174
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 5-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 5-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 5-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 5-22
RFLTD59                                internal static bit(36)                  initial dcl 9-72
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 5-22
SUBT                                   internal static fixed bin(17,0)          initial dcl 9-59
UNORDERED_SEQUENTIAL                   internal static fixed bin(17,0)          initial dcl 16-128
V_C                                    internal static fixed bin(5,0)           initial dcl 8-64
V_V                                    internal static fixed bin(5,0)           initial dcl 8-64
al_nattr_init                          automatic       fixed bin(17,0)          dcl 16-144
al_ptr                                 automatic       pointer                  dcl 18-13
alp                                    automatic       pointer                  dcl 16-143
arg_list                               based           structure                level 1 unaligned dcl 18-6
attr_list                              based           structure                level 1 dcl 16-135
condp                                  automatic       pointer                  dcl 16-153
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 23-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 23-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 23-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 23-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 23-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 23-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 23-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 23-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 23-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 23-62
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 2-27
el_nexprs_init                         automatic       fixed bin(17,0)          dcl 16-164
elp                                    automatic       pointer                  dcl 16-163
expr_list                              based           structure                level 1 dcl 16-155
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 21-24
general_typed_vector_ptr               automatic       pointer                  dcl 21-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 21-40
max_file_init                          automatic       fixed bin(17,0)          dcl 1-58
mi_nitems_init                         automatic       fixed bin(17,0)          dcl 15-121
mi_ptr                                 automatic       pointer                  dcl 15-120
model_area                             based           area                     dcl 19-16
model_seg                              based           structure                level 1 dcl 19-9
module                                 internal static structure                level 1 unaligned dcl 23-91
move_info                              based           structure                level 1 dcl 15-98
move_list_array                        based           structure                array level 1 unaligned dcl 11-40
natts_init                             automatic       fixed bin(17,0)          dcl 17-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 17-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 17-157
pl_ptr                                 automatic       pointer                  dcl 8-84
rel                                                    builtin function         dcl 1516
relation_numeric_specification         based           structure                level 1 dcl 4-41
rti_ptr                                automatic       pointer                  dcl 14-37
scope_info                             based           structure                level 1 dcl 1-32
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 1-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 1-61
select_area_struct                     based           structure                level 1 dcl 20-2
select_list                            based           structure                level 1 unaligned dcl 11-22
size                                                   builtin function         dcl 19-20
specification_head_ptr                 automatic       pointer                  dcl 5-18
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 1554
ta_nids                                automatic       fixed bin(17,0)          dcl 14-41
ta_ptr                                 automatic       pointer                  dcl 14-42
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 12-18
tid_array                              based           bit(36)                  array dcl 14-39

NAMES DECLARED BY EXPLICIT CONTEXT.
build_vectors                   006045 constant        entry                    internal dcl 1370 ref 580
canonize_pred                   002246 constant        entry                    internal dcl 602 ref 357
check_no_tuple_effect           005034 constant        entry                    internal dcl 1153 ref 1035
copy_expr                       005634 constant        entry                    internal dcl 1327 ref 1317 1363
copy_fun                        005732 constant        entry                    internal dcl 1348 ref 1342 1365
copy_subtree                    005423 constant        entry                    internal dcl 1239 ref 751 762
count_path_len_and_set_flags    004774 constant        entry                    internal dcl 1110 ref 917
create_search_lists             003417 constant        entry                    internal dcl 892 ref 361
cross_prod                      000531 constant        entry                    internal dcl 369 ref 353
error                           006560 constant        entry                    internal dcl 1430 ref 485 493 619 673 687 721 775
                                                                                  827 842 859 873 881 912 1029 1209 1304
exit                            000530 constant        label                    dcl 367 ref 1437
move_subtree                    005400 constant        entry                    internal dcl 1224 ref 753 755 764 766
mrds_dsl_optimize               000361 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7132        7216    6606        7142
Length     10162    6606        64         730     324           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_optimize                   553 external procedure  is an external procedure.  
cross_prod                              internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
canonize_pred                           internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
create_search_lists                     internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
count_path_len_and_set_flags            internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
check_no_tuple_effect                   internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
move_subtree                            internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
copy_subtree                         82 internal procedure  uses auto adjustable storage.  
copy_expr                            74 internal procedure  is called by several nonquick procedures.  
copy_fun                             74 internal procedure  calls itself recursively.  
build_vectors                           internal procedure  shares stack frame of external procedure mrds_dsl_optimize.  
error                                64 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
copy_expr                000100 i                           copy_expr
copy_fun                 000100 i                           copy_fun
copy_subtree             000100 sr_ptr                      copy_subtree
                         000102 cp_ptr                      copy_subtree
                         000104 p_hold                      copy_subtree
                         000106 top                         copy_subtree
                         000106 node_stack                  copy_subtree
mrds_dsl_optimize        000100 icode                       mrds_dsl_optimize
                         000101 top                         mrds_dsl_optimize
                         000102 or_top                      mrds_dsl_optimize
                         000103 and_top                     mrds_dsl_optimize
                         000104 sa_nvars                    mrds_dsl_optimize
                         000105 nxchng                      mrds_dsl_optimize
                         000106 begin_and_group             mrds_dsl_optimize
                         000110 c_ptr                       mrds_dsl_optimize
                         000112 notl_ptr                    mrds_dsl_optimize
                         000114 notr_ptr                    mrds_dsl_optimize
                         000116 p_ptr                       mrds_dsl_optimize
                         000120 and_ptr                     mrds_dsl_optimize
                         000122 copy_ptr                    mrds_dsl_optimize
                         000124 sa_ptr                      mrds_dsl_optimize
                         000126 sap                         mrds_dsl_optimize
                         000130 done                        mrds_dsl_optimize
                         000131 display_predicate_tree      mrds_dsl_optimize
                         000132 display_search_paths        mrds_dsl_optimize
                         000133 sa_alloc                    mrds_dsl_optimize
                         000134 wkspc1                      mrds_dsl_optimize
                         000134 or_stack                    mrds_dsl_optimize
                         000134 and_stack                   mrds_dsl_optimize
                         000134 node_stack                  mrds_dsl_optimize
                         000144 sorted                      mrds_dsl_optimize
                         000144 search_array                mrds_dsl_optimize
                         000145 exchanged                   mrds_dsl_optimize
                         000146 spare_element               mrds_dsl_optimize
                         000147 var_count                   mrds_dsl_optimize
                         000150 min_path_first_el_ptr       mrds_dsl_optimize
                         000152 min_path_last_el_ptr        mrds_dsl_optimize
                         000154 last_el_ptr                 mrds_dsl_optimize
                         000156 pvf_ptr                     mrds_dsl_optimize
                         000160 info_ptr                    mrds_dsl_optimize
                         000162 return_value                mrds_dsl_optimize
                         000164 temp_pvp                    mrds_dsl_optimize
                         000166 temp_rmri_ptr               mrds_dsl_optimize
                         000170 x                           mrds_dsl_optimize
                         000171 y                           mrds_dsl_optimize
                         000172 z                           mrds_dsl_optimize
                         000174 path_var_pointer_array      mrds_dsl_optimize
                         000174 rel_name                    mrds_dsl_optimize
                         000204 attr_name                   mrds_dsl_optimize
                         000214 saved_access_method         mrds_dsl_optimize
                         000215 non_null_and_groups         mrds_dsl_optimize
                         000216 current_max_tids_per_call   mrds_dsl_optimize
                         000220 current_scope_ptr           mrds_dsl_optimize
                         000222 scope_ptr                   mrds_dsl_optimize
                         000224 element_id_list_ptr         mrds_dsl_optimize
                         000226 ELEMENT_ID_LIST_VERSION_1   mrds_dsl_optimize
                         000230 relation_search_specification_ptr
                                                            mrds_dsl_optimize
                         000232 relation_numeric_specification_ptr
                                                            mrds_dsl_optimize
                         000234 rss_number_of_and_groups    mrds_dsl_optimize
                         000235 rss_maximum_number_of_constraints
                                                            mrds_dsl_optimize
                         000236 rdbi_ptr                    mrds_dsl_optimize
                         000240 pn_ptr                      mrds_dsl_optimize
                         000242 ag_ptr                      mrds_dsl_optimize
                         000244 num_ands_init               mrds_dsl_optimize
                         000245 num_terms_init              mrds_dsl_optimize
                         000246 expr_ptr                    mrds_dsl_optimize
                         000250 nexp_items_init             mrds_dsl_optimize
                         000252 sfn_ptr                     mrds_dsl_optimize
                         000254 nsf_args_init               mrds_dsl_optimize
                         000256 range_ptr                   mrds_dsl_optimize
                         000260 select_list_ptr             mrds_dsl_optimize
                         000262 ti_ptr                      mrds_dsl_optimize
                         000264 sv_ptr                      mrds_dsl_optimize
                         000266 sv_nvars_init               mrds_dsl_optimize
                         000267 so_nops_init                mrds_dsl_optimize
                         000270 seli_ptr                    mrds_dsl_optimize
                         000272 pvp                         mrds_dsl_optimize
                         000274 rmri_ptr                    mrds_dsl_optimize
                         000276 num_ptrs                    mrds_dsl_optimize
                         000300 model_seg_ptr               mrds_dsl_optimize
                         000302 model_area_ptr              mrds_dsl_optimize
                         000304 select_area_struct_ptr      mrds_dsl_optimize
                         000306 select_area_ptr             mrds_dsl_optimize
                         000310 simple_typed_vector_ptr     mrds_dsl_optimize
                         000312 stv_number_of_dimensions    mrds_dsl_optimize
                         000314 id_list_ptr                 mrds_dsl_optimize
                         000316 il_number_of_ids            mrds_dsl_optimize
                         000320 rai_ptr                     mrds_dsl_optimize
                         000354 i                           cross_prod
                         000355 j                           cross_prod
                         000356 ii                          cross_prod
                         000357 si                          cross_prod
                         000360 vi                          cross_prod
                         000361 rvi                         cross_prod
                         000362 rni                         cross_prod
                         000363 sz                          cross_prod
                         000364 next_element_id_list_ptr    cross_prod
                         000366 retval                      cross_prod
                         000412 i                           create_search_lists
                         000413 j                           create_search_lists
                         000414 k                           create_search_lists
                         000430 path_var_ptr                count_path_len_and_set_flags
                         000440 i                           check_no_tuple_effect
                         000441 j                           check_no_tuple_effect
                         000442 good_use_found              check_no_tuple_effect
                         000443 message                     check_no_tuple_effect
                         000475 return_value                check_no_tuple_effect
                         000514 bv_idl_ptr                  build_vectors
                         000516 bv_stv_ptr                  build_vectors
                         000520 bv_ri_ptr                   build_vectors
                         000522 i                           build_vectors
                         000523 k                           build_vectors

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           alloc_auto_adj      mpfx2               shorten_stack       ext_entry
int_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          mdb_display_path_$path        mdb_display_pred_tree$display_pred_tree_
mrds_dsl_gen_srch_prog        mrds_dsl_permute              mu_cursor_manager_$get        sub_err_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_and_groups     mrds_data_$max_and_terms      mrds_data_$max_attributes     mrds_data_$max_id_len
mrds_data_$max_pred_depth     mrds_data_$max_safe_tids_returned_per_call
mrds_data_$max_tids_returned_per_call                       mrds_data_$max_tup_var        mrds_debug_$switch
mrds_error_$max_and_groups    mrds_error_$max_and_terms     mrds_error_$no_tuple_effect   mrds_error_$node_stack_ovfl
mrds_error_$tuple_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000354      1467 000366      1468 000374      1469 000402      1474 000410      1535 000420      1536 000422
   1541 000423    1   59 000431    2   28 000433    4   50 000435    4   52 000440   11   38 000442   19   13 000443
19   18 000444   20    6 000445   20   10 000446   22   21 000447   22   22 000450   24   65 000452       339 000454
    340 000460       341 000464       342 000465       343 000472       344 000475       345 000477       347 000501
    348 000503       349 000504       350 000506       351 000507       352 000512       353 000514       354 000515
    357 000516       359 000517       361 000525       365 000526       367 000530       369 000531       387 000532
    388 000534       391 000541       394 000547       397 000551       398 000553       400 000563       401 000570
    402 000632       404 000636       406 000640       408 000646       409 000650       410 000657       411 000660
    416 000667       417 000676       418 000677       419 000701       420 000703       421 000705       422 000707
    423 000711       425 000712       426 000714       435 000717       441 000723       442 000725       444 000737
    445 000741       446 000742       447 000744       451 000750       453 000752       456 000753       457 000760
    458 000762       459 000764       460 000767       463 001012       464 001016       470 001030       471 001032
    472 001034       473 001036       474 001041       475 001043       476 001062       478 001066       480 001075
    482 001142       485 001221       487 001230       490 001311       493 001352       495 001362       497 001416
    498 001421       500 001425       501 001436       509 001451       510 001467       511 001504       514 001513
    515 001515       516 001517       517 001520       518 001523       521 001525       522 001534       525 001541
    526 001546       527 001550       528 001571       529 001573       530 001575       531 001601       532 001602
    533 001603       534 001625       535 001627       536 001631       537 001633       538 001635       540 001640
    542 001642       543 001644       544 001646       545 001650       546 001652       547 001654       548 001664
    549 001671       551 001677       552 001701       553 001702       554 001707       555 001714       556 001716
    558 001717       559 001721       562 001723       563 001725       564 001732       565 001735       566 001745
    567 001752       572 001757       573 001761       580 001765       582 001766       584 001774       585 002010
    587 002017       589 002024       592 002154       594 002165       596 002232       597 002234       600 002245
    602 002246       608 002247       609 002251       611 002257       613 002262       614 002266       616 002270
    619 002277       621 002312       622 002317       623 002323       625 002325       627 002326       629 002330
    630 002332       633 002347       638 002356       640 002363       642 002365       646 002372       653 002377
    655 002402       657 002406       665 002423       667 002426       668 002431       670 002434       671 002436
    673 002440       676 002453       677 002457       678 002462       680 002464       682 002465       686 002467
    687 002471       690 002504       691 002511       695 002512       696 002516       697 002521       698 002524
    699 002525       702 002535       707 002537       712 002540       713 002542       715 002550       717 002552
    718 002556       720 002560       721 002563       723 002576       724 002603       725 002607       728 002611
    731 002626       732 002627       733 002630       735 002631       737 002634       741 002641       742 002643
    743 002645       744 002647       745 002651       746 002652       747 002655       749 002657       751 002663
    753 002675       754 002711       755 002714       756 002730       758 002733       762 002734       764 002746
    765 002762       766 002765       767 003001       775 003004       780 003017       781 003020       782 003025
    783 003030       785 003033       786 003034       788 003036       789 003045       791 003053       795 003054
    803 003055       810 003111       811 003113       813 003121       814 003124       818 003136       819 003140
    821 003141       823 003144       824 003150       826 003152       827 003155       829 003173       830 003177
    831 003201       837 003212       838 003214       839 003223       841 003224       842 003230       844 003243
    845 003250       846 003254       847 003256       851 003257       852 003262       856 003273       858 003274
    859 003300       861 003312       863 003321       864 003323       865 003326       867 003332       869 003334
    870 003340       872 003342       873 003345       875 003360       876 003361       877 003365       881 003366
    883 003401       884 003403       885 003411       887 003414       889 003415       890 003416       892 003417
    898 003420       900 003427       902 003434       904 003443       905 003444       906 003452       911 003453
    912 003475       914 003505       915 003512       917 003517       919 003552       921 003554       924 003556
    925 003560       926 003574       927 003606       929 003622       934 003630       936 003650       941 003667
    942 003671       945 003700       946 003705       948 003706       953 003711       954 003713       956 003721
    958 003725       962 003731       963 003733       965 003776       968 004073       973 004077       974 004100
    975 004107       976 004112       978 004113       983 004115       986 004157       993 004205       995 004214
    998 004235      1004 004264      1007 004270      1011 004304      1014 004341      1021 004402      1025 004406
   1027 004411      1029 004434      1031 004444      1033 004446      1035 004467      1036 004470      1041 004476
   1042 004477      1043 004501      1044 004506      1046 004510      1048 004511      1050 004521      1052 004530
   1053 004537      1054 004544      1056 004551      1058 004553      1060 004555      1062 004562      1064 004570
   1065 004572      1076 004573      1077 004574      1078 004575      1079 004607      1080 004614      1081 004622
   1083 004623      1084 004625      1085 004626      1088 004640      1089 004642      1090 004643      1091 004655
   1092 004662      1093 004664      1094 004677      1095 004700      1097 004723      1098 004725      1100 004740
   1102 004743      1103 004745      1104 004746      1108 004773      1110 004774      1132 005000      1134 005004
   1135 005010      1136 005012      1138 005026      1139 005030      1140 005032      1143 005033      1153 005034
   1220 005035      1163 005036      1164 005037      1166 005047      1171 005114      1172 005115      1174 005127
   1178 005142      1184 005152      1186 005156      1191 005160      1193 005162      1196 005174      1198 005315
   1202 005316      1206 005320      1208 005325      1209 005370      1222 005377      1224 005400      1232 005402
   1233 005405      1235 005415      1237 005421      1239 005422      1250 005430      1256 005435      1257 005437
   1260 005446      1261 005451      1262 005457      1264 005462      1266 005464      1267 005470      1268 005473
   1270 005475      1271 005477      1272 005501      1273 005504      1275 005505      1276 005510      1280 005517
   1281 005520      1285 005527      1286 005530      1290 005531      1294 005540      1295 005541      1299 005550
   1303 005551      1304 005553      1306 005566      1307 005574      1308 005577      1309 005602      1311 005605
   1315 005606      1316 005610      1317 005613      1319 005626      1323 005631      1325 005632      1327 005633
   1334 005641      1335 005646      1338 005661      1339 005673      1341 005674      1342 005705      1344 005726
   1346 005730      1348 005731      1355 005737      1356 005745      1359 005760      1360 005772      1362 005773
   1363 006005      1365 006030      1367 006042      1369 006044      1370 006045      1375 006046      1376 006055
   1377 006061      1378 006124      1379 006135      1381 006154      1382 006161      1383 006165      1385 006166
   1386 006170      1387 006200      1388 006202      1390 006241      1391 006242      1392 006251      1394 006320
   1395 006322      1397 006327      1398 006331      1400 006334      1401 006335      1402 006351      1403 006354
   1405 006413      1406 006414      1407 006423      1409 006472      1410 006473      1413 006510      1414 006512
   1416 006513      1419 006554      1428 006556      1430 006557      1436 006565      1437 006572


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
