	COMPILATION LISTING OF SEGMENT cm_put_ordered_element
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0954.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*        This module allocates space for an element according to the rules of
       10*   the Ordered Element Storage Method, then puts the element at the allocated
       11*   spot.  There are two modes of operation, with an entry for each, those
       12*   being the normal approach and the buffered approach.  In the buffered
       13*   approach, a pointer to a copy of the control interval into which the
       14*   element must be put is passed to the $buffered entry.
       15*   
       16*        An element can be put either as a single datum in the specified
       17*   control interval or as a continued datum in the specified control interval
       18*   with subsequent maximum-sized continuation datums in other control
       19*   intervals.  Each maximum-sized continuation datum effectively fills up
       20*   an entire control interval on its own.  The contents of an element is
       21*   stored byte-aligned, so if the element length in bits does not correspond
       22*   to an integral number of bytes, the last byte is padded with enough extra
       23*   bits to make the total length correspond to an integral number of bytes.
       24*   In the multi-datum element case, this means that the last maximum-sized
       25*   datum may be slightly less than the maximum (up to 8 bits) size in bits.
       26*   The maximum size of a datum is MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
       27*   (declared in dm_cm_datum_constants.incl.pl1).
       28*
       29*        The Ordered Element Storage Method requires that the first datum
       30*   (either the whole element or the first datum of a multi-datum element) be
       31*   put in the specified control interval.  If there is not enough room in that
       32*   control interval for the first datum, the code dm_error_$long_element is
       33*   return along with total amount of free space in bits in the control
       34*   interval, not including the space required for the datum slot and the datum
       35*   header.  The caller can use this information in determining how much space
       36*   must be freed in the control interval before the datum will fit.
       37*   
       38*        The Ordered Element Storage Method also requires that the element uses
       39*   the specified datum slot.  If that slot is already in use, it and all
       40*   following slots are shifted one slot to the right.  If the specified slot
       41*   is more than one slot past the last slot, the intervening slots are
       42*   initialized as free slots, but are counted in the number_of_datums for the
       43*   control interval.
       44*   
       45*        The parameters are:
       46*   
       47*   p_cm_info_ptr - points to collection opening info set up by the caller.
       48*   p_bci_header_ptr - only in the normal entry, points to a copy of
       49*             bci_header local to the caller.  On output it will be filled with
       50*             the contents of the bci_header of the control interval in which
       51*             the element is pout.
       52*   p_ci_buffer_ptr - only in the buffered entry, points to the control
       53*             interval buffer set up by the caller.  This routine modifies the
       54*             contents of this control interval buffer, not the file copy of
       55*             the control interval, so the caller must be prepared to write the
       56*             entire buffer into the file.  If the element is stored as a
       57*             multi-datum element, only the first datum is in  this control
       58*             interval buffer; the rest are stored in other control intervals
       59*             by modifying the file copy of each control interval.
       60*   p_element_length - is the length of the element is bits.
       61*   p_element_ptr - points to the element to be put.
       62*   p_element_id - is the identifier the element is to have.  It contains a
       63*             control interval id and a slot index.  This is how the caller
       64*             specifies the control interval in which the element is to be put
       65*             and the slot which it should use.
       66*   p_free_space - is the total amount of free space in bits in the control
       67*             interval, not including the datum slot and datum header, but
       68*             including the datum contents if successfully put.
       69*   p_code - is a status code. It is dm_error_$long_element if there is not
       70*             enough room in the control interval for the first datum of the
       71*             element.
       72**/
       73 
       74 /* HISTORY:
       75*Written by Matthew C Pierret.
       76*Modified:
       77*04/09/82 by Lindsey Spratt: Changed to use the dm_element_id include file.
       78*	  Now uses the "local" element_id_string/element_id consistently.
       79*04/13/82 by Matthew Pierret: Fixed to set p_element_id before returning.
       80*04/14/82 by Matthew Pierret: Changed to accept slot index greater than the
       81*            the current number of datums + 1. Use cm_get_datum_slots instead
       82*            of cm_get_slot_table and cm_put_datum_slots instead of 
       83*            cm_shift_slots.
       84*04/15/82 by Matthew Pierret: Fixed some plus/minus 1 bugs and made to take
       85*            uninitialized slot space into consideration when calculating
       86*            free space.
       87*04/19/82 by Matthew Pierret: Added code to get the basic_control_interval header.
       88*04/27/82 by Matthew Pierret: Changed calling segquence of cm_compact_and_add.
       89*05/10/82 by Lindsey Spratt:  Changed division to find element_length_in_bytes
       90*	  to use a precision and scale of (35,18) rather than (17,2).  The
       91*	  length in bytes was coming out one short when the length in bits
       92*	  was not an integral multiple of the number of bits per byte.
       93*06/03/82 by Lindsey Spratt:  Changed to only shift the slots if using the free
       94*	  pool, since cm_compact_and_add does the shift when using
       95*	  compaction.
       96*06/21/82 by Matthew Pierret: Changed to use cm_compact.
       97*08/03/82 by Matthew Pierret: Changed to use cm_get_bci_header.
       98*10/27/82 by Lindsey Spratt:  Changed to set the
       99*	  automatic_datum_slot.offset_in_bytes to FREE_SLOT before calling
      100*	  cm_put_datum_in_pool.
      101*11/09/82 by Matthew Pierret: Changed to calculate p_free_space which is the
      102*            total number of free bits left in the control interval after
      103*            successfully allocating the element, or the number of extra bits
      104*            needed if the element would not fit.
      105*            Changed to use cm_determine_free_space and to support multi-datum
      106*            elements.
      107*11/22/82 by Matthew Pierret:  Changed to properly initialize datum slot.
      108*01/07/83 by Matthew Pierret:  Added $buffered entry.  Qualified all references
      109*            to bci_header with the pointer ci_buffer_or_ci_header_ptr. This is
      110*            because the normal entry takes a pointer to a bci_header structure
      111*            (p_bci_header_ptr), while $buffered entry takes a pointer to the
      112*            base of a buffered control interval (p_ci_buffer_ptr).
      113*            ci_buffer_or_ci_header_ptr is given the value of one of these 
      114*            parameters to make it clear that bci_header can be referencing an
      115*            automatic header or an actual buffered ci.
      116*01/11/83 by Lindsey Spratt (for Matthew Pierret):  Fixed to set the
      117*	  datum_contents_length_in_bits based on whether the element is
      118*	  continued or not.  Also fixed to set dm_error_$long_element if the
      119*	  total_free_bytes*BITS_PER_BYTE is less than the
      120*	  datum_contents_length_in_bits, rather than "less than or equal to".
      121*01/18/83 by Matthew Pierret: Fixed references to basic_control_interval that
      122*            were not qualified with a locator.
      123*            Added call to cm_compact$buffered_replacement, 
      124*            cm_put_datum_in_pool$buffered("" _continued).
      125*            Fixed bug in determination of whether slots should be shifted in
      126*            the buffered case. If element_id.index = number_of_datums, the
      127*            last datum should be shifted, but was not.
      128*01/31/83 by Lindsey Spratt:  Fixed to not increment the
      129*	  bci_header.number_of_datums when there is not enough room in the
      130*	  CI for the new element.  Also fixed to use cm_compact$buffered
      131*	  rather than $buffered_replacement, so that the task of moving
      132*	  slots to the right is done by cm_compact rather than before
      133*	  calling cm_compact (when necessary).  The old behavior caused
      134*	  datum contents to be overwritten by the last datum_slot when the
      135*	  start_of_used_space was immediately after the datum_position_table
      136*	  (before the addition of the new slot).
      137*	       Changed to set new_last_slot_idx, rather than
      138*	  basic_control_interval.number_of_datums, as this made the
      139*	  basic_control_interval inconsistent.  bci.nod is now only set to
      140*	  new_last_slot_idx when appropriate.
      141*02/03/83 by Matthew Pierret: Upgraded to CM_INFO_VERSION_2.
      142*08/04/83 by Matthew Pierret: Changed to use 
      143*            cm_determine_free_space$does_new_datum_fit.  This entry takes into
      144*            account the fact that the datum also needs space for a new datum 
      145*            slot and possibly datum header space, returning flags indicating
      146*            whether the datum can fit in the ci and in the pool.  Also returned
      147*            is amount of space left in the ci.  Added an ERROR_RETURN
      148*            routine and the forced all error returns to go through it.
      149*            Added verification to see if the calculated datum contents length
      150*            differs from the actual number of bits left after allocating an
      151*            overlength tail.
      152*            Changed to always return -1 for p_free_space if the allocation
      153*            fails for any reason other than a lack of space 
      154*            (dm_error_$long_element).
      155*09/25/84 by Matthew Pierret:  Changed to correctly calculate the length of
      156*            the first datum rather than rely on cm_put_overlength_tail to do
      157*            so.  Added BITS_TO_BYTES conversion function which uses a slightly
      158*            optimized conversion algorithm. Changed to use datum_slot_ptr 
      159*            instead of addr (automatic_datum_slot).  Changed automatic_*
      160*            to my_=.  Changed to use a my_ci_parts structure instead of
      161*            using a fixed bin (71) array buffer.
      162*01/04/85 by Matthew C. Pierret:  Added must_be_zero elment to my_ci_parts.
      163**/
      164 
      165 
      166 /* format: style2,ind3 */
      167 /* format: ^indblkcom,indcomtxt */
      168 /* ADD AFTER AUDIT IS DONE: ll79,^indnoniterdo,^indprocbody */
      169 
      170 cm_put_ordered_element:
      171    proc (p_cm_info_ptr, p_bci_header_ptr, p_element_length, p_element_ptr, p_element_id, p_free_space, p_code);
      172 
      173 /* START OF DECLARATIONS */
      174 /* Parameter */
      175 
      176       dcl	    p_cm_info_ptr	       ptr;
      177       dcl	    p_ci_buffer_ptr	       ptr;
      178       dcl	    p_bci_header_ptr       ptr;
      179       dcl	    p_element_length       fixed bin (35);
      180       dcl	    p_element_ptr	       ptr;
      181       dcl	    p_element_id	       bit (36) aligned;
      182       dcl	    p_free_space	       fixed bin (35);
      183       dcl	    p_code	       fixed bin (35);
      184 
      185 /* Automatic */
      186 
      187       dcl	    1 my_ci_parts	       aligned,
      188 	      2 number_of_parts    fixed bin init (1),
      189 	      2 must_be_zero       fixed bin init (0),
      190 	      2 part	       (1) like ci_parts.part;
      191       dcl	    1 my_datum_slot	       aligned like datum_slot;
      192       dcl	    1 datum_slot_table     (1024) aligned like datum_slot;
      193 
      194       dcl	    code		       fixed bin (35);
      195       dcl	    continuation	       bit (36) aligned init ("0"b);
      196 
      197       dcl	    (datum_contents_length_in_bytes, number_of_slots, previous_last_slot_idx, new_last_slot_idx, slot_idx,
      198 	    uninitialized_slot_space)
      199 			       fixed bin (17) init (0);
      200       dcl	    (datum_contents_length_in_bits, unallocated_element_length_in_bits, total_free_bytes)
      201 			       fixed bin (35) init (0);
      202 
      203       dcl	    (is_buffered, is_continued, must_shift_slots_to_the_right, must_initialize_slots_to_the_left, fits_in_ci,
      204 	    fits_in_pool)	       bit (1) aligned init ("0"b);
      205 
      206       dcl	    ci_buffer_or_ci_header_ptr
      207 			       ptr;
      208 
      209 /* Based */
      210 /* Builtin */
      211 
      212       dcl	    (abs, ceil, divide, addr, max, mod, null, size, string, unspec)
      213 			       builtin;
      214 
      215 /* Controlled */
      216 /* Constant */
      217 
      218       dcl	    myname	       init ("cm_put_ordered_element") char (32) varying internal static options (constant);
      219       dcl	    BYTES_PER_WORD	       init (4) fixed bin int static options (constant);
      220       dcl	    BITS_PER_BYTE	       init (9) fixed bin int static options (constant);
      221       dcl	    IS_NOT_A_CONTINUATION  init ("0"b) bit (1) aligned internal static options (constant);
      222 
      223 /* Entry */
      224 
      225       dcl	    file_manager_$get      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35));
      226       dcl	    file_manager_$put      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35));
      227       dcl	    sub_err_	       entry () options (variable);
      228 
      229 /* External */
      230 
      231       dcl	    (
      232 	    dm_error_$long_element,
      233 	    dm_error_$programming_error,
      234 	    error_table_$unimplemented_version
      235 	    )		       ext fixed bin (35);
      236 
      237 /* END OF DECLARATIONS */
      238 
      239 
      240 
      241       ci_buffer_or_ci_header_ptr = p_bci_header_ptr;
      242       goto JOIN;
      243 
      244 
      245 buffered:
      246    entry (p_cm_info_ptr, p_ci_buffer_ptr, p_element_length, p_element_ptr, p_element_id, p_free_space, p_code);
      247 
      248       is_buffered = "1"b;
      249       ci_buffer_or_ci_header_ptr = p_ci_buffer_ptr;
      250       goto JOIN;
      251 
      252 
      253 
      254 JOIN:
      255       p_code, code = 0;
      256       p_free_space = -1;
      257       bci_header_ptr, basic_control_interval_ptr = null;
      258 
      259       cm_info_ptr = p_cm_info_ptr;
      260       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      261 
      262       element_id_string = p_element_id;
      263 
      264       if ^is_buffered
      265       then
      266          do;
      267 	  call cm_get_bci_header (cm_info.file_oid, (element_id.control_interval_id), ci_buffer_or_ci_header_ptr, code);
      268 	  if code ^= 0
      269 	  then call ERROR_RETURN (code);
      270          end;
      271 
      272       if p_element_length > MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
      273       then
      274          do;
      275 	  is_continued = "1"b;
      276 	  datum_contents_length_in_bytes =
      277 	       BITS_TO_BYTES (mod (p_element_length, MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS));
      278 	  datum_contents_length_in_bits = datum_contents_length_in_bytes * BITS_PER_BYTE;
      279          end;
      280       else
      281          do;
      282 	  is_continued = "0"b;
      283 	  datum_contents_length_in_bits = p_element_length;
      284 	  datum_contents_length_in_bytes = BITS_TO_BYTES (datum_contents_length_in_bits);
      285          end;
      286 
      287 /**** Determine whether a) the requested slot is in the middle of the slot
      288*      array or b) the requested slot is beyond the end of the slot array. */
      289 
      290       if is_buffered
      291       then
      292          do;
      293 	  if element_id.index <= ci_buffer_or_ci_header_ptr -> basic_control_interval.header.number_of_datums
      294 	  then if unspec (ci_buffer_or_ci_header_ptr -> basic_control_interval.datum_position_table (element_id.index))
      295 		  = ""b
      296 	       then must_shift_slots_to_the_right = "0"b;
      297 	       else must_shift_slots_to_the_right = "1"b;
      298 	  else if element_id.index > ci_buffer_or_ci_header_ptr -> basic_control_interval.header.number_of_datums + 1
      299 	  then must_initialize_slots_to_the_left = "1"b;
      300 	  else must_initialize_slots_to_the_left = "0"b;
      301          end;
      302 
      303       else
      304          do;
      305 	  ci_parts_ptr = addr (my_ci_parts);
      306 	  ci_parts.part (1).local_ptr = addr (datum_slot_table);
      307 
      308 	  number_of_slots = ci_buffer_or_ci_header_ptr -> bci_header.number_of_datums - element_id.index + 1;
      309 
      310 	  if number_of_slots > 0
      311 	  then
      312 	     do;
      313 
      314 	     /*** There exist slots to the right of the requested slot.  Get those slots.
      315*		If the requested slot is not free, shift the slots one slot to the right
      316*		to make room for the new one.  Otherwise simply use the free slot without
      317*		bothering the slots to the right. */
      318 
      319 	        ci_parts.part (1).offset_in_bytes =
      320 		   BYTES_PER_WORD * (size (ci_buffer_or_ci_header_ptr -> bci_header) + element_id.index - 1);
      321 	        ci_parts.part (1).length_in_bytes = BYTES_PER_WORD * number_of_slots;
      322 
      323 	        call file_manager_$get (cm_info.file_oid, (element_id.control_interval_id), ci_parts_ptr, code);
      324 	        if code ^= 0
      325 	        then call ERROR_RETURN (code);
      326 
      327 	        if unspec (datum_slot_table (1)) = ""b
      328 	        then must_shift_slots_to_the_right = "0"b;
      329 	        else must_shift_slots_to_the_right = "1"b;
      330 	     end;
      331 	  else
      332 	     do;
      333 	        number_of_slots = element_id.index - ci_buffer_or_ci_header_ptr -> bci_header.number_of_datums - 1;
      334 	        if number_of_slots > 0
      335 	        then
      336 		 do;
      337 
      338 		 /*** The requested slot is beyond the end of the slot array.  This means that
      339*		      all slots between the current end of the array and the new slot must be
      340*		      initialized as free slots. */
      341 
      342 		    must_initialize_slots_to_the_left = "1"b;
      343 		    uninitialized_slot_space = number_of_slots * size (datum_slot) * BYTES_PER_WORD;
      344 
      345 		    ci_parts.part (1).offset_in_bytes =
      346 		         BYTES_PER_WORD
      347 		         * (size (ci_buffer_or_ci_header_ptr -> bci_header) + element_id.index - number_of_slots);
      348 		    ci_parts.part (1).length_in_bytes = BYTES_PER_WORD * number_of_slots;
      349 
      350 		    call file_manager_$get (cm_info.file_oid, (element_id.control_interval_id), ci_parts_ptr, code);
      351 		    if code ^= 0
      352 		    then call ERROR_RETURN (code);
      353 		 end;
      354 	     end;
      355          end;
      356 
      357       previous_last_slot_idx = ci_buffer_or_ci_header_ptr -> bci_header.number_of_datums;
      358 
      359       if must_shift_slots_to_the_right
      360       then new_last_slot_idx = max (element_id.index, ci_buffer_or_ci_header_ptr -> bci_header.number_of_datums + 1);
      361       else new_last_slot_idx = max (element_id.index, ci_buffer_or_ci_header_ptr -> bci_header.number_of_datums);
      362 
      363 /**** See if first datum will fit in control interval. */
      364 
      365       call cm_determine_free_space$does_new_datum_fit (ci_buffer_or_ci_header_ptr, (datum_contents_length_in_bytes),
      366 	 (element_id.index), is_continued, IS_NOT_A_CONTINUATION, fits_in_ci, fits_in_pool, total_free_bytes);
      367 
      368       if ^fits_in_ci
      369       then call ERROR_RETURN (dm_error_$long_element);
      370 
      371       if is_continued
      372       then
      373          do;
      374 
      375          /*** This is an overlength element requiring more than one datum to store.
      376*	    Store maximum-sized chunks of the element in newly allocated control
      377*	    intervals from right to left, until only a single datum is left. */
      378 
      379 	  unallocated_element_length_in_bits = p_element_length;
      380 	  call cm_put_overlength_tail (cm_info_ptr, p_element_ptr, unallocated_element_length_in_bits, continuation,
      381 	       code);
      382 	  if code ^= 0
      383 	  then call ERROR_RETURN (code);
      384 
      385 	  if unallocated_element_length_in_bits ^= datum_contents_length_in_bits
      386 	  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      387 		  "^/^a^/^d ^a ^d ^a^/^a", "The calculated length of the first datum of an multi-datum element is",
      388 		  datum_contents_length_in_bits, "bits; after all but the first datum were put",
      389 		  unallocated_element_length_in_bits, "bits remain.", "The two should be equal.");
      390 
      391 	  datum_contents_length_in_bits = unallocated_element_length_in_bits;
      392 	  datum_contents_length_in_bytes = BITS_TO_BYTES (datum_contents_length_in_bits);
      393          end;
      394 
      395       if ^fits_in_pool
      396       then
      397 DATUM_FITS_IN_CI_BUT_NOT_IN_POOL:
      398          do;
      399 	  if is_buffered
      400 	  then call cm_compact$buffered (ci_buffer_or_ci_header_ptr, new_last_slot_idx, element_id_string, code);
      401 	  else call cm_compact (cm_info.file_oid, new_last_slot_idx, element_id_string, ci_buffer_or_ci_header_ptr,
      402 		  code);
      403 	  if code ^= 0
      404 	  then call ERROR_RETURN (code);
      405 
      406 	  ci_buffer_or_ci_header_ptr -> basic_control_interval.number_of_datums = new_last_slot_idx;
      407          end DATUM_FITS_IN_CI_BUT_NOT_IN_POOL;
      408       else
      409 DATUM_FITS_IN_POOL:
      410          do;					/* datum_contents_length_in_bytes <= pool_free_bytes */
      411 	  ci_buffer_or_ci_header_ptr -> basic_control_interval.number_of_datums = new_last_slot_idx;
      412 
      413 	  if (must_shift_slots_to_the_right | must_initialize_slots_to_the_left)
      414 	  then
      415 	     do;
      416 	        if is_buffered
      417 	        then
      418 		 do;
      419 		    if must_shift_slots_to_the_right
      420 		    then
      421 		       do slot_idx = ci_buffer_or_ci_header_ptr -> basic_control_interval.header.number_of_datums
      422 			  to element_id.index + 1 by -1;
      423 			ci_buffer_or_ci_header_ptr -> basic_control_interval.datum_position_table (slot_idx) =
      424 			     ci_buffer_or_ci_header_ptr
      425 			     -> basic_control_interval.datum_position_table (slot_idx - 1);
      426 		       end;
      427 		    else if must_initialize_slots_to_the_left
      428 		    then
      429 		       do slot_idx = ci_buffer_or_ci_header_ptr -> basic_control_interval.header.number_of_datums - 1
      430 			  to previous_last_slot_idx by -1;
      431 			unspec (ci_buffer_or_ci_header_ptr
      432 			     -> basic_control_interval.datum_position_table (slot_idx)) = "0"b;
      433 		       end;
      434 		 end;
      435 	        else /* not buffered, datum_contents_length_in_bytes <= pool_free_bytes, and mssttr or misttl */
      436 		 do;
      437 		    if must_shift_slots_to_the_right
      438 		    then ci_parts.part (1).offset_in_bytes = ci_parts.part (1).offset_in_bytes + BYTES_PER_WORD;
      439 
      440 		    call file_manager_$put (cm_info.file_oid, (element_id.control_interval_id), ci_parts_ptr, code);
      441 
      442 		    if code ^= 0
      443 		    then call ERROR_RETURN (code);
      444 		 end;
      445 	     end;
      446          end DATUM_FITS_IN_POOL;
      447 
      448 /* Initialize datum_slot */
      449 
      450       if is_buffered
      451       then datum_slot_ptr =
      452 	      addr (ci_buffer_or_ci_header_ptr -> basic_control_interval.datum_position_table (element_id.index));
      453       else datum_slot_ptr = addr (my_datum_slot);
      454 
      455       unspec (datum_slot) = ""b;
      456 
      457 /* Put new datum in the control interval's free pool */
      458 
      459       if is_buffered
      460       then if is_continued
      461 	 then call cm_put_datum_in_pool$buffered_continued (ci_buffer_or_ci_header_ptr, p_element_ptr,
      462 		 datum_contents_length_in_bits, datum_slot_ptr, p_element_length, continuation, code);
      463 	 else call cm_put_datum_in_pool$buffered (ci_buffer_or_ci_header_ptr, p_element_ptr,
      464 		 datum_contents_length_in_bits, datum_slot_ptr, code);
      465 
      466       else if is_continued
      467       then call cm_put_datum_in_pool$continued (cm_info.file_oid, element_id_string, p_element_ptr,
      468 	      datum_contents_length_in_bits, datum_slot_ptr, ci_buffer_or_ci_header_ptr, p_element_length, continuation,
      469 	      code);
      470       else call cm_put_datum_in_pool (cm_info.file_oid, element_id_string, p_element_ptr, datum_contents_length_in_bits,
      471 	      datum_slot_ptr, ci_buffer_or_ci_header_ptr, code);
      472 
      473 
      474       p_element_id = element_id_string;
      475       call FINISH ();
      476 MAIN_RETURN:
      477       return;
      478 
      479 
      480 
      481 ERROR_RETURN:
      482    proc (er_p_code);
      483 
      484       dcl	    er_p_code	       fixed bin (35);
      485 
      486       p_code = er_p_code;
      487       call FINISH ();
      488       goto MAIN_RETURN;
      489 
      490    end ERROR_RETURN;
      491 
      492 
      493 FINISH:
      494    proc ();
      495 
      496       if p_code = 0 | p_code = dm_error_$long_element
      497       then p_free_space = total_free_bytes * BITS_PER_BYTE;
      498 
      499       return;
      500 
      501    end FINISH;
      502 
      503 CHECK_VERSION:
      504    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      505 
      506       dcl	    cv_p_structure_name    char (*);
      507       dcl	    cv_p_given_version     char (8) aligned;
      508       dcl	    cv_p_correct_version   char (8) aligned;
      509 
      510       if cv_p_given_version ^= cv_p_correct_version
      511       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      512 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", cv_p_correct_version,
      513 	      cv_p_structure_name, cv_p_given_version);
      514       else return;
      515 
      516    end CHECK_VERSION;
      517 
      518 
      519 BITS_TO_BYTES:
      520    proc (btb_p_bits) returns (fixed bin (17));
      521 
      522 /* This function takes a length in bits and returns the number of bytes
      523*   necessary to hold that many bits. The expression which figures this out
      524*   is an optimization of the expression:
      525*   ceil (divide (btb_p_bits, BITS_PER_BYTE, 35, 18)
      526**/
      527 
      528       dcl	    btb_p_bits	       fixed bin (35);
      529 
      530       return (divide (btb_p_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0));
      531 
      532    end BITS_TO_BYTES;
      533 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      534 
      535 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        The collection_manager_ manages the structure of the addressable
  2     6*   portion of a control interval.  The addressable portion is that portion of
  2     7*   a control interval which the file_manager_ will allow the
  2     8*   collection_manager_ to address.  In this description control interval will
  2     9*   be used to mean the addressable portion of a control interval.
  2    10*   
  2    11*        A control interval is divided into four parts: the header, the datum
  2    12*   position table (also known as the slot table or slots), un-used space and
  2    13*   used space.  The beginning of the header is at offset 0, and the end of the
  2    14*   used space is at the end of the control interval (curently offset 4072).
  2    15*   Pictoriarly, a control interval is structured as follows:
  2    16*   
  2    17*   ----------------------------------------------------------------------
  2    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  2    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  2    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  2    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  2    22*   ----------------------------------------------------------------------
  2    23*                                           ^ ^    ^      ^    ^  ^   ^
  2    24*                                           | |    |      |    |  |   |
  2    25*                                           | |...........|.......|...|
  2    26*                        start of used space|      |           |      |
  2    27*                                                  |           |  each|
  2    28*                                          scattered free space|  is a used
  2    29*                                                                 datum
  2    30*   
  2    31*      The basic_control_interval structure describes the header
  2    32*   (basic_control_interval.header, bci_header) and the slots
  2    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  2    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  2    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  2    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  2    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  2    38**/
  2    39 
  2    40 /* HISTORY:
  2    41*Written by Matthew Pierret, 02/07/82.
  2    42*Modified:
  2    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  2    44*            and its sub-structures.
  2    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  2    46*            basic_ci_header to bci_header. Added previous_control_interval.
  2    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  2    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  2    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  2    50*            is not used.
  2    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  2    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  2    53**/
  2    54 
  2    55 /* format: style2 */
  2    56      dcl	   1 basic_control_interval
  2    57 			      aligned based (basic_control_interval_ptr),
  2    58 	     2 header	      like bci_header,
  2    59 	     2 datum_position_table
  2    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  2    61 
  2    62 
  2    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  2    64 	     2 layout_type	      char (4) aligned,
  2    65 	     2 collection_id      bit (36) aligned,
  2    66 	     2 next_control_interval
  2    67 			      fixed bin (24) uns unal,
  2    68 	     2 previous_control_interval
  2    69 			      fixed bin (24) uns unal,
  2    70 	     2 flags	      unal,
  2    71 	       3 continuation_datum_is_present
  2    72 			      bit (1) unal,
  2    73 	       3 free_slot_is_present
  2    74 			      bit (1) unal,
  2    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  2    76 	     2 scattered_free_space
  2    77 			      fixed bin (17) unal,
  2    78 	     2 start_of_used_space
  2    79 			      fixed bin (17) unal,
  2    80 	     2 number_of_datums   fixed bin (17) unal;
  2    81 
  2    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  2    83 	     2 flags	      unal,
  2    84 	       3 special_format_datum
  2    85 			      bit (1) unal,		/* reserved */
  2    86 	       3 is_continued     bit (1) unal,
  2    87 	       3 is_continuation  bit (1) unal,
  2    88 	       3 mbz	      bit (1) unal,		/* reserved */
  2    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  2    90 	     2 length_in_bits     fixed bin (17) uns unal;
  2    91 
  2    92      dcl	   basic_control_interval_ptr
  2    93 			      ptr;
  2    94      dcl	   bci_header_ptr	      ptr;
  2    95      dcl	   datum_slot_ptr	      ptr;
  2    96 
  2    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  2    98 
  2    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      536 
      537 
  3     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        Contains constants describing the extents of datums and datum
  3     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  3     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  3     7*   datum that can be stored in a control interval, allowing for the largest
  3     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  3     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    10*   is the smallest length in bits which requires 
  3    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  3    12**/
  3    13 
  3    14 /*
  3    15*HISTORY:
  3    16*Written by Matthew Pierret, 02/07/82.
  3    17*Modified:
  3    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  3    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  3    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  3    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  3    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  3    23*            DESCRIPTION section.
  3    24**/
  3    25 
  3    26 /* format: style2,ind3,ll79 */
  3    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  3    28 			      fixed bin init (8) internal static
  3    29 			      options (constant);
  3    30 
  3    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  3    32 			      fixed bin init (72) internal static
  3    33 			      options (constant);
  3    34 
  3    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  3    36 			      init (4) fixed bin int static
  3    37 			      options (constant);
  3    38 
  3    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  3    40 			      init (36) fixed bin int static
  3    41 			      options (constant);
  3    42 
  3    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    44 			      init (36360) fixed bin (35) internal
  3    45 			      static options (constant);
  3    46 
  3    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  3    48 			      init (4040) fixed bin (35) internal
  3    49 			      static options (constant);
  3    50 
  3    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    52 			      init (36352) fixed bin (35) internal
  3    53 			      static options (constant);
  3    54 
  3    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      538 
      539 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      540 
      541 
  5     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        This include file contains the ci_parts structure.  This structure
  5     6*   is used across the file_manager_ interface to specify the parts of a
  5     7*   control interval to get or put.  If the number_of parts is equal to 0,
  5     8*   modules which take ci_parts interpret this case to mean to do everything
  5     9*   except the actual requested operation, i.e., lock the control interval
  5    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  5    11*   bytes from the beginning of the addressable portion of the control interval.
  5    12*   An offset_in_bytes which is in the addressable portion is in error.
  5    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  5    14*   portion, it is in error.
  5    15**/
  5    16 
  5    17 /* HISTORY:
  5    18*Written by Matthew Pierret, 01/28/82.
  5    19*  (01/28/82 Andre Bensoussan, Design.)
  5    20*Modified:
  5    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  5    22*            automatic storge.
  5    23**/
  5    24 
  5    25 /* format: style2,ind3 */
  5    26 
  5    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  5    28 	     2 number_of_parts    fixed bin (17),
  5    29 	     2 must_be_zero	      fixed bin,
  5    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  5    31 	       3 offset_in_bytes  fixed bin (17),
  5    32 	       3 length_in_bytes  fixed bin (17),
  5    33 	       3 local_ptr	      ptr;
  5    34 
  5    35      dcl	   ci_parts_ptr	      ptr init (null ());
  5    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  5    37 
  5    38 
  5    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      542 
      543 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      544 
      545 
  7     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*   Contains entry declarations of internally available collection_manager_
  7     6*   entries.  Entries which are only available via the collection_manager_
  7     7*   transfer vector are not included here, but are declared instead in 
  7     8*   dm_collmgr_entry_dcls.incl.pl1.
  7     9**/
  7    10 
  7    11 /* HISTORY:
  7    12*Written by Mathew Pierret, 04/01/82.
  7    13*Modified:
  7    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  7    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  7    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  7    17*            Added cm_get_element$info*, $header*.  The former is used when
  7    18*            the caller has a cm_info structure already; the latter is used to
  7    19*            get collection headers.
  7    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  7    21*            Added cm_allocate_element$info.
  7    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  7    23*            calling sequence for returning free space.
  7    24*            Added cm_free_cn_datum("" $header).
  7    25*01/07/83 by Matthew Pierret:  Added:
  7    26*            cm_allocate_element$buffered("" _info);
  7    27*            cm_put_element$buffered("" _info);
  7    28*            cm_put_datum_in_place$buffered("" _continued);
  7    29*            cm_put_datum_in_pool$buffered("" _continued);
  7    30*            cm_compact$buffered.
  7    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  7    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  7    33*            Added cm_opening_info$get_storage_record.
  7    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  7    35*            id of the previous datum.
  7    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  7    37*            which is for the number of slots after allocation.
  7    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  7    39*            header header_return_slot).
  7    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  7    41*            Added cm_get_element$bypass_info.
  7    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  7    43*            cm_free_opening_info.
  7    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  7    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  7    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  7    47*            return flags indicating if a datum fits in the ci and the pool.
  7    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  7    49*            returned the new value of bci_header.free_slot_is_present.
  7    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  7    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  7    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  7    53*            calling sequence as other cm_get_element entries.
  7    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  7    55*            and cm_allocate_element to cm_put.
  7    56*            Switched the element_length/element_ptr parameter pair to be
  7    57*            element_ptr/element_length in cm_modify and cm_put.
  7    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  7    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  7    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  7    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  7    62*            Removed cm_find_free_space. Commented out un-used entries.
  7    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  7    64*            Re-named free element and free datum entries to use delete instead
  7    65*            of free, and cm_recursive_put to cm_recursive_modify.
  7    66*            Removed cm_get_element$bypass_info.
  7    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  7    68*            that cm_modify$buffered uses it.
  7    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  7    70**/
  7    71 
  7    72 /* format: style2,ind3 */
  7    73 
  7    74 
  7    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  7    77      dcl	   cm_allocate_ci$info_header
  7    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  7    79 
  7    80 
  7    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  7    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  7    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  7    84      dcl	   cm_compact$buffered_replacement
  7    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  7    86 
  7    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    88 
  7    89      dcl	   cm_delete_cn_datum$header
  7    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    91 
  7    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    93 			      fixed bin (35));
  7    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  7    95 
  7    96      dcl	   cm_determine_free_space$all
  7    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  7    98      dcl	   cm_determine_free_space$effective
  7    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   cm_determine_free_space$does_new_datum_fit
  7   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  7   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  7   104 
  7   105 /**** Not yet used *********************************************************
  7   106*     dcl	   cm_determine_free_space$does_replacement_fit
  7   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  7   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  7   109*************************************************************************** */
  7   110 
  7   111      dcl	   cm_find_ci_to_alloc_datum
  7   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  7   113 			      fixed bin (24) uns, fixed bin (35));
  7   114 
  7   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  7   116 			      bit (1) aligned, fixed bin (35));
  7   117 
  7   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  7   119      dcl	   cm_free_ci$raw_return_prev_next
  7   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  7   121 			      fixed bin (24) uns, fixed bin (35));
  7   122      dcl	   cm_free_ci$trace_thread_modifications_on
  7   123 			      entry ();
  7   124      dcl	   cm_free_ci$trace_thread_modifications_off
  7   125 			      entry ();
  7   126 
  7   127 
  7   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7   129 
  7   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  7   131      dcl	   cm_get_bci_header$exclusive
  7   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  7   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   134 
  7   135 /**** Not yet used ********************************************************
  7   136*     dcl	   cm_get_bci_header$slot_exclusive
  7   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   138*************************************************************************** */
  7   139 
  7   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7   142      dcl	   cm_get_element$exclusive
  7   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7   145 
  7   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7   148 			      fixed bin (35), fixed bin (35));
  7   149 
  7   150 /**** Not yet used ********************************************************
  7   151*     dcl	   cm_get_element_portion$exclusive
  7   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7   154*			      fixed bin (35), fixed bin (35));
  7   155*************************************************************************** */
  7   156 
  7   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  7   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  7   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   161 
  7   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   163 			      fixed bin (35), fixed bin (35));
  7   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   165 			      fixed bin (35), fixed bin (35));
  7   166 
  7   167 /******* Not yet used *****************************************************
  7   168*     dcl	   cm_modify$buffered_info
  7   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  7   170*			      fixed bin (35));
  7   171*****************************************************************************/
  7   172 
  7   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   174      dcl	   cm_modify$unprotected_info
  7   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   176 
  7   177 
  7   178 /******* Not yet used *****************************************************
  7   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  7   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  7   181*****************************************************************************/
  7   182 
  7   183 
  7   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   185      dcl	   cm_opening_info$get_storage_record
  7   186 			      entry (ptr, fixed bin (35));
  7   187      dcl	   cm_opening_info$full_get
  7   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   189      dcl	   cm_opening_info$opening_table_ptr
  7   190 			      entry () returns (ptr);
  7   191 
  7   192      dcl	   cm_postcommit_increment
  7   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   194 
  7   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   196 			      fixed bin (35), fixed bin (35));
  7   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   198 			      fixed bin (35), fixed bin (35));
  7   199 
  7   200 /******* Not yet used *****************************************************
  7   201*     dcl	   cm_put$buffered_info
  7   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  7   203*			      fixed bin (35));
  7   204*****************************************************************************/
  7   205 
  7   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   207 
  7   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   209 			      fixed bin (35));
  7   210 
  7   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  7   212 
  7   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   214 			      fixed bin (35));
  7   215      dcl	   cm_put_datum_in_place$buffered
  7   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  7   217      dcl	   cm_put_datum_in_place$buffered_continued
  7   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  7   219 			      fixed bin (35));
  7   220      dcl	   cm_put_datum_in_place$continued
  7   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  7   223 
  7   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   225 			      fixed bin (35));
  7   226      dcl	   cm_put_datum_in_pool$buffered
  7   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  7   228      dcl	   cm_put_datum_in_pool$buffered_continued
  7   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  7   230 			      fixed bin (35));
  7   231      dcl	   cm_put_datum_in_pool$continued
  7   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  7   234 
  7   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   236 			      fixed bin (35));
  7   237      dcl	   cm_put_ordered_element$buffered
  7   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   239 			      fixed bin (35));
  7   240 
  7   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  7   242 
  7   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  7   244 			      fixed bin (35));
  7   245 
  7   246 
  7   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  7   248 			      entry ();
  7   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  7   250 			      entry ();
  7   251 
  7   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      546 
      547 
      548    end cm_put_ordered_element;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.8  cm_put_ordered_element.pl1        >spec>on>7192.pbf-04/04/85>cm_put_ordered_element.pl1
534          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
536          2    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
538          3    01/07/85  0858.2  dm_cm_datum_constants.incl.pl1    >ldd>include>dm_cm_datum_constants.incl.pl1
540          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
542          5    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
544          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
546          7    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000027 constant        bit(36)                  initial dcl 6-7 set ref 385* 510*
BITS_PER_BYTE                   001517 constant        fixed bin(17,0)          initial dcl 220 ref 278 496 530 530
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 219 ref 319 321 343 345 348 437
CM_INFO_VERSION_2               000000 constant        char(8)                  initial dcl 1-48 set ref 260*
IS_NOT_A_CONTINUATION           000026 constant        bit(1)                   initial dcl 221 set ref 365*
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                001516 constant        fixed bin(35,0)          initial dcl 3-43 ref 272 276 276
addr                                                   builtin function         dcl 212 ref 267 293 293 298 305 306 308 319 323 333
                                                                                  345 350 359 361 365 419 440 450 450 453
basic_control_interval                 based           structure                level 1 dcl 2-56
basic_control_interval_ptr      002134 automatic       pointer                  dcl 2-92 set ref 257*
bci_header                             based           structure                level 1 dcl 2-63 ref 319 345
bci_header_ptr                  002136 automatic       pointer                  dcl 2-94 set ref 257*
btb_p_bits                             parameter       fixed bin(35,0)          dcl 528 ref 519 530
ci_buffer_or_ci_header_ptr      002130 automatic       pointer                  dcl 206 set ref 241* 249* 267* 293 293 298 308 319
                                                                                  333 345 357 359 361 365* 399* 401* 406 411 419 423
                                                                                  423 427 431 450 459* 463* 466* 470*
ci_parts                               based           structure                level 1 dcl 5-27
ci_parts_ptr                    002144 automatic       pointer                  initial dcl 5-35 set ref 305* 306 319 321 323* 345
                                                                                  348 350* 437 437 440* 5-35*
cip_number_of_parts             002146 automatic       fixed bin(17,0)          initial dcl 5-36 set ref 5-36*
cm_compact                      000024 constant        entry                    external dcl 7-81 ref 401
cm_compact$buffered             000026 constant        entry                    external dcl 7-82 ref 399
cm_determine_free_space$does_new_datum_fit
                                000030 constant        entry                    external dcl 7-101 ref 365
cm_get_bci_header               000032 constant        entry                    external dcl 7-130 ref 267
cm_info                                based           structure                level 1 dcl 1-37
cm_info_ptr                     002132 automatic       pointer                  initial dcl 1-47 set ref 259* 260 267 323 350 380*
                                                                                  401 440 466 470 1-47*
cm_put_datum_in_pool            000034 constant        entry                    external dcl 7-224 ref 470
cm_put_datum_in_pool$buffered   000036 constant        entry                    external dcl 7-226 ref 463
cm_put_datum_in_pool$buffered_continued
                                000040 constant        entry                    external dcl 7-228 ref 459
cm_put_datum_in_pool$continued  000042 constant        entry                    external dcl 7-231 ref 466
cm_put_overlength_tail          000044 constant        entry                    external dcl 7-241 ref 380
code                            002107 automatic       fixed bin(35,0)          dcl 194 set ref 254* 267* 268 268* 323* 324 324*
                                                                                  350* 351 351* 380* 382 382* 399* 401* 403 403*
                                                                                  440* 442 442* 459* 463* 466* 470*
continuation                    002110 automatic       bit(36)                  initial dcl 195 set ref 195* 380* 459* 466*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-32 ref 267
                                                                                  323 350 440
cv_p_correct_version                   parameter       char(8)                  dcl 508 set ref 503 510 510*
cv_p_given_version                     parameter       char(8)                  dcl 507 set ref 503 510 510*
cv_p_structure_name                    parameter       char                     unaligned dcl 506 set ref 503 510*
datum_contents_length_in_bits   002117 automatic       fixed bin(35,0)          initial dcl 200 set ref 200* 278* 283* 284* 385 385*
                                                                                  391* 392* 459* 463* 466* 470*
datum_contents_length_in_bytes  002111 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 276* 278 284* 365 392*
datum_position_table      5            based           structure                array level 2 dcl 2-56 set ref 293 423* 423 431* 450
datum_slot                             based           structure                level 1 dcl 2-82 set ref 343 455*
datum_slot_ptr                  002140 automatic       pointer                  dcl 2-95 set ref 343 450* 453* 455 459* 463* 466*
                                                                                  470*
datum_slot_table                000107 automatic       structure                array level 1 dcl 192 set ref 306 327
divide                                                 builtin function         dcl 212 ref 530
dm_error_$long_element          000016 external static fixed bin(35,0)          dcl 231 set ref 368* 496
dm_error_$programming_error     000020 external static fixed bin(35,0)          dcl 231 set ref 385*
element_id                             based           structure                level 1 dcl 4-32
element_id_string               002142 automatic       bit(36)                  dcl 4-30 set ref 262* 267 293 293 298 308 319 323
                                                                                  333 345 350 359 361 365 399* 401* 419 440 450 466*
                                                                                  470* 474
er_p_code                              parameter       fixed bin(35,0)          dcl 484 ref 481 486
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 231 set ref 510*
file_manager_$get               000010 constant        entry                    external dcl 225 ref 323 350
file_manager_$put               000012 constant        entry                    external dcl 226 ref 440
file_oid                  3            based           bit(36)                  initial level 2 dcl 1-37 set ref 267* 323* 350* 401*
                                                                                  440* 466* 470*
fits_in_ci                      002126 automatic       bit(1)                   initial dcl 203 set ref 203* 365* 368
fits_in_pool                    002127 automatic       bit(1)                   initial dcl 203 set ref 203* 365* 395
header                                 based           structure                level 2 dcl 2-56
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 4-32 ref 293
                                                                                  293 298 308 319 333 345 359 361 365 419 450
is_buffered                     002122 automatic       bit(1)                   initial dcl 203 set ref 203* 248* 264 290 399 416
                                                                                  450 459
is_continued                    002123 automatic       bit(1)                   initial dcl 203 set ref 203* 275* 282* 365* 371 459
                                                                                  466
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 5-27 set ref 321* 348*
local_ptr                 4            based           pointer                  array level 3 dcl 5-27 set ref 306*
max                                                    builtin function         dcl 212 ref 359 361
mod                                                    builtin function         dcl 212 ref 276 276
must_be_zero              1     000100 automatic       fixed bin(17,0)          initial level 2 dcl 187 set ref 187*
must_initialize_slots_to_the_left
                                002125 automatic       bit(1)                   initial dcl 203 set ref 203* 298* 300* 342* 413 427
must_shift_slots_to_the_right   002124 automatic       bit(1)                   initial dcl 203 set ref 203* 293* 297* 327* 329* 359
                                                                                  413 419 437
my_ci_parts                     000100 automatic       structure                level 1 dcl 187 set ref 305
my_datum_slot                   000106 automatic       structure                level 1 dcl 191 set ref 453
myname                          000002 constant        varying char(32)         initial dcl 218 set ref 385* 510*
new_last_slot_idx               002114 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 359* 361* 399* 401* 406
                                                                                  411
null                                                   builtin function         dcl 212 ref 257 385 385 1-47 5-35 510 510
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 in structure "basic_control_interval" packed
                                                                                  unaligned dcl 2-56 in procedure
                                                                                  "cm_put_ordered_element" set ref 293 298 406* 411*
                                                                                  419 427
number_of_datums          4(18)        based           fixed bin(17,0)          level 2 in structure "bci_header" packed unaligned
                                                                                  dcl 2-63 in procedure "cm_put_ordered_element" ref
                                                                                  308 333 357 359 361
number_of_parts                 000100 automatic       fixed bin(17,0)          initial level 2 dcl 187 set ref 187*
number_of_slots                 002112 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 308* 310 321 333* 334
                                                                                  343 345 348
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 dcl 5-27 set ref 319* 345* 437* 437
p_bci_header_ptr                       parameter       pointer                  dcl 178 ref 170 241
p_ci_buffer_ptr                        parameter       pointer                  dcl 177 ref 245 249
p_cm_info_ptr                          parameter       pointer                  dcl 176 ref 170 245 259
p_code                                 parameter       fixed bin(35,0)          dcl 183 set ref 170 245 254* 486* 496 496
p_element_id                           parameter       bit(36)                  dcl 181 set ref 170 245 262 474*
p_element_length                       parameter       fixed bin(35,0)          dcl 179 set ref 170 245 272 276 276 283 379 459*
                                                                                  466*
p_element_ptr                          parameter       pointer                  dcl 180 set ref 170 245 380* 459* 463* 466* 470*
p_free_space                           parameter       fixed bin(35,0)          dcl 182 set ref 170 245 256* 496*
part                      2            based           structure                array level 2 dcl 5-27
previous_last_slot_idx          002113 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 357* 427
size                                                   builtin function         dcl 212 ref 319 343 345
slot_idx                        002115 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 419* 423 423* 427* 431*
sub_err_                        000014 constant        entry                    external dcl 227 ref 385 510
total_free_bytes                002121 automatic       fixed bin(35,0)          initial dcl 200 set ref 200* 365* 496
unallocated_element_length_in_bits
                                002120 automatic       fixed bin(35,0)          initial dcl 200 set ref 200* 379* 380* 385 385* 391
uninitialized_slot_space        002116 automatic       fixed bin(17,0)          initial dcl 197 set ref 197* 343*
unspec                                                 builtin function         dcl 212 set ref 293 327 431* 455*
version                                based           char(8)                  level 2 dcl 1-37 set ref 260*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 2-97
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 3-39
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      internal static fixed bin(17,0)          initial dcl 3-35
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 3-31
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 3-27
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 3-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 3-51
abs                                                    builtin function         dcl 212
ceil                                                   builtin function         dcl 212
cm_allocate_ci                  000000 constant        entry                    external dcl 7-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 7-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 7-77
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 7-84
cm_compact$replacement          000000 constant        entry                    external dcl 7-83
cm_delete                       000000 constant        entry                    external dcl 7-92
cm_delete$info                  000000 constant        entry                    external dcl 7-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 7-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 7-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 7-96
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 7-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 7-111
cm_find_free_slot               000000 constant        entry                    external dcl 7-115
cm_free_ci$info                 000000 constant        entry                    external dcl 7-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 7-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 7-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 7-122
cm_free_opening_info            000000 constant        entry                    external dcl 7-128
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 7-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 7-133
cm_get_element                  000000 constant        entry                    external dcl 7-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 7-142
cm_get_element_portion          000000 constant        entry                    external dcl 7-146
cm_get_id$id                    000000 constant        entry                    external dcl 7-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 7-159
cm_modify                       000000 constant        entry                    external dcl 7-162
cm_modify$buffered              000000 constant        entry                    external dcl 7-164
cm_modify$info                  000000 constant        entry                    external dcl 7-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 7-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 7-187
cm_opening_info$get             000000 constant        entry                    external dcl 7-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 7-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 7-189
cm_postcommit_increment         000000 constant        entry                    external dcl 7-192
cm_put                          000000 constant        entry                    external dcl 7-195
cm_put$buffered                 000000 constant        entry                    external dcl 7-197
cm_put$info                     000000 constant        entry                    external dcl 7-206
cm_put_basic_element            000000 constant        entry                    external dcl 7-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 7-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 7-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 7-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 7-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 7-220
cm_put_ordered_element          000000 constant        entry                    external dcl 7-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 7-237
cm_recursive_modify             000000 constant        entry                    external dcl 7-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 7-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 7-247
string                                                 builtin function         dcl 212

NAMES DECLARED BY EXPLICIT CONTEXT.
BITS_TO_BYTES                   001460 constant        entry                    internal dcl 519 ref 276 284 392
CHECK_VERSION                   001354 constant        entry                    internal dcl 503 ref 260
DATUM_FITS_IN_CI_BUT_NOT_IN_POOL
                                000775 constant        label                    dcl 395
DATUM_FITS_IN_POOL              001045 constant        label                    dcl 408
ERROR_RETURN                    001332 constant        entry                    internal dcl 481 ref 268 324 351 368 382 403 442
FINISH                          001341 constant        entry                    internal dcl 493 ref 475 487
JOIN                            000225 constant        label                    dcl 254 ref 242 250
MAIN_RETURN                     001331 constant        label                    dcl 476 ref 488
buffered                        000210 constant        entry                    external dcl 245
cm_put_ordered_element          000173 constant        entry                    external dcl 170

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1740        2006    1520        1750
Length      2352    1520        46         327     220           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_put_ordered_element             1326 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_put_ordered_element.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_put_ordered_element.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_put_ordered_element.  
BITS_TO_BYTES                           internal procedure  shares stack frame of external procedure cm_put_ordered_element.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_put_ordered_element   000100 my_ci_parts                 cm_put_ordered_element
                         000106 my_datum_slot               cm_put_ordered_element
                         000107 datum_slot_table            cm_put_ordered_element
                         002107 code                        cm_put_ordered_element
                         002110 continuation                cm_put_ordered_element
                         002111 datum_contents_length_in_bytes
                                                            cm_put_ordered_element
                         002112 number_of_slots             cm_put_ordered_element
                         002113 previous_last_slot_idx      cm_put_ordered_element
                         002114 new_last_slot_idx           cm_put_ordered_element
                         002115 slot_idx                    cm_put_ordered_element
                         002116 uninitialized_slot_space    cm_put_ordered_element
                         002117 datum_contents_length_in_bits
                                                            cm_put_ordered_element
                         002120 unallocated_element_length_in_bits
                                                            cm_put_ordered_element
                         002121 total_free_bytes            cm_put_ordered_element
                         002122 is_buffered                 cm_put_ordered_element
                         002123 is_continued                cm_put_ordered_element
                         002124 must_shift_slots_to_the_right
                                                            cm_put_ordered_element
                         002125 must_initialize_slots_to_the_left
                                                            cm_put_ordered_element
                         002126 fits_in_ci                  cm_put_ordered_element
                         002127 fits_in_pool                cm_put_ordered_element
                         002130 ci_buffer_or_ci_header_ptr  cm_put_ordered_element
                         002132 cm_info_ptr                 cm_put_ordered_element
                         002134 basic_control_interval_ptr  cm_put_ordered_element
                         002136 bci_header_ptr              cm_put_ordered_element
                         002140 datum_slot_ptr              cm_put_ordered_element
                         002142 element_id_string           cm_put_ordered_element
                         002144 ci_parts_ptr                cm_put_ordered_element
                         002146 cip_number_of_parts         cm_put_ordered_element

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mpfx2               mod_fx1             ext_entry
divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_compact                    cm_compact$buffered           cm_determine_free_space$does_new_datum_fit
cm_get_bci_header             cm_put_datum_in_pool          cm_put_datum_in_pool$buffered
cm_put_datum_in_pool$buffered_continued                     cm_put_datum_in_pool$continued
cm_put_overlength_tail        file_manager_$get             file_manager_$put             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$long_element        dm_error_$programming_error   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    187 000134       195 000137       197 000140       200 000146       203 000151    1   47 000157    5   35 000161
 5   36 000162       170 000165       241 000201       242 000205       245 000206       248 000216       249 000220
    250 000224       254 000225       256 000227       257 000231       259 000234       260 000237       262 000260
    264 000263       267 000265       268 000306       272 000312       275 000316       276 000320       278 000325
    279 000330       282 000331       283 000332       284 000333       290 000335       293 000337       297 000356
    298 000361       300 000367       301 000370       305 000371       306 000373       308 000375       310 000410
    319 000413       321 000420       323 000423       324 000444       327 000450       329 000454       330 000456
    333 000457       334 000463       342 000464       343 000466       345 000474       348 000501       350 000504
    351 000525       357 000531       359 000536       361 000552       365 000560       368 000612       371 000624
    379 000627       380 000632       382 000651       385 000655       391 000766       392 000770       395 000772
    399 000775       401 001015       403 001035       406 001041       407 001044       411 001045       413 001050
    416 001054       419 001057       423 001073       426 001076       427 001102       431 001115       433 001117
    434 001122       437 001123       440 001130       442 001151       450 001155       453 001165       455 001167
    459 001170       463 001222       466 001243       470 001300       474 001325       475 001330       476 001331
    481 001332       486 001334       487 001337       488 001340       493 001341       496 001342       499 001353
    503 001354       510 001365       514 001456       516 001457       519 001460       530 001462


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
