	COMPILATION LISTING OF SEGMENT mrds_dsm_semantics
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1830.06_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* -sem mrds_dsm_semantics
       12*   -ssl
       13*   -table mrds_dsm_parse_table
       14*   -alm
       15*   -term
       16*   -ct
       17*   -recover ;
       18*   -order
       19*   <identifier>
       20*   ;
       21*   -parse */
       22 
       23 mrds_dsm_semantics: proc (p_mrds_dsm_semantics_info_ptr, rule, alt, p_lex_stack_ptr, ls_top, p_code);
       24 
       25 /*
       26*   This is the LRK source and the semantics for parsing  mrds  cmdsm
       27*   sources. The source mrds_dsm_semantics.pl1 is produced by running
       28*   LRK  over  mrds_dsm_parse.lrk.  Changes  should  never  be   made
       29*   directly   to  the  module  mrds_dsm_semantics,  but  instead  to
       30*   mrds_dsm_parse.lrk.
       31*
       32*   The production of a dsm is a two pass  process,  the  first  pass
       33*   being  done  by this module (mrds_dsm_semantics) in collaboration
       34*   with mrds_dsm_parse and mrds_dsm_scanner, and the various  tables
       35*   and  include  files  built  by LRK using mrds_dsm_parse.lrk. This
       36*   produces a submodel with all of the relation records  implied  by
       37*   the  cmdsm,  with  attribute  names  filled in but no access bits
       38*   turned on. The second pass is  done  by  mrds_dsm_compute_access.
       39*   This  consists  solely  of  setting access bits. Using two passes
       40*   allows the syntax  for  cmdsm  sources  to  be  completely  order
       41*   independent,  e.g.  one  needn't define a relation before setting
       42*   access to it (or vice versa).
       43*
       44*   Present in the submodel at this  time  are  also  various  access
       45*   records,  default  relation  access,  default  attribute  access,
       46*   relation access, and attribute access.  The  record  portions  of
       47*   these   records   are  all  identical,  being  the  access_record
       48*   structure.  The  keys  are   built   using   strings   from   the
       49*   mrds_dsm_head_strings  include  file  and  relation and attribute
       50*   names, concatenating strings together in some instances.
       51*
       52*   The  basic  scheme  of  the  semantics  is  that  each  RULE   is
       53*   individually   invoked   by  the  parser,  mrds_dsm_parse.  Where
       54*   necessary to keep track of information between successive  RULEs,
       55*   the  semantics pointer in the lex_stack is used to hang arbitrary
       56*   structures off of.  For  instance,  the  alias  RULE  leaves  the
       57*   semantics  pointer  pointing  at  an  alias  structure  with null
       58*   forward and backward pointers. The alias  list  RULE  leaves  the
       59*   semantics  pointer  pointing at an end of a doubly linked list of
       60*   alias structures. The relation spec RULE actually uses the  alias
       61*   structures  to  figure  out  the  dsm  relation  name,  the model
       62*   relation name, and the dsm and model attribute names.
       63*
       64*   Known Bugs:
       65*
       66*   Other Problems:
       67*
       68*   1) mode_str has to be changed from update to modify. It  must  be
       69*   changed  simultaneously  in  several modules. Since the user does
       70*   not see the update value there is no hurry.
       71*
       72*   HISTORY:
       73*
       74*   ??-??-?? Spratt: written.
       75*
       76*   80-09-20 Spratt: The alias list was being followed backwards (via
       77*   .        the "prev" pointers) when filling  in  the  rel_rec.attr
       78*   .        array  in  the  code  for  the  "relation specification"
       79*   .        production. This was changed to follow  the  alias  list
       80*   .        along  the "next" thread, hence recording the attributes
       81*   .        in the correct order.
       82*
       83*   80-09-25 Spratt: Added  the  "in  <relation>"  construct  to  the
       84*   .        attracc statement.
       85*
       86*   80-12-05 Spratt: Removed status relation  access  keyword,  added
       87*   .        "null"  relation  access  keyword.  Formatted  the   lrk
       88*   .        source.
       89*
       90*   81-01-05 Davids: changed the update and u keywords to modify  and
       91*   .        m. added the  keywords  append_tuple  and  delete_tuple.
       92*   .        removed  the  keywords  status and s. added the key word
       93*   .        with and corrected rel  access  spec  to  use  the  with
       94*   .        keyword.
       95*
       96*   .        Added  the  attribute   access   modes   read_attr   and
       97*   .        modify_attr,  changed  read  and modify to read attr and
       98*   .        modify attr. Changed deltup and apptup to d and a.
       99*
      100*   81-01-27 Davids: added statements to free the alias, rel_rec  and
      101*   .        access_record structures.
      102*
      103*   81-02-03 Davids: modified the rel access spec rule alternative  2
      104*   .        (with option) to take the symbol and symbol length  from
      105*   .        ls_top  -  8 rather than 7. 7 was just plain wrong. Also
      106*   .        the rel_access_head had to take  the  semantics  pointer
      107*   .        from ls_top - 6 rather than 5.
      108*
      109*   81-03-09 Davids: modified default  relation  access  and  default
      110*   .        attribute access statements so that the access list  may
      111*   .        optionaly be enclosed in ().
      112*
      113*   81-04-28     Davids:     replaced      the      reference      to
      114*   .        cmdsm_access_record.incl.pl1                        with
      115*   .        mrds_dsm_access_record.incl.pl1
      116*
      117*   .        added a statement  in  the  make_access_record  internal
      118*   .        procedure  to  set  the  used  bit  of the access_record
      119*   .        structure to "0"b;
      120*
      121*   81-04-29 Davids: replaced the  include  file  cmdsm_rel_rec  with
      122*   .        mrds_dsm_rel_rec_5.  all  references  to  rel_rec  where
      123*   .        changed   to   rel_rec_5   and   the  pointer  reference
      124*   .        rel_rec_5_ptr was added to all references to rel_rec_5.
      125*
      126*   81-05-08  Davids:  added  the   validate_relation   routine   and
      127*   .        corrected the report_error routine to be able to  report
      128*   .        errors   with   severity  greater  than  1  with  out  a
      129*   .        conversion error (there was an  extra  ^d  in  the  ioa_
      130*   .        control string).
      131*
      132*   .        removed the use  of  include  files  from  the  internal
      133*   .        procedures  make_access_record  and free_link_list. this
      134*   .        was done by declaring local pointers and refering to the
      135*   .        based  structures  using  the pointer. The local copy is
      136*   .        perhaps not needed but i'm stcking to the original  code
      137*   .        as much as possible.
      138*
      139*   81-05-11 Davids: added calls to ioa using the listing iocb_ptr if
      140*   .        that pointer is non-null (in the report_error procedure)
      141*
      142*   .        removed  some  undeclared   variables   (including   the
      143*   .        iox_dcls include file - explicitly declared seek_key and
      144*   .        write_record)  and  declared  some  builtins  that  were
      145*   .        implicitly declared.
      146*
      147*   81-05-12 Davids: added code to validate that no relation has  the
      148*   .        same submodel attribute name defined twice or  uses  the
      149*   .        same  model  attribute  to define two different submodel
      150*   .        attributes.
      151*
      152*   81-05-13 Davids: added code to check  the  lengths  of  both  the
      153*   .        submodel relation name  and  attribute  name.  attribute
      154*   .        names  are  checked  in  the  validate_relation routine,
      155*   .        relation names are checked in the relation_specification
      156*   .        rule (which later calls validate_relation) because it is
      157*   .        the only  place  that  the  submodel  relation  name  is
      158*   .        available.
      159*
      160*   81-05-20 Davids:  changed  relacc  and  attracc  to  rel_acc  and
      161*   .        attr_acc.
      162*
      163*   81-05-21  Davids:  moved  code  that  checks  the  length of the
      164*   .       submodel name to the validate_relation proc and pass the
      165*   .       name to that proc as a parameter.
      166*
      167*   .       added  code  to write a model_relation_name key for each
      168*   .       relation.   the  key  points  to  the  submodel relation
      169*   .       record.   this  code  is  used  to  be sure that a model
      170*   .       relation is used to define only 1 submodel relation.
      171*
      172*   81-05-22 Davids: changed code so that the model relation name key
      173*   .        is not pointing at the relation  record  but  at  a  new
      174*   .        (just written) record that contains no information. this
      175*   .        was because having the two keys pointing at the relation
      176*   .        record was screwing up compute_access which uses the key
      177*   .        value to get the relation name.
      178*
      179*   81-05-28 Davids: changed the cmdsm_head_strings include  file  to
      180*   .        mrds_dsm_head_strings      include     file,     changed
      181*   .        cmdsm_link_list include file to mrds_dsm_link_list.
      182**/
      183 
      184 /* PARAMETER */
      185 
      186 	dcl     p_mrds_dsm_semantics_info_ptr ptr;
      187 	dcl     p_code		 fixed bin (35);
      188 	dcl     rule		 fixed bin (24);
      189 	dcl     alt		 fixed bin (24);
      190 	dcl     p_lex_stack_ptr	 ptr;
      191 	dcl     ls_top		 fixed bin (24);
      192 
      193 /* AUTOMATIC */
      194 
      195 	dcl     rel_rec_5_ptr	 ptr init (null ());
      196 	dcl     work_area_ptr	 ptr;
      197 	dcl     debug_sw		 bit (1) aligned;
      198 	dcl     submodel_iocb_ptr	 ptr;
      199 	dcl     message		 char (256);
      200 	dcl     message_length;
      201 	dcl     alias_ptr		 ptr;
      202 	dcl     key_string		 char (256) varying;
      203 	dcl     code		 fixed bin (35);
      204 	dcl     attr_idx		 fixed bin;
      205 	dcl     rec_len		 fixed bin (21);
      206 	dcl     mode_str		 char (32) varying;
      207 	dcl     temp_ptr		 ptr;
      208 
      209 /* BASED */
      210 
      211 	dcl     work_area		 area (261120) based (work_area_ptr);
      212 	dcl     seg_str		 char (261120) based;
      213 	dcl     1 alias		 based (alias_ptr),
      214 		2 prev		 ptr,
      215 		2 next		 ptr,
      216 		2 dm_name		 char (256) varying,
      217 		2 dsm_name	 char (256) varying;
      218 
      219 /* BUILTIN */
      220 
      221 	dcl     max		 builtin;
      222 	dcl     null		 builtin;
      223 	dcl     currentsize		 builtin;
      224 	dcl     hbound		 builtin;
      225 	dcl     length		 builtin;
      226 	dcl     addr		 builtin;
      227 	dcl     substr		 builtin;
      228 
      229 /* ENTRY */
      230 
      231 	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
      232 	dcl     ioa_$ioa_switch	 entry options (variable);
      233 	dcl     ioa_$rs		 entry options (variable);
      234 	dcl     ioa_		 entry () options (variable);
      235 	dcl     iox_$seek_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
      236 	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      237 
      238 /* EXTERNAL */
      239 
      240 	dcl     error_table_$no_record fixed bin (35) external static;
      241 	dcl     error_table_$key_duplication fixed bin (35) external static;
      242 	dcl     mrds_error_$inconsistent_submodel fixed bin (35) external static;
      243 	dcl     mrds_error_$invalid_rel fixed bin (35) external static;
      244 	dcl     mrds_error_$no_model_attr fixed bin (35) external static;
      245 	dcl     mrds_error_$no_model_rel fixed bin (35) external static;
      246 
      247 	mrds_dsm_semantics_info_ptr = p_mrds_dsm_semantics_info_ptr;
      248 	submodel_iocb_ptr = mrds_dsm_semantics_info.submodel_iocb_ptr;
      249 	work_area_ptr = mrds_dsm_semantics_info.work_area_ptr;
      250 	debug_sw = mrds_dsm_semantics_info.debug_semantics;
      251 	lex_stack_ptr = p_lex_stack_ptr;
      252 	p_code = 0;
      253 
      254 	goto RULE (rule);
      255 
      256 /* <source> ::= <statement list> ! */
      257 RULE (0001):
      258 	if debug_sw
      259 	then call ioa_ ("Source.");
      260 	return;
      261 
      262 /* <statement list> ::= <statement list> <statement> | <statement> ! */
      263 RULE (0002):
      264 	if debug_sw
      265 	then call ioa_ ("Statement list.");
      266 	return;
      267 
      268 /* <statement> ::= <relation statement>
      269*   |<relation access statement>
      270*   |<attribute access statement>
      271*   |<default relation access statement>
      272*   |<default attribute access statement>! */
      273 RULE (0003):
      274 	if debug_sw
      275 	then call ioa_ ("Statement");
      276 	return;
      277 
      278 /* <relation statement> ::= <relation key> ': <relation specification list> ;! */
      279 RULE (0004):
      280 	if debug_sw
      281 	then call ioa_ ("Relation statement.");
      282 	return;
      283 
      284 /* <relation specification list> ::= <relation specification list>, <relation specification>
      285*   |<relation specification>! */
      286 RULE (0005):
      287 	if debug_sw
      288 	then call ioa_ ("Relation specification list.");
      289 	return;
      290 
      291 /* <relation specification> ::= <alias> (<alias list>)! */
      292 RULE (0006):
      293 	if debug_sw
      294 	then call ioa_ ("Relation specification.");
      295 	key_string = REL_HEAD || lex_stack (ls_top - 3).semantics_ptr -> alias.dsm_name;
      296 	call iox_$seek_key (submodel_iocb_ptr, key_string, rec_len, code);
      297 	if code = 0
      298 	then do;
      299 		call ioa_$rs ("Relation ^a in line number ^d.", message, message_length,
      300 		     lex_stack (ls_top - 3).semantics_ptr -> alias.dsm_name, lex_stack (ls_top - 3).line);
      301 		call report_error (1, (DUPLICATE_RELATION_DEF_ERROR), (message));
      302 		return;
      303 	     end;
      304 	else if code ^= error_table_$no_record
      305 	then do;
      306 		call ioa_$rs ("Unable to make entry for relation ^a in submodel.", message, message_length,
      307 		     lex_stack (ls_top - 3).semantics_ptr -> alias.dsm_name);
      308 		call report_error (4, (code), (message));
      309 		return;
      310 	     end;
      311 
      312 /*  The semantics_ptr points at the tail of the alias list. When through with
      313*   this loop, alias_ptr will point at the root ot the alias list.
      314**/
      315 
      316 	alias_ptr = lex_stack (ls_top - 1).semantics_ptr;
      317 	do attr_idx = 1 by 1 while (alias.prev ^= null);
      318 	     alias_ptr = alias.prev;
      319 	end;
      320 
      321 	rel_rec_5_attr_num = attr_idx;
      322 	allocate rel_rec_5 in (work_area) set (rel_rec_5_ptr);
      323 	rel_rec_5_ptr -> rel_rec_5.rel_dm_name = lex_stack (ls_top - 3).semantics_ptr -> alias.dm_name;
      324 
      325 /* alias_ptr is set to the "Root" of the list of aliases (attributes) by the short loop
      326*   following the "prev" chain, above.
      327**/
      328 
      329 	do attr_idx = 1 to rel_rec_5_attr_num;
      330 	     rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name = alias.dsm_name;
      331 	     rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dm_name = alias.dm_name;
      332 	     temp_ptr = alias_ptr;
      333 	     alias_ptr = alias.next;
      334 	     free temp_ptr -> alias in (work_area);
      335 	end;
      336 
      337 	call iox_$write_record (submodel_iocb_ptr, rel_rec_5_ptr, 4 * currentsize (rel_rec_5_ptr -> rel_rec_5), code);
      338 	if code ^= 0
      339 	then do;
      340 		call ioa_$rs ("Unable to write submodel entry for relation ^a.", message, message_length,
      341 		     rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
      342 		call report_error (4, (code), message);
      343 	     end;
      344 
      345 	call validate_relation (lex_stack (ls_top - 3).semantics_ptr -> alias.dsm_name);
      346 
      347 	free rel_rec_5_ptr -> rel_rec_5 in (work_area);
      348 
      349 	return;
      350 
      351 /* <alias list> ::= <alias list> <alias> | <alias>! */
      352 RULE (0007):
      353 	if debug_sw
      354 	then call ioa_ ("Alias list.");
      355 	if alt = 1
      356 	then do;
      357 		lex_stack (ls_top).semantics_ptr -> alias.prev = lex_stack (ls_top - 1).semantics_ptr;
      358 		lex_stack (ls_top - 1).semantics_ptr -> alias.next = lex_stack (ls_top).semantics_ptr;
      359 		lex_stack (ls_top - 1).semantics_ptr = lex_stack (ls_top).semantics_ptr;
      360 	     end;
      361 	return;
      362 
      363 /* <alias> ::= <general identifier> '= <general identifier> | <general identifier>! */
      364 RULE (0008):
      365 	if debug_sw
      366 	then call ioa_ ("Alias.");
      367 	allocate alias in (work_area);
      368 	alias.prev = null;
      369 	alias.next = null;
      370 	alias.dm_name = substr (lex_stack (ls_top).symptr -> seg_str, 1, lex_stack (ls_top).symlen);
      371 	if alt = 1
      372 	then do;
      373 		alias.dsm_name = substr (lex_stack (ls_top - 2).symptr -> seg_str, 1, lex_stack (ls_top - 2).symlen);
      374 		lex_stack (ls_top - 2).semantics_ptr = alias_ptr;
      375 	     end;
      376 	else do;
      377 		alias.dsm_name = substr (lex_stack (ls_top).symptr -> seg_str, 1, lex_stack (ls_top).symlen);
      378 		lex_stack (ls_top).semantics_ptr = alias_ptr;
      379 	     end;
      380 	return;
      381 
      382 /* <relation access statement> ::= <relation access key> ': <rel access spec list> ;! */
      383 RULE (0009):
      384 	if debug_sw
      385 	then call ioa_ ("Relation access statement.");
      386 	return;
      387 
      388 /* <rel access spec list> ::= <rel access spec list>, <rel access spec>
      389*   |<rel access spec>! */
      390 RULE (0010):
      391 	if debug_sw
      392 	then call ioa_ ("Rel access spec list.");
      393 	return;
      394 
      395 /* <rel access spec> ::= <general identifier> (<rel access modes list>)
      396*   | <general identifier> (<rel access modes list>) <with keyword> <attribute access key> (<attr access modes list>)! */
      397 RULE (0011):
      398 	if debug_sw
      399 	then call ioa_ ("Rel access spec.");
      400 	if alt = 1
      401 	then do;
      402 		call process_access (REL_ACCESS_HEAD
      403 		     || substr (lex_stack (ls_top - 3).symptr -> seg_str, 1, lex_stack (ls_top - 3).symlen),
      404 		     lex_stack (ls_top - 1).semantics_ptr, code);
      405 		if code ^= 0
      406 		then do;
      407 			p_code = code;
      408 			return;
      409 		     end;
      410 	     end;
      411 	else if alt = 2
      412 	then do;
      413 		call process_access (REL_ACCESS_HEAD
      414 		     || substr (lex_stack (ls_top - 8).symptr -> seg_str, 1, lex_stack (ls_top - 8).symlen),
      415 		     lex_stack (ls_top - 6).semantics_ptr, code);
      416 		if code ^= 0
      417 		then do;
      418 			p_code = code;
      419 			return;
      420 		     end;
      421 		call process_access (REL_ATTR_ACCESS_HEAD
      422 		     || substr (lex_stack (ls_top - 8).symptr -> seg_str, 1, lex_stack (ls_top - 8).symlen),
      423 		     lex_stack (ls_top - 1).semantics_ptr, code);
      424 		if code ^= 0
      425 		then do;
      426 			p_code = code;
      427 			return;
      428 		     end;
      429 	     end;
      430 
      431 	return;
      432 
      433 /* <rel access modes list> ::= <rel access modes list>, <relation access mode key>
      434*   | <relation access mode key>! */
      435 RULE (0012):
      436 	if debug_sw
      437 	then call ioa_ ("Rel access mode list.");
      438 	if alt = 1
      439 	then do;
      440 		lex_stack (ls_top).semantics_ptr -> link.prev = lex_stack (ls_top - 2).semantics_ptr;
      441 		lex_stack (ls_top - 2).semantics_ptr -> link.next = lex_stack (ls_top).semantics_ptr;
      442 		lex_stack (ls_top - 2).semantics_ptr = lex_stack (ls_top).semantics_ptr;
      443 	     end;
      444 	return;
      445 
      446 
      447 
      448 /* <relation access mode key> ::= <delete tuple key>
      449*   | <null key>
      450*   | <append tuple key>! */
      451 RULE (0013):
      452 	if debug_sw
      453 	then call ioa_ ("Relation access mode key.");
      454 	if alt = 1
      455 	then mode_str = "delete_tuple";
      456 	else if alt = 2
      457 	then mode_str = "null";
      458 	else mode_str = "append_tuple";
      459 
      460 	link_str_len = length (mode_str);
      461 	allocate link in (work_area);
      462 	link.str = mode_str;
      463 	link.next = null;
      464 	link.prev = null;
      465 	lex_stack (ls_top).semantics_ptr = link_ptr;
      466 	return;
      467 
      468 /* <attribute access statement> ::= <attribute access key> ': <attr access spec list> ;! */
      469 RULE (0014):
      470 	if debug_sw
      471 	then call ioa_ ("Attribute access statement.");
      472 	return;
      473 
      474 /* <attr access spec list> ::= <attr access spec list>, <attr access spec>
      475*   | <attr access spec>! */
      476 RULE (0015):
      477 	if debug_sw
      478 	then call ioa_ ("Attr access spec list.");
      479 	return;
      480 
      481 /* <attr access spec> ::= <general identifier> (<attr access modes list>)
      482*   | <general identifier> <in keyword> <general identifier> (<attr access modes list>)! */
      483 RULE (0016):
      484 	if debug_sw
      485 	then call ioa_ ("Attr access spec.");
      486 	if alt = 1
      487 	then do;
      488 		call process_access (ATTR_ACCESS_HEAD
      489 		     || substr (lex_stack (ls_top - 3).symptr -> seg_str, 1, lex_stack (ls_top - 3).symlen),
      490 		     lex_stack (ls_top - 1).semantics_ptr, code);
      491 		if code ^= 0
      492 		then p_code = code;
      493 		return;
      494 	     end;
      495 	else do;
      496 		call process_access (ATTR_ACCESS_HEAD
      497 		     || substr (lex_stack (ls_top - 5).symptr -> seg_str, 1, lex_stack (ls_top - 5).symlen)
      498 		     || ATTR_REL_DELIMITER
      499 		     || substr (lex_stack (ls_top - 3).symptr -> seg_str, 1, lex_stack (ls_top - 3).symlen),
      500 		     lex_stack (ls_top - 1).semantics_ptr, code);
      501 		if code ^= 0
      502 		then p_code = code;
      503 		return;
      504 	     end;
      505 
      506 /* <attr access modes list> ::= <attr access modes list>, <attribute access mode key>
      507*   | <attribute access mode key>! */
      508 RULE (0017):
      509 	if debug_sw
      510 	then call ioa_ ("Attr access mode list.");
      511 	if alt = 1
      512 	then do;
      513 		lex_stack (ls_top).semantics_ptr -> link.prev = lex_stack (ls_top - 2).semantics_ptr;
      514 		lex_stack (ls_top - 2).semantics_ptr -> link.next = lex_stack (ls_top).semantics_ptr;
      515 		lex_stack (ls_top - 2).semantics_ptr = lex_stack (ls_top).semantics_ptr;
      516 	     end;
      517 	return;
      518 
      519 /* <attribute access mode key> ::= <read key> | <null key> | <modify key>! */
      520 RULE (0018):
      521 	if debug_sw
      522 	then call ioa_ ("Attribute access mode key.");
      523 	if alt = 1
      524 	then mode_str = "read";
      525 	else if alt = 2
      526 	then mode_str = "null";
      527 	else if alt = 3
      528 	then mode_str = "update";
      529 	link_str_len = length (mode_str);
      530 	allocate link in (work_area);
      531 	link.str = mode_str;
      532 	link.prev = null;
      533 	link.next = null;
      534 	lex_stack (ls_top).semantics_ptr = link_ptr;
      535 	return;
      536 
      537 /* <default attribute access statement> ::= <default attribute access key> ': <attr access modes list> ;
      538*   |   <default attribute access key> ': (<attr access modes list>) ;! */
      539 RULE (0019):
      540 	if debug_sw
      541 	then call ioa_ ("Default attribute access statement.");
      542 	if alt = 1
      543 	then do;
      544 		call process_access ((DEF_ATTR_ACCESS_HEAD), lex_stack (ls_top - 1).semantics_ptr, code);
      545 		if code ^= 0
      546 		then p_code = code;
      547 	     end;
      548 	else
      549 	     if alt = 2
      550 	then do;
      551 		call process_access ((DEF_ATTR_ACCESS_HEAD), lex_stack (ls_top - 2).semantics_ptr, code);
      552 		if code ^= 0
      553 		then p_code = code;
      554 	     end;
      555 	return;
      556 
      557 /* <default relation access statement> ::= <default relation access key> ': <rel access modes list> ;
      558*   |   <default relation access key> ': (<rel access modes list>) ;! */
      559 RULE (0020):
      560 	if debug_sw
      561 	then call ioa_ ("Default relation access statement.");
      562 	if alt = 1
      563 	then do;
      564 		call process_access ((DEF_REL_ACCESS_HEAD), lex_stack (ls_top - 1).semantics_ptr, code);
      565 		if code ^= 0
      566 		then p_code = code;
      567 	     end;
      568 	else
      569 	     if alt = 2
      570 	then do;
      571 		call process_access ((DEF_REL_ACCESS_HEAD), lex_stack (ls_top - 2).semantics_ptr, code);
      572 		if code ^= 0
      573 		then p_code = code;
      574 	     end;
      575 	return;
      576 
      577 
      578 
      579 /* <relation access key> ::= <relation keyword> <access keyword> | <rel_acc keyword>! */
      580 RULE (0021):
      581 	if debug_sw
      582 	then call ioa_ ("Relation access key.");
      583 	return;
      584 
      585 /* <attribute access key> ::= <attribute keyword> <access keyword> | <attr_acc keyword>! */
      586 RULE (0022):
      587 	if debug_sw
      588 	then call ioa_ ("Attribute access key.");
      589 	return;
      590 
      591 /* <default attribute access key> ::= <default keyword> <attribute keyword > <access keyword> | <default keyword> <attr_acc keyword>! */
      592 RULE (0023):
      593 	if debug_sw
      594 	then call ioa_ ("Default attribute access key.");
      595 	return;
      596 
      597 /* <default relation access key> ::= <default keyword> <relation keyword> <access keyword> | <default keyword> <rel_acc keyword>! */
      598 RULE (0024):
      599 	if debug_sw
      600 	then call ioa_ ("Default relation access key.");
      601 	return;
      602 
      603 
      604 
      605 /* <delete tuple key> ::= <delete keyword> <tuple keyword> | <d keyword> | <delete_tuple keyword>! */
      606 RULE (0025):
      607 	if debug_sw
      608 	then call ioa_ ("Delete tuple key.");
      609 	return;
      610 
      611 /* <append tuple key> ::= <append keyword> <tuple keyword> | <a keyword> | <append_tuple keyword>! */
      612 RULE (0026):
      613 	if debug_sw
      614 	then call ioa_ ("Append tuple key.");
      615 	return;
      616 
      617 /* <read key> ::= <read keyword> <attr keyword> | <read_attr keyword> | <r keyword>! */
      618 RULE (0027):
      619 	if debug_sw
      620 	then call ioa_ ("Read key.");
      621 	return;
      622 
      623 /* <modify key> ::= <modify keyword> <attr keyword> | <modify_attr keyword> | <m keyword>! */
      624 RULE (0028):
      625 	if debug_sw
      626 	then call ioa_ ("Update key.");
      627 	return;
      628 
      629 /* <null key> ::= <null keyword> | <n keyword>! */
      630 RULE (0029):
      631 	if debug_sw
      632 	then call ioa_ ("Null key.");
      633 	return;
      634 
      635 /* <general identifier> ::= <identifier>
      636*   | <relation keyword>
      637*   | <attribute keyword>
      638*   | <access keyword>
      639*   | <attr_acc keyword>
      640*   | <rel_acc keyword>
      641*   | <default keyword>
      642*   | <in keyword>
      643*   | <with keyword>
      644*   | <delete keyword>
      645*   | <append keyword>
      646*   | <tuple keyword>
      647*   | <attr keyword>
      648*   | <d keyword>
      649*   | <a keyword>
      650*   | <delete_tuple keyword>
      651*   | <append_tuple keyword>
      652*   | <read keyword>
      653*   | <read_attr keyword>
      654*   | <r keyword>
      655*   | <modify keyword>
      656*   | <modify_attr keyword>
      657*   | <m keyword>
      658*   | <null keyword>
      659*   | <n keyword>! */
      660 RULE (0030):
      661 	if debug_sw
      662 	then call ioa_ ("General identifier.");
      663 	return;
      664 
      665 /* <relation keyword> ::= relation! */
      666 RULE (0031):
      667 	if debug_sw
      668 	then call ioa_ ("Relation keyword.");
      669 	return;
      670 
      671 /* <attribute keyword> ::= attribute! */
      672 RULE (0032):
      673 	if debug_sw
      674 	then call ioa_ ("Attribute keyword.");
      675 	return;
      676 
      677 /* <access keyword> ::= access! */
      678 RULE (0033):
      679 	if debug_sw
      680 	then call ioa_ ("Access keyword.");
      681 	return;
      682 
      683 /* <rel_acc keyword> ::= rel_acc! */
      684 RULE (0034):
      685 	if debug_sw
      686 	then call ioa_ ("Rel_acc keyword.");
      687 	return;
      688 
      689 /* <attr_acc keyword> ::= attr_acc! */
      690 RULE (0035):
      691 	if debug_sw
      692 	then call ioa_ ("Attr_acc keyword.");
      693 	return;
      694 
      695 /* <default keyword> ::= default! */
      696 RULE (0036):
      697 	if debug_sw
      698 	then call ioa_ ("Default keyword.");
      699 	return;
      700 
      701 /* <relation key> ::= <relation keyword>! */
      702 RULE (0037):
      703 	if debug_sw
      704 	then call ioa_ ("Relation key.");
      705 
      706 /* <in keyword> ::= in! */
      707 RULE (0038):
      708 	if debug_sw
      709 	then call ioa_ ("In keyword.");
      710 	return;
      711 
      712 /* <with keyword> ::= with! */
      713 RULE (0039):
      714 	if debug_sw
      715 	then call ioa_ ("With keyword.");
      716 	return;
      717 
      718 /* <delete keyword> ::= delete! */
      719 RULE (0040):
      720 	if debug_sw
      721 	then call ioa_ ("Deltup keyword.");
      722 	return;
      723 
      724 /* <append keyword> ::= append! */
      725 RULE (0041):
      726 	if debug_sw
      727 	then call ioa_ ("Apptup keyword.");
      728 	return;
      729 
      730 /* <tuple keyword> ::= tuple! */
      731 RULE (0042):
      732 	if debug_sw
      733 	then call ioa_ ("Tuple keyword.");
      734 	return;
      735 
      736 /* <attr keyword> ::= attr! */
      737 RULE (0043):
      738 	if debug_sw
      739 	then call ioa_ ("Attr keyword.");
      740 	return;
      741 
      742 /* <d keyword> ::= d! */
      743 RULE (0044):
      744 	if debug_sw
      745 	then call ioa_ ("D keyword.");
      746 	return;
      747 
      748 /* <a keyword> ::= a! */
      749 RULE (0045):
      750 	if debug_sw
      751 	then call ioa_ ("A keyword.");
      752 	return;
      753 
      754 /* <delete_tuple keyword> ::= delete_tuple! */
      755 RULE (0046):
      756 	if debug_sw
      757 	then call ioa_ ("Delete_tuple keyword.");
      758 	return;
      759 
      760 /* <append_tuple keyword> ::= append_tuple! */
      761 RULE (0047):
      762 	if debug_sw
      763 	then call ioa_ ("Append_tuple keyword.");
      764 	return;
      765 
      766 /* <read keyword> ::= read! */
      767 RULE (0048):
      768 	if debug_sw
      769 	then call ioa_ ("Read keyword.");
      770 	return;
      771 
      772 /* <read_attr keyword> ::= read_attr! */
      773 RULE (0049):
      774 	if debug_sw
      775 	then call ioa_ ("Read_attr keyword.");
      776 	return;
      777 
      778 /* <modify keyword> ::= modify! */
      779 RULE (0050):
      780 	if debug_sw
      781 	then call ioa_ ("Update keyword.");
      782 	return;
      783 
      784 /* <modify_attr keyword> ::= modify_attr! */
      785 RULE (0051):
      786 	if debug_sw
      787 	then call ioa_ ("Modify_attr keuword.");
      788 	return;
      789 
      790 /* <null keyword> ::= null! */
      791 RULE (0052):
      792 	if debug_sw
      793 	then call ioa_ ("Null keyword.");
      794 	return;
      795 
      796 /* <n keyword> ::= n! */
      797 RULE (0053):
      798 	if debug_sw
      799 	then call ioa_ ("N keyword.");
      800 	return;
      801 
      802 /* <r keyword> ::= r! */
      803 RULE (0054):
      804 	if debug_sw
      805 	then call ioa_ ("R keyword.");
      806 	return;
      807 
      808 /* <m keyword> ::= m! */
      809 RULE (0055):
      810 	if debug_sw
      811 	then call ioa_ ("U keyword.");
      812 	return;
      813 
      814 make_access_record: proc (p_link_ptr, p_work_area_ptr, p_access_rec_ptr);
      815 
      816 /* PARAMETER */
      817 
      818 	dcl     p_link_ptr		 ptr;
      819 	dcl     p_work_area_ptr	 ptr;
      820 	dcl     p_access_rec_ptr	 ptr;
      821 
      822 /* AUTOMATIC */
      823 
      824 	dcl     local_access_record_ptr ptr;
      825 	dcl     local_link_ptr	 ptr;
      826 	dcl     mode_idx		 fixed bin;
      827 
      828 /* BASED */
      829 
      830 	dcl     work_area		 area (261120) based (p_work_area_ptr);
      831 
      832 
      833 
      834 	local_link_ptr = p_link_ptr;
      835 	do mode_idx = 0 by 1 while (local_link_ptr ^= null);
      836 	     local_link_ptr = local_link_ptr -> link.prev;
      837 	end;
      838 
      839 	access_record_mode_num = mode_idx;
      840 	allocate access_record in (work_area) set (local_access_record_ptr);
      841 	local_link_ptr = p_link_ptr;
      842 	do mode_idx = 1 to access_record_mode_num;
      843 	     local_access_record_ptr -> access_record.modes (mode_idx) = local_link_ptr -> link.str;
      844 	     local_link_ptr = local_link_ptr -> link.prev;
      845 	end;
      846 	local_access_record_ptr -> access_record.used = "0"b;
      847 	p_access_rec_ptr = local_access_record_ptr;
      848 
      849 	return;
      850 
      851      end;						/* End of make_access_record. */
      852 
      853 free_link_list: proc (p_link_ptr, p_work_area_ptr);
      854 
      855 /* PARAMETER */
      856 
      857 	dcl     p_link_ptr		 ptr;
      858 	dcl     p_work_area_ptr	 ptr;
      859 
      860 /* AUTOMATIC */
      861 
      862 	dcl     local_link_ptr	 ptr;
      863 	dcl     prev_link_ptr	 ptr;
      864 
      865 /* BASED */
      866 
      867 	dcl     work_area		 based (p_work_area_ptr) area (261120);
      868 
      869 
      870 
      871 	local_link_ptr = p_link_ptr;
      872 	do while (local_link_ptr ^= null);
      873 	     prev_link_ptr = local_link_ptr -> link.prev;
      874 	     free local_link_ptr -> link in (work_area);
      875 	     local_link_ptr = prev_link_ptr;
      876 	end;
      877 
      878 	return;
      879 
      880      end;						/* End of free_link_list. */
      881 
      882 report_error: proc (p_severity, p_error_number, p_message);
      883 
      884 /* PARAMETER */
      885 
      886 	dcl     p_severity		 fixed bin;
      887 	dcl     p_error_number	 fixed bin (35);
      888 	dcl     p_message		 char (*);
      889 
      890 /* AUTOMATIC */
      891 
      892 	dcl     long_message	 char (100);
      893 	dcl     short_message	 char (8);
      894 
      895 /* ENTRIES */
      896 
      897 	dcl     convert_status_code_	 entry (fixed bin (35), char (8), char (100));
      898 
      899 
      900 	if p_error_number > hbound (MRDS_DSM_ERROR_MESSAGE, 1)
      901 	then do;
      902 		call convert_status_code_ (p_error_number, short_message, long_message);
      903 		call ioa_$ioa_switch (mrds_dsm_semantics_info.error_iocb_ptr,
      904 		     "^[Severity ^d, Error^;^sWarning^] On or Before Line ^d.^/^a^/^a", (p_severity > 1), p_severity,
      905 		     lex_stack (ls_top).line, long_message, p_message);
      906 		if mrds_dsm_semantics_info.listing_iocb_ptr ^= null ()
      907 		then do;
      908 			call ioa_$ioa_switch (mrds_dsm_semantics_info.listing_iocb_ptr,
      909 			     "^[Severity ^d, Error^;^sWarning^] On or Before Line ^d.^/^a^/^a", (p_severity > 1), p_severity,
      910 			     lex_stack (ls_top).line, long_message, p_message);
      911 		     end;
      912 	     end;
      913 	else do;
      914 		call ioa_$ioa_switch (mrds_dsm_semantics_info.error_iocb_ptr,
      915 		     "^[Severity ^d, Error^;^sWarning^] On or Before Line ^d.^/^a^/^a", (p_severity > 1), p_severity,
      916 		     lex_stack (ls_top).line, MRDS_DSM_ERROR_MESSAGE (p_error_number), p_message);
      917 		if mrds_dsm_semantics_info.listing_iocb_ptr ^= null ()
      918 		then do;
      919 			call ioa_$ioa_switch (mrds_dsm_semantics_info.listing_iocb_ptr,
      920 			     "^[Severity ^d, Error^;^sWarning^] On or Before Line ^d.^/^a^/^a", (p_severity > 1), p_severity,
      921 			     lex_stack (ls_top).line, MRDS_DSM_ERROR_MESSAGE (p_error_number), p_message);
      922 		     end;
      923 	     end;
      924 	mrds_dsm_semantics_info.highest_severity = max (mrds_dsm_semantics_info.highest_severity, p_severity);
      925      end;						/* End of report_error. */
      926 
      927 process_access: proc (p_key_string, p_link_list_ptr, p_code);
      928 
      929 	dcl     p_key_string	 char (256) varying;
      930 	dcl     p_link_list_ptr	 ptr;
      931 	dcl     p_code		 fixed bin (35);
      932 
      933 
      934 
      935 	call iox_$seek_key (submodel_iocb_ptr, p_key_string, rec_len, p_code);
      936 	if p_code = 0
      937 	then do;
      938 		p_code = error_table_$key_duplication;
      939 		call ioa_$rs ("Multiple specifications for ^a submodel entry.", message, message_length, p_key_string);
      940 		call report_error (2, DUPLICATE_ENTRY_ERROR, (message));
      941 		return;
      942 	     end;
      943 	else if p_code ^= error_table_$no_record
      944 	then do;
      945 		call ioa_$rs ("Unable to seek submodel entry for ^a.", message, message_length, p_key_string);
      946 		call report_error (4, (p_code), (message));
      947 		return;
      948 	     end;
      949 
      950 	call make_access_record (p_link_list_ptr, work_area_ptr, access_record_ptr);
      951 
      952 	call iox_$write_record (submodel_iocb_ptr, access_record_ptr, 4 * currentsize (access_record), p_code);
      953 	if p_code ^= 0
      954 	then do;
      955 		call ioa_$rs ("Unable to write submodel entry for ^a.", message, message_length, p_key_string);
      956 		call report_error (4, (p_code), (message));
      957 		return;
      958 	     end;
      959 
      960 	free access_record_ptr -> access_record in (work_area);
      961 
      962 	call free_link_list (p_link_list_ptr, work_area_ptr);
      963 	p_code = 0;
      964      end;						/* End of process_access. */
      965 
      966 validate_relation: proc (dsm_relation_name);
      967 
      968 	dcl     dsm_relation_name	 char (256) varying;
      969 
      970 	dcl     found		 bit (1) unal;
      971 	dcl     model_attr_idx	 fixed bin;
      972 	dcl     j			 fixed bin;
      973 
      974 	if length (dsm_relation_name) > 30
      975 	then do;
      976 		call ioa_$rs ("Submodel relation name ^a has exceeded the maximum length of 30 characters",
      977 		     message, message_length, dsm_relation_name);
      978 		call report_error (4, mrds_error_$inconsistent_submodel, message);
      979 	     end;
      980 
      981 	call mrds_dm_get_attributes
      982 	     (mrds_dsm_semantics_info.data_model_ptr,
      983 	     (rel_rec_5_ptr -> rel_rec_5.rel_dm_name),
      984 	     work_area_ptr,
      985 	     rd_ptr,
      986 	     code);
      987 	if code = mrds_error_$no_model_rel
      988 	then do;
      989 		call ioa_$rs ("Model relation ^a does not exist in the database", message, message_length,
      990 		     rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
      991 		call report_error (4, mrds_error_$invalid_rel, message);
      992 		return;
      993 	     end;
      994 	else
      995 	     if code ^= 0
      996 	then do;
      997 		call ioa_$rs ("Unable to read model relation ^a for validation", message, message_length,
      998 		     rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
      999 		call report_error (4, code, message);
     1000 		return;
     1001 	     end;
     1002 
     1003 	do attr_idx = 1 to rel_rec_5_attr_num;
     1004 
     1005 	     if length (rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name) > 32
     1006 	     then do;
     1007 		     call ioa_$rs ("Submodel attribute name ^a has exceeded the maximum length of 32 characters",
     1008 			message, message_length, rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name);
     1009 		     call report_error (4, mrds_error_$inconsistent_submodel, message);
     1010 		end;
     1011 
     1012 	     found = "0"b;
     1013 	     do model_attr_idx = 1 to rd_ptr -> rel_desc.num_attr while (^found);
     1014 		if rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dm_name
     1015 		     = rd_ptr -> rel_desc.attributes (model_attr_idx).attribute_name
     1016 		then found = "1"b;
     1017 	     end;
     1018 	     if ^found
     1019 	     then do;
     1020 		     call ioa_$rs ("Model attribute ^a used in defining submodel attribute ^a does " ||
     1021 			"not exist in the model relation ^a", message, message_length,
     1022 			rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dm_name,
     1023 			rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name,
     1024 			rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
     1025 		     call report_error (4, mrds_error_$no_model_attr, message);
     1026 		end;
     1027 
     1028 	     do j = 1 to attr_idx - 1;
     1029 
     1030 		if rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name
     1031 		     = rel_rec_5_ptr -> rel_rec_5.attr (j).dsm_name
     1032 		then do;
     1033 			call ioa_$rs ("Submodel attribute ^a defined multiple times at attribute positions ^i and ^i",
     1034 			     message, message_length, rel_rec_5_ptr -> rel_rec_5.attr (j).dsm_name,
     1035 			     j, attr_idx);
     1036 			call report_error (4, mrds_error_$inconsistent_submodel, message);
     1037 		     end;
     1038 
     1039 		if rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dm_name
     1040 		     = rel_rec_5_ptr -> rel_rec_5.attr (j).dm_name
     1041 		then do;
     1042 			call ioa_$rs ("Model attribute ^a used multiple times at attribute positions ^i and ^i",
     1043 			     message, message_length, rel_rec_5_ptr -> rel_rec_5.attr (j).dm_name,
     1044 			     j, attr_idx);
     1045 			call report_error (4, mrds_error_$inconsistent_submodel, message);
     1046 		     end;
     1047 
     1048 	     end;
     1049 
     1050 	end;
     1051 
     1052 	key_string = MODEL_REL_HEAD || rel_rec_5_ptr -> rel_rec_5.rel_dm_name;
     1053 	call iox_$seek_key (submodel_iocb_ptr, key_string, rec_len, code);
     1054 	if code = 0
     1055 	then do;
     1056 		call ioa_$rs ("Model relation ^a has already been used to define a relation",
     1057 		     message, message_length, rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
     1058 		call report_error (4, mrds_error_$inconsistent_submodel, message);
     1059 		code = 0;
     1060 	     end;
     1061 	else
     1062 	     if code ^= error_table_$no_record
     1063 	then do;
     1064 		call ioa_$rs ("PROGRAM LOGIC ERROR^/Could not seek key for validating model relation use for ^a",
     1065 		     message, message_length, rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
     1066 		code = 0;
     1067 	     end;
     1068 	else do;
     1069 		call iox_$write_record (submodel_iocb_ptr, addr (j), 1, code);
     1070 		if code ^= 0
     1071 		then do;
     1072 			call ioa_$rs ("PROGRAM LOGIC ERROR^/Unable to write record for validating model relation use for ^a",
     1073 			     message, message_length, rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
     1074 			code = 0;
     1075 		     end;
     1076 	     end;
     1077 
     1078 	free rd_ptr -> rel_desc;
     1079 
     1080 	return;
     1081 
     1082      end validate_relation;
     1083 
  1     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_link_list.incl.pl1 */
  1     2 
  1     3 /* Used by mrds_dsm_semantics to make lists of mode names.
  1     4*
  1     5*Written  11/28/79  by  Lindsey L. Spratt
  1     6**/
  1     7      dcl	   link_str_len	      fixed bin;
  1     8      dcl	   link_ptr	      ptr;
  1     9      dcl	   1 link		      based (link_ptr),
  1    10 	     2 prev	      ptr init (null ()),
  1    11 	     2 next	      ptr init (null ()),
  1    12 	     2 str_len	      fixed bin,
  1    13 	     2 str	      char (link_str_len refer (link.str_len));
  1    14 
  1    15 /* END INCLUDE FILE  -  mrds_dsm_link_list.incl.pl1 */
     1084 
     1085 
  2     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_access_record.incl.pl1
  2     2*
  2     3*79-11-28 Spratt: written
  2     4*
  2     5*81-04-28 Davids: added the element used.
  2     6**/
  2     7 
  2     8      dcl	   access_record_ptr      ptr;
  2     9      dcl	   access_record_mode_num fixed bin;
  2    10 
  2    11      dcl	   1 access_record	      based (access_record_ptr),
  2    12 	     2 used               bit (1),
  2    13 	     2 mode_num	      fixed bin,
  2    14 	     2 modes	      (access_record_mode_num refer (access_record.mode_num)) char (32) varying;
  2    15 
  2    16 /* END INCLUDE FILE  - mrds_dsm_access_record.incl.pl1 */
     1086 
     1087 
  3     1 /* BEGIN INCLUDE FILE mrds_dsm_parse_stack.incl.pl1 */
  3     2 
  3     3 /* These structures are used by mrds_dsm_parse, mrds_dsm_scanner, and
  3     4*mrds_dsm_semantics.  They are very similar to the
  3     5*mrds_rst_parse_stack.incl.pl1 structures, the difference being the
  3     6*semantics_ptr in the lex_stack in this include file.
  3     7*
  3     8*Written  12/19/79  by  Lindsey L. Spratt
  3     9**/
  3    10      declare 1 lex_stack	      (-5:50) based (lex_stack_ptr),
  3    11 	     2 symptr	      ptr,		/* pointer to terminal symbol in source input */
  3    12 	     2 symlen	      fixed binary (24),	/* length of terminal symbol in input */
  3    13 	     2 line	      fixed binary (24),	/* line number in source for this symbol */
  3    14 	     2 symbol	      fixed binary (24),	/* parser's encoding value for the terminal symbol */
  3    15 	     2 val	      fixed binary (71),	/* conversion value for numbers */
  3    16 	     2 float	      float binary (63),	/* conversion value if floating point number */
  3    17 	     2 semantics_ptr      ptr,		/* Pointer to arbitrary data, not used by either parse or scan routines.*/
  3    18 	     2 line_strt	      ptr,		/* pointer to start of current line */
  3    19 	     2 line_size	      fixed binary (24),	/* current length of line */
  3    20 	     2 token_num	      fixed binary (24);	/* number of this token in current line,
  3    21*						   0 if <error_symbol> for missing or wrong symbol */
  3    22 
  3    23      declare lex_stack_ptr	      ptr;		/* pointer to lexical stack */
  3    24 
  3    25 /* on => output debug messages */
  3    26 
  3    27      dcl	   1 p_struct	      (50) aligned based (p_struct_ptr),
  3    28 	     2 parse_stack	      fixed bin (24),	/* * parse stack */
  3    29 	     2 parse_stack2	      fixed bin (24);	/* * copy of parse stack used
  3    30*						   with local error recovery */
  3    31 
  3    32      dcl	   p_struct_ptr	      ptr;
  3    33 
  3    34 
  3    35      dcl	   cur_lex_top	      (50) fixed bin (24) aligned based (cur_lex_top_ptr);
  3    36 						/* current lex top stack (with parse_stack) */
  3    37 
  3    38      declare cur_lex_top_ptr	      ptr;
  3    39 
  3    40 
  3    41 /* END INCLUDE FILE mrds_rst_parse_stack.incl.pl1 */
  3    42 
     1088 
     1089 
  4     1 /* BEGIN INCLUDE FILE - mrds_dsm_rel_rec_5.incl.pl1 */
  4     2 
  4     3 /*
  4     4*   This is the format of the relation record in version 5 submodels
  4     5*
  4     6*   HISTORY
  4     7*
  4     8*   80-12-23 Davids: written
  4     9*
  4    10*   81-04-29 Davids: changed the access elements from a bit string to
  4    11*   a  named set of bits and added the two structures relation_access
  4    12*   and attribute_access.
  4    13**/
  4    14 
  4    15 
  4    16 dcl 01 rel_rec_5 based,
  4    17     02 attr_num fixed bin,
  4    18     02 rel_dm_name char (256) varying,
  4    19     02 access like relation_access,
  4    20     02 attr (rel_rec_5_attr_num refer (rel_rec_5.attr_num)),
  4    21       03 dsm_name char (256) varying,
  4    22       03 dm_name char (256) varying,
  4    23       03 access like attribute_access;
  4    24 
  4    25 dcl  rel_rec_5_attr_num fixed bin;
  4    26 
  4    27 
  4    28 dcl 01 relation_access based,
  4    29     02 null bit (1) unal,
  4    30     02 append bit (1) unal,
  4    31     02 delete bit (1) unal,
  4    32     02 mbz1 bit (33) unal;
  4    33 
  4    34 
  4    35 dcl 01 attribute_access based,
  4    36     02 null bit (1) unal,
  4    37     02 read bit (1) unal,
  4    38     02 modify bit (1) unal,
  4    39     02 mbz1 bit (33) unal;
  4    40 
  4    41 /* END INCLUDE FILE - mrds_dsm_rel_rec_5.incl.pl1 */
     1090 
     1091 
  5     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_head_strings.incl.pl1 */
  5     2 
  5     3 /*
  5     4*   All of the key heads used in the mrds submodel vfile declared  as
  5     5*   constants in this file.
  5     6*
  5     7*   Written  11/30/79  by  Lindsey L. Spratt
  5     8*
  5     9*   80-12-23 Davids: modified so that  strings  lengths  are  128  to
  5    10*   accomodate longer relation and attribute names.
  5    11*
  5    12*   81-05-20 Davids: added MODEL_REL_HEAD.
  5    13**/
  5    14 
  5    15 dcl  REL_ACCESS_HEAD char (128) varying internal static options (constant) init ("relation access:");
  5    16 dcl  REL_ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("relation attribute access:");
  5    17 dcl  ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("attribute access:");
  5    18 dcl  DEF_REL_ACCESS_HEAD char (128) varying internal static options (constant) init ("default relation access:");
  5    19 dcl  DEF_ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("default attribute access:");
  5    20 dcl  REL_HEAD char (128) varying internal static options (constant) init ("relation:");
  5    21 dcl  ATTR_REL_DELIMITER char (128) varying internal static options (constant) init (":in:");
  5    22 dcl  MODEL_REL_HEAD char (128) varying internal static options (constant) init ("model relation:");
  5    23 
  5    24 /* END INCLUDE FILE  -  mrds_dsm_head_strings.incl.pl1 */
     1092 
     1093 
  6     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_sem_info.incl.pl1 */
  6     2 
  6     3 /*
  6     4*This structure is used to communicate with mrds_dsm_semantics, and to
  6     5*maintain information across calls to mrds_dsm_semantics.
  6     6*
  6     7*79-12-19 Spratt: written
  6     8*
  6     9*81-05-07 Davids: added the data_model_ptr element
  6    10**/
  6    11 
  6    12      dcl	   mrds_dsm_semantics_info_ptr
  6    13 			      ptr;
  6    14      dcl	   MRDS_DSM_SEMANTICS_INFO_VERSION_1
  6    15 			      fixed bin (17) internal static options (constant) init (1);
  6    16 
  6    17      dcl	   1 mrds_dsm_semantics_info
  6    18 			      based (mrds_dsm_semantics_info_ptr) aligned,
  6    19 	     2 version	      fixed bin (35),
  6    20 	     2 flags,
  6    21 	       3 debug_semantics  bit (1) unal,
  6    22 	       3 pad	      bit (35) unal,
  6    23 	     2 work_area_ptr      ptr,
  6    24 	     2 error_iocb_ptr     ptr,
  6    25 	     2 listing_iocb_ptr   ptr,
  6    26 	     2 highest_severity   fixed bin (35),
  6    27 	     2 submodel_iocb_ptr  ptr,
  6    28 	     2 data_model_ptr     ptr;
  6    29 
  6    30 /* END INCLUDE FILE  -  mrds_dsm_sem_info.incl.pl1 */
     1094 
     1095 
  7     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_error_info.incl.pl1 */
  7     2 
  7     3 /* This include file contains the standard error messages, and named constants
  7     4*for error codes which index into the array of messages.
  7     5*
  7     6*Written 12/19/79  by  Lindsey L. Spratt
  7     7**/
  7     8 
  7     9      dcl	   PARSE_ERROR_RECOVERY   fixed bin (35) internal static options (constant) init (1);
  7    10      dcl	   PARSE_NO_RECOVERY      fixed bin (35) internal static options (constant) init (2);
  7    11      dcl	   LEX_TOO_MANY	      fixed bin (35) internal static options (constant) init (3);
  7    12      dcl	   INTERNAL_STACK_OVERFLOW
  7    13 			      fixed bin (35) internal static options (constant) init (4);
  7    14      dcl	   PARSE_TOO_MANY	      fixed bin (35) internal static options (constant) init (5);
  7    15      dcl	   PARSE_FAILURE	      fixed bin (35) internal static options (constant) init (6);
  7    16      dcl	   LISTING_IO_ERROR	      fixed bin (35) internal static options (constant) init (7);
  7    17      dcl	   ILLEGAL_CHAR_ERROR     fixed bin (35) internal static options (constant) init (8);
  7    18      dcl	   OVERLENGTH_TOKEN_ERROR fixed bin (35) internal static options (constant) init (9);
  7    19      dcl	   NO_COMMENT_END_DELIMITER_ERROR
  7    20 			      fixed bin (35) internal static options (constant) init (10);
  7    21      dcl	   UNRECOGNIZED_CHARACTER_ERROR
  7    22 			      fixed bin (35) internal static options (constant) init (11);
  7    23      dcl	   UNRECOGNIZED_TOKEN_ERROR
  7    24 			      fixed bin (35) internal static options (constant) init (12);
  7    25      dcl	   DUPLICATE_RELATION_DEF_ERROR
  7    26 			      fixed bin (35) internal static options (constant) init (13);
  7    27 
  7    28      dcl	   DUPLICATE_ENTRY_ERROR  fixed bin (35) internal static options (constant) init (14);
  7    29 
  7    30 
  7    31      dcl	   MRDS_DSM_ERROR_MESSAGE (14) char (256) varying internal static options (constant)
  7    32 			      init ("Bad syntax, a correction has been made.",
  7    33 			      "Bad syntax, unable to make a correction.",
  7    34 			      "Translator error, the lexical stack overflowed.  Contact system personnel if problem persists."
  7    35 			      ,
  7    36 			      "Translator error, an internal stack overflowed.  Contact system personnel if problem persists."
  7    37 			      ,
  7    38 			      "Translator error, the parse stack overflowed.  Contact system personnel if problem persists."
  7    39 			      , "Unable to complete parsing.", "Unable to do I/O on the listing segment switch.",
  7    40 			      "An illegal character has been found in the source.",
  7    41 			      "A token has been found which is too long.",
  7    42 			      "A comment does not have a terminating delimiter.",
  7    43 			      "An unrecognized character has been found.", "An unrecognized token has been found.",
  7    44 			      "Multiple definitions of the same relation have been found, only the first one will be used."
  7    45 			      , "Attempt to multiply specify the same entry, only the first one will be used.");
  7    46 
  7    47 /* END INCLUDE FILE  -  mrds_dsm_error_info.incl.pl1 */
     1096 
     1097 
  8     1 /*	BEGIN INCLUDE FILE		mrds_rel_desc.incl.pl1	rgl, 03/31/76		*/
  8     2 
  8     3 /* 76-09-20 R. Lackey : modified to handle inverted attributes	
  8     4*
  8     5*   76-11-16 J. A. Weeldreyer : modified to add domain name 
  8     6*
  8     7*   82-08-19 D. Woodka : deleted rel_desc.attributes.bit_offset field
  8     8*   for the DMS conversion
  8     9*
  8    10**/
  8    11 
  8    12 dcl 1 rel_desc based (rd_ptr),			/* record description of relation records */
  8    13     2 num_attr fixed bin,				/* number of attributes in the model */
  8    14     2 key_length fixed bin (35),			/* length in bits of data portion of tuple */
  8    15     2 data_length fixed bin (35),			/* length in bits of data portion of tuple */
  8    16     2 num_keys fixed bin,				/* number of key attributes */
  8    17     2 inversion bit (1) unal,				/* On if this relation contains any inverted  attributes */
  8    18     2 reserved bit (35) unal,				/* Reserved for future use */
  8    19     2 attributes (num_attr_alloc refer (rel_desc.num_attr)),
  8    20       3 attribute_name char (32),			/* name of attribute  */
  8    21       3 domain_name char (32),			/* name of underlying domain */
  8    22       3 bit_length bit (18) unaligned,			/* length of data item in bits */
  8    23       3 key_flag bit (1) unaligned,			/* indicates whether attribute is part of primary key */
  8    24       3 inver_flag bit (1) unaligned,			/* On if this attribute is inverted */
  8    25       3 unused bit (34) unaligned,			/* reserved for expansion */
  8    26       3 key_attr_order fixed bin,			/* order num of this key attr */
  8    27       3 descriptor bit (36);				/* Multics descriptor for attribute */
  8    28 
  8    29 dcl  num_attr_alloc fixed bin (10);			/* Number of attributes in relation for allocation purposes */
  8    30 
  8    31 dcl  rd_ptr ptr;
  8    32 
  8    33 /*	END INCLUDE FILE		mrds_rel_desc.incl.pl1				*/
  8    34 
     1098 
     1099 
     1100 
     1101      end;						/* End of mrds_dsm_semantics. */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1830.0  mrds_dsm_semantics.pl1            >udd>sm>ds>w>ml>mrds_dsm_semantics.pl1
1084         1    10/14/83  1708.9  mrds_dsm_link_list.incl.pl1       >ldd>incl>mrds_dsm_link_list.incl.pl1
1086         2    10/14/83  1708.8  mrds_dsm_access_record.incl.pl1   >ldd>incl>mrds_dsm_access_record.incl.pl1
1088         3    10/14/83  1708.6  mrds_dsm_parse_stack.incl.pl1     >ldd>incl>mrds_dsm_parse_stack.incl.pl1
1090         4    10/14/83  1708.9  mrds_dsm_rel_rec_5.incl.pl1       >ldd>incl>mrds_dsm_rel_rec_5.incl.pl1
1092         5    10/14/83  1708.9  mrds_dsm_head_strings.incl.pl1    >ldd>incl>mrds_dsm_head_strings.incl.pl1
1094         6    10/14/83  1708.9  mrds_dsm_sem_info.incl.pl1        >ldd>incl>mrds_dsm_sem_info.incl.pl1
1096         7    10/14/83  1708.7  mrds_dsm_error_info.incl.pl1      >ldd>incl>mrds_dsm_error_info.incl.pl1
1098         8    10/14/83  1709.0  mrds_rel_desc.incl.pl1            >ldd>incl>mrds_rel_desc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTR_ACCESS_HEAD                002152 constant        varying char(128)        initial dcl 5-17 ref 488 496
ATTR_REL_DELIMITER              001746 constant        varying char(128)        initial dcl 5-21 ref 496
DEF_ATTR_ACCESS_HEAD            002050 constant        varying char(128)        initial dcl 5-19 ref 544 551
DEF_REL_ACCESS_HEAD             002111 constant        varying char(128)        initial dcl 5-18 ref 564 571
DUPLICATE_ENTRY_ERROR                  constant        fixed bin(35,0)          initial dcl 7-28 set ref 940*
DUPLICATE_RELATION_DEF_ERROR           constant        fixed bin(35,0)          initial dcl 7-25 ref 301
MODEL_REL_HEAD                  001705 constant        varying char(128)        initial dcl 5-22 ref 1052
MRDS_DSM_ERROR_MESSAGE          000067 constant        varying char(256)        initial array dcl 7-31 set ref 900 914* 919*
REL_ACCESS_HEAD                 002254 constant        varying char(128)        initial dcl 5-15 ref 402 413
REL_ATTR_ACCESS_HEAD            002213 constant        varying char(128)        initial dcl 5-16 ref 421
REL_HEAD                        002007 constant        varying char(128)        initial dcl 5-20 ref 295
access_record                          based           structure                level 1 unaligned dcl 2-11 set ref 840 952 960
access_record_mode_num          000342 automatic       fixed bin(17,0)          dcl 2-9 set ref 839* 840 840 842
access_record_ptr               000340 automatic       pointer                  dcl 2-8 set ref 950* 952* 952 960
addr                                                   builtin function         dcl 226 ref 1069 1069
alias                                  based           structure                level 1 unaligned dcl 213 set ref 334 367
alias_ptr                       000212 automatic       pointer                  dcl 201 set ref 316* 317 318* 318 330 331 332 333*
                                                                                  333 367* 368 369 370 373 374 377 378
alt                                    parameter       fixed bin(24,0)          dcl 189 ref 23 355 371 400 411 438 454 456 486 511
                                                                                  523 525 527 542 548 562 568
attr                    103            based           structure                array level 2 unaligned dcl 4-16
attr_idx                        000316 automatic       fixed bin(17,0)          dcl 204 set ref 317* 321 329* 330 331* 1003* 1005
                                                                                  1007 1014 1020 1020 1028 1030 1033* 1039 1042*
attr_num                               based           fixed bin(17,0)          level 2 dcl 4-16 set ref 322* 337 347
attribute_access                       based           structure                level 1 packed packed unaligned dcl 4-35
attribute_name            5            based           char(32)                 array level 3 packed packed unaligned dcl 8-12 ref
                                                                                  1014
attributes                5            based           structure                array level 2 unaligned dcl 8-12
code                            000315 automatic       fixed bin(35,0)          dcl 203 set ref 296* 297 304 308 337* 338 342 402*
                                                                                  405 407 413* 416 418 421* 424 426 488* 491 491
                                                                                  496* 501 501 544* 545 545 551* 552 552 564* 565
                                                                                  565 571* 572 572 981* 987 994 999* 1053* 1054
                                                                                  1059* 1061 1066* 1069* 1070 1074*
convert_status_code_            000040 constant        entry                    external dcl 897 ref 902
currentsize                                            builtin function         dcl 223 ref 337 952
data_model_ptr           14            based           pointer                  level 2 dcl 6-17 set ref 981*
debug_semantics           1            based           bit(1)                   level 3 packed packed unaligned dcl 6-17 ref 250
debug_sw                        000104 automatic       bit(1)                   dcl 197 set ref 250* 257 263 273 279 286 292 352 364
                                                                                  383 390 397 435 451 469 476 483 508 520 539 559
                                                                                  580 586 592 598 606 612 618 624 630 660 666 672
                                                                                  678 684 690 696 702 707 713 719 725 731 737 743
                                                                                  749 755 761 767 773 779 785 791 797 803 809
dm_name                 204            based           varying char(256)        array level 3 in structure "rel_rec_5" dcl 4-16
                                                                                  in procedure "mrds_dsm_semantics" set ref 331*
                                                                                  1014 1020* 1039 1039 1042*
dm_name                   4            based           varying char(256)        level 2 in structure "alias" dcl 213 in procedure
                                                                                  "mrds_dsm_semantics" set ref 323 331 370*
dsm_name                105            based           varying char(256)        level 2 in structure "alias" dcl 213 in procedure
                                                                                  "mrds_dsm_semantics" set ref 295 299* 306* 330
                                                                                  345* 373* 377*
dsm_name                103            based           varying char(256)        array level 3 in structure "rel_rec_5" dcl 4-16
                                                                                  in procedure "mrds_dsm_semantics" set ref 330*
                                                                                  1005 1007* 1020* 1030 1030 1033*
dsm_relation_name                      parameter       varying char(256)        dcl 968 set ref 966 974 976*
error_iocb_ptr            4            based           pointer                  level 2 dcl 6-17 set ref 903* 914*
error_table_$key_duplication    000026 external static fixed bin(35,0)          dcl 241 ref 938
error_table_$no_record          000024 external static fixed bin(35,0)          dcl 240 ref 304 943 1061
flags                     1            based           structure                level 2 dcl 6-17
found                           000462 automatic       bit(1)                   packed unaligned dcl 970 set ref 1012* 1013 1014*
                                                                                  1018
hbound                                                 builtin function         dcl 224 ref 900
highest_severity         10            based           fixed bin(35,0)          level 2 dcl 6-17 set ref 924* 924
ioa_                            000016 constant        entry                    external dcl 234 ref 257 263 273 279 286 292 352 364
                                                                                  383 390 397 435 451 469 476 483 508 520 539 559
                                                                                  580 586 592 598 606 612 618 624 630 660 666 672
                                                                                  678 684 690 696 702 707 713 719 725 731 737 743
                                                                                  749 755 761 767 773 779 785 791 797 803 809
ioa_$ioa_switch                 000012 constant        entry                    external dcl 232 ref 903 908 914 919
ioa_$rs                         000014 constant        entry                    external dcl 233 ref 299 306 340 939 945 955 976 989
                                                                                  997 1007 1020 1033 1042 1056 1064 1072
iox_$seek_key                   000020 constant        entry                    external dcl 235 ref 296 935 1053
iox_$write_record               000022 constant        entry                    external dcl 236 ref 337 952 1069
j                               000464 automatic       fixed bin(17,0)          dcl 972 set ref 1028* 1030 1033 1033* 1039 1042
                                                                                  1042* 1069 1069
key_string                      000214 automatic       varying char(256)        dcl 202 set ref 295* 296* 1052* 1053*
length                                                 builtin function         dcl 225 ref 460 529 974 1005
lex_stack                              based           structure                array level 1 unaligned dcl 3-10
lex_stack_ptr                   000344 automatic       pointer                  dcl 3-23 set ref 251* 295 299 299 306 316 323 345
                                                                                  357 357 358 358 359 359 370 370 373 373 374 377
                                                                                  377 378 402 402 402 413 413 413 421 421 421 440
                                                                                  440 441 441 442 442 465 488 488 488 496 496 496
                                                                                  496 496 513 513 514 514 515 515 534 544 551 564
                                                                                  571 903 908 914 919
line                      3            based           fixed bin(24,0)          array level 2 dcl 3-10 set ref 299* 903* 908* 914*
                                                                                  919*
link                                   based           structure                level 1 unaligned dcl 1-9 set ref 461 530 874
link_ptr                        000336 automatic       pointer                  dcl 1-8 set ref 461* 462 463 464 465 530* 531 532
                                                                                  533 534
link_str_len                    000334 automatic       fixed bin(17,0)          dcl 1-7 set ref 460* 461 461 529* 530 530
listing_iocb_ptr          6            based           pointer                  level 2 dcl 6-17 set ref 906 908* 917 919*
local_access_record_ptr         000364 automatic       pointer                  dcl 824 set ref 840* 843 846 847
local_link_ptr                  000366 automatic       pointer                  dcl 825 in procedure "make_access_record" set ref
                                                                                  834* 835 836* 836 841* 843 844* 844
local_link_ptr                  000400 automatic       pointer                  dcl 862 in procedure "free_link_list" set ref 871*
                                                                                  872 873 874 875*
long_message                    000412 automatic       char(100)                packed unaligned dcl 892 set ref 902* 903* 908*
ls_top                                 parameter       fixed bin(24,0)          dcl 191 ref 23 295 299 299 306 316 323 345 357 357
                                                                                  358 358 359 359 370 370 373 373 374 377 377 378
                                                                                  402 402 402 413 413 413 421 421 421 440 440 441
                                                                                  441 442 442 465 488 488 488 496 496 496 496 496
                                                                                  513 513 514 514 515 515 534 544 551 564 571 903
                                                                                  908 914 919
max                                                    builtin function         dcl 221 ref 924
message                         000110 automatic       char(256)                packed unaligned dcl 199 set ref 299* 301 306* 308
                                                                                  340* 342* 939* 940 945* 946 955* 956 976* 978*
                                                                                  989* 991* 997* 999* 1007* 1009* 1020* 1025* 1033*
                                                                                  1036* 1042* 1045* 1056* 1058* 1064* 1072*
message_length                  000210 automatic       fixed bin(17,0)          dcl 200 set ref 299* 306* 340* 939* 945* 955* 976*
                                                                                  989* 997* 1007* 1020* 1033* 1042* 1056* 1064*
                                                                                  1072*
mode_idx                        000370 automatic       fixed bin(17,0)          dcl 826 set ref 835* 839 842* 843*
mode_num                  1            based           fixed bin(17,0)          level 2 dcl 2-11 set ref 840* 952 960
mode_str                        000320 automatic       varying char(32)         dcl 206 set ref 454* 456* 458* 460 462 523* 525*
                                                                                  527* 529 531
model_attr_idx                  000463 automatic       fixed bin(17,0)          dcl 971 set ref 1013* 1014*
modes                     2            based           varying char(32)         array level 2 dcl 2-11 set ref 843*
mrds_dm_get_attributes          000010 constant        entry                    external dcl 231 ref 981
mrds_dsm_semantics_info                based           structure                level 1 dcl 6-17
mrds_dsm_semantics_info_ptr     000350 automatic       pointer                  dcl 6-12 set ref 247* 248 249 250 903 906 908 914
                                                                                  917 919 924 924 981
mrds_error_$inconsistent_submodel
                                000030 external static fixed bin(35,0)          dcl 242 set ref 978* 1009* 1036* 1045* 1058*
mrds_error_$invalid_rel         000032 external static fixed bin(35,0)          dcl 243 set ref 991*
mrds_error_$no_model_attr       000034 external static fixed bin(35,0)          dcl 244 set ref 1025*
mrds_error_$no_model_rel        000036 external static fixed bin(35,0)          dcl 245 ref 987
next                      2            based           pointer                  level 2 in structure "alias" dcl 213 in procedure
                                                                                  "mrds_dsm_semantics" set ref 333 358* 369*
next                      2            based           pointer                  initial level 2 in structure "link" dcl 1-9
                                                                                  in procedure "mrds_dsm_semantics" set ref 441*
                                                                                  461* 463* 514* 530* 533*
null                                                   builtin function         dcl 222 ref 195 317 368 369 461 461 463 464 530 530
                                                                                  532 533 835 872 906 917
num_attr                               based           fixed bin(17,0)          level 2 dcl 8-12 ref 1013 1078
p_access_rec_ptr                       parameter       pointer                  dcl 820 set ref 814 847*
p_code                                 parameter       fixed bin(35,0)          dcl 931 in procedure "process_access" set ref 927
                                                                                  935* 936 938* 943 946 952* 953 956 963*
p_code                                 parameter       fixed bin(35,0)          dcl 187 in procedure "mrds_dsm_semantics" set ref 23
                                                                                  252* 407* 418* 426* 491* 501* 545* 552* 565* 572*
p_error_number                         parameter       fixed bin(35,0)          dcl 887 set ref 882 900 902* 914 919
p_key_string                           parameter       varying char(256)        dcl 929 set ref 927 935* 939* 945* 955*
p_lex_stack_ptr                        parameter       pointer                  dcl 190 ref 23 251
p_link_list_ptr                        parameter       pointer                  dcl 930 set ref 927 950* 962*
p_link_ptr                             parameter       pointer                  dcl 818 in procedure "make_access_record" ref 814
                                                                                  834 841
p_link_ptr                             parameter       pointer                  dcl 857 in procedure "free_link_list" ref 853 871
p_message                              parameter       char                     packed unaligned dcl 888 set ref 882 903* 908* 914*
                                                                                  919*
p_mrds_dsm_semantics_info_ptr          parameter       pointer                  dcl 186 ref 23 247
p_severity                             parameter       fixed bin(17,0)          dcl 886 set ref 882 903 903* 908 908* 914 914* 919
                                                                                  919* 924
p_work_area_ptr                        parameter       pointer                  dcl 819 in procedure "make_access_record" ref 814
                                                                                  840
p_work_area_ptr                        parameter       pointer                  dcl 858 in procedure "free_link_list" ref 853 874
prev                                   based           pointer                  level 2 in structure "alias" dcl 213 in procedure
                                                                                  "mrds_dsm_semantics" set ref 317 318 357* 368*
prev                                   based           pointer                  initial level 2 in structure "link" dcl 1-9
                                                                                  in procedure "mrds_dsm_semantics" set ref 440*
                                                                                  461* 464* 513* 530* 532* 836 844 873
prev_link_ptr                   000402 automatic       pointer                  dcl 863 set ref 873* 875
rd_ptr                          000352 automatic       pointer                  dcl 8-31 set ref 981* 1013 1014 1078
rec_len                         000317 automatic       fixed bin(21,0)          dcl 205 set ref 296* 935* 1053*
rel_desc                               based           structure                level 1 unaligned dcl 8-12 ref 1078
rel_dm_name               1            based           varying char(256)        level 2 dcl 4-16 set ref 323* 340* 981 989* 997*
                                                                                  1020* 1052 1056* 1064* 1072*
rel_rec_5                              based           structure                level 1 unaligned dcl 4-16 set ref 322 337 347
rel_rec_5_attr_num              000346 automatic       fixed bin(17,0)          dcl 4-25 set ref 321* 322 322 329 1003
rel_rec_5_ptr                   000100 automatic       pointer                  initial dcl 195 set ref 195* 322* 323 330 331 337*
                                                                                  337 340 347 981 989 997 1005 1007 1014 1020 1020
                                                                                  1020 1030 1030 1033 1039 1039 1042 1052 1056 1064
                                                                                  1072
relation_access                        based           structure                level 1 packed packed unaligned dcl 4-28
rule                                   parameter       fixed bin(24,0)          dcl 188 ref 23 254
seg_str                                based           char(261120)             packed unaligned dcl 212 ref 370 373 377 402 413 421
                                                                                  488 496 496
semantics_ptr            12            based           pointer                  array level 2 dcl 3-10 set ref 295 299 306 316 323
                                                                                  345 357 357 358 358 359* 359 374* 378* 402* 413*
                                                                                  421* 440 440 441 441 442* 442 465* 488* 496* 513
                                                                                  513 514 514 515* 515 534* 544* 551* 564* 571*
short_message                   000444 automatic       char(8)                  packed unaligned dcl 893 set ref 902*
str                       5            based           char                     level 2 packed packed unaligned dcl 1-9 set ref 462*
                                                                                  531* 843
str_len                   4            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 461* 462 530* 531 843 874
submodel_iocb_ptr        12            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 6-17 in procedure "mrds_dsm_semantics" ref 248
submodel_iocb_ptr               000106 automatic       pointer                  dcl 198 in procedure "mrds_dsm_semantics" set ref
                                                                                  248* 296* 337* 935* 952* 1053* 1069*
substr                                                 builtin function         dcl 227 ref 370 373 377 402 413 421 488 496 496
symlen                    2            based           fixed bin(24,0)          array level 2 dcl 3-10 ref 370 373 377 402 413 421
                                                                                  488 496 496
symptr                                 based           pointer                  array level 2 dcl 3-10 ref 370 373 377 402 413 421
                                                                                  488 496 496
temp_ptr                        000332 automatic       pointer                  dcl 207 set ref 332* 334
used                                   based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  846*
work_area                              based           area(261120)             dcl 867 in procedure "free_link_list" ref 874
work_area                              based           area(261120)             dcl 830 in procedure "make_access_record" ref 840
work_area                              based           area(261120)             dcl 211 in procedure "mrds_dsm_semantics" ref 322
                                                                                  334 347 367 461 530 960
work_area_ptr             2            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 6-17 in procedure "mrds_dsm_semantics" ref 249
work_area_ptr                   000102 automatic       pointer                  dcl 196 in procedure "mrds_dsm_semantics" set ref
                                                                                  249* 322 334 347 367 461 530 950* 960 962* 981*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ILLEGAL_CHAR_ERROR                     internal static fixed bin(35,0)          initial dcl 7-17
INTERNAL_STACK_OVERFLOW                internal static fixed bin(35,0)          initial dcl 7-12
LEX_TOO_MANY                           internal static fixed bin(35,0)          initial dcl 7-11
LISTING_IO_ERROR                       internal static fixed bin(35,0)          initial dcl 7-16
MRDS_DSM_SEMANTICS_INFO_VERSION_1      internal static fixed bin(17,0)          initial dcl 6-14
NO_COMMENT_END_DELIMITER_ERROR         internal static fixed bin(35,0)          initial dcl 7-19
OVERLENGTH_TOKEN_ERROR                 internal static fixed bin(35,0)          initial dcl 7-18
PARSE_ERROR_RECOVERY                   internal static fixed bin(35,0)          initial dcl 7-9
PARSE_FAILURE                          internal static fixed bin(35,0)          initial dcl 7-15
PARSE_NO_RECOVERY                      internal static fixed bin(35,0)          initial dcl 7-10
PARSE_TOO_MANY                         internal static fixed bin(35,0)          initial dcl 7-14
UNRECOGNIZED_CHARACTER_ERROR           internal static fixed bin(35,0)          initial dcl 7-21
UNRECOGNIZED_TOKEN_ERROR               internal static fixed bin(35,0)          initial dcl 7-23
cur_lex_top                            based           fixed bin(24,0)          array dcl 3-35
cur_lex_top_ptr                        automatic       pointer                  dcl 3-38
num_attr_alloc                         automatic       fixed bin(10,0)          dcl 8-29
p_struct                               based           structure                array level 1 dcl 3-27
p_struct_ptr                           automatic       pointer                  dcl 3-32

NAMES DECLARED BY EXPLICIT CONTEXT.
RULE                            000000 constant        label                    array(55) dcl 257 ref 254
free_link_list                  006745 constant        entry                    internal dcl 853 ref 962
make_access_record              006647 constant        entry                    internal dcl 814 ref 950
mrds_dsm_semantics              003440 constant        entry                    external dcl 23
process_access                  007346 constant        entry                    internal dcl 927 ref 402 413 421 488 496 544 551 564
                                                                                  571
report_error                    006774 constant        entry                    internal dcl 882 ref 301 308 342 940 946 956 978 991
                                                                                  999 1009 1025 1036 1045 1058
validate_relation               007631 constant        entry                    internal dcl 966 ref 345

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11322       11364   11132       11332
Length     12020   11132        42         420     167           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsm_semantics                  754 external procedure  is an external procedure.  
make_access_record                      internal procedure  shares stack frame of external procedure mrds_dsm_semantics.  
free_link_list                          internal procedure  shares stack frame of external procedure mrds_dsm_semantics.  
report_error                            internal procedure  shares stack frame of external procedure mrds_dsm_semantics.  
process_access                          internal procedure  shares stack frame of external procedure mrds_dsm_semantics.  
validate_relation                       internal procedure  shares stack frame of external procedure mrds_dsm_semantics.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsm_semantics       000100 rel_rec_5_ptr               mrds_dsm_semantics
                         000102 work_area_ptr               mrds_dsm_semantics
                         000104 debug_sw                    mrds_dsm_semantics
                         000106 submodel_iocb_ptr           mrds_dsm_semantics
                         000110 message                     mrds_dsm_semantics
                         000210 message_length              mrds_dsm_semantics
                         000212 alias_ptr                   mrds_dsm_semantics
                         000214 key_string                  mrds_dsm_semantics
                         000315 code                        mrds_dsm_semantics
                         000316 attr_idx                    mrds_dsm_semantics
                         000317 rec_len                     mrds_dsm_semantics
                         000320 mode_str                    mrds_dsm_semantics
                         000332 temp_ptr                    mrds_dsm_semantics
                         000334 link_str_len                mrds_dsm_semantics
                         000336 link_ptr                    mrds_dsm_semantics
                         000340 access_record_ptr           mrds_dsm_semantics
                         000342 access_record_mode_num      mrds_dsm_semantics
                         000344 lex_stack_ptr               mrds_dsm_semantics
                         000346 rel_rec_5_attr_num          mrds_dsm_semantics
                         000350 mrds_dsm_semantics_info_ptr mrds_dsm_semantics
                         000352 rd_ptr                      mrds_dsm_semantics
                         000364 local_access_record_ptr     make_access_record
                         000366 local_link_ptr              make_access_record
                         000370 mode_idx                    make_access_record
                         000400 local_link_ptr              free_link_list
                         000402 prev_link_ptr               free_link_list
                         000412 long_message                report_error
                         000444 short_message               report_error
                         000462 found                       validate_relation
                         000463 model_attr_idx              validate_relation
                         000464 j                           validate_relation

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          ioa_                          ioa_$ioa_switch               ioa_$rs
iox_$seek_key                 iox_$write_record             mrds_dm_get_attributes

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$key_duplication  error_table_$no_record        mrds_error_$inconsistent_submodel
mrds_error_$invalid_rel       mrds_error_$no_model_attr     mrds_error_$no_model_rel




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 003432       195 003445       247 003447       248 003453       249 003455       250 003457       251 003462
    252 003465       254 003466       257 003470       260 003504       263 003505       266 003525       273 003526
    276 003544       279 003545       282 003562       286 003563       289 003600       292 003601       295 003621
    296 003651       297 003667       299 003671       301 003732       302 003744       304 003745       306 003750
    308 004004       309 004016       316 004017       317 004025       318 004034       319 004037       321 004041
    322 004043       323 004054       329 004067       330 004077       331 004111       332 004117       333 004120
    334 004122       335 004124       337 004126       338 004150       340 004152       342 004203       345 004212
    347 004225       349 004232       352 004233       355 004252       357 004256       358 004264       359 004267
    361 004271       364 004272       367 004306       368 004313       369 004315       370 004316       371 004334
    373 004340       374 004351       375 004352       377 004353       378 004363       380 004364       383 004365
    386 004402       390 004403       393 004423       397 004424       400 004444       402 004450       405 004511
    407 004514       408 004516       410 004517       411 004520       413 004522       416 004563       418 004566
    419 004570       421 004571       424 004633       426 004636       427 004640       431 004641       435 004642
    438 004662       440 004666       441 004674       442 004677       444 004701       451 004702       454 004717
    456 004731       458 004740       460 004745       461 004747       462 004764       464 004770       465 004772
    466 004777       469 005000       472 005015       476 005016       479 005036       483 005037       486 005057
    488 005063       491 005124       493 005131       496 005132       501 005217       503 005224       508 005225
    511 005245       513 005251       514 005257       515 005262       517 005264       520 005265       523 005302
    525 005313       527 005322       529 005331       530 005333       531 005350       532 005354       533 005356
    534 005357       535 005364       539 005365       542 005402       544 005406       545 005430       547 005434
    548 005435       551 005437       552 005461       555 005465       559 005466       562 005503       564 005507
    565 005531       567 005535       568 005536       571 005540       572 005562       575 005566       580 005567
    583 005604       586 005605       589 005625       592 005626       595 005643       598 005644       601 005661
    606 005662       609 005702       612 005703       615 005720       618 005721       621 005737       624 005740
    627 005757       630 005760       633 005776       660 005777       663 006017       666 006020       669 006035
    672 006036       675 006056       678 006057       681 006077       684 006100       687 006120       690 006121
    693 006136       696 006137       699 006157       702 006160       707 006200       710 006220       713 006221
    716 006241       719 006242       722 006262       725 006263       728 006303       731 006304       734 006324
    737 006325       740 006345       743 006346       746 006364       749 006365       752 006404       755 006405
    758 006425       761 006426       764 006446       767 006447       770 006467       773 006470       776 006510
    779 006511       782 006531       785 006532       788 006547       791 006550       794 006570       797 006571
    800 006607       803 006610       806 006627       809 006630       812 006646       814 006647       834 006651
    835 006654       836 006662       837 006665       839 006667       840 006671       841 006704       842 006710
    843 006717       844 006734       845 006736       846 006740       847 006741       849 006744       853 006745
    871 006747       872 006752       873 006756       874 006761       875 006770       876 006772       878 006773
    882 006774       900 007005       902 007011       903 007024       906 007103       908 007110       912 007166
    914 007167       917 007250       919 007255       924 007336       925 007345       927 007346       935 007350
    936 007366       938 007371       939 007374       940 007423       941 007433       943 007434       945 007437
    946 007466       947 007501       950 007502       952 007514       953 007540       955 007543       956 007573
    957 007606       960 007607       962 007615       963 007626       964 007630       966 007631       974 007633
    976 007637       978 007670       981 007713       987 007740       989 007744       991 007774       992 010017
    994 010020       997 010022       999 010052      1000 010057      1003 010060      1005 010067      1007 010075
   1009 010130      1012 010153      1013 010154      1014 010165      1017 010206      1018 010210      1020 010212
   1025 010260      1028 010303      1030 010313      1033 010332      1036 010374      1039 010417      1042 010436
   1045 010500      1048 010523      1050 010525      1052 010527      1053 010552      1054 010570      1056 010572
   1058 010623      1059 010646      1060 010647      1061 010650      1064 010653      1066 010703      1067 010704
   1069 010705      1070 010725      1072 010727      1074 010760      1078 010761      1080 010766


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
