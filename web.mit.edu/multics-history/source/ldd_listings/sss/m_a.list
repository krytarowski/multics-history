	COMPILATION LISTING OF SEGMENT m_a
	Compiled by: Multics PL/I Compiler, Release 32c, of June 16, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 09/19/89  1013.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(89-02-28,RWaters), approve(89-02-28,MCR8068), audit(89-09-07,Vu),
       17*     install(89-09-19,MR12.3-1068):
       18*     Fix bug 1899.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 /* Program to make a reference addressable
       23*
       24*   Initial Version: 16 April 1971 by BLW for Version II
       25*	Modified: 10 May 1973 by RAB for multiple base regs
       26*	Modified:	19 June 1973 by RAB for EIS
       27*	Modified:	4 June 1975 by RAB for separate_static
       28*	Modified:	27 November 1975 by RAB to fix 1431
       29*	Modified:	11 May 1976 by RAB to fix 1496
       30*	Modified:	2 Oct 1976 by RAB to fix 1530
       31*	Modified:	9 Mar 1977 by RAB to eliminate mod_word operator
       32*	Modified:	11 Jan 1978 by RAB to set base_regs(i).used
       33*	Modified:	11 Aug 1978 by RAB to fix 1734
       34*	Modified:	31 Dec 1978 by RAB to fix 1807 (bad code for internal
       35*		file constants if linkage section >16k)
       36*	Modified: 14 Dec 1988 by RW null pointer with defined references.
       37**/
       38 /* format: style3,^indattr,ifthendo,ifthen,^indnoniterdo,indproc,^elsestmt,dclind9,idind23 */
       39 
       40 m_a:
       41      proc (pt, bits);
       42 
       43 dcl      pt ptr,					/* points at ref node to be made addressable */
       44          bits aligned bit (2),			/* 2 bits as follows: */
       45          no_ind aligned bit (1),			/* "1"b if no indirection allowed */
       46          eis aligned bit (1);				/* "1"b if addressing for EIS instruction */
       47 
       48 dcl      (
       49          cg_stat$cur_block,
       50          cg_stat$cur_statement,
       51          cg_stat$long_string_temp
       52          ) ptr ext,
       53          cg_stat$extended_stack bit (1) ext,
       54          cg_stat$text_pos fixed bin (18) ext,
       55          cg_stat$cur_level fixed bin ext;
       56 
       57 dcl      ref ptr,					/* points at ref node to be made addressable */
       58          r1 ptr;					/* points at ref node from which addressing info
       59*				   is obtained.  r1 starts off equal to ref. */
       60 
       61 dcl      (p1, p2, ro, s1, q, vwo) ptr,
       62          (i, k) fixed bin,
       63          xr fixed bin (3),
       64          base bit (3),
       65          (dont_load, have_loaded, useless) bit (1) aligned,
       66          (word_offset, save_word_offset, off, delta) fixed bin (15),
       67          (fract_offset, save_fract_offset, fo) fixed bin (6),
       68          (ind_word, multiple) fixed bin (18),
       69          base_offset fixed bin (24),
       70          locked bit (1) aligned,
       71          fok bit (1) aligned,
       72          (tag, tagind) bit (6) aligned,
       73          reloc bit (12) aligned,
       74          op_code bit (9) aligned;
       75 
       76 dcl      (abs, bit, divide, fixed, mod, null, string, substr) builtin;
       77 
       78 dcl      m_a entry (ptr, bit (2) aligned);
       79 dcl      expmac entry (fixed bin (15), ptr);
       80 dcl      base_man$load_arg_ptr entry (fixed bin, ptr, fixed bin) returns (bit (3) aligned);
       81 dcl      base_man$load_stack_indirect entry (fixed bin (18)) returns (bit (3) aligned);
       82 dcl      base_man$load_display entry (fixed bin) returns (bit (3) aligned);
       83 dcl      base_man$load_link_indirect entry (fixed bin, bit (12) aligned) returns (bit (3) aligned);
       84 dcl      base_man$load_controlled entry (fixed bin, fixed bin (15)) returns (bit (3) aligned);
       85 dcl      base_man$load_linkage entry returns (bit (3) aligned);
       86 dcl      base_man$load_static entry returns (bit (3) aligned);
       87 dcl      base_man_link_or_static entry returns (bit (3) aligned) variable;
       88 dcl      base_man$load_any_var entry (fixed bin, ptr) returns (bit (3) aligned);
       89 dcl      base_man$load_arg entry (fixed bin, ptr) returns (bit (3) aligned);
       90 dcl      base_man$load_var entry (fixed bin, ptr, fixed bin),
       91          stack_temp$free_temp entry (ptr),
       92          stack_temp$assign_temp entry (ptr),
       93          stack_temp$assign_block entry (ptr, fixed bin),
       94          stack_temp$assign_aggregate entry (ptr),
       95          stack_temp$assign_return_value entry (ptr),
       96          copy_temp entry (ptr) returns (ptr),
       97          cg_error entry (fixed bin, fixed bin),
       98          error entry (fixed bin, ptr, ptr),
       99          prepare_operand entry (ptr, fixed bin, bit (1) aligned) returns (ptr),
      100          aq_man$load_any_const entry (fixed bin (24), fixed bin (2)),
      101          aq_man$load_any_var entry (ptr, fixed bin (2), fixed bin (24)),
      102          xr_man$lock entry (ptr, fixed bin (3)),
      103          xr_man$unlock entry (fixed bin (3)),
      104          xr_man$load_any_const entry (fixed bin (18), fixed bin (3)),
      105          xr_man$load_any_var entry (ptr, fixed bin (3), fixed bin (18));
      106 
      107 dcl      (
      108          r_mod init ("001"b),
      109          ri_mod init ("011"b),
      110          ir_mod init ("111"b)
      111          ) bit (3) int static;
      112 
      113 dcl      (
      114          aq_mod init ("0001"b),
      115          iaq_mod init ("1101"b)
      116          ) bit (4) int static;
      117 
      118 dcl      fix_bin fixed bin (15) based;
      119 
      120 dcl      (
      121          first_base init (1),
      122          last_base init (6)
      123          ) fixed bin int static;
      124 
      125 dcl      load_pt init (60) fixed bin (15) int static;
      126 
      127 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
      128 
      129 
  2     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  2     2 
  2     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  2     4 
  2     5 dcl (	block_node		initial("000000001"b),
  2     6 	statement_node		initial("000000010"b),
  2     7 	operator_node		initial("000000011"b),
  2     8 	reference_node		initial("000000100"b),
  2     9 	token_node		initial("000000101"b),
  2    10 	symbol_node		initial("000000110"b),
  2    11 	context_node		initial("000000111"b),
  2    12 	array_node		initial("000001000"b),
  2    13 	bound_node		initial("000001001"b),
  2    14 	format_value_node		initial("000001010"b),
  2    15 	list_node			initial("000001011"b),
  2    16 	default_node		initial("000001100"b),
  2    17 	machine_state_node		initial("000001101"b),
  2    18 	source_node		initial("000001110"b),
  2    19 	label_node		initial("000001111"b),
  2    20 	cross_reference_node	initial("000010000"b),
  2    21 	sf_par_node		initial("000010001"b),
  2    22 	temporary_node		initial("000010010"b),
  2    23 	label_array_element_node	initial("000010011"b),
  2    24 	by_name_agg_node		initial("000010100"b))
  2    25 				bit(9) internal static aligned options(constant);
  2    26 
  2    27 dcl	1 node			based aligned,
  2    28 	2 type			unal bit(9),
  2    29 	2 source_id		unal structure,
  2    30 	  3 file_number		bit(8),
  2    31 	  3 line_number		bit(14),
  2    32 	  3 statement_number	bit(5);
  2    33 
  2    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
      130 
      131 
  3     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  3     2 
  3     3 dcl	1 reference		based aligned,
  3     4 	2 node_type		bit(9) unaligned,
  3     5 	2 array_ref		bit(1) unaligned,
  3     6 	2 varying_ref		bit(1) unaligned,
  3     7 	2 shared			bit(1) unaligned,
  3     8 	2 put_data_sw		bit(1) unaligned,
  3     9 	2 processed		bit(1) unaligned,
  3    10 	2 units			fixed(3) unaligned,
  3    11 	2 ref_count		fixed(17) unaligned,
  3    12 	2 c_offset		fixed(24),
  3    13 	2 c_length		fixed(24),
  3    14 	2 symbol			ptr unaligned,
  3    15 	2 qualifier		ptr unaligned,
  3    16 	2 offset			ptr unaligned,
  3    17 	2 length			ptr unaligned,
  3    18 						/* these fields are used by the 645 code generator */
  3    19 	2 c_f_offset		fixed bin(6),
  3    20 	2 address			structure unaligned,
  3    21 	  3 base			bit(3),
  3    22 	  3 offset		bit(15),
  3    23 	  3 op			bit(9),
  3    24 	  3 no_address		bit(1),
  3    25 	  3 inhibit		bit(1),
  3    26 	  3 ext_base		bit(1),
  3    27 	  3 tag			bit(6),
  3    28 	2 info			structure unaligned,
  3    29 	  3 address_in		structure,
  3    30 	    4 b			dimension(0:7) bit(1),
  3    31 	    4 storage		bit(1),
  3    32 	  3 value_in		structure,
  3    33 	    4 a			bit(1),
  3    34 	    4 q			bit(1),
  3    35 	    4 aq			bit(1),
  3    36 	    4 string_aq		bit(1),
  3    37 	    4 complex_aq		bit(1),
  3    38 	    4 decimal_aq		bit(1),
  3    39 	    4 b			dimension(0:7) bit(1),
  3    40 	    4 storage		bit(1),
  3    41 	    4 indicators		bit(1),
  3    42 	    4 x			dimension(0:7) bit(1),
  3    43 	  3 other			structure,
  3    44 	    4 big_offset		bit(1),
  3    45 	    4 big_length		bit(1),
  3    46 	    4 modword_in_offset	bit(1),
  3    47 	2 data_type		fixed(5) unaligned,
  3    48 	2 bits			structure unaligned,
  3    49 	  3 padded_ref		bit(1),
  3    50 	  3 aligned_ref		bit(1),
  3    51 	  3 long_ref		bit(1),
  3    52 	  3 forward_ref		bit(1),
  3    53 	  3 ic_ref		bit(1),
  3    54 	  3 temp_ref		bit(1),
  3    55 	  3 defined_ref		bit(1),
  3    56 	  3 evaluated		bit(1),
  3    57 	  3 allocate		bit(1),
  3    58 	  3 allocated		bit(1),
  3    59 	  3 aliasable		bit(1),
  3    60 	  3 even			bit(1),
  3    61 	  3 perm_address		bit(1),
  3    62 	  3 aggregate		bit(1),
  3    63 	  3 hit_zero		bit(1),
  3    64 	  3 dont_save		bit(1),
  3    65 	  3 fo_in_qual		bit(1),
  3    66 	  3 hard_to_load		bit(1),
  3    67 	2 relocation		bit(12) unaligned,
  3    68 	2 more_bits		structure unaligned,
  3    69 	  3 substr		bit(1),
  3    70 	  3 padded_for_store_ref	bit(1),
  3    71 	  3 aligned_for_store_ref	bit(1),
  3    72 	  3 mbz			bit(15),
  3    73 	2 store_ins		bit(18) unaligned;
  3    74 
  3    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
      132 
      133 
  4     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  4     2 
  4     3 dcl	1 symbol			based aligned,
  4     4 	2 node_type		bit(9) unal,
  4     5 	2 source_id		structure unal,
  4     6 	  3 file_number		bit(8),
  4     7 	  3 line_number		bit(14),
  4     8 	  3 statement_number	bit(5),
  4     9 	2 location		fixed(18) unal unsigned,
  4    10 	2 allocated		bit(1) unal,
  4    11 	2 dcl_type		bit(3) unal,
  4    12 	2 reserved		bit(6) unal,
  4    13 	2 pix			unal,
  4    14 	  3 pic_fixed		bit(1) unal,
  4    15 	  3 pic_float		bit(1) unal,
  4    16 	  3 pic_char		bit(1) unal,
  4    17 	  3 pic_scale		fixed(7) unal,
  4    18 	  3 pic_size		fixed(7) unal,
  4    19 	2 level			fixed(8) unal,
  4    20 	2 boundary		fixed(3) unal,
  4    21 	2 size_units		fixed(3) unal,
  4    22 	2 scale			fixed(7) unal,
  4    23 	2 runtime			bit(18) unal,
  4    24 	2 runtime_offset		bit(18) unal,
  4    25 	2 block_node		ptr unal,
  4    26 	2 token			ptr unal,
  4    27 	2 next			ptr unal,
  4    28 	2 multi_use		ptr unal,
  4    29 	2 cross_references		ptr unal,
  4    30 	2 initial			ptr unal,
  4    31 	2 array			ptr unal,
  4    32 	2 descriptor		ptr unal,
  4    33 	2 equivalence		ptr unal,
  4    34 	2 reference		ptr unal,
  4    35 	2 general			ptr unal,
  4    36 	2 father			ptr unal,
  4    37 	2 brother			ptr unal,
  4    38 	2 son			ptr unal,
  4    39 	2 word_size		ptr unal,
  4    40 	2 bit_size		ptr unal,
  4    41 	2 dcl_size		ptr unal,
  4    42 	2 symtab_size		ptr unal,
  4    43 	2 c_word_size		fixed(24),
  4    44 	2 c_bit_size		fixed(24),
  4    45 	2 c_dcl_size		fixed(24),
  4    46 
  4    47 	2 attributes		structure aligned,
  4    48 	  3 data_type		structure unal,
  4    49 	    4 structure		bit(1) ,
  4    50 	    4 fixed		bit(1),
  4    51 	    4 float		bit(1),
  4    52 	    4 bit			bit(1),
  4    53 	    4 char		bit(1),
  4    54 	    4 ptr			bit(1),
  4    55 	    4 offset		bit(1),
  4    56 	    4 area		bit(1),
  4    57 	    4 label		bit(1),
  4    58 	    4 entry		bit(1),
  4    59 	    4 file		bit(1),
  4    60 	    4 arg_descriptor	bit(1),
  4    61 	    4 storage_block		bit(1),
  4    62 	    4 explicit_packed	bit(1), /* options(packed) */
  4    63 	    4 condition		bit(1),
  4    64 	    4 format		bit(1),
  4    65 	    4 builtin		bit(1),
  4    66 	    4 generic		bit(1),
  4    67 	    4 picture		bit(1),
  4    68 
  4    69 	  3 misc_attributes		structure unal,
  4    70 	    4 dimensioned		bit(1),
  4    71 	    4 initialed		bit(1),
  4    72 	    4 aligned		bit(1),
  4    73 	    4 unaligned		bit(1),
  4    74 	    4 signed		bit(1),
  4    75 	    4 unsigned		bit(1),
  4    76 	    4 precision		bit(1),
  4    77 	    4 varying		bit(1),
  4    78 	    4 local		bit(1),
  4    79 	    4 decimal		bit(1),
  4    80 	    4 binary		bit(1),
  4    81 	    4 real		bit(1),
  4    82 	    4 complex		bit(1),
  4    83 	    4 variable		bit(1),
  4    84 	    4 reducible		bit(1),
  4    85 	    4 irreducible		bit(1),
  4    86 	    4 returns		bit(1),
  4    87 	    4 position		bit(1),
  4    88 	    4 internal		bit(1),
  4    89 	    4 external		bit(1),
  4    90 	    4 like		bit(1),
  4    91 	    4 member		bit(1),
  4    92 	    4 non_varying		bit(1),
  4    93 	    4 options		bit(1),
  4    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  4    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  4    96 
  4    97 	  3 storage_class		structure unal,
  4    98 	    4 auto		bit(1),
  4    99 	    4 based		bit(1),
  4   100 	    4 static		bit(1),
  4   101 	    4 controlled		bit(1),
  4   102 	    4 defined		bit(1),
  4   103 	    4 parameter		bit(1),
  4   104 	    4 param_desc		bit(1),
  4   105 	    4 constant		bit(1),
  4   106 	    4 temporary		bit(1),
  4   107 	    4 return_value		bit(1),
  4   108 
  4   109 	  3 file_attributes		structure unal,
  4   110 	    4 print		bit(1),
  4   111 	    4 input		bit(1),
  4   112 	    4 output		bit(1),
  4   113 	    4 update		bit(1),
  4   114 	    4 stream		bit(1),
  4   115 	    4 reserved_1		bit(1),
  4   116 	    4 record		bit(1),
  4   117 	    4 sequential		bit(1),
  4   118 	    4 direct		bit(1),
  4   119 	    4 interactive		bit(1),		/* env(interactive) */
  4   120 	    4 reserved_2		bit(1),
  4   121 	    4 reserved_3		bit(1),
  4   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  4   123 	    4 keyed		bit(1),
  4   124 	    4 reserved_4		bit(1),
  4   125 	    4 environment		bit(1),
  4   126 
  4   127 	  3 compiler_developed	structure unal,
  4   128 	    4 aliasable		bit(1),
  4   129 	    4 packed		bit(1),
  4   130 	    4 passed_as_arg		bit(1),
  4   131 	    4 allocate		bit(1),
  4   132 	    4 set			bit(1),
  4   133 	    4 exp_extents		bit(1),
  4   134 	    4 refer_extents		bit(1),
  4   135 	    4 star_extents		bit(1),
  4   136 	    4 isub		bit(1),
  4   137 	    4 put_in_symtab		bit(1),
  4   138 	    4 contiguous		bit(1),
  4   139 	    4 put_data		bit(1),
  4   140 	    4 overlayed		bit(1),
  4   141 	    4 error		bit(1),
  4   142 	    4 symtab_processed	bit(1),
  4   143 	    4 overlayed_by_builtin	bit(1),
  4   144 	    4 defaulted		bit(1),
  4   145 	    4 connected		bit(1);
  4   146 
  4   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
      134 
      135 
  5     1 /* BEGIN INCLUDE FILE ... temporary.incl.pl1 */
  5     2 
  5     3 dcl	1 temporary	based,
  5     4 	2 node_type	bit(9),	/* type is "000001010"b */
  5     5 	2 size		fixed bin(18),
  5     6 	2 next		ptr,
  5     7 	2 location	fixed bin(18),
  5     8 	2 ref_count	fixed bin,
  5     9 	2 symbol		ptr unal,
  5    10 	2 last_freed	fixed bin(18);
  5    11 
  5    12 /* END INCLUDE FILE ... temporary.incl.pl1 */
      136 
      137 
  6     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  6     2 
  6     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  6     4 
  6     5 /* format: style3 */
  6     6 dcl	1 operator	based aligned,
  6     7 	  2 node_type	bit (9) unaligned,
  6     8 	  2 op_code	bit (9) unaligned,
  6     9 	  2 shared	bit (1) unaligned,
  6    10 	  2 processed	bit (1) unaligned,
  6    11 	  2 optimized	bit (1) unaligned,
  6    12 	  2 number	fixed (14) unaligned,
  6    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  6    14 
  6    15 dcl	max_number_of_operands
  6    16 			fixed bin (15) int static options (constant) initial (32767);
  6    17 
  6    18 /* END INCLUDE FILE ... operator.incl.pl1 */
      138 
      139 
  7     1 /* BEGIN INCLUDE FILE ... block.incl.pl1 */
  7     2 /* Modified 22 Ocober 1980 by M. N. Davidoff to increase max block.number to 511 */
  7     3 /* format: style3,idind30 */
  7     4 
  7     5 declare	1 block			aligned based,
  7     6 	  2 node_type		bit (9) unaligned,
  7     7 	  2 source_id		structure unaligned,
  7     8 	    3 file_number		bit (8),
  7     9 	    3 line_number		bit (14),
  7    10 	    3 statement_number	bit (5),
  7    11 	  2 father		ptr unaligned,
  7    12 	  2 brother		ptr unaligned,
  7    13 	  2 son			ptr unaligned,
  7    14 	  2 declaration		ptr unaligned,
  7    15 	  2 end_declaration		ptr unaligned,
  7    16 	  2 default		ptr unaligned,
  7    17 	  2 end_default		ptr unaligned,
  7    18 	  2 context		ptr unaligned,
  7    19 	  2 prologue		ptr unaligned,
  7    20 	  2 end_prologue		ptr unaligned,
  7    21 	  2 main			ptr unaligned,
  7    22 	  2 end_main		ptr unaligned,
  7    23 	  2 return_values		ptr unaligned,
  7    24 	  2 return_count		ptr unaligned,
  7    25 	  2 plio_ps		ptr unaligned,
  7    26 	  2 plio_fa		ptr unaligned,
  7    27 	  2 plio_ffsb		ptr unaligned,
  7    28 	  2 plio_ssl		ptr unaligned,
  7    29 	  2 plio_fab2		ptr unaligned,
  7    30 	  2 block_type		bit (9) unaligned,
  7    31 	  2 prefix		bit (12) unaligned,
  7    32 	  2 like_attribute		bit (1) unaligned,
  7    33 	  2 no_stack		bit (1) unaligned,
  7    34 	  2 get_data		bit (1) unaligned,
  7    35 	  2 flush_at_call		bit (1) unaligned,
  7    36 	  2 processed		bit (1) unaligned,
  7    37 	  2 text_displayed		bit (1) unaligned,
  7    38 	  2 number		fixed bin (9) unsigned unaligned,
  7    39 	  2 free_temps		dimension (3) ptr,	/* these fields are used by the code generator */
  7    40 	  2 temp_list		ptr,
  7    41 	  2 entry_list		ptr,
  7    42 	  2 o_and_s		ptr,
  7    43 	  2 why_nonquick		aligned,
  7    44 	    3 auto_adjustable_storage bit (1) unaligned,
  7    45 	    3 returns_star_extents	bit (1) unaligned,
  7    46 	    3 stack_extended_by_args	bit (1) unaligned,
  7    47 	    3 invoked_by_format	bit (1) unaligned,
  7    48 	    3 format_statement	bit (1) unaligned,
  7    49 	    3 io_statements		bit (1) unaligned,
  7    50 	    3 assigned_to_entry_var	bit (1) unaligned,
  7    51 	    3 condition_statements	bit (1) unaligned,
  7    52 	    3 no_owner		bit (1) unaligned,
  7    53 	    3 recursive_call	bit (1) unaligned,
  7    54 	    3 options_non_quick	bit (1) unaligned,
  7    55 	    3 options_variable	bit (1) unaligned,
  7    56 	    3 never_referenced	bit (1) unaligned,
  7    57 	    3 pad_nonquick		bit (5) unaligned,
  7    58 	  2 prologue_flag		bit (1) unaligned,
  7    59 	  2 options_main		bit (1) unaligned,
  7    60 	  2 pad			bit (16) unaligned,
  7    61 	  2 number_of_entries	fixed bin (17),
  7    62 	  2 level			fixed bin (17),
  7    63 	  2 last_auto_loc		fixed bin (17),
  7    64 	  2 symbol_block		fixed bin (17),
  7    65 	  2 entry_info		fixed bin (18),
  7    66 	  2 enter			structure unaligned,
  7    67 	    3 start		fixed bin (17),
  7    68 	    3 end			fixed bin (17),
  7    69 	  2 leave			structure unaligned,
  7    70 	    3 start		fixed bin (17),
  7    71 	    3 end			fixed bin (17),
  7    72 	  2 owner			ptr;
  7    73 
  7    74 declare	max_block_number		fixed bin internal static options (constant) initial (511);
  7    75 
  7    76 /* END INCLUDE FILE ... block.incl.pl1 */
      140 
      141 
  8     1 /* BEGIN INCLUDE FILE relocation_bits.incl.pl1 */
  8     2 
  8     3 /* This include file defines the relocation bits as bit (6) entities.  See
  8     4*   also relbts.incl.pl1 and reloc_lower.incl.pl1. */
  8     5 
  8     6 dcl (	rc_a	initial("000000"b),		/* absolute */
  8     7 	rc_t	initial("010000"b),		/* text */
  8     8 	rc_nt	initial("010001"b),		/* negative text */
  8     9 	rc_lp18	initial("010010"b),		/* linkage, 18 bit */
  8    10 	rc_nlp18	initial("010011"b),		/* negative link, 18 bit */
  8    11 	rc_lp15	initial("010100"b),		/* linkage, 15 bit */
  8    12 	rc_dp	initial("010101"b),		/* def section */
  8    13 	rc_s	initial("010110"b),		/* symbol segment */
  8    14 	rc_ns	initial("010111"b),		/* negative symbol */
  8    15 	rc_is18	initial("011000"b),		/* internal static 18 */
  8    16 	rc_is15	initial("011001"b),		/* internal static 15 */
  8    17 	rc_lb	initial("011000"b),		/* link block */
  8    18 	rc_nlb	initial("011001"b),		/* negative link block */
  8    19 	rc_sr	initial("011010"b),		/* self relative */
  8    20 	rc_e	initial("011111"b))		/* escape */
  8    21 	bit(6) int static options(constant);
  8    22 
  8    23 /* END INCLUDE FILE relocation_bits.incl.pl1 */
      142 
      143 
  9     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
  9     2 
  9     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
  9     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
  9     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
  9     6 /* Modified: 26 July 82 BIM wordno, segno */
  9     7 
  9     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
  9     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
  9    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
  9    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
  9    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
  9    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
  9    14 
  9    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
  9    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
  9    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
  9    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
  9    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
  9    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
  9    21 
  9    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
  9    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
  9    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
  9    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
  9    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
  9    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
  9    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
  9    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
  9    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
  9    31 
  9    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
  9    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
  9    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
  9    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
  9    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
  9    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
  9    38 
  9    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
  9    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
  9    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
  9    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
  9    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
  9    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
  9    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
  9    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
  9    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
  9    48 
  9    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
  9    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
  9    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
  9    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
  9    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
  9    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
  9    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
  9    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
  9    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
  9    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
  9    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
  9    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
  9    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
  9    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
  9    63 
  9    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
  9    65*						   opnd(2) <- opnd(3) / 36		*/
  9    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
  9    67*						   opnd(2) <- opnd(3) / 4		*/
  9    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
  9    69*						   opnd(2) <- opnd(3) / 2		*/
  9    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
  9    71 
  9    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
  9    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
  9    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
  9    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
  9    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
  9    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
  9    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
  9    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
  9    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
  9    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
  9    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
  9    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
  9    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
  9    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
  9    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
  9    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
  9    88 
  9    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
  9    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
  9    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
  9    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
  9    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
  9    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
  9    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
  9    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
  9    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
  9    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
  9    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
  9   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
  9   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
  9   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
  9   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
  9   104 
  9   105 	index_fun		initial("010100000"b),	/* opnd(1) <- index(opnd(2),opnd(3))	*/
  9   106 	off_fun		initial("010100001"b),	/* opnd(1) <- offset(opnd(2),opnd(3))	*/
  9   107 	complex_fun	initial("010100010"b),	/* opnd(1) <- complex(opnd(2),opnd(3))	*/
  9   108 	conjg_fun		initial("010100011"b),	/* opnd(1) <- conjg(opnd(2),opnd(3))	*/
  9   109 	mod_fun		initial("010100100"b),	/* opnd(1) <- mod(opnd(2),opnd(3))	*/
  9   110 	repeat_fun	initial("010100101"b),	/* opnd(1) <- repeat(opnd(2),opnd(3))	*/
  9   111 	verify_fun	initial("010100110"b),	/* opnd(1) <- verify(opnd(2),opnd(3))	*/
  9   112 	translate_fun	initial("010100111"b),	/* opnd(1) <- translate(opnd(2),opnd(3))*/
  9   113 	real_fun   	initial("010101001"b),	/* opnd(1) <- real(opnd(2))		*/
  9   114 	imag_fun   	initial("010101010"b),	/* opnd(1) <- imag(opnd(2))		*/
  9   115 	length_fun	initial("010101011"b),	/* opnd(1) <- length(opnd(2))	*/
  9   116 	pl1_mod_fun	initial("010101100"b),	/* opnd(1) <- mod(opnd(2)) */
  9   117 	search_fun	initial("010101101"b),	/* opnd(1) <- search(opnd(2),opnd(3)) */
  9   118 	allocation_fun	initial("010101110"b),	/* opnd(1) <- allocation(opnd(2)) */
  9   119 	reverse_fun	initial("010101111"b),	/* opnd(1) <- reverse(opnd(2)) */
  9   120 
  9   121 	addr_fun		initial("010110000"b),	/* opnd(1) <- addr(opnd(2))		*/
  9   122 	addr_fun_bits	initial("010110001"b),	/* opnd(1) <- addr(opnd(2))		*/
  9   123 	ptr_fun		initial("010110010"b),	/* opnd(1) <- ptr(opnd(2),opnd(3))	*/
  9   124 	baseptr_fun	initial("010110011"b),	/* opnd(1) <- baseptr(opnd(2))	*/
  9   125 	addrel_fun	initial("010110100"b),	/* opnd(1) <- addrel(opnd(2),opnd(3))	*/
  9   126 	codeptr_fun	initial("010110101"b),	/* opnd(1) <- codeptr(opnd(2))	*/
  9   127 	environmentptr_fun	initial("010110110"b),	/* opnd(1) <- environmentptr(opnd(2))	*/
  9   128 	stackbaseptr_fun	initial("010110111"b),	/* opnd(1) is ptr to base of current stack	*/
  9   129 	stackframeptr_fun	initial("010111000"b),	/* opnd(1) is ptr to current block's stack frame	*/
  9   130 	setcharno_fun	initial("010111001"b),	/* opnd(1) <- opnd(2) with charno opnd(3) */
  9   131 	addcharno_fun	initial("010111010"b),	/* opnd(1) <- opnd(2) with charno = charno + opnd(3) */
  9   132 	setbitno_fun	initial("010111011"b),	/* setcharno for bitsno */
  9   133 	addbitno_fun	initial("010111100"b),	/* addcharno for bitno */
  9   134 
  9   135 	min_fun		initial("011000000"b),	/* opnd(1) <- min(opnd(1),opnd(2),...)	*/
  9   136 	max_fun		initial("011000001"b),	/* opnd(1) <- max(opnd(1),opnd(2),...)	*/
  9   137 
  9   138 	stack_ptr		initial("011010001"b),	/* opnd(1) <- stack frame ptr		*/
  9   139 	empty_area	initial("011010010"b),	/* empty opnd(1), length in words is opnd(2) */
  9   140 	enable_on		initial("011010100"b),	/* opnd(1) is the cond name
  9   141*						   opnd(2) is the file name
  9   142*						   opnd(3) is the block	*/
  9   143 	revert_on		initial("011010101"b),	/* opnd(1) is the cond name,
  9   144*						   opnd(2) is the file name	*/
  9   145 	signal_on		initial("011010110"b),	/* opnd(1) is the cond name
  9   146*						   opnd(2) is the file name */
  9   147 
  9   148 	lock_fun		initial("011010111"b),	/* opnd(1) <- stac(opnd(2),opnd(3))	*/
  9   149 	stacq_fun		initial("011011000"b),	/* opnd(1) is result, opnd(2) is ptr to lock word,
  9   150*						   opnd(3) is old value, (4) is new value. */
  9   151 	clock_fun		initial("011011001"b),	/* opnd(1) is the clock time		*/
  9   152 	vclock_fun	initial("011011010"b),	/* opnd(1) is the virtual clock time	*/
  9   153 
  9   154 	bound_ck		initial("011100000"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  9   155 	range_ck		initial("011100001"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  9   156 	loop		initial("011100010"b),	/* do opnd(1) for opnd(2) from opnd(3) to opnd(4) by 1,
  9   157*						   opnd(5) is the list */
  9   158 	join		initial("011100011"b),	/* do opnd(1), opnd(2) ... opnd(n)	*/
  9   159 	allot_based	initial("011100100"b),	/* allocate opnd(2) words in opnd(3), set opnd(1) */
  9   160 	free_based	initial("011100101"b),	/* free opnd(1) in opnd(3), length is opnd(2) words */
  9   161 
  9   162 	r_parn		initial("011110001"b),	/* format op code			*/
  9   163 	l_parn		initial("011110010"b),
  9   164 	r_format		initial("011110011"b),
  9   165 	c_format		initial("011110100"b),
  9   166 	f_format		initial("011110101"b),
  9   167 	e_format		initial("011110110"b),
  9   168 	b_format		initial("011110111"b),
  9   169 	a_format		initial("011111000"b),
  9   170 	x_format		initial("011111001"b),
  9   171 	skip_format	initial("011111010"b),
  9   172 	column_format	initial("011111011"b),
  9   173 	page_format	initial("011111100"b),
  9   174 	line_format	initial("011111101"b),
  9   175 	picture_format	initial("011111110"b),
  9   176 	bn_format		initial("011111111"b),	/* bit format, length(opnd(2)), radix factor(opnd(3)) */
  9   177 
  9   178 	get_list_trans	initial("100000000"b),	/* getlist(opnd(2) with desc(opnd(1)))	*/
  9   179 	get_edit_trans	initial("100000001"b),	/* getedit(opnd(2) with desc(opnd(1)))	*/
  9   180 	get_data_trans	initial("100000010"b),	/* getdata(opnd(1) to opnd(n))	*/
  9   181 	put_list_trans	initial("100000011"b),	/* putlist(opnd(2) with desc(opnd(1)))	*/
  9   182 	put_edit_trans	initial("100000100"b),	/* putedit(opnd(2) with desc(opnd(1)))	*/
  9   183 	put_data_trans	initial("100000101"b),	/* putdata(opnd(2)) with subscript-list opnd(1) */
  9   184 	terminate_trans	initial("100000110"b),	/* terminate stream transmission	*/
  9   185 	stream_prep	initial("100000111"b),	/* initiate stream transmission	*/
  9   186 	record_io		initial("100001000"b),	/* perform record io operation	*/
  9   187 	fortran_read	initial("100001001"b),	/* A complete read statement		*/
  9   188 	fortran_write	initial("100001010"b),	/* A complete write statement		*/
  9   189 	ftn_file_manip	initial("100001011"b),	/* endfile,backspace,rewind,etc.	*/
  9   190 	ftn_trans_loop	initial("100001100"b),	/* An implied do in i/o list		*/
  9   191 	put_control	initial("100001101"b),	/* put control opnd(1) opnd(2) times	*/
  9   192 	put_field		initial("100001110"b),	/* putlist(opnd(2)) of length(opnd(1))	*/
  9   193 	put_field_chk	initial("100001111"b),	/* putlist(op(2)) of len(op(1)) check char index(op(3)) */
  9   194 
  9   195 /* These operators are produced by the parse but are not used as input to the code generator.	*/
  9   196 /* They are processed by the semantic translator.						*/
  9   197 
  9   198 	return_value	initial("100010010"b),	/* return(opnd(1))			*/
  9   199 	allot_var		initial("100010011"b),	/* allot opnd(1) in opnd(2)		*/
  9   200 	free_var		initial("100010100"b),	/* free opnd(1) out of opnd(2)	*/
  9   201 	get_file		initial("100010101"b),	/* opnd(1) is filename,opnd(2) is copy	*/
  9   202 						/* opnd(3) is skip, opnd(4) is list	*/
  9   203 	get_string	initial("100010110"b),	/* opnd(1) is string,opnd(2) is list	*/
  9   204 	put_file		initial("100010111"b),	/* opnd(1) is filename,opnd(2) is page	*/
  9   205 						/* opnd(3) is skip,opnd(4) is line	*/
  9   206 	put_string	initial("100011000"b),	/* opnd(1) is string,opnd(2) is list	*/
  9   207 	open_file		initial("100011001"b),
  9   208 	close_file	initial("100011010"b),
  9   209 	read_file		initial("100011011"b),
  9   210 	write_file	initial("100011100"b),
  9   211 	locate_file	initial("100011101"b),
  9   212 	do_fun		initial("100011110"b),	/* opnd(1) is join of a list		*/
  9   213 						/* opnd(2) is control variable ref	*/
  9   214 						/* opnd(3) is specification operator	*/
  9   215 	do_spec		initial("100011111"b),	/* opnd(1) to opnd(2) by opnd(3) 	*/
  9   216 						/* repeat opnd(4) while opnd(5)	*/
  9   217 						/* opnd(6) is next specification	*/
  9   218 
  9   219 	rewrite_file	initial("100100000"b),
  9   220 	delete_file	initial("100100001"b),
  9   221 	unlock_file	initial("100100010"b),
  9   222 	lock_file		initial("100100011"b),
  9   223 	refer		initial("100100101"b),	/* opnd(1) refer(opnd(2))		*/
  9   224 	prefix_plus	initial("100100110"b),	/* opnd(1) <- +opnd(2)		*/
  9   225 	nop		initial("100100111"b),	/* no-op */
  9   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
  9   227 
  9   228 /* These operators are produced by the semantic translator in processing the math
  9   229*   builtin functions and are used as input to the code generator			*/
  9   230 
  9   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
  9   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
  9   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
  9   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
  9   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
  9   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
  9   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
  9   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
  9   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
  9   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
  9   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
  9   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
  9   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
  9   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
  9   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
  9   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
  9   247 
  9   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
  9   249 
  9   250 			bit(9) aligned internal static options(constant);
  9   251 
  9   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
      144 
      145 
 10     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
 10     2 	options(constant);
 10     3 
 10     4 dcl (	ap	defined(bases(0)),
 10     5 	bp	defined(bases(1)),
 10     6 	lp	defined(bases(2)),
 10     7 	sp	defined(bases(7))) bit(3) aligned;
 10     8 
 10     9 dcl (	ab	defined(bases(3)),
 10    10 	bb	defined(bases(4)),
 10    11 	lb	defined(bases(5)),
 10    12 	sb	defined(bases(6))) bit(3) aligned;
 10    13 
 10    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
      146 
      147 
 11     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
 11     2 
 11     3 dcl	cg_static_$m_s_p ptr ext static,
 11     4 	m_s_p ptr init(cg_static_$m_s_p);
 11     5 
 11     6 dcl	1 machine_state	aligned based(m_s_p),
 11     7 	2 node_type	bit(9),
 11     8 	2 indicators	fixed bin,
 11     9 	2 next		ptr unal,
 11    10 	2 a_reg,
 11    11 	  3 variable(10)	ptr unal,
 11    12 	  3 number	fixed bin(17),
 11    13 	  3 size		fixed bin(8),
 11    14 	  3 length	fixed bin(8),
 11    15 	  3 offset	fixed bin(8),
 11    16 	  3 constant	fixed bin(24),
 11    17 	  3 changed	fixed bin(18),
 11    18 	  3 instruction	bit(36),
 11    19 	  3 locked	bit(1) aligned,
 11    20 	  3 number_h_o	fixed bin,
 11    21 	  3 has_offset(3)	ptr unal,
 11    22 	2 q_reg,
 11    23 	  3 variable(10)	ptr unal,
 11    24 	  3 number	fixed bin(17),
 11    25 	  3 size		fixed bin(8),
 11    26 	  3 length	fixed bin(8),
 11    27 	  3 offset	fixed bin(8),
 11    28 	  3 constant	fixed bin(24),
 11    29 	  3 changed	fixed bin(18),
 11    30 	  3 instruction	bit(36),
 11    31 	  3 locked	bit(1) aligned,
 11    32 	  3 number_h_o	fixed bin,
 11    33 	  3 has_offset(3)	ptr unal,
 11    34 	2 string_reg,
 11    35 	  3 variable	ptr unal,
 11    36 	  3 size		fixed bin(8),
 11    37 	  3 offset	fixed bin(8),
 11    38 	2 complex_reg,
 11    39 	  3 variable	ptr unal,
 11    40 	  3 size		fixed bin(8),
 11    41 	  3 scale		fixed bin(8),
 11    42 	2 decimal_reg,
 11    43 	  3 variable	ptr unal,
 11    44 	  3 size		fixed bin(8),
 11    45 	  3 scale		fixed bin(8),
 11    46 	2 index_regs(0:7),
 11    47 	  3 variable	ptr unal,
 11    48 	  3 constant	fixed bin,
 11    49 	  3 type		fixed bin(8),
 11    50 	  3 used		fixed bin(18),
 11    51 	  3 changed	fixed bin(18),
 11    52 	  3 instruction	bit(36),
 11    53 	  3 filler	fixed bin,
 11    54 	2 base_regs(0:7),
 11    55 	  3 variable	ptr unal,
 11    56 	  3 constant	fixed bin,
 11    57 	  3 type		fixed bin(8),
 11    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
 11    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
 11    60 	  3 used		fixed bin(18),
 11    61 	  3 changed	fixed bin(18),
 11    62 	  3 instruction	bit(36),
 11    63 	  3 locked	fixed bin(2),
 11    64 	2 indicators_ref(2:3) ptr unal;
 11    65 
 11    66 /* Permissible values for machine_state.indicators. */
 11    67 
 11    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
 11    69 	ind_invalid	init (-1),
 11    70 	ind_string_aq	init (0),			/* logical value in storage */
 11    71 	ind_logical	init (1),			/* logical value in A or AQ */
 11    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
 11    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
 11    74 	ind_decimal_reg	init (14)
 11    75 	) fixed bin internal static options (constant);
 11    76 
 11    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
      148 
      149 
 12     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
 12     2 
 12     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
 12     4 
 12     5 dcl (	bit_		init(1),
 12     6 	digit_		init(2),
 12     7 	character_	init(3),
 12     8 	half_		init(4),
 12     9 	word_		init(5),
 12    10 	mod2_		init(6),
 12    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
 12    12 
 12    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
      150 
      151 
      152 /* program */
      153 
      154 	no_ind = substr (bits, 1, 1);
      155 	eis = substr (bits, 2, 1);
      156 
      157 	ref, r1 = pt;
      158 	if ^ref -> reference.no_address then
      159 	     if ref -> reference.perm_address then
      160 		if no_ind then
      161 		     goto test1;
      162 		else
      163 		     return;
      164 
      165 	dont_load, ref -> reference.even, ref -> reference.forward_ref, ref -> reference.ic_ref,
      166 	     ref -> reference.relocation, string (ref -> reference.address) = "0"b;
      167 
      168 	ref -> reference.c_f_offset = 0;
      169 
      170 	s1 = ref -> reference.symbol;
      171 
      172 /* check for address already in a base register 
      173*	   (we skip this code for temporaries so that
      174*	    store$save_string_temp works)	        */
      175 
      176 	if ^ref -> reference.temp_ref then do;
      177 
      178 	     if string (ref -> reference.address_in.b) then
      179 		do i = first_base to last_base;
      180 		     if ref -> reference.address_in.b (i) then do;
      181 			ref -> reference.base = bases (i);
      182 			ref -> reference.ext_base = "1"b;
      183 			base_regs (i).used = cg_stat$text_pos;
      184 			return;
      185 		     end;
      186 		end;
      187 
      188 	end;
      189 
      190 	locked, reloc = "0"b;
      191 
      192 /* get variable word offset */
      193 
      194 	call get_vwo (ref);
      195 
      196 	word_offset, fract_offset = 0;
      197 	call get_c_offset;
      198 
      199 	if ^eis then
      200 	     fok = "1"b;
      201 	else
      202 	     fok = fract_offset = 0 & ^(no_ind & vwo ^= null);
      203 
      204 	if ref -> reference.temp_ref then do;
      205 
      206 temp:
      207 	     if r1 -> reference.aggregate then do;
      208 		if s1 -> symbol.varying then
      209 		     word_offset = word_offset + 1;
      210 
      211 /* if the temp aggregate is a structure, we want to allocate
      212*		   the level 1 temporary instead of the descendant */
      213 
      214 		p1 = s1;
      215 		do while (p1 -> symbol.father ^= null);
      216 		     p1 = p1 -> symbol.father;
      217 		end;
      218 
      219 		if p1 -> symbol.initial = null then
      220 		     call stack_temp$assign_aggregate (p1);
      221 
      222 		p2 = p1 -> symbol.initial;
      223 
      224 		if p1 -> symbol.word_size = null then do;
      225 		     word_offset = word_offset + p2 -> temporary.location;
      226 		     goto lv;
      227 		end;
      228 
      229 		call load_vwo;
      230 
      231 		if word_offset = 0 & fok & abs (p2 -> temporary.location) < 16384 then do;
      232 		     tag = tagind;
      233 		     word_offset = p2 -> temporary.location;
      234 		     goto t1;
      235 		end;
      236 
      237 		ref -> address.base = base_man$load_stack_indirect (p2 -> temporary.location);
      238 		goto so1;
      239 	     end;
      240 
      241 	     if r1 -> reference.address_in.storage then do;
      242 		if r1 -> reference.allocated then
      243 		     if r1 -> reference.qualifier ^= null then
      244 			ind_word = r1 -> reference.qualifier -> temporary.location;
      245 		     else
      246 			goto err330;
      247 		else if r1 -> reference.value_in.string_aq then
      248 		     ind_word = fixed (cg_stat$long_string_temp -> address.offset, 15);
      249 		else do;
      250 err330:
      251 		     call error (330, cg_stat$cur_statement, r1);
      252 		     return;
      253 		end;
      254 		if word_offset = 0 & fok then do;
      255 		     r1 -> reference.even = "1"b;
      256 		     word_offset = ind_word;
      257 		     call load_vwo;
      258 		     tag = tag | substr (ri_mod, 1, 2);
      259 		     goto t1;
      260 		end;
      261 		else do;
      262 		     call load_vwo;
      263 		     ref -> address.base = base_man$load_stack_indirect (ind_word);
      264 		     goto so;
      265 		end;
      266 	     end;
      267 
      268 	     if ^r1 -> reference.allocated then do;
      269 		if ^r1 -> reference.allocate then
      270 		     ref, r1, pt = copy_temp (r1);
      271 		call stack_temp$assign_temp (r1);
      272 	     end;
      273 	     else if r1 -> reference.qualifier = null then do;
      274 		call error (316, cg_stat$cur_statement, r1);
      275 		return;
      276 	     end;
      277 
      278 	     word_offset = word_offset + r1 -> reference.qualifier -> temporary.location;
      279 	     goto lv;
      280 	end;
      281 
      282 	p1 = ref -> reference.qualifier;
      283 
      284 	if s1 -> node.type ^= symbol_node then
      285 	     goto dr;
      286 
      287 	if s1 -> symbol.return_value then do;
      288 
      289 	     do p2 = s1 repeat p2 -> symbol.father while (p2 -> symbol.father ^= null);
      290 	     end;
      291 
      292 	     p1 = p2 -> symbol.initial;
      293 
      294 	     if p1 ^= null /* not 1st reference */ then do;
      295 		if s1 -> symbol.varying then
      296 		     if s1 -> symbol.dimensioned | s1 -> symbol.member then
      297 			word_offset = word_offset + 1;
      298 		call load_vwo;
      299 
      300 		if word_offset = 0 & fok & abs (p1 -> temporary.location) < 16384 then do;
      301 		     word_offset = p1 -> temporary.location;
      302 		     tag = tagind;
      303 		end;
      304 		else do;
      305 		     ref -> address.base = base_man$load_stack_indirect (p1 -> temporary.location);
      306 		     goto so1;
      307 		end;
      308 
      309 	     end;
      310 	     else do;				/* p1 is NULL */
      311 
      312 /* 1st reference, get 2 word slot to hold ptr to datum */
      313 
      314 		call stack_temp$assign_return_value (p2);
      315 		p1 = p2 -> symbol.initial;
      316 		word_offset = p1 -> temporary.location;
      317 		call load_vwo;
      318 
      319 /* the stack will get extended when call is made to the procedure
      320*returning the star extent value, so turn the bit on now */
      321 
      322 		cg_stat$extended_stack = "1"b;
      323 	     end;
      324 
      325 	     goto t1;
      326 	end;
      327 
      328 dr:
      329 	if ref -> reference.defined_ref then do;
      330 	     if p1 = null then do;			/* write file (afile) from (thing); where "thing" is a defined  structure */
      331 		p1 = s1 -> symbol.reference -> reference.qualifier;
      332 	     end;
      333 
      334 	     r1 = p1;
      335 
      336 l0:
      337 	     if r1 -> node.type = operator_node then
      338 		r1 = r1 -> operand (1);
      339 
      340 	     if r1 -> reference.defined_ref then do;
      341 		r1 = r1 -> reference.qualifier;
      342 		goto l0;
      343 	     end;
      344 
      345 	     if s1 -> symbol.varying & s1 -> symbol.member then
      346 		word_offset = word_offset + 1;
      347 
      348 l0b:
      349 	     s1 = r1 -> reference.symbol;
      350 
      351 	     if r1 -> reference.temp_ref & r1 -> reference.address_in.storage then
      352 		goto l0a;
      353 
      354 	     if s1 -> symbol.return_value then
      355 		goto l0a;
      356 
      357 	     if vwo = null & ref -> reference.units = r1 -> reference.units then
      358 		call get_vwo (r1);
      359 	     else if r1 -> reference.offset ^= null then do;
      360 l0a:
      361 		if ^r1 -> reference.shared then
      362 		     r1 -> reference.ref_count = r1 -> reference.ref_count + 1;
      363 		ref -> address.base = base_man$load_any_var (2, r1);
      364 		call load_vwo;
      365 		goto so1;
      366 	     end;
      367 
      368 	     call get_c_offset;
      369 
      370 	     if r1 -> reference.temp_ref then
      371 		goto temp;
      372 
      373 	     p1 = r1 -> reference.qualifier;
      374 	end;
      375 
      376 	if p1 ^= null then
      377 	     goto have_qual;
      378 
      379 	if s1 -> node.type = label_node then
      380 	     goto lv;
      381 
      382 	if s1 -> symbol.constant then do;
      383 	     if s1 -> symbol.varying then
      384 		word_offset = word_offset + 1;
      385 	     if s1 -> symbol.file & s1 -> symbol.internal then
      386 		word_offset = word_offset + s1 -> symbol.location;
      387 	     goto lv;
      388 	end;
      389 
      390 	if s1 -> symbol.parameter | s1 -> symbol.param_desc then do;
      391 	     p1 = s1 -> symbol.reference -> reference.qualifier;
      392 	     goto have_qual;
      393 	end;
      394 
      395 	if r1 -> reference.temp_ref then
      396 	     word_offset = word_offset + r1 -> reference.qualifier -> temporary.location;
      397 	else if ^(s1 -> symbol.static & s1 -> symbol.external | s1 -> symbol.controlled) then
      398 	     word_offset = word_offset + s1 -> symbol.location;
      399 
      400 	if s1 -> symbol.varying then
      401 	     if s1 -> symbol.auto | s1 -> symbol.static | s1 -> symbol.controlled then
      402 		word_offset = word_offset + 1;
      403 
      404 /* load variable word offset into an index register and reduce
      405*	   word offset to a value less than 16384 */
      406 
      407 lv:
      408 	call load_vwo;
      409 
      410 	if s1 ^= null then
      411 	     if s1 -> node.type = label_node then
      412 		goto l3a;
      413 
      414 	if r1 -> reference.temp_ref then do;
      415 t1:
      416 	     ref -> address.base = sp;
      417 	     goto so;
      418 	end;
      419 
      420 	if s1 -> symbol.auto then do;
      421 
      422 	     k = cg_stat$cur_level - s1 -> symbol.block_node -> block.level;
      423 	     if k = 0 then
      424 		goto t1;
      425 
      426 /* load ptr to display(k) level back */
      427 
      428 	     ref -> address.base = base_man$load_display (k);
      429 
      430 so:
      431 	     if tag = "000000"b then
      432 		ref -> reference.even = mod (word_offset, 2) = 0;
      433 
      434 so1:
      435 	     ref -> address.offset = bit (word_offset, 15);
      436 	     if eis then
      437 		ref -> reference.c_f_offset = fract_offset;
      438 
      439 	     ref -> address.tag = tag;
      440 	     ref -> reference.relocation = reloc;
      441 
      442 seteb1:
      443 	     ref -> address.ext_base = "1"b;
      444 
      445 /* if no indirection is permitted, we may have to generate a
      446*	        ptr to the reference in a base register */
      447 
      448 	     if no_ind then do;
      449 
      450 test1:
      451 		if substr (ref -> address.tag, 1, 2) = "00"b then
      452 		     return;
      453 
      454 /* we have to load pointer to reference into a base to get rid
      455*		   of indirection, but we don't want to count this as a reference */
      456 
      457 		ref -> reference.perm_address = "1"b;
      458 
      459 call_baseman:
      460 		if ^ref -> reference.shared then
      461 		     ref -> reference.ref_count = ref -> reference.ref_count + 1;
      462 
      463 		base = base_man$load_any_var (2, ref);
      464 
      465 		ref -> address.ext_base = "1"b;
      466 		ref -> address.base = base;
      467 
      468 		ref -> reference.c_f_offset = 0;
      469 		ref -> address.tag, ref -> address.offset, ref -> reference.perm_address = "0"b;
      470 
      471 	     end;
      472 
      473 	     return;
      474 	end;
      475 
      476 	if s1 -> symbol.static then do;
      477 
      478 	     if s1 -> symbol.internal then do;
      479 is:
      480 		reloc = rc_is15;
      481 		ref -> address.base = base_man$load_static ();
      482 		goto so;
      483 	     end;
      484 
      485 /* external static or reference to link */
      486 
      487 lr:
      488 	     reloc = rc_lp15;
      489 	     base_man_link_or_static = base_man$load_linkage;
      490 
      491 lr1:
      492 	     if word_offset = 0 & fok then do;
      493 
      494 		off = s1 -> symbol.location;
      495 		if off >= 16384 then do;
      496 		     if tag ^= (6)"0"b then
      497 			goto gen;
      498 
      499 		     multiple = off - mod (off, 16384);
      500 		     call xr_man$load_any_const (multiple, xr);
      501 		     tagind = ri_mod || bit (xr, 3);
      502 
      503 		     off = off - multiple;
      504 		end;
      505 
      506 		ref -> address.base = base_man_link_or_static ();
      507 		ref -> reference.relocation = reloc;
      508 		ref -> address.offset = bit (fixed (off, 15), 15);
      509 es:
      510 		ref -> reference.tag = tagind;
      511 		goto seteb1;
      512 	     end;
      513 
      514 /* generate an instruction of the form
      515*			eapbp	lp|k,*
      516*	        where 'k' is offset of link */
      517 
      518 gen:
      519 	     ref -> address.base = base_man$load_link_indirect ((s1 -> symbol.location), reloc);
      520 	     reloc = "0"b;
      521 	     goto so1;
      522 	end;
      523 
      524 	if s1 -> symbol.constant then do;
      525 
      526 	     if s1 -> symbol.entry then
      527 		if s1 -> symbol.initial ^= null | s1 -> symbol.internal then
      528 		     goto l3a;
      529 		else
      530 		     goto lr;
      531 
      532 	     if s1 -> symbol.external then
      533 		goto lr;
      534 
      535 	     if s1 -> symbol.file then
      536 		goto is;
      537 
      538 	     if s1 -> symbol.equivalence ^= null then
      539 		s1 = s1 -> symbol.equivalence;
      540 
      541 l3a:
      542 	     if ^s1 -> symbol.allocated then do;
      543 		ref -> reference.forward_ref = "1"b;
      544 
      545 		if tag ^= "000000"b | word_offset ^= 0 then do;
      546 		     p1 = s1 -> symbol.reference;
      547 		     if p1 -> reference.data_type = 0 then
      548 			p1 = prepare_operand (p1, 0, useless);
      549 		     ref -> address.base = base_man$load_any_var (2, p1);
      550 		     goto so1;
      551 		end;
      552 
      553 		if s1 -> node.type = symbol_node then
      554 		     if s1 -> symbol.c_word_size = 2 | s1 -> symbol.boundary = mod2_ then
      555 			ref -> reference.even = "1"b;
      556 
      557 		goto l3b;
      558 	     end;
      559 
      560 /* the constant reference occurs earlier in text section */
      561 
      562 	     word_offset = word_offset + s1 -> symbol.location;
      563 
      564 	     if tag = "000000"b then do;
      565 		ref -> reference.even = mod (word_offset, 2) = 0;
      566 l3b:
      567 		ref -> reference.ic_ref = "1"b;
      568 		ref -> address.tag = "000100"b;	/* IC */
      569 	     end;
      570 	     else do;
      571 		ref -> reference.relocation = rc_t;
      572 		ref -> address.tag = tag;
      573 	     end;
      574 
      575 /* put an 18 bit offset into the address */
      576 
      577 	     substr (string (ref -> reference.address), 1, 18) = bit (fixed (word_offset, 18), 18);
      578 	     if eis then
      579 		ref -> reference.c_f_offset = fract_offset;
      580 	     return;
      581 	end;
      582 
      583 	if s1 -> symbol.controlled then do;
      584 
      585 	     if tag = "0"b then
      586 		ref -> reference.even = mod (word_offset, 2) = 0;
      587 
      588 	     if s1 -> symbol.internal then do;
      589 		reloc = rc_is15;
      590 		base_man_link_or_static = base_man$load_static;
      591 		goto lr1;
      592 	     end;
      593 
      594 /* external controlled */
      595 
      596 	     delta = 2 * fixed (s1 -> symbol.arg_descriptor, 1);
      597 
      598 	     if word_offset = 0 & fok then do;
      599 		ref -> address.base = base_man$load_link_indirect ((s1 -> symbol.location), (rc_lp15));
      600 		ref -> address.offset = bit (delta, 15);
      601 		ref -> address.tag = tagind;
      602 	     end;
      603 	     else do;
      604 		ref -> address.base = base_man$load_controlled ((s1 -> symbol.location), delta);
      605 		ref -> address.offset = bit (word_offset, 15);
      606 		ref -> address.tag = tag;
      607 		if eis then
      608 		     ref -> reference.c_f_offset = fract_offset;
      609 	     end;
      610 
      611 	     goto seteb1;
      612 	end;
      613 
      614 /* ERROR */
      615 
      616 	call cg_error (305, fixed (string (s1 -> symbol.storage_class), 10));
      617 	goto t1;
      618 
      619 /* have a qualifier */
      620 
      621 have_qual:
      622 	if s1 -> symbol.varying then
      623 	     if s1 -> symbol.based | (s1 -> symbol.auto & s1 -> symbol.exp_extents) | s1 -> symbol.member then
      624 		word_offset = word_offset + 1;
      625 
      626 	if eis then
      627 	     if ref -> reference.units = word_ then
      628 		if abs (word_offset) >= 16384 then
      629 		     goto call_baseman;
      630 
      631 	if p1 -> node.type = reference_node then
      632 	     goto l5;
      633 
      634 	op_code = p1 -> operator.op_code;
      635 
      636 	if op_code = addr_fun then do;
      637 	     if p1 -> operand (1) -> reference.evaluated then
      638 		goto l4a;
      639 
      640 	     r1 = p1 -> operand (2);
      641 
      642 	     if r1 -> reference.varying_ref then
      643 		word_offset = word_offset - 1;
      644 
      645 	     if r1 -> reference.defined_ref then
      646 		goto l0a;
      647 	     goto l0b;
      648 	end;
      649 
      650 	if op_code = param_ptr then do;
      651 	     i = 0;				/* load arg ptr */
      652 	     goto l4;
      653 	end;
      654 
      655 	if op_code = param_desc_ptr then do;
      656 	     i = 1;				/* load desc ptr */
      657 
      658 l4:
      659 	     call load_vwo;
      660 
      661 	     q = p1 -> operand (3);
      662 	     k = p1 -> operand (2) -> reference.symbol -> symbol.initial -> fix_bin;
      663 
      664 	     if word_offset = 0 & fok & ^no_ind then do;
      665 		ref -> address.base = base_man$load_arg (i, q);
      666 		ref -> address.offset = bit (fixed (2 * (k - i), 15), 15);
      667 		goto es;
      668 	     end;
      669 
      670 	     ref -> address.base = base_man$load_arg_ptr (i, q, k);
      671 	     goto so1;
      672 	end;
      673 
      674 /* the operator is not a special one, so it must have been
      675*	   evaluated by prepare_operand, pick up the temporary */
      676 
      677 l4a:
      678 	p1 = p1 -> operand (1);
      679 
      680 l5:
      681 	if ^p1 -> reference.shared then
      682 	     p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
      683 
      684 /* check to see if the value of the qualifier is in a base */
      685 
      686 	do i = first_base to last_base;
      687 	     if p1 -> reference.value_in.b (i) then do;
      688 
      689 /* value is in base, load vwo into an xr and
      690*		   see if value of qualifier is still in base;
      691*		   if so, we're home free! */
      692 
      693 		call load_vwo;
      694 
      695 		if p1 -> reference.value_in.b (i) then do;
      696 		     ref -> address.base = bases (i);
      697 		     base_regs (i).used = cg_stat$text_pos;
      698 
      699 		     if ^p1 -> reference.shared then
      700 			p1 -> reference.ref_count = p1 -> reference.ref_count - 1;
      701 		     goto so1;
      702 		end;
      703 
      704 /* the qualifier got forced out of the base by
      705*   the process of making the variable word offset
      706*   addressable, so go lock the offset in the index */
      707 
      708 		goto lock;
      709 	     end;
      710 
      711 	end;
      712 
      713 /* if the variable word offset and qualifier are not both automatic
      714*	   variables declared in the current stack frame, we may have a
      715*	   conflict such that the base register(s) needed to address the
      716*	   offset may conflict with the base register(s) needed to address
      717*	   the qualifier.  We resolve this problem by loading the offset
      718*	   into the index register before making the pointer addressable
      719*	   rather than afterwards, and call a special entry to "lock"
      720*	   the value into the index register.  (Note that if the ref has a "big"
      721*	   offset, loading it requires the a or q, which could affect
      722*	   the qualifier's offset.) */
      723 
      724 	if ^ro -> reference.big_offset then do;
      725 	     if vwo = null then
      726 		goto l6;
      727 
      728 	     p2 = vwo -> reference.symbol;
      729 	     if p2 -> symbol.temporary then
      730 		goto l6;
      731 
      732 	     if p2 -> symbol.auto then
      733 		if p2 -> symbol.block_node = cg_stat$cur_block then
      734 		     goto l6;
      735 
      736 	     if p1 -> reference.temp_ref then
      737 		goto l6;
      738 
      739 	     p2 = p1 -> reference.symbol;
      740 	     if p2 -> symbol.auto then
      741 		if p2 -> symbol.block_node = cg_stat$cur_block then
      742 		     goto l6;
      743 	end;
      744 
      745 /* may have the conflict */
      746 
      747 	call load_vwo;
      748 
      749 lock:
      750 	if xr >= 0 then do;
      751 	     call xr_man$lock (vwo, xr);
      752 	     locked = "1"b;
      753 	end;
      754 
      755 	word_offset = save_word_offset;
      756 	fract_offset = save_fract_offset;
      757 
      758 /* make the qualifier permanently addressable */
      759 
      760 l6:
      761 	call m_a (p1, "00"b);
      762 	p1 -> reference.perm_address = "1"b;
      763 
      764 	if locked then do;
      765 	     if vwo -> reference.value_in.x (xr) then
      766 		dont_load = "1"b;
      767 	     call xr_man$unlock (xr);
      768 	     if base_offset ^= 0 then
      769 		vwo -> reference.value_in.x (xr) = "0"b;
      770 	end;
      771 
      772 	call load_vwo;
      773 
      774 /* we may be able to use the ptr via indirection if the qualified
      775*	   variable has a zero word offset and there is no subscript or
      776*	   indirection on the qualifier */
      777 
      778 	if word_offset ^= 0 then
      779 	     goto l7;
      780 
      781 	if ^fok then
      782 	     goto l7;
      783 
      784 	if no_ind then
      785 	     goto l7;
      786 
      787 	if tag then
      788 	     if substr (p1 -> reference.tag, 3, 4) then
      789 		goto l7;
      790 
      791 	if substr (p1 -> reference.tag, 1, 2) then
      792 	     base = base_man$load_any_var (2, p1);
      793 	else if ^p1 -> reference.shared then
      794 	     p1 -> reference.ref_count = p1 -> reference.ref_count - 1;
      795 
      796 	string (ref -> address) = string (p1 -> address);
      797 	ref -> reference.relocation = p1 -> reference.relocation;
      798 
      799 	if tag then
      800 	     ref -> address.tag = tagind;
      801 	else
      802 	     substr (ref -> address.tag, 1, 2) = ri_mod;
      803 
      804 	p1 -> reference.perm_address = "0"b;
      805 
      806 	goto seteb1;
      807 
      808 /* can't use the qualifier via indirection, have to load
      809*	   it into a base register */
      810 
      811 l7:
      812 	ref -> address.base = base_man$load_any_var (1, p1);
      813 	p1 -> reference.perm_address = "0"b;
      814 
      815 	goto so1;
      816 
      817 
      818 get_c_offset:
      819      proc ();
      820 
      821 dcl      word_off fixed bin (15);
      822 dcl      fract_off fixed bin (6);
      823 
      824 	if r1 -> reference.c_offset = 0 then
      825 	     return;
      826 
      827 	word_off = divide (r1 -> reference.c_offset, units_per_word (r1 -> reference.units), 15, 0);
      828 	fract_off = mod (r1 -> reference.c_offset, units_per_word (r1 -> reference.units));
      829 
      830 	if fract_off ^= 0 then
      831 	     if r1 -> reference.c_offset < 0 then
      832 		word_off = word_off - 1;
      833 
      834 	word_offset = word_offset + word_off;
      835 
      836 	if ref -> reference.units = r1 -> reference.units then do;
      837 	     fract_offset = fract_offset + fract_off;
      838 
      839 	     if fract_offset >= units_per_word (r1 -> reference.units) then do;
      840 		fract_offset = fract_offset - units_per_word (r1 -> reference.units);
      841 		word_offset = word_offset + 1;
      842 	     end;
      843 	end;
      844 
      845      end get_c_offset;
      846 
      847 
      848 
      849 /* vwo takes on two different meanings depending on the value of eis.  When
      850*   eis is "0"b, vwo means variable_word_offset.  However, when eis is "1"b,
      851*   vwo refers to variable offset instead of variable_word_offset unless 
      852*   reference.modword_in_offset is ON.  The EIS instructions take their offsets
      853*   in the reference units rather than in word units like the other instructions. */
      854 
      855 get_vwo:
      856      proc (rp);
      857 
      858 dcl      rp ptr parameter;
      859 
      860 	have_loaded = "0"b;
      861 
      862 	ro = rp;
      863 
      864 	vwo = rp -> reference.offset;
      865 
      866 	if vwo ^= null then do;
      867 	     if rp -> reference.units = word_ | rp -> reference.modword_in_offset then do;
      868 		if eis then
      869 		     goto call_baseman;
      870 	     end;
      871 	     else if ^eis then
      872 		goto print;
      873 
      874 	     if vwo -> node.type = operator_node then
      875 		vwo = vwo -> operand (1);
      876 
      877 	     if ^vwo -> reference.shared then
      878 		vwo -> reference.ref_count = vwo -> reference.ref_count + 1;
      879 	end;
      880 
      881 	return;
      882 
      883 print:
      884 	call error (312, cg_stat$cur_statement, rp);
      885 	vwo = null;
      886      end get_vwo;
      887 
      888 load_vwo:
      889      proc ();
      890 
      891 dcl      bxr bit (3) aligned;
      892 dcl      aq fixed bin (2);
      893 dcl      baq bit (2) aligned;
      894 
      895 dcl      max_num (18) fixed bin (18) int static
      896 	    init (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143);
      897 
      898 	xr = -1;
      899 
      900 	save_word_offset = word_offset;
      901 	save_fract_offset = fract_offset;
      902 	base_offset = 0;
      903 
      904 	if s1 ^= null then do;
      905 	     if s1 -> node.type ^= symbol_node then
      906 		goto vwo_1;
      907 	     if s1 -> symbol.constant & ^ro -> reference.temp_ref & ^(s1 -> symbol.internal & s1 -> symbol.file) then
      908 		goto vwo_1;
      909 	end;
      910 
      911 	if abs (word_offset) >= 16384 then do;
      912 	     base_offset = word_offset - mod (word_offset, 16384);
      913 	     word_offset = word_offset - base_offset;
      914 	end;
      915 
      916 vwo_1:
      917 	if eis then do;
      918 	     if base_offset ^= 0 then
      919 		if ro -> reference.units = word_ then
      920 		     goto call_baseman;
      921 		else
      922 		     base_offset = base_offset * units_per_word (ro -> reference.units);
      923 	     if ^no_ind then do;
      924 		base_offset = base_offset + fract_offset;
      925 		fract_offset = 0;
      926 		fok = "1"b;
      927 	     end;
      928 	end;
      929 
      930 	if dont_load then
      931 	     goto vwo_3;
      932 
      933 	if vwo ^= null then do;
      934 
      935 	     if eis then do;
      936 		if ro -> reference.big_offset then
      937 		     goto large;
      938 		if base_offset > 0 then
      939 		     if base_offset + max_num (vwo -> reference.symbol -> symbol.c_dcl_size)
      940 			> max_index_register_value then
      941 			goto large;
      942 	     end;
      943 
      944 	     if have_loaded then
      945 		if ^vwo -> reference.shared then
      946 		     vwo -> reference.ref_count = vwo -> reference.ref_count + 1;
      947 
      948 	     have_loaded = "1"b;
      949 
      950 /* can use QL | AL modification if value of offset is in Q|A register
      951*		   and we don't have complex data type */
      952 
      953 	     if s1 -> node.type = symbol_node then
      954 		if s1 -> symbol.complex then
      955 		     goto vwo_1a;
      956 
      957 	     if base_offset ^= 0 then
      958 		goto vwo_1a;
      959 
      960 	     if vwo -> reference.value_in.q then do;
      961 		tag = "000110"b;			/* ql */
      962 		tagind = "110110"b;			/* *ql */
      963 
      964 vwo_1b:
      965 		if ^vwo -> reference.shared then
      966 		     vwo -> reference.ref_count = vwo -> reference.ref_count - 1;
      967 
      968 		goto vwo_3;
      969 	     end;
      970 
      971 	     if vwo -> reference.value_in.a then do;
      972 		tag = "000101"b;			/* al */
      973 		tagind = "110101"b;			/* *al */
      974 		goto vwo_1b;
      975 	     end;
      976 
      977 vwo_1a:
      978 	     call xr_man$load_any_var (vwo, xr, (base_offset));
      979 	     goto vwo_2;
      980 	end;
      981 
      982 	if base_offset ^= 0 then do;
      983 	     if base_offset >= 262144 then do;
      984 		call aq_man$load_any_const (base_offset, aq);
      985 		goto vwo_4;
      986 	     end;
      987 	     call xr_man$load_any_const ((base_offset), xr);
      988 vwo_2:
      989 	     bxr = bit (xr, 3);
      990 	     tag = r_mod || bxr;
      991 	     tagind = ir_mod || bxr;
      992 	end;
      993 	else do;
      994 	     tag = "000000"b;
      995 	     tagind = "010000"b;
      996 	end;
      997 
      998 vwo_3:
      999 	if word_offset < 0 then
     1000 	     word_offset = word_offset + 262144;
     1001 
     1002 	return;
     1003 
     1004 large:
     1005 	if have_loaded then
     1006 	     goto vwo_3;
     1007 	call aq_man$load_any_var (vwo, aq, base_offset);
     1008 vwo_4:
     1009 	baq = bit (aq, 2);
     1010 	tag = aq_mod || baq;
     1011 	tagind = iaq_mod || baq;
     1012 	have_loaded = "1"b;
     1013 	goto vwo_3;
     1014 
     1015      end load_vwo;
     1016 
     1017      end m_a;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/19/89  1013.9  m_a.pl1                           >spec>install>1068>m_a.pl1
128          1    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
130          2    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
132          3    07/21/80  1546.3  cg_reference.incl.pl1             >ldd>include>cg_reference.incl.pl1
134          4    12/07/83  1701.7  symbol.incl.pl1                   >ldd>include>symbol.incl.pl1
136          5    11/30/78  1227.4  temporary.incl.pl1                >ldd>include>temporary.incl.pl1
138          6    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
140          7    08/13/81  2043.5  block.incl.pl1                    >ldd>include>block.incl.pl1
142          8    10/30/80  1648.7  relocation_bits.incl.pl1          >ldd>include>relocation_bits.incl.pl1
144          9    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
146         10    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
148         11    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
150         12    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed packed unaligned dcl 3-3 ref 971
abs                                                    builtin function         dcl 76 ref 231 300 626 911
addr_fun                               constant        bit(9)                   initial dcl 9-8 ref 636
address                  10            based           structure                level 2 packed packed unaligned dcl 3-3 set ref 165*
                                                                                  577 796* 796
address_in               11            based           structure                level 3 packed packed unaligned dcl 3-3
aggregate                12(19)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 206
allocate                 12(14)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 269
allocated                 1(18)        based           bit(1)                   level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-3 in procedure "m_a" ref 541
allocated                12(15)        based           bit(1)                   level 3 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 242 268
aq                              000205 automatic       fixed bin(2,0)           dcl 892 set ref 984* 1007* 1008
aq_man$load_any_const           000066 constant        entry                    external dcl 90 ref 984
aq_man$load_any_var             000070 constant        entry                    external dcl 90 ref 1007
aq_mod                                 constant        bit(4)                   initial packed unaligned dcl 113 ref 1010
arg_descriptor           31(11)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 596
attributes               31            based           structure                level 2 dcl 4-3
auto                     32(09)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 400 420
                                                                                  621 732 740
b                        11(15)        based           bit(1)                   array level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 687 695
b                        11            based           bit(1)                   array level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 178 180
baq                             000206 automatic       bit(2)                   dcl 893 set ref 1008* 1010 1011
base                            000125 automatic       bit(3)                   packed unaligned dcl 61 in procedure "m_a" set ref
                                                                                  463* 466 791*
base                     10            based           bit(3)                   level 3 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" set ref 181*
                                                                                  237* 263* 305* 363* 415* 428* 466* 481* 506* 518*
                                                                                  549* 599* 604* 665* 670* 696* 811*
base_man$load_any_var           000044 constant        entry                    external dcl 88 ref 363 463 549 791 811
base_man$load_arg               000046 constant        entry                    external dcl 89 ref 665
base_man$load_arg_ptr           000026 constant        entry                    external dcl 80 ref 670
base_man$load_controlled        000036 constant        entry                    external dcl 84 ref 604
base_man$load_display           000032 constant        entry                    external dcl 82 ref 428
base_man$load_link_indirect     000034 constant        entry                    external dcl 83 ref 518 599
base_man$load_linkage           000040 constant        entry                    external dcl 85 ref 489
base_man$load_stack_indirect    000030 constant        entry                    external dcl 81 ref 237 263 305
base_man$load_static            000042 constant        entry                    external dcl 86 ref 481 590
base_man_link_or_static         000150 automatic       entry variable           dcl 87 set ref 489* 506 590*
base_offset                     000141 automatic       fixed bin(24,0)          dcl 61 set ref 768 902* 912* 913 918 921* 921 924*
                                                                                  924 938 938 957 977 982 983 984* 987 1007*
base_regs               160            based           structure                array level 2 dcl 11-6
based                    32(10)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 621
bases                           000022 constant        bit(3)                   initial array dcl 10-1 ref 181 415 415 696
big_offset               11(33)        based           bit(1)                   level 4 packed packed unaligned dcl 3-3 ref 724 936
bit                                                    builtin function         dcl 76 ref 434 501 508 577 600 605 666 988 1008
bits                     12(06)        based           structure                level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a"
bits                                   parameter       bit(2)                   dcl 43 in procedure "m_a" ref 40 154 155
block                                  based           structure                level 1 dcl 7-5
block_node                4            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 422 732
                                                                                  740
boundary                  2(20)        based           fixed bin(3,0)           level 2 packed packed unaligned dcl 4-3 ref 553
bxr                             000204 automatic       bit(3)                   dcl 891 set ref 988* 990 991
c_dcl_size               30            based           fixed bin(24,0)          level 2 dcl 4-3 ref 938
c_f_offset                7            based           fixed bin(6,0)           level 2 dcl 3-3 set ref 168* 436* 468* 578* 607*
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 3-3 ref 824 827 828 830
c_word_size              26            based           fixed bin(24,0)          level 2 dcl 4-3 ref 553
cg_error                        000060 constant        entry                    external dcl 90 ref 616
cg_stat$cur_block               000010 external static pointer                  dcl 48 ref 732 740
cg_stat$cur_level               000022 external static fixed bin(17,0)          dcl 48 ref 422
cg_stat$cur_statement           000012 external static pointer                  dcl 48 set ref 250* 274* 883*
cg_stat$extended_stack          000016 external static bit(1)                   packed unaligned dcl 48 set ref 322*
cg_stat$long_string_temp        000014 external static pointer                  dcl 48 ref 247
cg_stat$text_pos                000020 external static fixed bin(18,0)          dcl 48 ref 183 697
cg_static_$m_s_p                000102 external static pointer                  dcl 11-3 ref 11-3
compiler_developed       32(35)        based           structure                level 3 packed packed unaligned dcl 4-3
complex                  31(31)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 953
constant                 32(16)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 382 524
                                                                                  907
controlled               32(12)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 397 400
                                                                                  583
copy_temp                       000056 constant        entry                    external dcl 90 ref 269
data_type                12            based           fixed bin(5,0)           level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 547
data_type                31            based           structure                level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-3 in procedure "m_a"
defined_ref              12(12)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 328 340
                                                                                  645
delta                           000134 automatic       fixed bin(15,0)          dcl 61 set ref 596* 600 604*
dimensioned              31(19)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 295
divide                                                 builtin function         dcl 76 ref 827
dont_load                       000126 automatic       bit(1)                   dcl 61 set ref 165* 765* 930
eis                             000101 automatic       bit(1)                   dcl 43 set ref 155* 199 436 578 607 626 868 871 916
                                                                                  935
entry                    31(09)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 526
equivalence              14            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 538 538
error                           000062 constant        entry                    external dcl 90 ref 250 274 883
evaluated                12(13)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 637
even                     12(17)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 165*
                                                                                  255* 430* 553* 565* 585*
exp_extents              33(04)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 621
ext_base                 10(29)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 182*
                                                                                  442* 465*
external                 32(02)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 397 532
father                   17            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 215 216
                                                                                  289 290
file                     31(10)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 385 535
                                                                                  907
first_base                             constant        fixed bin(17,0)          initial dcl 120 ref 178 686
fix_bin                                based           fixed bin(15,0)          dcl 118 ref 662
fixed                                                  builtin function         dcl 76 ref 247 508 577 596 616 616 666
fok                             000143 automatic       bit(1)                   dcl 61 set ref 199* 201* 231 254 300 491 598 664 781
                                                                                  926*
forward_ref              12(09)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 165*
                                                                                  543*
fract_off                       000167 automatic       fixed bin(6,0)           dcl 822 set ref 828* 830 837
fract_offset                    000135 automatic       fixed bin(6,0)           dcl 61 set ref 196* 201 436 578 607 756* 837* 837
                                                                                  839 840* 840 901 924 925*
have_loaded                     000127 automatic       bit(1)                   dcl 61 set ref 860* 944 948* 1004 1012*
i                               000122 automatic       fixed bin(17,0)          dcl 61 set ref 178* 180 181 183* 651* 656* 665* 666
                                                                                  670* 686* 687 695 696 697*
iaq_mod                                constant        bit(4)                   initial packed unaligned dcl 113 ref 1011
ic_ref                   12(10)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 165*
                                                                                  566*
ind_word                        000137 automatic       fixed bin(18,0)          dcl 61 set ref 242* 247* 256 263*
info                     11            based           structure                level 2 packed packed unaligned dcl 3-3
initial                  11            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 219 222
                                                                                  292 315 526 662
internal                 32(01)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 385 478
                                                                                  526 588 907
ir_mod                                 constant        bit(3)                   initial packed unaligned dcl 107 ref 991
k                               000123 automatic       fixed bin(17,0)          dcl 61 set ref 422* 423 428* 662* 666 670*
label_node                             constant        bit(9)                   initial dcl 2-5 ref 379 410
last_base                              constant        fixed bin(17,0)          initial dcl 120 ref 178 686
level                    45            based           fixed bin(17,0)          level 2 dcl 7-5 ref 422
location                  1            based           fixed bin(18,0)          level 2 in structure "symbol" packed packed unsigned
                                                                                  unaligned dcl 4-3 in procedure "m_a" ref 385 397
                                                                                  494 518 562 599 604
location                  4            based           fixed bin(18,0)          level 2 in structure "temporary" dcl 5-3
                                                                                  in procedure "m_a" set ref 225 231 233 237* 242
                                                                                  278 300 301 305* 316 395
locked                          000142 automatic       bit(1)                   dcl 61 set ref 190* 752* 764
m_a                             000024 constant        entry                    external dcl 78 ref 760
m_s_p                           000154 automatic       pointer                  initial dcl 11-3 set ref 183 697 11-3*
machine_state                          based           structure                level 1 dcl 11-6
max_index_register_value               constant        fixed bin(31,0)          initial dcl 1-38 ref 938
max_num                         000000 constant        fixed bin(18,0)          initial array dcl 895 ref 938
member                   32(04)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 295 345
                                                                                  621
misc_attributes          31(19)        based           structure                level 3 packed packed unaligned dcl 4-3
mod                                                    builtin function         dcl 76 ref 430 499 565 585 828 912
mod2_                                  constant        fixed bin(3,0)           initial dcl 12-5 ref 553
modword_in_offset        11(35)        based           bit(1)                   level 4 packed packed unaligned dcl 3-3 ref 867
multiple                        000140 automatic       fixed bin(18,0)          dcl 61 set ref 499* 500* 503
no_address               10(27)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 158
no_ind                          000100 automatic       bit(1)                   dcl 43 set ref 154* 158 201 448 664 784 923
node                                   based           structure                level 1 dcl 2-27
null                                                   builtin function         dcl 76 ref 201 215 219 224 242 273 289 294 330 357
                                                                                  359 376 410 526 538 725 866 885 904 933
off                             000133 automatic       fixed bin(15,0)          dcl 61 set ref 494* 495 499 499 503* 503 508
offset                   10(03)        based           bit(15)                  level 3 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" set ref 247
                                                                                  434* 469* 508* 600* 605* 666*
offset                    5            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 359 864
op_code                         000147 automatic       bit(9)                   dcl 61 in procedure "m_a" set ref 634* 636 650 655
op_code                   0(09)        based           bit(9)                   level 2 in structure "operator" packed packed
                                                                                  unaligned dcl 6-6 in procedure "m_a" ref 634
operand                   1            based           pointer                  array level 2 packed packed unaligned dcl 6-6 ref
                                                                                  336 637 640 661 662 677 874
operator                               based           structure                level 1 dcl 6-6
operator_node                          constant        bit(9)                   initial dcl 2-5 ref 336 874
other                    11(33)        based           structure                level 3 packed packed unaligned dcl 3-3
p1                              000106 automatic       pointer                  dcl 61 set ref 214* 215 216* 216 219 219* 222 224
                                                                                  282* 292* 294 300 301 305 315* 316 330 331* 334
                                                                                  373* 376 391* 546* 547 547* 547* 549* 631 634 637
                                                                                  640 661 662 677* 677 680 680 680 687 695 699 699
                                                                                  699 736 739 760* 762 787 791 791* 793 793 793 796
                                                                                  797 804 811* 813
p2                              000110 automatic       pointer                  dcl 61 set ref 222* 225 231 233 237 289* 289* 290
                                                                                  292 314* 315 728* 729 732 732 739* 740 740
param_desc               32(15)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 390
param_desc_ptr                         constant        bit(9)                   initial dcl 9-8 ref 655
param_ptr                              constant        bit(9)                   initial dcl 9-8 ref 650
parameter                32(14)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 390
perm_address             12(18)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 158
                                                                                  457* 469* 762* 804* 813*
prepare_operand                 000064 constant        entry                    external dcl 90 ref 547
pt                                     parameter       pointer                  dcl 43 set ref 40 157 269*
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 960
q                               000116 automatic       pointer                  dcl 61 in procedure "m_a" set ref 661* 665* 670*
qualifier                 4            based           pointer                  level 2 packed packed unaligned dcl 3-3 ref 242 242
                                                                                  273 278 282 331 341 373 391 395
r1                              000104 automatic       pointer                  dcl 57 set ref 157* 206 241 242 242 242 247 250* 255
                                                                                  268 269 269* 269* 271* 273 274* 278 334* 336 336*
                                                                                  336 340 341* 341 348 351 351 357 357* 359 360 360
                                                                                  360 363* 370 373 395 395 414 640* 642 645 824 827
                                                                                  827 828 828 830 836 839 840
r_mod                                  constant        bit(3)                   initial packed unaligned dcl 107 ref 990
rc_is15                                constant        bit(6)                   initial packed unaligned dcl 8-6 ref 479 589
rc_lp15                                constant        bit(6)                   initial packed unaligned dcl 8-6 ref 487 599
rc_t                                   constant        bit(6)                   initial packed unaligned dcl 8-6 ref 571
ref                             000102 automatic       pointer                  dcl 57 set ref 157* 158 158 165 165 165 165 165 168
                                                                                  170 176 178 180 181 182 194* 204 237 263 269* 282
                                                                                  305 328 357 363 415 428 430 434 436 439 440 442
                                                                                  450 457 459 459 459 463* 465 466 468 469 469 469
                                                                                  481 506 507 508 509 518 543 549 553 565 566 568
                                                                                  571 572 577 578 585 599 600 601 604 605 606 607
                                                                                  626 665 666 670 696 796 797 799 801 811 836
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-3 set ref 360*
                                                                                  360 459* 459 680* 680 699* 699 793* 793 877* 877
                                                                                  944* 944 964* 964
reference                15            based           pointer                  level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-3 in procedure "m_a" ref 331 391
                                                                                  546
reference                              based           structure                level 1 dcl 3-3 in procedure "m_a"
reference_node                         constant        bit(9)                   initial dcl 2-5 ref 631
reloc                           000146 automatic       bit(12)                  dcl 61 set ref 190* 440 479* 487* 507 518* 520* 589*
relocation               12(24)        based           bit(12)                  level 2 packed packed unaligned dcl 3-3 set ref 165*
                                                                                  440* 507* 571* 797* 797
return_value             32(18)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 287 354
ri_mod                                 constant        bit(3)                   initial packed unaligned dcl 107 ref 258 501 801
ro                              000112 automatic       pointer                  dcl 61 set ref 724 862* 907 918 921 936
rp                                     parameter       pointer                  dcl 858 set ref 855 862 864 867 867 883*
s1                              000114 automatic       pointer                  dcl 61 set ref 170* 208 214 284 287 289 295 295 295
                                                                                  331 345 345 348* 354 379 382 383 385 385 385 390
                                                                                  390 391 397 397 397 397 400 400 400 400 410 410
                                                                                  420 422 476 478 494 518 524 526 526 526 532 535
                                                                                  538 538* 538 541 546 553 553 553 562 583 588 596
                                                                                  599 604 616 616 621 621 621 621 621 904 905 907
                                                                                  907 907 953 953
save_fract_offset               000136 automatic       fixed bin(6,0)           dcl 61 set ref 756 901*
save_word_offset                000132 automatic       fixed bin(15,0)          dcl 61 set ref 755 900*
shared                    0(11)        based           bit(1)                   level 2 packed packed unaligned dcl 3-3 ref 360 459
                                                                                  680 699 793 877 944 964
sp                                     defined         bit(3)                   dcl 10-4 ref 415
stack_temp$assign_aggregate     000052 constant        entry                    external dcl 90 ref 219
stack_temp$assign_return_value  000054 constant        entry                    external dcl 90 ref 314
stack_temp$assign_temp          000050 constant        entry                    external dcl 90 ref 271
static                   32(11)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 397 400
                                                                                  476
storage                  11(08)        based           bit(1)                   level 4 packed packed unaligned dcl 3-3 ref 241 351
storage_class            32(09)        based           structure                level 3 packed packed unaligned dcl 4-3 ref 616 616
string                                                 builtin function         dcl 76 set ref 165* 178 577 616 616 796* 796
string_aq                11(12)        based           bit(1)                   level 4 packed packed unaligned dcl 3-3 ref 247
substr                                                 builtin function         dcl 76 set ref 154 155 258 450 577* 787 791 801*
symbol                    3            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" ref 170 348
                                                                                  662 728 739 938
symbol                                 based           structure                level 1 dcl 4-3 in procedure "m_a"
symbol_node                            constant        bit(9)                   initial dcl 2-5 ref 284 553 905 953
tag                             000144 automatic       bit(6)                   dcl 61 in procedure "m_a" set ref 232* 258* 258 302*
                                                                                  430 439 496 545 564 572 585 606 787 799 961* 972*
                                                                                  990* 994* 1010*
tag                      10(30)        based           bit(6)                   level 3 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "m_a" set ref 439*
                                                                                  450 469* 509* 568* 572* 601* 606* 787 791 799*
                                                                                  801*
tagind                          000145 automatic       bit(6)                   dcl 61 set ref 232 302 501* 509 601 799 962* 973*
                                                                                  991* 995* 1011*
temp_ref                 12(11)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 176 204
                                                                                  351 370 395 414 736 907
temporary                32(17)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 4-3 in procedure "m_a" ref 729
temporary                              based           structure                level 1 unaligned dcl 5-3 in procedure "m_a"
type                                   based           bit(9)                   level 2 packed packed unaligned dcl 2-27 ref 284 336
                                                                                  379 410 553 631 874 905 953
units                     0(14)        based           fixed bin(3,0)           level 2 packed packed unaligned dcl 3-3 ref 357 357
                                                                                  626 827 828 836 836 839 840 867 918 921
units_per_word                  000032 constant        fixed bin(8,0)           initial array dcl 1-5 ref 827 828 839 840 921
used                    200            based           fixed bin(18,0)          array level 3 dcl 11-6 set ref 183* 697*
useless                         000130 automatic       bit(1)                   dcl 61 set ref 547*
value_in                 11(09)        based           structure                level 3 packed packed unaligned dcl 3-3
varying                  31(26)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 ref 208 295
                                                                                  345 383 400 621
varying_ref               0(10)        based           bit(1)                   level 2 packed packed unaligned dcl 3-3 ref 642
vwo                             000120 automatic       pointer                  dcl 61 set ref 201 357 725 728 751* 765 768 864* 866
                                                                                  874 874* 874 877 877 877 885* 933 938 944 944 944
                                                                                  960 964 964 964 971 977* 1007*
word_                                  constant        fixed bin(3,0)           initial dcl 12-5 ref 626 867 918
word_off                        000166 automatic       fixed bin(15,0)          dcl 821 set ref 827* 830* 830 834
word_offset                     000131 automatic       fixed bin(15,0)          dcl 61 set ref 196* 208* 208 225* 225 231 233* 254
                                                                                  256* 278* 278 295* 295 300 301* 316* 345* 345 383*
                                                                                  383 385* 385 395* 395 397* 397 400* 400 430 434
                                                                                  491 545 562* 562 565 577 585 598 605 621* 621 626
                                                                                  642* 642 664 755* 778 834* 834 841* 841 900 911
                                                                                  912 912 913* 913 998 998* 998
word_size                22            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 224
x                        11(25)        based           bit(1)                   array level 4 packed packed unaligned dcl 3-3 set
                                                                                  ref 765 768*
xr                              000124 automatic       fixed bin(3,0)           dcl 61 set ref 500* 501 749 751* 765 767* 768 898*
                                                                                  977* 987* 988
xr_man$load_any_const           000076 constant        entry                    external dcl 90 ref 500 987
xr_man$load_any_var             000100 constant        entry                    external dcl 90 ref 977
xr_man$lock                     000072 constant        entry                    external dcl 90 ref 751
xr_man$unlock                   000074 constant        entry                    external dcl 90 ref 767

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 9-8
ab                                     defined         bit(3)                   dcl 10-9
abs_fun                                internal static bit(9)                   initial dcl 9-8
acos_fun                               internal static bit(9)                   initial dcl 9-8
acosd_fun                              internal static bit(9)                   initial dcl 9-8
add                                    internal static bit(9)                   initial dcl 9-8
addbitno_fun                           internal static bit(9)                   initial dcl 9-8
addcharno_fun                          internal static bit(9)                   initial dcl 9-8
addr_fun_bits                          internal static bit(9)                   initial dcl 9-8
addrel_fun                             internal static bit(9)                   initial dcl 9-8
allocation_fun                         internal static bit(9)                   initial dcl 9-8
allot_auto                             internal static bit(9)                   initial dcl 9-8
allot_based                            internal static bit(9)                   initial dcl 9-8
allot_ctl                              internal static bit(9)                   initial dcl 9-8
allot_var                              internal static bit(9)                   initial dcl 9-8
and_bits                               internal static bit(9)                   initial dcl 9-8
ap                                     defined         bit(3)                   dcl 10-4
array_node                             internal static bit(9)                   initial dcl 2-5
asin_fun                               internal static bit(9)                   initial dcl 9-8
asind_fun                              internal static bit(9)                   initial dcl 9-8
assign                                 internal static bit(9)                   initial dcl 9-8
assign_by_name                         internal static bit(9)                   initial dcl 9-8
assign_round                           internal static bit(9)                   initial dcl 9-8
assign_size_ck                         internal static bit(9)                   initial dcl 9-8
assign_zero                            internal static bit(9)                   initial dcl 9-8
atan_fun                               internal static bit(9)                   initial dcl 9-8
atand_fun                              internal static bit(9)                   initial dcl 9-8
b_format                               internal static bit(9)                   initial dcl 9-8
base_man$load_var               000000 constant        entry                    external dcl 90
baseno_fun                             internal static bit(9)                   initial dcl 9-8
baseptr_fun                            internal static bit(9)                   initial dcl 9-8
bb                                     defined         bit(3)                   dcl 10-9
bit_                                   internal static fixed bin(3,0)           initial dcl 12-5
bit_pointer                            internal static bit(9)                   initial dcl 9-8
bit_to_char                            internal static bit(9)                   initial dcl 9-8
bit_to_word                            internal static bit(9)                   initial dcl 9-8
bitno_fun                              internal static bit(9)                   initial dcl 9-8
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 1-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 1-5
bits_per_word                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 1-5
block_node                             internal static bit(9)                   initial dcl 2-5
bn_format                              internal static bit(9)                   initial dcl 9-8
bool_fun                               internal static bit(9)                   initial dcl 9-8
bound_ck                               internal static bit(9)                   initial dcl 9-8
bound_node                             internal static bit(9)                   initial dcl 2-5
bp                                     defined         bit(3)                   dcl 10-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
by_name_agg_node                       internal static bit(9)                   initial dcl 2-5
byte_fun                               internal static bit(9)                   initial dcl 9-8
c_format                               internal static bit(9)                   initial dcl 9-8
cat_string                             internal static bit(9)                   initial dcl 9-8
ceil_fun                               internal static bit(9)                   initial dcl 9-8
char_to_word                           internal static bit(9)                   initial dcl 9-8
character_                             internal static fixed bin(3,0)           initial dcl 12-5
charno_fun                             internal static bit(9)                   initial dcl 9-8
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
clock_fun                              internal static bit(9)                   initial dcl 9-8
close_file                             internal static bit(9)                   initial dcl 9-8
codeptr_fun                            internal static bit(9)                   initial dcl 9-8
column_format                          internal static bit(9)                   initial dcl 9-8
complex_fun                            internal static bit(9)                   initial dcl 9-8
conjg_fun                              internal static bit(9)                   initial dcl 9-8
context_node                           internal static bit(9)                   initial dcl 2-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 1-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 1-5
copy_string                            internal static bit(9)                   initial dcl 9-8
copy_words                             internal static bit(9)                   initial dcl 9-8
cos_fun                                internal static bit(9)                   initial dcl 9-8
cosd_fun                               internal static bit(9)                   initial dcl 9-8
cross_reference_node                   internal static bit(9)                   initial dcl 2-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
default_node                           internal static bit(9)                   initial dcl 2-5
delete_file                            internal static bit(9)                   initial dcl 9-8
desc_size                              internal static bit(9)                   initial dcl 9-8
digit_                                 internal static fixed bin(3,0)           initial dcl 12-5
digit_to_bit                           internal static bit(9)                   initial dcl 9-8
div                                    internal static bit(9)                   initial dcl 9-8
do_fun                                 internal static bit(9)                   initial dcl 9-8
do_spec                                internal static bit(9)                   initial dcl 9-8
e_format                               internal static bit(9)                   initial dcl 9-8
empty_area                             internal static bit(9)                   initial dcl 9-8
enable_on                              internal static bit(9)                   initial dcl 9-8
environmentptr_fun                     internal static bit(9)                   initial dcl 9-8
equal                                  internal static bit(9)                   initial dcl 9-8
ex_prologue                            internal static bit(9)                   initial dcl 9-8
exp                                    internal static bit(9)                   initial dcl 9-8
exp_fun                                internal static bit(9)                   initial dcl 9-8
expmac                          000000 constant        entry                    external dcl 79
f_format                               internal static bit(9)                   initial dcl 9-8
floor_fun                              internal static bit(9)                   initial dcl 9-8
fo                                     automatic       fixed bin(6,0)           dcl 61
format_value_node                      internal static bit(9)                   initial dcl 2-5
fortran_read                           internal static bit(9)                   initial dcl 9-8
fortran_write                          internal static bit(9)                   initial dcl 9-8
free_based                             internal static bit(9)                   initial dcl 9-8
free_ctl                               internal static bit(9)                   initial dcl 9-8
free_var                               internal static bit(9)                   initial dcl 9-8
ftn_file_manip                         internal static bit(9)                   initial dcl 9-8
ftn_trans_loop                         internal static bit(9)                   initial dcl 9-8
get_data_trans                         internal static bit(9)                   initial dcl 9-8
get_edit_trans                         internal static bit(9)                   initial dcl 9-8
get_file                               internal static bit(9)                   initial dcl 9-8
get_list_trans                         internal static bit(9)                   initial dcl 9-8
get_string                             internal static bit(9)                   initial dcl 9-8
greater_or_equal                       internal static bit(9)                   initial dcl 9-8
greater_than                           internal static bit(9)                   initial dcl 9-8
half_                                  internal static fixed bin(3,0)           initial dcl 12-5
half_to_word                           internal static bit(9)                   initial dcl 9-8
imag_fun                               internal static bit(9)                   initial dcl 9-8
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 11-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 11-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 11-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 11-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 11-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 11-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 11-68
index_after_fun                        internal static bit(9)                   initial dcl 9-8
index_before_fun                       internal static bit(9)                   initial dcl 9-8
index_fun                              internal static bit(9)                   initial dcl 9-8
index_rev_fun                          internal static bit(9)                   initial dcl 9-8
join                                   internal static bit(9)                   initial dcl 9-8
jump                                   internal static bit(9)                   initial dcl 9-8
jump_false                             internal static bit(9)                   initial dcl 9-8
jump_if_eq                             internal static bit(9)                   initial dcl 9-8
jump_if_ge                             internal static bit(9)                   initial dcl 9-8
jump_if_gt                             internal static bit(9)                   initial dcl 9-8
jump_if_le                             internal static bit(9)                   initial dcl 9-8
jump_if_lt                             internal static bit(9)                   initial dcl 9-8
jump_if_ne                             internal static bit(9)                   initial dcl 9-8
jump_true                              internal static bit(9)                   initial dcl 9-8
l_parn                                 internal static bit(9)                   initial dcl 9-8
label_array_element_node               internal static bit(9)                   initial dcl 2-5
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
lb                                     defined         bit(3)                   dcl 10-9
length_fun                             internal static bit(9)                   initial dcl 9-8
less_or_equal                          internal static bit(9)                   initial dcl 9-8
less_than                              internal static bit(9)                   initial dcl 9-8
line_format                            internal static bit(9)                   initial dcl 9-8
list_node                              internal static bit(9)                   initial dcl 2-5
load_pt                                internal static fixed bin(15,0)          initial dcl 125
locate_file                            internal static bit(9)                   initial dcl 9-8
lock_file                              internal static bit(9)                   initial dcl 9-8
lock_fun                               internal static bit(9)                   initial dcl 9-8
log10_fun                              internal static bit(9)                   initial dcl 9-8
log2_fun                               internal static bit(9)                   initial dcl 9-8
log_fun                                internal static bit(9)                   initial dcl 9-8
loop                                   internal static bit(9)                   initial dcl 9-8
lp                                     defined         bit(3)                   dcl 10-4
machine_state_node                     internal static bit(9)                   initial dcl 2-5
make_desc                              internal static bit(9)                   initial dcl 9-8
max_block_number                       internal static fixed bin(17,0)          initial dcl 7-74
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_fun                                internal static bit(9)                   initial dcl 9-8
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 6-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
min_fun                                internal static bit(9)                   initial dcl 9-8
mod4_                                  internal static fixed bin(3,0)           initial dcl 12-5
mod_bit                                internal static bit(9)                   initial dcl 9-8
mod_byte                               internal static bit(9)                   initial dcl 9-8
mod_fun                                internal static bit(9)                   initial dcl 9-8
mod_half                               internal static bit(9)                   initial dcl 9-8
mod_word                               internal static bit(9)                   initial dcl 9-8
mult                                   internal static bit(9)                   initial dcl 9-8
negate                                 internal static bit(9)                   initial dcl 9-8
nop                                    internal static bit(9)                   initial dcl 9-8
not_bits                               internal static bit(9)                   initial dcl 9-8
not_equal                              internal static bit(9)                   initial dcl 9-8
off_fun                                internal static bit(9)                   initial dcl 9-8
open_file                              internal static bit(9)                   initial dcl 9-8
or_bits                                internal static bit(9)                   initial dcl 9-8
pack                                   internal static bit(9)                   initial dcl 9-8
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
page_format                            internal static bit(9)                   initial dcl 9-8
picture_format                         internal static bit(9)                   initial dcl 9-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 9-8
prefix_plus                            internal static bit(9)                   initial dcl 9-8
ptr_fun                                internal static bit(9)                   initial dcl 9-8
put_control                            internal static bit(9)                   initial dcl 9-8
put_data_trans                         internal static bit(9)                   initial dcl 9-8
put_edit_trans                         internal static bit(9)                   initial dcl 9-8
put_field                              internal static bit(9)                   initial dcl 9-8
put_field_chk                          internal static bit(9)                   initial dcl 9-8
put_file                               internal static bit(9)                   initial dcl 9-8
put_list_trans                         internal static bit(9)                   initial dcl 9-8
put_string                             internal static bit(9)                   initial dcl 9-8
r_format                               internal static bit(9)                   initial dcl 9-8
r_parn                                 internal static bit(9)                   initial dcl 9-8
range_ck                               internal static bit(9)                   initial dcl 9-8
rank_fun                               internal static bit(9)                   initial dcl 9-8
rc_a                                   internal static bit(6)                   initial packed unaligned dcl 8-6
rc_dp                                  internal static bit(6)                   initial packed unaligned dcl 8-6
rc_e                                   internal static bit(6)                   initial packed unaligned dcl 8-6
rc_is18                                internal static bit(6)                   initial packed unaligned dcl 8-6
rc_lb                                  internal static bit(6)                   initial packed unaligned dcl 8-6
rc_lp18                                internal static bit(6)                   initial packed unaligned dcl 8-6
rc_nlb                                 internal static bit(6)                   initial packed unaligned dcl 8-6
rc_nlp18                               internal static bit(6)                   initial packed unaligned dcl 8-6
rc_ns                                  internal static bit(6)                   initial packed unaligned dcl 8-6
rc_nt                                  internal static bit(6)                   initial packed unaligned dcl 8-6
rc_s                                   internal static bit(6)                   initial packed unaligned dcl 8-6
rc_sr                                  internal static bit(6)                   initial packed unaligned dcl 8-6
read_file                              internal static bit(9)                   initial dcl 9-8
real_fun                               internal static bit(9)                   initial dcl 9-8
record_io                              internal static bit(9)                   initial dcl 9-8
refer                                  internal static bit(9)                   initial dcl 9-8
rel_fun                                internal static bit(9)                   initial dcl 9-8
repeat_fun                             internal static bit(9)                   initial dcl 9-8
return_bits                            internal static bit(9)                   initial dcl 9-8
return_string                          internal static bit(9)                   initial dcl 9-8
return_value                           internal static bit(9)                   initial dcl 9-8
return_words                           internal static bit(9)                   initial dcl 9-8
reverse_fun                            internal static bit(9)                   initial dcl 9-8
revert_on                              internal static bit(9)                   initial dcl 9-8
rewrite_file                           internal static bit(9)                   initial dcl 9-8
round_fun                              internal static bit(9)                   initial dcl 9-8
sb                                     defined         bit(3)                   dcl 10-9
search_fun                             internal static bit(9)                   initial dcl 9-8
search_rev_fun                         internal static bit(9)                   initial dcl 9-8
segno_fun                              internal static bit(9)                   initial dcl 9-8
setbitno_fun                           internal static bit(9)                   initial dcl 9-8
setcharno_fun                          internal static bit(9)                   initial dcl 9-8
sf_par_node                            internal static bit(9)                   initial dcl 2-5
sign_fun                               internal static bit(9)                   initial dcl 9-8
signal_on                              internal static bit(9)                   initial dcl 9-8
sin_fun                                internal static bit(9)                   initial dcl 9-8
sind_fun                               internal static bit(9)                   initial dcl 9-8
skip_format                            internal static bit(9)                   initial dcl 9-8
source_node                            internal static bit(9)                   initial dcl 2-5
sqrt_fun                               internal static bit(9)                   initial dcl 9-8
stack_ptr                              internal static bit(9)                   initial dcl 9-8
stack_temp$assign_block         000000 constant        entry                    external dcl 90
stack_temp$free_temp            000000 constant        entry                    external dcl 90
stackbaseptr_fun                       internal static bit(9)                   initial dcl 9-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 9-8
stacq_fun                              internal static bit(9)                   initial dcl 9-8
statement_node                         internal static bit(9)                   initial dcl 2-5
std_arg_list                           internal static bit(9)                   initial dcl 9-8
std_call                               internal static bit(9)                   initial dcl 9-8
std_entry                              internal static bit(9)                   initial dcl 9-8
std_return                             internal static bit(9)                   initial dcl 9-8
stop                                   internal static bit(9)                   initial dcl 9-8
stream_prep                            internal static bit(9)                   initial dcl 9-8
sub                                    internal static bit(9)                   initial dcl 9-8
tan_fun                                internal static bit(9)                   initial dcl 9-8
tand_fun                               internal static bit(9)                   initial dcl 9-8
temporary_node                         internal static bit(9)                   initial dcl 2-5
terminate_trans                        internal static bit(9)                   initial dcl 9-8
token_node                             internal static bit(9)                   initial dcl 2-5
translate_fun                          internal static bit(9)                   initial dcl 9-8
trunc_fun                              internal static bit(9)                   initial dcl 9-8
unlock_file                            internal static bit(9)                   initial dcl 9-8
unpack                                 internal static bit(9)                   initial dcl 9-8
vclock_fun                             internal static bit(9)                   initial dcl 9-8
verify_fun                             internal static bit(9)                   initial dcl 9-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 9-8
verify_rev_fun                         internal static bit(9)                   initial dcl 9-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 9-8
which_base                             internal static fixed bin(17,0)          initial array dcl 10-14
word_to_mod2                           internal static bit(9)                   initial dcl 9-8
word_to_mod4                           internal static bit(9)                   initial dcl 9-8
word_to_mod8                           internal static bit(9)                   initial dcl 9-8
wordno_fun                             internal static bit(9)                   initial dcl 9-8
write_file                             internal static bit(9)                   initial dcl 9-8
x_format                               internal static bit(9)                   initial dcl 9-8
xor_bits                               internal static bit(9)                   initial dcl 9-8

NAMES DECLARED BY EXPLICIT CONTEXT.
call_baseman                    001234 constant        label                    dcl 459 ref 626 868 918
dr                              000646 constant        label                    dcl 328 ref 284
err330                          000361 constant        label                    dcl 250 ref 242
es                              001434 constant        label                    dcl 509 ref 667
gen                             001441 constant        label                    dcl 518 ref 496
get_c_offset                    002627 constant        entry                    internal dcl 818 ref 197 368
get_vwo                         002676 constant        entry                    internal dcl 855 ref 194 357
have_qual                       002054 constant        label                    dcl 621 ref 376 392
is                              001312 constant        label                    dcl 479 ref 535
l0                              000663 constant        label                    dcl 336 ref 342
l0a                             000751 constant        label                    dcl 360 ref 351 354 645
l0b                             000711 constant        label                    dcl 348 ref 647
l3a                             001520 constant        label                    dcl 541 ref 410 526
l3b                             001637 constant        label                    dcl 566 ref 557
l4                              002155 constant        label                    dcl 658 ref 652
l4a                             002257 constant        label                    dcl 677 ref 637
l5                              002262 constant        label                    dcl 680 ref 631
l6                              002435 constant        label                    dcl 760 ref 725 729 732 736 740
l7                              002600 constant        label                    dcl 811 ref 778 781 784 787
large                           003273 constant        label                    dcl 1004 ref 936 938
load_vwo                        002772 constant        entry                    internal dcl 888 ref 229 257 262 298 317 364 407 658
                                                                                  693 747 772
lock                            002414 constant        label                    dcl 749 ref 708
lr                              001332 constant        label                    dcl 487 ref 529 532
lr1                             001341 constant        label                    dcl 491 ref 591
lv                              001110 constant        label                    dcl 407 ref 226 279 379 387
m_a                             000052 constant        entry                    external dcl 40
print                           002751 constant        label                    dcl 883 ref 871
seteb1                          001221 constant        label                    dcl 442 ref 511 611 806
so                              001163 constant        label                    dcl 430 ref 264 417 482
so1                             001176 constant        label                    dcl 434 ref 238 306 365 521 550 671 701 815
t1                              001125 constant        label                    dcl 415 ref 234 259 325 423 617
temp                            000222 constant        label                    dcl 206 ref 370
test1                           001226 constant        label                    dcl 450 ref 158
vwo_1                           003047 constant        label                    dcl 916 ref 905 907
vwo_1a                          003200 constant        label                    dcl 977 ref 953 957
vwo_1b                          003156 constant        label                    dcl 964 ref 974
vwo_2                           003246 constant        label                    dcl 988 ref 979
vwo_3                           003266 constant        label                    dcl 998 ref 930 968 1004 1013
vwo_4                           003310 constant        label                    dcl 1008 ref 985

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3706        4012    3356        3716
Length      4460    3356       104         432     330           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
m_a                                 190 external procedure  is an external procedure.  
get_c_offset                            internal procedure  shares stack frame of external procedure m_a.  
get_vwo                                 internal procedure  shares stack frame of external procedure m_a.  
load_vwo                                internal procedure  shares stack frame of external procedure m_a.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
m_a                      000100 no_ind                      m_a
                         000101 eis                         m_a
                         000102 ref                         m_a
                         000104 r1                          m_a
                         000106 p1                          m_a
                         000110 p2                          m_a
                         000112 ro                          m_a
                         000114 s1                          m_a
                         000116 q                           m_a
                         000120 vwo                         m_a
                         000122 i                           m_a
                         000123 k                           m_a
                         000124 xr                          m_a
                         000125 base                        m_a
                         000126 dont_load                   m_a
                         000127 have_loaded                 m_a
                         000130 useless                     m_a
                         000131 word_offset                 m_a
                         000132 save_word_offset            m_a
                         000133 off                         m_a
                         000134 delta                       m_a
                         000135 fract_offset                m_a
                         000136 save_fract_offset           m_a
                         000137 ind_word                    m_a
                         000140 multiple                    m_a
                         000141 base_offset                 m_a
                         000142 locked                      m_a
                         000143 fok                         m_a
                         000144 tag                         m_a
                         000145 tagind                      m_a
                         000146 reloc                       m_a
                         000147 op_code                     m_a
                         000150 base_man_link_or_static     m_a
                         000154 m_s_p                       m_a
                         000166 word_off                    get_c_offset
                         000167 fract_off                   get_c_offset
                         000204 bxr                         load_vwo
                         000205 aq                          load_vwo
                         000206 baq                         load_vwo

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             unpk_to_pk          call_ent_var        call_ext_out        return_mac
mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aq_man$load_any_const         aq_man$load_any_var           base_man$load_any_var         base_man$load_arg
base_man$load_arg_ptr         base_man$load_controlled      base_man$load_display         base_man$load_link_indirect
base_man$load_linkage         base_man$load_stack_indirect  base_man$load_static          cg_error
copy_temp                     error                         m_a                           prepare_operand
stack_temp$assign_aggregate   stack_temp$assign_return_value                              stack_temp$assign_temp
xr_man$load_any_const         xr_man$load_any_var           xr_man$lock                   xr_man$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_block             cg_stat$cur_level             cg_stat$cur_statement         cg_stat$extended_stack
cg_stat$long_string_temp      cg_stat$text_pos              cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000046   11    3 000057       154 000062       155 000066       157 000072       158 000076       162 000107
    165 000110       168 000122       170 000123       176 000125       178 000130       180 000143       181 000150
    182 000154       183 000156       184 000164       186 000165       190 000167       194 000171       196 000173
    197 000175       199 000176       201 000203       204 000216       206 000222       208 000226       214 000233
    215 000234       216 000240       217 000242       219 000243       222 000255       224 000260       225 000264
    226 000266       229 000267       231 000270       232 000303       233 000305       234 000307       237 000310
    238 000330       241 000331       242 000334       247 000346       250 000361       252 000376       254 000377
    255 000403       256 000405       257 000407       258 000410       259 000413       262 000414       263 000415
    264 000434       268 000435       269 000440       271 000461       272 000470       273 000471       274 000474
    275 000511       278 000512       279 000516       282 000517       284 000521       287 000525       289 000531
    290 000536       292 000541       294 000543       295 000547       298 000562       300 000563       301 000576
    302 000600       303 000602       305 000603       306 000623       309 000624       314 000625       315 000634
    316 000637       317 000641       322 000642       325 000645       328 000646       330 000651       331 000655
    334 000661       336 000663       340 000672       341 000676       342 000700       345 000701       348 000711
    351 000714       354 000723       357 000726       359 000746       360 000751       363 000762       364 001005
    365 001006       368 001007       370 001010       373 001014       376 001016       379 001022       382 001026
    383 001032       385 001036       387 001047       390 001050       391 001053       392 001056       395 001057
    397 001067       400 001101       407 001110       410 001111       414 001121       415 001125       417 001132
    420 001133       422 001137       423 001144       428 001145       430 001163       434 001176       436 001207
    439 001213       440 001216       442 001221       448 001224       450 001226       457 001232       459 001234
    463 001245       465 001265       466 001270       468 001274       469 001275       473 001303       476 001304
    478 001307       479 001312       481 001314       482 001331       487 001332       489 001334       491 001341
    494 001345       495 001351       496 001353       499 001355       500 001363       501 001374       503 001403
    506 001405       507 001421       508 001424       509 001434       511 001440       518 001441       520 001466
    521 001467       524 001470       526 001473       529 001504       532 001505       535 001510       538 001513
    541 001520       543 001524       545 001527       546 001533       547 001535       549 001556       550 001601
    553 001602       557 001620       562 001621       564 001624       565 001626       566 001637       568 001641
    569 001643       571 001644       572 001647       577 001652       578 001657       580 001663       583 001664
    585 001667       588 001702       589 001705       590 001707       591 001714       596 001715       598 001722
    599 001726       600 001754       601 001764       602 001767       604 001770       605 002014       606 002024
    607 002027       611 002033       616 002034       617 002053       621 002054       626 002075       631 002112
    634 002116       636 002122       637 002124       640 002131       642 002134       645 002141       647 002144
    650 002145       651 002147       652 002150       655 002151       656 002153       658 002155       661 002156
    662 002161       664 002167       665 002175       666 002216       667 002232       670 002233       671 002256
    677 002257       680 002262       686 002273       687 002303       693 002310       695 002311       696 002317
    697 002324       699 002333       701 002343       708 002344       711 002345       724 002347       725 002353
    728 002357       729 002362       732 002365       736 002375       739 002401       740 002403       747 002413
    749 002414       751 002416       752 002427       755 002431       756 002433       760 002435       762 002450
    764 002453       765 002455       767 002465       768 002474       772 002503       778 002504       781 002506
    784 002510       787 002512       791 002520       793 002545       796 002555       797 002561       799 002563
    801 002571       804 002575       806 002577       811 002600       813 002623       815 002626       818 002627
    824 002630       827 002634       828 002644       830 002650       834 002656       836 002660       837 002665
    839 002667       840 002672       841 002674       845 002675       855 002676       860 002700       862 002701
    864 002704       866 002706       867 002712       868 002724       870 002726       871 002727       874 002731
    877 002737       881 002750       883 002751       885 002767       886 002771       888 002772       898 002773
    900 002775       901 002777       902 003001       904 003002       905 003006       907 003012       911 003030
    912 003036       913 003045       916 003047       918 003051       921 003060       923 003064       924 003066
    925 003070       926 003071       930 003073       933 003075       935 003101       936 003103       938 003107
    944 003117       948 003132       953 003134       957 003144       960 003146       961 003152       962 003154
    964 003156       968 003167       971 003170       972 003173       973 003175       974 003177       977 003200
    979 003215       982 003216       983 003220       984 003222       985 003233       987 003234       988 003246
    990 003253       991 003256       992 003262       994 003263       995 003264       998 003266      1002 003272
   1004 003273      1007 003275      1008 003310      1010 003315      1011 003320      1012 003324      1013 003326


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
