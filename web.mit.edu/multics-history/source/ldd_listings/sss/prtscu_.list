	COMPILATION LISTING OF SEGMENT prtscu_
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1714.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 prtscu_: proc;
       12 	return;					/* should never enter here */
       13 
       14 /* Modification History - prtscu_
       15*   Initially coded by J. A. Bush - Dec 1975
       16*   Modified May 1977 by J. A. Bush to be intellegent about group 7 faults and not print out tsr|ca
       17*   Modified Aug 1980  by R.L. Coppola to be more intelligent about IOM channels greater than 37 (octal).
       18*   Also added display of the CT Hold reg in CU status.
       19**/
       20 
       21 dcl  a_iocbp ptr;					/* output switch (iox_$user_output is default) */
       22 dcl  scup ptr;					/* pointer to SCU Data */
       23 dcl  a_offset fixed bin;				/*  relative offset of SCU data */
       24 dcl  lg_sw bit (1);					/* long format switch "1"b => long */
       25 dcl  odsp ptr;					/* ptr to ol_dump structure (defined in ol_dump_struc.incl.pl1) */
  1     1 /* BEGIN INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
  1     2 
  1     3 dcl 1 struc based (strp) aligned,			/* This useful structure is in trace_stack pgms */
  1     4     2 comment char (64),				/* name of boundseg, or thing pointed to, or .. */
  1     5     2 segment char (32),				/* name of segment, or segment number with # */
  1     6     2 entryn char (33),				/* entry name, preceded by $, or blank */
  1     7     2 offset char (6),				/* offset in segment, or blank */
  1     8     2 opname char (32),				/* may be pl1 operator name */
  1     9     2 ring char (1) unal,				/* ring number of ptr */
  1    10     2 std_flag bit (1) unal,				/* TRUE if std object. */
  1    11     2 xpad bit (26) unal,
  1    12     2 bitoff char (4),				/* bit offset */
  1    13     2 modifier char (8),				/* ptr modifier, or special code like "noaccess" */
  1    14     2 symbolp ptr,					/* ptr to symbol section */
  1    15     2 instruction_counter fixed bin,			/* binary instruction counter */
  1    16     2 sourcemap fixed bin,				/* source map offset in symbol section */
  1    17     2 compiler char (8),				/* name of compiler */
  1    18     2 text_ptr ptr,					/* ptr to segment text */
  1    19     2 stack_ptr ptr;				/* ptr to stack frame */
  1    20 
  1    21 dcl 1 strbuf aligned like struc;			/* If referenced, will make storage for struc */
  1    22 
  1    23 /* END INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
       26 
       27 dcl (strp, byptr, refptr) ptr;
       28 dcl (lnpos, flt_lng, inst6, i, j, reoffset) fixed bin;
       29 dcl  code fixed bin (35);
       30 dcl  w (0 : 7) fixed bin based;
       31 dcl  flt_ln char (100);
       32 dcl  flt_bf char (24) varying;
       33 dcl  iocbp ptr;
       34 dcl (length, fixed, addr, addrel, baseptr, substr, null, hbound, lbound) builtin;
       35 dcl (tsrpr, on_line) bit (1);
       36 dcl  cvbinbuf char (12);
       37 dcl  fltdtab (0:35) bit (1) based (byptr) unaligned;
       38 dcl  cpul (0 : 7) char (1) int static options (constant) init ("a", "b", "c", "d", "e", "f", "g", "h");
       39 dcl  at_by_wd char (2);
       40 dcl (ioa_$ioa_switch, ioa_$rsnnl) entry options (variable);
       41 dcl  db_print entry (ptr, char (*) aligned, ptr, char (*), fixed bin, fixed bin, ptr, fixed bin, fixed bin);
       42 dcl  ol_dump_$namef_ entry (ptr, ptr) returns (char (*));
       43 dcl  interpret_ptr_ entry (ptr, ptr, ptr);
       44 dcl  cv_bin_$oct entry (fixed bin, char (12));
       45 dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
       46 dcl  iox_$user_output ptr ext;
       47 
       48 dcl 1 scud based (scup) aligned,
       49     2 wd0 unaligned,				/* :: */
       50       3 prr bit (3),				/* Procedure Ring Register */
       51       3 psr bit (15),				/* Procedure Segment Register */
       52       3 apust bit (18),				/* APU Status */
       53     2 wd1 unaligned,				/* :: */
       54       3 fid bit (20),				/* fault/interrupt data */
       55       3 ill_act_lns bit (4),				/* Illegal Action Lines */
       56       3 ill_act_chan bit (3),				/* Illegal Action Channel (Port) */
       57       3 con_chan bit (3),				/* Connect Channel (Port) */
       58       3 fi bit (6),					/* Fault/Interrupt Vector Address */
       59     2 wd2 unaligned,				/* :: */
       60       3 trr bit (3),				/* Temporary Ring Register */
       61       3 tsr bit (15),				/* Temporary Segment Register */
       62       3 mbz bit (9),				/* :: */
       63       3 cpu bit (3),				/* Processor Number */
       64       3 tmd bit (6),				/* :: */
       65     2 wd3 fixed bin (35),				/* :: */
       66     2 wd4 unaligned,				/* :: */
       67       3 ict bit (18),				/* Instruction Counter */
       68       3 ir bit (18),				/* Indicator Register */
       69     2 wd5 unaligned,				/* :: */
       70       3 ca bit (18),				/* Computed Address */
       71       3 cus bit (12),				/* CU Status */
       72       3 ct_hold bit (6),				/* remember mod field */
       73     2 wd6 fixed bin (35),				/* Even Instruction */
       74     2 wd7 fixed bin (35);				/* Odd Instruction */
       75 
       76 dcl  ill_act (0:15) char (37) varying int static options (constant) init
       77     ("...", "Unasigned", "Non Existant Address", "Fault on Condition",
       78      "Unassigned", "Data Parity (Store -> SCU)", "Data Parity in Store",
       79      "Data Parity (Store -> SCU & in Store)", "Not Control", "Port Not Enabled", "Illegal Command",
       80      "Store Not Ready", "ZAC Parity (Processor -> SCU)", "Data Parity (Processor -> SCU)",
       81      "ZAC parity (SCU -> Store)", "Data Parity (SCU -> Store)");
       82 
       83 dcl  indrs (18:31) char (4) varying int static options (constant) init
       84     ("zero", "neg", "cary", "ovfl", "eovf", "eufl", "oflm", "tro", "par", "parm", "^bar", "tru", "mif", "abs");
       85 
       86 dcl  APU (18:32) char (6) varying int static options (constant) init
       87     ("priv", "xsf", "sdwamm", "sd-on", "ptwamm", "pt-on", "pi-ap", "dsptw", "sdwnp",
       88      "sdwp", "ptw", "ptw2", "fap", "fanp", "fabs");
       89 
       90 dcl  CU (18:29) char (3) varying int static options (constant) init
       91     ("rf", "rpt", "rd", "rl", "pot", "pon", "xde", "xdo", "itp", "rfi", "its", "fif");
       92 
       93 dcl  g1and7flts (5) bit (6) int static options (constant) unaligned init
       94     ("01"b3, "11"b3, "21"b3, "31"b3, "37"b3);
       95 
       96 dcl  grp1flt (0:19) char (24) varying int static options (constant) init
       97     ("Illegal Ring Order", "Not in Execute Bracket", "Execute Bit off",
       98      "Not In Read Bracket", "Read Bit Off", "Not In Write Bracket",
       99      "Write Bit Off", "Not A Gate", "Not In Call Bracket", "Outward Call",
      100      "Bad Outward Call", "Inward Return", "Cross Ring Transfer",
      101      "Ring Alarm", "Associative Memory", "Out of Segment Bounds",
      102      "Processor Parity Upper", "Processor Parity Lower",
      103      "SC To Proc. Seq. Error 1", "SC To Proc. Seq. Error 2");
      104 
      105 dcl  grp2flt (0:6) char (24) varying int static options (constant) init
      106     ("Illegal Segment Number", "Illegal Op Code",
      107      "Illegal Address & Mod", "Illegal Slave Procedure",
      108      "Illegal Procedure", "Non Existant Address", "Out Of Bounds");
      109 
      110 dcl  flt_int_typ (0:63) char (24) varying int static options (constant) init
      111     ("...", "Shutdown", "...", "Store", "Bulk Store 0 Term", "MME 1", "...", "Fault Tag 1",
      112      "IOM 0 Overhead", "Timer Runout", "IOM 1 Overhead", "Command", "IOM 2 Overhead", "Derail",
      113      "IOM 3 Overhead", "Lockup", "IOM 0 Terminate Ch 40-77", "Connect", "IOM 1 Terminate Ch 40-77", "Parity", "Bulk Store 1 Term",
      114      "Illegal Procedure", "...", "Op Not Complete", "IOM 0 Terminate", "Startup", "IOM 1 Terminate",
      115      "Overflow", "IOM 2 Terminate", "Divide Check", "IOM 3 Terminate", "Execute", "IOM 0 Marker Ch 40-77",
      116      "(DF0) Segment", "IOM 1 Marker Ch 40-77", "(DF1) Page", "...", "Directed Fault 2", "...", "Directed Fault 3",
      117      "IOM 0 Marker", "Access Violation", "IOM 1 Marker", "MME 2", "IOM 2 Marker", "MME 3",
      118      "IOM 3 Marker", "MME 4", "...", "(FT2) Linkage", "...", "Fault Tag 3", "...", "...", "...", "...",
      119      "IOM 0 Special", "...", "IOM 1 Special", "...", "IOM 2 Special", "...", "IOM 3 Special", "Trouble");
      120 
      121 dcl  TAG_ptr ptr;					/* pointer to tag table */
      122 dcl  tag_prt bit (1) init ("0"b);
      123 dcl  tag_ char (4) init ("");
      124 dcl  TAG_table (8) char (40) init (			/* tag table */
      125      "     au   qu   du   ic   al   ql   dl   ",
      126      "x0   x1   x2   x3   x4   x5   x6   x7   ",
      127      "n*  aau* aqu* ailtg ic* aal* aql* ailtg ",
      128      "0*  a1*  a2*  a3*  a4*  a5*  a6*  a7*  a",
      129      "fi   itp  iltg its  sd   scr  f2   f3   ",
      130      "ci   i    sc   ad   di   dic aid   idc a",
      131      "*n   *au  *qu  iltg *ic  *al  *ql  iltg ",
      132      "*0   *1   *2   *3   *4   *5   *6   *7   ");
      133 
      134 
      135 dcl 1 TAG (64) based (TAG_ptr),
      136     2 code char (4) unal,
      137     2 pad bit (8) unal,
      138     2 chain bit (1);
      139 
      140 /*  */
      141 
      142 /* on_line - entry to display scu data from a live on line system */
      143 
      144 on_line:	entry (a_iocbp, scup, lg_sw);
      145 
      146 	on_line = "1"b;				/* set switch for this entry */
      147 	reoffset = fixed (rel (scup));		/* form relitive offset */
      148 	go to common;				/* join common code */
      149 
      150 /* dump - entry to display scu data within a dump segment */
      151 
      152 dump:	entry (a_iocbp, scup, a_offset, lg_sw, odsp);
      153 
      154 	on_line = "0"b;
      155 	reoffset = a_offset;			/* copy relative offset */
      156 
      157 common:
      158 
      159 	if a_iocbp = null then			/* if null iocb ptr supplied */
      160 	     iocbp = iox_$user_output;		/* default to user output */
      161 	else iocbp = a_iocbp;			/* else use supplied switch name */
      162 	if scud.wd0.psr = "0"b then
      163 	     if scud.wd2.tsr = "0"b then do;
      164 		call ioa_$ioa_switch (iocbp, "No SCU data stored");
      165 		return;
      166 	     end;
      167 	inst6 = reoffset + 6;
      168 	if lg_sw then				/* user wants octal dump too */
      169 	     call ioa_$ioa_switch (iocbp, "^6o^-^4(^w ^)^/^-^4(^w ^)^/", reoffset, scup -> w (0),
      170 	     scup -> w (1), scup -> w (2), scup -> w (3), scup -> w (4),
      171 	     scup -> w (5), scup -> w (6), scup -> w (7));
      172 	flt_ln, flt_bf = "";
      173 	tsrpr = "0"b;
      174 	flt_bf = flt_int_typ (fixed (scud.wd1.fi, 6));
      175 	if substr (flt_bf, 1, 3) = "..." then
      176 	     call ioa_$ioa_switch (iocbp, "Fault/Interrupt (^o), Undefined", fixed (scud.wd1.fi, 6));
      177 	else do;
      178 	     flt_lng = length (flt_int_typ (fixed (scud.wd1.fi, 6)));
      179 	     substr (flt_ln, 1, flt_lng) = substr (flt_bf, 1, flt_lng);
      180 	     byptr = addrel (scup, 1);
      181 	     if fltdtab (35) = "1"b then do;
      182 		substr (flt_ln, flt_lng + 2, 5) = "Fault";
      183 		lnpos = flt_lng + 8;
      184 		do i = 1 to hbound (g1and7flts, 1);	/*  If grp 1 or 7 faults, don't print out tsr|ca */
      185 		     if scud.wd1.fi = g1and7flts (i) then
      186 			tsrpr = "1"b;
      187 		end;
      188 	     end;
      189 	     else do;
      190 		substr (flt_ln, flt_lng + 2, 9) = "Interrupt";
      191 		lnpos = flt_lng + 12;
      192 		tsrpr = "1"b;			/* don't print out tsr|ca for interrupts */
      193 	     end;
      194 	     flt_lng = fixed (scud.wd1.fi, 6);
      195 	     call cv_bin_$oct (flt_lng, cvbinbuf);
      196 	     substr (flt_ln, lnpos, 4) = "(" || substr (cvbinbuf, 11, 2) || ")";
      197 	     lnpos = lnpos + 4;
      198 	     j = lnpos;
      199 	     do i = 0 to hbound (grp1flt, 1);
      200 		if fltdtab (i) then do;
      201 		     if substr (flt_ln, 1, 5) = "Store"|substr (flt_ln, 1, 12) = "Illegal Proc" then
      202 			if i <= 6 then
      203 			     call ioa_$rsnnl ("^a, ^a", flt_ln, j, flt_ln, grp2flt (i));
      204 			else;
      205 		     else call ioa_$rsnnl ("^a, ^a", flt_ln, j, flt_ln, grp1flt (i));
      206 		end;
      207 	     end;
      208 	     call ioa_$ioa_switch (iocbp, "^a", flt_ln);
      209 	end;
      210 	if ill_act_lns ^= "0"b then do;		/* display illegal action lines if present */
      211 	     call ioa_$ioa_switch (iocbp, "Illegal Action Code (^o) - ^a", fixed (scud.wd1.ill_act_lns, 4),
      212 		ill_act (fixed (scud.wd1.ill_act_lns, 4)));
      213 	end;
      214 	if tsrpr then at_by_wd = "At";		/* if not printing tsr */
      215 	else at_by_wd = "By";
      216 	byptr = addrel (baseptr (fixed (scud.wd0.psr, 18)), fixed (scud.wd4.ict, 18));
      217 	if ^tsrpr then
      218 	     refptr = addrel (baseptr (fixed (scud.wd2.tsr, 18)), fixed (scud.wd5.ca, 18));
      219 	if ^on_line then do;			/* if  we are looking at a dump */
      220 	     call ioa_$ioa_switch (iocbp, "^a: ^p  ^a", at_by_wd, byptr,
      221 		ol_dump_$namef_ (byptr, odsp));
      222 	     if ^tsrpr then				/* if we want to print out tsr|ca */
      223 		call ioa_$ioa_switch (iocbp, "Referencing: ^p  ^a", refptr,
      224 		ol_dump_$namef_ (refptr, odsp));
      225 	end;
      226 	else do;					/* if printing on line info */
      227 	     strp = addr (strbuf);
      228 	     call interpret_ptr_ (byptr, null, strp);	/* get on line name */
      229 	     call ioa_$ioa_switch (iocbp, "^a: ^p ^a^a|^a ^a ^a", at_by_wd, byptr,
      230 		struc.segment, struc.entryn, struc.offset, struc.modifier, struc.comment);
      231 	     if ^tsrpr then do;			/* if we want to print out tsr|ca */
      232 		call interpret_ptr_ (refptr, null, strp);
      233 		call ioa_$ioa_switch (iocbp, "Referencing: ^p ^a^a|^a ^a ^a", refptr,
      234 		     struc.segment, struc.entryn, struc.offset, struc.modifier, struc.comment);
      235 	     end;
      236 	end;
      237 	call ioa_$ioa_switch (iocbp, "On: cpu ^a (#^o)", cpul (fixed (scud.wd2.cpu, 3)),
      238 	     fixed (scud.wd2.cpu, 3));
      239 	flt_ln = "";
      240 	byptr = addr (scud.wd4);			/* display Indicator register if any bits present */
      241 	do i = lbound (indrs, 1) to hbound (indrs, 1);
      242 	     if fltdtab (i) then
      243 		call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, indrs (i));
      244 	end;
      245 	if flt_ln ^= "" then do;
      246 	     substr (flt_ln, j, 1) = " ";
      247 	     call ioa_$ioa_switch (iocbp, "Indicators: ^a", flt_ln);
      248 	     flt_ln = "";
      249 	end;
      250 	byptr = addr (scud.wd0);			/* display interpreted APU status if any bits present */
      251 	do i = lbound (APU, 1) to hbound (APU, 1);
      252 	     if fltdtab (i) then
      253 		call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, APU (i));
      254 	end;
      255 	if flt_ln ^= "" then do;
      256 	     substr (flt_ln, j, 1) = " ";
      257 	     call ioa_$ioa_switch (iocbp, "APU Status: ^a", flt_ln);
      258 	     flt_ln = "";
      259 	end;
      260 	byptr = addr (scud.wd5);			/* display interprted CU status if any bits present */
      261 	do i = lbound (CU, 1) to hbound (CU, 1);
      262 	     if fltdtab (i) then
      263 		call ioa_$rsnnl ("^a ^a,", flt_ln, j, flt_ln, CU (i));
      264 	end;
      265 
      266 	TAG_ptr = addr (TAG_table);
      267 	i = fixed (wd5.ct_hold);
      268 
      269 	if i ^= 0 then do;
      270 	     tag_ = TAG.code (i+1);
      271 	     tag_prt = "1"b;
      272 	end;
      273 
      274 	if (flt_ln ^= "") | (tag_ ^= "") then do;
      275 	     substr (flt_ln, j, 1) = " ";
      276 	     call ioa_$ioa_switch (iocbp, "CU Status:  ^a  ^[^/CT Hold: ^a^]",
      277 		flt_ln, tag_prt, tag_);
      278 	end;
      279 
      280 
      281 	call ioa_$ioa_switch (iocbp, "Instructions: ");	/* display Instructions (words 6 & 7) */
      282 	call db_print (iocbp, iocbp -> iocb.name, addr (scud.wd6), "i", inst6, 1, null, 0, 0);
      283 	call db_print (iocbp, iocbp -> iocb.name, addr (scud.wd7), "i", inst6 + 1, 1, null, 0, 0);
      284 
      285 /*  */
  2     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  2     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  2     3*      version number to IOX2. */
  2     4 /* format: style2 */
  2     5 
  2     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  2     7 	     2 version	      character (4) aligned,	/* IOX2 */
  2     8 	     2 name	      char (32),		/* I/O name of this block. */
  2     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    17 						/* open(p,mode,not_used,s) */
  2    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    24 						/* put_chars(p,bufptr,buflen,s) */
  2    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    26 						/* modes(p,newmode,oldmode,s) */
  2    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    28 						/* position(p,u1,u2,s) */
  2    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    30 						/* control(p,order,infptr,s) */
  2    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    34 						/* write_record(p,bufptr,buflen,s) */
  2    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    36 						/* rewrite_record(p,bufptr,buflen,s) */
  2    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    39 						/* seek_key(p,key,len,s) */
  2    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    41 						/* read_key(p,key,len,s) */
  2    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  2    43 						/* read_length(p,len,s) */
  2    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  2    45 						/* open_file(p,mode,desc,not_used,s) */
  2    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  2    47 						/* close_file(p,desc,s) */
  2    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  2    49 						/* detach(p,desc,s) */
  2    50 
  2    51      declare iox_$iocb_version_sentinel
  2    52 			      character (4) aligned external static;
  2    53 
  2    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      286 
      287 
      288      end prtscu_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.6  prtscu_.pl1                       >spec>on>pl128d>prtscu_.pl1
26           1    06/11/74  0602.3  interpret_ptr_struc.incl.pl1      >ldd>include>interpret_ptr_struc.incl.pl1
286          2    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APU                             001226 constant        varying char(6)          initial array dcl 86 set ref 251 251 252*
CU                              001176 constant        varying char(3)          initial array dcl 90 set ref 261 261 262*
TAG                                    based           structure                array level 1 packed unaligned dcl 135
TAG_ptr                         000256 automatic       pointer                  dcl 121 set ref 266* 270
TAG_table                       000262 automatic       char(40)                 initial array unaligned dcl 124 set ref 124* 124*
                                                                                  124* 124* 124* 124* 124* 124* 266
a_iocbp                                parameter       pointer                  dcl 21 ref 144 152 157 161
a_offset                               parameter       fixed bin(17,0)          dcl 23 ref 152 155
addr                                                   builtin function         dcl 34 ref 227 240 250 260 266 282 282 283 283
addrel                                                 builtin function         dcl 34 ref 180 216 217
at_by_wd                        000255 automatic       char(2)                  unaligned dcl 39 set ref 214* 215* 220* 229*
baseptr                                                builtin function         dcl 34 ref 216 217
byptr                           000174 automatic       pointer                  dcl 27 set ref 180* 181 200 216* 220* 220* 228* 229*
                                                                                  240* 242 250* 252 260* 262
ca                        5            based           bit(18)                  level 3 packed unaligned dcl 48 set ref 217
code                                   based           char(4)                  array level 2 packed unaligned dcl 135 ref 270
comment                                based           char(64)                 level 2 dcl 1-3 set ref 229* 233*
cpu                       2(27)        based           bit(3)                   level 3 packed unaligned dcl 48 ref 237 237 237
cpul                            001620 constant        char(1)                  initial array unaligned dcl 38 set ref 237*
ct_hold                   5(30)        based           bit(6)                   level 3 packed unaligned dcl 48 set ref 267
cv_bin_$oct                     000022 constant        entry                    external dcl 44 ref 195
cvbinbuf                        000252 automatic       char(12)                 unaligned dcl 36 set ref 195* 196
db_print                        000014 constant        entry                    external dcl 41 ref 282 283
entryn                   30            based           char(33)                 level 2 dcl 1-3 set ref 229* 233*
fi                        1(30)        based           bit(6)                   level 3 packed unaligned dcl 48 ref 174 175 175 178
                                                                                  185 194
fixed                                                  builtin function         dcl 34 ref 147 174 175 175 178 194 211 211 211 216
                                                                                  216 217 217 237 237 237 267
flt_bf                          000237 automatic       varying char(24)         dcl 32 set ref 172* 174* 175 179
flt_int_typ                     000000 constant        varying char(24)         initial array dcl 110 ref 174 178
flt_ln                          000206 automatic       char(100)                unaligned dcl 31 set ref 172* 179* 182* 190* 196*
                                                                                  201 201 201* 201* 205* 205* 208* 239* 242* 242*
                                                                                  245 246* 247* 248* 252* 252* 255 256* 257* 258*
                                                                                  262* 262* 274 275* 276*
flt_lng                         000201 automatic       fixed bin(17,0)          dcl 28 set ref 178* 179 179 182 183 190 191 194*
                                                                                  195*
fltdtab                                based           bit(1)                   array unaligned dcl 37 ref 181 200 242 252 262
g1and7flts                      001175 constant        bit(6)                   initial array unaligned dcl 93 ref 184 185
grp1flt                         000761 constant        varying char(24)         initial array dcl 96 set ref 199 205*
grp2flt                         000700 constant        varying char(24)         initial array dcl 105 set ref 201*
hbound                                                 builtin function         dcl 34 ref 184 199 241 251 261
i                               000203 automatic       fixed bin(17,0)          dcl 28 set ref 184* 185* 199* 200 201 201 205* 241*
                                                                                  242 242* 251* 252 252* 261* 262 262* 267* 269 270
ict                       4            based           bit(18)                  level 3 packed unaligned dcl 48 set ref 216
ill_act                         001337 constant        varying char(37)         initial array dcl 76 set ref 211*
ill_act_lns               1(20)        based           bit(4)                   level 3 packed unaligned dcl 48 ref 210 211 211 211
indrs                           001303 constant        varying char(4)          initial array dcl 83 set ref 241 241 242*
inst6                           000202 automatic       fixed bin(17,0)          dcl 28 set ref 167* 282* 283
interpret_ptr_                  000020 constant        entry                    external dcl 43 ref 228 232
ioa_$ioa_switch                 000010 constant        entry                    external dcl 40 ref 164 168 175 208 211 220 222 229
                                                                                  233 237 247 257 276 281
ioa_$rsnnl                      000012 constant        entry                    external dcl 40 ref 201 205 242 252 262
iocb                                   based           structure                level 1 dcl 2-6
iocbp                           000246 automatic       pointer                  dcl 33 set ref 157* 161* 164* 168* 175* 208* 211*
                                                                                  220* 222* 229* 233* 237* 247* 257* 276* 281* 282*
                                                                                  282 283* 283
iox_$user_output                000024 external static pointer                  dcl 46 ref 157
j                               000204 automatic       fixed bin(17,0)          dcl 28 set ref 198* 201* 205* 242* 246 252* 256 262*
                                                                                  275
lbound                                                 builtin function         dcl 34 ref 241 251 261
length                                                 builtin function         dcl 34 ref 178
lg_sw                                  parameter       bit(1)                   unaligned dcl 24 ref 144 152 168
lnpos                           000200 automatic       fixed bin(17,0)          dcl 28 set ref 183* 191* 196 197* 197 198
modifier                 55            based           char(8)                  level 2 dcl 1-3 set ref 229* 233*
name                      1            based           char(32)                 level 2 dcl 2-6 set ref 282* 283*
null                                                   builtin function         dcl 34 ref 157 228 228 232 232 282 282 283 283
odsp                                   parameter       pointer                  dcl 25 set ref 152 220* 222*
offset                   41            based           char(6)                  level 2 dcl 1-3 set ref 229* 233*
ol_dump_$namef_                 000016 constant        entry                    external dcl 42 ref 220 222
on_line                         000251 automatic       bit(1)                   unaligned dcl 35 set ref 146* 154* 219
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 48 set ref 162 216
refptr                          000176 automatic       pointer                  dcl 27 set ref 217* 222* 222* 232* 233*
reoffset                        000205 automatic       fixed bin(17,0)          dcl 28 set ref 147* 155* 167 168*
scud                                   based           structure                level 1 dcl 48
scup                                   parameter       pointer                  dcl 22 ref 144 147 152 162 162 168 168 168 168 168
                                                                                  168 168 168 174 175 175 178 180 185 194 210 211
                                                                                  211 211 216 216 217 217 237 237 237 240 250 260
                                                                                  267 282 282 283 283
segment                  20            based           char(32)                 level 2 dcl 1-3 set ref 229* 233*
strbuf                          000100 automatic       structure                level 1 dcl 1-21 set ref 227
strp                            000172 automatic       pointer                  dcl 27 set ref 227* 228* 229 229 229 229 229 232*
                                                                                  233 233 233 233 233
struc                                  based           structure                level 1 dcl 1-3
substr                                                 builtin function         dcl 34 set ref 175 179* 179 182* 190* 196* 196 201
                                                                                  201 246* 256* 275*
tag_                            000261 automatic       char(4)                  initial unaligned dcl 123 set ref 123* 270* 274 276*
tag_prt                         000260 automatic       bit(1)                   initial unaligned dcl 122 set ref 122* 271* 276*
tsr                       2(03)        based           bit(15)                  level 3 packed unaligned dcl 48 ref 162 217
tsrpr                           000250 automatic       bit(1)                   unaligned dcl 35 set ref 173* 185* 192* 214 217 222
                                                                                  231
w                                      based           fixed bin(17,0)          array dcl 30 set ref 168* 168* 168* 168* 168* 168*
                                                                                  168* 168*
wd0                                    based           structure                level 2 packed unaligned dcl 48 set ref 250
wd1                       1            based           structure                level 2 packed unaligned dcl 48
wd2                       2            based           structure                level 2 packed unaligned dcl 48
wd4                       4            based           structure                level 2 packed unaligned dcl 48 set ref 240
wd5                       5            based           structure                level 2 packed unaligned dcl 48 set ref 260
wd6                       6            based           fixed bin(35,0)          level 2 dcl 48 set ref 282 282
wd7                       7            based           fixed bin(35,0)          level 2 dcl 48 set ref 283 283

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
code                                   automatic       fixed bin(35,0)          dcl 29
get_line_length_$switch         000000 constant        entry                    external dcl 45
iox_$iocb_version_sentinel             external static char(4)                  dcl 2-51

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          002315 constant        label                    dcl 157 ref 148
dump                            002300 constant        entry                    external dcl 152
on_line                         002251 constant        entry                    external dcl 144
prtscu_                         002236 constant        entry                    external dcl 11

NAME DECLARED BY CONTEXT OR IMPLICATION.
rel                                                    builtin function         ref 147

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4424        4452    4307        4434
Length      4702    4307        26         214     115           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
prtscu_                             336 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
prtscu_                  000100 strbuf                      prtscu_
                         000172 strp                        prtscu_
                         000174 byptr                       prtscu_
                         000176 refptr                      prtscu_
                         000200 lnpos                       prtscu_
                         000201 flt_lng                     prtscu_
                         000202 inst6                       prtscu_
                         000203 i                           prtscu_
                         000204 j                           prtscu_
                         000205 reoffset                    prtscu_
                         000206 flt_ln                      prtscu_
                         000237 flt_bf                      prtscu_
                         000246 iocbp                       prtscu_
                         000250 tsrpr                       prtscu_
                         000251 on_line                     prtscu_
                         000252 cvbinbuf                    prtscu_
                         000255 at_by_wd                    prtscu_
                         000256 TAG_ptr                     prtscu_
                         000260 tag_prt                     prtscu_
                         000261 tag_                        prtscu_
                         000262 TAG_table                   prtscu_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_bin_$oct                   db_print                      interpret_ptr_                ioa_$ioa_switch
ioa_$rsnnl                    ol_dump_$namef_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    122 002137       123 002140       124 002142        11 002235        12 002244       144 002245       146 002262
    147 002264       148 002272       152 002273       154 002311       155 002312       157 002315       161 002326
    162 002331       164 002341       165 002361       167 002362       168 002365       172 002447       173 002453
    174 002454       175 002473       178 002530       179 002532       180 002535       181 002537       182 002543
    183 002546       184 002550       185 002555       187 002567       188 002571       190 002572       191 002575
    192 002577       194 002601       195 002607       196 002620       197 002634       198 002636       199 002640
    200 002645       201 002652       204 002721       205 002722       207 002756       208 002760       210 003003
    211 003012       214 003050       215 003055       216 003057       217 003074       219 003114       220 003116
    222 003172       225 003250       227 003252       228 003254       229 003271       231 003345       232 003347
    233 003364       237 003434       239 003504       240 003507       241 003514       242 003521       244 003562
    245 003564       246 003570       247 003574       248 003623       250 003626       251 003632       252 003637
    254 003700       255 003702       256 003706       257 003712       258 003741       260 003744       261 003751
    262 003757       264 004020       266 004022       267 004024       269 004032       270 004034       271 004040
    274 004042       275 004053       276 004057       281 004113       282 004136       283 004220       288 004305


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
