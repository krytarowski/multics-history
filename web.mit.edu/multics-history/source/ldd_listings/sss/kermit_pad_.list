	COMPILATION LISTING OF SEGMENT kermit_pad_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1937.68_Mon_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(88-05-16,Huen), approve(88-05-16,MCR7841), audit(88-05-25,RWaters),
       13*     install(88-07-05,MR12.2-1054):
       14*     Fix kermit 15, 16, 17, and 18.
       15*  2) change(89-01-02,Huen), approve(89-01-02,MCR8027), audit(89-01-25,Lee),
       16*     install(89-03-01,MR12.3-1020):
       17*     Fix kermit bugs: PC_File_Transfer 18, 20, and 23.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 kermit_pad_: proc;
       22   
       23   /********************************************************************/
       24   /*							*/
       25   /*n	kermit_pad_					*/
       26   /*							*/
       27   /*d	This routine is the Packet Assembler/Disassembler that is	*/
       28   /*d	responsible for taking text and formatting it into packets	*/
       29   /*d	and taking incoming packets and decoding them.		*/
       30   /*							*/
       31   /*l	Written:	84-10-15	by Dean Elhard			*/
       32   /*l	Modified: 86-09-29  by Don Kozlowski - Check if the server	*/
       33   /*l		kermit will honour the encoding of Receive_init	*/
       34   /*l		packets before the encoding is done. (kermit 12)	*/
       35   /*l     Modified: 87-06-12  by Don Kozlowski - Move  CR and NL      */
       36   /*l               constant definitions to include file. (kermit 15) */
       37   /*l     Modified: 87-06-12  by S.Huen - Add extended packet length  */
       38   /*l               support based on D. Kozlowski version.(kermit 16) */
       39   /*l	Modified:	87-07-22	by Don Kozlowski - Add packet_fix and	*/
       40   /*l		packet_type to get around optimizer bug.	*/
       41   /*l		for msf file support. (kermit 18)		*/
       42   /*l	Modified:	87-08-26	by Don Kozlowski - use offsets into	*/
       43   /*l		packet in decode_data procedure. (kermit 18)	*/
       44   /*							*/
       45   /********************************************************************/
       46   
       47   /* constants */
       48   
       49   dcl true		bit (1) static options (constant) init ("1"b);
       50   dcl false		bit (1) static options (constant) init ("0"b);
       51   
       52   dcl Seconds_to_microseconds fixed bin (71) static options (constant)
       53 			     init (1000000);
       54   
       55   dcl Transmit		char (1) static options (constant) init (">");
       56   dcl Receive		char (1) static options (constant) init ("<");
       57   
       58   dcl Char_encoding_offset	fixed bin static options (constant) init (32);
       59   dcl Max_packet_size	fixed bin static options (constant) init (1500);
       60   dcl No_eight_bit_encoding	char (1) static options (constant) init ("N");
       61   dcl No_repeat_encoding	char (1) static options (constant) init (" ");
       62   dcl Binary_file_type	char (1) static options (constant) init ("B");
       63   dcl Ascii_file_type	char (1) static options (constant) init ("A");
       64   
       65   dcl Eight_bit_byte_size	fixed bin (8) static options (constant) init (8);
       66   
       67   dcl Receive_init_packet_type char (1) static options (constant) init ("R");
       68   dcl Send_init_packet_type	char (1) static options (constant) init ("S");
       69   dcl Ack_packet_type	char (1) static options (constant) init ("Y");
       70   dcl Server_init_packet_type char (1) static options (constant) init ("I");
       71   
       72   dcl Ascii_ctl_limit	fixed bin static options (constant) init (31);
       73   dcl Ascii_printable_limit	fixed bin static options (constant) init (126);
       74   dcl Ascii_pad_char	fixed bin static options (constant) init (127);
       75   
       76   dcl Max_repeat_encoding	fixed bin static options (constant) init (94);
       77   dcl Min_repeat_encoding	fixed bin static options (constant) init (4);
       78   
       79   dcl Mark_parity		char (1) static options (constant) init ("M");
       80   dcl Space_parity		char (1) static options (constant) init ("S");
       81   dcl No_parity		char (1) static options (constant) init ("N");
       82   
       83   /* parameters */
       84   
       85   dcl A_infop		ptr parameter;
       86   dcl A_crnl		bit (1) parameter;
       87   dcl A_rcvd		fixed bin (21) parameter;
       88   dcl A_sent		fixed bin (21) parameter;
       89   dcl A_size		fixed bin (21) parameter;
       90   dcl A_datal		fixed bin (21) parameter;
       91   dcl A_datap		ptr parameter;
       92   dcl A_code		fixed bin (35) parameter;
       93   dcl A_bufl		fixed bin (21) parameter;
       94   dcl A_bufp		ptr parameter;
       95   dcl A_seq_no		fixed bin parameter;
       96   dcl A_type		char (1) parameter;
       97   
       98   /* procedures */
       99   
      100   dcl add_char_offset_	entry (ptr, fixed bin(21)) 
      101 			    returns(ptr) reducible;
      102   dcl iox_$control		entry (ptr, char(*), ptr, fixed bin(35));
      103   dcl iox_$put_chars	entry (ptr, ptr, fixed bin(21), fixed bin(35));
      104   dcl timed_io_$get_chars	entry (ptr, fixed bin(71), ptr, fixed bin(21),
      105 			     fixed bin(21), fixed bin(35));
      106   
      107   /* external */
      108   
      109   dcl error_table_$line_status_pending
      110 			external fixed bin (35);
      111   dcl error_table_$timeout
      112 			external fixed bin (35);
      113   dcl kermit_et_$cannot_decode
      114 			external fixed bin (35);
      115   dcl kermit_et_$crc_error	external fixed bin (35);
      116   dcl kermit_et_$length_mismatch
      117 			external fixed bin (35);
      118   dcl kermit_et_$mangled_packet
      119 			external fixed bin (35);
      120   dcl kermit_et_$unimplemented_check_type
      121 			external fixed bin (35);
      122   dcl sys_info$max_seg_size	external fixed bin (35);
      123   
      124   /* based */
      125   
      126   /* automatic */
      127   
      128   dcl ec			fixed bin (35);
      129   dcl packet		char (Max_packet_size) varying;
      130   
      131   /* builtin */
      132   
      133   dcl addr		builtin;
      134   dcl addrel		builtin;
      135   dcl bin			builtin;
      136   dcl bool		builtin;
      137   dcl byte		builtin;  
      138   dcl copy		builtin;
      139   dcl index		builtin;
      140   dcl length		builtin;
      141   dcl min	                    builtin;
      142   dcl mod			builtin;
      143   dcl null		builtin;
      144   dcl rank		builtin;
      145   dcl rtrim		builtin;
      146   dcl string                  builtin;  
      147   dcl substr                  builtin;
      148   dcl unspec                  builtin;
      149   dcl verify		builtin;
      150   
      151   /* include files */
      152   
      153 
  1     1 /*  START OF:	kermit_dcls.incl.pl1		  *  *  *  *  *  */
  1     2   
  1     3   /********************************************************************/
  1     4   /*							*/
  1     5   /*n	kermit_dcls					*/
  1     6   /*							*/
  1     7   /*d	This include file contains the declarations of the external	*/
  1     8   /*d	kermit entrypoints that are called by other modules within	*/
  1     9   /*d	kermit as well as an explanation of the parameters.	*/
  1    10   /*							*/
  1    11   /*l	Written:	84-10-11	by Dean Elhard			*/
  1    12   /*							*/
  1    13   /********************************************************************/
  1    14   
  1    15   dcl kermit_comm_mgr_$flush_input
  1    16 			entry
  1    17 	(ptr,			/* kermit info ptr		*/
  1    18 	fixed bin(35));		/* error code		*/
  1    19   
  1    20   dcl kermit_comm_mgr_$reset_line_modes
  1    21 			entry
  1    22 	(ptr,			/* kermit info ptr		*/
  1    23 	fixed bin(35));		/* error code		*/
  1    24   
  1    25   dcl kermit_comm_mgr_$set_line_modes
  1    26 			entry
  1    27 	(ptr,			/* kermit info ptr		*/
  1    28 	fixed bin(35));		/* error code		*/
  1    29   
  1    30   dcl kermit_get_filenames_	entry
  1    31 	(ptr,			/* kermit info ptr		*/
  1    32 	 char(*),			/* argument		*/
  1    33 	 ptr,			/* filename ptr		*/
  1    34 	 char(*),			/* reason			*/
  1    35 	 fixed bin(35));		/* error code		*/
  1    36   
  1    37   dcl kermit_log_mgr_$close_log
  1    38 			entry
  1    39 	(ptr,			/* kermit info ptr		*/
  1    40 	 fixed bin (35));		/* error code		*/
  1    41   
  1    42   dcl kermit_log_mgr_$disable	entry
  1    43   	(ptr,			/* kermit info ptr		*/
  1    44 	 fixed bin (35));		/* error code		*/
  1    45   
  1    46   dcl kermit_log_mgr_$display_stats
  1    47 			entry	/* statistics command	*/
  1    48   	(ptr,			/* sci ptr		*/
  1    49 	 ptr);			/* kermit info ptr		*/
  1    50   
  1    51   dcl kermit_log_mgr_$enable	entry
  1    52 	(ptr,			/* kermit info ptr		*/
  1    53 	 fixed bin (35));		/* error code		*/
  1    54   
  1    55   dcl kermit_log_mgr_$log_message
  1    56 			entry 
  1    57 	(ptr,			/* kermit info ptr		*/
  1    58 	 ptr);			/* log info ptr		*/
  1    59   
  1    60   dcl kermit_log_mgr_$open_log
  1    61 			entry 
  1    62 	(ptr,			/* kermit info ptr		*/
  1    63 	 char (*) varying,		/* log file name		*/
  1    64 	 fixed bin (35));		/* error code		*/
  1    65   
  1    66   dcl kermit_log_mgr_$start	entry	/* start log command	*/
  1    67   	(ptr,			/* sci ptr		*/
  1    68 	 ptr);			/* kermit info ptr		*/
  1    69   
  1    70   dcl kermit_log_mgr_$stop	entry	/* stop log command		*/
  1    71 	(ptr,			/* sci ptr		*/
  1    72 	 ptr);			/* kermit info ptr		*/
  1    73   
  1    74   dcl kermit_mode_mgr_$get	entry	/* get modes command	*/
  1    75 	(ptr,			/* sci ptr		*/
  1    76 	 ptr);			/* kermit info ptr		*/
  1    77   
  1    78   dcl kermit_mode_mgr_$retrieve
  1    79 			entry
  1    80 	(ptr,			/* kermit info ptr		*/
  1    81 	 fixed bin,		/* permanent/temporary select	*/
  1    82 	 (*) fixed bin,		/* mode selector array	*/
  1    83 	 ptr,			/* mode value ptr		*/
  1    84 	 fixed bin (35));		/* error code		*/
  1    85   
  1    86   dcl kermit_mode_mgr_$set	entry	/* set modes command	*/
  1    87 	(ptr,			/* sci ptr		*/
  1    88 	 ptr);			/* kermit info ptr		*/
  1    89   
  1    90   dcl kermit_mode_mgr_$store	entry
  1    91 	(ptr,			/* kermit info ptr		*/
  1    92 	 fixed bin,		/* permanent/temporary select	*/
  1    93 	 (*) fixed bin,		/* mode selector array	*/
  1    94 	 ptr,			/* mode value ptr		*/
  1    95 	 fixed bin (35));		/* error code		*/
  1    96   
  1    97   dcl kermit_pad_$receive	entry
  1    98 	(ptr,			/* kermit info ptr		*/
  1    99 	 char (1),		/* packet type		*/
  1   100   	 ptr,			/* buffer pointer		*/
  1   101 	 fixed bin (21),		/* buffer length		*/
  1   102 	 fixed bin,		/* sequence number		*/
  1   103 	 fixed bin (21),		/* chars received		*/
  1   104 	 fixed bin (21),		/* packet size		*/
  1   105 	 bit (1),			/* CR/NL split flag		*/
  1   106 	 fixed bin (35));		/* error code		*/
  1   107   
  1   108   dcl kermit_pad_$send	entry
  1   109   	(ptr,			/* kermit info ptr		*/
  1   110 	 char (1),		/* packet type		*/
  1   111 	 ptr,			/* data ptr		*/
  1   112 	 fixed bin (21),		/* data length		*/
  1   113 	 fixed bin,		/* sequence number		*/
  1   114 	 fixed bin (21),		/* chars transmitted	*/
  1   115 	 fixed bin (21),		/* packet length		*/
  1   116 	 fixed bin (35));		/* error code		*/
  1   117   
  1   118   dcl kermit_receive_$receive_from_remote
  1   119 			entry
  1   120 	(ptr,			/* kermit info ptr		*/
  1   121 	 fixed bin,		/* initial state		*/
  1   122 	 fixed bin,                   /* initial sequence number    */
  1   123 	 char (*),		/* user filename (first file)	*/
  1   124 	 bit (1),			/* =1 if user gave filename	*/
  1   125 	 fixed bin,		/* number of files received	*/
  1   126 	 fixed bin (35));		/* error code		*/
  1   127 
  1   128   dcl kermit_send_$send_to_remote
  1   129 			entry 
  1   130 	(ptr,			/* kermit info ptr		*/
  1   131 	 ptr,			/* filenames area ptr	*/
  1   132 	 char (*),		/* user filename (first file)	*/
  1   133 	 bit (1),			/* =1 if user gave filename	*/
  1   134 	 fixed bin,                   /* number of files sent       */
  1   135 	 fixed bin (35));		/* error code		*/
  1   136 
  1   137 
  1   138   dcl kermit_server_
  1   139 			entry 
  1   140 	(ptr,			/* kermit info ptr		*/
  1   141 	 ptr);			/* filenames area ptr	*/
  1   142 
  1   143 
  1   144   dcl kermit_xfer_modes_$check_params
  1   145 			entry
  1   146 	(ptr,			/*  kermit info ptr		*/
  1   147 	 ptr,			/*  remote parameters	*/
  1   148 	 fixed bin (21),		/*  remote parameters length	*/
  1   149 	 ptr,                         /*  local parameters          */
  1   150 	 fixed bin (35));		/*  error code		*/
  1   151 
  1   152   dcl kermit_xfer_modes_$init 
  1   153 			entry
  1   154 	(ptr,			/*  ptr to kermit info	*/
  1   155 	 fixed bin (35));		/*  error code		*/
  1   156 
  1   157   dcl kermit_xfer_modes_$get_local_params
  1   158 			entry
  1   159 	(ptr,			/*  kermit info ptr		*/
  1   160 	 ptr,			/*  local parameters	*/
  1   161  	 fixed bin (21),		/*  local parameters length	*/
  1   162 	 ptr,			/*  encoded parameters	*/
  1   163 	 fixed bin (21),		/*  encoded parameters length */
  1   164 	 fixed bin (35));		/*  error code		*/
  1   165 
  1   166   dcl kermit_xfer_modes_$process_params
  1   167 			entry
  1   168 	(ptr,			/*  kermit info ptr		*/
  1   169 	 ptr,			/*  remote parameters	*/
  1   170 	 fixed bin (21),		/*  remote parameters length	*/
  1   171 	 ptr,                         /*  local parameters          */
  1   172 	 fixed bin (35));		/*  error code		*/
  1   173 
  1   174 /*  END OF:	kermit_dcls.incl.pl1		  *  *  *  *  *  */
      154 
      155 
  2     1 /*  START OF:	kermit_info.incl.pl1		  *  *  *  *  *  */
  2     2   
  2     3 
  2     4   
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(88-05-16,Huen), approve(88-05-16,MCR7841), audit(88-05-25,RWaters),
  2     8*     install(88-07-05,MR12.2-1054):
  2     9*     Fix kermit 15, 16, 17, and 18.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /********************************************************************/
  2    14   /*							*/
  2    15   /*n	kermit_constants					*/
  2    16   /*							*/
  2    17   /*d	This structure contains the constant definitions of CR, 	*/
  2    18   /*d  and NL characters which are coded as bit strings with 	*/
  2    19   /*d  overlays.                                                      */
  2    20   /*							*/
  2    21   /*l	Written:	87-06-19	by Don Kozlowski			*/
  2    22   /*l     Modified: 87-06-19  by Don Kozlowski - CR and NL are coded  */
  2    23   /*l			as bit strings with overlays (kermit 15)*/
  2    24   /*							*/
  2    25   /********************************************************************/
  2    26 
  2    27   dcl 01 kermit_bit_constants	internal static options (constant),
  2    28          02 CR_bit		bit (9) unaligned init ("015"b3),
  2    29          02 NL_bit		bit (9) unaligned init ("012"b3);
  2    30 
  2    31   dcl 01 kermit_char_constants based (addr (kermit_bit_constants)),
  2    32          02 CR		char (1) unaligned,
  2    33          02 NL		char (1) unaligned;
  2    34 
  2    35   dcl 01 kermit_fixed_constants based (addr (kermit_bit_constants)),
  2    36          02 CR_fixed	fixed bin (9) unsigned unaligned,
  2    37          02 NL_fixed	fixed bin (9) unsigned unaligned;
  2    38 	
  2    39 
  2    40   /********************************************************************/
  2    41   /*							*/
  2    42   /*n	kermit_info					*/
  2    43   /*							*/
  2    44   /*d	This data structure is the subsystem info structure used	*/
  2    45   /*d	when creating a kermit invocation.  It is used to find the	*/
  2    46   /*d	three kermit databases.				*/
  2    47   /*							*/
  2    48   /*l	Written:	84-10-11	by Dean Elhard			*/
  2    49   /*							*/
  2    50   /********************************************************************/
  2    51   
  2    52   dcl 01 kermit_info	aligned based (kermit_infop),
  2    53        02 version		char (8),
  2    54        02 sci_ptr		ptr,	/* ssu_ sci_ptr		*/
  2    55        02 perm_modesp	ptr,	/* ptr to permanent modes db	*/
  2    56        02 temp_modesp	ptr,	/* ptr to temporary modes db	*/
  2    57        02 log_infop		ptr,	/* ptr to log info db	*/
  2    58        02 comm_infop	ptr;	/* ptr to comm info db	*/
  2    59   
  2    60   dcl kermit_infop		ptr;
  2    61   dcl kermit_info_version	char (8) static options (constant)
  2    62 			     init ("ki   1.0");
  2    63   
  2    64   /********************************************************************/
  2    65   /*							*/
  2    66   /*n	kermit_perm_modes					*/
  2    67   /*							*/
  2    68   /*d	This data structure contains the array of 9-bit values that	*/
  2    69   /*d	represent the permanent kermit modes.			*/
  2    70   /*							*/
  2    71   /*l	Written:	84-10-11	by Dean Elhard			*/
  2    72   /*l     Modified: 87-06-12  by Don Kozlowski - Increase mode_counts */
  2    73   /*l			(kermit 16)			*/
  2    74   /*							*/
  2    75   /********************************************************************/
  2    76   
  2    77   dcl 01 kermit_perm_modes	aligned based (kermit_perm_modesp),
  2    78        02 version		char (8),
  2    79        02 mode (1:kermit_perm_mode_count)
  2    80 			bit (9) unaligned;
  2    81   
  2    82   dcl kermit_perm_modesp	ptr;
  2    83   dcl kermit_perm_mode_count	fixed bin static options (constant) init (20);
  2    84   dcl kermit_perm_modes_version
  2    85 			char (8) static options (constant)
  2    86 			     init ("kpm  1.1");
  2    87   
  2    88   /********************************************************************/
  2    89   /*							*/
  2    90   /*n	kermit_temp_modes					*/
  2    91   /*							*/
  2    92   /*d	This data structure contains the array of 9-bit values that	*/
  2    93   /*d	represent the temporary kermit modes.			*/
  2    94   /*							*/
  2    95   /*l	Written:	84-10-11	by Dean Elhard			*/
  2    96   /*							*/
  2    97   /********************************************************************/
  2    98   
  2    99   dcl 01 kermit_temp_modes	aligned based (kermit_temp_modesp),
  2   100        02 version		char (8),
  2   101        02 mode (1:kermit_temp_mode_count)
  2   102 			bit (9) unaligned;
  2   103   
  2   104   dcl kermit_temp_modesp	ptr;
  2   105   dcl kermit_temp_mode_count	fixed bin static options (constant) init (23);
  2   106   dcl kermit_temp_modes_version
  2   107 			char (8) static options (constant)
  2   108 			     init ("ktm  1.1");
  2   109   
  2   110   /********************************************************************/
  2   111   /*							*/
  2   112   /*n	kermit_log_info					*/
  2   113   /*							*/
  2   114   /*d	This data structure contains 2 types of logging info:	*/
  2   115   /*d	     - data concerning the logging state and log_file	*/
  2   116   /*d	     - statistics on the last completed file-transfer	*/
  2   117   /*							*/
  2   118   /*l	Written:	84-10-11	by Dean Elhard			*/
  2   119   /*							*/
  2   120   /********************************************************************/
  2   121   
  2   122   dcl 01 kermit_log_info	aligned based (kermit_log_infop),
  2   123        02 version		char (8),
  2   124        02 log_file		aligned,		/* log_file info	*/
  2   125         03 iocbp		ptr,		/* iocb ptr	*/
  2   126         03 flags		aligned,
  2   127          04 enabled		bit (1) unaligned,	/* enabled flag	*/
  2   128          04 stats_valid	bit (1) unaligned,	/* stats are set	*/
  2   129          04 mbz		bit (34) unaligned,
  2   130        02 statistics	aligned like kermit_stats_info;
  2   131   
  2   132   dcl kermit_log_infop	ptr;
  2   133   dcl kermit_log_info_version char (8) static options (constant)
  2   134 			     init ("kli  1.0");
  2   135   
  2   136   /********************************************************************/
  2   137   /*							*/
  2   138   /*n	kermit_stats_info					*/
  2   139   /*							*/
  2   140   /*d	This structure is the statistics information passed to the	*/
  2   141   /*d	log manager and stored as the statistics.		*/
  2   142   /*							*/
  2   143   /*l	Written:	84-10-25	by Dean Elhard			*/
  2   144   /*							*/
  2   145   /********************************************************************/
  2   146   
  2   147   dcl 01 kermit_stats_info	aligned based (kermit_stats_infop),
  2   148        02 caller		char (32),	/* send or receive	*/
  2   149        02 status		fixed bin (35),	/* status of F-T	*/
  2   150        02 filename		char (194) unal,	/* name of file	*/
  2   151        02 file_len		fixed bin (21),	/* len in chars	*/
  2   152        02 char_count	fixed bin (21),	/* number sent	*/
  2   153        02 packet_chars	fixed bin (21),	/* after encoding	*/
  2   154        02 packet_count	fixed bin (21),	/* num of packets	*/
  2   155        02 packet_retries	fixed bin (21),	/* retries done	*/
  2   156        02 start_time	fixed bin (71),	/* time F-T started	*/
  2   157        02 end_time		fixed bin (71),	/* time F-T done	*/
  2   158        02 error_message	char (94);	/* rcvd error msg	*/
  2   159   
  2   160   dcl kermit_stats_infop	ptr;
  2   161   
  2   162   /********************************************************************/
  2   163   /*							*/
  2   164   /*n	kermit_comm_info					*/
  2   165   /*							*/
  2   166   /*d	This data structure contains information regarding the	*/
  2   167   /*d	communications channel over which the file transfer takes	*/
  2   168   /*d	place.						*/
  2   169   /*							*/
  2   170   /*l	Written:	84-10-12	by Dean Elhard			*/
  2   171   /*l	Modified: 86-10-09  by Don Kozlowski Add transfer_modes_set	*/
  2   172   /*l                         and server indicators. (kermit 13)      */
  2   173   /*							*/
  2   174   /********************************************************************/
  2   175   
  2   176   dcl 01 kermit_comm_info	aligned based (kermit_comm_infop),
  2   177        02 version		char (8),
  2   178        02 ft_iocbp		ptr,		/* transfer iocbp	*/
  2   179        02 debug_segp	ptr,		/* debug segment	*/
  2   180        02 debug_segl	fixed bin (21),
  2   181        02 input_buffer	aligned,		/* input buffer	*/
  2   182         03 bufferp		ptr,
  2   183         03 bufferl		fixed bin (21),
  2   184        02 old_modes		char (512) unal,	/* ft switch modes	*/
  2   185        02 old_framing_chars	aligned,		/* saved frm chars	*/
  2   186         03 start_char	char (1) unaligned,
  2   187         03 end_char		char (1) unaligned,
  2   188         03 server		bit (1) unaligned,	/* In server mode	*/
  2   189         03 transfer_modes_set	bit (1) unaligned,
  2   190         03 pad		bit (16) unaligned,
  2   191        02 old_wake_table	aligned,		/* saved wake table	*/
  2   192         03 breaks (0:127)	bit (1) unaligned,
  2   193         03 mbz		bit (16) unaligned,
  2   194        02 old_delays	aligned,		/* saved delay info	*/
  2   195         03 version		fixed bin,
  2   196         03 default		fixed bin,
  2   197         03 delay,
  2   198          04 vert_nl		fixed bin,
  2   199          04 horz_nl		fixed bin,
  2   200          04 const_tab	float bin,
  2   201          04 var_tab		fixed bin,
  2   202          04 backspace	fixed bin,
  2   203          04 vt_ff		fixed bin;
  2   204   
  2   205   dcl kermit_comm_infop	ptr;
  2   206   dcl kermit_comm_info_version
  2   207 			char (8) static options (constant)
  2   208 			     init ("kci  1.0");
  2   209   
  2   210 /*  END OF:	kermit_info.incl.pl1		  *  *  *  *  *  */
      156 
      157 
  3     1 /*  START OF:	kermit_mode_info.incl.pl1		  *  *  *  *  *  */
  3     2   
  3     3 
  3     4   
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(88-05-16,Huen), approve(88-05-16,MCR7841), audit(88-05-25,RWaters),
  3     8*     install(88-07-05,MR12.2-1054):
  3     9*     Fix kermit 15, 16, 17, and 18.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /************************************************************************/
  3    14   /*							    */
  3    15   /*l     Modified: 87-06-19  by S. Huen - Add fields for capabilities,   */
  3    16   /*l		window_size, max_len_ext_1 and max_len_ext_2  based   */
  3    17   /*l		on D. Kozlowski's version. (kermit 16)                */
  3    18   /*                                                                      */
  3    19   /************************************************************************/
  3    20 
  3    21   dcl Permanent		fixed bin static options (constant) init (1);
  3    22   dcl Temporary		fixed bin static options (constant) init (2);
  3    23   
  3    24   dcl Store_all (1:1)	fixed bin static options (constant) init (0);
  3    25   dcl Retrieve_all (1:1)	fixed bin static options (constant) init (0);
  3    26   
  3    27   dcl Maxl		fixed bin static options (constant) init (1);
  3    28   dcl Timeout		fixed bin static options (constant) init (2);
  3    29   dcl N_pads		fixed bin static options (constant) init (3);
  3    30   dcl Pad_char		fixed bin static options (constant) init (4);
  3    31   dcl Eol_char		fixed bin static options (constant) init (5);
  3    32   dcl Quote_char		fixed bin static options (constant) init (6);
  3    33   dcl Eight_bit_char	fixed bin static options (constant) init (7);
  3    34   dcl Repeat_char		fixed bin static options (constant) init (8);
  3    35   dcl Start_char		fixed bin static options (constant) init (9);
  3    36   dcl Check_type		fixed bin static options (constant) init (10);
  3    37   dcl Parity		fixed bin static options (constant) init (11);
  3    38   dcl Incomplete		fixed bin static options (constant) init (12);
  3    39   dcl File_warning		fixed bin static options (constant) init (13);
  3    40   dcl File_type		fixed bin static options (constant) init (14);
  3    41   dcl Retry_threshold	fixed bin static options (constant) init (15);
  3    42   dcl Line_byte_size	fixed bin static options (constant) init (16);
  3    43   dcl Window_size		fixed bin static options (constant) init (17);
  3    44   dcl Max_len_ext_1		fixed bin static options (constant) init (18);
  3    45   dcl Max_len_ext_2		fixed bin static options (constant) init (19);
  3    46   dcl Capabilities		fixed bin static options (constant) init (20);
  3    47   
  3    48   dcl 01 Perm_defaults	aligned static options (constant),
  3    49        02 maxl		fixed bin (8) unal init (80),
  3    50        02 time		fixed bin (8) unal init (15),
  3    51        02 npad		fixed bin (8) unal init (0),
  3    52        02 padc		char (1) unal init (" "),
  3    53        02 eol		char (1) unal init (""),
  3    54        02 qctl		char (1) unal init ("#"),
  3    55        02 qbin		char (1) unal init ("&"),
  3    56        02 rept		char (1) unal init ("~"),
  3    57        02 start		char (1) unal init (""),
  3    58        02 chkt		fixed bin (8) unal init (1),
  3    59        02 parity		char (1) unal init ("N"),
  3    60        02 incomplete	char (1) unal init ("K"),
  3    61        02 file_warning	char (1) unal init ("Y"),
  3    62        02 file_type		char (1) unal init ("A"),
  3    63        02 retry_threshold	fixed bin (8) unal init (5),
  3    64        02 line_type		fixed bin (8) unal init (7),
  3    65        02 window_size	fixed bin (8) unal init (0),
  3    66        02 max_len_ext_1	fixed bin (8) unal init (5),
  3    67        02 max_len_ext_2	fixed bin (8) unal init (25),
  3    68        02 capabilities	fixed bin (8) unal init (2);
  3    69 	
  3    70   
  3    71   dcl I_maxl		fixed bin static options (constant) init (1);
  3    72   dcl I_timeout		fixed bin static options (constant) init (2);
  3    73   dcl I_n_pads		fixed bin static options (constant) init (3);
  3    74   dcl I_pad_char		fixed bin static options (constant) init (4);
  3    75   dcl I_eol_char		fixed bin static options (constant) init (5);
  3    76   dcl I_quote_char		fixed bin static options (constant) init (6);
  3    77   dcl O_maxl		fixed bin static options (constant) init (7);
  3    78   dcl O_timeout		fixed bin static options (constant) init (8);
  3    79   dcl O_n_pads		fixed bin static options (constant) init (9);
  3    80   dcl O_pad_char		fixed bin static options (constant) init (10);
  3    81   dcl O_eol_char		fixed bin static options (constant) init (11);
  3    82   dcl O_quote_char		fixed bin static options (constant) init (12);
  3    83   dcl G_eight_bit_char	fixed bin static options (constant) init (13);
  3    84   dcl G_repeat_char		fixed bin static options (constant) init (14);
  3    85   dcl G_start_char		fixed bin static options (constant) init (15);
  3    86   dcl G_check_type		fixed bin static options (constant) init (16);
  3    87   dcl G_parity		fixed bin static options (constant) init (17);
  3    88   dcl G_window		fixed bin static options (constant) init (18);
  3    89   dcl I_max_lenx1		fixed bin static options (constant) init (19);
  3    90   dcl I_max_lenx2		fixed bin static options (constant) init (20);
  3    91   dcl O_max_lenx1		fixed bin static options (constant) init (21);
  3    92   dcl O_max_lenx2		fixed bin static options (constant) init (22);
  3    93   dcl G_capabilities	fixed bin static options (constant) init (23);
  3    94   
  3    95   dcl 01 Temp_defaults	aligned static options (constant),
  3    96        02 i_maxl		fixed bin (8) unal init (80),
  3    97        02 i_time		fixed bin (8) unal init (15),
  3    98        02 i_npad		fixed bin (8) unal init (0),
  3    99        02 i_padc		char (1) unal init (" "),
  3   100        02 i_eol		char (1) unal init (""),
  3   101        02 i_qctl		char (1) unal init ("#"),
  3   102        02 o_maxl		fixed bin (8) unal init (80),
  3   103        02 o_time		fixed bin (8) unal init (15),
  3   104        02 o_npad		fixed bin (8) unal init (0),
  3   105        02 o_padc		char (1) unal init (" "),
  3   106        02 o_eol		char (1) unal init (""),
  3   107        02 o_qctl		char (1) unal init ("#"),
  3   108        02 qbin		char (1) unal init ("N"),
  3   109        02 rept		char (1) unal init (" "),
  3   110        02 start		char (1) unal init (""),
  3   111        02 chkt		fixed bin (8) unal init (1),
  3   112        02 parity		char (1) unal init ("N"),
  3   113        02 window		fixed bin (8) unal init (0),
  3   114        02 i_maxlx1		fixed bin (8) unal init (5),
  3   115        02 i_maxlx2		fixed bin (8) unal init (25),
  3   116        02 o_maxlx1		fixed bin (8) unal init (5),
  3   117        02 o_maxlx2		fixed bin (8) unal init (25),
  3   118        02 capabilities	fixed bin (8) unal init (2);
  3   119 	
  3   120   dcl Ext_Headers		bit (9) static options (constant) init ("002"b3);
  3   121 	
  3   122 
  3   123 /*  END OF:	kermit_mode_info.incl.pl1		  *  *  *  *  *  */
      158 
      159 
      160 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      161 
      162 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      163 
      164 
      165 send: entry (A_infop,	/* subsystem info pointer		*/
      166 	   A_type,	/* packet type			*/
      167 	   A_datap,	/* pointer to the data buffer		*/
      168 	   A_datal,	/* length of the data buffer		*/
      169 	   A_seq_no,	/* packet sequence number		*/
      170 	   A_sent,	/* number of chars sent from buffer	*/
      171 	   A_size,	/* length of packet in chars		*/
      172 	   A_code);	/* returned status code		*/
      173   
      174   /********************************************************************/
      175   /*							*/
      176   /*n	Name:	kermit_pad_$send			external	*/
      177   /*i	Input:	packet_type, data, sequence_no, info_ptr	*/
      178   /*f	Function:	calls encode_data to encode the data, calls	*/
      179   /*f		append_ctl_info to add the sequence_number and	*/
      180   /*f		length, calls append_checksum to calculate and	*/
      181   /*f		add the checksum, and the calls transmit_packet	*/
      182   /*f		to add parity if required and send the packet to	*/
      183   /*f		the remote system.				*/
      184   /*o	Output:	error_code, characters_transmitted, packet_size	*/
      185   /*							*/
      186   /*l	Written:	84-10-15	by Dean Elhard			*/
      187   /*							*/
      188   /********************************************************************/
      189   
      190   call encode_data (A_infop, A_type, A_datap, A_datal, packet,
      191 			A_sent, ec);
      192   
      193   call append_ctl_info (A_infop, A_seq_no, packet);
      194   
      195   call append_checksum (A_infop, packet, A_code);
      196   if A_code ^= 0
      197     then return;
      198     
      199   A_size = length (packet) + 2;
      200   
      201   call transmit_packet (A_infop, packet, A_code);
      202   if A_code = 0
      203     then A_code = ec;
      204     
      205   return;
      206 
      207 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      208 
      209 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      210 
      211 
      212 receive: entry (A_infop,	/* subsystem info pointer		*/
      213 	      A_type,	/* packet type received		*/
      214 	      A_bufp,	/* pointer to text buffer		*/
      215 	      A_bufl,	/* length of text buffer		*/
      216 	      A_seq_no,	/* sequence number of packet received	*/
      217 	      A_rcvd,	/* number of decoded chars received	*/
      218 	      A_size,	/* size or received packet		*/
      219 	      A_crnl,	/* flag if CR/NL encoding spans packet	*/
      220 	      A_code);	/* output status code		*/
      221 
      222   /********************************************************************/
      223   /*							*/
      224   /*n	Name:	kermit_pad_$receive			external	*/
      225   /*i	Input:	info_ptr					*/
      226   /*f	Function:	calls receive_packet to get the packet, then	*/
      227   /*f		calls validate_checksum to make sure the checksum	*/
      228   /*f		is correct and to remove it from the packet, then	*/
      229   /*f		calls check_ctl_info to extract the sequence_no	*/
      230   /*f		and validate that the length is correct,	*/
      231   /*f		and then calls decode_data to decode the data	*/
      232   /*f		section of the packet.			*/
      233   /*o	Output:	data, packet_type, sequence_number, packet_size,	*/
      234   /*o		chars_recieved, spanned_cr/nl_flag, error_code	*/
      235   /*							*/
      236   /*l	Written:	84-10-15	by Dean Elhard			*/
      237   /*							*/
      238   /********************************************************************/
      239   
      240   A_rcvd = 0;
      241   A_size = 0;
      242   A_seq_no = 0;
      243   
      244   call receive_packet (A_infop, packet, A_size, A_code);
      245   if A_code ^= 0
      246     then return;
      247     
      248   call validate_checksum (A_infop, packet, A_code);
      249   if A_code ^= 0
      250     then return;
      251     
      252   call check_ctl_info (A_infop, packet, A_seq_no, A_code);
      253   if A_code ^= 0
      254     then return;
      255     
      256   call decode_data (A_infop, A_bufp, A_bufl, A_type, packet, A_rcvd,
      257 		A_crnl, A_code);
      258   
      259   return;
      260 
      261 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      262 
      263 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      264 
      265 
      266 encode_data: proc (infop,	/* subsystem info pointer		*/
      267 	         type,	/* packet type to encode		*/
      268 	         datap,	/* ptr to data to be encoded		*/
      269 	         datal,	/* length of data to be encoded	*/
      270 	         packet,	/* encoded data packet		*/
      271 	         n_sent,	/* number of characters encoded	*/
      272 	         ec);	/* error code			*/
      273   
      274   /********************************************************************/
      275   /*							*/
      276   /*n	Name:	encode_data			internal	*/
      277   /*i	Input:	data, type, info_ptr			*/
      278   /*f	Function:	for each character until the buffer is full, call	*/
      279   /*f		encode_char to encode it into a sequence.  If the	*/
      280   /*f		sequence can be added to the packet,  add it and	*/
      281   /*f		continue, otherwise, prepend the type and quit	*/
      282   /*f		returning the number of chars encoded.		*/
      283   /*o	Output:	error_code, encoded_data, characters_encoded	*/
      284   /*							*/
      285   /*l	Written:	84-10-15	by Dean Elhard			*/
      286   /*l     Modified: 89-01-02  by S.Huen - kermit should use the packet*/
      287   /*l               length and control quoting character expected by  */
      288   /*l               the external kermit. (pc_18)                      */
      289   /*							*/
      290   /********************************************************************/
      291   
      292   /* parameters */
      293   
      294   dcl infop		ptr;
      295   dcl type		char (1);
      296   dcl datap		ptr;
      297   dcl datal		fixed bin (21);
      298   dcl packet		char (*) varying;
      299   dcl n_sent		fixed bin (21);
      300   dcl ec			fixed bin (35);
      301   
      302   /* based */
      303   
      304   dcl data		char (datal) based (datap);
      305   
      306   /* automatic */
      307   
      308   dcl t_selector (1:8)	fixed bin;
      309   dcl p_selector (1:2)	fixed bin;
      310   dcl 01 perm_modes		aligned,
      311        02 line_byte_size	fixed bin (8) unaligned,
      312        02 file_type		char (1) unaligned;
      313   dcl 01 capabilities	aligned,
      314        02 bit_string,
      315          03 eight_bit	bit (1) unaligned,
      316          03 repeat		bit (1) unaligned,
      317          03 binary		bit (1) unaligned,
      318          03 raw		bit (1) unaligned,
      319          03 ext_header	bit (1) unaligned,
      320          03 mbz		bit (33) unaligned,
      321        02 max_len		fixed bin;
      322 	   
      323 
      324   dcl 01 modes		aligned,
      325        02 maxl		fixed bin (8) unaligned,
      326        02 quote		char (1) unaligned,
      327        02 eight_bit		char (1) unaligned,
      328        02 repeat		char (1) unaligned,
      329        02 check_type	fixed bin (8) unaligned,
      330        02 capas		bit (9) unaligned,
      331        02 maxlnx1		fixed bin (9) unsigned unaligned,
      332        02 maxlnx2		fixed bin (9) unsigned unaligned;
      333 
      334   dcl done		bit (1);
      335   dcl subsetp		ptr;
      336   dcl subsetl		fixed bin (21);
      337   dcl sequence		char (5) varying;
      338   dcl n_chars		fixed bin;
      339   dcl header_size		fixed bin;  
      340   packet = "";
      341   ec = 0;
      342   
      343   /* fetch the packet length, check type and prefix characters	*/
      344   /* Fix bug 18 - Fetch the correct packet length and control quoting characters */
      345   
      346   t_selector (1) = O_maxl;
      347   t_selector (2) = O_quote_char;
      348   t_selector (3) = G_eight_bit_char;
      349   t_selector (4) = G_repeat_char;
      350   t_selector (5) = G_check_type;
      351   t_selector (6) = G_capabilities;
      352   t_selector (7) = O_max_lenx1;
      353   t_selector (8) = O_max_lenx2;
      354   
      355   call kermit_mode_mgr_$retrieve (infop, Temporary, t_selector,
      356 			addr (modes), ec);
      357   
      358   /* fetch the line type					*/
      359   
      360   p_selector (1) = Line_byte_size;
      361   p_selector (2) = File_type;
      362   
      363   call kermit_mode_mgr_$retrieve (infop, Permanent, p_selector,
      364 			addr (perm_modes), ec);
      365   
      366   string (capabilities.bit_string) = ""b;
      367   
      368   /* determine the capabilities from the line type and prefix chars	*/
      369   if modes.capas & Ext_Headers         /* extended packet headers	      */
      370        then do;
      371        capabilities.ext_header = true;
      372        capabilities.max_len = modes.maxlnx1 * 95 + modes.maxlnx2;
      373        end;
      374   else capabilities.max_len = modes.maxl;
      375 
      376   if modes.eight_bit ^= No_eight_bit_encoding
      377     then capabilities.eight_bit = true;
      378   if modes.repeat ^= No_repeat_encoding
      379     then capabilities.repeat = true;
      380     
      381   if perm_modes.line_byte_size = Eight_bit_byte_size
      382     then do;
      383       capabilities.raw = true;
      384       capabilities.eight_bit = false;
      385     end;
      386   
      387   if perm_modes.file_type = Binary_file_type
      388     then capabilities.binary = true;
      389     
      390   n_sent = 0;
      391   done = false;
      392   if capabilities.ext_header & (datal > 94)
      393        then header_size = 6;       /* Extended length packet header     */
      394   else header_size = 3;	         /* Normal packet header	      */
      395 
      396   
      397   /* skip encoding if there is no data to send			*/
      398   
      399   if datal = 0
      400     then do;
      401       n_sent = 0;
      402       packet = "";
      403     end;
      404     
      405    /* Do not encode send_init, server_init, ack, and receive_init      */
      406    /* packets before determining whether the server kermit will        */
      407    /* honour its encoding.                                             */
      408   
      409   else if type = Send_init_packet_type |
      410 	type = Receive_init_packet_type |
      411 	type = Ack_packet_type |
      412 	type = Server_init_packet_type
      413     then do;
      414       n_sent = min (datal, capabilities.max_len);
      415       packet = substr (data, 1, n_sent);
      416     end;
      417     else do while (^done);
      418       subsetp = add_char_offset_ (datap, (n_sent));
      419       subsetl = datal - n_sent;
      420       
      421       call encode_char (infop, subsetp, subsetl, sequence, n_chars,
      422 			modes.quote, modes.eight_bit, modes.repeat,
      423 			string (capabilities.bit_string));
      424       
      425       if length(packet) + length(sequence) > capabilities.max_len - modes.check_type - header_size
      426         then done = true;
      427         else do;
      428 	packet = packet || sequence;
      429 	n_sent = n_sent + n_chars;
      430 	if n_sent >= datal
      431 	  then done = true;
      432         end;
      433     end;
      434   
      435   /* prepend the packet type					*/
      436 
      437   packet = type || packet;
      438 
      439 end encode_data;
      440 
      441 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      442 
      443 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      444 
      445 
      446 append_ctl_info: proc (infop,		/* subsystem info pointer	*/
      447 		   seq_no,	/* sequence number to add	*/
      448 		   packet);	/* packed to add info to	*/
      449   
      450   /********************************************************************/
      451   /*							*/
      452   /*n	Name:	append_ctl_info			internal	*/
      453   /*i	Input:	encoded_data, info_ptr, sequence_no		*/
      454   /*f	Function:	gets the checksum type from the temp modes to	*/
      455   /*f		calculate the length of the packet, encodes the	*/
      456   /*f		length and sequence number and adds them to the	*/
      457   /*f		packet.					*/
      458   /*o	Output:	partial_packet				*/
      459   /*							*/
      460   /*l	Written:	84-10-15	by Dean Elhard			*/
      461   /*							*/
      462   /********************************************************************/
      463   
      464   /* parameters */
      465   
      466   dcl infop		ptr;
      467   dcl packet		char (*) varying;
      468   dcl seq_no		fixed bin;
      469   
      470   /* automatic */
      471   
      472   dcl selector (1:1)	fixed bin init (G_check_type);
      473   dcl chk_tp		fixed bin (8) unal;
      474   dcl ec			fixed bin (35);
      475   dcl (len, lenx1, lenx2)	fixed bin;
      476   dcl check		fixed bin;
      477   dcl hcheck		fixed bin (9) unsigned;
      478   dcl packet_fix		char (1);
      479   call kermit_mode_mgr_$retrieve (infop, Temporary, selector, 
      480 			addr (chk_tp), ec);
      481    
      482   /* calculate the length of the packet				*/
      483   
      484   len = length (packet) + chk_tp + 1;
      485 
      486   /* prepend the encoded length and sequence number		*/
      487   if len > 94
      488        then do;
      489        packet_fix = packet;	         /* Use packet_fix to strip off first */
      490 			         /* character of packet since substr  */
      491 			         /* doesn't work with -optimize	here  */
      492        len = len - 2;	         /* Calculate size after header	      */
      493        lenx1 = (len / 95) + Char_encoding_offset;
      494        lenx2 = mod (len, 95) + Char_encoding_offset;
      495        check = (Char_encoding_offset * 2) + seq_no
      496 	  + rank (packet_fix) + lenx1 + lenx2;
      497 
      498        hcheck = mod(check + (mod (check, 256) / 64), 64) + Char_encoding_offset;
      499        packet = substr (packet, 2);
      500        packet = byte (Char_encoding_offset) ||   /* Len = 0 	      */
      501 	      byte (seq_no + Char_encoding_offset) ||
      502 	      packet_fix ||	         /* Type		      */
      503 	      byte (lenx1) || byte (lenx2) ||
      504 	      byte (hcheck) || packet;
      505        end;
      506      else packet = byte (len + Char_encoding_offset) ||
      507 	byte (seq_no + Char_encoding_offset) || packet;
      508   
      509 end append_ctl_info;
      510 
      511 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      512 
      513 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      514 
      515 
      516 append_checksum: proc (infop,		/* subsystem info pointer	*/
      517 		   packet,	/* packet to add checksum to	*/
      518 		   ec);		/* error code		*/
      519   
      520   /********************************************************************/
      521   /*							*/
      522   /*n	Name:	append_checksum			internal	*/
      523   /*i	Input:	partial_packet, info_ptr			*/
      524   /*f	Function:	calls calculate_checksum to get the checksum	*/
      525   /*f		value, and appends it to the partial packet	*/
      526   /*o	Output:	packet					*/
      527   /*							*/
      528   /*l	Written:	84-10-15	by Dean Elhard			*/
      529   /*							*/
      530   /********************************************************************/
      531   
      532   /* parameters */
      533   
      534   dcl infop		ptr;
      535   dcl packet		char (*) varying;
      536   dcl ec			fixed bin (35);
      537   
      538   /* automatic */
      539   
      540   dcl checksum		char (3) varying;
      541   
      542   call calculate_checksum (infop, packet, checksum, ec);
      543   if ec ^= 0
      544     then return;
      545     
      546   packet = packet || checksum;
      547   
      548 end append_checksum;
      549 
      550 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      551 
      552 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      553 
      554 
      555 transmit_packet: proc (infop,		/* subsystem info pointer	*/
      556 		   packet,	/* packet to transmit	*/
      557 		   ec);		/* error code		*/
      558     
      559   /********************************************************************/
      560   /*							*/
      561   /*n	Name:	transmit_packet			internal	*/
      562   /*i	Input:	packet, info_ptr				*/
      563   /*f	Function:	prepends the mark character and the EOL		*/
      564   /*f		character, calls set_parity to set the parity	*/
      565   /*f		bits on the data if mark or space parity is	*/
      566   /*f		selected, appends the appropriate number of pad	*/
      567   /*f		characters and transmits the packet to the remote	*/
      568   /*f		computer.					*/
      569   /*o	Output:	error_code				*/
      570   /*							*/
      571   /*l	Written:	84-10-15	by Dean Elhard			*/
      572   /*l	Modified:	84-11-06	by Dean Elhard to handle line_status	*/
      573   /*							*/
      574   /********************************************************************/
      575   
      576   /* parameters */
      577   
      578   dcl infop		ptr;
      579   dcl packet		char (*) varying;
      580   dcl ec			fixed bin (35);
      581   
      582   /* based */
      583   
      584   dcl 01 comm_info		aligned like kermit_comm_info
      585 			     based (info.comm_infop);
      586   dcl 01 info		aligned like kermit_info based (infop);
      587   
      588   /* automatic */
      589   
      590   dcl selector (1:4)	fixed bin;
      591   dcl 01 modes		aligned,
      592        02 start_ch		char (1) unaligned,
      593        02 eol_ch		char (1) unaligned,
      594        02 pad_char		char (1) unaligned,
      595        02 pad_count		fixed bin (8) unaligned;
      596   
      597   selector (1) = G_start_char;
      598   selector (2) = O_eol_char;
      599   selector (3) = O_pad_char;
      600   selector (4) = O_n_pads;
      601   
      602   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
      603 			addr (modes), ec);
      604   
      605   /* add the mark and eol characters to the packet		*/
      606   
      607   packet = modes.start_ch || packet || modes.eol_ch;
      608   
      609   if modes.eol_ch ^= CR
      610     then packet = packet || CR;
      611     
      612   /* add any padding that may be required			*/
      613   
      614   packet = copy (modes.pad_char, modes.pad_count) || packet;
      615   
      616   /* set the parity on the packet				*/
      617   
      618   call set_parity (infop, packet);
      619   
      620   /* send the packet to the remote system			*/
      621   
      622   ec = error_table_$line_status_pending;
      623   
      624   do while (ec = error_table_$line_status_pending);
      625     call iox_$put_chars (comm_info.ft_iocbp, addrel (addr (packet), 1),
      626 		length (packet), ec);
      627     if ec = error_table_$line_status_pending
      628       then call process_line_status (infop);
      629   end;
      630   
      631   if ec = 0 & comm_info.debug_segp ^= null
      632     then call debug_log (infop, Transmit, (packet));
      633     
      634 end transmit_packet;
      635 
      636 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      637 
      638 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      639 
      640 
      641 receive_packet: proc (infop,		/* subsystem info pointer	*/
      642 		  packet,		/* packet received		*/
      643 		  char_count,	/* packet length		*/
      644 		  ec);		/* error code		*/
      645   
      646   /********************************************************************/
      647   /*							*/
      648   /*n	Name:	receive_packet			internal	*/
      649   /*i	Input:	info_ptr					*/
      650   /*f	Function:	reads a line of text in from the remote system,	*/
      651   /*f		and calls strip_parity to remove the parity bits	*/
      652   /*f		Then the mark and EOL characters are removed.	*/
      653   /*o	Output:	packet, char_count, error_code		*/
      654   /*							*/
      655   /*l	Written:	84-10-15	by Dean Elhard			*/
      656   /*l	Modified:	84-11-06	by Dean Elhard to handle line_status	*/
      657   /*							*/
      658   /********************************************************************/
      659   
      660   /* parameters */
      661   
      662   dcl infop		ptr;
      663   dcl packet		char (*) varying;
      664   dcl char_count		fixed bin (21);
      665   dcl ec			fixed bin (35);
      666   
      667   /* based */
      668   
      669   dcl 01 info		aligned like kermit_info based (infop);
      670   dcl input_buffer		char (comm_info.input_buffer.bufferl)
      671 			     based (comm_info.input_buffer.bufferp);
      672   dcl 01 comm_info		aligned like kermit_comm_info
      673 			     based (info.comm_infop);
      674   
      675   
      676   /* automatic */
      677   
      678   dcl buffer_len		fixed bin (21);
      679   dcl eol_index		fixed bin (21);
      680   dcl start_index		fixed bin (21);
      681   dcl input_time		fixed bin (71);
      682   dcl add_to_buffer		char (chars_read) based (buffer_offsetp);
      683   dcl buffer_offsetp	ptr;	      
      684   dcl chars_read		fixed bin (21);
      685   dcl 01 modes		aligned,
      686        02 timeout		fixed bin (8) unaligned,
      687        02 start_ch		char (1) unaligned,
      688        02 eol_char		char (1) unaligned;
      689   dcl selector (1:3)	fixed bin;
      690   
      691   selector (1) = I_timeout;
      692   selector (2) = G_start_char;
      693   selector (3) = I_eol_char;
      694   
      695   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
      696 			addr (modes), ec);
      697   
      698   /* calculate the timeout time value				*/
      699   
      700   input_time = modes.timeout * Seconds_to_microseconds;
      701   buffer_len = sys_info$max_seg_size * 4;
      702   
      703   packet = "";
      704   
      705   do while (length (packet) = 0);
      706        eol_index = 0;
      707        do while (eol_index = 0);
      708 	  eol_index = index (input_buffer, modes.eol_char);
      709 	  /* if eol is a CR, check for a NL instead.  It may be translated.   */
      710 	  if eol_index = 0 & modes.eol_char = CR
      711 	       then eol_index = index (input_buffer, NL);
      712 	  buffer_offsetp = add_char_offset_ (
      713 	       comm_info.input_buffer.bufferp, 
      714 	       comm_info.input_buffer.bufferl);
      715       
      716 		  /* read a packet from the remote system	      */
      717 	  if eol_index = 0 then      /* Wait patiently for it	      */
      718 	       call timed_io_$get_chars (comm_info.ft_iocbp, input_time,
      719 	       buffer_offsetp, buffer_len - comm_info.input_buffer.bufferl,
      720 	       chars_read, ec);
      721 	  else		         /* Don't wait around for it	      */
      722 	       call timed_io_$get_chars (comm_info.ft_iocbp, 1,
      723 	       buffer_offsetp, buffer_len - comm_info.input_buffer.bufferl,
      724 	       chars_read, ec);
      725 	  
      726 	  comm_info.input_buffer.bufferl = comm_info.input_buffer.bufferl + chars_read;
      727 	  if ec = 0 & comm_info.debug_segp ^= null
      728 	       then call debug_log (infop, Receive, (add_to_buffer));
      729       
      730 	  if ec = error_table_$timeout & eol_index ^= 0
      731 	       then ec = 0;	         /* We can ignore this	      */
      732 
      733 	  if ec = error_table_$line_status_pending
      734 	       then do;
      735 	       call process_line_status (infop);
      736 	       end;
      737 	  else if ec ^= 0 
      738 	       then return;
      739 	  /* strip the parity bits off the received packet	      */
      740 	  call strip_parity (infop, add_to_buffer);
      741 	  end;
      742        packet = substr (input_buffer, 1, eol_index - 1);
      743        input_buffer = substr (input_buffer, eol_index + 1);
      744        comm_info.input_buffer.bufferl = comm_info.input_buffer.bufferl - eol_index;
      745        
      746     /* find the start character in the received packet		*/
      747     
      748     start_index = index (packet, modes.start_ch);
      749     if start_index = 0 then packet = "";    /* Nothing there	      */
      750     else do;
      751          packet = substr (packet, start_index + 1);
      752          char_count = length(packet) + 2;
      753          start_index = index (input_buffer, modes.start_ch);
      754          if start_index > 0 then do;
      755 	    eol_index = index (substr (input_buffer, start_index),
      756 	         modes.eol_char);
      757 	  /* if eol is a CR, check for a NL instead.  It may be translated.  */
      758 	    if eol_index = 0 & modes.eol_char = CR
      759 	         then eol_index = index (substr (input_buffer, start_index),
      760 	         NL);
      761 	    if eol_index > 0
      762 	         then packet = "";   /* Discard it, check next packet   */
      763 	    end;
      764          end;
      765   end;
      766 
      767 end receive_packet;
      768 
      769 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      770 
      771 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      772 
      773 
      774 validate_checksum: proc (infop,	/* subsystem info pointer	*/
      775 		     packet,	/* packet to be validated	*/
      776 		     ec);		/* error code		*/
      777   
      778   /********************************************************************/
      779   /*							*/
      780   /*n	Name:	validate_checksum			internal	*/
      781   /*i	Input:	packet, info_ptr				*/
      782   /*f	Function:	calculates a checksum for the packet and compares	*/
      783   /*f		it with the checksum in the packet. If the	*/
      784   /*f		checksums match, the checksum is stripped from	*/
      785   /*f		the packet.				*/
      786   /*o	Output:	packet, error_code				*/
      787   /*							*/
      788   /*l	Written:	84-10-15	by Dean Elhard			*/
      789   /*							*/
      790   /********************************************************************/
      791   
      792   /* parameters */
      793   
      794   dcl infop		ptr;
      795   dcl packet		char (*) varying;
      796   dcl ec			fixed bin (35);
      797   
      798   /* automatic */
      799   
      800   dcl selector (1:1)	fixed bin;
      801   dcl ck_type		fixed bin (8) unaligned;
      802   dcl new_packet		char (Max_packet_size) varying;
      803   dcl received_checksum	char (3) varying;
      804   dcl calculated_checksum	char (3) varying;
      805   
      806   selector (1) = G_check_type;
      807   
      808   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
      809 			addr (ck_type), ec);
      810   
      811   /* make sure there are enough characters in the packet to contain	*/
      812   /* a length, sequence number, and checksum			*/
      813   
      814   if length (packet) < ck_type + 2
      815     then do;
      816       ec = kermit_et_$mangled_packet;
      817       return;
      818     end;
      819     
      820   /* extract the portion of the packet excluding the checksum	*/
      821   
      822   new_packet = substr (packet, 1, length(packet)-ck_type);
      823   
      824   /* extract the transmitted checksum				*/
      825   
      826   received_checksum = substr (packet, length(packet)+1-ck_type, ck_type);
      827   
      828   /* calculate a checksum from the packet			*/
      829   
      830   call calculate_checksum (infop, new_packet, calculated_checksum, ec);
      831   if ec ^= 0
      832     then return;
      833     
      834   /* see if the calculated checksum matches the received checksum	*/
      835   
      836   if calculated_checksum ^= received_checksum
      837     then ec = kermit_et_$crc_error;
      838     
      839   packet = new_packet;
      840   
      841 end validate_checksum;
      842 
      843 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      844 
      845 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      846 
      847 
      848 check_ctl_info: proc (infop,	/* subsystem info pointer		*/
      849 		  packet,	/* packet to check			*/
      850 		  seq_no,	/* sequence no extracted from packet	*/
      851 		  ec);	/* error code			*/
      852   
      853   /********************************************************************/
      854   /*							*/
      855   /*n	Name:	check_ctl_info			internal	*/
      856   /*i	Input:	partial_packet, info_ptr			*/
      857   /*f	Function:	decodes the length and sequence_no from the	*/
      858   /*f		partial_packet and validates that the length is	*/
      859   /*f		correct and returns the sequence number		*/
      860   /*o	Output:	encoded_data, seq_no, error_code		*/
      861   /*							*/
      862   /*l	Written:	84-10-15	by Dean Elhard			*/
      863   /*							*/
      864   /********************************************************************/
      865   
      866   /* parameters */
      867   
      868   dcl infop		ptr;
      869   dcl packet		char (*) varying;
      870   dcl seq_no		fixed bin;
      871   dcl ec			fixed bin (35);
      872   
      873   /* automatic */
      874   
      875   dcl selector (1:1)	fixed bin;
      876   dcl ck_type		fixed bin (8) unaligned;
      877   dcl len			fixed bin;
      878   dcl check		fixed bin;
      879   dcl hcheck		fixed bin (9) unsigned;
      880   dcl packet_fix		char(3);  
      881 
      882   selector (1) = G_check_type;
      883   
      884   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
      885 			addr (ck_type), ec);
      886   
      887   /* make sure the packet has enough characters to contain the length	*/
      888   /* byte and encoded sequence number				*/
      889   
      890   if length (packet) < 2
      891     then do;
      892       ec = kermit_et_$mangled_packet;
      893       return;
      894     end;
      895     
      896   /* decode the sequence number				*/
      897   
      898   seq_no = rank (substr (packet, 2, 1)) - Char_encoding_offset;
      899   
      900   /* check that the length byte matches the actual packet length	*/
      901   
      902   len = rank (substr (packet, 1, 1)) - Char_encoding_offset;
      903   if len = 0
      904        then do;		         /* extended packet header	      */
      905        check = rank (substr (packet, 1, 1)) + rank (substr (packet, 2, 1))
      906 	   + rank (substr (packet, 3, 1)) + rank (substr (packet, 4, 1))
      907 	   + rank (substr (packet, 5, 1));
      908        hcheck = mod(check + (mod (check, 256) / 64), 64);
      909        if hcheck ^= rank (substr (packet, 6, 1)) - Char_encoding_offset
      910 	  then do;
      911 	  ec = kermit_et_$mangled_packet;
      912 	  return;
      913 	  end;
      914        len = (rank (substr (packet, 4, 1)) - Char_encoding_offset) * 95
      915 	  + rank (substr (packet, 5, 1)) - Char_encoding_offset;
      916        if len ^= length (packet) + ck_type - 6
      917 	  then ec = kermit_et_$length_mismatch;
      918        packet_fix = packet;
      919        packet = substr (packet_fix, 3, 1) || substr (packet, 7);
      920        end;
      921   else do;
      922        if len ^= length (packet) + ck_type - 1
      923 	  then ec = kermit_et_$length_mismatch;
      924        packet = substr (packet, 3);
      925        end;
      926   
      927   
      928 end check_ctl_info;
      929     
      930 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      931 
      932 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      933 
      934 
      935 decode_data: proc (infop,	/* subsystem info pointer		*/
      936 	         bufp,	/* decoded text buffer pointer	*/
      937 	         bufl,	/* decoded text buffer length		*/
      938 	         type,	/* packet type			*/
      939 	         packet,	/* packet to be decoded		*/
      940 	         rcvd,	/* received character count		*/
      941 	         crnl_sw,	/* spanned CR/NL pair switch		*/
      942 	         ec);	/* error code			*/
      943   
      944   /********************************************************************/
      945   /*							*/
      946   /*n	Name:	decode_data			internal	*/
      947   /*i	Input:	encoded_data, info_ptr			*/
      948   /*f	Function:	removes the prefix encoding characters and	*/
      949   /*f		returns the decoded text.			*/
      950   /*o	Output:	data					*/
      951   /*							*/
      952   /*l	Written:	84-10-15	by Dean Elhard			*/
      953   /*							*/
      954   /********************************************************************/
      955   
      956   /* parameters */
      957   
      958   dcl infop		ptr;
      959   dcl bufp		ptr;
      960   dcl bufl		fixed bin (21);
      961   dcl type		char (1);
      962   dcl packet		char (*) varying;
      963   dcl rcvd		fixed bin (21);
      964   dcl crnl_sw		bit (1);
      965   dcl ec			fixed bin (35);
      966   
      967   /* based */
      968   
      969   dcl buf			char (bufl) based (bufp);
      970   
      971   /* automatic */
      972   
      973   dcl pkt_len		fixed bin;
      974   dcl pkt_chr		fixed bin;
      975   dcl 01 capabilities	aligned,
      976        02 eight_bit		bit (1) unaligned,
      977        02 repeat		bit (1) unaligned,
      978        02 mbz		bit (34) unaligned;
      979   dcl t_selector (1:3)	fixed bin;
      980   dcl p_selector (1:2)	fixed bin;
      981   dcl 01 modes		aligned,
      982        02 quote		char (1) unaligned,
      983        02 eight_bit		char (1) unaligned,
      984        02 repeat		char (1) unaligned;
      985   dcl 01 perm_modes		aligned,
      986        02 line_byte_size	fixed bin (8) unaligned,
      987        02 file_type		char (1) unaligned;
      988   dcl sequence		char (Max_repeat_encoding) varying;
      989   dcl seql		fixed bin;
      990   
      991   rcvd = 0;
      992   pkt_len = length (packet);
      993   pkt_chr = 1;
      994   /* make sure we have something to decode			*/
      995   
      996   if pkt_len = 0
      997     then do;
      998       ec = kermit_et_$mangled_packet;
      999       return;
     1000     end;
     1001     
     1002   /* extract the type from the packet				*/
     1003   
     1004   type = substr (packet, 1, 1);
     1005   pkt_chr = 2;
     1006   
     1007   /* Do not decode send_init, server_init and ack packets.            */
     1008   /* Decode receive_init packet only.                                 */
     1009   
     1010   if type = Send_init_packet_type |
     1011 /*     type = Receive_init_packet_type | * for compatibility with phx: */
     1012      type = Server_init_packet_type |
     1013      type = Ack_packet_type
     1014     then do;
     1015       rcvd = pkt_len - 1;
     1016       substr (buf, 1, rcvd) = substr (packet, 2);
     1017       return;
     1018     end;
     1019     
     1020   t_selector (1) = I_quote_char;
     1021   t_selector (2) = G_eight_bit_char;
     1022   t_selector (3) = G_repeat_char;
     1023   
     1024   call kermit_mode_mgr_$retrieve (infop, Temporary, t_selector,
     1025 			addr (modes), ec);
     1026   
     1027   p_selector (1) = Line_byte_size;
     1028   p_selector (2) = File_type;
     1029   
     1030   call kermit_mode_mgr_$retrieve (infop, Permanent, p_selector,
     1031 			addr (perm_modes), ec);
     1032   
     1033   string (capabilities) = ""b;
     1034   
     1035   /* calculate the capabilities from the prefix chars and file type	*/
     1036   
     1037   if modes.eight_bit ^= No_eight_bit_encoding &
     1038      perm_modes.line_byte_size ^= Eight_bit_byte_size
     1039     then capabilities.eight_bit = true;
     1040   if modes.repeat ^= No_repeat_encoding
     1041     then capabilities.repeat = true;
     1042     
     1043   do while (pkt_chr <= pkt_len);
     1044     call decode_char (infop, packet, pkt_chr, pkt_len, sequence, modes.quote,
     1045          			modes.eight_bit, modes.repeat,
     1046          			string (capabilities), ec);
     1047     if ec ^= 0
     1048       then return;
     1049       
     1050     /* handle special decoding of CR/NL to nl and detection of	*/
     1051     /* CR/NL sequences spanning multiple packets			*/
     1052     
     1053     if sequence = NL & perm_modes.file_type = Ascii_file_type
     1054       then if rcvd = 0
     1055         then crnl_sw = true;
     1056         else if substr (buf, rcvd, 1) = CR
     1057 	then rcvd = rcvd - 1;
     1058     
     1059     /* append the decoded sequence to the buffer			*/
     1060     
     1061     seql = length (sequence);
     1062     substr (buf, rcvd+1, seql) = sequence;
     1063     rcvd = rcvd + seql;
     1064   end;
     1065   
     1066 end decode_data;
     1067 
     1068 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1069 
     1070 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1071 
     1072 
     1073 encode_char: proc (infop,		/* subsystem info pointer	*/
     1074 	         datap,		/* ptr to data to encode	*/
     1075 	         datal,		/* length of data to encode	*/
     1076 	         sequence,		/* resulting output sequence	*/
     1077 	         char_count,	/* number of chars encoded	*/
     1078 	         quote_ch,		/* control quote char	*/
     1079 	         eight_bit_ch,	/* 8-bit prefix char	*/
     1080 	         repeat_ch,		/* repeat prefix char	*/
     1081 	         capability_str);	/* capability flags		*/
     1082   
     1083   /********************************************************************/
     1084   /*							*/
     1085   /*n	Name:	encode_char			internal	*/
     1086   /*i	Input:	info_ptr, data, quote_char, 8bit_char,		*/
     1087   /*i		repeat_char				*/
     1088   /*f	Function:	encodes the first character(s) in the data passed	*/
     1089   /*f		returning the encoded sequence and the number of	*/
     1090   /*f		characters encoded.				*/
     1091   /*o	Output:	encoded_sequence, char_count			*/
     1092   /*							*/
     1093   /*l	Written:	84-10-15	by Dean Elhard			*/
     1094   /*l	Modified:	84-11-15	by Dean Elhard for correct encoding of	*/
     1095   /*l			8-bit characters over 8-bit lines	*/
     1096   /*l	Modified:	85-03-26	by M. Mallmes for correct encoding of	*/
     1097   /*l			8-bit characters over 8-bit lines	*/
     1098   /*l			when optimized.			*/
     1099   /*							*/
     1100   /********************************************************************/
     1101   
     1102   /* parameters */
     1103   
     1104   dcl infop		ptr;
     1105   dcl datap		ptr;
     1106   dcl datal		fixed bin (21);
     1107   dcl sequence		char (*) varying;
     1108   dcl char_count		fixed bin;
     1109   dcl quote_ch		char (1);
     1110   dcl eight_bit_ch		char (1);
     1111   dcl repeat_ch		char (1);
     1112   dcl capability_str	bit (38) aligned;
     1113   
     1114 /*  constants  */
     1115 
     1116   dcl Bit_8_mask		bit (9) aligned static options (constant) init ("200"b3);
     1117   dcl Clear_bit_8		bit (9) aligned static options (constant) init ("577"b3);
     1118   dcl Clear_bit_9		bit (9) aligned static options (constant) init ("377"b3);
     1119 
     1120   /* based */
     1121   
     1122   dcl data		char (datal) based (datap);
     1123   dcl 01 capabilities	aligned based (addr (capability_str)),
     1124        02 eight_bit		bit (1) unaligned,
     1125        02 repeat		bit (1) unaligned,
     1126        02 binary		bit (1) unaligned,
     1127        02 raw		bit (1) unaligned,
     1128        02 mbz		bit (32) unaligned;
     1129   dcl char_to_code            char (1) aligned;
     1130 			
     1131   /* automatic */
     1132   
     1133   dcl bit_8_value		bit (9) aligned;
     1134   
     1135   /* don't bother if there is no data */
     1136   
     1137   if datal = 0
     1138     then return;
     1139     
     1140   char_to_code =  substr (data, 1, 1);
     1141   
     1142   /* clear the ninth bit if set */
     1143   
     1144   unspec (char_to_code) = (unspec (char_to_code) & Clear_bit_9);
     1145   
     1146   /* get the mask for the 8th bit  */
     1147 
     1148   bit_8_value = (unspec (char_to_code) & Bit_8_mask);
     1149 
     1150   /*  clear the 8th bit  */
     1151 
     1152   unspec (char_to_code) = (unspec (char_to_code) & Clear_bit_8);
     1153 
     1154   /* clear the eighth bit flag if we cannot send the eighth bit */
     1155   
     1156   if ^capabilities.raw & ^capabilities.eight_bit
     1157     then bit_8_value = "0"b;
     1158       
     1159   if capabilities.eight_bit & (bit_8_value ^= "0"b)
     1160     then sequence = eight_bit_ch;
     1161     else sequence = "";
     1162   
     1163   /* see if we are encoding one of our prefix characters */
     1164   
     1165   if char_to_code = quote_ch |
     1166      (char_to_code = eight_bit_ch & capabilities.eight_bit) |
     1167      (char_to_code = repeat_ch & capabilities.repeat)
     1168     then do;
     1169       if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
     1170       sequence = sequence || quote_ch || char_to_code;
     1171     end;
     1172     
     1173   /* see if we are encoding an newline character */
     1174   
     1175   else if rank (char_to_code) = NL_fixed & (bit_8_value = "0"b) &
     1176 	^capabilities.binary
     1177     then sequence = quote_ch || "M" || quote_ch || "J";
     1178     
     1179   /* see if we are encoding a normal control character */
     1180   
     1181   else if rank (char_to_code) <= Ascii_ctl_limit
     1182     then do;
     1183       if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
     1184       sequence = sequence || quote_ch || ctl_encode  (rank (char_to_code));
     1185     end;
     1186     
     1187   /* see if we are encoding a normal printing character */
     1188   
     1189   else if  rank (char_to_code) <= Ascii_printable_limit
     1190     then do;
     1191       if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
     1192       sequence = sequence || char_to_code;
     1193     end;
     1194     
     1195   /* see if we are encoding a pad character (177 octal) */
     1196   
     1197   else if  rank (char_to_code) = Ascii_pad_char
     1198     then do;
     1199       if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
     1200       sequence = sequence || quote_ch || ctl_encode (rank (char_to_code));
     1201     end;
     1202     else sequence = sequence || char_to_code;
     1203   
     1204   char_count = verify (data, substr (data, 1, 1)) - 1;
     1205   if char_count < 0
     1206     then char_count = datal;
     1207     
     1208   /* don't try to repeat encode newlines due to special NL encoding */
     1209   
     1210   if rank (char_to_code) = NL_fixed & (bit_8_value = "0"b) & ^capabilities.binary
     1211     then char_count = 1;
     1212     
     1213   /* limit encoding count to max representable repeat value */
     1214   
     1215   else if char_count > Max_repeat_encoding
     1216     then char_count = Max_repeat_encoding;
     1217     
     1218   /* don't encode if there are not enough chars to make it worthwhile */
     1219   
     1220   if char_count > Min_repeat_encoding & capabilities.repeat
     1221     then sequence = repeat_ch ||
     1222 		byte (char_count + Char_encoding_offset) || sequence;
     1223     else char_count = 1;
     1224     
     1225 end encode_char;
     1226 
     1227 
     1228 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1229 
     1230 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1231 
     1232 
     1233 set_parity: proc (infop,	/* subsystem info pointer		*/
     1234 	        packet);	/* packet to set parity on		*/
     1235   
     1236   /********************************************************************/
     1237   /*							*/
     1238   /*n	Name:	set_parity			internal	*/
     1239   /*i	Input:	complete_packet, info_ptr			*/
     1240   /*f	Function:	if mark or space parity is in effect, set the	*/
     1241   /*f		eighth bit of each character in the packet	*/
     1242   /*f		appropriately				*/
     1243   /*o	Output:	complete_packet				*/
     1244   /*							*/
     1245   /*l	Written:	84-10-15	by Dean Elhard			*/
     1246   /*							*/
     1247   /********************************************************************/
     1248   
     1249   /* parameters */
     1250   
     1251   dcl infop		ptr;
     1252   dcl packet		char (*) varying;
     1253   
     1254   /* automatic */
     1255   
     1256   dcl ec			fixed bin (35);
     1257   dcl mask		bit (Max_packet_size * 9) varying;
     1258   dcl parity		char (1) unal;
     1259   dcl selector (1:1)	fixed bin init (G_parity);
     1260   dcl workspace		bit (Max_packet_size * 9) varying;
     1261   dcl 01 wksp_overlay	based (addr (workspace)),
     1262        02 len		fixed bin (24),
     1263        02 chars		char (Max_packet_size);
     1264   
     1265   /* get the prevailing parity				*/
     1266   
     1267   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
     1268 			addr (parity), ec);
     1269   
     1270   /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
     1271   
     1272   if rank (parity) = rank (Mark_parity) | rank (parity) = rank (Space_parity)
     1273     then do;
     1274       wksp_overlay.chars = packet;
     1275       wksp_overlay.len = 9 * length (packet);
     1276       mask = copy ("200"b3, length (packet));
     1277   
     1278   /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
     1279   
     1280       if rank (parity) = rank (Mark_parity)
     1281         then workspace = workspace | mask;
     1282         else workspace = workspace & ^mask;
     1283       packet = substr (wksp_overlay.chars, 1, length (packet));
     1284     end;
     1285     
     1286 end set_parity;
     1287 
     1288 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1289 
     1290 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1291 
     1292 
     1293 strip_parity: proc (infop,	/* subsystem info pointer		*/
     1294 	          packet);	/* packet to strip parity from	*/
     1295   
     1296   /********************************************************************/
     1297   /*							*/
     1298   /*n	Name:	strip_parity			internal	*/
     1299   /*i	Input:	complete_packet, info_ptr			*/
     1300   /*f	Function:	zeroes the parity bits on an incoming packet	*/
     1301   /*o	Output:	complete_packet				*/
     1302   /*							*/
     1303   /*l	Written:	84-10-15	by Dean Elhard			*/
     1304   /*							*/
     1305   /********************************************************************/
     1306   
     1307   /* parameters */
     1308   
     1309   dcl infop		ptr;
     1310   dcl packet		char (*);
     1311   
     1312   /* automatic */
     1313   
     1314   dcl selector (1:1)	fixed bin init (G_parity);
     1315   dcl parity		char (1) unal;
     1316   dcl workspace		bit (length (packet) * 9) based (addr (packet));
     1317   dcl ec			fixed bin (35);
     1318   
     1319   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
     1320 			addr (parity), ec);
     1321   
     1322   /* for anything except "No Parity", strip the parity bit */
     1323   
     1324   /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
     1325   
     1326   if rank (parity) ^= rank (No_parity)
     1327     then workspace = bool(workspace, copy("600"b3, length(packet)), "0010"b);
     1328     else workspace = bool(workspace, copy("400"b3, length(packet)), "0010"b);
     1329   
     1330 end strip_parity;
     1331 
     1332 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1333 
     1334 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1335 
     1336 
     1337 decode_char: proc (infop,		/* subsystem info pointer	*/
     1338 	         packet,		/* packet to decode from	*/
     1339 	         pkt_chr,		/* offset in packet		*/
     1340 	         pkt_len,		/* packet length		*/
     1341 	         sequence,		/* decoded character sequence	*/
     1342 	         quote_ch,		/* control quote character	*/
     1343 	         eight_bit_ch,	/* 8 bit prefix character	*/
     1344 	         repeat_ch,		/* repeat prefix character	*/
     1345 	         capability_str,	/* decode capability string	*/
     1346 	         ec);		/* error code		*/
     1347   
     1348   /********************************************************************/
     1349   /*							*/
     1350   /*n	Name:	decode_char			internal	*/
     1351   /*i	Input:	info_ptr, packet, quote_char, 8bit_char,	*/
     1352   /*i		repeat_char, capabilities			*/
     1353   /*f	Function:	decodes the first sequence in the packet based	*/
     1354   /*f		on the current capabilities and prefix chars	*/
     1355   /*f		and returns the resulting sequence.  The encoded	*/
     1356   /*f		sequence is stripped from the start of the packet	*/
     1357   /*o	Output:	decoded_sequence, packet, error_code		*/
     1358   /*							*/
     1359   /*l	Written:	84-10-23	by Dean Elhard			*/
     1360   /*l	Modified:	84-10-28	by Dean Elhard to fix decoding of	*/
     1361   /*l			prefix characters			*/
     1362   /*l	Modified:	84-11-15	by Dean Elhard for correct decoding of	*/
     1363   /*l			8-bit characters over 8-bit lines	*/
     1364   /*							*/
     1365   /********************************************************************/
     1366   
     1367   /* parameters */
     1368   
     1369   dcl infop		ptr;
     1370   dcl packet		char (*) varying;
     1371   dcl (pkt_chr, pkt_len)	fixed bin;
     1372   dcl sequence		char (*) varying;
     1373   dcl quote_ch		char (1);
     1374   dcl eight_bit_ch		char (1);
     1375   dcl repeat_ch		char (1);
     1376   dcl capability_str	bit (36) aligned;
     1377   dcl ec			fixed bin (35);
     1378   
     1379   /* based */
     1380   
     1381   dcl 01 capabilities	aligned based (addr (capability_str)),
     1382        02 eight_bit		bit (1) unaligned,
     1383        02 repeat		bit (1) unaligned,
     1384        02 mbz		bit (34) unaligned;
     1385   dcl 01 char_overlay	unaligned based (addr (decoded_char)),
     1386        02 bit_9		bit (1) unaligned,
     1387        02 bit_8		bit (1) unaligned,
     1388        02 ascii_bits	bit (7) unaligned;
     1389   dcl 01 seven_bit_overlay	unaligned based (addr (seven_bit_char)),
     1390        02 bit_9		bit (1) unaligned,
     1391        02 bit_8		bit (1) unaligned,
     1392        02 ascii_bits	bit (7) unaligned;
     1393   
     1394   /* automatic */
     1395   
     1396   dcl repeat_count		fixed bin;
     1397   dcl set_eighth_bit	bit (1);
     1398   dcl seven_bit_char	char (1);
     1399   dcl control_decode	bit (1);
     1400   dcl decoded_char		char (1);
     1401   
     1402   /* check if there is a repeat prefix on the sequence		*/
     1403   
     1404   if capabilities.repeat & substr (packet, pkt_chr, 1) = repeat_ch
     1405     then do;
     1406       
     1407       /* if there are not enough chars in the packet for a repeat	*/
     1408       /* sequence, abort the packet decodeing			*/
     1409       
     1410       if pkt_len - pkt_chr < 2
     1411         then do;
     1412 	ec = kermit_et_$cannot_decode;
     1413 	return;
     1414         end;
     1415         
     1416       /* decode the repeat count and strip the prefix and count	*/
     1417       
     1418       repeat_count = rank (substr (packet, pkt_chr + 1, 1)) - Char_encoding_offset;
     1419       pkt_chr = pkt_chr + 2;
     1420     end;
     1421     else repeat_count = 1;
     1422   
     1423   /* see if there is an eight-bit prefix on the sequence		*/
     1424   
     1425   if capabilities.eight_bit & substr (packet, pkt_chr, 1) = eight_bit_ch
     1426     then do;
     1427       
     1428       /* if there are not enought characters in the packet for a	*/
     1429       /* eight-bit prefixed sequence, then yell			*/
     1430       
     1431       if pkt_len - pkt_chr < 1
     1432         then do;
     1433 	ec = kermit_et_$cannot_decode;
     1434 	return;
     1435         end;
     1436         
     1437       /* set the eight-bit flag and strip the prefix		*/
     1438       
     1439       set_eighth_bit = true;
     1440       pkt_chr = pkt_chr + 1;
     1441     end;
     1442     else set_eighth_bit = false;
     1443   
     1444   /* see if there is a control prefix on the sequence		*/
     1445   
     1446   if substr (packet, pkt_chr, 1) = quote_ch
     1447     then do;
     1448       
     1449       /* if there are not enough characters in the packet to contain	*/
     1450       /* a valid control-prefixed sequence, then yell		*/
     1451       
     1452       if pkt_len - pkt_chr < 1
     1453         then do;
     1454 	ec = kermit_et_$cannot_decode;
     1455 	return;
     1456         end;
     1457         
     1458       /* set the flag indicating that control decoding is required	*/
     1459       /* and strip the control prefix from the packet		*/
     1460       
     1461       control_decode = true;
     1462       pkt_chr = pkt_chr + 1;
     1463     end;
     1464     else control_decode = false;
     1465   
     1466   /* extract the target character of the sequence from the packet	*/
     1467   
     1468   decoded_char = substr (packet, pkt_chr, 1);
     1469   pkt_chr = pkt_chr + 1;
     1470   
     1471   seven_bit_char = decoded_char;
     1472   seven_bit_overlay.bit_8 = false;
     1473   
     1474   /* perform control decoding if required special casing control	*/
     1475   /* encoded prefix characters				*/
     1476   
     1477   if control_decode
     1478     then if (seven_bit_char ^= quote_ch) &
     1479 	  ((seven_bit_char ^= eight_bit_ch) | ^capabilities.eight_bit) &
     1480 	  ((seven_bit_char ^= repeat_ch) | ^capabilities.repeat)
     1481       then decoded_char = ctl_encode (rank (decoded_char));
     1482     
     1483   /* perform eight-bit decoding if required			*/
     1484   
     1485   if set_eighth_bit
     1486     then char_overlay.bit_8 = true;
     1487     
     1488   /* copy the character as required by repeat prefixing		*/
     1489   
     1490   sequence = copy (decoded_char, repeat_count);
     1491   
     1492 end decode_char;
     1493 
     1494 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1495 
     1496 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1497 
     1498 
     1499 calculate_checksum: proc (infop,	/* subsystem info pointer	*/
     1500 		      packet,	/* packet do calc cksum for	*/
     1501 		      checksum,	/* calculated checksum	*/
     1502 		      ec);	/* error code		*/
     1503   
     1504   /********************************************************************/
     1505   /*							*/
     1506   /*n	Name:	calculate_checksum			internal	*/
     1507   /*i	Input:	packet, info_ptr				*/
     1508   /*f	Function:	calculates the checksum based on the prevailing	*/
     1509   /*f		checksum type and returns the character sequence	*/
     1510   /*f		representing the checksum			*/
     1511   /*o	Output:	checksum, error_code			*/
     1512   /*							*/
     1513   /*l	Written:	84-10-15	by Dean Elhard			*/
     1514   /*							*/
     1515   /********************************************************************/
     1516   
     1517   /* parameters */
     1518   
     1519   dcl infop		ptr;
     1520   dcl packet		char (*) varying;
     1521   dcl checksum		char (*) varying;
     1522   dcl ec			fixed bin (35);
     1523   
     1524   /* automatic */
     1525   
     1526   dcl check_type		fixed bin (8) unal;
     1527   dcl i			fixed bin;
     1528   dcl selector (1:1)	fixed bin init (G_check_type);
     1529   dcl six_seven_mask	bit (36) aligned static options (constant)
     1530 			     init ("000000000300"b3);
     1531   dcl sum			fixed bin (35) aligned;
     1532   dcl sum_bits		bit (36) aligned based (addr (sum));
     1533   dcl zero_five_mask	bit (36) aligned static options (constant)
     1534 			     init ("000000000077"b3);
     1535   
     1536   /* get the current checksum type				*/
     1537   
     1538   call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
     1539 			addr (check_type), 0);
     1540   
     1541   ec = 0;
     1542   
     1543   /* check type 1  -  single character encoded checksum		*/
     1544   
     1545   if check_type = 1
     1546     then do;
     1547       sum = 0;
     1548       
     1549       /* sum the ascii values of the packet			*/
     1550       
     1551       do i = 1 to length (packet);
     1552         sum = sum + rank (substr (packet, i, 1));
     1553       end;
     1554       
     1555       /* adjust the checksum into a 6 bit value			*/
     1556       
     1557       sum = sum + (bin (sum_bits & six_seven_mask) / 64);
     1558       sum_bits = sum_bits & zero_five_mask;
     1559       
     1560       /* encode the checksum into a printable ascii character	*/
     1561       
     1562       checksum = byte (sum + Char_encoding_offset);
     1563     end;
     1564     
     1565   /* no other checksum types are currently supported		*/
     1566   
     1567     else ec = kermit_et_$unimplemented_check_type;
     1568   
     1569 end calculate_checksum;
     1570 
     1571 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1572 
     1573 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1574 
     1575 
     1576 ctl_encode: proc (value_to_encode) returns (char (1)) reducible;
     1577   
     1578   /********************************************************************/
     1579   /*							*/
     1580   /*n	Name:	ctl_encode			internal	*/
     1581   /*i	Input:	ascii_value				*/
     1582   /*f	Function:	performs the kermit ctl() encoding function which	*/
     1583   /*f		toggles bit 7 in the specified value.		*/
     1584   /*o	Output:	encoded_char				*/
     1585   /*							*/
     1586   /*l	Written:	84-10-18	by Dean Elhard			*/
     1587   /*							*/
     1588   /********************************************************************/
     1589   
     1590   /* parameters */
     1591   
     1592   dcl value_to_encode	fixed bin (35) aligned;
     1593   
     1594   /* based */
     1595   
     1596   dcl bit_overlay		bit (36) aligned based (addr (value_to_encode));
     1597   dcl 01 char_overlay	aligned based (addr (encoded_value)),
     1598        02 pad		char (3) unaligned,
     1599        02 encoded_char	char (1) unaligned;
     1600   
     1601   /* automatic */
     1602   
     1603   dcl encoded_value		bit (36) aligned;
     1604   
     1605   /* control encode by XORing the ascii value with 64		*/
     1606   
     1607   encoded_value = bool (bit_overlay, "000000000100"b3, "0110"b);
     1608   
     1609   return (char_overlay.encoded_char);
     1610   
     1611 end ctl_encode;
     1612 
     1613 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1614 
     1615 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1616 
     1617 
     1618 process_line_status: proc (infop);
     1619   
     1620   /********************************************************************/
     1621   /*							*/
     1622   /*n	Name:	process_line_status			internal	*/
     1623   /*i	Input:	info_ptr					*/
     1624   /*f	Function:	clears the line status on the file transfer	*/
     1625   /*f		switch.					*/
     1626   /*o	Output:	none					*/
     1627   /*							*/
     1628   /*l	Written:	84-11-05	by Dean Elhard			*/
     1629   /*							*/
     1630   /********************************************************************/
     1631   
     1632   /* parameters */
     1633   
     1634   dcl infop		ptr;
     1635   
     1636   /* based */
     1637   
     1638   dcl 01 info		aligned like kermit_info based (infop);
     1639   dcl 01 comm_info		aligned like kermit_comm_info
     1640 			     based (info.comm_infop);
     1641   
     1642   /* automatic */
     1643   
     1644   dcl ls_data		bit (72) aligned;
     1645   dcl ec			fixed bin (35);
     1646   
     1647   call iox_$control (comm_info.ft_iocbp, "line_status", addr (ls_data), ec);
     1648   
     1649 end process_line_status;
     1650 
     1651 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1652 
     1653 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
     1654 
     1655 
     1656 debug_log: proc (infop, direction, data);
     1657   
     1658   /********************************************************************/
     1659   /*  							*/
     1660   /*n	Name:	debug_log				internal	*/
     1661   /*i	Input:	info_ptr, direction, packet_data		*/
     1662   /*f	Function:	logs the packet traffic in a segment to aid in	*/
     1663   /*f		debugging.				*/
     1664   /*o	Output:	none					*/
     1665   /*							*/
     1666   /*l	Written:	84-11-15	by Dean Elhard			*/
     1667   /*							*/
     1668   /********************************************************************/
     1669   
     1670   /* parameters */
     1671   
     1672   dcl infop		ptr;
     1673   dcl direction		char (1);
     1674   dcl data		char (*);
     1675   
     1676   /* based */
     1677   
     1678   dcl 01 info		aligned like kermit_info based (infop);
     1679   dcl 01 comm_info		aligned like kermit_comm_info
     1680 			     based (info.comm_infop);
     1681   
     1682   /* automatic */
     1683   
     1684   dcl str			char (4000);
     1685   
     1686   /* insert direction marker					*/
     1687   str = direction || data || NL;
     1688   call iox_$put_chars (comm_info.debug_segp, addr (str), length (rtrim (str)), ec);
     1689 
     1690 end debug_log;
     1691 
     1692 end kermit_pad_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1937.6  kermit_pad_.pl1                   >udd>sm>ds>w>ml>kermit_pad_.pl1
154          1    11/20/84  1451.4  kermit_dcls.incl.pl1              >ldd>incl>kermit_dcls.incl.pl1
156          2    07/07/88  2141.4  kermit_info.incl.pl1              >ldd>incl>kermit_info.incl.pl1
158          3    07/07/88  2141.4  kermit_mode_info.incl.pl1         >ldd>incl>kermit_mode_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_bufl                                 parameter       fixed bin(21,0)          dcl 93 set ref 212 256*
A_bufp                                 parameter       pointer                  dcl 94 set ref 212 256*
A_code                                 parameter       fixed bin(35,0)          dcl 92 set ref 165 195* 196 201* 202 202* 212 244*
                                                                                  245 248* 249 252* 253 256*
A_crnl                                 parameter       bit(1)                   packed unaligned dcl 86 set ref 212 256*
A_datal                                parameter       fixed bin(21,0)          dcl 90 set ref 165 190*
A_datap                                parameter       pointer                  dcl 91 set ref 165 190*
A_infop                                parameter       pointer                  dcl 85 set ref 165 190* 193* 195* 201* 212 244* 248*
                                                                                  252* 256*
A_rcvd                                 parameter       fixed bin(21,0)          dcl 87 set ref 212 240* 256*
A_sent                                 parameter       fixed bin(21,0)          dcl 88 set ref 165 190*
A_seq_no                               parameter       fixed bin(17,0)          dcl 95 set ref 165 193* 212 242* 252*
A_size                                 parameter       fixed bin(21,0)          dcl 89 set ref 165 199* 212 241* 244*
A_type                                 parameter       char(1)                  packed unaligned dcl 96 set ref 165 190* 212 256*
Ack_packet_type                        constant        char(1)                  initial packed unaligned dcl 69 ref 409 1010
Ascii_ctl_limit                        constant        fixed bin(17,0)          initial dcl 72 ref 1181
Ascii_file_type                        constant        char(1)                  initial packed unaligned dcl 63 ref 1053
Ascii_pad_char                         constant        fixed bin(17,0)          initial dcl 74 ref 1197
Ascii_printable_limit                  constant        fixed bin(17,0)          initial dcl 73 ref 1189
Binary_file_type                       constant        char(1)                  initial packed unaligned dcl 62 ref 387
Bit_8_mask                             constant        bit(9)                   initial dcl 1116 ref 1148
CR                                     based           char(1)                  level 2 packed packed unaligned dcl 2-31 ref 609 609
                                                                                  710 758 1056
Char_encoding_offset                   constant        fixed bin(17,0)          initial dcl 58 ref 493 494 495 498 500 500 506 506
                                                                                  898 902 909 914 914 1220 1418 1562
Clear_bit_8                            constant        bit(9)                   initial dcl 1117 ref 1152
Clear_bit_9                            constant        bit(9)                   initial dcl 1118 ref 1144
Eight_bit_byte_size                    constant        fixed bin(8,0)           initial dcl 65 ref 381 1037
Ext_Headers                            constant        bit(9)                   initial packed unaligned dcl 3-120 ref 369
File_type                              constant        fixed bin(17,0)          initial dcl 3-40 ref 361 1028
G_capabilities                         constant        fixed bin(17,0)          initial dcl 3-93 ref 351
G_check_type                           constant        fixed bin(17,0)          initial dcl 3-86 ref 350 472 806 882 1528
G_eight_bit_char                       constant        fixed bin(17,0)          initial dcl 3-83 ref 348 1021
G_parity                               internal static fixed bin(17,0)          initial dcl 3-87 ref 1259 1314
G_repeat_char                          constant        fixed bin(17,0)          initial dcl 3-84 ref 349 1022
G_start_char                           constant        fixed bin(17,0)          initial dcl 3-85 ref 597 692
I_eol_char                             constant        fixed bin(17,0)          initial dcl 3-75 ref 693
I_quote_char                           constant        fixed bin(17,0)          initial dcl 3-76 ref 1020
I_timeout                              constant        fixed bin(17,0)          initial dcl 3-72 ref 691
Line_byte_size                         constant        fixed bin(17,0)          initial dcl 3-42 ref 360 1027
Mark_parity                            constant        char(1)                  initial packed unaligned dcl 79 ref 1272 1280
Max_packet_size                        internal static fixed bin(17,0)          initial dcl 59 ref 129 802 1257 1260 1261
Max_repeat_encoding                    constant        fixed bin(17,0)          initial dcl 76 ref 988 1215 1215
Min_repeat_encoding                    constant        fixed bin(17,0)          initial dcl 77 ref 1220
NL                        0(09)        based           char(1)                  level 2 packed packed unaligned dcl 2-31 ref 710 758
                                                                                  1053 1687
NL_fixed                  0(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 2-35
                                                                                  ref 1175 1210
No_eight_bit_encoding                  constant        char(1)                  initial packed unaligned dcl 60 ref 376 1037
No_parity                              constant        char(1)                  initial packed unaligned dcl 81 ref 1326
No_repeat_encoding                     constant        char(1)                  initial packed unaligned dcl 61 ref 378 1040
O_eol_char                             constant        fixed bin(17,0)          initial dcl 3-81 ref 598
O_max_lenx1                            constant        fixed bin(17,0)          initial dcl 3-91 ref 352
O_max_lenx2                            constant        fixed bin(17,0)          initial dcl 3-92 ref 353
O_maxl                                 constant        fixed bin(17,0)          initial dcl 3-77 ref 346
O_n_pads                               constant        fixed bin(17,0)          initial dcl 3-79 ref 600
O_pad_char                             constant        fixed bin(17,0)          initial dcl 3-80 ref 599
O_quote_char                           constant        fixed bin(17,0)          initial dcl 3-82 ref 347
Permanent                       000027 constant        fixed bin(17,0)          initial dcl 3-21 set ref 363* 1030*
Receive                         000001 constant        char(1)                  initial packed unaligned dcl 56 set ref 727*
Receive_init_packet_type               constant        char(1)                  initial packed unaligned dcl 67 ref 409
Seconds_to_microseconds         000004 constant        fixed bin(71,0)          initial dcl 52 ref 700
Send_init_packet_type                  constant        char(1)                  initial packed unaligned dcl 68 ref 409 1010
Server_init_packet_type                constant        char(1)                  initial packed unaligned dcl 70 ref 409 1010
Space_parity                           constant        char(1)                  initial packed unaligned dcl 80 ref 1272
Temporary                       000021 constant        fixed bin(17,0)          initial dcl 3-22 set ref 355* 479* 602* 695* 808*
                                                                                  884* 1024* 1267* 1319* 1538*
Transmit                        000002 constant        char(1)                  initial packed unaligned dcl 55 set ref 631*
add_char_offset_                000010 constant        entry                    external dcl 100 ref 418 712
add_to_buffer                          based           char                     packed unaligned dcl 682 set ref 727 740*
addr                                                   builtin function         dcl 133 ref 355 355 363 363 479 479 602 602 609 609
                                                                                  625 625 695 695 710 710 758 758 808 808 884 884
                                                                                  1024 1024 1030 1030 1053 1056 1156 1156 1159 1165
                                                                                  1165 1169 1175 1175 1183 1191 1199 1210 1210 1220
                                                                                  1267 1267 1274 1275 1283 1319 1319 1326 1326 1328
                                                                                  1328 1404 1425 1472 1477 1477 1485 1538 1538 1557
                                                                                  1558 1558 1607 1609 1647 1647 1687 1688 1688
addrel                                                 builtin function         dcl 134 ref 625 625
bin                                                    builtin function         dcl 135 ref 1557
binary                    0(02) 000715 automatic       bit(1)                   level 3 in structure "capabilities" packed packed
                                                                                  unaligned dcl 313 in procedure "encode_data" set
                                                                                  ref 387*
binary                    0(02)        based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1123 in procedure "encode_char" ref
                                                                                  1175 1210
bit_8                     0(01)        based           bit(1)                   level 2 in structure "char_overlay" packed packed
                                                                                  unaligned dcl 1385 in procedure "decode_char" set
                                                                                  ref 1485*
bit_8                     0(01)        based           bit(1)                   level 2 in structure "seven_bit_overlay" packed
                                                                                  packed unaligned dcl 1389 in procedure
                                                                                  "decode_char" set ref 1472*
bit_8_value                     001725 automatic       bit(9)                   dcl 1133 set ref 1148* 1156* 1159 1169 1175 1183
                                                                                  1191 1199 1210
bit_overlay                            based           bit(36)                  dcl 1596 ref 1607
bit_string                      000715 automatic       structure                level 2 dcl 313 set ref 366* 421 421
bool                                                   builtin function         dcl 136 ref 1326 1328 1607
buf                                    based           char                     packed unaligned dcl 969 set ref 1016* 1056 1062*
buffer_len                      001006 automatic       fixed bin(21,0)          dcl 678 set ref 701* 717 721
buffer_offsetp                  001014 automatic       pointer                  dcl 683 set ref 712* 717* 721* 727 740
bufferl                  12            based           fixed bin(21,0)          level 3 dcl 672 set ref 708 710 712* 717 721 726*
                                                                                  726 742 743 743 744* 744 753 755 758
bufferp                  10            based           pointer                  level 3 dcl 672 set ref 708 710 712* 742 743 743 753
                                                                                  755 758
bufl                                   parameter       fixed bin(21,0)          dcl 960 ref 935 1016 1056 1062
bufp                                   parameter       pointer                  dcl 959 ref 935 1016 1056 1062
byte                                                   builtin function         dcl 137 ref 500 500 500 500 500 506 506 1220 1562
calculated_checksum             001626 automatic       varying char(3)          dcl 804 set ref 830* 836
capabilities                           based           structure                level 1 dcl 1123 in procedure "encode_char"
capabilities                    000715 automatic       structure                level 1 dcl 313 in procedure "encode_data"
capabilities                    001654 automatic       structure                level 1 dcl 975 in procedure "decode_data" set ref
                                                                                  1033* 1044 1044
capabilities                           based           structure                level 1 dcl 1381 in procedure "decode_char"
capability_str                         parameter       bit(36)                  dcl 1376 in procedure "decode_char" set ref 1337
                                                                                  1404 1425 1477 1477
capability_str                         parameter       bit(38)                  dcl 1112 in procedure "encode_char" set ref 1073
                                                                                  1156 1156 1159 1165 1165 1169 1175 1183 1191 1199
                                                                                  1210 1220
capas                     1(09) 000720 automatic       bit(9)                   level 2 packed packed unaligned dcl 324 set ref 369
char_count                             parameter       fixed bin(21,0)          dcl 664 in procedure "receive_packet" set ref 641
                                                                                  752*
char_count                             parameter       fixed bin(17,0)          dcl 1108 in procedure "encode_char" set ref 1073
                                                                                  1204* 1205 1205* 1210* 1215 1215* 1220 1220 1223*
char_overlay                           based           structure                level 1 packed packed unaligned dcl 1385
                                                                                  in procedure "decode_char"
char_overlay                           based           structure                level 1 dcl 1597 in procedure "ctl_encode"
char_to_code                    001724 automatic       char(1)                  dcl 1129 set ref 1140* 1144* 1144 1148 1152* 1152
                                                                                  1165 1165 1165 1169* 1169 1170 1175 1181 1183*
                                                                                  1183 1184 1184 1189 1191* 1191 1192 1197 1199*
                                                                                  1199 1200 1200 1202 1210
chars                     1            based           char(1500)               level 2 packed packed unaligned dcl 1261 set ref
                                                                                  1274* 1283
chars_read                      001016 automatic       fixed bin(21,0)          dcl 684 set ref 717* 721* 726 727 740 740
check                           000750 automatic       fixed bin(17,0)          dcl 476 in procedure "append_ctl_info" set ref 495*
                                                                                  498 498
check                           001641 automatic       fixed bin(17,0)          dcl 878 in procedure "check_ctl_info" set ref 905*
                                                                                  908 908
check_type                      003354 automatic       fixed bin(8,0)           packed unaligned dcl 1526 in procedure
                                                                                  "calculate_checksum" set ref 1538 1538 1545
check_type                1     000720 automatic       fixed bin(8,0)           level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 324 in procedure "encode_data" set ref 425
checksum                        000762 automatic       varying char(3)          dcl 540 in procedure "append_checksum" set ref 542*
                                                                                  546
checksum                               parameter       varying char             dcl 1521 in procedure "calculate_checksum" set ref
                                                                                  1499 1562*
chk_tp                          000743 automatic       fixed bin(8,0)           packed unaligned dcl 473 set ref 479 479 484
ck_type                         001033 automatic       fixed bin(8,0)           packed unaligned dcl 801 in procedure
                                                                                  "validate_checksum" set ref 808 808 814 822 826
                                                                                  826
ck_type                         001637 automatic       fixed bin(8,0)           packed unaligned dcl 876 in procedure
                                                                                  "check_ctl_info" set ref 884 884 916 922
comm_info                              based           structure                level 1 dcl 584 in procedure "transmit_packet"
comm_info                              based           structure                level 1 dcl 672 in procedure "receive_packet"
comm_info                              based           structure                level 1 dcl 1679 in procedure "debug_log"
comm_info                              based           structure                level 1 dcl 1639 in procedure "process_line_status"
comm_infop               12            based           pointer                  level 2 in structure "info" dcl 1638 in procedure
                                                                                  "process_line_status" ref 1647
comm_infop               12            based           pointer                  level 2 in structure "info" dcl 1678 in procedure
                                                                                  "debug_log" ref 1688
comm_infop               12            based           pointer                  level 2 in structure "info" dcl 669 in procedure
                                                                                  "receive_packet" ref 708 708 710 710 712 712 717
                                                                                  717 721 721 726 726 727 742 742 743 743 743 743
                                                                                  744 744 753 753 755 755 758 758
comm_infop               12            based           pointer                  level 2 in structure "info" dcl 586 in procedure
                                                                                  "transmit_packet" ref 625 631
control_decode                  003343 automatic       bit(1)                   packed unaligned dcl 1399 set ref 1461* 1464* 1477
copy                                                   builtin function         dcl 138 ref 614 1276 1326 1328 1490
crnl_sw                                parameter       bit(1)                   packed unaligned dcl 964 set ref 935 1053*
data                                   based           char                     packed unaligned dcl 1122 in procedure "encode_char"
                                                                                  ref 1140 1204 1204
data                                   parameter       char                     packed unaligned dcl 1674 in procedure "debug_log"
                                                                                  ref 1656 1687
data                                   based           char                     packed unaligned dcl 304 in procedure "encode_data"
                                                                                  ref 415
datal                                  parameter       fixed bin(21,0)          dcl 297 in procedure "encode_data" ref 266 392 399
                                                                                  414 415 419 430
datal                                  parameter       fixed bin(21,0)          dcl 1106 in procedure "encode_char" ref 1073 1137
                                                                                  1140 1204 1204 1205
datap                                  parameter       pointer                  dcl 1105 in procedure "encode_char" ref 1073 1140
                                                                                  1204 1204
datap                                  parameter       pointer                  dcl 296 in procedure "encode_data" set ref 266 415
                                                                                  418*
debug_segp                4            based           pointer                  level 2 in structure "comm_info" dcl 672
                                                                                  in procedure "receive_packet" ref 727
debug_segp                4            based           pointer                  level 2 in structure "comm_info" dcl 584
                                                                                  in procedure "transmit_packet" ref 631
debug_segp                4            based           pointer                  level 2 in structure "comm_info" dcl 1679
                                                                                  in procedure "debug_log" set ref 1688*
decoded_char                    003344 automatic       char(1)                  packed unaligned dcl 1400 set ref 1468* 1471 1477*
                                                                                  1477 1477 1485 1490
direction                              parameter       char(1)                  packed unaligned dcl 1673 ref 1656 1687
done                            000722 automatic       bit(1)                   packed unaligned dcl 334 set ref 391* 417 425* 430*
ec                              001734 automatic       fixed bin(35,0)          dcl 1256 in procedure "set_parity" set ref 1267*
ec                                     parameter       fixed bin(35,0)          dcl 1522 in procedure "calculate_checksum" set ref
                                                                                  1499 1541* 1567*
ec                                     parameter       fixed bin(35,0)          dcl 580 in procedure "transmit_packet" set ref 555
                                                                                  602* 622* 624 625* 627 631
ec                                     parameter       fixed bin(35,0)          dcl 665 in procedure "receive_packet" set ref 641
                                                                                  695* 717* 721* 727 730 730* 733 737
ec                                     parameter       fixed bin(35,0)          dcl 965 in procedure "decode_data" set ref 935 998*
                                                                                  1024* 1030* 1044* 1047
ec                              003402 automatic       fixed bin(35,0)          dcl 1645 in procedure "process_line_status" set ref
                                                                                  1647*
ec                                     parameter       fixed bin(35,0)          dcl 1377 in procedure "decode_char" set ref 1337
                                                                                  1412* 1433* 1454*
ec                              000744 automatic       fixed bin(35,0)          dcl 474 in procedure "append_ctl_info" set ref 479*
ec                              000100 automatic       fixed bin(35,0)          dcl 128 in procedure "kermit_pad_" set ref 190* 202
                                                                                  1688*
ec                                     parameter       fixed bin(35,0)          dcl 536 in procedure "append_checksum" set ref 516
                                                                                  542* 543
ec                                     parameter       fixed bin(35,0)          dcl 796 in procedure "validate_checksum" set ref 774
                                                                                  808* 816* 830* 831 836*
ec                              003330 automatic       fixed bin(35,0)          dcl 1317 in procedure "strip_parity" set ref 1319*
ec                                     parameter       fixed bin(35,0)          dcl 871 in procedure "check_ctl_info" set ref 848
                                                                                  884* 892* 911* 916* 922*
ec                                     parameter       fixed bin(35,0)          dcl 300 in procedure "encode_data" set ref 266 341*
                                                                                  355* 363*
eight_bit                       001654 automatic       bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 975 in procedure "decode_data" set
                                                                                  ref 1037*
eight_bit                              based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1381 in procedure "decode_char" ref
                                                                                  1425 1477
eight_bit                       000715 automatic       bit(1)                   level 3 in structure "capabilities" packed packed
                                                                                  unaligned dcl 313 in procedure "encode_data" set
                                                                                  ref 376* 384*
eight_bit                              based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1123 in procedure "encode_char" ref
                                                                                  1156 1159 1165
eight_bit                 0(09) 001662 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 981 in procedure "decode_data" set ref 1037
                                                                                  1044*
eight_bit                 0(18) 000720 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 324 in procedure "encode_data" set ref 376
                                                                                  421*
eight_bit_ch                           parameter       char(1)                  packed unaligned dcl 1110 in procedure "encode_char"
                                                                                  ref 1073 1159 1165
eight_bit_ch                           parameter       char(1)                  packed unaligned dcl 1374 in procedure "decode_char"
                                                                                  ref 1337 1425 1477
encoded_char              0(27)        based           char(1)                  level 2 packed packed unaligned dcl 1597 ref 1609
encoded_value                   003370 automatic       bit(36)                  dcl 1603 set ref 1607* 1609
eol_ch                    0(09) 000776 automatic       char(1)                  level 2 packed packed unaligned dcl 591 set ref 607
                                                                                  609
eol_char                  0(18) 001017 automatic       char(1)                  level 2 packed packed unaligned dcl 685 set ref 708
                                                                                  710 755 758
eol_index                       001007 automatic       fixed bin(21,0)          dcl 679 set ref 706* 707 708* 710 710* 717 730 742
                                                                                  743 744 755* 758 758* 761
error_table_$line_status_pending
                                000020 external static fixed bin(35,0)          dcl 109 ref 622 624 627 733
error_table_$timeout            000022 external static fixed bin(35,0)          dcl 111 ref 730
ext_header                0(04) 000715 automatic       bit(1)                   level 3 packed packed unaligned dcl 313 set ref 371*
                                                                                  392
false                                  constant        bit(1)                   initial packed unaligned dcl 50 ref 384 391 1442
                                                                                  1464 1472
file_type                 0(09) 001663 automatic       char(1)                  level 2 in structure "perm_modes" packed packed
                                                                                  unaligned dcl 985 in procedure "decode_data" set
                                                                                  ref 1053
file_type                 0(09) 000714 automatic       char(1)                  level 2 in structure "perm_modes" packed packed
                                                                                  unaligned dcl 310 in procedure "encode_data" set
                                                                                  ref 387
ft_iocbp                  2            based           pointer                  level 2 in structure "comm_info" dcl 1639
                                                                                  in procedure "process_line_status" set ref 1647*
ft_iocbp                  2            based           pointer                  level 2 in structure "comm_info" dcl 584
                                                                                  in procedure "transmit_packet" set ref 625*
ft_iocbp                  2            based           pointer                  level 2 in structure "comm_info" dcl 672
                                                                                  in procedure "receive_packet" set ref 717* 721*
hcheck                          000751 automatic       fixed bin(9,0)           unsigned dcl 477 in procedure "append_ctl_info" set
                                                                                  ref 498* 500
hcheck                          001642 automatic       fixed bin(9,0)           unsigned dcl 879 in procedure "check_ctl_info" set
                                                                                  ref 908* 909
header_size                     000733 automatic       fixed bin(17,0)          dcl 339 set ref 392* 394* 425
i                               003355 automatic       fixed bin(17,0)          dcl 1527 set ref 1551* 1552*
index                                                  builtin function         dcl 139 ref 708 710 748 753 755 758
info                                   based           structure                level 1 dcl 586 in procedure "transmit_packet"
info                                   based           structure                level 1 dcl 669 in procedure "receive_packet"
info                                   based           structure                level 1 dcl 1678 in procedure "debug_log"
info                                   based           structure                level 1 dcl 1638 in procedure "process_line_status"
infop                                  parameter       pointer                  dcl 1634 in procedure "process_line_status" ref 1618
                                                                                  1647
infop                                  parameter       pointer                  dcl 294 in procedure "encode_data" set ref 266 355*
                                                                                  363* 421*
infop                                  parameter       pointer                  dcl 1519 in procedure "calculate_checksum" set ref
                                                                                  1499 1538*
infop                                  parameter       pointer                  dcl 662 in procedure "receive_packet" set ref 641
                                                                                  695* 708 708 710 710 712 712 717 717 721 721 726
                                                                                  726 727 727* 735* 740* 742 742 743 743 743 743 744
                                                                                  744 753 753 755 755 758 758
infop                                  parameter       pointer                  dcl 1672 in procedure "debug_log" ref 1656 1688
infop                                  parameter       pointer                  dcl 868 in procedure "check_ctl_info" set ref 848
                                                                                  884*
infop                                  parameter       pointer                  dcl 794 in procedure "validate_checksum" set ref 774
                                                                                  808* 830*
infop                                  parameter       pointer                  dcl 1309 in procedure "strip_parity" set ref 1293
                                                                                  1319*
infop                                  parameter       pointer                  dcl 1104 in procedure "encode_char" ref 1073
infop                                  parameter       pointer                  dcl 958 in procedure "decode_data" set ref 935 1024*
                                                                                  1030* 1044*
infop                                  parameter       pointer                  dcl 578 in procedure "transmit_packet" set ref 555
                                                                                  602* 618* 625 627* 631 631*
infop                                  parameter       pointer                  dcl 534 in procedure "append_checksum" set ref 516
                                                                                  542*
infop                                  parameter       pointer                  dcl 466 in procedure "append_ctl_info" set ref 446
                                                                                  479*
infop                                  parameter       pointer                  dcl 1251 in procedure "set_parity" set ref 1233
                                                                                  1267*
infop                                  parameter       pointer                  dcl 1369 in procedure "decode_char" ref 1337
input_buffer                           based           char                     packed unaligned dcl 670 in procedure
                                                                                  "receive_packet" set ref 708 710 742 743* 743 753
                                                                                  755 758
input_buffer             10            based           structure                level 2 in structure "comm_info" dcl 672
                                                                                  in procedure "receive_packet"
input_time                      001012 automatic       fixed bin(71,0)          dcl 681 set ref 700* 717*
iox_$control                    000012 constant        entry                    external dcl 102 ref 1647
iox_$put_chars                  000014 constant        entry                    external dcl 103 ref 625 1688
kermit_bit_constants            000000 constant        structure                level 1 packed packed unaligned dcl 2-27 set ref 609
                                                                                  609 710 710 758 758 1053 1056 1175 1210 1687
kermit_char_constants                  based           structure                level 1 packed packed unaligned dcl 2-31
kermit_comm_info                       based           structure                level 1 dcl 2-176
kermit_et_$cannot_decode        000024 external static fixed bin(35,0)          dcl 113 ref 1412 1433 1454
kermit_et_$crc_error            000026 external static fixed bin(35,0)          dcl 115 ref 836
kermit_et_$length_mismatch      000030 external static fixed bin(35,0)          dcl 116 ref 916 922
kermit_et_$mangled_packet       000032 external static fixed bin(35,0)          dcl 118 ref 816 892 911 998
kermit_et_$unimplemented_check_type
                                000034 external static fixed bin(35,0)          dcl 120 ref 1567
kermit_fixed_constants                 based           structure                level 1 packed packed unaligned dcl 2-35
kermit_info                            based           structure                level 1 dcl 2-52
kermit_mode_mgr_$retrieve       000040 constant        entry                    external dcl 1-78 ref 355 363 479 602 695 808 884
                                                                                  1024 1030 1267 1319 1538
kermit_stats_info                      based           structure                level 1 dcl 2-147
len                             001640 automatic       fixed bin(17,0)          dcl 877 in procedure "check_ctl_info" set ref 902*
                                                                                  903 914* 916 922
len                             000745 automatic       fixed bin(17,0)          dcl 475 in procedure "append_ctl_info" set ref 484*
                                                                                  487 492* 492 493 494 506
len                                    based           fixed bin(24,0)          level 2 in structure "wksp_overlay" dcl 1261
                                                                                  in procedure "set_parity" set ref 1275*
length                                                 builtin function         dcl 140 ref 199 425 425 484 625 625 705 752 814 822
                                                                                  826 890 916 922 992 1061 1275 1276 1283 1326 1326
                                                                                  1326 1328 1328 1328 1551 1688 1688
lenx1                           000746 automatic       fixed bin(17,0)          dcl 475 set ref 493* 495 500
lenx2                           000747 automatic       fixed bin(17,0)          dcl 475 set ref 494* 495 500
line_byte_size                  001663 automatic       fixed bin(8,0)           level 2 in structure "perm_modes" packed packed
                                                                                  unaligned dcl 985 in procedure "decode_data" set
                                                                                  ref 1037
line_byte_size                  000714 automatic       fixed bin(8,0)           level 2 in structure "perm_modes" packed packed
                                                                                  unaligned dcl 310 in procedure "encode_data" set
                                                                                  ref 381
ls_data                         003400 automatic       bit(72)                  dcl 1644 set ref 1647 1647
mask                            001735 automatic       varying bit(13500)       dcl 1257 set ref 1276* 1280 1282
max_len                   2     000715 automatic       fixed bin(17,0)          level 2 dcl 313 set ref 372* 374* 414 425
maxl                            000720 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 324 set ref 374
maxlnx1                   1(18) 000720 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 324 set
                                                                                  ref 372
maxlnx2                   1(27) 000720 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 324 set
                                                                                  ref 372
min                                                    builtin function         dcl 141 ref 414
mod                                                    builtin function         dcl 142 ref 494 498 498 908 908
modes                           001662 automatic       structure                level 1 dcl 981 in procedure "decode_data" set ref
                                                                                  1024 1024
modes                           000776 automatic       structure                level 1 dcl 591 in procedure "transmit_packet" set
                                                                                  ref 602 602
modes                           001017 automatic       structure                level 1 dcl 685 in procedure "receive_packet" set
                                                                                  ref 695 695
modes                           000720 automatic       structure                level 1 dcl 324 in procedure "encode_data" set ref
                                                                                  355 355
n_chars                         000732 automatic       fixed bin(17,0)          dcl 338 set ref 421* 429
n_sent                                 parameter       fixed bin(21,0)          dcl 299 set ref 266 390* 401* 414* 415 418 419 429*
                                                                                  429 430
new_packet                      001034 automatic       varying char(1500)       dcl 802 set ref 822* 830* 839
null                                                   builtin function         dcl 143 ref 631 727
p_selector                      000712 automatic       fixed bin(17,0)          array dcl 309 in procedure "encode_data" set ref
                                                                                  360* 361* 363*
p_selector                      001660 automatic       fixed bin(17,0)          array dcl 980 in procedure "decode_data" set ref
                                                                                  1027* 1028* 1030*
packet                          000101 automatic       varying char(1500)       dcl 129 in procedure "kermit_pad_" set ref 190* 193*
                                                                                  195* 199 201* 244* 248* 252* 256*
packet                                 parameter       char                     packed unaligned dcl 1310 in procedure
                                                                                  "strip_parity" set ref 1293 1326 1326 1326 1326
                                                                                  1326 1328 1328 1328 1328 1328
packet                                 parameter       varying char             dcl 1252 in procedure "set_parity" set ref 1233 1274
                                                                                  1275 1276 1283* 1283
packet                                 parameter       varying char             dcl 535 in procedure "append_checksum" set ref 516
                                                                                  542* 546* 546
packet                                 parameter       varying char             dcl 579 in procedure "transmit_packet" set ref 555
                                                                                  607* 607 609* 609 614* 614 618* 625 625 625 625
                                                                                  631
packet                                 parameter       varying char             dcl 869 in procedure "check_ctl_info" set ref 848
                                                                                  890 898 902 905 905 905 905 905 909 914 914 916
                                                                                  918 919* 919 922 924* 924
packet                                 parameter       varying char             dcl 795 in procedure "validate_checksum" set ref 774
                                                                                  814 822 822 826 826 839*
packet                                 parameter       varying char             dcl 1370 in procedure "decode_char" ref 1337 1404
                                                                                  1418 1425 1446 1468
packet                                 parameter       varying char             dcl 663 in procedure "receive_packet" set ref 641
                                                                                  703* 705 742* 748 749* 751* 751 752 761*
packet                                 parameter       varying char             dcl 298 in procedure "encode_data" set ref 266 340*
                                                                                  402* 415* 425 428* 428 437* 437
packet                                 parameter       varying char             dcl 467 in procedure "append_ctl_info" set ref 446
                                                                                  484 489 499* 499 500* 500 506* 506
packet                                 parameter       varying char             dcl 1520 in procedure "calculate_checksum" ref 1499
                                                                                  1551 1552
packet                                 parameter       varying char             dcl 962 in procedure "decode_data" set ref 935 992
                                                                                  1004 1016 1044*
packet_fix                      000752 automatic       char(1)                  packed unaligned dcl 478 in procedure
                                                                                  "append_ctl_info" set ref 489* 495 500
packet_fix                      001643 automatic       char(3)                  packed unaligned dcl 880 in procedure
                                                                                  "check_ctl_info" set ref 918* 919
pad_char                  0(18) 000776 automatic       char(1)                  level 2 packed packed unaligned dcl 591 set ref 614
pad_count                 0(27) 000776 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 591 set ref 614
parity                          003327 automatic       char(1)                  packed unaligned dcl 1315 in procedure
                                                                                  "strip_parity" set ref 1319 1319 1326
parity                          002525 automatic       char(1)                  packed unaligned dcl 1258 in procedure "set_parity"
                                                                                  set ref 1267 1267 1272 1272 1280
perm_modes                      000714 automatic       structure                level 1 dcl 310 in procedure "encode_data" set ref
                                                                                  363 363
perm_modes                      001663 automatic       structure                level 1 dcl 985 in procedure "decode_data" set ref
                                                                                  1030 1030
pkt_chr                         001653 automatic       fixed bin(17,0)          dcl 974 in procedure "decode_data" set ref 993*
                                                                                  1005* 1043 1044*
pkt_chr                                parameter       fixed bin(17,0)          dcl 1371 in procedure "decode_char" set ref 1337
                                                                                  1404 1410 1418 1419* 1419 1425 1431 1440* 1440
                                                                                  1446 1452 1462* 1462 1468 1469* 1469
pkt_len                                parameter       fixed bin(17,0)          dcl 1371 in procedure "decode_char" ref 1337 1410
                                                                                  1431 1452
pkt_len                         001652 automatic       fixed bin(17,0)          dcl 973 in procedure "decode_data" set ref 992* 996
                                                                                  1015 1043 1044*
quote                           001662 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 981 in procedure "decode_data" set ref 1044*
quote                     0(09) 000720 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 324 in procedure "encode_data" set ref 421*
quote_ch                               parameter       char(1)                  packed unaligned dcl 1109 in procedure "encode_char"
                                                                                  ref 1073 1165 1170 1175 1175 1184 1200
quote_ch                               parameter       char(1)                  packed unaligned dcl 1373 in procedure "decode_char"
                                                                                  ref 1337 1446 1477
rank                                                   builtin function         dcl 144 ref 495 898 902 905 905 905 905 905 909 914
                                                                                  914 1175 1181 1184 1184 1189 1197 1200 1200 1210
                                                                                  1272 1272 1272 1272 1280 1280 1326 1326 1418 1477
                                                                                  1477 1552
raw                       0(03)        based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1123 in procedure "encode_char" ref
                                                                                  1156 1169 1183 1191 1199
raw                       0(03) 000715 automatic       bit(1)                   level 3 in structure "capabilities" packed packed
                                                                                  unaligned dcl 313 in procedure "encode_data" set
                                                                                  ref 383*
rcvd                                   parameter       fixed bin(21,0)          dcl 963 set ref 935 991* 1015* 1016 1053 1056 1056*
                                                                                  1056 1062 1063* 1063
received_checksum               001624 automatic       varying char(3)          dcl 803 set ref 826* 836
repeat                    0(18) 001662 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 981 in procedure "decode_data" set ref 1040
                                                                                  1044*
repeat                    0(27) 000720 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 324 in procedure "encode_data" set ref 378
                                                                                  421*
repeat                    0(01)        based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1381 in procedure "decode_char" ref
                                                                                  1404 1477
repeat                    0(01) 001654 automatic       bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 975 in procedure "decode_data" set
                                                                                  ref 1040*
repeat                    0(01) 000715 automatic       bit(1)                   level 3 in structure "capabilities" packed packed
                                                                                  unaligned dcl 313 in procedure "encode_data" set
                                                                                  ref 378*
repeat                    0(01)        based           bit(1)                   level 2 in structure "capabilities" packed packed
                                                                                  unaligned dcl 1123 in procedure "encode_char" ref
                                                                                  1165 1220
repeat_ch                              parameter       char(1)                  packed unaligned dcl 1111 in procedure "encode_char"
                                                                                  ref 1073 1165 1220
repeat_ch                              parameter       char(1)                  packed unaligned dcl 1375 in procedure "decode_char"
                                                                                  ref 1337 1404 1477
repeat_count                    003340 automatic       fixed bin(17,0)          dcl 1396 set ref 1418* 1421* 1490
rtrim                                                  builtin function         dcl 145 ref 1688 1688
selector                        003326 automatic       fixed bin(17,0)          initial array dcl 1314 in procedure "strip_parity"
                                                                                  set ref 1314* 1319*
selector                        001020 automatic       fixed bin(17,0)          array dcl 689 in procedure "receive_packet" set ref
                                                                                  691* 692* 693* 695*
selector                        001032 automatic       fixed bin(17,0)          array dcl 800 in procedure "validate_checksum" set
                                                                                  ref 806* 808*
selector                        000742 automatic       fixed bin(17,0)          initial array dcl 472 in procedure "append_ctl_info"
                                                                                  set ref 472* 479*
selector                        003356 automatic       fixed bin(17,0)          initial array dcl 1528 in procedure
                                                                                  "calculate_checksum" set ref 1528* 1538*
selector                        002526 automatic       fixed bin(17,0)          initial array dcl 1259 in procedure "set_parity" set
                                                                                  ref 1259* 1267*
selector                        001636 automatic       fixed bin(17,0)          array dcl 875 in procedure "check_ctl_info" set ref
                                                                                  882* 884*
selector                        000772 automatic       fixed bin(17,0)          array dcl 590 in procedure "transmit_packet" set ref
                                                                                  597* 598* 599* 600* 602*
seq_no                                 parameter       fixed bin(17,0)          dcl 870 in procedure "check_ctl_info" set ref 848
                                                                                  898*
seq_no                                 parameter       fixed bin(17,0)          dcl 468 in procedure "append_ctl_info" ref 446 495
                                                                                  500 506
seql                            001715 automatic       fixed bin(17,0)          dcl 989 set ref 1061* 1062 1063
sequence                        000727 automatic       varying char(5)          dcl 337 in procedure "encode_data" set ref 421* 425
                                                                                  428
sequence                        001664 automatic       varying char(94)         dcl 988 in procedure "decode_data" set ref 1044*
                                                                                  1053 1061 1062
sequence                               parameter       varying char             dcl 1107 in procedure "encode_char" set ref 1073
                                                                                  1159* 1161* 1170* 1170 1175* 1184* 1184 1192* 1192
                                                                                  1200* 1200 1202* 1202 1220* 1220
sequence                               parameter       varying char             dcl 1372 in procedure "decode_char" set ref 1337
                                                                                  1490*
set_eighth_bit                  003341 automatic       bit(1)                   packed unaligned dcl 1397 set ref 1439* 1442* 1485
seven_bit_char                  003342 automatic       char(1)                  packed unaligned dcl 1398 set ref 1471* 1472 1477
                                                                                  1477 1477
seven_bit_overlay                      based           structure                level 1 packed packed unaligned dcl 1389
six_seven_mask                         constant        bit(36)                  initial dcl 1529 ref 1557
start_ch                  0(09) 001017 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 685 in procedure "receive_packet" set ref 748
                                                                                  753
start_ch                        000776 automatic       char(1)                  level 2 in structure "modes" packed packed unaligned
                                                                                  dcl 591 in procedure "transmit_packet" set ref 607
start_index                     001010 automatic       fixed bin(21,0)          dcl 680 set ref 748* 749 751 753* 754 755 758
str                             000100 automatic       char(4000)               packed unaligned dcl 1684 set ref 1687* 1688 1688
                                                                                  1688 1688
string                                                 builtin function         dcl 146 set ref 366* 421 421 1033* 1044 1044
subsetl                         000726 automatic       fixed bin(21,0)          dcl 336 set ref 419* 421*
subsetp                         000724 automatic       pointer                  dcl 335 set ref 418* 421*
substr                                                 builtin function         dcl 147 set ref 415 499 742 743 751 755 758 822 826
                                                                                  898 902 905 905 905 905 905 909 914 914 919 919
                                                                                  924 1004 1016* 1016 1056 1062* 1140 1204 1283 1404
                                                                                  1418 1425 1446 1468 1552
sum                             003357 automatic       fixed bin(35,0)          dcl 1531 set ref 1547* 1552* 1552 1557* 1557 1557
                                                                                  1558 1558 1562
sum_bits                               based           bit(36)                  dcl 1532 set ref 1557 1558* 1558
sys_info$max_seg_size           000036 external static fixed bin(35,0)          dcl 122 ref 701
t_selector                      001655 automatic       fixed bin(17,0)          array dcl 979 in procedure "decode_data" set ref
                                                                                  1020* 1021* 1022* 1024*
t_selector                      000702 automatic       fixed bin(17,0)          array dcl 308 in procedure "encode_data" set ref
                                                                                  346* 347* 348* 349* 350* 351* 352* 353* 355*
timed_io_$get_chars             000016 constant        entry                    external dcl 104 ref 717 721
timeout                         001017 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 685 set ref 700
true                                   constant        bit(1)                   initial packed unaligned dcl 49 ref 371 376 378 383
                                                                                  387 425 430 1037 1040 1053 1439 1461 1485
type                                   parameter       char(1)                  packed unaligned dcl 295 in procedure "encode_data"
                                                                                  ref 266 409 409 409 409 437
type                                   parameter       char(1)                  packed unaligned dcl 961 in procedure "decode_data"
                                                                                  set ref 935 1004* 1010 1010 1010
unspec                                                 builtin function         dcl 148 set ref 1144* 1144 1148 1152* 1152 1169*
                                                                                  1169 1183* 1183 1191* 1191 1199* 1199
value_to_encode                        parameter       fixed bin(35,0)          dcl 1592 set ref 1576 1607
verify                                                 builtin function         dcl 149 ref 1204
wksp_overlay                           based           structure                level 1 unaligned dcl 1261
workspace                       002527 automatic       varying bit(13500)       dcl 1260 in procedure "set_parity" set ref 1274 1275
                                                                                  1280* 1280 1282* 1282 1283
workspace                              based           bit                      packed unaligned dcl 1316 in procedure
                                                                                  "strip_parity" set ref 1326* 1326 1328* 1328
zero_five_mask                         constant        bit(36)                  initial dcl 1533 ref 1558

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Capabilities                           internal static fixed bin(17,0)          initial dcl 3-46
Check_type                             internal static fixed bin(17,0)          initial dcl 3-36
Eight_bit_char                         internal static fixed bin(17,0)          initial dcl 3-33
Eol_char                               internal static fixed bin(17,0)          initial dcl 3-31
File_warning                           internal static fixed bin(17,0)          initial dcl 3-39
G_window                               internal static fixed bin(17,0)          initial dcl 3-88
I_max_lenx1                            internal static fixed bin(17,0)          initial dcl 3-89
I_max_lenx2                            internal static fixed bin(17,0)          initial dcl 3-90
I_maxl                                 internal static fixed bin(17,0)          initial dcl 3-71
I_n_pads                               internal static fixed bin(17,0)          initial dcl 3-73
I_pad_char                             internal static fixed bin(17,0)          initial dcl 3-74
Incomplete                             internal static fixed bin(17,0)          initial dcl 3-38
Max_len_ext_1                          internal static fixed bin(17,0)          initial dcl 3-44
Max_len_ext_2                          internal static fixed bin(17,0)          initial dcl 3-45
Maxl                                   internal static fixed bin(17,0)          initial dcl 3-27
N_pads                                 internal static fixed bin(17,0)          initial dcl 3-29
O_timeout                              internal static fixed bin(17,0)          initial dcl 3-78
Pad_char                               internal static fixed bin(17,0)          initial dcl 3-30
Parity                                 internal static fixed bin(17,0)          initial dcl 3-37
Perm_defaults                          internal static structure                level 1 dcl 3-48
Quote_char                             internal static fixed bin(17,0)          initial dcl 3-32
Repeat_char                            internal static fixed bin(17,0)          initial dcl 3-34
Retrieve_all                           internal static fixed bin(17,0)          initial array dcl 3-25
Retry_threshold                        internal static fixed bin(17,0)          initial dcl 3-41
Start_char                             internal static fixed bin(17,0)          initial dcl 3-35
Store_all                              internal static fixed bin(17,0)          initial array dcl 3-24
Temp_defaults                          internal static structure                level 1 dcl 3-95
Timeout                                internal static fixed bin(17,0)          initial dcl 3-28
Window_size                            internal static fixed bin(17,0)          initial dcl 3-43
kermit_comm_info_version               internal static char(8)                  initial packed unaligned dcl 2-206
kermit_comm_infop                      automatic       pointer                  dcl 2-205
kermit_comm_mgr_$flush_input    000000 constant        entry                    external dcl 1-15
kermit_comm_mgr_$reset_line_modes
                                000000 constant        entry                    external dcl 1-20
kermit_comm_mgr_$set_line_modes 000000 constant        entry                    external dcl 1-25
kermit_get_filenames_           000000 constant        entry                    external dcl 1-30
kermit_info_version                    internal static char(8)                  initial packed unaligned dcl 2-61
kermit_infop                           automatic       pointer                  dcl 2-60
kermit_log_info                        based           structure                level 1 dcl 2-122
kermit_log_info_version                internal static char(8)                  initial packed unaligned dcl 2-133
kermit_log_infop                       automatic       pointer                  dcl 2-132
kermit_log_mgr_$close_log       000000 constant        entry                    external dcl 1-37
kermit_log_mgr_$disable         000000 constant        entry                    external dcl 1-42
kermit_log_mgr_$display_stats   000000 constant        entry                    external dcl 1-46
kermit_log_mgr_$enable          000000 constant        entry                    external dcl 1-51
kermit_log_mgr_$log_message     000000 constant        entry                    external dcl 1-55
kermit_log_mgr_$open_log        000000 constant        entry                    external dcl 1-60
kermit_log_mgr_$start           000000 constant        entry                    external dcl 1-66
kermit_log_mgr_$stop            000000 constant        entry                    external dcl 1-70
kermit_mode_mgr_$get            000000 constant        entry                    external dcl 1-74
kermit_mode_mgr_$set            000000 constant        entry                    external dcl 1-86
kermit_mode_mgr_$store          000000 constant        entry                    external dcl 1-90
kermit_pad_$receive             000000 constant        entry                    external dcl 1-97
kermit_pad_$send                000000 constant        entry                    external dcl 1-108
kermit_perm_mode_count                 internal static fixed bin(17,0)          initial dcl 2-83
kermit_perm_modes                      based           structure                level 1 dcl 2-77
kermit_perm_modes_version              internal static char(8)                  initial packed unaligned dcl 2-84
kermit_perm_modesp                     automatic       pointer                  dcl 2-82
kermit_receive_$receive_from_remote
                                000000 constant        entry                    external dcl 1-118
kermit_send_$send_to_remote     000000 constant        entry                    external dcl 1-128
kermit_server_                  000000 constant        entry                    external dcl 1-138
kermit_stats_infop                     automatic       pointer                  dcl 2-160
kermit_temp_mode_count                 internal static fixed bin(17,0)          initial dcl 2-105
kermit_temp_modes                      based           structure                level 1 dcl 2-99
kermit_temp_modes_version              internal static char(8)                  initial packed unaligned dcl 2-106
kermit_temp_modesp                     automatic       pointer                  dcl 2-104
kermit_xfer_modes_$check_params 000000 constant        entry                    external dcl 1-144
kermit_xfer_modes_$get_local_params
                                000000 constant        entry                    external dcl 1-157
kermit_xfer_modes_$init         000000 constant        entry                    external dcl 1-152
kermit_xfer_modes_$process_params
                                000000 constant        entry                    external dcl 1-166

NAMES DECLARED BY EXPLICIT CONTEXT.
append_checksum                 001420 constant        entry                    internal dcl 516 ref 195
append_ctl_info                 001126 constant        entry                    internal dcl 446 ref 193
calculate_checksum              005076 constant        entry                    internal dcl 1499 ref 542 830
check_ctl_info                  002743 constant        entry                    internal dcl 848 ref 252
ctl_encode                      005246 constant        entry                    internal dcl 1576 ref 1184 1200 1477
debug_log                       005321 constant        entry                    internal dcl 1656 ref 631 727
decode_char                     004652 constant        entry                    internal dcl 1337 ref 1044
decode_data                     003203 constant        entry                    internal dcl 935 ref 256
encode_char                     003547 constant        entry                    internal dcl 1073 ref 421
encode_data                     000440 constant        entry                    internal dcl 266 ref 190
kermit_pad_                     000070 constant        entry                    external dcl 21
process_line_status             005260 constant        entry                    internal dcl 1618 ref 627 735
receive                         000260 constant        entry                    external dcl 212
receive_packet                  002016 constant        entry                    internal dcl 641 ref 244
send                            000105 constant        entry                    external dcl 165
set_parity                      004266 constant        entry                    internal dcl 1233 ref 618
strip_parity                    004472 constant        entry                    internal dcl 1293 ref 740
transmit_packet                 001477 constant        entry                    internal dcl 555 ref 201
validate_checksum               002552 constant        entry                    internal dcl 774 ref 248

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5676        5740    5455        5706
Length      6214    5455        42         237     220           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
kermit_pad_                        2286 external procedure  is an external procedure.  
encode_data                             internal procedure  shares stack frame of external procedure kermit_pad_.  
append_ctl_info                         internal procedure  shares stack frame of external procedure kermit_pad_.  
append_checksum                         internal procedure  shares stack frame of external procedure kermit_pad_.  
transmit_packet                         internal procedure  shares stack frame of external procedure kermit_pad_.  
receive_packet                          internal procedure  shares stack frame of external procedure kermit_pad_.  
validate_checksum                       internal procedure  shares stack frame of external procedure kermit_pad_.  
check_ctl_info                          internal procedure  shares stack frame of external procedure kermit_pad_.  
decode_data                             internal procedure  shares stack frame of external procedure kermit_pad_.  
encode_char                             internal procedure  shares stack frame of external procedure kermit_pad_.  
set_parity                              internal procedure  shares stack frame of external procedure kermit_pad_.  
strip_parity                            internal procedure  shares stack frame of external procedure kermit_pad_.  
decode_char                             internal procedure  shares stack frame of external procedure kermit_pad_.  
calculate_checksum                      internal procedure  shares stack frame of external procedure kermit_pad_.  
ctl_encode                              internal procedure  shares stack frame of external procedure kermit_pad_.  
process_line_status                     internal procedure  shares stack frame of external procedure kermit_pad_.  
debug_log                          1080 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
debug_log                000100 str                         debug_log
kermit_pad_              000100 ec                          kermit_pad_
                         000101 packet                      kermit_pad_
                         000702 t_selector                  encode_data
                         000712 p_selector                  encode_data
                         000714 perm_modes                  encode_data
                         000715 capabilities                encode_data
                         000720 modes                       encode_data
                         000722 done                        encode_data
                         000724 subsetp                     encode_data
                         000726 subsetl                     encode_data
                         000727 sequence                    encode_data
                         000732 n_chars                     encode_data
                         000733 header_size                 encode_data
                         000742 selector                    append_ctl_info
                         000743 chk_tp                      append_ctl_info
                         000744 ec                          append_ctl_info
                         000745 len                         append_ctl_info
                         000746 lenx1                       append_ctl_info
                         000747 lenx2                       append_ctl_info
                         000750 check                       append_ctl_info
                         000751 hcheck                      append_ctl_info
                         000752 packet_fix                  append_ctl_info
                         000762 checksum                    append_checksum
                         000772 selector                    transmit_packet
                         000776 modes                       transmit_packet
                         001006 buffer_len                  receive_packet
                         001007 eol_index                   receive_packet
                         001010 start_index                 receive_packet
                         001012 input_time                  receive_packet
                         001014 buffer_offsetp              receive_packet
                         001016 chars_read                  receive_packet
                         001017 modes                       receive_packet
                         001020 selector                    receive_packet
                         001032 selector                    validate_checksum
                         001033 ck_type                     validate_checksum
                         001034 new_packet                  validate_checksum
                         001624 received_checksum           validate_checksum
                         001626 calculated_checksum         validate_checksum
                         001636 selector                    check_ctl_info
                         001637 ck_type                     check_ctl_info
                         001640 len                         check_ctl_info
                         001641 check                       check_ctl_info
                         001642 hcheck                      check_ctl_info
                         001643 packet_fix                  check_ctl_info
                         001652 pkt_len                     decode_data
                         001653 pkt_chr                     decode_data
                         001654 capabilities                decode_data
                         001655 t_selector                  decode_data
                         001660 p_selector                  decode_data
                         001662 modes                       decode_data
                         001663 perm_modes                  decode_data
                         001664 sequence                    decode_data
                         001715 seql                        decode_data
                         001724 char_to_code                encode_char
                         001725 bit_8_value                 encode_char
                         001734 ec                          set_parity
                         001735 mask                        set_parity
                         002525 parity                      set_parity
                         002526 selector                    set_parity
                         002527 workspace                   set_parity
                         003326 selector                    strip_parity
                         003327 parity                      strip_parity
                         003330 ec                          strip_parity
                         003340 repeat_count                decode_char
                         003341 set_eighth_bit              decode_char
                         003342 seven_bit_char              decode_char
                         003343 control_decode              decode_char
                         003344 decoded_char                decode_char
                         003354 check_type                  calculate_checksum
                         003355 i                           calculate_checksum
                         003356 selector                    calculate_checksum
                         003357 sum                         calculate_checksum
                         003370 encoded_value               ctl_encode
                         003400 ls_data                     process_line_status
                         003402 ec                          process_line_status

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     alloc_bit_temp      cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
return_mac          mpfx2               mdfx1               shorten_stack       ext_entry           int_entry_desc
trunc_fx2           repeat              set_chars_eis       set_bits_eis        verify_eis          divide_fx1
divide_fx3          scaled_mod_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_char_offset_              iox_$control                  iox_$put_chars                kermit_mode_mgr_$retrieve
timed_io_$get_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$line_status_pending                            error_table_$timeout          kermit_et_$cannot_decode
kermit_et_$crc_error          kermit_et_$length_mismatch    kermit_et_$mangled_packet
kermit_et_$unimplemented_check_type                         sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000067       165 000075       190 000115       193 000154       195 000175       196 000216       199 000220
    201 000224       202 000244       205 000250       212 000251       240 000270       241 000272       242 000273
    244 000274       245 000320       248 000322       249 000343       252 000345       253 000372       256 000374
    259 000437       266 000440       340 000451       341 000454       346 000455       347 000457       348 000461
    349 000463       350 000465       351 000467       352 000471       353 000473       355 000475       360 000527
    361 000531       363 000533       366 000566       369 000571       371 000576       372 000600       373 000611
    374 000612       376 000615       378 000624       381 000632       383 000636       384 000640       387 000642
    390 000651       391 000653       392 000654       394 000665       399 000667       401 000671       402 000672
    403 000674       409 000675       414 000712       415 000716       416 000730       417 000731       418 000734
    419 000752       421 000756       425 001035       428 001056       429 001070       430 001072       433 001077
    437 001100       439 001124       446 001126       472 001137       479 001144       484 001177       487 001206
    489 001210       492 001215       493 001217       494 001232       495 001236       498 001247       499 001273
    500 001304       505 001362       506 001364       509 001416       516 001420       542 001431       543 001457
    546 001463       548 001476       555 001477       597 001510       598 001512       599 001514       600 001516
    602 001520       607 001553       609 001607       614 001627       618 001660       622 001676       624 001702
    625 001707       627 001736       629 001751       631 001752       634 002014       641 002016       691 002027
    692 002031       693 002033       695 002035       700 002070       701 002075       703 002101       705 002104
    706 002110       707 002111       708 002114       710 002133       712 002160       717 002173       721 002226
    726 002260       727 002266       730 002324       733 002335       735 002340       736 002346       737 002347
    740 002352       741 002372       742 002373       743 002411       744 002424       748 002426       749 002442
    751 002445       752 002457       753 002463       754 002475       755 002476       758 002515       761 002543
    765 002550       767 002551       774 002552       806 002563       808 002565       814 002620       816 002627
    817 002632       822 002633       826 002647       830 002670       831 002714       836 002720       839 002731
    841 002742       848 002743       882 002754       884 002756       890 003011       892 003016       893 003021
    898 003022       902 003030       903 003035       905 003036       908 003056       909 003075       911 003103
    912 003106       914 003107       916 003115       918 003126       919 003133       920 003156       922 003160
    924 003171       928 003202       935 003203       991 003214       992 003216       993 003221       996 003223
    998 003225       999 003230      1004 003231      1005 003235      1010 003237      1015 003251      1016 003254
   1017 003264      1020 003265      1021 003267      1022 003271      1024 003273      1027 003325      1028 003327
   1030 003331      1033 003364      1037 003365      1040 003400      1043 003407      1044 003413      1047 003474
   1053 003500      1056 003523      1061 003533      1062 003535      1063 003544      1064 003545      1066 003546
   1073 003547      1137 003560      1140 003564      1144 003572      1148 003576      1152 003601      1156 003604
   1159 003623      1161 003642      1165 003644      1169 003702      1170 003707      1171 003743      1175 003745
   1181 004006      1183 004011      1184 004016      1185 004060      1189 004062      1191 004064      1192 004071
   1193 004101      1197 004102      1199 004104      1200 004111      1201 004153      1202 004155      1204 004165
   1205 004175      1210 004200      1215 004220      1220 004225      1223 004262      1225 004265      1233 004266
   1259 004277      1267 004304      1272 004337      1274 004353      1275 004361      1276 004364      1280 004401
   1282 004433      1283 004460      1286 004471      1293 004472      1314 004503      1319 004510      1326 004543
   1328 004611      1330 004650      1337 004652      1404 004670      1410 004705      1412 004711      1413 004714
   1418 004715      1419 004723      1420 004725      1421 004726      1425 004730      1431 004742      1433 004746
   1434 004751      1439 004752      1440 004754      1441 004755      1442 004756      1446 004757      1452 004766
   1454 004772      1455 004775      1461 004776      1462 005000      1463 005001      1464 005002      1468 005003
   1469 005010      1471 005011      1472 005014      1477 005016      1485 005051      1490 005055      1492 005074
   1499 005076      1528 005114      1538 005121      1541 005155      1545 005157      1547 005163      1551 005164
   1552 005175      1553 005206      1557 005210      1558 005220      1562 005222      1563 005241      1567 005242
   1569 005245      1576 005246      1607 005250      1609 005253      1618 005260      1647 005262      1649 005317
   1656 005320      1687 005334      1688 005364      1690 005421


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
