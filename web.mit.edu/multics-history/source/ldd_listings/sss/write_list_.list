	COMPILATION LISTING OF SEGMENT write_list_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1844.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*converted to version 2 pl1 on 11.20.72 by Alan Downing*/
       12 write_list_: proc;
       13 
       14 dcl (sp,						/* save ap */
       15      p,						/* pointer to current argument */
       16      xptr) ptr,					/* pointer to floating point number */
       17 
       18      packed bit(1) aligned,				/* "1"b if packed argument */
       19      ndims fixed bin(15),				/* number of dimensions in an array */
       20      size fixed bin(35),				/* arithemetic precision, string size,
       21*						   or number of structure elements */
       22      scale fixed bin(15),				/* arithemetic scale */
       23 
       24     (i,j,jj,l,bin_exp,no_of_arg,type) fixed bin(15),
       25      exponent fixed bin(15),
       26      number1 fixed bin(35),
       27     (int2,int_temp) fixed bin(63),
       28      fractional fixed bin(35),
       29      fractional2 fixed bin(71),
       30 
       31     (upper,upper_quotient,upper_remainder) fixed bin(35),
       32     (lower,lower_quotient) fixed bin(50),
       33 
       34      d(25) fixed bin(15),
       35 
       36      x float bin(63),
       37 
       38      bit0 bit(36) aligned int static init("0"b),
       39      single_p bit(1) aligned,
       40      dec_bit72 bit(72) aligned,
       41 
       42      based_fix fixed bin(35) based(p),
       43      based_fix71 fixed bin(71) based(p),
       44      based_float float bin(27) based(p),
       45      based_float63 float bin(63) based(p),
       46      based_bit bit(36) aligned based(p),
       47      based_bit_string bit(144) based(p),
       48      based_bit72 bit(72) aligned based(p),
       49 
       50      digit(0: 9) char(1) int static
       51      init("0","1","2","3","4","5","6","7","8","9"),
       52 
       53      based_char_string char(140) based(p);
       54 
       55 dcl 1 arg based(sp) aligned,				/* Multics argument list structure */
       56     2 (acount,spval,dcount,padding) bit(18) unal,
       57     2 ptr(1) pointer;				/* argument pointers */
       58 
       59 dcl 1 pointer based(p) aligned,			/* PL/1 pointer structure */
       60     2 (segno,pad,offset) bit(18) unal,
       61     2 (bit_offset,modifier) bit(9) unal;
       62 
       63 dcl  cv_chars char(13) varying aligned,
       64      ch char(1) aligned;
       65 
       66 dcl  suffix char(4) aligned;
       67 
       68 dcl  nl_is_required bit(1) aligned;			/* flag to remember if new line char is needed */
       69 dcl nl char(1) init("
       70 ");/*new line character*/
       71 
       72 dcl  string char(132) aligned varying,
       73      substring char(132) aligned varying,
       74      temp_string char(21) aligned;
       75 
       76 dcl  proc_name char(12) aligned int static init("write_list_");
       77 dcl  string_no_descrip char(80) aligned int static
       78      init("No descriptors supplied; delete the declaration of the parameters to write_list_");
       79 
       80 dcl  cu_$arg_list_ptr entry(ptr),
       81      com_err_ entry options(variable),
       82      convert_binary_integer_$decimal_string entry(fixed bin(35)) returns(char(12) varying),
       83      convert_binary_integer_$long_decimal_string entry(fixed bin(71)) returns(char(23) varying),
       84      convert_binary_integer_$octal_string entry(fixed bin(35)) returns(char(13) varying),
       85      decode_descriptor_ entry(ptr,fixed bin(15),fixed bin(15),bit(1) aligned,
       86      fixed bin(15),fixed bin(35),fixed bin(15)),
       87      ios_$write_ptr entry(ptr,fixed bin(35),fixed bin(35));
       88 
       89 dcl (abs,addr,addrel,divide,fixed,length,mod,substr,unspec) builtin;
       90 
  1     1 dcl	decimal_table(34) fixed bin(35) int static init(
  1     2 
  1     3 5000000000,
  1     4 2500000000,
  1     5 1250000000,
  1     6  625000000,
  1     7  312500000,	/*  5 */
  1     8  156250000,
  1     9   78125000,
  1    10   39062500,
  1    11   19531250,
  1    12    9765625,	/* 10 */
  1    13    4882813,
  1    14    2441406,
  1    15    1220703,
  1    16     610352,
  1    17     305176,	/* 15 */
  1    18     152588,
  1    19      76294,
  1    20      38147,
  1    21      19073,
  1    22       9537,	/* 20 */
  1    23       4768,
  1    24       2384,
  1    25       1192,
  1    26        596,
  1    27        298,	/* 25 */
  1    28        149,
  1    29         75,
  1    30         37,
  1    31         19,
  1    32          9,	/* 30 */
  1    33          5,
  1    34          2,
  1    35          1,
  1    36          1
  1    37 
  1    38 		);
       91 
  2     1 dcl	decimal_table_2(72) fixed bin(71) int static init(
  2     2 
  2     3 500000000000000000000,
  2     4 250000000000000000000,
  2     5 125000000000000000000,
  2     6  62500000000000000000,
  2     7  31250000000000000000,	/*  5 */
  2     8  15625000000000000000,
  2     9   7812500000000000000,
  2    10   3906250000000000000,
  2    11   1953125000000000000,
  2    12    976562500000000000,	/* 10 */
  2    13    488281250000000000,
  2    14    244140625000000000,
  2    15    122070312500000000,
  2    16     61035156250000000,
  2    17     30517578125000000,	/* 15 */
  2    18     15258789062500000,
  2    19      7629394531250000,
  2    20      3814697265625000,
  2    21      1907348632812500,
  2    22       953674316406250,	/* 20 */
  2    23       476837158203125,
  2    24       238418579101563,
  2    25       119209289550781,
  2    26        59604644775391,
  2    27        29802322387695,	/* 25 */
  2    28        14901161193848,
  2    29         7450580596924,
  2    30         3725290298462,
  2    31         1862645149231,
  2    32          931322574615,	/* 30 */
  2    33          465661287308,
  2    34          232830643654,
  2    35          116415321827,
  2    36           58207660913,
  2    37           29103830457,	/* 35 */
  2    38           14551915228,
  2    39            7275957614,
  2    40            3637978807,
  2    41            1818989404,
  2    42             909494702,	/* 40 */
  2    43             454747351,
  2    44             227373675,
  2    45             113686838,
  2    46              56843419,
  2    47              28421709,	/* 45 */
  2    48              14210855,
  2    49               7105427,
  2    50               3552714,
  2    51               1776357,
  2    52                888178,	/* 50 */
  2    53                444089,
  2    54                222045,
  2    55                111022,
  2    56                 55511,
  2    57                 27756,	/* 55 */
  2    58                 13878,
  2    59                  6939,
  2    60                  3469,
  2    61                  1735,
  2    62                   867,	/* 60 */
  2    63                   434,
  2    64                   217,
  2    65                   108,
  2    66                    54,
  2    67                    27,	/* 65 */
  2    68                    14,
  2    69                     7,
  2    70                     3,
  2    71                     2,
  2    72                     1,	/* 70 */
  2    73                     0,
  2    74                     0
  2    75 			);
       92 
       93 /*  */
       94 	nl_is_required = "1"b;			/* normal entry adds new line character */
       95 	go to start;
       96 
       97 nnl:	entry;					/* entry to suppress new line character */
       98 	nl_is_required = "0"b;
       99 
      100 start:	
      101 	call cu_$arg_list_ptr(sp);			/* get a pointer to the argument list */
      102 	if arg.dcount = (18)"0"b			/* error, no descripters */
      103 	then do;
      104 	     call com_err_ (0,proc_name,string_no_descrip);
      105 	     return;
      106 	end;
      107 
      108 	no_of_arg = divide(fixed(arg.acount,18),2,15,0);
      109 	string = "";
      110 
      111 	do j = 1 to no_of_arg;			/* loop for processing arguments */
      112 	     call decode_descriptor_(sp,j,type,packed,ndims,size,scale);
      113 	     p = arg.ptr(j);			/* get pointer to current argument */
      114 
      115 /* Note that when Version II PL/1 comes along, we will have to be very careful
      116*   to obey the "packed" flag for all data items. All packed integers will have
      117*   to be extracted with an adjustable bit string, and their sign bit extended to
      118*   the unpacked representation. Also, we should print out the scale factor for fixed
      119*   point items (345f+6) */
      120 
      121 
      122 /*  */
      123 	     if type = 1				/* real fixed single */
      124 	     then substring = "  "||convert_binary_integer_$decimal_string(p->based_fix);
      125 						/*  */
      126 	     else if type = 2			/* real fixed double */
      127 	     then substring = "  "||convert_binary_integer_$long_decimal_string(p->based_fix71);
      128 
      129 /*  */
      130 	     else if type < 5			/* for real floating point; 3 = single precision,4 = double */
      131 	     then do;
      132 		x = 0e0;
      133 		if type = 3			/* the number is single precision */
      134 		then do;
      135 		     single_p = "1"b;		/* set the single precision flag on */
      136 		     x = p->based_float;		/* pick up a single precision number */
      137 		end;
      138 		else do;				/* the number is double precision */
      139 		     single_p = "0"b;		/* set the single precision flag off */
      140 		     x = p->based_float63;		/* pick up a double precision number */
      141 		end;
      142 
      143 		if substr(p->based_bit,9,2) = bit0	/* if the number is zero */
      144 		then do;
      145 		     substring = "  0.00000000e+00";	/* set the answer */
      146 		     go to end_float;
      147 		end;
      148 
      149 		if substr(p->based_bit,9,1)		/* if the number is negative */
      150 		then substring = " -0.";		/* set a leading minus sign in answer */
      151 		else substring = "  0.";
      152 
      153 		x = abs(x);			/* take the absolute value of the number */
      154 
      155 		exponent = 0;			/* initialize the print-out exponent */
      156 
      157 		if x>=1.0e-1			/* if the number is > than .1 */
      158 		then do;				/* reduce it so that 0 < number < .1 */
      159 		     do while (x>=1.0e4);
      160 			x = x*(10.0e0**-5);		/* first pull out powers of 10**5 */
      161 			exponent = exponent+5;	/* increment exponent accordingly */
      162 		     end;
      163 		     do while(x>=1.0e0);
      164 			x = x*(10.0e0**-1);		/* then pull out powers of 10 */
      165 			exponent = exponent+1;	/* incrementing the exponent */
      166 		     end;
      167 		end;
      168 		else do;				/* if the number is negative, reverse procedure */
      169 		     do while(x<1.0e-5);		/* while the number is < 10**-5 */
      170 			x = x*(10.0e0**5);		/* multiply by 10**5 */
      171 			exponent = exponent-5;	/* and increment exponent */
      172 		     end;
      173 		     do while(x<1.0e-1);		/* while number is < 10**-1 */
      174 			x = x*(10.0e0**1);		/* multiply by 10 */
      175 			exponent = exponent-1;	/* and increment exponent */
      176 		     end;
      177 		end;
      178 
      179 		if exponent>=0			/* set the sign of the exponent */
      180 		then suffix = "e+  ";
      181 		else suffix = "e-  ";
      182 
      183 		exponent = abs(exponent);		/* take the absolute value of the exponent */
      184 
      185 		xptr = addr(x);
      186 		bin_exp = fixed(substr(xptr->based_bit,1,8),8); /* get binary exponent */
      187 
      188 		dec_bit72 = substr(xptr->based_bit72,10,63); /* pick out mantissa */
      189 
      190 		if bin_exp^=0 then bin_exp = 256-bin_exp; /* since the number is less than .1, the exponent
      191*						   is <= 0. Take its absolute value */
      192 
      193 		if single_p			/* if the number is single precision */
      194 		then do;
      195 		     fractional = 0;		/* initialize fixed point representation */
      196 		     do i = 1 to 27;		/* multiply bits by appropriate exponent */
      197 			if substr(dec_bit72,i,1)
      198 			then fractional = fractional+decimal_table(i+bin_exp);
      199 		     end;				/* fractional is fixed point representation */
      200 		     fractional = fractional+decimal_table(28+bin_exp); /* round-off step */
      201 
      202 		     number1 = divide(fractional+50,100,35,0); /* add fifty to force carry
      203*						   if all bits are ones, divide by
      204*						   100 to throw away last two bits */
      205 
      206 		     do i = 1 to 7;
      207 			d(i) = mod(number1,10);	/* pull out rightmost digit */
      208 			number1 = divide(number1,10,35,0); /* decrement number */
      209 		     end;
      210 
      211 		     if number1 = 10		/* if the result is 10 */
      212 		     then do;			/* put it in a better representation */
      213 			number1 = 1;
      214 			exponent = exponent+1;
      215 		     end;
      216 
      217 		     substring = substring||(digit(number1)||digit(d(7))||digit(d(6))||digit(d(5))
      218 		     ||digit(d(4))||digit(d(3))||digit(d(2))||digit(d(1))); /* make up output string */
      219 		end;
      220 		else do;				/* for double precision numbers */
      221 		     fractional2 = 0;		/* initialize fixed point representation */
      222 		     do i = 1 to 63;		/* convert number to fixed point representation */
      223 			if substr(dec_bit72,i,1)
      224 			then fractional2 = fractional2+decimal_table_2(i+bin_exp);
      225 		     end;
      226 
      227 		     fractional2 = fractional2+decimal_table_2(64+bin_exp)+54;
      228 						/* 54 is added in order to force a carry
      229*						   if all 63 mantissa bits are one's */
      230 
      231 		     upper = addr(fractional2)->based_fix; /* split number into 2 parts */
      232 		     lower = fractional2-68719476736*upper;
      233 
      234 		     do i = 1 by 1 while(upper>=134217728); /* reduce upper part to < 2**27 */
      235 			upper_quotient = divide(upper,10,35,0);
      236 			upper_remainder = upper-10*upper_quotient;
      237 
      238 			lower = lower+68719476736*upper_remainder;
      239 			lower_quotient = divide(lower,10,50,0);
      240 			d(i) = lower-10*lower_quotient;
      241 			substr(temp_string,22-i,1) = digit(d(i));
      242 
      243 			upper = upper_quotient;
      244 			lower = lower_quotient;
      245 		     end;
      246 
      247 		     int2 = 68719476736*upper+lower;
      248 
      249 		     do i = i to 21;		/* now continue division normally */
      250 			int_temp = divide(int2,10,63,0);
      251 			d(i) = int2-10*int_temp;
      252 			int2 = int_temp;
      253 			substr(temp_string,22-i,1) = digit(d(i));
      254 		     end;
      255 
      256 		     substring = substring||substr(temp_string,1,19);
      257 		     if substr(substring,5,1) = "0"	/* round-off */
      258 		     then do;
      259 			substr(substring,5,1) = digit(1);
      260 			exponent = exponent+1;
      261 		     end;
      262 		end;
      263 
      264 		substr(suffix,3,2) = digit(divide(exponent,10,15,0))||digit(mod(exponent,10));
      265 		substring = substring||suffix;
      266 end_float:	
      267 	     end;
      268 
      269 /*  */
      270 
      271 	     else if type = 9 | type = 10		/*  for real decimal; 9 = fixed, 10 = float */
      272 	     then do;
      273 		cv_chars = "";
      274 		size = size + 1;			/* account for leading sign */
      275 		if type = 10
      276 		then do;
      277 		     ch = substr(p->based_char_string,size+1,1); /* pick off exponent from number */
      278 exponent = fixed(unspec(ch),9);
      279 		     if exponent >= 128 then exponent = exponent - 256; /* normalize from 8 bit representation */
      280 		     cv_chars = convert_binary_integer_$decimal_string((exponent));
      281 		     cv_chars = "e"||cv_chars;
      282 		end;
      283 		do jj = 2 to size while(substr(p->based_char_string,jj,1) = "0");
      284 		end;
      285 		if jj = size+1
      286 		then do;
      287 		     jj = size;
      288 		     cv_chars = "";
      289 		end;
      290 		ch = substr(p->based_char_string,1,1);
      291 		if ch ^= "-" then ch = "";
      292 		l = size-jj+1;
      293 		substring = "  "||ch||substr(p->based_char_string,jj,l)||cv_chars;
      294 	     end;
      295 						/*  */
      296 	     else if type = 13			/* pointer datum */
      297 	     then do;
      298 		cv_chars = convert_binary_integer_$octal_string(fixed(pointer.segno,35));
      299 		substring = "  "||cv_chars||"|";
      300 		cv_chars = convert_binary_integer_$octal_string(fixed(pointer.offset,35));
      301 		substring = substring||cv_chars;
      302 
      303 		if pointer.bit_offset ^= (9)"0"b	/* add in bit offset if found */
      304 		then do;
      305 		     cv_chars = convert_binary_integer_$decimal_string(fixed(pointer.bit_offset,9));
      306 		     substring = substring||"("||cv_chars||")";
      307 		end;
      308 
      309 	     end;
      310 
      311 /*  */
      312 	     else if type = 19 | type = 20		/* for bit strings; 19 = fixed length, 20 = varying */
      313 	     then do;
      314 		if type = 20			/* varying string, get current length */
      315 		then l = addrel(p,-1)->based_fix;
      316 		else l = size;			/* fixed string, get length from descriptor */
      317 		substring = "  """;
      318 
      319 		do i = 1 to l;
      320 		     if substr(p->based_bit_string,i,1)
      321 		     then substring = substring||"1";
      322 		     else substring = substring||"0";
      323 		end;
      324 
      325 		substring = substring||"""b";
      326 	     end;
      327 
      328 /*  */
      329 	     else if type = 21 | type = 22		/* for character strings; 21 = fixed length,22 = varying */
      330 	     then do;
      331 		if type = 22			/* varying string, get current length */
      332 		then l = addrel(p,-1)->based_fix;
      333 		else l = size;			/* fixed string, get length from descriptor */
      334 
      335 		if l = 0
      336 		then do;
      337 		     substring = "  """"";
      338 		end;
      339 		else do;
      340 		     substring = "  "||substr(p->based_char_string,1,l);
      341 		end;
      342 	     end;
      343 
      344 /*  */
      345 	     else do;				/* illegal descripter type */
      346 		call com_err_(0,proc_name,"Unhandled data-type ^d for argument ^d. It will be replaced by XXX",type,j);
      347 		substring = "  XXX";
      348 	     end;
      349 
      350 	     if length(string)+length(substring) > 131	/* if length of output string exceeded */
      351 	     then do;
      352 		call ios_$write_ptr(addr(string),0,length(string)); /* write what you've got */
      353 		string = substring;			/* and begin a new output string */
      354 	     end;
      355 	     else do;				/* no overflow, concatenate substring */
      356 		string = string||substring;		/* add argument to print-out string */
      357 	     end;
      358 
      359 	end;					/* end of do loop for processing arguments */
      360 
      361 	if nl_is_required
      362 	then do;
      363 	string = string || nl;/* add on a new line character*/
      364 	end;
      365 
      366 	call ios_$write_ptr(addrel(addr(string),1),0,length(string));
      367 
      368      end write_list_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1631.8  write_list_.pl1                   >dumps>old>recomp>write_list_.pl1
91           1    05/06/74  1742.2  dectab.incl.pl1                   >ldd>include>dectab.incl.pl1
92           2    05/06/74  1741.1  decimal_table.incl.pl1            >ldd>include>decimal_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abs                                                    builtin function         dcl 89 ref 153 183
acount                                 based           bit(18)                  level 2 packed unaligned dcl 55 ref 108
addr                                                   builtin function         dcl 89 ref 185 231 352 352 366 366
addrel                                                 builtin function         dcl 89 ref 314 331 366 366
arg                                    based           structure                level 1 dcl 55
based_bit                              based           bit(36)                  dcl 14 ref 143 149 186
based_bit72                            based           bit(72)                  dcl 14 ref 188
based_bit_string                       based           bit(144)                 unaligned dcl 14 ref 320
based_char_string                      based           char(140)                unaligned dcl 14 ref 277 283 290 293 340
based_fix                              based           fixed bin(35,0)          dcl 14 set ref 123* 231 314 331
based_fix71                            based           fixed bin(71,0)          dcl 14 set ref 126*
based_float                            based           float bin(27)            dcl 14 ref 136
based_float63                          based           float bin(63)            dcl 14 ref 140
bin_exp                         000116 automatic       fixed bin(15,0)          dcl 14 set ref 186* 190 190* 190 197 200 223 227
bit0                                   constant        bit(36)                  initial dcl 14 ref 143
bit_offset                1(18)        based           bit(9)                   level 2 packed unaligned dcl 59 ref 303 305 305
ch                              000211 automatic       char(1)                  dcl 63 set ref 277* 278 290* 291 291* 293
com_err_                        000044 constant        entry                    external dcl 80 ref 104 346
convert_binary_integer_$decimal_string
                                000046 constant        entry                    external dcl 80 ref 123 280 305
convert_binary_integer_$long_decimal_string
                                000050 constant        entry                    external dcl 80 ref 126
convert_binary_integer_$octal_string
                                000052 constant        entry                    external dcl 80 ref 298 300
cu_$arg_list_ptr                000042 constant        entry                    external dcl 80 ref 100
cv_chars                        000204 automatic       varying char(13)         dcl 63 set ref 273* 280* 281* 281 288* 293 298* 299
                                                                                  300* 301 305* 306
d                               000144 automatic       fixed bin(15,0)          array dcl 14 set ref 207* 217 217 217 217 217 217
                                                                                  217 240* 241 251* 253
dcount                    1            based           bit(18)                  level 2 packed unaligned dcl 55 ref 102
dec_bit72                       000202 automatic       bit(72)                  dcl 14 set ref 188* 197 223
decimal_table                   000220 constant        fixed bin(35,0)          initial array dcl 1-1 ref 197 200
decimal_table_2                 000000 constant        fixed bin(71,0)          initial array dcl 2-1 ref 223 227
decode_descriptor_              000054 constant        entry                    external dcl 80 ref 112
digit                           000262 constant        char(1)                  initial array unaligned dcl 14 ref 217 217 217 217
                                                                                  217 217 217 217 241 253 259 264 264
divide                                                 builtin function         dcl 89 ref 108 202 208 235 239 250 264
exponent                        000121 automatic       fixed bin(15,0)          dcl 14 set ref 155* 161* 161 165* 165 171* 171 175*
                                                                                  175 179 183* 183 214* 214 260* 260 264 264 278*
                                                                                  279 279* 279 280
fixed                                                  builtin function         dcl 89 ref 108 186 278 298 298 300 300 305 305
fractional                      000130 automatic       fixed bin(35,0)          dcl 14 set ref 195* 197* 197 200* 200 202
fractional2                     000132 automatic       fixed bin(71,0)          dcl 14 set ref 221* 223* 223 227* 227 231 232
i                               000112 automatic       fixed bin(15,0)          dcl 14 set ref 196* 197 197* 206* 207* 222* 223 223*
                                                                                  234* 240 241 241* 249* 249* 251 253 253* 319* 320*
int2                            000124 automatic       fixed bin(63,0)          dcl 14 set ref 247* 250 251 252*
int_temp                        000126 automatic       fixed bin(63,0)          dcl 14 set ref 250* 251 252
ios_$write_ptr                  000056 constant        entry                    external dcl 80 ref 352 366
j                               000113 automatic       fixed bin(15,0)          dcl 14 set ref 111* 112* 113 346*
jj                              000114 automatic       fixed bin(15,0)          dcl 14 set ref 283* 283* 285 287* 292 293
l                               000115 automatic       fixed bin(15,0)          dcl 14 set ref 292* 293 314* 316* 319 331* 333* 335
                                                                                  340
length                                                 builtin function         dcl 89 ref 350 350 352 352 366 366
lower                           000140 automatic       fixed bin(50,0)          dcl 14 set ref 232* 238* 238 239 240 244* 247
lower_quotient                  000142 automatic       fixed bin(50,0)          dcl 14 set ref 239* 240 244
mod                                                    builtin function         dcl 89 ref 207 264
ndims                           000107 automatic       fixed bin(15,0)          dcl 14 set ref 112*
nl                              000214 automatic       char(1)                  initial unaligned dcl 69 set ref 69* 363
nl_is_required                  000213 automatic       bit(1)                   dcl 68 set ref 94* 98* 361
no_of_arg                       000117 automatic       fixed bin(15,0)          dcl 14 set ref 108* 111
number1                         000122 automatic       fixed bin(35,0)          dcl 14 set ref 202* 207 208* 208 211 213* 217
offset                    1            based           bit(18)                  level 2 packed unaligned dcl 59 ref 300 300
p                               000102 automatic       pointer                  dcl 14 set ref 113* 123 126 136 140 143 149 277 283
                                                                                  290 293 298 298 300 300 303 305 305 314 320 331
                                                                                  340
packed                          000106 automatic       bit(1)                   dcl 14 set ref 112*
pointer                                based           structure                level 1 dcl 59
proc_name                       000010 internal static char(12)                 initial dcl 76 set ref 104* 346*
ptr                       2            based           pointer                  array level 2 dcl 55 ref 113
scale                           000111 automatic       fixed bin(15,0)          dcl 14 set ref 112*
segno                                  based           bit(18)                  level 2 packed unaligned dcl 59 ref 298 298
single_p                        000200 automatic       bit(1)                   dcl 14 set ref 135* 139* 193
size                            000110 automatic       fixed bin(35,0)          dcl 14 set ref 112* 274* 274 277 283 285 287 292 316
                                                                                  333
sp                              000100 automatic       pointer                  dcl 14 set ref 100* 102 108 112* 113
string                          000215 automatic       varying char(132)        dcl 72 set ref 109* 350 352 352 352 352 353* 356*
                                                                                  356 363* 363 366 366 366 366
string_no_descrip               000013 internal static char(80)                 initial dcl 77 set ref 104*
substr                                                 builtin function         dcl 89 set ref 143 149 186 188 197 223 241* 253* 256
                                                                                  257 259* 264* 277 283 290 293 320 340
substring                       000257 automatic       varying char(132)        dcl 72 set ref 123* 126* 145* 149* 151* 217* 217
                                                                                  256* 256 257 259* 265* 265 293* 299* 301* 301 306*
                                                                                  306 317* 320* 320 322* 322 325* 325 337* 340* 347*
                                                                                  350 353 356
suffix                          000212 automatic       char(4)                  dcl 66 set ref 179* 181* 264* 265
temp_string                     000321 automatic       char(21)                 dcl 72 set ref 241* 253* 256
type                            000120 automatic       fixed bin(15,0)          dcl 14 set ref 112* 123 126 130 133 271 271 275 296
                                                                                  312 312 314 329 329 331 346*
unspec                                                 builtin function         dcl 89 ref 278
upper                           000134 automatic       fixed bin(35,0)          dcl 14 set ref 231* 232 234 235 236 243* 247
upper_quotient                  000135 automatic       fixed bin(35,0)          dcl 14 set ref 235* 236 243
upper_remainder                 000136 automatic       fixed bin(35,0)          dcl 14 set ref 236* 238
x                               000176 automatic       float bin(63)            dcl 14 set ref 132* 136* 140* 153* 153 157 159 160*
                                                                                  160 163 164* 164 169 170* 170 173 174* 174 185
xptr                            000104 automatic       pointer                  dcl 14 set ref 185* 186 188

NAMES DECLARED BY EXPLICIT CONTEXT.
end_float                       001540 constant        label                    dcl 266 ref 146
nnl                             000365 constant        entry                    external dcl 97
start                           000374 constant        label                    dcl 100 ref 95
write_list_                     000353 constant        entry                    external dcl 12

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2612        2672    2461        2622
Length      3114    2461        60         206     131          30

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
write_list_                         324 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 proc_name                   write_list_
000013 string_no_descrip           write_list_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
write_list_              000100 sp                          write_list_
                         000102 p                           write_list_
                         000104 xptr                        write_list_
                         000106 packed                      write_list_
                         000107 ndims                       write_list_
                         000110 size                        write_list_
                         000111 scale                       write_list_
                         000112 i                           write_list_
                         000113 j                           write_list_
                         000114 jj                          write_list_
                         000115 l                           write_list_
                         000116 bin_exp                     write_list_
                         000117 no_of_arg                   write_list_
                         000120 type                        write_list_
                         000121 exponent                    write_list_
                         000122 number1                     write_list_
                         000124 int2                        write_list_
                         000126 int_temp                    write_list_
                         000130 fractional                  write_list_
                         000132 fractional2                 write_list_
                         000134 upper                       write_list_
                         000135 upper_quotient              write_list_
                         000136 upper_remainder             write_list_
                         000140 lower                       write_list_
                         000142 lower_quotient              write_list_
                         000144 d                           write_list_
                         000176 x                           write_list_
                         000200 single_p                    write_list_
                         000202 dec_bit72                   write_list_
                         000204 cv_chars                    write_list_
                         000211 ch                          write_list_
                         000212 suffix                      write_list_
                         000213 nl_is_required              write_list_
                         000214 nl                          write_list_
                         000215 string                      write_list_
                         000257 substring                   write_list_
                         000321 temp_string                 write_list_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              mpfx2
mod_fx1             shorten_stack       ext_entry           real_to_real_rd     divide_fx3          real_p_real

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_binary_integer_$decimal_string
convert_binary_integer_$long_decimal_string                 convert_binary_integer_$octal_string
cu_$arg_list_ptr              decimal_exp_                  decode_descriptor_            ios_$write_ptr

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     69 000346        12 000352        94 000361        95 000363        97 000364        98 000373       100 000374
    102 000403       104 000407       105 000431       108 000432       109 000436       111 000437       112 000445
    113 000470       123 000475       126 000533       130 000571       132 000574       133 000576       135 000601
    136 000603       137 000605       139 000606       140 000607       143 000611       145 000614       146 000621
    149 000622       151 000632       153 000636       155 000642       157 000643       159 000646       160 000651
    161 000711       162 000713       163 000714       164 000717       165 000757       166 000760       167 000761
    169 000762       170 000765       171 001021       172 001023       173 001024       174 001027       175 001063
    176 001065       179 001066       181 001073       183 001075       185 001102       186 001104       188 001107
    190 001113       193 001117       195 001121       196 001122       197 001127       199 001141       200 001143
    202 001150       206 001157       207 001164       208 001171       209 001174       211 001176       213 001201
    214 001203       217 001204       219 001314       221 001315       222 001317       223 001324       225 001336
    227 001340       231 001347       232 001351       234 001356       235 001363       236 001365       238 001371
    239 001375       240 001401       241 001410       243 001416       244 001420       245 001422       247 001424
    249 001430       250 001435       251 001442       252 001451       253 001453       254 001461       256 001463
    257 001475       259 001501       260 001504       264 001505       265 001526       266 001540       271 001541
    273 001545       274 001546       275 001552       277 001555       278 001562       279 001565       280 001571
    281 001611       282 001632       283 001633       284 001647       285 001651       287 001661       288 001663
    290 001664       291 001671       292 001676       293 001705       294 001745       296 001747       298 001751
    299 001765       300 002017       301 002035       303 002047       305 002054       306 002074       307 002140
    309 002141       312 002142       314 002146       316 002155       317 002157       319 002163       320 002172
    322 002207       323 002216       325 002220       326 002232       329 002233       331 002237       333 002246
    335 002250       337 002251       338 002255       340 002256       341 002276       342 002277       346 002300
    347 002334       350 002340       352 002345       353 002365       354 002372       356 002373       359 002405
    361 002407       363 002411       366 002420       368 002442


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
