	COMPILATION LISTING OF SEGMENT rlm_destroy_index
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1617.2 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*         This  routine destroys an index in a relation.  The relation must be
       10*     open.
       11**/
       12 
       13 /* HISTORY:
       14*Written by Matthew Pierret, 03/28/83.
       15*Modified:
       16*06/21/84 by Matthew Pierret: Added prefices to variables local to
       17*            CHECK_VERSION and CHECK_VERSION_CHAR_8. Declared hbound.
       18**/
       19 /* format: style2,ind3 */
       20 
       21 /* format: style2,ind3 */
       22 
       23 rlm_destroy_index:
       24    proc (p_rel_opening_id, p_index_collection_id, p_code);
       25 
       26 
       27 /* START OF DECLARATIONS */
       28 /* Parameter */
       29 
       30       dcl	    p_index_cursor_ptr     ptr parameter;
       31       dcl	    p_rel_opening_id       bit (36) aligned parameter;
       32       dcl	    p_index_collection_id  bit (36) aligned parameter;
       33       dcl	    p_code	       fixed bin (35) parameter;
       34 
       35 /* Automatic */
       36 
       37       dcl	    (file_opening_id, index_collection_id)
       38 			       bit (36) aligned;
       39       dcl	    index_idx	       fixed bin (17);
       40 
       41 /* Based */
       42 /* Builtin */
       43 
       44       dcl	    (hbound, null)	       builtin;
       45 
       46 /* Constant */
       47 
       48       dcl	    myname	       init ("rlm_destroy_index") char (32) varying internal static options (constant);
       49 
       50 /* Entry */
       51 
       52       dcl	    index_manager_$destroy_index
       53 			       entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
       54       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
       55       dcl	    rlm_update_opening_info$index_attribute_map
       56 			       entry (ptr, ptr, fixed bin (35));
       57       dcl	    sub_err_	       entry () options (variable);
       58 
       59 /* External */
       60 
       61       dcl	    (
       62 	    dm_error_$index_not_in_relation,
       63 	    dm_error_$wrong_cursor_type,
       64 	    error_table_$unimplemented_version
       65 	    )		       fixed bin (35) ext;
       66 
       67 /* END OF DECLARATIONS */
       68 
       69 /* format: ^indblkcom,indcomtxt */
       70 
       71       file_opening_id = p_rel_opening_id;
       72       index_collection_id = p_index_collection_id;
       73       goto JOIN;
       74 
       75 by_cursor:
       76    entry (p_index_cursor_ptr, p_code);
       77 
       78       index_cursor_ptr = p_index_cursor_ptr;
       79       if index_cursor.type ^= INDEX_CURSOR_TYPE
       80       then call
       81 	    sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
       82 	    "^/Expected an index cursor, type ^d.  Received type ^d.", INDEX_CURSOR_TYPE, index_cursor.type);
       83       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
       84 
       85       file_opening_id = index_cursor.file_opening_id;
       86       index_collection_id = index_cursor.collection_id;
       87       goto JOIN;
       88 
       89 JOIN:
       90       p_code = 0;
       91       relation_opening_info_ptr = null;
       92 
       93       call rlm_opening_info$get (file_opening_id, relation_opening_info_ptr, p_code);
       94       if p_code ^= 0
       95       then return;
       96 
       97       call CHECK_VERSION_CHAR_8 (relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2, "relation_opening_info");
       98       index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
       99       call CHECK_VERSION_CHAR_8 (index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2, "index_attribute_map");
      100 
      101       do index_idx = 1 to hbound (index_attribute_map.index, 1)
      102          while (index_attribute_map.index (index_idx).collection_id ^= index_collection_id);
      103       end;
      104       if index_idx > hbound (index_attribute_map.index, 1)
      105       then p_code = dm_error_$index_not_in_relation;
      106       else
      107          do;
      108 	  index_attribute_map.index (index_idx).number_of_attributes = 0;
      109 	  index_attribute_map.number_of_indices = index_attribute_map.number_of_indices - 1;
      110 
      111 	  call rlm_update_opening_info$index_attribute_map (relation_opening_info_ptr, index_attribute_map_ptr, p_code);
      112 	  if p_code ^= 0
      113 	  then return;
      114 
      115 	  call index_manager_$destroy_index (file_opening_id, index_collection_id, p_code);
      116 	  if p_code ^= 0
      117 	  then return;
      118          end;
      119 
      120       return;
      121 
      122 CHECK_VERSION:
      123    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      124       dcl	    cv_p_received_version  fixed bin (35);
      125       dcl	    cv_p_expected_version  fixed bin (35);
      126       dcl	    cv_p_structure_name    char (*);
      127       if cv_p_received_version ^= cv_p_expected_version
      128       then call
      129 	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      130 	    "^/Expected version ^d of the ^a structure.
      131 Received version ^d instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      132    end CHECK_VERSION;
      133 
      134 
      135 
      136 CHECK_VERSION_CHAR_8:
      137    proc (cvc8_p_received_version, cvc8_p_expected_version, cvc8_p_structure_name);
      138       dcl	    cvc8_p_received_version
      139 			       char (8) aligned;
      140       dcl	    cvc8_p_expected_version
      141 			       char (8) aligned;
      142       dcl	    cvc8_p_structure_name  char (*);
      143       if cvc8_p_received_version ^= cvc8_p_expected_version
      144       then call
      145 	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      146 	    "^/Expected version ^8a of the ^a structure.
      147 Received version ^8a instead.", cvc8_p_expected_version, cvc8_p_structure_name, cvc8_p_received_version);
      148    end CHECK_VERSION_CHAR_8;
      149 
  1     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  1     2 
  1     3 /* Written by Matthew Pierret, 09/08/82. 
  1     4*Modified:
  1     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  1     6*            transaction_id.
  1     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  1     8*            relation_info).
  1     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    10**/
  1    11 
  1    12 
  1    13 /* format: style2,ind3 */
  1    14 
  1    15      dcl	   1 relation_opening_info
  1    16 			      aligned based (relation_opening_info_ptr),
  1    17 	     2 version	      char (8),
  1    18 	     2 per_process,
  1    19 	       3 current_transaction_id
  1    20 			      bit (36) aligned init ("0"b),
  1    21 	       3 current_rollback_count
  1    22 			      fixed bin (35) init (0),
  1    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  1    24 	       3 number_of_openings
  1    25 			      fixed bin (17) aligned init (0),
  1    26 	       3 lock_advice      aligned,
  1    27 	         4 this_process   bit (2) unaligned init ("0"b),
  1    28 	         4 other_processes
  1    29 			      bit (2) unaligned init ("0"b),
  1    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  1    31 	       3 record_cursor_ptr
  1    32 			      ptr init (null),
  1    33 	       3 index_cursor_array_ptr
  1    34 			      ptr init (null),
  1    35 	     2 relation_header_ptr
  1    36 			      ptr init (null),
  1    37 	     2 attribute_info_ptr ptr init (null),
  1    38 	     2 index_attribute_map_ptr
  1    39 			      ptr init (null);
  1    40 
  1    41      dcl	   relation_opening_info_ptr
  1    42 			      ptr;
  1    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  1    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  1    45 
  1    46 
  1    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      150 
      151 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION
  2     4*        
  2     5*   Relation index components.  This info is kept in the header
  2     6*   collection of existing files, therefore this incl should not be changed.
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*Written by Matthew Pierret, 01/15/83.
  2    11*Modified:
  2    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  2    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  2    14*   which were incompatible with existing DM files.        
  2    15**/
  2    16 
  2    17 /* format: style2,ind3 */
  2    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  2    19 	     2 version	      char (8),
  2    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  2    21 	     2 maximum_number_of_indices
  2    22 			      fixed bin (17) unal,
  2    23 	     2 maximum_number_of_attributes_per_index
  2    24 			      fixed bin (17) unal,
  2    25 	     2 mbz	      fixed bin (17) unal,
  2    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  2    27 	       3 collection_id    bit (36) aligned,
  2    28 	       3 style	      fixed bin (17) unal,
  2    29 	       3 number_of_duplication_fields
  2    30 			      fixed bin (17) unal,
  2    31 	       3 number_of_attributes
  2    32 			      fixed bin (17) unal,
  2    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  2    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  2    35 			      bin (17) unal;
  2    36 
  2    37      dcl	   index_attribute_map_ptr
  2    38 			      ptr init (null);
  2    39      dcl	   iam_maximum_number_of_indices
  2    40 			      fixed bin (17);
  2    41      dcl	   iam_maximum_number_of_attributes_per_index
  2    42 			      fixed bin (17);
  2    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  2    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  2    45      dcl	   INITIAL_NUMBER_OF_INDICES
  2    46 			      init (5) fixed bin (17);
  2    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  2    48 			      init (0) fixed bin (17);
  2    49 
  2    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      152 
      153 
  3     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          This structure specifies a DM file, an index collection in that DM
  3     6*file, and a position (key) in that index collection.
  3     7*
  3     8**/
  3     9 
  3    10 /* HISTORY:
  3    11*
  3    12*Written by Lindsey Spratt, 03/29/82
  3    13*Modified:
  3    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  3    15*            "bit (35) aligned".
  3    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  3    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  3    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  3    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  3    20*	  which is a unique number used by hash_index_ to develop the
  3    21*	  key_check_value.
  3    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  3    23*	  cursor.  Also, implemented the ability to have the cursor
  3    24*	  positioned before or after the index.  
  3    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3 */
  3    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  3    30 	     2 type	      fixed bin (17) unaligned,
  3    31 	     2 version	      fixed bin (17) unaligned,
  3    32 	     2 file_opening_id    bit (36) aligned,
  3    33 	     2 collection_id      bit (36) aligned,
  3    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  3    35 						/* if flags.current_key_exists is on. Is the location */
  3    36 						/* of the end of the index if flags.is_at_end_of_index */
  3    37 						/* is on, which is only available via an operation */
  3    38 						/* requiring the "previous" key.  Is the location of */
  3    39 						/* the "next" key, otherwise. */
  3    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  3    41 						/* Must be a freeing area. */
  3    42 	     2 current_key_string_ptr
  3    43 			      ptr,		/* Points to the value of the current key. */
  3    44 	     2 current_key_string_length
  3    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  3    46 	     2 pad	      bit (12) unal,
  3    47 	     2 flags	      aligned,
  3    48 	       3 is_at_beginning_of_index
  3    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  3    50 	       3 is_at_end_of_index
  3    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  3    52 	       3 current_key_exists
  3    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  3    54 						/* by the key_id_string.  If off, the "current" position */
  3    55 						/* is undefined, and the key_id_string identifies the */
  3    56 						/* previous or next key, depending on whether */
  3    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  3    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  3    59 						/* setting the cursor position and the cursor is not */
  3    60 						/* to be trusted for relative position operations. */
  3    61 	       3 pad	      bit (32) unal;
  3    62 
  3    63 
  3    64      dcl	   index_cursor_ptr	      ptr;
  3    65 
  3    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  3    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  3    68 
  3    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      154 
      155 
  4     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  4     2 /* format: style3 */
  4     3 
  4     4 /* These constants are to be used for the flags argument of sub_err_ */
  4     5 /* They are just "string (condition_info_header.action_flags)" */
  4     6 
  4     7 declare	(
  4     8 	ACTION_CAN_RESTART	init (""b),
  4     9 	ACTION_CANT_RESTART init ("1"b),
  4    10 	ACTION_DEFAULT_RESTART
  4    11 			init ("01"b),
  4    12 	ACTION_QUIET_RESTART
  4    13 			init ("001"b),
  4    14 	ACTION_SUPPORT_SIGNAL
  4    15 			init ("0001"b)
  4    16 	)		bit (36) aligned internal static options (constant);
  4    17 
  4    18 /* End include file */
      156 
      157    end rlm_destroy_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1147.5  rlm_destroy_index.pl1             >spec>temp>famis1>rlm_destroy_index.pl1
150          1    01/03/85  1004.6  dm_rlm_opening_info.incl.pl1      >spec>temp>famis1>dm_rlm_opening_info.incl.pl1
152          2    01/03/85  1005.7  dm_rlm_index_attr_map.incl.pl1    >spec>temp>famis1>dm_rlm_index_attr_map.incl.pl1
154          3    01/03/85  1003.5  dm_im_cursor.incl.pl1             >spec>temp>famis1>dm_im_cursor.incl.pl1
156          4    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 4-7 set ref 79* 127* 143*
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 2-43 set ref 99*
INDEX_CURSOR_TYPE               000034 constant        fixed bin(17,0)          initial dcl 3-67 set ref 79 79*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 3-66 ref 83
INITIAL_NUMBER_OF_INDICES       000110 automatic       fixed bin(17,0)          initial dcl 2-45 set ref 2-45*
RELATION_OPENING_INFO_VERSION_2 000004 constant        char(8)                  initial dcl 1-43 set ref 97*
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000111 automatic       fixed bin(17,0)          initial dcl 2-47 set ref 2-47*
collection_id             4            based           bit(36)                  array level 3 in structure "index_attribute_map"
                                                                                  dcl 2-18 in procedure "rlm_destroy_index" ref 101
collection_id             2            based           bit(36)                  level 2 in structure "index_cursor" dcl 3-29
                                                                                  in procedure "rlm_destroy_index" ref 86
cv_p_expected_version                  parameter       fixed bin(35,0)          dcl 125 set ref 122 127 127*
cv_p_received_version                  parameter       fixed bin(35,0)          dcl 124 set ref 122 127 127*
cv_p_structure_name                    parameter       char                     unaligned dcl 126 set ref 122 127*
cvc8_p_expected_version                parameter       char(8)                  dcl 140 set ref 136 143 143*
cvc8_p_received_version                parameter       char(8)                  dcl 138 set ref 136 143 143*
cvc8_p_structure_name                  parameter       char                     unaligned dcl 142 set ref 136 143*
dm_error_$index_not_in_relation 000020 external static fixed bin(35,0)          dcl 61 ref 104
dm_error_$wrong_cursor_type     000022 external static fixed bin(35,0)          dcl 61 set ref 79*
error_table_$unimplemented_version
                                000024 external static fixed bin(35,0)          dcl 61 set ref 127* 143*
file_opening_id                 000100 automatic       bit(36)                  dcl 37 in procedure "rlm_destroy_index" set ref 71*
                                                                                  85* 93* 115*
file_opening_id           1            based           bit(36)                  level 2 in structure "index_cursor" dcl 3-29
                                                                                  in procedure "rlm_destroy_index" ref 85
hbound                                                 builtin function         dcl 44 ref 101 104
index                     4            based           structure                array level 2 dcl 2-18 set ref 101 104
index_attribute_map                    based           structure                level 1 dcl 2-18
index_attribute_map_ptr         000106 automatic       pointer                  initial dcl 2-37 in procedure "rlm_destroy_index"
                                                                                  set ref 98* 99 101 101 104 108 109 109 111* 2-37*
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_destroy_index" ref 98
index_collection_id             000101 automatic       bit(36)                  dcl 37 set ref 72* 86* 101 115*
index_cursor                           based           structure                level 1 unaligned dcl 3-29
index_cursor_ptr                000112 automatic       pointer                  dcl 3-64 set ref 78* 79 79 83 85 86
index_idx                       000102 automatic       fixed bin(17,0)          dcl 39 set ref 101* 101* 104 108
index_manager_$destroy_index    000010 constant        entry                    external dcl 52 ref 115
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-18 ref 101 101 108
                                                                                  108
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-18 ref 101 104
myname                          000006 constant        varying char(32)         initial dcl 48 set ref 79* 127* 143*
null                                                   builtin function         dcl 44 ref 79 79 91 2-37 127 127 143 143
number_of_attributes      6            based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-18 set ref 108*
number_of_indices         2            based           fixed bin(17,0)          initial level 2 packed unaligned dcl 2-18 set ref
                                                                                  109* 109
p_code                                 parameter       fixed bin(35,0)          dcl 33 set ref 23 75 89* 93* 94 104* 111* 112 115*
                                                                                  116
p_index_collection_id                  parameter       bit(36)                  dcl 32 ref 23 72
p_index_cursor_ptr                     parameter       pointer                  dcl 30 ref 75 78
p_rel_opening_id                       parameter       bit(36)                  dcl 31 ref 23 71
relation_opening_info                  based           structure                level 1 dcl 1-15
relation_opening_info_ptr       000104 automatic       pointer                  dcl 1-41 set ref 91* 93* 97 98 111*
rlm_opening_info$get            000012 constant        entry                    external dcl 54 ref 93
rlm_update_opening_info$index_attribute_map
                                000014 constant        entry                    external dcl 55 ref 111
sub_err_                        000016 constant        entry                    external dcl 57 ref 79 127 143
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 3-29 set ref 79 79*
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_destroy_index" set ref
                                                                                  97*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 3-29 in procedure "rlm_destroy_index" ref 83
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 2-18
                                                                                  in procedure "rlm_destroy_index" set ref 99*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 2-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 2-39

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000534 constant        entry                    internal dcl 122 ref 83
CHECK_VERSION_CHAR_8            000630 constant        entry                    internal dcl 136 ref 97 99
JOIN                            000321 constant        label                    dcl 89 set ref 73 87
by_cursor                       000202 constant        entry                    external dcl 75
rlm_destroy_index               000157 constant        entry                    external dcl 23

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1116        1144     750        1126
Length      1424     750        26         243     145           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_destroy_index                   268 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_destroy_index.  
CHECK_VERSION_CHAR_8                    internal procedure  shares stack frame of external procedure rlm_destroy_index.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_destroy_index        000100 file_opening_id             rlm_destroy_index
                         000101 index_collection_id         rlm_destroy_index
                         000102 index_idx                   rlm_destroy_index
                         000104 relation_opening_info_ptr   rlm_destroy_index
                         000106 index_attribute_map_ptr     rlm_destroy_index
                         000110 INITIAL_NUMBER_OF_INDICES   rlm_destroy_index
                         000111 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_destroy_index
                         000112 index_cursor_ptr            rlm_destroy_index

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
index_manager_$destroy_index  rlm_opening_info$get          rlm_update_opening_info$index_attribute_map
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$index_not_in_relation                             dm_error_$wrong_cursor_type
error_table_$unimplemented_version


CONSTANTS
000732  aa     000006000000
000733  aa     000006000000
000734  aa     600000000041
000735  aa     000135000000
000736  aa     600000000041
000737  aa     000220000000
000740  aa     600000000041
000741  aa     000140000000
000742  ta     000033000000
000743  aa     000000000000
000744  ta     000033000000
000745  aa     000000000000
000746  ta     000025000000
000747  aa     000000000000

000000  aa     400000000000

000002  aa  151 144 170 137	idx_
000003  aa  155 141 160 062	map2

000004  aa  162 154 155 157	rlmo
000005  aa  160 145 156 062	pen2

000006  aa     000000000021
000007  aa  162 154 155 137	rlm_
000010  aa  144 145 163 164	dest
000011  aa  162 157 171 137	roy_
000012  aa  151 156 144 145	inde
000013  aa  170 040 040 040	x   
000014  aa  040 040 040 040	    
000015  aa  040 040 040 040	    
000016  aa  040 040 040 040	    

000017  aa     524000000111

000020  aa     524000000107

000021  aa     526077777777

000022  aa     524000000023

000023  aa     524000000025

000024  aa     524000000010

000025  aa     524000000014

000026  aa     406000000021

000027  aa     404000000021

000030  aa     524000000067

000031  aa     404000000005

000032  aa     530000000040

000033  aa     404000000043

000034  aa     000000000002

000035  aa     514000000044

000036  aa     464000000000

000040  aa     077777000043
000041  aa     000001000000

000042  aa  151 156 144 145	inde
000043  aa  170 137 143 165	x_cu
000044  aa  162 163 157 162	rsor

000045  aa  151 156 144 145	inde
000046  aa  170 137 141 164	x_at
000047  aa  164 162 151 142	trib
000050  aa  165 164 145 137	ute_
000051  aa  155 141 160 000	map

000052  aa  162 145 154 141	rela
000053  aa  164 151 157 156	tion
000054  aa  137 157 160 145	_ope
000055  aa  156 151 156 147	ning
000056  aa  137 151 156 146	_inf
000057  aa  157 000 000 000	o

000060  aa  136 057 105 170	^/Ex
000061  aa  160 145 143 164	pect
000062  aa  145 144 040 141	ed a
000063  aa  156 040 151 156	n in
000064  aa  144 145 170 040	dex 
000065  aa  143 165 162 163	curs
000066  aa  157 162 054 040	or, 
000067  aa  164 171 160 145	type
000070  aa  040 136 144 056	 ^d.
000071  aa  040 040 122 145	  Re
000072  aa  143 145 151 166	ceiv
000073  aa  145 144 040 164	ed t
000074  aa  171 160 145 040	ype 
000075  aa  136 144 056 000	^d.

000076  aa  136 057 105 170	^/Ex
000077  aa  160 145 143 164	pect
000100  aa  145 144 040 166	ed v
000101  aa  145 162 163 151	ersi
000102  aa  157 156 040 136	on ^
000103  aa  144 040 157 146	d of
000104  aa  040 164 150 145	 the
000105  aa  040 136 141 040	 ^a 
000106  aa  163 164 162 165	stru
000107  aa  143 164 165 162	ctur
000110  aa  145 056 012 122	e.
R
000111  aa  145 143 145 151	ecei
000112  aa  166 145 144 040	ved 
000113  aa  166 145 162 163	vers
000114  aa  151 157 156 040	ion 
000115  aa  136 144 040 151	^d i
000116  aa  156 163 164 145	nste
000117  aa  141 144 056 000	ad.

000120  aa  136 057 105 170	^/Ex
000121  aa  160 145 143 164	pect
000122  aa  145 144 040 166	ed v
000123  aa  145 162 163 151	ersi
000124  aa  157 156 040 136	on ^
000125  aa  070 141 040 157	8a o
000126  aa  146 040 164 150	f th
000127  aa  145 040 136 141	e ^a
000130  aa  040 163 164 162	 str
000131  aa  165 143 164 165	uctu
000132  aa  162 145 056 012	re.

000133  aa  122 145 143 145	Rece
000134  aa  151 166 145 144	ived
000135  aa  040 166 145 162	 ver
000136  aa  163 151 157 156	sion
000137  aa  040 136 070 141	 ^8a
000140  aa  040 151 156 163	 ins
000141  aa  164 145 141 144	tead
000142  aa  056 000 000 000	.

BEGIN PROCEDURE rlm_destroy_index
PROLOGUE SEQUENCE
000143  aa  6 00134 4401 00	sxl0 	pr6|92
						STATEMENT 1 ON LINE 37 OF FILE 2
000144  aa   777674 2370 04	ldaq 	-68,ic		000040 = 077777000043 000001000000
000145  aa  6 00106 7571 00	staq 	pr6|70		index_attribute_map_ptr
						STATEMENT 1 ON LINE 45 OF FILE 2
000146  aa   000005 2360 07	ldq  	5,dl
000147  aa  6 00110 7561 00	stq  	pr6|72		INITIAL_NUMBER_OF_INDICES
						STATEMENT 1 ON LINE 47 OF FILE 2
000150  aa  6 00111 4501 00	stz  	pr6|73		UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
000151  aa  6 00134 7201 00	lxl0 	pr6|92
000152  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO rlm_destroy_index                                  STATEMENT 1 ON LINE 23
rlm_destroy_index:
   proc (p_rel_opening_id, p_index_collection_id, p_code);

000153  at     000003000035
000154  tt     000035000033
000155  ta     000153000000
000156  da     000133300000
000157  aa   000420 6270 00	eax7 	272
000160  aa  7 00034 3521 20	epp2 	pr7|28,*
000161  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000162  aa     000006000000
000163  aa     000000000000
000164  aa  6 00032 3735 20	epp7 	pr6|26,*
000165  aa  7 00006 3715 20	epp5 	pr7|6,*
000166  aa  6 00114 6515 00	spri5	pr6|76
000167  aa   777754 7000 04	tsx0 	-20,ic		000143
						STATEMENT 1 ON LINE 71
      file_opening_id = p_rel_opening_id;

000170  aa  6 00032 3735 20	epp7 	pr6|26,*
000171  aa  7 00002 2351 20	lda  	pr7|2,*		p_rel_opening_id
000172  aa  6 00100 7551 00	sta  	pr6|64		file_opening_id
						STATEMENT 1 ON LINE 72
      index_collection_id = p_index_collection_id;

000173  aa  7 00004 2351 20	lda  	pr7|4,*		p_index_collection_id
000174  aa  6 00101 7551 00	sta  	pr6|65		index_collection_id
						STATEMENT 1 ON LINE 73
      goto JOIN;

000175  aa   000124 7100 04	tra  	84,ic		000321
ENTRY TO by_cursor                                          STATEMENT 1 ON LINE 75
by_cursor:
   entry (p_index_cursor_ptr, p_code);

000176  at     000002000036
000177  ta     000033000000
000200  ta     000176000000
000201  da     000141300000
000202  aa   000420 6270 00	eax7 	272
000203  aa  7 00034 3521 20	epp2 	pr7|28,*
000204  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000205  aa     000004000000
000206  aa     000000000000
000207  aa  6 00032 3735 20	epp7 	pr6|26,*
000210  aa  7 00004 3715 20	epp5 	pr7|4,*
000211  aa  6 00114 6515 00	spri5	pr6|76
000212  aa   777731 7000 04	tsx0 	-39,ic		000143
						STATEMENT 1 ON LINE 78
      index_cursor_ptr = p_index_cursor_ptr;

000213  aa  6 00032 3735 20	epp7 	pr6|26,*
000214  aa  7 00002 3715 20	epp5 	pr7|2,*		p_index_cursor_ptr
000215  aa  5 00000 3715 20	epp5 	pr5|0,*		p_index_cursor_ptr
000216  aa  6 00112 6515 00	spri5	pr6|74		index_cursor_ptr
						STATEMENT 1 ON LINE 79
      if index_cursor.type ^= INDEX_CURSOR_TYPE
      then call
	    sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
	    "^/Expected an index cursor, type ^d.  Received type ^d.", INDEX_CURSOR_TYPE, index_cursor.type);

000217  aa  5 00000 2351 00	lda  	pr5|0		index_cursor.type
000220  aa   000066 7330 00	lrs  	54
000221  aa   000002 1160 07	cmpq 	2,dl
000222  aa   000054 6000 04	tze  	44,ic		000276
000223  aa   777615 3534 24	epp3 	-115,ic*
000224  aa  6 00136 2535 00	spri3	pr6|94
000225  aa  6 00135 4501 00	stz  	pr6|93
000226  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000227  aa   777632 00 0070	desc9a	-102,56		000060 = 136057105170
000230  aa  6 00140 00 0070	desc9a	pr6|96,56
000231  aa  6 00044 3701 20	epp4 	pr6|36,*
000232  la  4 00022 3521 20	epp2 	pr4|18,*		dm_error_$wrong_cursor_type
000233  aa  6 00160 2521 00	spri2	pr6|112
000234  aa   777553 3520 04	epp2 	-149,ic		000007 = 162154155137
000235  aa  6 00162 2521 00	spri2	pr6|114
000236  aa   777542 3520 04	epp2 	-158,ic		000000 = 400000000000
000237  aa  6 00164 2521 00	spri2	pr6|116
000240  aa  6 00136 3521 00	epp2 	pr6|94
000241  aa  6 00166 2521 00	spri2	pr6|118
000242  aa  6 00135 3521 00	epp2 	pr6|93
000243  aa  6 00170 2521 00	spri2	pr6|120
000244  aa  6 00140 3521 00	epp2 	pr6|96
000245  aa  6 00172 2521 00	spri2	pr6|122
000246  aa   777566 3520 04	epp2 	-138,ic		000034 = 000000000002
000247  aa  6 00174 2521 00	spri2	pr6|124
000250  aa  5 00000 3521 00	epp2 	pr5|0		index_cursor.type
000251  aa  6 00176 2521 00	spri2	pr6|126
000252  aa   777561 3520 04	epp2 	-143,ic		000033 = 404000000043
000253  aa  6 00200 2521 00	spri2	pr6|128
000254  aa   777556 3520 04	epp2 	-146,ic		000032 = 530000000040
000255  aa  6 00202 2521 00	spri2	pr6|130
000256  aa   777557 3520 04	epp2 	-145,ic		000035 = 514000000044
000257  aa  6 00204 2521 00	spri2	pr6|132
000260  aa   777556 3520 04	epp2 	-146,ic		000036 = 464000000000
000261  aa  6 00206 2521 00	spri2	pr6|134
000262  aa   777547 3520 04	epp2 	-153,ic		000031 = 404000000005
000263  aa  6 00210 2521 00	spri2	pr6|136
000264  aa   777544 3520 04	epp2 	-156,ic		000030 = 524000000067
000265  aa  6 00212 2521 00	spri2	pr6|138
000266  aa   777541 3520 04	epp2 	-159,ic		000027 = 404000000021
000267  aa  6 00214 2521 00	spri2	pr6|140
000270  aa   777536 3520 04	epp2 	-162,ic		000026 = 406000000021
000271  aa  6 00216 2521 00	spri2	pr6|142
000272  aa  6 00156 6211 00	eax1 	pr6|110
000273  aa   040000 4310 07	fld  	16384,dl
000274  la  4 00016 3521 20	epp2 	pr4|14,*		sub_err_
000275  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 83
      call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");

000276  aa  6 00112 2351 20	lda  	pr6|74,*		index_cursor.version
000277  aa   000022 7350 00	als  	18
000300  aa   000066 7330 00	lrs  	54
000301  aa  6 00135 7561 00	stq  	pr6|93
000302  aa   000003 2360 07	ldq  	3,dl
000303  aa  6 00220 7561 00	stq  	pr6|144
000304  aa   777536 2370 04	ldaq 	-162,ic		000042 = 151156144145 170137143165
000305  aa  6 00140 7571 00	staq 	pr6|96
000306  aa   777536 2350 04	lda  	-162,ic		000044 = 162163157162
000307  aa  6 00142 7551 00	sta  	pr6|98
000310  aa   000422 3520 04	epp2 	274,ic		000732 = 000006000000
000311  aa  2 00000 2351 00	lda  	pr2|0
000312  aa   000222 6700 04	tsp4 	146,ic		000534
						STATEMENT 1 ON LINE 85
      file_opening_id = index_cursor.file_opening_id;

000313  aa  6 00112 3735 20	epp7 	pr6|74,*		index_cursor_ptr
000314  aa  7 00001 2351 00	lda  	pr7|1		index_cursor.file_opening_id
000315  aa  6 00100 7551 00	sta  	pr6|64		file_opening_id
						STATEMENT 1 ON LINE 86
      index_collection_id = index_cursor.collection_id;

000316  aa  7 00002 2351 00	lda  	pr7|2		index_cursor.collection_id
000317  aa  6 00101 7551 00	sta  	pr6|65		index_collection_id
						STATEMENT 1 ON LINE 87
      goto JOIN;

000320  aa   000001 7100 04	tra  	1,ic		000321
						STATEMENT 1 ON LINE 89
JOIN:
      p_code = 0;

000321  aa  6 00114 4501 20	stz  	pr6|76,*		p_code
						STATEMENT 1 ON LINE 91
      relation_opening_info_ptr = null;

000322  aa   777516 2370 04	ldaq 	-178,ic		000040 = 077777000043 000001000000
000323  aa  6 00104 7571 00	staq 	pr6|68		relation_opening_info_ptr
						STATEMENT 1 ON LINE 93
      call rlm_opening_info$get (file_opening_id, relation_opening_info_ptr, p_code);

000324  aa  6 00100 3521 00	epp2 	pr6|64		file_opening_id
000325  aa  6 00142 2521 00	spri2	pr6|98
000326  aa  6 00104 3521 00	epp2 	pr6|68		relation_opening_info_ptr
000327  aa  6 00144 2521 00	spri2	pr6|100
000330  aa  6 00114 3521 20	epp2 	pr6|76,*		p_code
000331  aa  6 00146 2521 00	spri2	pr6|102
000332  aa  6 00140 6211 00	eax1 	pr6|96
000333  aa   014000 4310 07	fld  	6144,dl
000334  aa  6 00044 3701 20	epp4 	pr6|36,*
000335  la  4 00012 3521 20	epp2 	pr4|10,*		rlm_opening_info$get
000336  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 94
      if p_code ^= 0
      then return;

000337  aa  6 00114 2361 20	ldq  	pr6|76,*		p_code
000340  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 97
      call CHECK_VERSION_CHAR_8 (relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2, "relation_opening_info");

000341  aa   777511 2370 04	ldaq 	-183,ic		000052 = 162145154141 164151157156
000342  aa  6 00140 7571 00	staq 	pr6|96
000343  aa   777511 2370 04	ldaq 	-183,ic		000054 = 137157160145 156151156147
000344  aa  6 00142 7571 00	staq 	pr6|98
000345  aa   777511 2370 04	ldaq 	-183,ic		000056 = 137151156146 157000000000
000346  aa  6 00144 7571 00	staq 	pr6|100
000347  aa  6 00104 3521 20	epp2 	pr6|68,*		relation_opening_info.version
000350  aa  6 00160 2521 00	spri2	pr6|112
000351  aa   777433 3520 04	epp2 	-229,ic		000004 = 162154155157
000352  aa  6 00162 2521 00	spri2	pr6|114
000353  aa  6 00140 3521 00	epp2 	pr6|96
000354  aa  6 00164 2521 00	spri2	pr6|116
000355  aa   777447 3520 04	epp2 	-217,ic		000024 = 524000000010
000356  aa  6 00166 2521 00	spri2	pr6|118
000357  aa  6 00170 2521 00	spri2	pr6|120
000360  aa   777443 3520 04	epp2 	-221,ic		000023 = 524000000025
000361  aa  6 00172 2521 00	spri2	pr6|122
000362  aa  6 00156 3521 00	epp2 	pr6|110
000363  aa   014000 4310 07	fld  	6144,dl
000364  aa  2 00000 7571 00	staq 	pr2|0
000365  aa   000243 6700 04	tsp4 	163,ic		000630
						STATEMENT 1 ON LINE 98
      index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;

000366  aa  6 00104 3735 20	epp7 	pr6|68,*		relation_opening_info_ptr
000367  aa  7 00020 3735 20	epp7 	pr7|16,*		relation_opening_info.index_attribute_map_ptr
000370  aa  6 00106 6535 00	spri7	pr6|70		index_attribute_map_ptr
						STATEMENT 1 ON LINE 99
      call CHECK_VERSION_CHAR_8 (index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2, "index_attribute_map");

000371  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000372  aa   777454 00 0024	desc9a	-212,20		000045 = 151156144145
000373  aa  6 00140 00 0024	desc9a	pr6|96,20
000374  aa  7 00000 3521 00	epp2 	pr7|0		index_attribute_map.version
000375  aa  6 00160 2521 00	spri2	pr6|112
000376  aa   777404 3520 04	epp2 	-252,ic		000002 = 151144170137
000377  aa  6 00162 2521 00	spri2	pr6|114
000400  aa  6 00140 3521 00	epp2 	pr6|96
000401  aa  6 00164 2521 00	spri2	pr6|116
000402  aa   777422 3520 04	epp2 	-238,ic		000024 = 524000000010
000403  aa  6 00166 2521 00	spri2	pr6|118
000404  aa  6 00170 2521 00	spri2	pr6|120
000405  aa   777415 3520 04	epp2 	-243,ic		000022 = 524000000023
000406  aa  6 00172 2521 00	spri2	pr6|122
000407  aa  6 00156 3521 00	epp2 	pr6|110
000410  aa   014000 4310 07	fld  	6144,dl
000411  aa  2 00000 7571 00	staq 	pr2|0
000412  aa   000216 6700 04	tsp4 	142,ic		000630
						STATEMENT 1 ON LINE 101
      do index_idx = 1 to hbound (index_attribute_map.index, 1)
         while (index_attribute_map.index (index_idx).collection_id ^= index_collection_id);

000413  aa  6 00106 3735 20	epp7 	pr6|70,*		index_attribute_map_ptr
000414  aa  7 00002 2351 00	lda  	pr7|2		index_attribute_map.maximum_number_of_indices
000415  aa   000022 7350 00	als  	18
000416  aa   000066 7330 00	lrs  	54
000417  aa  6 00116 7561 00	stq  	pr6|78
000420  aa   000001 2360 07	ldq  	1,dl
000421  aa  6 00102 7561 00	stq  	pr6|66		index_idx
000422  aa  6 00102 2361 00	ldq  	pr6|66		index_idx
000423  aa  6 00116 1161 00	cmpq 	pr6|78
000424  aa   000021 6054 04	tpnz 	17,ic		000445
000425  aa  6 00106 3735 20	epp7 	pr6|70,*		index_attribute_map_ptr
000426  aa  7 00003 2351 00	lda  	pr7|3		index_attribute_map.maximum_number_of_attributes_per_index
000427  aa   000066 7330 00	lrs  	54
000430  aa   000022 4020 07	mpy  	18,dl
000431  aa   000132 0760 07	adq  	90,dl
000432  aa   000043 0760 07	adq  	35,dl
000433  aa   000044 5060 07	div  	36,dl
000434  aa  6 00220 7561 00	stq  	pr6|144
000435  aa  6 00102 2361 00	ldq  	pr6|66		index_idx
000436  aa   000001 1760 07	sbq  	1,dl
000437  aa  6 00220 4021 00	mpy  	pr6|144
000440  aa  7 00004 2351 06	lda  	pr7|4,ql		index_attribute_map.collection_id
000441  aa  6 00101 1151 00	cmpa 	pr6|65		index_collection_id
000442  aa   000003 6000 04	tze  	3,ic		000445
						STATEMENT 1 ON LINE 103
      end;

000443  aa  6 00102 0541 00	aos  	pr6|66		index_idx
000444  aa   777756 7100 04	tra  	-18,ic		000422
						STATEMENT 1 ON LINE 104
      if index_idx > hbound (index_attribute_map.index, 1)
      then p_code = dm_error_$index_not_in_relation;

000445  aa  6 00106 3735 20	epp7 	pr6|70,*		index_attribute_map_ptr
000446  aa  7 00002 2351 00	lda  	pr7|2		index_attribute_map.maximum_number_of_indices
000447  aa   000022 7350 00	als  	18
000450  aa   000066 7330 00	lrs  	54
000451  aa  6 00102 1161 00	cmpq 	pr6|66		index_idx
000452  aa   000005 6050 04	tpl  	5,ic		000457
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00020 2361 20	ldq  	pr4|16,*		dm_error_$index_not_in_relation
000455  aa  6 00114 7561 20	stq  	pr6|76,*		p_code
000456  aa   000055 7100 04	tra  	45,ic		000533
						STATEMENT 1 ON LINE 106
      else
         do;

						STATEMENT 1 ON LINE 108
	  index_attribute_map.index (index_idx).number_of_attributes = 0;

000457  aa  7 00003 2351 00	lda  	pr7|3		index_attribute_map.maximum_number_of_attributes_per_index
000460  aa   000066 7330 00	lrs  	54
000461  aa   000022 4020 07	mpy  	18,dl
000462  aa   000132 0760 07	adq  	90,dl
000463  aa   000043 0760 07	adq  	35,dl
000464  aa   000044 5060 07	div  	36,dl
000465  aa  6 00220 7561 00	stq  	pr6|144
000466  aa  6 00102 2361 00	ldq  	pr6|66		index_idx
000467  aa   000001 1760 07	sbq  	1,dl
000470  aa  6 00220 4021 00	mpy  	pr6|144
000471  aa   000000 2350 07	lda  	0,dl
000472  aa  7 00006 3715 06	epp5 	pr7|6,ql		index_attribute_map.number_of_attributes
000473  aa  5 00000 5511 60	stba 	pr5|0,60		index_attribute_map.number_of_attributes
						STATEMENT 1 ON LINE 109
	  index_attribute_map.number_of_indices = index_attribute_map.number_of_indices - 1;

000474  aa  7 00002 2351 00	lda  	pr7|2		index_attribute_map.number_of_indices
000475  aa   000066 7330 00	lrs  	54
000476  aa   000001 1760 07	sbq  	1,dl
000477  aa   000066 7370 00	lls  	54
000500  aa  7 00002 5511 60	stba 	pr7|2,60		index_attribute_map.number_of_indices
						STATEMENT 1 ON LINE 111
	  call rlm_update_opening_info$index_attribute_map (relation_opening_info_ptr, index_attribute_map_ptr, p_code);

000501  aa  6 00104 3521 00	epp2 	pr6|68		relation_opening_info_ptr
000502  aa  6 00142 2521 00	spri2	pr6|98
000503  aa  6 00106 3521 00	epp2 	pr6|70		index_attribute_map_ptr
000504  aa  6 00144 2521 00	spri2	pr6|100
000505  aa  6 00114 3521 20	epp2 	pr6|76,*		p_code
000506  aa  6 00146 2521 00	spri2	pr6|102
000507  aa  6 00140 6211 00	eax1 	pr6|96
000510  aa   014000 4310 07	fld  	6144,dl
000511  aa  6 00044 3701 20	epp4 	pr6|36,*
000512  la  4 00014 3521 20	epp2 	pr4|12,*		rlm_update_opening_info$index_attribute_map
000513  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 112
	  if p_code ^= 0
	  then return;

000514  aa  6 00114 2361 20	ldq  	pr6|76,*		p_code
000515  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 115
	  call index_manager_$destroy_index (file_opening_id, index_collection_id, p_code);

000516  aa  6 00100 3521 00	epp2 	pr6|64		file_opening_id
000517  aa  6 00142 2521 00	spri2	pr6|98
000520  aa  6 00101 3521 00	epp2 	pr6|65		index_collection_id
000521  aa  6 00144 2521 00	spri2	pr6|100
000522  aa  6 00114 3521 20	epp2 	pr6|76,*		p_code
000523  aa  6 00146 2521 00	spri2	pr6|102
000524  aa  6 00140 6211 00	eax1 	pr6|96
000525  aa   014000 4310 07	fld  	6144,dl
000526  aa  6 00044 3701 20	epp4 	pr6|36,*
000527  la  4 00010 3521 20	epp2 	pr4|8,*		index_manager_$destroy_index
000530  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 116
	  if p_code ^= 0
	  then return;

000531  aa  6 00114 2361 20	ldq  	pr6|76,*		p_code
000532  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 118
         end;

						STATEMENT 1 ON LINE 120
      return;

000533  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 157
   end rlm_destroy_index;

BEGIN PROCEDURE CHECK_VERSION
ENTRY TO CHECK_VERSION                                      STATEMENT 1 ON LINE 122
CHECK_VERSION:
   proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);

000534  aa  6 00120 6501 00	spri4	pr6|80
000535  aa  6 00122 2521 00	spri2	pr6|82
000536  aa  2 00002 3521 01	epp2 	pr2|2,au
000537  aa  6 00124 2521 00	spri2	pr6|84
000540  aa  2 00004 2361 20	ldq  	pr2|4,*
000541  aa   000002 6040 04	tmi  	2,ic		000543
000542  aa   777777 3760 07	anq  	262143,dl
000543  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000544  aa  6 00221 7561 00	stq  	pr6|145
						STATEMENT 1 ON LINE 127
      if cv_p_received_version ^= cv_p_expected_version
      then call
	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	    "^/Expected version ^d of the ^a structure.
Received version ^d instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);

000545  aa  6 00122 3735 20	epp7 	pr6|82,*
000546  aa  7 00002 2361 20	ldq  	pr7|2,*		cv_p_received_version
000547  aa  7 00004 1161 20	cmpq 	pr7|4,*		cv_p_expected_version
000550  aa   000057 6000 04	tze  	47,ic		000627
000551  aa   777267 3714 24	epp5 	-329,ic*
000552  aa  6 00222 6515 00	spri5	pr6|146
000553  aa  6 00224 4501 00	stz  	pr6|148
000554  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000555  aa   777322 00 0110	desc9a	-302,72		000076 = 136057105170
000556  aa  6 00226 00 0110	desc9a	pr6|150,72
000557  aa  6 00044 3701 20	epp4 	pr6|36,*
000560  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$unimplemented_version
000561  aa  6 00252 2521 00	spri2	pr6|170
000562  aa   777225 3520 04	epp2 	-363,ic		000007 = 162154155137
000563  aa  6 00254 2521 00	spri2	pr6|172
000564  aa   777214 3520 04	epp2 	-372,ic		000000 = 400000000000
000565  aa  6 00256 2521 00	spri2	pr6|174
000566  aa  6 00222 3521 00	epp2 	pr6|146
000567  aa  6 00260 2521 00	spri2	pr6|176
000570  aa  6 00224 3521 00	epp2 	pr6|148
000571  aa  6 00262 2521 00	spri2	pr6|178
000572  aa  6 00226 3521 00	epp2 	pr6|150
000573  aa  6 00264 2521 00	spri2	pr6|180
000574  aa  7 00004 3521 20	epp2 	pr7|4,*		cv_p_expected_version
000575  aa  6 00266 2521 00	spri2	pr6|182
000576  aa  7 00006 3521 20	epp2 	pr7|6,*		cv_p_structure_name
000577  aa  6 00270 2521 00	spri2	pr6|184
000600  aa  7 00002 3521 20	epp2 	pr7|2,*		cv_p_received_version
000601  aa  6 00272 2521 00	spri2	pr6|186
000602  aa   777231 3520 04	epp2 	-359,ic		000033 = 404000000043
000603  aa  6 00274 2521 00	spri2	pr6|188
000604  aa  6 00310 2521 00	spri2	pr6|200
000605  aa  6 00314 2521 00	spri2	pr6|204
000606  aa   777224 3520 04	epp2 	-364,ic		000032 = 530000000040
000607  aa  6 00276 2521 00	spri2	pr6|190
000610  aa   777225 3520 04	epp2 	-363,ic		000035 = 514000000044
000611  aa  6 00300 2521 00	spri2	pr6|192
000612  aa   777224 3520 04	epp2 	-364,ic		000036 = 464000000000
000613  aa  6 00302 2521 00	spri2	pr6|194
000614  aa   777215 3520 04	epp2 	-371,ic		000031 = 404000000005
000615  aa  6 00304 2521 00	spri2	pr6|196
000616  aa   777202 3520 04	epp2 	-382,ic		000020 = 524000000107
000617  aa  6 00306 2521 00	spri2	pr6|198
000620  aa  6 00124 3535 20	epp3 	pr6|84,*
000621  aa  3 00004 3521 20	epp2 	pr3|4,*
000622  aa  6 00312 2521 00	spri2	pr6|202
000623  aa  6 00250 6211 00	eax1 	pr6|168
000624  aa   044000 4310 07	fld  	18432,dl
000625  la  4 00016 3521 20	epp2 	pr4|14,*		sub_err_
000626  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 132
   end CHECK_VERSION;

000627  aa  6 00120 6101 00	rtcd 	pr6|80
  END PROCEDURE CHECK_VERSION
BEGIN PROCEDURE CHECK_VERSION_CHAR_8
ENTRY TO CHECK_VERSION_CHAR_8                               STATEMENT 1 ON LINE 136
CHECK_VERSION_CHAR_8:
   proc (cvc8_p_received_version, cvc8_p_expected_version, cvc8_p_structure_name);

000630  aa  6 00126 6501 00	spri4	pr6|86
000631  aa  6 00130 2521 00	spri2	pr6|88
000632  aa  2 00002 3521 01	epp2 	pr2|2,au
000633  aa  6 00132 2521 00	spri2	pr6|90
000634  aa  2 00004 2361 20	ldq  	pr2|4,*
000635  aa   000002 6040 04	tmi  	2,ic		000637
000636  aa   777777 3760 07	anq  	262143,dl
000637  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000640  aa  6 00316 7561 00	stq  	pr6|206
						STATEMENT 1 ON LINE 143
      if cvc8_p_received_version ^= cvc8_p_expected_version
      then call
	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	    "^/Expected version ^8a of the ^a structure.
Received version ^8a instead.", cvc8_p_expected_version, cvc8_p_structure_name, cvc8_p_received_version);

000641  aa  6 00130 3735 20	epp7 	pr6|88,*
000642  aa  7 00002 3715 20	epp5 	pr7|2,*
000643  aa  5 00000 2351 00	lda  	pr5|0		cvc8_p_received_version
000644  aa  5 00001 2361 00	ldq  	pr5|1		cvc8_p_received_version
000645  aa  7 00004 3535 20	epp3 	pr7|4,*
000646  aa  3 00000 1151 00	cmpa 	pr3|0		cvc8_p_expected_version
000647  aa   000002 6010 04	tnz  	2,ic		000651
000650  aa  3 00001 1161 00	cmpq 	pr3|1		cvc8_p_expected_version
000651  aa   000060 6000 04	tze  	48,ic		000731
000652  aa   777166 3514 24	epp1 	-394,ic*
000653  aa  6 00320 2515 00	spri1	pr6|208
000654  aa  6 00317 4501 00	stz  	pr6|207
000655  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000656  aa   777243 00 0114	desc9a	-349,76		000120 = 136057105170
000657  aa  6 00322 00 0114	desc9a	pr6|210,76
000660  aa  6 00044 3701 20	epp4 	pr6|36,*
000661  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$unimplemented_version
000662  aa  6 00350 2521 00	spri2	pr6|232
000663  aa   777124 3520 04	epp2 	-428,ic		000007 = 162154155137
000664  aa  6 00352 2521 00	spri2	pr6|234
000665  aa   777113 3520 04	epp2 	-437,ic		000000 = 400000000000
000666  aa  6 00354 2521 00	spri2	pr6|236
000667  aa  6 00320 3521 00	epp2 	pr6|208
000670  aa  6 00356 2521 00	spri2	pr6|238
000671  aa  6 00317 3521 00	epp2 	pr6|207
000672  aa  6 00360 2521 00	spri2	pr6|240
000673  aa  6 00322 3521 00	epp2 	pr6|210
000674  aa  6 00362 2521 00	spri2	pr6|242
000675  aa  7 00004 3521 20	epp2 	pr7|4,*		cvc8_p_expected_version
000676  aa  6 00364 2521 00	spri2	pr6|244
000677  aa  7 00006 3521 20	epp2 	pr7|6,*		cvc8_p_structure_name
000700  aa  6 00366 2521 00	spri2	pr6|246
000701  aa  7 00002 3521 20	epp2 	pr7|2,*		cvc8_p_received_version
000702  aa  6 00370 2521 00	spri2	pr6|248
000703  aa   777130 3520 04	epp2 	-424,ic		000033 = 404000000043
000704  aa  6 00372 2521 00	spri2	pr6|250
000705  aa   777125 3520 04	epp2 	-427,ic		000032 = 530000000040
000706  aa  6 00374 2521 00	spri2	pr6|252
000707  aa   777126 3520 04	epp2 	-426,ic		000035 = 514000000044
000710  aa  6 00376 2521 00	spri2	pr6|254
000711  aa   777125 3520 04	epp2 	-427,ic		000036 = 464000000000
000712  aa  6 00400 2521 00	spri2	pr6|256
000713  aa   777116 3520 04	epp2 	-434,ic		000031 = 404000000005
000714  aa  6 00402 2521 00	spri2	pr6|258
000715  aa   777102 3520 04	epp2 	-446,ic		000017 = 524000000111
000716  aa  6 00404 2521 00	spri2	pr6|260
000717  aa   777105 3520 04	epp2 	-443,ic		000024 = 524000000010
000720  aa  6 00406 2521 00	spri2	pr6|262
000721  aa  6 00412 2521 00	spri2	pr6|266
000722  aa  6 00132 3715 20	epp5 	pr6|90,*
000723  aa  5 00004 3521 20	epp2 	pr5|4,*
000724  aa  6 00410 2521 00	spri2	pr6|264
000725  aa  6 00346 6211 00	eax1 	pr6|230
000726  aa   044000 4310 07	fld  	18432,dl
000727  la  4 00016 3521 20	epp2 	pr4|14,*		sub_err_
000730  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 148
   end CHECK_VERSION_CHAR_8;

000731  aa  6 00126 6101 00	rtcd 	pr6|86
  END PROCEDURE CHECK_VERSION_CHAR_8
  END PROCEDURE rlm_destroy_index


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
