	COMPILATION LISTING OF SEGMENT rcm_general_search
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1136.10_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          This routine implements the several record_manager_ operations
       11*     which require searching a record collection. The operations (and the
       12*     entry into this routine which implements the operation) are:
       13*     get_records_by_spec ($get), get_record_ids_by_spec ($get_id),
       14*     get_records_and_ids_by_spec ($get_records_and_ids), 
       15*     delete_records_by_spec ($delete), get_record_count ($count),
       16*     and modify_records_by_spec ($modify).
       17*          Each entry takes as input a search_specification and a
       18*     record_cursor. Records are returned in typed_vector_arrays;
       19*     record ids are returned in element_id_lists.
       20*
       21*     The actual work processing of the records, such as deleting a record,
       22*     is done in one of two subroutines depending if the operation is an update
       23*     operation or a retrieval.  This routine, rcm_general_search, sets up the 
       24*     environment in which the utility subroutines run, thereby making those
       25*     subroutines relatively simple.
       26*     
       27*     All entries in this procedure share the following of parameters:
       28*     
       29*     p_record_cursor_ptr: points to a record_cursor.  The record_cursor holds
       30*		      the file_opening_id, the collection_id, and the
       31*		      record_id of the current record.  The record_id may
       32*		      be "0"b for no-current-record.  If non-zero and the 
       33*		      search is relative to that record, that record is 
       34*		      retrieved for verification.
       35*     p_specification_ptr: points to a numeric_specification or to a
       36*		      search_specification.  The spec determines how the 
       37*		      search is to be conducted and applies constraints on
       38*		      records selected.  The spec is used to set up the 
       39*		      search environment as from it are determined whether
       40*		      numeric poistioning or search on constraints is to be
       41*		      done, whether any record value satisfies the 
       42*		      constraints, whether the search is relative to the
       43*		      current record (in the record_cursor) or absolute
       44*		      (actually, relative to the beginning or end of the 
       45*		      record collection), the maximum number of records to
       46*		      return (if specified), and the number of records
       47*		      away from the current (or beginning or end) record
       48*		      the first record to process is.  This last item can
       49*		      be the number specified in a numeric_specification
       50*		      or, if for a search_specification, +1 or -1, with the
       51*		      sign indicating whether to process records backwards
       52*		      or forwards.  It is important to note that the 
       53*		      current record is not the first record processed.
       54*		      The first record processed is always some number of 
       55*		      records away from the current record.
       56**/
       57 
       58 /* HISTORY:
       59*
       60*Written by Matthew Pierret, 08/19/82.
       61*   (Largely copied from im_general_search, written by Lindsey Spratt, 06/16/82.
       62*Modified:
       63*10/12/82 by Lindsey Spratt:  Changed to use version 2 of the 
       64*	  search_specification.
       65*11/09/82 by Lindsey Spratt:  Changed to use version 3 of the specification
       66*	  structures.
       67*11/22/82 by Lindsey Spratt:  Changed to use the correct calling sequence  for
       68*	  data_mgmt_util_$cv_table_to_typed_array.
       69*12/14/82 by Matthew Pierret: Added $count, $get_id, $modify, $position.
       70*            Changed calling sequence to rm_process_records$get and $delete to
       71*            include is_numeric_specification and is_relative_specification 
       72*            flags.
       73*12/22/82 by Matthew Pierret: Removed initial_record_id from rm_process_records
       74*            entries.  Changed to handle case of null p_specification_ptr.
       75*02/28/83 by Lindsey Spratt:  Changed to return a 0 error code when asked to
       76*	  count an empty collection.
       77*03/16/83 by Matthew Pierret: Changed to use record_collection_opening_info.
       78*            Removed cleanup handler and FINISH. Added check of record_cursor
       79*            type prior to version check.
       80*04/22/83 by Matthew Pierret:  Added the $get_records_and_ids entry.
       81*04/27/83 by Matthew Pierret:  Changed to allocate a typed_vector_array before
       82*            calling rm_process_records $get_records_and_ids.
       83*05/23/83 by Matthew Pierret:  Changed to use version 4 of specification_head.
       84*06/14/83 by Lindsey L. Spratt:  Moved conversion of field table to
       85*            typed_vector_array into rm_process_records.  Added cleanup
       86*            handler, FINISH and ERROR_RETURN procedures.
       87*07/28/83 by Matthew Pierret: Changed name from rm_general_search to
       88*            rcm_general_search, and all rm_ prefixes to rcm_.
       89*04/12/84 by Lee Baldwin: Added the entry for $position.  Removed the
       90*            p_typed_vector_array_type parameter since it never got used.
       91*12/04/84 by Matthew Pierret: Changed to use dm_vector_util_ instead of
       92*            vector_util_, and rcm_get_by_spec and rcm_update_by_spec instead
       93*            of rcm_process_records. Fixed for audit.
       94*12/13/84 by R. Michael Tague: Made get the main procedure, removed some
       95*            CHECK_VERISON pass by values.
       96*02/12/85 by Lindsey L. Spratt:  Changed to test the code after each call in
       97*            the main "case" statement, rather than in the end of the case.
       98*            Changed the GET, GET_ID, and GET_RECORDS_AND_IDS to check for
       99*            et_$area_too_small.
      100* */
      101 
      102 /* format: style2,ind3 */
      103 
      104 get:
      105    proc (p_specification_ptr, p_id_list_ptr, p_work_area_ptr, p_record_cursor_ptr, p_typed_vector_array_ptr, p_code);
      106 
      107 /* START OF DECLARATIONS */
      108 /* Parameter */
      109 
      110       dcl	    p_specification_ptr    ptr parameter;
      111       dcl	    p_id_list_ptr	       ptr parameter;
      112       dcl	    p_work_area_ptr	       ptr parameter;
      113       dcl	    p_record_cursor_ptr    ptr parameter;
      114       dcl	    p_element_id_list_ptr  ptr parameter;
      115       dcl	    p_typed_vector_array_ptr
      116 			       ptr parameter;
      117       dcl	    p_general_typed_vector_ptr
      118 			       ptr parameter;
      119       dcl	    p_number_of_records_processed
      120 			       fixed bin (35) parameter;
      121       dcl	    p_code	       fixed bin (35) parameter;
      122 
      123 /* Automatic */
      124 
      125       dcl	    entry		       fixed bin;
      126       dcl	    spec_is_relative       bit (1) aligned;
      127       dcl	    spec_is_numeric	       bit (1) aligned;
      128       dcl	    spec_is_always_satisfied
      129 			       bit (1) aligned;
      130       dcl	    search_in_reverse_order
      131 			       bit (1) aligned;
      132 
      133       dcl	    first_record_id	       bit (36) aligned;
      134       dcl	    low_record_id_bound    bit (36) aligned;
      135       dcl	    high_record_id_bound   bit (36) aligned;
      136 
      137       dcl	    code		       fixed bin (35);
      138       dcl	    maximum_number_of_records
      139 			       fixed bin (35);
      140       dcl	    direction_of_search    fixed bin (17);
      141       dcl	    position_from_initial  fixed bin (17);
      142       dcl	    (typed_vector_array_ptr, field_table_ptr)
      143 			       ptr init (null);
      144 
      145 /* Based */
      146 /* Builtin */
      147 
      148       dcl	    null		       builtin;
      149 
      150 /* Condition */
      151 
      152       dcl	    cleanup	       condition;
      153 
      154 /* Constant */
      155 
      156       dcl	    myname	       char (32) varying init ("rcm_general_search") internal static options (constant);
      157       dcl	    DEFAULT_RECORD_ID_BOUND
      158 			       init ("0"b) bit (36) aligned internal static options (constant);
      159       dcl	    DEFAULT_MAXIMUM_NUMBER_OF_RECORDS
      160 			       init (3435974000) fixed bin (35) internal static options (constant);
      161       dcl	    NO_POSITIONING	       init (0) fixed bin (17) internal static options (constant);
      162       dcl	    SPECIFIED_ID_IS_NOT_DEFAULT_ID
      163 			       init ("0"b) bit (1) aligned internal static options (constant);
      164       dcl	    (
      165 	    GET_ENTRY	       init (1),
      166 	    GET_ID_ENTRY	       init (2),
      167 	    GET_RECORDS_AND_IDS_ENTRY
      168 			       init (3),
      169 	    COUNT_ENTRY	       init (4),
      170 	    POSITION_ENTRY	       init (5),
      171 	    DELETE_ENTRY	       init (6),
      172 	    MODIFY_ENTRY	       init (7)
      173 	    )		       fixed bin internal static options (constant);
      174 
      175 /* Entry */
      176 
      177       dcl	    rcm_get_opening_info   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      178       dcl	    rcm_get_by_spec$count  entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      179 			       fixed bin (35), fixed bin (35), fixed bin (35));
      180       dcl	    rcm_get_by_spec$get    entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      181 			       fixed bin (35), ptr, ptr, ptr, fixed bin (35));
      182       dcl	    rcm_get_by_spec$get_records_and_ids
      183 			       entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      184 			       fixed bin (35), ptr, ptr, ptr, ptr, fixed bin (35));
      185       dcl	    rcm_get_by_spec$get_id entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      186 			       fixed bin (35), ptr, ptr, fixed bin (35));
      187       dcl	    rcm_get_by_spec$position
      188 			       entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      189 			       fixed bin (35), fixed bin (35));
      190       dcl	    rcm_update_by_spec$delete
      191 			       entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      192 			       fixed bin (35), fixed bin (35), fixed bin (35));
      193       dcl	    rcm_update_by_spec$modify
      194 			       entry (ptr, ptr, ptr, bit (36) aligned, bit (36) aligned, bit (1) aligned, fixed bin,
      195 			       fixed bin (35), ptr, fixed bin (35), fixed bin (35));
      196 
      197       dcl	    sub_err_	       entry options (variable);
      198       dcl	    dm_vector_util_$free_typed_vector_array
      199 			       entry (ptr, ptr, fixed bin (35));
      200 
      201 /* External */
      202 
      203       dcl	    (
      204 	    dm_error_$bad_specification_type,
      205 	    dm_error_$beginning_of_collection,
      206 	    dm_error_$ci_not_allocated,
      207 	    dm_error_$ci_not_in_collection,
      208 	    dm_error_$end_of_collection,
      209 	    dm_error_$invalid_cursor_position,
      210 	    dm_error_$no_element,
      211 	    dm_error_$programming_error,
      212 	    dm_error_$record_not_found,
      213 	    dm_error_$wrong_cursor_type,
      214 	    error_table_$area_too_small,
      215 	    error_table_$unimplemented_version
      216 	    )		       fixed bin (35) ext;
      217 
      218 /* END OF DECLARATIONS */
      219 
      220 /* rcm_general_search$get entry point. */
      221 
      222       entry = GET_ENTRY;
      223       goto JOIN;
      224 
      225 get_id:
      226    entry (p_specification_ptr, p_work_area_ptr, p_record_cursor_ptr, p_element_id_list_ptr, p_code);
      227 
      228       entry = GET_ID_ENTRY;
      229       goto JOIN;
      230 
      231 get_records_and_ids:
      232    entry (p_specification_ptr, p_id_list_ptr, p_work_area_ptr, p_record_cursor_ptr, p_element_id_list_ptr,
      233         p_typed_vector_array_ptr, p_code);
      234 
      235       entry = GET_RECORDS_AND_IDS_ENTRY;
      236       goto JOIN;
      237 
      238 delete:
      239    entry (p_specification_ptr, p_record_cursor_ptr, p_number_of_records_processed, p_code);
      240 
      241       entry = DELETE_ENTRY;
      242       p_number_of_records_processed = 0;
      243       goto JOIN;
      244 
      245 modify:
      246    entry (p_specification_ptr, p_general_typed_vector_ptr, p_record_cursor_ptr, p_number_of_records_processed, p_code);
      247 
      248       entry = MODIFY_ENTRY;
      249       p_number_of_records_processed = 0;
      250       goto JOIN;
      251 
      252 count:
      253    entry (p_specification_ptr, p_record_cursor_ptr, p_number_of_records_processed, p_code);
      254 
      255       entry = COUNT_ENTRY;
      256       p_number_of_records_processed = 0;
      257       goto JOIN;
      258 
      259 position:
      260    entry (p_specification_ptr, p_record_cursor_ptr, p_code);
      261 
      262       entry = POSITION_ENTRY;
      263       goto JOIN;
      264 
      265 JOIN:
      266       p_code = 0;
      267       code = 0;
      268       record_cursor_ptr = p_record_cursor_ptr;
      269       if record_cursor.type ^= RECORD_CURSOR_TYPE
      270       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      271 	      "^/Expected record cursor, type ^d; received type ^d.", RECORD_CURSOR_TYPE, record_cursor.type);
      272       call CHECK_VERSION ((record_cursor.version), (RECORD_CURSOR_VERSION_2), "record_cursor");
      273 
      274       specification_head_ptr = p_specification_ptr;
      275       call GET_SPEC_VALUES (specification_head_ptr, spec_is_relative, spec_is_numeric, spec_is_always_satisfied,
      276 	 search_in_reverse_order, maximum_number_of_records, position_from_initial);
      277       if spec_is_relative
      278       then
      279          do;
      280 	  call VERIFY_POSITION (record_cursor_ptr);
      281 	  if search_in_reverse_order
      282 	  then
      283 	     do;
      284 	        low_record_id_bound = DEFAULT_RECORD_ID_BOUND;
      285 	        high_record_id_bound = record_cursor.record_id;
      286 	     end;
      287 	  else
      288 	     do;
      289 	        low_record_id_bound = record_cursor.record_id;
      290 	        high_record_id_bound = DEFAULT_RECORD_ID_BOUND;
      291 	     end;
      292          end;
      293       else low_record_id_bound, high_record_id_bound = DEFAULT_RECORD_ID_BOUND;
      294 
      295       first_record_id = FIRST_RECORD_TO_PROCESS (record_cursor_ptr, low_record_id_bound, position_from_initial);
      296 
      297       if search_in_reverse_order
      298       then direction_of_search = -1;
      299       else direction_of_search = +1;
      300 
      301       call rcm_get_opening_info (record_cursor.file_opening_id, record_cursor.collection_id,
      302 	 record_collection_opening_info_ptr, code);
      303       if code ^= 0
      304       then call ERROR_RETURN (code);
      305       call CHECK_VERSION_CHAR_8 (record_collection_opening_info.version, RECORD_COLLECTION_OPENING_INFO_VERSION_1,
      306 	 "record_collection_opening_info");
      307       field_table_ptr = record_collection_opening_info.field_table_ptr;
      308 
      309       on cleanup call FINISH;
      310 
      311       if entry = GET_ENTRY
      312       then
      313          do;
      314 	  call rcm_get_by_spec$get (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      315 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records,
      316 	       p_work_area_ptr, p_id_list_ptr, typed_vector_array_ptr, code);
      317 	  if code ^= 0
      318 	  then if code ^= error_table_$area_too_small
      319 	       then call ERROR_RETURN (code);
      320          end;
      321       else if entry = GET_ID_ENTRY
      322       then
      323          do;
      324 	  call rcm_get_by_spec$get_id (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      325 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records,
      326 	       p_work_area_ptr, p_element_id_list_ptr, code);
      327 	  if code ^= 0
      328 	  then if code ^= error_table_$area_too_small
      329 	       then call ERROR_RETURN (code);
      330          end;
      331 
      332       else if entry = GET_RECORDS_AND_IDS_ENTRY
      333       then
      334          do;
      335 	  call rcm_get_by_spec$get_records_and_ids (record_cursor_ptr, field_table_ptr, specification_head_ptr,
      336 	       first_record_id, high_record_id_bound, spec_is_always_satisfied, direction_of_search,
      337 	       maximum_number_of_records, p_work_area_ptr, p_id_list_ptr, p_element_id_list_ptr, typed_vector_array_ptr,
      338 	       code);
      339 	  if code ^= 0
      340 	  then if code ^= error_table_$area_too_small
      341 	       then call ERROR_RETURN (code);
      342          end;
      343 
      344       else if entry = COUNT_ENTRY
      345       then
      346          do;
      347 	  call rcm_get_by_spec$count (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      348 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records,
      349 	       p_number_of_records_processed, code);
      350 	  if code ^= 0
      351 	  then if code ^= dm_error_$record_not_found
      352 	       then call ERROR_RETURN (code);
      353          end;
      354       else if entry = POSITION_ENTRY
      355       then
      356          do;
      357 	  call rcm_get_by_spec$position (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      358 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records, code);
      359 	  if code ^= 0
      360 	  then call ERROR_RETURN (code);
      361          end;
      362       else if entry = DELETE_ENTRY
      363       then
      364          do;
      365 	  call rcm_update_by_spec$delete (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      366 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records,
      367 	       p_number_of_records_processed, code);
      368 	  if code ^= 0
      369 	  then call ERROR_RETURN (code);
      370          end;
      371       else if entry = MODIFY_ENTRY
      372       then
      373          do;
      374 	  call rcm_update_by_spec$modify (record_cursor_ptr, field_table_ptr, specification_head_ptr, first_record_id,
      375 	       high_record_id_bound, spec_is_always_satisfied, direction_of_search, maximum_number_of_records,
      376 	       p_general_typed_vector_ptr, p_number_of_records_processed, code);
      377 	  if code ^= 0
      378 	  then call ERROR_RETURN (code);
      379          end;
      380       else call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null (), 0,
      381 	      "The entry code ^d is not one of the possible valid entry codes.", entry);
      382 
      383       if entry = GET_ENTRY | entry = GET_RECORDS_AND_IDS_ENTRY
      384       then p_typed_vector_array_ptr = typed_vector_array_ptr;
      385       else ;
      386 
      387       p_code = code;
      388 
      389       call FINISH;
      390 MAIN_RETURN:
      391       return;
      392 
      393 FINISH:
      394    proc;
      395       if entry = GET_ENTRY | entry = GET_RECORDS_AND_IDS_ENTRY
      396       then if typed_vector_array_ptr ^= null & p_typed_vector_array_ptr ^= typed_vector_array_ptr
      397 	 then call dm_vector_util_$free_typed_vector_array (p_work_area_ptr, typed_vector_array_ptr, code);
      398    end FINISH;
      399 
      400 
      401 ERROR_RETURN:
      402    proc (er_p_code);
      403 
      404       dcl	    er_p_code	       fixed bin (35) parm;
      405 
      406       p_code = er_p_code;
      407       call FINISH;
      408       goto MAIN_RETURN;
      409    end ERROR_RETURN;
      410 
      411 CHECK_VERSION:
      412    proc (p_received_version, p_expected_version, p_structure_name);
      413       dcl	    p_received_version     fixed bin (35);
      414       dcl	    p_expected_version     fixed bin (35);
      415       dcl	    p_structure_name       char (*);
      416 
      417       if p_received_version ^= p_expected_version
      418       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      419 	      "^/Expected version ^d of the ^a structure.
      420 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      421 
      422    end CHECK_VERSION;
      423 
      424 
      425 CHECK_VERSION_CHAR_8:
      426    proc (p_given_version, p_correct_version, p_structure_name);
      427 
      428       dcl	    p_structure_name       char (*);
      429       dcl	    p_given_version	       char (8) aligned;
      430       dcl	    p_correct_version      char (8) aligned;
      431 
      432       if p_given_version ^= p_correct_version
      433       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      434 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      435 	      p_given_version);
      436 
      437       return;
      438 
      439    end CHECK_VERSION_CHAR_8;
      440 
      441 VERIFY_POSITION:
      442    proc (vp_p_record_cursor_ptr);
      443 
      444 /* VERIFY_POSITION attempts to access the record specified by
      445*   record_cursor.record_id.  If that record does not exist, the cursor
      446*   is invalid.  If it does exist but some other error occurs, return that
      447*   error.  Either type of error results in a return to the caller of the
      448*   main procedure.  This routine returns to the main procedure only if the
      449*   cursor is valid. */
      450 
      451       dcl	    vp_p_record_cursor_ptr ptr parm;
      452       dcl	    vp_code	       fixed bin (35);
      453 
      454       vp_code = 0;
      455       call collection_manager_$get_id (vp_p_record_cursor_ptr -> record_cursor.file_opening_id,
      456 	 vp_p_record_cursor_ptr -> record_cursor.collection_id, vp_p_record_cursor_ptr -> record_cursor.record_id,
      457 	 NO_POSITIONING, SPECIFIED_ID_IS_NOT_DEFAULT_ID, ("0"b), vp_code);
      458       if vp_code ^= 0
      459       then if vp_code = dm_error_$no_element | vp_code = dm_error_$ci_not_in_collection
      460 	      | vp_code = dm_error_$ci_not_allocated
      461 	 then call ERROR_RETURN (dm_error_$invalid_cursor_position);
      462 	 else call ERROR_RETURN (vp_code);
      463       else return;
      464 
      465    end VERIFY_POSITION;
      466 
      467 FIRST_RECORD_TO_PROCESS:
      468    proc (frp_p_record_cursor_ptr, frp_p_initial_record_id, frp_p_position_from_initial) returns (bit (36) aligned);
      469 
      470 /* FIRST_RECORD_TO_PROCESS is a function which returns the record id of
      471*   the first record to process. 
      472*   The error processing is different from that in VERIFY_CURSOR.  This is
      473*   because we know that frp_p_initial_record_id is either a valid record id
      474*   or "0"b.  Any error codes cannot refer to the frp_p_initial_record_id.
      475*   dm_error_$no_element (necessarily with frp_p_initial_record_id = "0"b)
      476*   can only mean that there are no records at all, and
      477*   dm_error_$(beginning end)_of_collection can only mean that we attempted to
      478*   position past the beginning or end of the collection.  All three simply
      479*   mean that the desired record was not found.  Any other error is an
      480*   unexpected error and should be reported as is.  
      481**/
      482 
      483       dcl	    frp_p_record_cursor_ptr
      484 			       ptr parm;
      485       dcl	    frp_p_initial_record_id
      486 			       bit (36) aligned parm;
      487       dcl	    frp_p_position_from_initial
      488 			       fixed bin (17) parm;
      489       dcl	    frp_code	       fixed bin (35);
      490       dcl	    frp_start_from_edge    bit (1) aligned;
      491       dcl	    frp_first_record_id    bit (36) aligned;
      492 
      493       frp_code = 0;
      494       frp_start_from_edge = (frp_p_initial_record_id = "0"b);
      495 
      496       call collection_manager_$get_id (frp_p_record_cursor_ptr -> record_cursor.file_opening_id,
      497 	 frp_p_record_cursor_ptr -> record_cursor.collection_id, frp_p_initial_record_id, frp_p_position_from_initial,
      498 	 frp_start_from_edge, frp_first_record_id, frp_code);
      499       if frp_code ^= 0
      500       then if frp_code = dm_error_$no_element | frp_code = dm_error_$end_of_collection
      501 	      | frp_code = dm_error_$beginning_of_collection
      502 	 then call ERROR_RETURN (dm_error_$record_not_found);
      503 	 else call ERROR_RETURN (frp_code);
      504       else return (frp_first_record_id);
      505 
      506    end FIRST_RECORD_TO_PROCESS;
      507 
      508 GET_SPEC_VALUES:
      509    proc (gsv_p_spec_ptr, gsv_p_spec_is_relative, gsv_p_spec_is_numeric, gsv_p_spec_is_always_satisfied,
      510         gsv_p_search_in_reverse_order, gsv_p_maximum_number_of_records, gsv_p_position_from_initial);
      511 
      512 /* This routine analyzes the given specification to determine various
      513*   information to be used in selecting records.  Determination of such
      514*   information is dependent upon the type of specification supplied:
      515*   absolute or relative, search or numeric.  The information returned is:
      516*  
      517*   gsv_p_spec_is_relative : ON if the type of the spec is relative, 
      518*		        OFF if absolute.
      519*   gsv_p_spec_is_numeric :  ON if the type of the spec is numeric,
      520*		        OFF if the type is search.
      521*   gsv_p_spec_is_always_satisfied : ON if the specification is such that
      522*                    any record satisfies its constraints.  This is true if
      523*		a search spec has no constraints, if no spec is supplied,
      524*		or if a numeric spec is supplied.
      525*   gsv_p_search_in_reverse_order : ON if the records are to be processed 
      526*                    backwards.  This is true if a negative position_number is
      527*                    supplied with a numeric_spec, or if a search_spec specifies
      528*                    a range of records which is at the end of acceptable 
      529*                    records (range.type = HIGH_RANGE_TYPE).
      530*   gsv_p_maximum_number_of_records : specifies the most records allowed by the
      531*                    spec.
      532*   gsv_p_position_from_initial : is the number of records to position from the 
      533*                    initial position to get the first record to examine.
      534*                    This can be positive or negative for positioning forward
      535*                    or backward.
      536**/
      537 
      538       dcl	    gsv_p_spec_ptr	       ptr parm;
      539       dcl	    gsv_p_spec_is_relative bit (1) aligned parm;
      540       dcl	    gsv_p_spec_is_numeric  bit (1) aligned parm;
      541       dcl	    gsv_p_spec_is_always_satisfied
      542 			       bit (1) aligned parm;
      543       dcl	    gsv_p_search_in_reverse_order
      544 			       bit (1) aligned parm;
      545       dcl	    gsv_p_maximum_number_of_records
      546 			       fixed bin (35) parm;
      547       dcl	    gsv_p_position_from_initial
      548 			       fixed bin (17) parm;
      549 
      550       if gsv_p_spec_ptr = null ()
      551       then
      552          do;
      553 	  gsv_p_spec_is_relative = "0"b;
      554 	  gsv_p_spec_is_numeric = "0"b;
      555 	  gsv_p_spec_is_always_satisfied = "1"b;
      556 	  gsv_p_search_in_reverse_order = "0"b;
      557 	  gsv_p_position_from_initial = 1;
      558 	  gsv_p_maximum_number_of_records = DEFAULT_MAXIMUM_NUMBER_OF_RECORDS;
      559          end;
      560       else
      561          do;
      562 	  call CHECK_VERSION (gsv_p_spec_ptr -> specification_head.version, SPECIFICATION_VERSION_4, "specification");
      563 
      564 	  if gsv_p_spec_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      565 	       | gsv_p_spec_ptr -> specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
      566 	  then
      567 	     do;
      568 	        if gsv_p_spec_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      569 	        then gsv_p_spec_is_relative = "1"b;
      570 	        else gsv_p_spec_is_relative = "0"b;
      571 
      572 	        search_specification_ptr = gsv_p_spec_ptr;
      573 	        gsv_p_spec_is_numeric = "0"b;
      574 	        gsv_p_spec_is_always_satisfied = (search_specification.number_of_and_groups <= 0);
      575 	        gsv_p_search_in_reverse_order = (search_specification.range.type = HIGH_RANGE_TYPE);
      576 	        gsv_p_position_from_initial = 1;
      577 	        if search_specification.range.type ^= ALL_RANGE_TYPE & search_specification.range.size > 0
      578 	        then gsv_p_maximum_number_of_records = search_specification.range.size;
      579 	        else gsv_p_maximum_number_of_records = DEFAULT_MAXIMUM_NUMBER_OF_RECORDS;
      580 	     end;
      581 	  else if gsv_p_spec_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      582 	       | gsv_p_spec_ptr -> specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
      583 	  then
      584 	     do;
      585 	        if gsv_p_spec_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      586 	        then gsv_p_spec_is_relative = "1"b;
      587 	        else gsv_p_spec_is_relative = "0"b;
      588 
      589 	        numeric_specification_ptr = gsv_p_spec_ptr;
      590 	        gsv_p_spec_is_numeric = "1"b;
      591 	        gsv_p_spec_is_always_satisfied = "1"b;
      592 	        gsv_p_position_from_initial = numeric_specification.position_number;
      593 	        gsv_p_search_in_reverse_order = (gsv_p_position_from_initial < 0);
      594 	        if numeric_specification.range_size > 0
      595 	        then gsv_p_maximum_number_of_records = numeric_specification.range_size;
      596 	        else gsv_p_maximum_number_of_records = DEFAULT_MAXIMUM_NUMBER_OF_RECORDS;
      597 	     end;
      598 	  else call sub_err_ (dm_error_$bad_specification_type, myname, ACTION_CANT_RESTART, null, 0,
      599 		  "^/The  specification structure does not have a recognizable type.^/The recognizable types are: ^d, ^d, ^d or ^d. Received a type ^d structure."
      600 		  , ABSOLUTE_SEARCH_SPECIFICATION_TYPE, RELATIVE_SEARCH_SPECIFICATION_TYPE,
      601 		  ABSOLUTE_NUMERIC_SPECIFICATION_TYPE, RELATIVE_NUMERIC_SPECIFICATION_TYPE,
      602 		  gsv_p_spec_ptr -> specification_head.type);
      603          end;
      604 
      605       return;
      606 
      607 
      608    end GET_SPEC_VALUES;
      609 
  1     1 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*Written by Matthew Pierret, 03/15/83. 
  1     5*Modified:
  1     6*07/28/83 by Matthew Pierret: Changed name from dm_rm_opening_info.incl.pl1 to
  1     7*            dm_rcm_opening_info.incl.pl1.
  1     8**/
  1     9 
  1    10 /* format: style2,ind3 */
  1    11      dcl	   1 record_collection_opening_info
  1    12 			      aligned based (record_collection_opening_info_ptr),
  1    13 	     2 version	      char (8) aligned init (RECORD_COLLECTION_OPENING_INFO_VERSION_1),
  1    14 	     2 current_transaction_id
  1    15 			      bit (36) aligned init ("0"b),
  1    16 	     2 current_rollback_count
  1    17 			      fixed bin (35) init (0),
  1    18 	     2 file_opening_id    bit (36) aligned init ("0"b),
  1    19 	     2 collection_id      bit (36) aligned init ("0"b),
  1    20 	     2 field_table_ptr    ptr init (null);
  1    21 
  1    22      dcl	   record_collection_opening_info_ptr
  1    23 			      ptr init (null);
  1    24      dcl	   RECORD_COLLECTION_OPENING_INFO_VERSION_1
  1    25 			      char (8) aligned init ("rc_open1") internal static options (constant);
  1    26 
  1    27 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
      610 
      611 
  2     1 /* BEGIN INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 04/05/82.
  2     5*Modified:
  2     6*08/19/82 by Matthew Pierret:  Version 2. Changed collection_id to 
  2     7*            bit (36) aligned.
  2     8*07/28/83 by Matthew Pierret: Changed name from dm_rm_cursor.incl.pl1 to
  2     9*            dm_rcm_cursor.incl.pl1.
  2    10*04/13/84 by Lee Baldwin:  Renamed pf_opening_id to file_opening_id to coincide
  2    11*            with the naming conventions used in the rcm_XX routines.
  2    12**/
  2    13 
  2    14 /* format: style2,ind3 */
  2    15      dcl	   1 record_cursor	      aligned based (record_cursor_ptr),
  2    16 	     2 type	      fixed bin (17) unaligned,
  2    17 	     2 version	      fixed bin (17) unaligned,
  2    18 	     2 flags,
  2    19 	       3 position_is_valid
  2    20 			      bit (1) unal,
  2    21 	       3 pad	      bit (35) unal,
  2    22 	     2 area_ptr	      ptr,
  2    23 	     2 file_opening_id    bit (36) aligned,
  2    24 	     2 collection_id      bit (36) aligned,
  2    25 	     2 record_id	      bit (36) aligned,
  2    26 	     2 record_check_value bit (36) aligned;
  2    27 
  2    28      dcl	   record_cursor_ptr      ptr;
  2    29      dcl	   RECORD_CURSOR_VERSION_2
  2    30 			      init (2) fixed bin int static options (constant);
  2    31      dcl	   RECORD_CURSOR_TYPE     init (1) fixed bin int static options (constant);
  2    32      dcl	   BEGINNING_OF_COLLECTION_RECORD_ID
  2    33 			      init ("0"b) bit (36) aligned int static options (constant);
  2    34 
  2    35 /* END INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
      612 
      613 
  3     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  3     5*Modified:
  3     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  3     7**/
  3     8 
  3     9 /* format: style2,ind3 */
  3    10      dcl	   1 specification_head   based (specification_head_ptr),
  3    11 	     2 version	      fixed bin (35),
  3    12 	     2 type	      fixed bin (17) unal,
  3    13 	     2 pad	      bit (18) unal,
  3    14 	     2 subset_specification_ptr
  3    15 			      ptr;
  3    16 
  3    17 
  3    18      dcl	   specification_head_ptr ptr;
  3    19      dcl	   SPECIFICATION_VERSION_4
  3    20 			      init (4) fixed bin (35) internal static options (constant);
  3    21 
  3    22      dcl	   (
  3    23 	   SEARCH_SPECIFICATION_TYPE
  3    24 			      init (1),
  3    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  3    26 			      init (1),
  3    27 	   NUMERIC_SPECIFICATION_TYPE
  3    28 			      init (2),
  3    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  3    30 			      init (2),
  3    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  3    32 			      init (3),
  3    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  3    34 			      init (4),
  3    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  3    36 			      init (5),
  3    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  3    38 			      init (6),
  3    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  3    40 			      init (7),
  3    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  3    42 			      init (8)
  3    43 	   )		      fixed bin (17) internal static options (constant);
  3    44 
  3    45 
  3    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      614 
      615 
  4     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          The specification structure is used to identify sets items based on
  4     6*     the value of some of the contents of the items (the
  4     7*     search_specification), or based on the ordinal position (the
  4     8*     numeric_specification) of the first or last item in the desired set of
  4     9*     items in the set of all possible items.  It is used with the relation,
  4    10*     index and record managers.  The items for these three managers are
  4    11*     tuples, keys and records, respectively.  The sets of "all possible
  4    12*     items", for determination of ordinal position for these three managers
  4    13*     are: a relation, an index, and a record collection, respectively.
  4    14*     
  4    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  4    16*     must be included in any program which uses this (the
  4    17*     dm_specification.incl.pl1) include file.
  4    18**/
  4    19 
  4    20 /* HISTORY:
  4    21*
  4    22*Written by Lindsey Spratt, 05/19/82.
  4    23*Modified:
  4    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  4    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  4    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  4    27*	  Changed the version to 3.
  4    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  4    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  4    30*            Moved range type constants into dm_range_constants.incl.pl1.
  4    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  4    32*            intra-key/record compares.
  4    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  4    34*            Added a DESCRIPTION comment.
  4    35**/
  4    36 
  4    37 /* format: style2,ind3 */
  4    38      dcl	   1 search_specification based (search_specification_ptr),
  4    39 	     2 head	      like specification_head,
  4    40 	     2 maximum_number_of_constraints
  4    41 			      fixed bin (17) unal,
  4    42 	     2 number_of_and_groups
  4    43 			      fixed bin (17) unal,
  4    44 	     2 range	      unal,
  4    45 	       3 type	      fixed bin (17),
  4    46 	       3 size	      fixed bin (17),
  4    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  4    48 	       3 number_of_constraints
  4    49 			      fixed bin (17) unal,
  4    50 	       3 constraint	      (ss_maximum_number_of_constraints
  4    51 			      refer (search_specification.maximum_number_of_constraints)),
  4    52 	         4 field_id	      fixed bin (17) unal,
  4    53 	         4 operator_code  fixed bin (17) unal,
  4    54 	         4 value_field_id fixed bin (17) unal,
  4    55 	         4 pad	      bit (18) unal,
  4    56 	         4 value_ptr      ptr unal;
  4    57 
  4    58      dcl	   search_specification_ptr
  4    59 			      ptr;
  4    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  4    61 			      fixed bin (17);
  4    62 
  4    63      dcl	   1 numeric_specification
  4    64 			      based (numeric_specification_ptr),
  4    65 	     2 head	      like specification_head,
  4    66 	     2 range_size	      fixed bin (35) aligned,
  4    67 	     2 position_number    fixed bin (17) unal,
  4    68 	     2 pad	      bit (18) unal;
  4    69 
  4    70      dcl	   numeric_specification_ptr
  4    71 			      ptr;
  4    72 
  4    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      616 
      617 
  5     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 05/27/83.
  5     5*Modified:
  5     6**/
  5     7 
  5     8      dcl	   (
  5     9 	   ALL_RANGE_TYPE	      init (1),
  5    10 	   LOW_RANGE_TYPE	      init (2),
  5    11 	   HIGH_RANGE_TYPE	      init (3)
  5    12 	   )		      fixed bin internal static options (constant);
  5    13 
  5    14 
  5    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
      618 
      619 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      620 
      621 
  7     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*     This include file contains declarations of all collection_manager_ 
  7     5*     entrypoints.
  7     6**/
  7     7 
  7     8 /* HISTORY:
  7     9*Written by Matthew Pierret 
  7    10*Modified:
  7    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  7    12*	  allocate_control_interval operation to be unaligned, as well as
  7    13*	  unsigned.
  7    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  7    15*            removed the beginning_location parameter from the put_element
  7    16*            operation. Added the create_page_file_operation.
  7    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  7    18*            wherever collection_id was required.
  7    19*            Also changed the control_interval_id parameter of the 
  7    20*            allocate_control_interval operation back to be aligned. So there.
  7    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  7    22*            added the argument file_create_info_ptr to $create_file.
  7    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  7    24*	  include the zero_on_free bit.
  7    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  7    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  7    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  7    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  7    29*            cm_$put_unprotected_header.
  7    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  7    31*             $simple_get_buffered_element.
  7    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  7    33*            parameter for specifying absolute/relative nature of search.
  7    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  7    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  7    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  7    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  7    38*            delete_from_ci_buffer.
  7    39*            Re-named *_buffered_ci to =_ci_buffer.
  7    40*            get entries.
  7    41*            modify entries.
  7    42*            Changed calling sequence of modify entries to have a ptr/length
  7    43*            instead of length/ptr parameter pair.
  7    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  7    45**/
  7    46 
  7    47 /* This include file contains declarations of collection_manager_ entrypoints */
  7    48 
  7    49 /* format: style2,ind3 */
  7    50      dcl	   collection_manager_$allocate_control_interval
  7    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    52      dcl	   collection_manager_$compact_control_interval
  7    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  7    54      dcl	   collection_manager_$create_collection
  7    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7    56      dcl	   collection_manager_$create_file
  7    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  7    58      dcl	   collection_manager_$destroy_collection
  7    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7    60      dcl	   collection_manager_$free_control_interval
  7    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  7    62 			      fixed bin (35));
  7    63 
  7    64      dcl	   collection_manager_$delete
  7    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    66 			      fixed bin (35));
  7    67      dcl	   collection_manager_$delete_from_ci_buffer
  7    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    69 			      fixed bin (35));
  7    70 
  7    71      dcl	   collection_manager_$get
  7    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    74      dcl	   collection_manager_$get_control_interval_ptr
  7    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  7    76 			      fixed bin (35));
  7    77      dcl	   collection_manager_$get_from_ci_buffer
  7    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    80      dcl	   collection_manager_$get_by_ci_ptr
  7    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  7    83      dcl	   collection_manager_$get_header
  7    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  7    85 			      ptr, fixed bin (35), fixed bin (35));
  7    86      dcl	   collection_manager_$get_id
  7    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  7    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    89      dcl	   collection_manager_$get_portion
  7    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7    92 			      fixed bin (35), fixed bin (35));
  7    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  7    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7    96 			      fixed bin (35));
  7    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  7    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   collection_manager_$modify
  7   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   103 			      fixed bin (35), fixed bin (35));
  7   104      dcl	   collection_manager_$modify_unprotected
  7   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   106 			      fixed bin (35), fixed bin (35));
  7   107      dcl	   collection_manager_$modify_in_ci_buffer
  7   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   109 			      fixed bin (35), fixed bin (35));
  7   110      dcl	   collection_manager_$modify_portion
  7   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  7   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   113      dcl	   collection_manager_$postcommit_increments
  7   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   115      dcl	   collection_manager_$put
  7   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   117 			      fixed bin (35), fixed bin (35));
  7   118      dcl	   collection_manager_$put_in_ci_buffer
  7   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   120 			      fixed bin (35), fixed bin (35));
  7   121      dcl	   collection_manager_$put_header
  7   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   123      dcl	   collection_manager_$put_unprotected_header
  7   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   125 
  7   126      dcl	   collection_manager_$replace_ci_buffer
  7   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   128 			      fixed bin (35));
  7   129      dcl	   collection_manager_$setup_ci_buffer
  7   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   131 			      fixed bin (35));
  7   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  7   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   134 			      fixed bin (35));
  7   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  7   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   137 			      fixed bin (35));
  7   138 
  7   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      622 
      623 
      624    end get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1136.1  rcm_general_search.pl1            >udd>sm>ds>w>ml>rcm_general_search.pl1
610          1    01/07/85  0959.4  dm_rcm_opening_info.incl.pl1      >ldd>incl>dm_rcm_opening_info.incl.pl1
612          2    01/07/85  0959.4  dm_rcm_cursor.incl.pl1            >ldd>incl>dm_rcm_cursor.incl.pl1
614          3    10/14/83  1709.1  dm_specification_head.incl.pl1    >ldd>incl>dm_specification_head.incl.pl1
616          4    01/07/85  0959.8  dm_specification.incl.pl1         >ldd>incl>dm_specification.incl.pl1
618          5    10/14/83  1709.1  dm_range_constants.incl.pl1       >ldd>incl>dm_range_constants.incl.pl1
620          6    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
622          7    04/05/85  1024.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>incl>dm_collmgr_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
                                000040 constant        fixed bin(17,0)          initial dcl 3-22 set ref 581 598*
ABSOLUTE_SEARCH_SPECIFICATION_TYPE
                                000041 constant        fixed bin(17,0)          initial dcl 3-22 set ref 564 598*
ACTION_CANT_RESTART             000015 constant        bit(36)                  initial dcl 6-7 set ref 269* 380* 417* 432* 598*
ALL_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 5-8 ref 577
COUNT_ENTRY                            constant        fixed bin(17,0)          initial dcl 164 ref 255 344
DEFAULT_MAXIMUM_NUMBER_OF_RECORDS
                                000002 constant        fixed bin(35,0)          initial dcl 159 ref 558 579 596
DEFAULT_RECORD_ID_BOUND                constant        bit(36)                  initial dcl 157 ref 284 290 293
DELETE_ENTRY                           constant        fixed bin(17,0)          initial dcl 164 ref 241 362
GET_ENTRY                              constant        fixed bin(17,0)          initial dcl 164 ref 222 311 383 395
GET_ID_ENTRY                           constant        fixed bin(17,0)          initial dcl 164 ref 228 321
GET_RECORDS_AND_IDS_ENTRY              constant        fixed bin(17,0)          initial dcl 164 ref 235 332 383 395
HIGH_RANGE_TYPE                        constant        fixed bin(17,0)          initial dcl 5-8 ref 575
MODIFY_ENTRY                           constant        fixed bin(17,0)          initial dcl 164 ref 248 371
NO_POSITIONING                  000033 constant        fixed bin(17,0)          initial dcl 161 set ref 455*
POSITION_ENTRY                         constant        fixed bin(17,0)          initial dcl 164 ref 262 354
RECORD_COLLECTION_OPENING_INFO_VERSION_1
                                000000 constant        char(8)                  initial dcl 1-24 set ref 305*
RECORD_CURSOR_TYPE              000041 constant        fixed bin(17,0)          initial dcl 2-31 set ref 269 269*
RECORD_CURSOR_VERSION_2                constant        fixed bin(17,0)          initial dcl 2-29 ref 272
RELATIVE_NUMERIC_SPECIFICATION_TYPE
                                000034 constant        fixed bin(17,0)          initial dcl 3-22 set ref 581 585 598*
RELATIVE_SEARCH_SPECIFICATION_TYPE
                                000035 constant        fixed bin(17,0)          initial dcl 3-22 set ref 564 568 598*
SPECIFICATION_VERSION_4         000034 constant        fixed bin(35,0)          initial dcl 3-19 set ref 562*
SPECIFIED_ID_IS_NOT_DEFAULT_ID  000033 constant        bit(1)                   initial dcl 162 set ref 455*
cleanup                         000120 stack reference condition                dcl 152 ref 309
code                            000110 automatic       fixed bin(35,0)          dcl 137 set ref 267* 301* 303 303* 314* 317 317 317*
                                                                                  324* 327 327 327* 335* 339 339 339* 347* 350 350
                                                                                  350* 357* 359 359* 365* 368 368* 374* 377 377* 387
                                                                                  395*
collection_id             5            based           bit(36)                  level 2 dcl 2-15 set ref 301* 455* 496*
collection_manager_$get_id      000064 constant        entry                    external dcl 7-86 ref 455 496
direction_of_search             000112 automatic       fixed bin(17,0)          dcl 140 set ref 297* 299* 314* 324* 335* 347* 357*
                                                                                  365* 374*
dm_error_$bad_specification_type
                                000034 external static fixed bin(35,0)          dcl 203 set ref 598*
dm_error_$beginning_of_collection
                                000036 external static fixed bin(35,0)          dcl 203 ref 499
dm_error_$ci_not_allocated      000040 external static fixed bin(35,0)          dcl 203 ref 458
dm_error_$ci_not_in_collection  000042 external static fixed bin(35,0)          dcl 203 ref 458
dm_error_$end_of_collection     000044 external static fixed bin(35,0)          dcl 203 ref 499
dm_error_$invalid_cursor_position
                                000046 external static fixed bin(35,0)          dcl 203 set ref 458*
dm_error_$no_element            000050 external static fixed bin(35,0)          dcl 203 ref 458 499
dm_error_$programming_error     000052 external static fixed bin(35,0)          dcl 203 set ref 380*
dm_error_$record_not_found      000054 external static fixed bin(35,0)          dcl 203 set ref 350 499*
dm_error_$wrong_cursor_type     000056 external static fixed bin(35,0)          dcl 203 set ref 269*
dm_vector_util_$free_typed_vector_array
                                000032 constant        entry                    external dcl 198 ref 395
entry                           000100 automatic       fixed bin(17,0)          dcl 125 set ref 222* 228* 235* 241* 248* 255* 262*
                                                                                  311 321 332 344 354 362 371 380* 383 383 395 395
er_p_code                              parameter       fixed bin(35,0)          dcl 404 ref 401 406
error_table_$area_too_small     000060 external static fixed bin(35,0)          dcl 203 ref 317 327 339
error_table_$unimplemented_version
                                000062 external static fixed bin(35,0)          dcl 203 set ref 417* 432*
field_table_ptr                 000116 automatic       pointer                  initial dcl 142 in procedure "get" set ref 142* 307*
                                                                                  314* 324* 335* 347* 357* 365* 374*
field_table_ptr           6            based           pointer                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 1-11
                                                                                  in procedure "get" ref 307
file_opening_id           4            based           bit(36)                  level 2 dcl 2-15 set ref 301* 455* 496*
first_record_id                 000105 automatic       bit(36)                  dcl 133 set ref 295* 314* 324* 335* 347* 357* 365*
                                                                                  374*
frp_code                        000214 automatic       fixed bin(35,0)          dcl 489 set ref 493* 496* 499 499 499 499 503*
frp_first_record_id             000216 automatic       bit(36)                  dcl 491 set ref 496* 504
frp_p_initial_record_id                parameter       bit(36)                  dcl 485 set ref 467 494 496*
frp_p_position_from_initial            parameter       fixed bin(17,0)          dcl 487 set ref 467 496*
frp_p_record_cursor_ptr                parameter       pointer                  dcl 483 ref 467 496 496
frp_start_from_edge             000215 automatic       bit(1)                   dcl 490 set ref 494* 496*
gsv_p_maximum_number_of_records        parameter       fixed bin(35,0)          dcl 545 set ref 508 558* 577* 579* 594* 596*
gsv_p_position_from_initial            parameter       fixed bin(17,0)          dcl 547 set ref 508 557* 576* 592* 593
gsv_p_search_in_reverse_order          parameter       bit(1)                   dcl 543 set ref 508 556* 575* 593*
gsv_p_spec_is_always_satisfied         parameter       bit(1)                   dcl 541 set ref 508 555* 574* 591*
gsv_p_spec_is_numeric                  parameter       bit(1)                   dcl 540 set ref 508 554* 573* 590*
gsv_p_spec_is_relative                 parameter       bit(1)                   dcl 539 set ref 508 553* 568* 570* 585* 587*
gsv_p_spec_ptr                         parameter       pointer                  dcl 538 ref 508 550 562 564 564 568 572 581 581 585
                                                                                  589 598
high_record_id_bound            000107 automatic       bit(36)                  dcl 135 set ref 285* 290* 293* 314* 324* 335* 347*
                                                                                  357* 365* 374*
low_record_id_bound             000106 automatic       bit(36)                  dcl 134 set ref 284* 289* 293* 295*
maximum_number_of_records       000111 automatic       fixed bin(35,0)          dcl 138 set ref 275* 314* 324* 335* 347* 357* 365*
                                                                                  374*
myname                          000003 constant        varying char(32)         initial dcl 156 set ref 269* 380* 417* 432* 598*
null                                                   builtin function         dcl 148 ref 142 142 269 269 380 380 1-22 395 417 417
                                                                                  432 432 550 598 598
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-38 ref 574
numeric_specification                  based           structure                level 1 unaligned dcl 4-63
numeric_specification_ptr       000136 automatic       pointer                  dcl 4-70 set ref 589* 592 594 594
p_code                                 parameter       fixed bin(35,0)          dcl 121 set ref 104 225 231 238 245 252 259 265*
                                                                                  387* 406*
p_correct_version                      parameter       char(8)                  dcl 430 set ref 425 432 432*
p_element_id_list_ptr                  parameter       pointer                  dcl 114 set ref 225 231 324* 335*
p_expected_version                     parameter       fixed bin(35,0)          dcl 414 set ref 411 417 417*
p_general_typed_vector_ptr             parameter       pointer                  dcl 117 set ref 245 374*
p_given_version                        parameter       char(8)                  dcl 429 set ref 425 432 432*
p_id_list_ptr                          parameter       pointer                  dcl 111 set ref 104 231 314* 335*
p_number_of_records_processed          parameter       fixed bin(35,0)          dcl 119 set ref 238 242* 245 249* 252 256* 347* 365*
                                                                                  374*
p_received_version                     parameter       fixed bin(35,0)          dcl 413 set ref 411 417 417*
p_record_cursor_ptr                    parameter       pointer                  dcl 113 ref 104 225 231 238 245 252 259 268
p_specification_ptr                    parameter       pointer                  dcl 110 ref 104 225 231 238 245 252 259 274
p_structure_name                       parameter       char                     packed unaligned dcl 428 in procedure
                                                                                  "CHECK_VERSION_CHAR_8" set ref 425 432*
p_structure_name                       parameter       char                     packed unaligned dcl 415 in procedure
                                                                                  "CHECK_VERSION" set ref 411 417*
p_typed_vector_array_ptr               parameter       pointer                  dcl 115 set ref 104 231 383* 395
p_work_area_ptr                        parameter       pointer                  dcl 112 set ref 104 225 231 314* 324* 335* 395*
position_from_initial           000113 automatic       fixed bin(17,0)          dcl 141 set ref 275* 295*
position_number           5            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-63 ref 592
range                     5            based           structure                level 2 packed packed unaligned dcl 4-38
range_size                4            based           fixed bin(35,0)          level 2 dcl 4-63 ref 594 594
rcm_get_by_spec$count           000012 constant        entry                    external dcl 178 ref 347
rcm_get_by_spec$get             000014 constant        entry                    external dcl 180 ref 314
rcm_get_by_spec$get_id          000020 constant        entry                    external dcl 185 ref 324
rcm_get_by_spec$get_records_and_ids
                                000016 constant        entry                    external dcl 182 ref 335
rcm_get_by_spec$position        000022 constant        entry                    external dcl 187 ref 357
rcm_get_opening_info            000010 constant        entry                    external dcl 177 ref 301
rcm_update_by_spec$delete       000024 constant        entry                    external dcl 190 ref 365
rcm_update_by_spec$modify       000026 constant        entry                    external dcl 193 ref 374
record_collection_opening_info         based           structure                level 1 dcl 1-11
record_collection_opening_info_ptr
                                000126 automatic       pointer                  initial dcl 1-22 set ref 301* 305 307 1-22*
record_cursor                          based           structure                level 1 dcl 2-15
record_cursor_ptr               000130 automatic       pointer                  dcl 2-28 set ref 268* 269 269 272 280* 285 289 295*
                                                                                  301 301 314* 324* 335* 347* 357* 365* 374*
record_id                 6            based           bit(36)                  level 2 dcl 2-15 set ref 285 289 455*
search_in_reverse_order         000104 automatic       bit(1)                   dcl 130 set ref 275* 281 297
search_specification                   based           structure                level 1 unaligned dcl 4-38
search_specification_ptr        000134 automatic       pointer                  dcl 4-58 set ref 572* 574 575 577 577 577
size                      5(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-38 ref 577 577
spec_is_always_satisfied        000103 automatic       bit(1)                   dcl 128 set ref 275* 314* 324* 335* 347* 357* 365*
                                                                                  374*
spec_is_numeric                 000102 automatic       bit(1)                   dcl 127 set ref 275*
spec_is_relative                000101 automatic       bit(1)                   dcl 126 set ref 275* 277
specification_head                     based           structure                level 1 unaligned dcl 3-10
specification_head_ptr          000132 automatic       pointer                  dcl 3-18 set ref 274* 275* 314* 324* 335* 347* 357*
                                                                                  365* 374*
sub_err_                        000030 constant        entry                    external dcl 197 ref 269 380 417 432 598
type                      5            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 4-38 in procedure "get" ref
                                                                                  575 577
type                      1            based           fixed bin(17,0)          level 2 in structure "specification_head" packed
                                                                                  packed unaligned dcl 3-10 in procedure "get" set
                                                                                  ref 564 564 568 581 581 585 598*
type                                   based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 2-15 in procedure "get" set ref 269
                                                                                  269*
typed_vector_array_ptr          000114 automatic       pointer                  initial dcl 142 set ref 142* 314* 335* 383 395 395
                                                                                  395*
version                                based           char(8)                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 1-11
                                                                                  in procedure "get" set ref 305*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 2-15 in procedure "get" ref 272
version                                based           fixed bin(35,0)          level 2 in structure "specification_head" dcl 3-10
                                                                                  in procedure "get" set ref 562*
vp_code                         000204 automatic       fixed bin(35,0)          dcl 452 set ref 454* 455* 458 458 458 458 462*
vp_p_record_cursor_ptr                 parameter       pointer                  dcl 451 ref 441 455 455 455

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
BEGINNING_OF_COLLECTION_RECORD_ID      internal static bit(36)                  initial dcl 2-32
LOW_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 5-8
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 3-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 3-22
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 7-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 7-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 7-54
collection_manager_$create_file 000000 constant        entry                    external dcl 7-56
collection_manager_$delete      000000 constant        entry                    external dcl 7-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 7-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 7-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 7-60
collection_manager_$get         000000 constant        entry                    external dcl 7-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 7-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-77
collection_manager_$get_header  000000 constant        entry                    external dcl 7-83
collection_manager_$get_portion 000000 constant        entry                    external dcl 7-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 7-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 7-93
collection_manager_$modify      000000 constant        entry                    external dcl 7-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 7-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 7-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 7-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 7-113
collection_manager_$put         000000 constant        entry                    external dcl 7-115
collection_manager_$put_header  000000 constant        entry                    external dcl 7-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 7-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 7-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 7-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 7-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-135
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 4-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 4-60

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001471 constant        entry                    internal dcl 411 ref 272 562
CHECK_VERSION_CHAR_8            001565 constant        entry                    internal dcl 425 ref 305
ERROR_RETURN                    001460 constant        entry                    internal dcl 401 ref 303 317 327 339 350 359 368 377
                                                                                  458 462 499 503
FINISH                          001422 constant        entry                    internal dcl 393 ref 309 389 407
FIRST_RECORD_TO_PROCESS         001746 constant        entry                    internal dcl 467 ref 295
GET_SPEC_VALUES                 002035 constant        entry                    internal dcl 508 ref 275
JOIN                            000501 constant        label                    dcl 265 ref 223 229 236 243 250 257 263
MAIN_RETURN                     001420 constant        label                    dcl 390 ref 408
VERIFY_POSITION                 001667 constant        entry                    internal dcl 441 ref 280
count                           000436 constant        entry                    external dcl 252
delete                          000365 constant        entry                    external dcl 238
get                             000255 constant        entry                    external dcl 104
get_id                          000304 constant        entry                    external dcl 225
get_records_and_ids             000334 constant        entry                    external dcl 231
modify                          000413 constant        entry                    external dcl 245
position                        000463 constant        entry                    external dcl 259

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2750        3036    2370        2760
Length      3426    2370        66         354     357           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get                                 492 external procedure  is an external procedure.  
on unit on line 309                  64 on unit               
FINISH                               72 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure get.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure get.  
CHECK_VERSION_CHAR_8                    internal procedure  shares stack frame of external procedure get.  
VERIFY_POSITION                         internal procedure  shares stack frame of external procedure get.  
FIRST_RECORD_TO_PROCESS                 internal procedure  shares stack frame of external procedure get.  
GET_SPEC_VALUES                         internal procedure  shares stack frame of external procedure get.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get                      000100 entry                       get
                         000101 spec_is_relative            get
                         000102 spec_is_numeric             get
                         000103 spec_is_always_satisfied    get
                         000104 search_in_reverse_order     get
                         000105 first_record_id             get
                         000106 low_record_id_bound         get
                         000107 high_record_id_bound        get
                         000110 code                        get
                         000111 maximum_number_of_records   get
                         000112 direction_of_search         get
                         000113 position_from_initial       get
                         000114 typed_vector_array_ptr      get
                         000116 field_table_ptr             get
                         000126 record_collection_opening_info_ptr
                                                            get
                         000130 record_cursor_ptr           get
                         000132 specification_head_ptr      get
                         000134 search_specification_ptr    get
                         000136 numeric_specification_ptr   get
                         000204 vp_code                     VERIFY_POSITION
                         000214 frp_code                    FIRST_RECORD_TO_PROCESS
                         000215 frp_start_from_edge         FIRST_RECORD_TO_PROCESS
                         000216 frp_first_record_id         FIRST_RECORD_TO_PROCESS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              r_le_a              call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          signal_op           enable_op           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get_id    dm_vector_util_$free_typed_vector_array                     rcm_get_by_spec$count
rcm_get_by_spec$get           rcm_get_by_spec$get_id        rcm_get_by_spec$get_records_and_ids
rcm_get_by_spec$position      rcm_get_opening_info          rcm_update_by_spec$delete     rcm_update_by_spec$modify
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_specification_type                            dm_error_$beginning_of_collection
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$end_of_collection
dm_error_$invalid_cursor_position                           dm_error_$no_element          dm_error_$programming_error
dm_error_$record_not_found    dm_error_$wrong_cursor_type   error_table_$area_too_small
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    142 000241    1   22 000244       104 000247       222 000274       223 000276       225 000277       228 000323
    229 000325       231 000326       235 000355       236 000357       238 000360       241 000402       242 000404
    243 000405       245 000406       248 000430       249 000432       250 000433       252 000434       255 000453
    256 000455       257 000456       259 000457       262 000476       263 000500       265 000501       267 000502
    268 000503       269 000506       272 000565       274 000602       275 000606       277 000610       280 000613
    281 000615       284 000620       285 000621       286 000624       289 000625       290 000630       292 000631
    293 000632       295 000635       297 000637       299 000645       301 000647       303 000665       305 000671
    307 000713       309 000716       311 000740       314 000743       317 001001       320 001010       321 001011
    324 001013       327 001046       330 001055       332 001056       335 001060       339 001120       342 001127
    344 001130       347 001132       350 001163       353 001172       354 001173       357 001175       359 001224
    361 001230       362 001231       365 001233       368 001264       370 001270       371 001271       374 001273
    377 001327       379 001333       380 001334       383 001403       387 001412       389 001414       390 001420
    393 001421       395 001427       398 001457       401 001460       406 001462       407 001464       408 001470
    411 001471       417 001502       422 001564       425 001565       432 001576       437 001666       441 001667
    454 001671       455 001672       458 001721       462 001741       463 001744       465 001745       467 001746
    493 001750       494 001751       496 001754       499 002002       503 002022       504 002025       506 002031
    508 002035       550 002037       553 002043       554 002044       555 002045       556 002047       557 002050
    558 002052       559 002054       562 002055       564 002101       568 002113       570 002120       572 002121
    573 002122       574 002123       575 002131       576 002136       577 002141       579 002154       580 002156
    581 002157       585 002163       587 002170       589 002171       590 002172       591 002174       592 002175
    593 002201       594 002203       596 002207       597 002211       598 002212       605 002276


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
