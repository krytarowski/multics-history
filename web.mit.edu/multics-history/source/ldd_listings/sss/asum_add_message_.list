	COMPILATION LISTING OF SEGMENT asum_add_message_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/04/86  1441.5 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(85-05-31,Swenson), approve(86-07-25,MCR7302),
       10*     audit(86-08-13,EJSharpe), install(86-09-04,MR12.0-1147):
       11*     Fixed to ensure all sending process security-relevant information is set
       12*     in message segment entry.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* asum_add_message_ -- procedure that appends a message to the
       17*   database for delivery. This is the gate target, effectively */
       18 
       19 /* format: style2,indcomtxt */
       20 
       21 asum_add_message_:
       22      procedure (P_add_info_ptr, P_code);
       23 
       24 /* Written 2/20/85 BIM */
       25 /* Modified 1985-04, BIM: changed for new mseg_ calling sequences. */
       26 
       27 /**** NOTE: this implements the initial strategy of keeping all the destination
       28*      information in the _system segment. This limits to 16K messages
       29*      outstanding. For volume applications, something better is needed.
       30*
       31*      Also, note that this locks the database for the entire operation,
       32*      making no use of the potential lockless update.
       33**/
       34 
       35 	declare P_add_info_ptr	 pointer;
       36 	declare P_code		 fixed bin (35);
       37 
       38 
       39 	declare 1 add_info		 aligned like as_user_message_add_info;
       40 	declare code		 fixed bin (35);
       41 	declare message_added	 bit (1) aligned;
       42 	declare hx		 fixed bin;
       43 	declare ms_ptr		 pointer;
       44 	declare start_n_segments	 fixed bin;
       45 	declare sx		 fixed bin;
       46 
       47 /* Entries */
       48 
       49 	declare asum_error_		 entry options (variable);
       50 	declare asum_find_segment_	 entry (fixed binary, pointer);
       51 	declare asum_create_segment_	 entry (fixed binary, pointer);
       52 	declare get_group_id_	 entry () returns (char (32));
       53 	declare get_process_authorization_
       54 				 entry () returns (bit (72) aligned);
       55 	declare get_process_max_authorization_
       56 				 entry () returns (bit (72) aligned);
       57 	declare set_lock_$lock	 entry (bit (36) aligned, fixed binary, fixed binary (35));
       58 	declare set_lock_$unlock	 entry (bit (36) aligned, fixed binary (35));
       59 
       60 	declare error_table_$bad_arg	 fixed bin (35) ext static;
       61 	declare error_table_$notalloc	 fixed bin (35) ext static;
       62 
       63 	dcl     addr		 builtin;
       64 	dcl     bin		 builtin;
       65 	dcl     bit		 builtin;
       66 	dcl     hbound		 builtin;
       67 	dcl     stacq		 builtin;
       68 	dcl     unspec		 builtin;
       69 
  1     1 /* Begin include file as_user_message_system.incl.pl1 BIM 1985-01-11 */
  1     2 /* format: style4 */
  1     3 
  1     4 /**** Per-system and per-user information on the as_user_message segments */
  1     5 
  1     6 /**** Declaration used to construct the name of one of the set of segments */
  1     7 
  1     8 declare  1 as_user_message_segment_name unaligned,
  1     9 	 2 constant char (16),			/* as_user_message_ */
  1    10 	 2 index picture "99";
  1    11 
  1    12 declare  AS_USER_MESSAGE_SEGMENT_NAME_CONSTANT char (16) init ("as_user_message_") int static options (constant);
  1    13 
  1    14 /**** as_user_messages (mis)-use the pad bits in a message segment
  1    15*      message ID to identify which of one of a series of segments
  1    16*      to find the message in. */
  1    17 
  1    18 declare  1 as_user_message_id aligned,			/* use UNSPEC, not based (addr) */
  1    19 	 2 segment_index fixed bin (9) unsigned unaligned,
  1    20 	 2 pad bit (11) unaligned,
  1    21 	 2 pad_clock bit (52) unaligned;
  1    22 
  1    23 /**** Data stored in the as_user_message_system segment.
  1    24*      This is the shared overhead database, including the
  1    25*      associative memory of messages and destination processes. */
  1    26 
  1    27 declare  AS_USER_MESSAGE_SYSTEM_NAME char (32) init ("as_user_message_system") int static options (constant);
  1    28 
  1    29 declare  as_user_message_system_info_ptr pointer;
  1    30 declare  1 as_user_message_system_info aligned based (as_user_message_system_info_ptr),
  1    31 	 2 header aligned,
  1    32 	   3 sentinel char (8) aligned,		/* Version, but mostly validity check */
  1    33 	   3 time_of_bootload fixed bin (71),		/* was this segment initialized in this bootload? */
  1    34 	   3 lock bit (36) aligned,			/* on segment creation/deletion */
  1    35 	   3 n_segments fixed bin,			/* total created */
  1    36 
  1    37 	   3 highest_in_use fixed bin (35),		/* update with stacq */
  1    38 	 2 pad (9) bit (36) aligned,
  1    39 	 2 destination_am (16000) aligned, /* each entry is 16 words. Listen UP, compiler */
  1    40 	   3 process_id bit (36) aligned,
  1    41 	   3 ring fixed bin (3) unsigned unaligned,
  1    42 	   3 reader_deletes bit (1) unaligned,
  1    43 	   3 pad bit (32) unaligned,
  1    44 	   3 handle bit (72) aligned,
  1    45 	   3 message_id bit (72) aligned,
  1    46 	   3 group_id char (32) unaligned,
  1    47 	   3 access_class bit (72) aligned;
  1    48 
  1    49 declare  AS_USER_ANY_PROCESS_ID bit (36) aligned init ("777777777777"b3) int static options (constant);
  1    50 
  1    51 
  1    52 /**** + To look for a message, do the following:
  1    53*      initialize the message_id to 72 1's.
  1    54*      loop on the process_id_list, setting px as index;
  1    55*      if the process_id (px) is ANY_PROCESS_ID or the target process id then do;
  1    56*      if handle_list (px) is the desired handle then do;
  1    57*      if the process_id match was exact then
  1    58*      message_id = min (message_id, message_id (px));
  1    59*      otherwise do;
  1    60*      read out the mesage for message_id (px),
  1    61*      determine if it is really for target_process. If so,
  1    62*      message_id = min (message_id, message_id (px));
  1    63*      end;
  1    64*      end;
  1    65*      end;
  1    66*
  1    67*      If message_id = 72 1's, then there is no message destined for this handle
  1    68*      for this process.
  1    69*
  1    70*      Otherwise, message_id is the id of the first message for this handle.
  1    71**/
  1    72 
  1    73 declare  AS_USER_MESSAGE_SYSTEM_SENTINEL char (8) aligned init ("asumsys1") int static options (constant);
  1    74 
  1    75 /**** Data for each user process */
  1    76 
  1    77 /**** *system variable to find this stuff with */
  1    78 
  1    79 declare  as_user_message_perprocess_info_ptr pointer;
  1    80 
  1    81 declare  1 as_user_message_perprocess_info aligned based (as_user_message_perprocess_info_ptr),
  1    82 	 2 sentinel char (8) aligned,
  1    83 	 2 mseg_ptr (0:99) pointer options (packed);	/* for mseg_ */
  1    84 
  1    85 declare  AS_USER_MESSAGE_PROCESS_SENTINEL char (8) aligned init ("asumprc1") int static options (constant);
  1    86 
  1    87 /* End include file as_user_message_system.incl.pl1 */
       70 
  2     1 /* Begin include file as_user_message_add.incl.pl1 BIM 1985-01-12 */
  2     2 /* format: style4 */
  2     3 
  2     4 declare as_user_message_add_info_ptr pointer;
  2     5 declare 1 as_user_message_add_info aligned based (as_user_message_add_info_ptr),
  2     6         2 version char (8) aligned,
  2     7         2 message_info aligned,
  2     8           3 message_ptr pointer,
  2     9 	3 message_length fixed bin (18),
  2    10 	3 pad bit (36) aligned,
  2    11 	3 message_access_class bit (72) aligned,
  2    12 	3 message_id bit (72) aligned, /* output */
  2    13         2 destination_info aligned,
  2    14           3 group_id char (32) unal, /* stars permitted */
  2    15 	3 process_id bit (36) aligned, /* (36)"1"b for ANY */
  2    16 	3 handle bit (72) aligned, /* may NOT be zero */
  2    17 	3 ring fixed bin (3),
  2    18 	3 reader_deletes bit (1) aligned;
  2    19 
  2    20 declare AS_USER_MESSAGE_ADD_INFO_VERSION_1
  2    21         char (8) init ("auma0001") int static options (constant);
  2    22 
  2    23 /* End include file as_user_message_add.incl.pl1 */
       71 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1985 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* Begin include file asum_data_.incl.pl1 */
  3     7 /* Definitions in asum_data_ (as_user_message_data_) BIM 1985-01-17 */
  3     8 /* format: style3 */
  3     9 
  3    10 declare	asum_data_$acl_entries
  3    11 			bit (36) aligned ext;	/* base acl array here */
  3    12 declare	asum_data_$db_dir	char (168) ext;
  3    13 declare	asum_data_$db_multiclass
  3    14 			bit (1) aligned ext;
  3    15 declare	asum_data_$n_acl_entries
  3    16 			fixed bin ext;
  3    17 declare	asum_data_$db_cbi	bit (36) aligned ext;	/* No need to declare the whole structure here */
  3    18 declare	asum_data_$db_dir_cbi
  3    19 			bit (36) aligned ext;	/* No need to declare the whole structure here */
  3    20 declare	asum_data_$db_dir_rb
  3    21 			(2) fixed bin (3) ext;
  3    22 declare	asum_data_$db_rb	(3) fixed bin (3) ext;
  3    23 declare	asum_data_$db_locked
  3    24 			bit (1) aligned ext;
  3    25 declare	asum_data_$process_info_ptr
  3    26 			pointer static ext;
  3    27 declare	asum_data_$system_info_ptr
  3    28 			pointer static ext;
  3    29 declare	asum_data_$entry_ring
  3    30 			fixed bin (3) static ext;
  3    31 declare	asum_data_$lock_id	bit (36) aligned ext;
  3    32 declare	asum_data_$process_id
  3    33 			bit (36) aligned ext;
  3    34 
  3    35 /* End include file asum_data_.incl.pl1 */
       72 
  4     1 /* BEGIN INCLUDE FILE ... mseg_entries.incl.pl1 */
  4     2 /* Created:  April 1985 by G. Palter */
  4     3 
  4     4 /* format: style3,linecom,idind30 */
  4     5 
  4     6 /* Message segment primitive operations --
  4     7*
  4     8*   The first argument of all of these entrypoints is a pointer to the mseg_operation describing the segment and, when
  4     9*   appropriate, the message to be manipulated by the operation.  (See mseg_operation.incl.pl1 for additional information.)
  4    10*
  4    11*   The last argument is always a standard system status code.
  4    12*
  4    13*   For each operation defined below, the fields in the mseg_operation which must be supplied by the caller are listed
  4    14*   along with a brief description of the additional arguments, if any.  For greater detail on the use of these
  4    15*   entrypoints, refer to mseg_mbx_ms_gate_target_.pl1 which is the classic user of these entrypoints. */
  4    16 
  4    17 
  4    18 declare
  4    19      /*** Add (or update) ACL entries -- OP.mseg_pathname; general_extended_acl_ptr (I) */
  4    20 	mseg_$add_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
  4    21 
  4    22 declare
  4    23      /*** Add a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
  4    24 	mseg_$add_message		entry (pointer, fixed binary (35));
  4    25 
  4    26 declare
  4    27      /*** Change the names -- OP.mseg_pathname or OP.mseg_ptr; old_name_to_delete (I), new_name_to_add (I) */
  4    28 	mseg_$chname_seg		entry (pointer, character (*), character (*), fixed binary (35));
  4    29 
  4    30 declare
  4    31      /*** Close the segment -- OP.mseg_ptr (optional), OP.mseg_index (optional); mseg_index_table_ptr (I/O)
  4    32*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
  4    33 	mseg_$close_seg		entry (pointer, pointer, fixed binary (35));
  4    34 
  4    35 declare
  4    36      /*** Compact the segment -- OP.mseg_ptr; compaction_ratio (I) */
  4    37 	mseg_$compact_seg		entry (pointer, float binary, fixed binary (35));
  4    38 
  4    39 declare
  4    40      /*** Copy the segment -- OP.mseg_ptr; target_mseg_operation_ptr (I) (TOP.mseg_ptr), error_on_target (O) */
  4    41 	mseg_$copy_seg		entry (pointer, pointer, bit (1) aligned, fixed binary (35));
  4    42 
  4    43 declare
  4    44      /*** Count the accessible messages -- OP.mseg_ptr, OP.access_info; n_messages (O) */
  4    45 	mseg_$count_messages	entry (pointer, fixed binary, fixed binary (35));
  4    46 
  4    47 declare
  4    48      /*** Create the segment -- OP.mseg_pathname; general_extended_acl_ptr (I) --
  4    49*	     If general_extended_acl_ptr is null, the default ACL for the type of segment to be created will be used */
  4    50 	mseg_$create_seg		entry (pointer, pointer, fixed binary (35));
  4    51 
  4    52 declare
  4    53      /*** Delete ACL entries -- OP.mseg_pathname; general_delete_acl_ptr (I) --
  4    54*	     If general_delete_acl_ptr is null, the entire ACL will be deleted */
  4    55 	mseg_$delete_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
  4    56 
  4    57 declare
  4    58      /*** Delete a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
  4    59 	mseg_$delete_message	entry (pointer, fixed binary (35));
  4    60 
  4    61 declare
  4    62      /*** Delete the segment -- OP.mseg_ptr (surprise); mseg_index_table_ptr (I/O)
  4    63*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
  4    64 	mseg_$delete_seg		entry (pointer, pointer, fixed binary (35));
  4    65 
  4    66 declare
  4    67      /*** Get the salvaged flag -- OP.mseg_ptr; segment_was_salvaged (O) */
  4    68 	mseg_$get_salvaged_flag_seg	entry (pointer, bit (1) aligned, fixed binary (35));
  4    69 
  4    70 declare
  4    71      /*** Get the wakeup acceptance state -- OP.mseg_ptr, OP.wakeup_state.version */
  4    72 	mseg_$get_wakeup_state_seg	entry (pointer, fixed binary (35));
  4    73 
  4    74 declare
  4    75      /*** Initiate the segment -- OP.mseg_pathname */
  4    76 	mseg_$initiate_seg		entry (pointer, fixed binary (35));
  4    77 
  4    78 declare
  4    79      /*** List the entire ACL -- OP.mseg_pathname; general_extended_acl_ptr (O)
  4    80*	     The general_extended_acl is allocated in the system free area */
  4    81 	mseg_$list_acl_seg		entry (pointer, pointer, fixed binary (35));
  4    82 
  4    83 declare
  4    84      /*** List individual ACL entries -- OP.mseg_pathname; general_extended_acl_ptr (I) */
  4    85 	mseg_$list_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
  4    86 
  4    87 declare
  4    88      /*** Open the segment -- OP.mseg_ptr; mseg_index_table_ptr (I/O)
  4    89*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
  4    90 	mseg_$open_seg		entry (pointer, pointer, fixed binary (35));
  4    91 
  4    92 declare
  4    93      /*** Read (and optionally delete) a message -- OP.mseg_ptr, OP.access_info, OP.message_info; users_area_ptr (I) */
  4    94 	mseg_$read_message		entry (pointer, pointer, fixed binary (35));
  4    95 
  4    96 declare
  4    97      /*** Replace the ACL -- OP.mseg_pathname; general_extended_acl_ptr (I) --
  4    98*	     If general_extended_acl_ptr is null, the new ACL will be empty */
  4    99 	mseg_$replace_acl_seg	entry (pointer, pointer, fixed binary (35));
  4   100 
  4   101 declare
  4   102      /*** Reset the salvaged flag -- OP.mseg_ptr, OP.access_info */
  4   103 	mseg_$reset_salvaged_flag_seg entry (pointer, fixed binary (35));
  4   104 
  4   105 declare
  4   106      /*** Reset wakeup acceptance (i.e., turn it off) -- OP.mseg_ptr */
  4   107 	mseg_$reset_wakeup_state_seg	entry (pointer, fixed binary (35));
  4   108 
  4   109 declare
  4   110      /*** Set the max length -- OP.mseg_ptr (surprise); new_max_length (I) */
  4   111 	mseg_$set_max_length_seg	entry (pointer, fixed binary (19), fixed binary (35));
  4   112 
  4   113 declare
  4   114      /*** Set the safety switch -- OP.mseg_pathname or OP.mseg_ptr; new_safety_switch (I) */
  4   115 	mseg_$set_safety_switch_seg	entry (pointer, bit (1) aligned, fixed binary (35));
  4   116 
  4   117 declare
  4   118      /*** Set the wakeup acceptance state -- OP.mseg_ptr, OP.wakeup_state */
  4   119 	mseg_$set_wakeup_state_seg	entry (pointer, fixed binary (35));
  4   120 
  4   121 declare
  4   122      /*** Update a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
  4   123 	mseg_$update_message	entry (pointer, fixed binary (35));
  4   124 
  4   125 /* END INCLUDE FILE ... mseg_entries.incl.pl1 */
       73 
  5     1 /* Begin include file mseg_data_.incl.pl1 BIM 1985-04-15 */
  5     2 /* format: style4 */
  5     3 
  5     4 declare  mseg_data_$lock_id bit (72) aligned external;
  5     5 declare  mseg_data_$block_size fixed bin (35) ext static;
  5     6 declare  mseg_data_$max_message_size fixed bin (35) ext static;
  5     7 declare  mseg_data_$template_operation bit (36) aligned external static; /* like mseg_operation */
  5     8 declare  mseg_data_$admin_ring fixed binary (3) external;
  5     9 declare  mseg_data_$execution_ring fixed bin (3) ext static;
  5    10 declare  mseg_data_$process_max_authorization bit (72) aligned ext static;
  5    11 declare  mseg_data_$group_id char (32) unaligned external static;
  5    12 
  5    13 /* End include file mseg_data_.incl.pl1 */
       74 
  6     1 /* BEGIN INCLUDE FILE ... mseg_operation.incl.pl1 */
  6     2 
  6     3 /* format: style3,idind30,linecom */
  6     4 
  6     5 /**** Created 1985-04-16, BIM: from Pandolf's  mseg_access_operation */
  6     6 
  6     7 /**** NOTES:
  6     8*      The caller of mseg_ must set mseg_operation.access_operation to record
  6     9*      the type of access checking it has performed and which mseg_ should
  6    10*      perform when needed (i.e., for those entrypoints which operate on
  6    11*      messages like mseg_$read_message).
  6    12*
  6    13*      mseg_operation.operation is reserved explicitly for use by mseg_ and
  6    14*      its underlying modules.
  6    15*
  6    16*      You must also include entry_access_info, mseg_message_info, and
  6    17*      mbx_wakeup_state along with this include file. */
  6    18 
  6    19 dcl	mseg_operation_ptr		pointer;
  6    20 dcl	MSEG_OPERATION_VERSION_1	fixed bin internal static options (constant) init (1);
  6    21 dcl	MSEG_TYPE_MBX		fixed bin init (1) internal static options (constant);
  6    22 dcl	MSEG_TYPE_MS		fixed bin init (2) internal static options (constant);
  6    23 
  6    24 dcl	1 mseg_operation		based (mseg_operation_ptr) aligned,
  6    25 	  2 version		fixed binary,	/* current version is MSEG_OPERATION_VERSION_1 */
  6    26 	  2 type			fixed binary,	/* MBX or MS */
  6    27 	  2 access_operation	fixed binary,	/* type of access checks required for the operation */
  6    28 	  2 operation		bit (36) aligned,	/* for use by mseg_ and underlying modules */
  6    29 	  2 caller		aligned,		/* always collected in gate target */
  6    30 	    3 validation_level	fixed bin (3),
  6    31 	    3 privileges		bit (18) aligned,	/* factored for speed */
  6    32 	    3 pad_align_double	fixed bin (71),	/* just to force alignment */
  6    33 	    3 authorization		bit (72) aligned,	/* must be 2word aligned */
  6    34 	    3 max_authorization	bit (72) aligned,
  6    35 	    3 group_id		char (32) unaligned,
  6    36 	  2 flags			aligned,
  6    37 	    3 mseg_pathname_valid	bit (1) unaligned,
  6    38 	    3 mseg_ptr_valid	bit (1) unaligned,
  6    39 	    3 mseg_index_valid	bit (1) unaligned,
  6    40 	    3 access_info_valid	bit (1) unaligned,
  6    41 	    3 md_ptr_valid		bit (1) unaligned,
  6    42 	    3 message_info_valid	bit (1) unaligned,	/* note -- for some operations not all fields are used */
  6    43 	    3 wakeup_state_valid	bit (1) unaligned,
  6    44 	    3 suppress_access_checks	bit (1) unaligned,	/* set by privileged interfaces, suppresses ALL access checking */
  6    45 	    3 call_admin_gate	bit (1) unaligned,	/* we is in ring 1, boss */
  6    46 	    3 only_own_access	bit (1) unaligned,	/* the user had o rather than r/d */
  6    47 	    3 add_message_info_all_valid
  6    48 				bit (1) unaligned,	/* Believe ALL the fields in message info on an add */
  6    49 	    3 pad			bit (24) unaligned,
  6    50 	  2 dir_name		char (168) unaligned,
  6    51 	  2 entryname		char (32) unaligned,
  6    52 	  2 mseg_ptr		pointer,
  6    53 	  2 md_ptr		pointer,		/* message descriptor */
  6    54 	  2 mseg_index		fixed bin,
  6    55 	  2 access_info		aligned like entry_access_info,
  6    56 	  2 message_info		aligned like mseg_message_info,
  6    57 	  2 wakeup_state		aligned like mseg_wakeup_state;
  6    58 
  6    59 /* END INCLUDE FILE ... mseg_operation.incl.pl1 */
       75 
  7     1 /* Begin include file mseg_access_operation.incl.pl1 BIM 1098-04-18 */
  7     2 /* format: style3,idind30 */
  7     3 
  7     4 declare	mseg_access_operation_ptr	pointer;
  7     5 declare	1 mseg_access_operation	aligned based (mseg_access_operation_ptr),
  7     6 	  2 access_operation	bit (36) aligned,
  7     7 	  2 required_modes		bit (36) aligned,	/* ""b if no modes required */
  7     8 	  2 flags			unaligned,
  7     9 	    3 dont_audit		bit (1) unaligned,
  7    10 	    3 dont_audit_success	bit (1) unaligned,
  7    11 	    3 non_null_modes	bit (1) unaligned,
  7    12 	    3 no_modes		bit (1) unaligned,
  7    13 	    3 o_for_r		bit (1) unaligned,	/* if no r, o will do */
  7    14 	    3 o_for_d		bit (1) unaligned,	/* if no d, o will do */
  7    15 	    3 admin		bit (1) unaligned,
  7    16 	    3 dir_modes		bit (1) unaligned, /* dir mode is needed */
  7    17 	    3 dir_modes_or_ex_modes   bit (1) unaligned, /* if not ex-mode, dir mode */
  7    18 	    3 pad			bit (9) unaligned,
  7    19             2 required_dir_modes        bit (3) unaligned,
  7    20 	  2 pad1			bit (6) unaligned,
  7    21 	  2 mseg_access_op_index	fixed bin (9) uns unaligned,
  7    22 	  2 pad2			bit (36) aligned;
  7    23 
  7    24 declare	(
  7    25 	MSEG_READ_SEG_ATTR		init (1),		/* any attribute */
  7    26 	MSEG_MODIFY_SEG_ATTR	init (2),		/* any attribute, access or no */
  7    27 	MSEG_COPY_SEG		init (3),		/* reference a segment for copying */
  7    28 	MSEG_CREATE_SEG		init (4),		/* check on candidate parent dir */
  7    29 	MSEG_ADD_MESSAGE		init (5),		/* append */
  7    30 	MSEG_MODIFY_MESSAGE		init (6),		/* update/delete */
  7    31 	MSEG_ACCEPT_WAKEUPS		init (7),		/* what the sign says */
  7    32 	MSEG_READ_MESSAGE		init (8)		/* ditto */
  7    33 	)			fixed bin (9) int static options (constant);
  7    34 
  7    35 dcl	1 mseg_access_operations_$data
  7    36 				(25) external static aligned like mseg_access_operation;
  7    37 
  7    38 /* End include file mseg_access_operation.incl.pl1 */
       76 
  8     1 /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  8     2 /* Created:  April 1985 by G. Palter */
  8     3 
  8     4 /* format: style3,linecom */
  8     5 
  8     6 /* Description of the wakeup state of a message segment --
  8     7*
  8     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  8     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  8    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  8    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  8    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  8    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  8    14*
  8    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  8    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  8    17*   the status code error_table_$messages_off.
  8    18*
  8    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  8    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  8    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  8    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  8    23 
  8    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  8    25 	  2 version	character (8) unaligned,
  8    26 	  2 flags		aligned,
  8    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  8    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  8    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  8    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  8    31 	    3 pad		bit (34) unaligned,
  8    32 	  2 pad		bit (36) aligned,
  8    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  8    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  8    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  8    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  8    37 
  8    38 declare	mseg_wakeup_state_ptr
  8    39 			pointer;
  8    40 
  8    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  8    42 			character (8) static options (constant) initial ("msegwkp1");
  8    43 
  8    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
       77 
  9     1 /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  9     2 /* format: style3,idind30 */
  9     3 
  9     4 /* structure returned when message is read from a message segment */
  9     5 
  9     6 
  9     7 dcl	mseg_message_info_ptr	pointer;
  9     8 
  9     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  9    10 	  2 version		char (8) aligned,
  9    11 	  2 message_code		fixed bin,
  9    12 	  2 control_flags		unaligned,
  9    13 	    3 own			bit (1),
  9    14 	    3 delete		bit (1),
  9    15 	    3 pad			bit (34),
  9    16 	  2 ms_ptr		ptr,		/* pointer to message */
  9    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  9    18 	  2 ms_id			bit (72),		/* unique ID of message */
  9    19 						/* input in some cases */
  9    20 	  2 ms_access_class		bit (72),		/* message access class */
  9    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  9    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  9    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  9    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  9    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  9    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  9    27 
  9    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  9    29 
  9    30 declare	(
  9    31 	MSEG_READ_FIRST		init (1),
  9    32 	MSEG_READ_LAST		init (2),
  9    33 	MSEG_READ_SPECIFIED		init (3),
  9    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  9    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  9    36 	fixed bin int static options (constant);
  9    37 
  9    38 declare  (MSEG_READ_OWN		init ("1"b),
  9    39 	MSEG_READ_DELETE		init ("01"b)
  9    40 	)			bit (36) aligned internal static options (constant);
  9    41 
  9    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
       78 
 10     1 /* BEGIN INCLUDE FILE ... entry_access_info.incl.pl1 */
 10     2 
 10     3 /*
 10     4*   Written  03/22/85 by M. Pandolf
 10     5*   Modified 1985-04-19, BIM: added parent access class.
 10     6**/
 10     7 
 10     8 dcl  entry_access_info_ptr pointer;
 10     9 dcl  ENTRY_ACCESS_INFO_VERSION_1 char (8) internal static options (constant)
 10    10      init ("eainf001");
 10    11 
 10    12 dcl 1 entry_access_info aligned based (entry_access_info_ptr),
 10    13     2 version char (8),				/* = ENTRY_ACCESS_INFO_VERSION_1 */
 10    14     2 type fixed bin,				/* see status_structures.incl.pl1 */
 10    15     2 dir_name char (168) unaligned,			/* parent of this entry */
 10    16     2 entryname char (32) unaligned,			/* primary name of this entry */
 10    17     2 uid bit (36) aligned,				
 10    18     2 ring_brackets (3) fixed bin (3),			/* for dirs, the dir ring brackets are here */
 10    19     2 extended_ring_brackets (3) fixed bin (3),		/* not-yet-implemented x-rb's */
 10    20     2 effective_access_modes bit (36) aligned,		/* for dirs, dir mode is here */
 10    21     2 extended_access_modes bit (36) aligned,		/* always null for dirs */
 10    22     2 access_class bit (72) aligned,			/* for multiclass, max access class */
 10    23     2 parent_access_class bit (72) aligned,		/* for multiclass, this is effectively the min access class */
 10    24     2 multiclass bit (1) aligned;
 10    25 
 10    26 /* END INCLUDE FILE ... entry_access_info.incl.pl1 */
       79 
       80 
       81 
       82 	as_user_message_add_info_ptr = P_add_info_ptr;
       83 	add_info = as_user_message_add_info;		/* Copy the parm. We will copy back out */
       84 	as_user_message_system_info_ptr = asum_data_$system_info_ptr;
       85 	as_user_message_perprocess_info_ptr = asum_data_$process_info_ptr;
       86 	if add_info.process_id = ""b | add_info.handle = ""b
       87 	then call RETURN_ERROR (error_table_$bad_arg);
       88 
       89 	call lock_database;
       90 	do hx = 1 to hbound (as_user_message_system_info.destination_am, 1);
       91 	     if stacq (as_user_message_system_info.destination_am (hx).process_id, add_info.process_id, ""b)
       92 	     then go to HAVE_HX;
       93 	end;
       94 
       95 	call asum_error_ (0, "asum_add_message_", "destination AM full.");
       96 HAVE_HX:
       97 	if hx > as_user_message_system_info.highest_in_use
       98 	then begin;
       99 		declare his		 bit (36) aligned based (his_ptr);
      100 		declare his_ptr		 pointer;
      101 		declare new_his		 bit (36) aligned;
      102 		declare old_his		 bit (36) aligned;
      103 
      104 		old_his = unspec (as_user_message_system_info.highest_in_use);
      105 		new_his = bit (bin (hx, 36), 36);
      106 		his_ptr = addr (as_user_message_system_info.highest_in_use);
      107 		do while (^stacq (his, new_his, old_his) & hx > bin (old_his, 36));
      108 						/* use old_his to assure same comparison as stacq */
      109 		     old_his = unspec (as_user_message_system_info.highest_in_use);
      110 		end;
      111 	     end;
      112 
      113 
      114 	message_added = "0"b;
      115 	do while (^message_added);
      116 	     start_n_segments = as_user_message_system_info.n_segments;
      117 	     do sx = 0 to start_n_segments - 1;
      118 		call asum_find_segment_ (sx, ms_ptr);	/* in PP data or the hard way */
      119 		call TRY_ADD_MESSAGE (hx, ms_ptr);
      120 
      121 	     end;
      122 	     if ^message_added
      123 	     then call ADD_SEGMENT;			/* but start at the beginning again */
      124 	end;
      125 
      126 	call unlock_database;
      127 
      128 /**** Arrive here on success */
      129 
      130 	P_code = 0;
      131 	as_user_message_add_info = add_info;		/* Copy parm back out */
      132 	return;
      133 
      134 RETURN_ERROR:
      135      procedure (code);
      136 	declare code		 fixed bin (35);
      137 	P_code = code;
      138 	go to ERROR_RETURN;
      139      end RETURN_ERROR;
      140 
      141 ERROR_RETURN:
      142 	return;
      143 
      144 
      145 ADD_SEGMENT:
      146      procedure;
      147 
      148 	if start_n_segments ^= as_user_message_system_info.n_segments
      149 	then return;
      150 
      151 /**** So readers don't have to lock, create before bumping the count.
      152*      readers won't try to look at an uninitialized segment, and
      153*      writers will wait on the lock and then discover that we have added one. */
      154 
      155 	call asum_create_segment_ (as_user_message_system_info.n_segments, ms_ptr);
      156 	as_user_message_system_info.n_segments = as_user_message_system_info.n_segments + 1;
      157 	return;
      158      end ADD_SEGMENT;
      159 
      160 lock_database:
      161      procedure;
      162 
      163 	if ^stacq (as_user_message_system_info.lock, asum_data_$lock_id, ""b)
      164 	then call set_lock_$lock (as_user_message_system_info.lock, -1, (0));
      165 	asum_data_$db_locked = "1"b;
      166 	return;
      167      end lock_database;
      168 
      169 unlock_database:
      170      procedure;
      171 
      172 	if ^stacq (as_user_message_system_info.lock, ""b, asum_data_$lock_id)
      173 	then call set_lock_$unlock (as_user_message_system_info.lock, (0));
      174 	asum_data_$db_locked = "0"b;
      175 	return;
      176      end unlock_database;
      177 
      178 TRY_ADD_MESSAGE:
      179      procedure (hx, a_mseg_ptr);
      180 
      181 	declare hx		 fixed bin;
      182 	declare a_mseg_ptr		 pointer;
      183 	declare l_message_id	 bit (72) aligned;
      184 	declare 1 am_entry		 aligned like as_user_message_system_info.destination_am based (amep);
      185 	declare amep		 pointer;
      186 	declare 1 mop		 aligned like mseg_operation;
      187 
      188 	amep = addr (as_user_message_system_info.destination_am (hx));
      189 
      190 	mop = addr (mseg_data_$template_operation) -> mseg_operation;
      191 	mop.suppress_access_checks = "1"b;
      192 	mop.mseg_ptr = a_mseg_ptr;
      193 	mop.mseg_ptr_valid = "1"b;
      194 	mop.message_info.ms_ptr = add_info.message_ptr;
      195 	mop.message_info.ms_len = 36 * add_info.message_length;
      196 	mop.message_info.ms_id = ""b;			/* let mseg generate it */
      197 	mop.message_info.ms_access_class = add_info.message_access_class;
      198 	mop.message_info.sender_id = get_group_id_ ();
      199 	mop.message_info.sender_process_id = asum_data_$process_id;
      200 	mop.message_info.sender_level = asum_data_$entry_ring;
      201 	mop.message_info.sender_authorization = get_process_authorization_ ();
      202 	mop.message_info.sender_max_authorization = get_process_max_authorization_ ();
      203 	mop.message_info.sender_audit = ""b;
      204 	mop.message_info_valid = "1"b;
      205 	mop.add_message_info_all_valid = "1"b;
      206 
      207 	call mseg_$add_message (addr (mop), code);
      208 
      209 	l_message_id = mop.message_info.ms_id;
      210 
      211 	if code ^= 0 & code ^= error_table_$notalloc
      212 	then do;
      213 		do while (
      214 		     ^stacq (as_user_message_system_info.destination_am (hx).process_id, ""b, add_info.process_id));
      215 		end;
      216 
      217 		call asum_error_ (code, "asum_add_message_", "Failed to add message to message segment.");
      218 	     end;
      219 	if code = error_table_$notalloc
      220 	then return;
      221 	if code = 0
      222 	then do;
      223 		unspec (as_user_message_id) = l_message_id;
      224 		as_user_message_id.segment_index = sx;
      225 		l_message_id = unspec (as_user_message_id);
      226 		add_info.message_id = l_message_id;
      227 		am_entry.handle = add_info.destination_info.handle;
      228 		am_entry.message_id = l_message_id;
      229 		am_entry.ring = add_info.destination_info.ring;
      230 		am_entry.group_id = add_info.destination_info.group_id;
      231 		am_entry.reader_deletes = add_info.destination_info.reader_deletes;
      232 		am_entry.access_class = add_info.message_access_class;
      233 		message_added = "1"b;
      234 	     end;
      235 	return;
      236      end TRY_ADD_MESSAGE;
      237 
      238      end asum_add_message_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/04/86  1441.5  asum_add_message_.pl1             >spec>install>1147>asum_add_message_.pl1
70           1    03/08/85  0852.5  as_user_message_system.incl.pl1   >ldd>include>as_user_message_system.incl.pl1
71           2    03/08/85  0852.7  as_user_message_add.incl.pl1      >ldd>include>as_user_message_add.incl.pl1
72           3    03/19/85  1613.7  asum_data_.incl.pl1               >ldd>include>asum_data_.incl.pl1
73           4    05/17/85  0615.6  mseg_entries.incl.pl1             >ldd>include>mseg_entries.incl.pl1
74           5    05/17/85  0619.0  mseg_data_.incl.pl1               >ldd>include>mseg_data_.incl.pl1
75           6    05/17/85  0615.6  mseg_operation.incl.pl1           >ldd>include>mseg_operation.incl.pl1
76           7    05/17/85  0619.0  mseg_access_operation.incl.pl1    >ldd>include>mseg_access_operation.incl.pl1
77           8    05/17/85  0615.7  mseg_wakeup_state.incl.pl1        >ldd>include>mseg_wakeup_state.incl.pl1
78           9    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
79          10    05/17/85  0615.5  entry_access_info.incl.pl1        >ldd>include>entry_access_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_add_info_ptr                         parameter       pointer                  dcl 35 ref 21 82
P_code                                 parameter       fixed bin(35,0)          dcl 36 set ref 21 130* 137*
a_mseg_ptr                             parameter       pointer                  dcl 182 ref 178 192
access_class             16            based           bit(72)                  level 2 dcl 184 set ref 232*
add_info                        000100 automatic       structure                level 1 dcl 39 set ref 83* 131
add_message_info_all_valid
                         24(10) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 186 set ref 205*
addr                                                   builtin function         dcl 63 ref 106 188 190 207 207
am_entry                               based           structure                level 1 dcl 184
amep                            000214 automatic       pointer                  dcl 185 set ref 188* 227 228 229 230 231 232
as_user_message_add_info               based           structure                level 1 dcl 2-5 set ref 83 131*
as_user_message_add_info_ptr    000144 automatic       pointer                  dcl 2-4 set ref 82* 83 131
as_user_message_id              000136 automatic       structure                level 1 dcl 1-18 set ref 223* 225
as_user_message_perprocess_info_ptr
                                000142 automatic       pointer                  dcl 1-79 set ref 85*
as_user_message_system_info            based           structure                level 1 dcl 1-30
as_user_message_system_info_ptr 000140 automatic       pointer                  dcl 1-29 set ref 84* 90 91 96 104 106 109 116 148
                                                                                  155 156 156 163 163 172 172 188 213
asum_create_segment_            000014 constant        entry                    external dcl 51 ref 155
asum_data_$db_locked            000034 external static bit(1)                   dcl 3-23 set ref 165* 174*
asum_data_$entry_ring           000042 external static fixed bin(3,0)           dcl 3-29 ref 200
asum_data_$lock_id              000044 external static bit(36)                  dcl 3-31 ref 163 172
asum_data_$process_id           000046 external static bit(36)                  dcl 3-32 ref 199
asum_data_$process_info_ptr     000036 external static pointer                  dcl 3-25 ref 85
asum_data_$system_info_ptr      000040 external static pointer                  dcl 3-27 ref 84
asum_error_                     000010 constant        entry                    external dcl 49 ref 95 217
asum_find_segment_              000012 constant        entry                    external dcl 50 ref 118
bin                                                    builtin function         dcl 64 ref 105 107
bit                                                    builtin function         dcl 65 ref 105
code                                   parameter       fixed bin(35,0)          dcl 136 in procedure "RETURN_ERROR" ref 134 137
code                            000127 automatic       fixed bin(35,0)          dcl 40 in procedure "asum_add_message_" set ref 207*
                                                                                  211 211 217* 219 221
destination_am           20            based           structure                array level 2 dcl 1-30 set ref 90 188
destination_info         12     000100 automatic       structure                level 2 dcl 39
entry_access_info                      based           structure                level 1 dcl 10-12
error_table_$bad_arg            000030 external static fixed bin(35,0)          dcl 60 set ref 86*
error_table_$notalloc           000032 external static fixed bin(35,0)          dcl 61 ref 211 219
flags                    24     000216 automatic       structure                level 2 dcl 186
get_group_id_                   000016 constant        entry                    external dcl 52 ref 198
get_process_authorization_      000020 constant        entry                    external dcl 53 ref 201
get_process_max_authorization_  000022 constant        entry                    external dcl 55 ref 202
group_id                 12     000100 automatic       char(32)                 level 3 in structure "add_info" packed unaligned
                                                                                  dcl 39 in procedure "asum_add_message_" set ref
                                                                                  230
group_id                  6            based           char(32)                 level 2 in structure "am_entry" packed unaligned
                                                                                  dcl 184 in procedure "TRY_ADD_MESSAGE" set ref
                                                                                  230*
handle                    2            based           bit(72)                  level 2 in structure "am_entry" dcl 184 in procedure
                                                                                  "TRY_ADD_MESSAGE" set ref 227*
handle                   23     000100 automatic       bit(72)                  level 3 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_" set ref 86 227
hbound                                                 builtin function         dcl 66 ref 90
header                                 based           structure                level 2 dcl 1-30
highest_in_use            6            based           fixed bin(35,0)          level 3 dcl 1-30 set ref 96 104 106 109
his                                    based           bit(36)                  dcl 99 ref 107
his_ptr                         000150 automatic       pointer                  dcl 100 set ref 106* 107
hx                              000131 automatic       fixed bin(17,0)          dcl 42 in procedure "asum_add_message_" set ref 90*
                                                                                  91* 96 105 107 119*
hx                                     parameter       fixed bin(17,0)          dcl 181 in procedure "TRY_ADD_MESSAGE" ref 178 188
                                                                                  213
l_message_id                    000212 automatic       bit(72)                  dcl 183 set ref 209* 223 225* 226 228
lock                      4            based           bit(36)                  level 3 dcl 1-30 set ref 163 163* 172 172*
message_access_class      6     000100 automatic       bit(72)                  level 3 dcl 39 set ref 197 232
message_added                   000130 automatic       bit(1)                   dcl 41 set ref 114* 115 122 233*
message_id               10     000100 automatic       bit(72)                  level 3 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_" set ref 226*
message_id                4            based           bit(72)                  level 2 in structure "am_entry" dcl 184 in procedure
                                                                                  "TRY_ADD_MESSAGE" set ref 228*
message_info              2     000100 automatic       structure                level 2 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_"
message_info            220     000216 automatic       structure                level 2 in structure "mop" dcl 186 in procedure
                                                                                  "TRY_ADD_MESSAGE"
message_info_valid       24(05) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 186 set ref 204*
message_length            4     000100 automatic       fixed bin(18,0)          level 3 dcl 39 set ref 195
message_ptr               2     000100 automatic       pointer                  level 3 dcl 39 set ref 194
mop                             000216 automatic       structure                level 1 dcl 186 set ref 190* 207 207
ms_access_class         231     000216 automatic       bit(72)                  level 3 dcl 186 set ref 197*
ms_id                   227     000216 automatic       bit(72)                  level 3 dcl 186 set ref 196* 209
ms_len                  226     000216 automatic       fixed bin(24,0)          level 3 dcl 186 set ref 195*
ms_ptr                  224     000216 automatic       pointer                  level 3 in structure "mop" dcl 186 in procedure
                                                                                  "TRY_ADD_MESSAGE" set ref 194*
ms_ptr                          000132 automatic       pointer                  dcl 43 in procedure "asum_add_message_" set ref 118*
                                                                                  119* 155*
mseg_$add_message               000050 constant        entry                    external dcl 4-22 ref 207
mseg_access_operation                  based           structure                level 1 dcl 7-5
mseg_data_$template_operation   000052 external static bit(36)                  dcl 5-7 set ref 190
mseg_message_info                      based           structure                level 1 dcl 9-9
mseg_operation                         based           structure                level 1 dcl 6-24 ref 190
mseg_ptr                110     000216 automatic       pointer                  level 2 dcl 186 set ref 192*
mseg_ptr_valid           24(01) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 186 set ref 193*
mseg_wakeup_state                      based           structure                level 1 dcl 8-24
n_segments                5            based           fixed bin(17,0)          level 3 dcl 1-30 set ref 116 148 155* 156* 156
new_his                         000152 automatic       bit(36)                  dcl 101 set ref 105* 107
old_his                         000153 automatic       bit(36)                  dcl 102 set ref 104* 107 107 109*
process_id               22     000100 automatic       bit(36)                  level 3 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_" set ref 86 91 213
process_id               20            based           bit(36)                  array level 3 in structure
                                                                                  "as_user_message_system_info" dcl 1-30
                                                                                  in procedure "asum_add_message_" set ref 91 213
reader_deletes           26     000100 automatic       bit(1)                   level 3 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_" set ref 231
reader_deletes            1(03)        based           bit(1)                   level 2 in structure "am_entry" packed unaligned
                                                                                  dcl 184 in procedure "TRY_ADD_MESSAGE" set ref
                                                                                  231*
ring                      1            based           fixed bin(3,0)           level 2 in structure "am_entry" packed unsigned
                                                                                  unaligned dcl 184 in procedure "TRY_ADD_MESSAGE"
                                                                                  set ref 229*
ring                     25     000100 automatic       fixed bin(3,0)           level 3 in structure "add_info" dcl 39 in procedure
                                                                                  "asum_add_message_" set ref 229
segment_index                   000136 automatic       fixed bin(9,0)           level 2 packed unsigned unaligned dcl 1-18 set ref
                                                                                  224*
sender_audit            251     000216 automatic       bit(36)                  level 3 dcl 186 set ref 203*
sender_authorization    245     000216 automatic       bit(72)                  level 3 dcl 186 set ref 201*
sender_id               233     000216 automatic       char(32)                 level 3 packed unaligned dcl 186 set ref 198*
sender_level            244     000216 automatic       fixed bin(17,0)          level 3 dcl 186 set ref 200*
sender_max_authorization
                        247     000216 automatic       bit(72)                  level 3 dcl 186 set ref 202*
sender_process_id       243     000216 automatic       bit(36)                  level 3 dcl 186 set ref 199*
set_lock_$lock                  000024 constant        entry                    external dcl 57 ref 163
set_lock_$unlock                000026 constant        entry                    external dcl 58 ref 172
stacq                                                  builtin function         dcl 67 ref 91 107 163 172 213
start_n_segments                000134 automatic       fixed bin(17,0)          dcl 44 set ref 116* 117 148
suppress_access_checks
                         24(07) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 186 set ref 191*
sx                              000135 automatic       fixed bin(17,0)          dcl 45 set ref 117* 118* 224
unspec                                                 builtin function         dcl 68 set ref 104 109 223* 225

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AS_USER_ANY_PROCESS_ID                 internal static bit(36)                  initial dcl 1-49
AS_USER_MESSAGE_ADD_INFO_VERSION_1     internal static char(8)                  initial unaligned dcl 2-20
AS_USER_MESSAGE_PROCESS_SENTINEL       internal static char(8)                  initial dcl 1-85
AS_USER_MESSAGE_SEGMENT_NAME_CONSTANT  internal static char(16)                 initial unaligned dcl 1-12
AS_USER_MESSAGE_SYSTEM_NAME            internal static char(32)                 initial unaligned dcl 1-27
AS_USER_MESSAGE_SYSTEM_SENTINEL        internal static char(8)                  initial dcl 1-73
ENTRY_ACCESS_INFO_VERSION_1            internal static char(8)                  initial unaligned dcl 10-9
MSEG_ACCEPT_WAKEUPS                    internal static fixed bin(9,0)           initial dcl 7-24
MSEG_ADD_MESSAGE                       internal static fixed bin(9,0)           initial dcl 7-24
MSEG_COPY_SEG                          internal static fixed bin(9,0)           initial dcl 7-24
MSEG_CREATE_SEG                        internal static fixed bin(9,0)           initial dcl 7-24
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 9-28
MSEG_MODIFY_MESSAGE                    internal static fixed bin(9,0)           initial dcl 7-24
MSEG_MODIFY_SEG_ATTR                   internal static fixed bin(9,0)           initial dcl 7-24
MSEG_OPERATION_VERSION_1               internal static fixed bin(17,0)          initial dcl 6-20
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 9-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_MESSAGE                      internal static fixed bin(9,0)           initial dcl 7-24
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 9-38
MSEG_READ_SEG_ATTR                     internal static fixed bin(9,0)           initial dcl 7-24
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 9-30
MSEG_TYPE_MBX                          internal static fixed bin(17,0)          initial dcl 6-21
MSEG_TYPE_MS                           internal static fixed bin(17,0)          initial dcl 6-22
MSEG_WAKEUP_STATE_VERSION_1            internal static char(8)                  initial unaligned dcl 8-41
as_user_message_perprocess_info        based           structure                level 1 dcl 1-81
as_user_message_segment_name           automatic       structure                level 1 packed unaligned dcl 1-8
asum_data_$acl_entries                 external static bit(36)                  dcl 3-10
asum_data_$db_cbi                      external static bit(36)                  dcl 3-17
asum_data_$db_dir                      external static char(168)                unaligned dcl 3-12
asum_data_$db_dir_cbi                  external static bit(36)                  dcl 3-18
asum_data_$db_dir_rb                   external static fixed bin(3,0)           array dcl 3-20
asum_data_$db_multiclass               external static bit(1)                   dcl 3-13
asum_data_$db_rb                       external static fixed bin(3,0)           array dcl 3-22
asum_data_$n_acl_entries               external static fixed bin(17,0)          dcl 3-15
entry_access_info_ptr                  automatic       pointer                  dcl 10-8
mseg_$add_acl_entries_seg       000000 constant        entry                    external dcl 4-18
mseg_$chname_seg                000000 constant        entry                    external dcl 4-26
mseg_$close_seg                 000000 constant        entry                    external dcl 4-30
mseg_$compact_seg               000000 constant        entry                    external dcl 4-35
mseg_$copy_seg                  000000 constant        entry                    external dcl 4-39
mseg_$count_messages            000000 constant        entry                    external dcl 4-43
mseg_$create_seg                000000 constant        entry                    external dcl 4-47
mseg_$delete_acl_entries_seg    000000 constant        entry                    external dcl 4-52
mseg_$delete_message            000000 constant        entry                    external dcl 4-57
mseg_$delete_seg                000000 constant        entry                    external dcl 4-61
mseg_$get_salvaged_flag_seg     000000 constant        entry                    external dcl 4-66
mseg_$get_wakeup_state_seg      000000 constant        entry                    external dcl 4-70
mseg_$initiate_seg              000000 constant        entry                    external dcl 4-74
mseg_$list_acl_entries_seg      000000 constant        entry                    external dcl 4-83
mseg_$list_acl_seg              000000 constant        entry                    external dcl 4-78
mseg_$open_seg                  000000 constant        entry                    external dcl 4-87
mseg_$read_message              000000 constant        entry                    external dcl 4-92
mseg_$replace_acl_seg           000000 constant        entry                    external dcl 4-96
mseg_$reset_salvaged_flag_seg   000000 constant        entry                    external dcl 4-101
mseg_$reset_wakeup_state_seg    000000 constant        entry                    external dcl 4-105
mseg_$set_max_length_seg        000000 constant        entry                    external dcl 4-109
mseg_$set_safety_switch_seg     000000 constant        entry                    external dcl 4-113
mseg_$set_wakeup_state_seg      000000 constant        entry                    external dcl 4-117
mseg_$update_message            000000 constant        entry                    external dcl 4-121
mseg_access_operation_ptr              automatic       pointer                  dcl 7-4
mseg_access_operations_$data           external static structure                array level 1 dcl 7-35
mseg_data_$admin_ring                  external static fixed bin(3,0)           dcl 5-8
mseg_data_$block_size                  external static fixed bin(35,0)          dcl 5-5
mseg_data_$execution_ring              external static fixed bin(3,0)           dcl 5-9
mseg_data_$group_id                    external static char(32)                 unaligned dcl 5-11
mseg_data_$lock_id                     external static bit(72)                  dcl 5-4
mseg_data_$max_message_size            external static fixed bin(35,0)          dcl 5-6
mseg_data_$process_max_authorization   external static bit(72)                  dcl 5-10
mseg_message_info_ptr                  automatic       pointer                  dcl 9-7
mseg_operation_ptr                     automatic       pointer                  dcl 6-19
mseg_wakeup_state_ptr                  automatic       pointer                  dcl 8-38

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_SEGMENT                     000273 constant        entry                    internal dcl 145 ref 122
ERROR_RETURN                    000264 constant        label                    dcl 141 ref 138
HAVE_HX                         000154 constant        label                    dcl 96 ref 91
RETURN_ERROR                    000265 constant        entry                    internal dcl 134 ref 86
TRY_ADD_MESSAGE                 000372 constant        entry                    internal dcl 178 ref 119
asum_add_message_               000045 constant        entry                    external dcl 21
lock_database                   000315 constant        entry                    internal dcl 160 ref 89
unlock_database                 000346 constant        entry                    internal dcl 169 ref 126

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1074        1150     632        1104
Length      1560     632        54         373     241           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
asum_add_message_                   418 external procedure  is an external procedure.  
begin block on line 96                  begin block         shares stack frame of external procedure asum_add_message_.  
RETURN_ERROR                            internal procedure  shares stack frame of external procedure asum_add_message_.  
ADD_SEGMENT                             internal procedure  shares stack frame of external procedure asum_add_message_.  
lock_database                           internal procedure  shares stack frame of external procedure asum_add_message_.  
unlock_database                         internal procedure  shares stack frame of external procedure asum_add_message_.  
TRY_ADD_MESSAGE                         internal procedure  shares stack frame of external procedure asum_add_message_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
asum_add_message_        000100 add_info                    asum_add_message_
                         000127 code                        asum_add_message_
                         000130 message_added               asum_add_message_
                         000131 hx                          asum_add_message_
                         000132 ms_ptr                      asum_add_message_
                         000134 start_n_segments            asum_add_message_
                         000135 sx                          asum_add_message_
                         000136 as_user_message_id          asum_add_message_
                         000140 as_user_message_system_info_ptr
                                                            asum_add_message_
                         000142 as_user_message_perprocess_info_ptr
                                                            asum_add_message_
                         000144 as_user_message_add_info_ptr
                                                            asum_add_message_
                         000150 his_ptr                     begin block on line 96
                         000152 new_his                     begin block on line 96
                         000153 old_his                     begin block on line 96
                         000212 l_message_id                TRY_ADD_MESSAGE
                         000214 amep                        TRY_ADD_MESSAGE
                         000216 mop                         TRY_ADD_MESSAGE

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        return_mac          ext_entry           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
asum_create_segment_          asum_error_                   asum_find_segment_            get_group_id_
get_process_authorization_    get_process_max_authorization_                              mseg_$add_message
set_lock_$lock                set_lock_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
asum_data_$db_locked          asum_data_$entry_ring         asum_data_$lock_id            asum_data_$process_id
asum_data_$process_info_ptr   asum_data_$system_info_ptr    error_table_$bad_arg          error_table_$notalloc
mseg_data_$template_operation




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000041        82 000052        83 000056        84 000061        85 000064        86 000067        89 000103
     90 000104        91 000111        93 000117        95 000121        96 000154       104 000160       105 000163
    106 000171       107 000173       109 000213       110 000216       114 000217       115 000220       116 000222
    117 000225       118 000233       119 000244       121 000246       122 000250       124 000253       126 000254
    130 000255       131 000257       132 000263       141 000264       134 000265       137 000267       138 000272
    145 000273       148 000274       155 000301       156 000312       157 000314       160 000315       163 000316
    165 000342       166 000345       169 000346       172 000347       174 000367       175 000371       178 000372
    188 000374       190 000400       191 000405       192 000407       193 000412       194 000414       195 000416
    196 000421       197 000424       198 000427       199 000435       200 000440       201 000442       202 000450
    203 000457       204 000460       205 000462       207 000464       209 000477       211 000502       213 000507
    215 000521       217 000522       219 000551       221 000556       223 000560       224 000562       225 000565
    226 000567       227 000570       228 000575       229 000600       230 000605       231 000610       232 000615
    233 000620       235 000622


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
