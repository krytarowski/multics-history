	COMPILATION LISTING OF SEGMENT format_document_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1151.30_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(90-03-14,Kallstrom), approve(90-03-27,MCR8150),
       13*     audit(90-04-03,Zimmerman), install(90-04-11,MR12.4-1003):
       14*     Added an rtrim after CRs and VTs are removed.
       15*  2) change(92-09-14,Vu), approve(92-09-14,MCR8260), audit(92-09-23,Zimmerman),
       16*     install(92-10-06,MR12.5-1024):
       17*     format_document_ looses characters and generates unwanted new paragraph.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 format_document_:
       22 	proc (dnamin, enamin, dnamout, enamout, optptr, code);
       23 	
       24 /* subroutine to format text a la compose and runoff.  Used by 
       25*   format_document (fdoc) command.  There are 3 entries:
       26*
       27*	format_document_              takes input and output pathnames.
       28*          format_document_$string       takes input and output strings.
       29*          format_document_$switch       takes input pathname and writes to
       30*                                        an i/o switch.
       31*
       32*   Command written 79.01.12 by Paul W. Benjamin.
       33*   Subroutine interface added 80.02.14 by PWB.
       34*   Re-Written 81.02.10 by PWB.
       35*   Modified 81.04.20 by PWB to supress compression of leading spaces.
       36*   Modified 81.04.20 by PWB to fix bug where page numbers not centered 
       37*		        properly.
       38*   Modified 81.06.26 by PWB to fix 2 more bugs relating to leading spaces.
       39*   Modified 81.08.14 by PWB to fix bug where extra NL written to end when store
       40*		        is empty.
       41*   Modified 81.10.22 by PWB to avoid storage condition when compressing blanks
       42*		        in long (truncated to 508 chars) strings.
       43*   Modified 81.10.22 by PWB to fix bug where lines beginning with ". " or ".." 
       44*                            interpreted as undent controls (!)
       45*   Modified 82.07.16 by PWB to initially null 3 pointers before checking 
       46*		        version
       47*   Modified 82.07.16 by PWB to remove nonlocal goto on cleanup.
       48*   Modified 82.09.02 by PWB to prevent backing up into left margin when looking
       49*		        looking for a place to break an overlength line.
       50*   Modified 82.10.18 by PWB to add support for dont_compress_sw.
       51*   Modified 83.02.15 by PWB to add support for break_word_sw and 
       52*		        max_line_length_sw.
       53*   Modified 83.02.22 by PWB to stop truncating input lines at 508 chars.
       54*   Modified 83.03.01 by PWB to implement dont_break_indented_lines_sw.
       55*   Modified 83.03.03 by PWB to implement sub_err_sw.
       56*   Modified 83.06.07 by PWB to implement dont_fill_sw.
       57*   Modified 83.06.08 by PWB to implement hyphenation.
       58*   Modified 83.08.30 by PWB to fix bug where words that were larger than the
       59*		        line length didn't get hyphenated.
       60*   Modified 83.11.17 by PWB to have dont_break_indented_lines imply "don't
       61*		        do compression or sentence formatting on indented
       62*		        lines, either."
       63*   Modified 83.11.23 by PWB to add the names: .inl to .in, .unl to .un and to
       64*		        add the .spf control.
       65*   Modified 83.11.28 by PWB for various minor changes in response to audit.
       66*   Modified 83.12.01 by PWB to add .brf and .brp.
       67*   Modified 84.01.24 by PWB to fix bug introduced in MR10.2 that caused callers
       68*		        using version_1 to possibly have random values for
       69*		        the option switches that were new in that release.
       70*   Modified 84.02.08 by PWB to apply defaults for dont_compress, break_word,
       71*		        dont_break_indented_lines, sub_err, dont_fill
       72*		        and hyphenation for version_1 callers.
       73**/
       74 
       75 /* parameters */
       76 
       77 dcl  code fixed bin (35) parameter;			/* output system status code */
       78 dcl  dnamin char (*) parameter;			/* input file directory */
       79 dcl  dnamout char (*) parameter;			/* output file directory */
       80 dcl  enamin char (*) parameter;			/* input file name */
       81 dcl  enamout char (*) parameter;			/* output file name */
       82 dcl  instring char (*) parameter;			/* input string for string entry */
       83 dcl  iocbptr ptr parameter;				/* output switch for switch entry */
       84 dcl  optptr ptr parameter;				/* input ptr to options structure */
       85 dcl  outlen fixed bin (21) parameter;			/* output string length for string entry */
       86 dcl  outstring char (*) parameter;			/* output string for string entry */
       87 	
       88 /* entries */
       89 
       90 dcl  canonicalize_ entry (ptr, fixed bin(21), ptr, fixed bin(21),
       91 	fixed bin(35));
       92 dcl  convert_status_code_ entry (fixed bin(35), char(8) aligned,
       93 	char(100) aligned);
       94 dcl  cv_dec_check_ entry (char(*), fixed bin(35)) returns(fixed bin(35));
       95 dcl  hyphenate_word_ entry (char(*), fixed bin, fixed bin, fixed bin(35));
       96 dcl  ioa_$rs entry() options(variable);
       97 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       98 dcl  msf_manager_$close entry (ptr);
       99 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit(1), ptr, fixed bin(24),
      100 	fixed bin(35));
      101 dcl  msf_manager_$open entry (char(*), char(*), ptr, fixed bin(35));
      102 dcl  sub_err_ entry() options(variable);
      103 dcl  tssi_$finish_file entry (ptr, fixed bin, fixed bin(24),
      104 	bit(36) aligned, ptr, fixed bin(35));
      105 dcl  tssi_$get_file	entry (char(*), char(*), ptr, ptr, ptr, fixed bin(35));
      106 
      107 /* external static */
      108 
      109 dcl  error_table_$smallarg fixed bin(35) ext static;
      110 dcl  error_table_$fatal_error external static fixed bin (35);
      111 dcl  error_table_$improper_data_format external static fixed bin(35);
      112 dcl  error_table_$noentry fixed bin(35) ext static;
      113 dcl  error_table_$recoverable_error fixed bin(35) ext static;
      114 dcl  error_table_$unimplemented_version	external static fixed bin(35);
      115 dcl  error_table_$zero_length_seg fixed bin(35) ext static;
      116 dcl  fdoc_et_$indent_too_far_left fixed bin(35) ext static;
      117 dcl  fdoc_et_$indent_too_far_right fixed bin(35) ext static;
      118 dcl  fdoc_et_$line_length_too_small fixed bin(35) ext static;
      119 dcl  fdoc_et_$line_too_long fixed bin(35) ext static;
      120 dcl  fdoc_et_$no_hyphenate_word fixed bin(35) ext static;
      121 dcl  fdoc_et_$no_parameter_allowed fixed bin(35) ext static;
      122 dcl  fdoc_et_$no_sign_allowed fixed bin(35) ext static;
      123 dcl  fdoc_et_$nonnumeric_parameter fixed bin(35) ext static;
      124 dcl  fdoc_et_$page_length_lt_13 fixed bin(35) ext static;
      125 dcl  fdoc_et_$page_length_lt_14 fixed bin(35) ext static;
      126 dcl  fdoc_et_$page_width_exceeds_max fixed bin(35) ext static;
      127 dcl  fdoc_et_$text_too_long_for_line fixed bin(35) ext static;
      128 dcl  fdoc_et_$undent_too_far_left fixed bin(35) ext static;
      129 dcl  fdoc_et_$undent_too_far_right fixed bin(35) ext static;
      130 dcl  fdoc_et_$unsupported_control fixed bin(35) ext static;
      131 dcl  iox_$error_output ptr ext static;
      132 dcl  sys_info$max_seg_size fixed bin (19) ext static;
      133 	
      134 /* automatic */
      135 
      136 dcl  aclinfoptr ptr;				/* required for tssi_$get_file */
      137 dcl  adj_line_out char (508) varying;			/* temporary output line for adjust_line proc */
      138 dcl  adjust bit (1) aligned;				/* ON = in adjust mode */
      139 dcl  bc fixed bin (24);				/* required for various calls */
      140 dcl  blank_lines_to_be_written fixed bin;		/* user used .spf N and this has value N */
      141 dcl  breaking_words bit (1) aligned;			/* user specified break_word_sw */
      142 dcl  bsndx fixed bin;				/* index of backspace in line */
      143 dcl  bsndx1 fixed bin;				/* used when incrementing bsndx */
      144 dcl  bscnt fixed bin;				/* number of backspaces in line */
      145 dcl  buf char (256) varying;				/* input buffer */
      146 dcl  buf_len21 fixed bin (21);			/* length of buf -- needed for call to canonicalize_ */
      147 dcl  char_cnt fixed bin (21);				/* position of next char to be written */
      148 dcl  component_ends_wo_NL bit;			/* ON = component ends without a newline */
      149 dcl  continued_line bit (1);
      150 dcl  ctl char (5);					/* user specified control */
      151 dcl  ctl_index fixed bin;				/* index of ctl into ctl_list */
      152 dcl  current_syllable_size fixed bin;			/* syllable size as currently adjusted */
      153 dcl  default_syllable_size fixed bin;			/* syllable size as originally specified */
      154 dcl  dont_break_indented_lines bit (1) aligned;		/* user specified dont_break_indented_lines_sw */
      155 dcl  dont_compress bit (1) aligned;			/* user specified dont_compress_sw */
      156 dcl  elen fixed bin (21);				/* length of error message */
      157 dcl  error bit (1) aligned;				/* ON = an error has occurred */
      158 dcl  error_lines char (508);				/* error message */
      159 dcl  errtxt char (100) aligned;			/* output from convert_status_code_ */
      160 dcl  fill bit (1) aligned;				/* ON = fill mode */
      161 dcl  filout bit (1) aligned;				/* ON = main entry or string entry */
      162 dcl  fit bit (1) aligned;				/* used in bs_rtn: can use portion of line as is */
      163 dcl  galley_mode bit (1) aligned;			/* user specified galley_sw */
      164 dcl  h fixed bin;					/* index for do-group */
      165 dcl  hyph_len fixed bin (21);				/* length of based variable hyph_word */
      166 dcl  hyph_point fixed bin;				/* where to hyphenate, output from hyphenate_word_ */
      167 dcl  hyph_ptr ptr;					/* pointer to based variable hyph_word */
      168 dcl  hyph_space fixed bin;				/* how much space in which to hyphenate */
      169 dcl  hyphenating bit (1) aligned;			/* caller has requested hyphenation */
      170 dcl  hyphenation_routine_state fixed bin;		/* = 0 hyphenate_word_ not looked for yet */
      171 						/* = 1 hyphenate_word_ found */
      172 						/* = 2 hyphenate_word_ not found */
      173 dcl  hyphenate_entry entry variable;			/* dummy entry to test for linkage error */
      174 dcl  i fixed bin;					/* index for do-group */
      175 dcl  in_comp_no fixed bin;				/* current input component number */
      176 dcl  ind fixed bin;					/* current indentation value */
      177 dcl  ind_minus_und fixed bin;				/* current calculation of ind - und */
      178 dcl  indptr ptr;					/* ptr to initial indentation string */
      179 dcl  infcbptr ptr;					/* ptr to fcb for input file */
      180 dcl  initial_ind fixed bin;				/* initial indentation value */
      181 dcl  initial_inlen fixed bin (21);			/* length of input component */
      182 dcl  initial_inptr ptr;				/* pointer to beginning of input component */
      183 dcl  initial_line_length fixed bin;			/* user specified line_length */
      184 dcl  initial_outptr ptr;				/* pointer to beginning of output component */
      185 dcl  inlen fixed bin (21);				/* length of remainder of input component */
      186 dcl  inplnctr fixed;				/* current line in input file */
      187 dcl  inptr ptr;					/* current position in input file */
      188 dcl  ioxbuf char (508);				/* output buffer for switch entry */
      189 dcl  j fixed bin;					/* index for do-group */
      190 dcl  k fixed bin;					/* index for do-group */
      191 dcl  last_blank fixed bin;				/* position of blank in line for bs_rtn */
      192 dcl  left bit (1) aligned;				/* ON = start adjusting from left side */
      193 dcl  line_began_with_blank bit (1) aligned;		/* exactly what it says */
      194 dcl  literal_mode bit (1) aligned;			/* user specified literal_sw */
      195 dcl  ll fixed bin;					/* current linelength */
      196 dcl  lnctr fixed bin;				/* output line counter */
      197 dcl  long_line_and_no_blank bit (1) aligned;		/* used in bs_rtn when having problems breaking line */
      198 dcl  maxcnt fixed bin (21);				/* position of first character past end of segment */
      199 dcl  maximum_line_length bit (1) aligned;		/* user specified max_line_length_sw */
      200 dcl  new_adjust bit (1) aligned;			/* new value for adjust */
      201 dcl  new_fill bit (1) aligned;			/* new value for fill */
      202 dcl  new_ind fixed bin;				/* new value for ind */
      203 dcl  new_und fixed bin;				/* new value for und */
      204 dcl  nlindex fixed bin;				/* index of next newline in input component */
      205 dcl  out_comp_no fixed bin;				/* current output component number */
      206 dcl  outline char (508) varying;			/* line to be written out */
      207 dcl  outfcbptr ptr;					/* ptr to fcb for output file */
      208 dcl  outptr ptr;					/* ptr to next character position in output file */
      209 dcl  outstringlen fixed bin (21);			/* length of output string for string entry */
      210 dcl  pads fixed;					/* number of spaces for adjust_line to fill in */
      211 dcl  param char (100) varying;			/* parameter to ctl */
      212 dcl  paramfb fixed bin;				/* fixed bin version of param */
      213 dcl  pgctr fixed bin;				/* last output page number */
      214 dcl  pgctra char (10) varying;			/* ascii representation of pgctr */
      215 dcl  pgno bit;					/* ON = end page with centered page number */
      216 dcl  pl fixed bin;					/* current output page length */
      217 dcl  retval fixed bin (35);				/* meaningless but required by sub_err_ */
      218 dcl  signed bit;					/* ON = param has optional leading sign */
      219 dcl  space_available fixed bin;			/* characters remaining in output string or component */
      220 dcl  space_pos (100) fixed;				/* where adjust_line keeps track of spaces in line */
      221 dcl  spaces fixed;					/* number of spaces in line found by adjust_line */
      222 dcl  spindex fixed bin;				/* index of space in line */
      223 dcl  spindex1 fixed bin;				/* used when incrementing spindex */
      224 dcl  store char (508) varying;			/* characters read but not yet written */
      225 dcl  string_entry bit;				/* ON = entry via format_document_$string */
      226 dcl  subcode fixed bin (35);				/* used in call to sub_err_ */
      227 dcl  tabfill fixed bin;				/* number of spaces needed to replace tab */
      228 dcl  tabndx fixed bin;				/* index of first tab in line */
      229 dcl  temp_code fixed bin (35);			/* temporary code used at cleanup time */
      230 dcl  tlen fixed bin;				/* length of text in write_file */
      231 dcl  trash char (8) aligned;				/* unused output from convert_status_code_ */
      232 dcl  und fixed bin;					/* current undentation value */
      233 dcl  using_sub_err bit (1) aligned;			/* user asked for the usage of sub_err_ */
      234 dcl  vlen fixed bin;				/* virtual length (width) of line */
      235 dcl  vtabndx fixed bin;				/* virtual position of tab in line */
      236 
      237 dcl  1 error_info like format_document_error;
      238 
      239 /* based */
      240 
      241 dcl  hyph_word char (hyph_len) based (hyph_ptr);		/* word passed to hyphenate_word_ */
      242 dcl  indstr char (initial_ind) based (indptr);		/* initial indentation string */
      243 dcl  in_chars (inlen + 2) char (1) based (inptr);		/* infile: one char at a time */
      244 						/* (the +2 is to avoid a subscriptrange) */
      245 dcl  infile char (inlen) based (inptr);			/* remainder of input component */
      246 dcl  initial_in_chars (initial_inlen) char (1) 
      247 	based (initial_inptr);			/* input component */
      248 dcl  out_chars (sys_info$max_seg_size * 4) char (1) 
      249 	based (initial_outptr);			/* output component */
      250 dcl  outfile char ((sys_info$max_seg_size * 4) + 1 - char_cnt) 
      251 	based (outptr);				/* remainder of output component */
      252 
      253 dcl  1 buf_structure based (addr (buf)),		/* to look at buf as non-varying */
      254        2 buf_len fixed bin (35),
      255        2 buf_chars (256) char (1);
      256 dcl  1 store_structure based (addr (store)),		/* to look at store one character at a time */
      257        2 store_len fixed bin (35),
      258        2 store_char (508) char (1);
      259 
      260 /* internal static */
      261 
      262 dcl  BS char (1) internal static options (constant) init ("");
      263 dcl  BS_or_HT char (2) internal static options (constant) init ("	");
      264 dcl  BS_or_HT_or_SP char (3) internal static options (constant) init ("	 ");
      265 dcl  BUFFER_SIZE fixed internal static options (constant) init (256);
      266 dcl  BUFFER_SIZE_PLUS_ONE fixed internal static options (constant) init (257);
      267 dcl  CR char (1) internal static options (constant) init ("");
      268 dcl  CR_or_VT char (2) internal static options (constant) init ("");
      269 dcl  DEFAULT_LINE_LENGTH fixed internal static options (constant) init (65);
      270 dcl  DEFAULT_PAGE_LENGTH fixed internal static options (constant) init (66);
      271 dcl  FF char (1) internal static options (constant) init ("");
      272 dcl  HT char (1) internal static options (constant) init ("	");
      273 dcl  HT_or_SP char (2) internal static options (constant) init ("	 ");
      274 dcl  HT_or_NL_or_SP char (3) internal static options (constant) init ("	 
      275 ");
      276 dcl  HYPHEN char (1) internal static options (constant) init ("-");
      277 dcl  NL char (1) internal static options (constant) init ("
      278 ");
      279 dcl  VT char (1) internal static options (constant) init ("");
      280 dcl  ctl_list char (83) internal static options (constant) init 
      281 	("   .un .in .alb.all.fin.fif.pdw.pdl.hy .hyf.hyn.inl.unl.spf.   ..  ... .....brf.brp");
      282 	
      283 	
      284 /* builtins */
      285 
      286 dcl (addr, after, before, char, copy, decat, divide, index, length, ltrim, 
      287 	mod, null, reverse, rtrim, search, substr, translate, verify) builtin;
      288 
      289 /* condition */
      290 
      291 dcl (cleanup, linkage_error) condition;
      292 	
      293 
      294 /* include file */
      295 
  1     1 /*	BEGIN INCLUDE FILE   format_document_options.incl.pl1	     
  1     2*
  1     3*     Modified 82.10.18 by Paul W. Benjamin to add dont_compress_sw and upgrade
  1     4*			to version_2.
  1     5*     Modified 83.02.15 by PWB to add break_word_sw and max_line_length_sw.
  1     6*     Modified 83.03.01 by PWB to add dont_break_indented_lines_sw.
  1     7*     Modified 83.03.03 by PWB to add sub_err_sw.
  1     8*     Modified 83.06.07 by PWB to add dont_fill_sw.
  1     9*     Modified 83.06.09 by PWB to add hyphenation_sw and syllable_size.
  1    10**/
  1    11 
  1    12 dcl 1 format_document_options aligned based (format_document_options_ptr),
  1    13       2 version_number        fixed bin,		/* input */
  1    14                                                             /* must be format_document_version_2 */
  1    15       2 indentation           fixed bin,		/* input */
  1    16 						/* all lines must be indented by this value */
  1    17       2 line_length           fixed bin,		/* input */
  1    18 						/* initial line length */
  1    19       2 switches,
  1    20         3 pgno_sw             bit (1) unal,		/* input */
  1    21 						/* end each page with a centered page number */
  1    22         3 adj_sw              bit (1) unal,		/* input */
  1    23 						/* adjust mode initially on */
  1    24                                                             /* only meaningful if dont_fill_sw = "0"b */
  1    25         3 galley_sw           bit (1) unal,		/* input */
  1    26 						/* galley mode -- no page breaks */
  1    27         3 error_sw            bit (1) unal,		/* input */
  1    28 						/* report all errors on error_output */
  1    29         3 literal_sw          bit (1) unal,		/* input */
  1    30 						/* "1"b - interpret all lines as text */
  1    31 						/* "0"b - lines that start with "." are controls */
  1    32         3 file_sw             bit (1) unal,		/* output */
  1    33 						/* has meaning for non-zero storage system status codes */
  1    34 						/* "1"b code refers to output file */
  1    35 						/* "0"b code refers to input file */
  1    36         3 dont_compress_sw    bit (1) unal,		/* input */
  1    37 						/* "1"b - don't compress white space */
  1    38 						/* "0"b - compress white space when filling */
  1    39         3 break_word_sw      bit (1) unal,		/* input */
  1    40 						/* "1"b - break a word rather than exceed line_length */
  1    41 						/* "0"b - write an overlength line if no spaces found */
  1    42         3 max_line_length_sw  bit (1) unal,		/* input */
  1    43 						/* "1"b - line_length cannot be exceeded */
  1    44 						/* "0"b - line_length can be exceeded (by .pdw controls) */
  1    45         3 dont_break_indented_lines_sw			/* input */
  1    46 			bit (1) unal,		/* don't break a line that begins with whitespace */
  1    47 						/* when it is the last line, or the next line is */
  1    48 						/* null or the next line begins with whitespace */
  1    49         3 sub_err_sw	bit (1) unal,		/* input */
  1    50 						/* quietly call sub_err_ with diagnostic errors */
  1    51         3 dont_fill_sw        bit (1) unal,                 /* input */
  1    52                                                             /* "1"b - fill mode off initially */
  1    53                                                             /* "0"b - fill mode on initially */
  1    54         3 hyphenation_sw      bit (1) unal,
  1    55         3 mbz                 bit (23) unal,		/* input */
  1    56 						/* MUST be zero */
  1    57       2 syllable_size
  1    58 			fixed bin;		/* input */
  1    59 						/* smallest portion of word */
  1    60 						/* to be left by hyphenation */
  1    61 
  1    62 dcl  format_document_options_ptr ptr;
  1    63 dcl  format_document_version_2 fixed bin int static options (constant) init (2);
  1    64 dcl  format_document_version_1 fixed bin int static options (constant) init (1);
  1    65 	
  1    66 /*	END INCLUDE FILE   format_document_options.incl.pl1	     */
      296 
      297 
  2     1 /*	BEGIN INCLUDE FILE   format_document_error.incl.pl1	     
  2     2*
  2     3*     Information structure used by format_document_ in calls to sub_err_.
  2     4*
  2     5*     Written 83.03.03 by Paul W. Benjamin
  2     6*
  2     7**/
  2     8 
  2     9 dcl 1 format_document_error aligned based (format_document_error_ptr),
  2    10       2 version_number        fixed bin,		/* format_document_error_version_1 */
  2    11       2 error_code	          fixed bin (35),		/* which error has occurred? */
  2    12       2 line_number           fixed bin,		/* and on what line? */
  2    13       2 text_line             char (128) varying;		/* the offending line (or first 128 chars) */
  2    14 
  2    15 dcl  format_document_error_ptr ptr;
  2    16 dcl  format_document_error_version_1 fixed bin int static options (constant) init (1);
  2    17 
  2    18 /*	END INCLUDE FILE   format_document_error.incl.pl1	     */
      298 
      299 
  3     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  3     2 /* format: style3 */
  3     3 
  3     4 /* These constants are to be used for the flags argument of sub_err_ */
  3     5 /* They are just "string (condition_info_header.action_flags)" */
  3     6 
  3     7 declare	(
  3     8 	ACTION_CAN_RESTART	init (""b),
  3     9 	ACTION_CANT_RESTART init ("1"b),
  3    10 	ACTION_DEFAULT_RESTART
  3    11 			init ("01"b),
  3    12 	ACTION_QUIET_RESTART
  3    13 			init ("001"b),
  3    14 	ACTION_SUPPORT_SIGNAL
  3    15 			init ("0001"b)
  3    16 	)		bit (36) aligned internal static options (constant);
  3    17 
  3    18 /* End include file */
      300 
      301 
      302 /* program */
      303 
      304 /* main entry -- format_document_ */
      305 
      306           error = "0"b;
      307 	indptr = null ();
      308 	infcbptr = null ();
      309 	outfcbptr = null ();
      310           format_document_options_ptr = optptr;
      311 	format_document_options.file_sw = "0"b;
      312 	call check_version_and_set_options;
      313 	if format_document_options.switches.mbz ^= "0"b
      314 	     then do;
      315 	     code = error_table_$improper_data_format;
      316 	     goto done;
      317 	end;
      318 	filout = "1"b;
      319 	string_entry = "0"b;
      320 
      321 	on cleanup call done_proc;
      322 	call msf_manager_$open (dnamin, enamin, infcbptr, code);
      323 	if code ^= 0
      324 	     then goto done;
      325 	call msf_manager_$get_ptr (infcbptr, 0, "0"b, inptr, bc, code);
      326 	if inptr = null ()
      327 	     then goto done;
      328 	if bc = 0
      329 	     then do;
      330 	     code = error_table_$zero_length_seg;
      331 	     goto done;
      332 	end;
      333 	inlen = divide (bc, 9, 21, 0);
      334 	call tssi_$get_file (dnamout, enamout, outptr, aclinfoptr, outfcbptr, code);
      335 	if code ^= 0
      336 	     then do;
      337 	     format_document_options.file_sw = "1"b;
      338 	     goto done;
      339 	end;
      340 	out_comp_no = 0;
      341 	initial_outptr = outptr;
      342 	code = 0;
      343 	goto process;
      344 
      345 string:	entry (instring, outstring, outlen, optptr, code);
      346 
      347 	error = "0"b;
      348 	indptr = null ();
      349 	infcbptr = null ();
      350 	outfcbptr = null ();
      351           format_document_options_ptr = optptr;
      352 	format_document_options.file_sw = "0"b;
      353 	call check_version_and_set_options;
      354 	if format_document_options.switches.mbz ^= "0"b
      355 	     then do;
      356 	     code = error_table_$improper_data_format;
      357 	     goto done;
      358 	end;
      359 	code = 0;
      360 	filout = "1"b;
      361 	inlen = length (instring);
      362 	inptr = addr (instring);
      363 	outptr, initial_outptr = addr (outstring);
      364 	outstringlen = length (outstring);
      365 	string_entry = "1"b;
      366 	on cleanup call done_proc;
      367 	goto process;
      368 
      369 switch:	entry (dnamin, enamin, iocbptr, optptr, code);
      370 
      371 	error = "0"b;
      372 	indptr = null ();
      373 	infcbptr = null ();
      374 	outfcbptr = null ();
      375           format_document_options_ptr = optptr;
      376 	format_document_options.file_sw = "0"b;
      377 	call check_version_and_set_options;
      378 	if format_document_options.switches.mbz ^= "0"b
      379 	     then do;
      380 	     code = error_table_$improper_data_format;
      381 	     goto done;
      382 	end;
      383 	filout = "0"b;
      384 	string_entry = "0"b;
      385 
      386 	on cleanup call done_proc;
      387 	call msf_manager_$open (dnamin, enamin, infcbptr, code);
      388 	if code ^= 0
      389 	     then goto done;
      390 	call msf_manager_$get_ptr (infcbptr, 0, "0"b, inptr, bc, code);
      391 	if inptr = null ()
      392 	     then goto done;
      393 	if bc = 0
      394 	     then do;
      395 	     code = error_table_$zero_length_seg;
      396 	     goto done;
      397 	end;
      398 	inlen = divide (bc, 9, 21, 0);
      399 	code = 0;
      400 
      401 process:
      402 	char_cnt = 1;
      403 	component_ends_wo_NL = "0"b;
      404           continued_line = "0"b;
      405 	current_syllable_size = default_syllable_size;
      406 	hyphenation_routine_state = 0;
      407 	in_comp_no = 0;
      408 	ind = 0;
      409 	ind_minus_und = 0;
      410 	inplnctr = 0;
      411 	left = "1"b;
      412 	lnctr = 0;
      413 	maxcnt = (sys_info$max_seg_size * 4) + 1;
      414 	pgctr = 0;
      415 	pl = DEFAULT_PAGE_LENGTH;
      416 	store = "";
      417 	und = 0;
      418 	if hyphenating
      419 	     then call look_for_hyphenation_routine;
      420           allocate indstr;
      421 	indstr = copy (" ", initial_ind);
      422 process_one_component:
      423 	initial_inlen = inlen;
      424 	initial_inptr = inptr;
      425 	do while (inlen > 0);			/* while there is more input */
      426 	     nlindex = index (infile, NL);
      427 	     inplnctr = inplnctr + 1;
      428                continued_line = "0"b;
      429 	     if nlindex = 0
      430 		then nlindex = inlen + 1;
      431 	     if nlindex > BUFFER_SIZE_PLUS_ONE		/* line longer than internal buffer */
      432 		then do;				/* find someplace to break it */
      433                     continued_line = "1"b;
      434 		if length (rtrim (substr (infile, 1, nlindex - 1), HT_or_SP)) <= BUFFER_SIZE
      435                     /* line merely had a lot of trailing blanks */
      436 		     then buf = rtrim (substr (infile, 1, nlindex - 1), HT_or_SP);
      437 		else do;
      438 		     spindex = BUFFER_SIZE_PLUS_ONE - index (reverse (substr (infile, 1, BUFFER_SIZE_PLUS_ONE)), " ");
      439 		     if spindex ^= BUFFER_SIZE_PLUS_ONE /* and break it there */
      440 			then do;
      441 			buf = rtrim (substr (infile, 1, spindex), HT_or_SP);
      442 			nlindex = spindex + 1;
      443 		     end;
      444 		     else if breaking_words
      445 			then do;
      446 			buf = substr (infile, 1, ll);
      447 			nlindex = ll;
      448 		     end;
      449 		     else do;			/* no place to break it */
      450 			if store_len ^= 0		/* write out store if not empty */
      451 			     then do;
      452 			     store = copy (" ", ind_minus_und) || store;
      453 			     call write (store);
      454 			     store = "";
      455 			end;
      456 			call err_reporter (fdoc_et_$line_too_long); /* report as (recoverable) error */
      457 			call write ((substr (infile, 1, nlindex - 1)));	/* and write it as is */
      458 			goto continue;
      459 		     end;
      460 		end;
      461 	     end;
      462 	     else buf = rtrim (substr (infile, 1, nlindex - 1), HT_or_SP); /* get the next line into buf */
      463 
      464                if ^literal_mode & buf_len > 0 
      465                     & ^continued_line                       /* literal_sw says ignore controls */
      466 		then if buf_chars (1) = "."
      467 		then do;
      468 		buf = translate (buf, " ", HT);	/* quasi- */
      469 		do while (index (buf, "  ") ^= 0);	/* canonicalize */
      470 		     buf = before (buf, "  ") || " " || after (buf, "  ");
      471 		end;
      472 		ctl = before (buf, " ");
      473 		if index (ctl, " ") = 0		/* ctl is 1 char longer than the longest ctl */
      474 		     then do;			/* so it better end in a space or two */
      475 		     call err_reporter (fdoc_et_$unsupported_control);
      476 		     goto continue;
      477 		end;
      478 		code = 0;
      479 		param = (after (buf, " "));
      480 		if length (param) ^= 0
      481 		     then do;
      482 		     signed = (verify (substr (param, 1, 1), "+-") = 0);
      483 		     paramfb = cv_dec_check_ ((param), code);
      484 		end;
      485 		ctl_index = divide (index (ctl_list, substr (ctl, 1, 4)), 4, 17, 0);
      486 		if ctl_index = 0
      487 		     then do;
      488 		     call err_reporter (fdoc_et_$unsupported_control);
      489 		     goto continue;
      490 		end;
      491 		goto process_ctl (ctl_index);
      492 
      493 process_ctl (1):					/* undent */
      494 process_ctl (13):	if code ^= 0
      495 		     then do;
      496 		     code = 0;
      497 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      498 		     goto continue;
      499 		end;
      500 		if length (param) = 0
      501 		     then new_und = ind;
      502 		else do;
      503 		     new_und = paramfb;
      504 		     if new_und > ind
      505 			then do;
      506 			call err_reporter (fdoc_et_$undent_too_far_left);
      507 			new_und = ind;
      508 		     end;
      509 		     else if (ll -ind) + new_und < 0
      510 			then do;
      511 			call err_reporter (fdoc_et_$undent_too_far_right);
      512 			new_und = ind - ll;
      513 		     end;
      514 		end;
      515 		goto process_break;
      516 
      517 process_ctl (2):					/* indent */
      518 process_ctl (12):	if code ^= 0
      519 		     then do;
      520 		     code = 0;
      521 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      522 		     goto continue;
      523 		end;
      524 		if length (param) = 0
      525 		     then new_ind = 0;
      526 		else do;
      527 		     if signed 
      528 			then do;
      529 			new_ind = paramfb + ind;
      530 			if new_ind < 0
      531 			     then do;
      532 			     call err_reporter (fdoc_et_$indent_too_far_left);
      533 			     new_ind = 0;
      534 			end;
      535 		     end;
      536 		     else new_ind = paramfb;
      537 		     if new_ind > ll
      538 			then do;
      539 			call err_reporter (fdoc_et_$indent_too_far_right);
      540 			new_ind = ll;
      541 		     end;
      542 		end;
      543 		goto process_break;
      544 
      545 process_ctl (3):					/* allign both */
      546 		if length (param) ^= 0
      547 		     then do;
      548 		     code = 0;
      549 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      550 		     goto continue;
      551 		end;
      552 		new_adjust = "1"b;
      553 		goto process_break;
      554 
      555 process_ctl (4):					/* allign left */
      556 		if length (param) ^= 0
      557 		     then do;
      558 		     code = 0;
      559 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      560 		     goto continue;
      561 		end;
      562 		new_adjust = "0"b;
      563 		goto process_break;
      564 process_ctl (5):					/* fill on */
      565 		if length (param) ^= 0
      566 		     then do;
      567 		     code = 0;
      568 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      569 		     goto continue;
      570 		end;
      571 		new_fill = "1"b;
      572 		goto process_break;
      573 process_ctl (6):					/* fill off */
      574 		if length (param) ^= 0
      575 		     then do;
      576 		     code = 0;
      577 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      578 		     goto continue;
      579 		end;
      580 		new_fill = "0"b;
      581 		goto process_break;
      582 
      583 process_ctl (7):					/* page width */
      584 		if code ^= 0
      585 		     then do;
      586 		     code = 0;
      587 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      588 		     goto continue;
      589 		end;
      590 		if length (param) = 0
      591 		     then ll = DEFAULT_LINE_LENGTH;
      592 		else if signed
      593 		     then ll = ll + paramfb;
      594 		else ll = paramfb;
      595 		if maximum_line_length
      596 		     & ll > initial_line_length
      597 		     then do;
      598 		     ll = initial_line_length;
      599 		     call err_reporter (fdoc_et_$page_width_exceeds_max);
      600 		end;
      601 		goto continue;
      602 process_ctl (8):					/* page length */
      603 		if code ^= 0
      604 		     then do;
      605 		     code = 0;
      606 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      607 		     goto continue;
      608 		end;
      609 		if length (param) = 0
      610 		     then pl = DEFAULT_PAGE_LENGTH;
      611 		else if signed
      612 		     then pl = pl + paramfb;
      613 		else pl = paramfb;
      614 		if ^pgno & pl < 13
      615 		     then do;
      616 		     pl = 13;
      617 		     call err_reporter (fdoc_et_$page_length_lt_13);
      618 		end;
      619 		else if pgno & pl < 14
      620 		     then do;
      621 	               pl = 14;
      622 		     call err_reporter (fdoc_et_$page_length_lt_14);
      623 		end;
      624 		goto continue;
      625 
      626 process_ctl (9):					/* hyphenate default */
      627 		if length (param) ^= 0
      628 		     then do;
      629 		     code = 0;
      630 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      631 		     goto continue;
      632 		end;
      633 		hyphenating = format_document_options.hyphenation_sw;
      634 		current_syllable_size = default_syllable_size;
      635 		if hyphenating
      636 		     then if hyphenation_routine_state = 0
      637 		     then call look_for_hyphenation_routine;
      638 		else if hyphenation_routine_state = 2
      639 		     then hyphenating = "0"b;
      640 		goto continue;
      641 
      642 
      643 process_ctl (10):					/* hyphenate off */
      644 		if length (param) ^= 0
      645 		     then do;
      646 		     code = 0;
      647 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      648 		     goto continue;
      649 		end;
      650 		hyphenating = "0"b;
      651 		goto continue;
      652 
      653 
      654 process_ctl (11):					/* hyphenate on */
      655 
      656 		if code ^= 0
      657 		     then do;
      658 		     code = 0;
      659 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      660 		     goto continue;
      661 		end;
      662 
      663 		if length (param) ^= 0
      664 		     then if signed
      665 		     then do;
      666 		     call err_reporter (fdoc_et_$no_sign_allowed);
      667 		     goto continue;
      668 		end;
      669 		
      670 		hyphenating = "1"b;
      671 		if hyphenation_routine_state = 0
      672 		     then call look_for_hyphenation_routine;
      673 		else if hyphenation_routine_state = 2
      674 		     then hyphenating = "0"b;
      675 		if length (param) ^= 0
      676 		     then current_syllable_size = paramfb;
      677 		else current_syllable_size = default_syllable_size;
      678 		goto continue;
      679 
      680 process_ctl (14):					/* space-format */
      681 		if code ^= 0
      682 		     then do;
      683 		     code = 0;
      684 		     call err_reporter (fdoc_et_$nonnumeric_parameter);
      685 		     goto continue;
      686 		end;
      687 		if length (param) ^= 0
      688 		     then if signed
      689 		     then do;
      690 		     call err_reporter (fdoc_et_$no_sign_allowed);
      691 		     goto continue;
      692 		end;
      693 		if length (param) = 0
      694 		     then blank_lines_to_be_written = 1;
      695 		else blank_lines_to_be_written = paramfb;    
      696 		goto process_break;			
      697 			     
      698 
      699 process_ctl (15):					/* . */
      700 process_ctl (16):					/* .. */
      701 process_ctl (17):					/* ... */
      702 process_ctl (18):					/* .... */
      703 		goto process_text;			/* these are text */		
      704 
      705 process_ctl (19):					/* break-format */
      706 process_ctl (20):					/* break-page */
      707 		if length (param) ^= 0
      708 		     then do;
      709 		     code = 0;
      710 		     call err_reporter (fdoc_et_$no_parameter_allowed);
      711 		     goto continue;
      712 		end;
      713 		goto process_break;			/* which is currently the next statement */
      714 
      715 process_break:		
      716 /* We have hit a control break, must write out anything left */
      717 		if store_len ^= 0 
      718 		     then do;
      719 		     store = copy (" ", ind_minus_und) || store;     /* indent */
      720 		     call write (store);		/* write it */
      721 		     store = "";			/* clear out save area */
      722 		end;
      723 		
      724 /* NOW apply specified control */
      725 		if ctl_index = 2			/* .in  */
      726 		     | ctl_index = 12		/* .inl */
      727 		     then ind = new_ind;
      728 		else if ctl_index = 1		/* .un  */
      729 		     | ctl_index = 13		/* .unl */
      730 		     then und = new_und;
      731 		else if ctl_index = 3		/* .alb */
      732 		     | ctl_index = 4		/* .all */
      733 		     then adjust = new_adjust;
      734 		else if ctl_index = 5		/* .fin */
      735 		     | ctl_index = 6		/* .fif */
      736 		     then fill = new_fill;
      737 		else if ctl_index = 14		/* .spf */
      738 		     then do i = 1 to blank_lines_to_be_written;
      739 		     call write ("");
      740 		end;
      741 		else if ctl_index = 20		/* .brp */
      742 		     then if ^galley_mode
      743 		     then do;
      744 		     if lnctr ^= 0			/* maybe the break caused a new page already */
      745 			then do;
      746 			if pgno 
      747 			     then do i = lnctr to pl - 8;
      748 			     call write ("");		
      749 			end;
      750 			else if filout
      751 			     then do;
      752 			     lnctr = pl - 7;	
      753 			     call write ("");
      754 			end;
      755 			else /* ^pgno & ^filout */ 
      756 			     do i = lnctr to pl - 7;
      757 			     call write ("");
      758 			end;
      759 		     end;				
      760 		end;
      761 				
      762 		ind_minus_und = ind - und;
      763 		goto continue;			/* go process another line */
      764 	     end;
      765 
      766 process_text:  
      767 	     if search (buf, CR_or_VT) ^= 0 
      768 		then do;				/* discard VT or CR */
      769 		do while (index (buf, VT) ^= 0);
      770 		     buf = decat (buf, VT, "101"b);
      771 		end;
      772 		do while (index (buf, CR) ^= 0);
      773 		     buf = decat (buf, CR, "101"b);
      774 		end;
      775 		buf = rtrim (buf, HT_or_SP);            /* rtrim buf in case there are now blanks at the end */
      776 	     end;
      777 
      778 	     if search (buf, BS_or_HT) ^= 0 
      779 		then do;				/* Input may not be canonical */
      780 		bsndx = index (buf, BS);		/* Or may need tabs expanded */
      781 		if bsndx = 0 
      782 		     then goto tab_check;
      783 		else if bsndx = 1
      784 		     then goto call_canon;		/* BS in pos 1 is uncanonical */
      785 		do while ("1"b);
      786 		     if bsndx = length (buf)
      787 			then goto call_canon;	/* As is BS in last pos */
      788 		     if search (buf_chars (bsndx - 1), BS_or_HT_or_SP) ^= 0
      789 			then goto call_canon;
      790 		     if search (buf_chars (bsndx + 1), BS_or_HT_or_SP) ^= 0
      791 			then goto call_canon;
      792 		     bsndx1 = bsndx + index (substr (buf, bsndx + 1), BS);
      793 		     if bsndx = bsndx1
      794 			then goto tab_check;	/* No more BSs */
      795 		     bsndx = bsndx1;
      796 		end;
      797 
      798 tab_check:	tabndx = index (buf, HT);
      799 		do while (tabndx ^= 0);		/* While there are tabs */
      800 		     vtabndx = tabndx;
      801 		     do i = 2 to tabndx;		/* Determine virtual position of tab in line */
      802 			if buf_chars (i) = BS	/* BS means line is virtually */
      803 			     then do;		/* 2 less characters wide than seems */
      804 			     vtabndx = vtabndx - 2;
      805 			     i = i + 1;		/* Next char is not BS */
      806 			end;
      807 		     end;
      808 		     tabfill = 11 - mod (vtabndx, 10);	/* See how many spaces to fill in */
      809 		     if tabfill = 11 
      810 			then tabfill = 1;	
      811 		     buf = substr (buf, 1, tabndx - 1)	/* Fill 'em in */
      812 			|| copy (" ", tabfill)
      813 			|| substr (buf, tabndx + 1);
      814 		     tabndx = index (buf, HT);
      815 		end;
      816 		goto dont_canon;
      817 
      818 call_canon:	call canonicalize_ (addr (buf_chars (1)), (buf_len), addr (buf_chars (1)), buf_len21, code);
      819 		if code ^= 0 
      820 		     then goto done;
      821 		buf_len = buf_len21;
      822 dont_canon:    end;
      823 
      824 	     line_began_with_blank = "0"b;
      825 
      826 	     if ^fill 
      827 		then do;				/* No fill, just write it */
      828 		store = buf;
      829 		store = copy (" ", ind_minus_und) || store;
      830 		call write (store);
      831 		store = "";
      832 		goto check_length;
      833 	     end;
      834 
      835 	     else if length (buf) = 0 
      836 		then do;				/* null line? */
      837 		if store_len ^= 0 
      838 		     then do;			/* if there is something left */
      839 		     store = copy (" ", ind_minus_und) || store;     /* then indent */
      840 		     call write (store);		/* and write it */
      841 		end;
      842 		call write (buf);			/* now write out null line */
      843 		store = "";			/* clear out save area */
      844 		goto check_length;
      845 	     end;
      846 	     else if buf_chars (1) = " " 
      847 		then do;				/* leading blank cause break */
      848 		line_began_with_blank = "1"b;
      849 		if store_len ^= 0 
      850 		     then do;			/* if save area not empty */
      851 		     store = copy (" ", ind_minus_und) || store;     /* indent it */
      852 		     call write (store);		/* and write it */
      853 		end;
      854 		store = buf;			/* move buffer to save area */
      855 	     end;
      856 	     else do;
      857 		if component_ends_wo_NL		/* special handling */
      858 		     then do;			/* when spanning msf */
      859 		     component_ends_wo_NL = "0"b;	/* components */
      860 		     store = store || buf;
      861 		end;
      862 		else do;				/* concatenate buffer to end of save area */
      863 		     if store_len > 0
      864                               then store = store || " ";
      865 		     store = store || buf;
      866 		end;
      867 	     end;
      868 
      869 /* The following code enforces the convention of 2 spaces after certain 
      870*   punctuation.  What appears to be a serious flirtation with stringrange is
      871*   actually a firm knowledge that store has been rtrimmed of spaces. */
      872 
      873 	     if ^dont_compress
      874 		then do;
      875 		if dont_break_indented_lines & line_began_with_blank
      876 		     then if nlindex >= inlen		/* if next line blank or this is eof */
      877 		     then goto check_length;		/* don't do any compression */
      878 		else if search (in_chars (nlindex + 1), HT_or_NL_or_SP) ^= 0
      879 		     then goto check_length;
      880 		spindex = index (store, " ");		
      881 		if spindex = 1			/* Don't mess with leading spaces */
      882 		     then do;			/* Find first space after non-blank char */
      883 		     spindex = verify (store, " ");
      884 		     spindex1 = index (substr (store, spindex), " ");
      885 		     if spindex1 = 0
      886 			then spindex = 0;
      887 		     else spindex = spindex + spindex1 - 1;
      888 		end;
      889 		if spindex ^= 0			
      890 		     then do while (index (substr (store, spindex), " ") ^= 0);
      891 		     if verify (store_char (spindex - 1), ":.!?)") = 0
      892 			then do;
      893 			if store_char (spindex - 1) = ")"
      894 			     then do;
      895 			     if spindex < 3
      896 				then goto compress_blanks;
      897 			     if verify (store_char (spindex - 2), "!?.") ^= 0
      898 				then goto compress_blanks;
      899 			end;
      900 			if store_char (spindex + 1) ^= " " /* should be 2 spaces */
      901 			     then store = substr (store, 1, spindex) || " " || substr (store, spindex + 1);
      902 			else do while (store_char (spindex + 2) = " ");	/* and only 2 */
      903 			     store = substr (store, 1, spindex + 1) || substr (store, spindex + 3);
      904 			end;
      905 			spindex = spindex + 2;	/* look at next char past spaces */
      906 		     end;
      907 		     else do;				
      908 compress_blanks:		do while (store_char (spindex + 1) = " ");
      909 			     store = substr (store, 1, spindex) || substr (store, spindex + 2);
      910 			end;
      911 			spindex = spindex + 1;	/* skip over space */
      912 		     end;
      913 		     spindex1 = index (substr (store, spindex), " ");
      914 		     if spindex1 = 0
      915 			then goto check_length;
      916 		     else spindex = spindex + spindex1 - 1;
      917 		end;
      918 	     end;
      919 	     	     	     	     
      920 check_length:  if ll - ind_minus_und < 1		/* negative effective linelength */
      921 		then do;
      922 		call err_reporter (fdoc_et_$line_length_too_small);
      923 		code = error_table_$fatal_error;
      924 		goto done;
      925 	     end;
      926 
      927 	     do while (length (rtrim (store)) + ind_minus_und > ll - 1);	/* if line long enough, deal with it */
      928 
      929 /* check for backspaces */
      930 /* if there are backspaces in the line we got problems, and therefore branch to a special routine */
      931 		if index (store, BS) < ll - ind_minus_und + 2 & index (store, BS) ^= 0 
      932 		     then goto bs_rtn;
      933 		store = copy (" ", ind_minus_und) || store;	/* indent */
      934 		if line_began_with_blank & dont_break_indented_lines
      935 		     then do;			/* called by Gary Palter */
      936 		     if nlindex < inlen		/* don't break the line if is followed by a blank line */
      937 						/* or an indented line or the end of the file */
      938 			then if search (in_chars (nlindex + 1), HT_or_NL_or_SP) = 0
      939 			then goto process_normally;
      940 		     call write (store);
      941 		     store = "";
      942 		     goto continue;
      943 		end;
      944 
      945 process_normally:	if store_len = ll 
      946 		     then do;			/* line is exactly the right size */
      947 		     outline = rtrim (store);		/* put it in the output buffer */
      948 		     store = "";			/* clear save area */
      949 		     call write (outline);		/* write it out */
      950 		end;
      951 		else if store_char (ll + 1) = " " 
      952 		     then do;			/* blank at ll + 1 */
      953 		     outline = rtrim (substr (store, 1, ll)); /* put first ll chars in out buffer */
      954 		     store = ltrim (substr (store, ll + 2)); /* let save area have the rest */
      955                          if outline ^= "" then do;
      956                               if adjust & length (outline) < ll	/* needs adjusted */
      957 			then call adjust_line (outline, ll);
      958 		          call write (outline);		/* and write */
      959                          end;
      960 		end;
      961 		else do;
      962 
      963 /* find first blank counting left from ll */
      964 		     spindex = ll - index (reverse (substr (store, 1, ll)), " ");
      965 		     if spindex ^= ll &
      966 			(spindex - ind) > 0		/* don't wanna go into the left margin */
      967 			then do;
      968 			if hyphenating
      969 			     then if ll - spindex > current_syllable_size + 1
      970 			     then do;
      971 			     hyph_ptr = addr (store_char (spindex + 2));
      972 			     hyph_len = search (substr (store, spindex + 2), " ") - 1;
      973 			     if hyph_len = -1		/* no spaces */
      974 				then hyph_len = store_len - spindex - 1;
      975 			     hyph_space = ll - spindex - 1;
      976 			     call hyphenate_word_ (hyph_word, hyph_space, hyph_point, code);
      977 			     if code ^= 0 
      978 				then goto done;
      979 			     if hyph_point > current_syllable_size - 1
      980 				then do;
      981 				outline = rtrim (substr (store, 1, spindex + hyph_point + 1));
      982 				outline = outline || HYPHEN;
      983 				store = ltrim (substr (store, spindex + hyph_point + 2));
      984 				goto adjust_check;
      985 			     end;
      986 			end;
      987 			outline = rtrim (substr (store, 1, spindex)); /* save off chars up to that blank */
      988 			store = ltrim (substr (store, spindex + 2)); /* put rest in save area */
      989 adjust_check:		if adjust 
      990 			     then call adjust_line (outline, ll); /* call space filling rtn */
      991 		     end;
      992 
      993 						/* no blanks from 1 to ll */
      994 		     else do;
      995 
      996 			if hyphenating		/* try hyphenating first */
      997 			     then do;
      998 			     hyph_ptr = addr (store_char (1));
      999 			     hyph_len = store_len;
     1000 			     hyph_space = ll;
     1001 			     call hyphenate_word_ (hyph_word, hyph_space, hyph_point, code);
     1002 			     if code ^= 0
     1003 				then goto done;
     1004 			     if hyph_point >= current_syllable_size
     1005 				then do;
     1006 				outline = substr (store, 1, hyph_point);
     1007 				outline = outline || HYPHEN;
     1008 				store = substr (store, hyph_point + 1);
     1009 				goto write_here;
     1010 			     end;
     1011 			end;
     1012 			if breaking_words
     1013 			     then do;		/* either cut it off in mid-word */
     1014 			     outline = substr (store, 1, ll);
     1015 			     store = substr (store, ll + 1);
     1016 			end;
     1017 			else do;
     1018 			     if index (substr (store, ind + 1), " ") ^= 0
     1019 						/* or cut it off at first blank past ll */
     1020 			     then do;
     1021 			          outline = substr (store, 1, index (store, " ") - 1);
     1022 				store = ltrim (substr (store, index (store, " ") + 1));
     1023 			     end;
     1024 			     else do;		/* no blanks anywhere in line */
     1025 				outline = store;
     1026 				store = "";
     1027 			     end;
     1028 			     call err_reporter (fdoc_et_$text_too_long_for_line);	/* too much data for output line */
     1029 			end;
     1030 		     end;
     1031 write_here:	     call write (outline);		/* and finally write */
     1032 		end;
     1033 still_in_write_loop_with_more_to_process:		/* come back here from bs_rtn */
     1034 	     end;
     1035 	     goto continue;				/* branch around backspace code */
     1036 
     1037 bs_rtn:
     1038 
     1039 /* At this point we think we have more than ll characters, but we know we have
     1040*   backspaces.  We have to find out how many print positions we actually have
     1041*   and if it's still more than ll, we have to locate where to break the line
     1042*   apart.  vlen is the actual number of print positions. */
     1043 	     
     1044 	     store = copy (" ", ind_minus_und) || store;/* indent */
     1045 	     last_blank = 0;
     1046 	     vlen = 0;
     1047 	     bscnt = 0;
     1048 	     long_line_and_no_blank = "0"b;
     1049 	     fit = "0"b;
     1050 	     do k = 1 to store_len while (^fit);
     1051 		if store_char (k) = BS
     1052 		     then do;
     1053 		     k = k + 1;
     1054 		     bscnt = bscnt + 1;
     1055 		end;
     1056 		else vlen = vlen + 1;
     1057 		if store_char (k) = " "
     1058 		     then do;
     1059 		     if long_line_and_no_blank 
     1060 			then do;
     1061 			outline = substr (store, 1, k - 1);
     1062 			store = ltrim (substr (store, k));
     1063 			call err_reporter (fdoc_et_$text_too_long_for_line);
     1064 			call write (outline);
     1065 			goto still_in_write_loop_with_more_to_process;
     1066 		     end;
     1067 		     last_blank = k;
     1068 		     if vlen > ll
     1069 			then do;
     1070 			outline = substr (store, 1, k - 1);
     1071 			store = ltrim (substr (store, k));
     1072 			call err_reporter (fdoc_et_$text_too_long_for_line);
     1073 			call write (outline);
     1074 			goto still_in_write_loop_with_more_to_process;
     1075 		     end;
     1076 		end;
     1077 		if vlen = ll
     1078 		     then do;
     1079 		     if k < store_len
     1080 			then if store_char (k + 1) = BS
     1081 			then k = k + 2;
     1082 		     if k = store_len
     1083 			then fit = "1"b;
     1084 		     if k < store_len
     1085 			then if store_char (k + 1) = " "
     1086 			then fit = "1"b;
     1087 		     else if last_blank ^= 0
     1088 			then do;
     1089 			do h = last_blank + 1 to k - 1;
     1090 			     if store_char (h) = BS
     1091 				then bscnt = bscnt - 1;
     1092 			end;
     1093 			k = store_len;
     1094 		     end;
     1095 		     else if breaking_words
     1096 			then do;
     1097 			outline = substr (store, 1, k);
     1098 			store = substr (store, k + 1);
     1099 			call write (outline);
     1100 			goto still_in_write_loop_with_more_to_process;
     1101 		     end;
     1102 		     else long_line_and_no_blank = "1"b;
     1103 		end;
     1104 	     end;
     1105 
     1106 	     if long_line_and_no_blank
     1107 		then do;
     1108 		outline = store;
     1109 		store = "";
     1110 		call err_reporter (fdoc_et_$text_too_long_for_line);
     1111 		call write (outline);
     1112 		goto continue;
     1113 	     end;
     1114 	     else if vlen < ll			/* print position count < ll */
     1115 		then do;
     1116 		store = substr (store, (ind + 1) - und);/* undo indentation */
     1117 		goto continue;			/* get another line */
     1118 	     end;
     1119 	     else if fit
     1120 		then do;
     1121 		outline = substr (store, 1, k - 1);
     1122 		if k - 1 ^= store_len
     1123 		     then store = ltrim (substr (store, k));
     1124 		else store = "";
     1125 		call write (outline);
     1126 	     end;
     1127 	     else do;
     1128 		if line_began_with_blank & dont_break_indented_lines
     1129 		     then do;			/* see the comments that proceed */
     1130 		     if nlindex < inlen		/* the label "process_normally" */
     1131 			then if search (in_chars (nlindex + 1), HT_or_NL_or_SP) = 0
     1132 			then goto process_backspaces_normally;
     1133 		     call write (store);
     1134 		     store = "";
     1135 		     goto continue;
     1136 		end;
     1137 process_backspaces_normally:
     1138 		outline = rtrim (substr (store, 1, last_blank - 1)); /* move printable portion to buffer */
     1139 		store = ltrim (substr (store, last_blank + 1)); /* make rest contents of store */
     1140 		if adjust 
     1141 		     then call adjust_line (outline, ll + bscnt * 2);  /* call space fill rtn */
     1142 		call write (outline);		/* and write */
     1143 	     end;
     1144 	     goto still_in_write_loop_with_more_to_process;
     1145 
     1146 continue:
     1147 	     if nlindex ^= 0			/* if there is more data */
     1148 		then do;
     1149 		inptr = addr (in_chars (nlindex + 1));	/* move input ptr past next NL */
     1150 		inlen = inlen - nlindex;		/* change length to reflect what is left */
     1151                     if continued_line
     1152                            then do;
     1153                            spindex = verify (infile, " ");
     1154                            inptr = addr (in_chars (spindex));
     1155                            inlen = inlen - spindex + 1;
     1156                     end;
     1157 	     end;
     1158 	     else goto no_more_data;			/* end of component, maybe end of file */
     1159 	end;
     1160 
     1161 /* Almost done, now clean up. */
     1162 
     1163 no_more_data:
     1164 	if string_entry				/* input string can't be MSF */
     1165 	     then goto no_more_components;
     1166 	in_comp_no = in_comp_no + 1;			/* try next component */
     1167 	call msf_manager_$get_ptr (infcbptr, in_comp_no, "0"b, inptr, bc, code);
     1168 	if inptr = null
     1169 	     then if code = error_table_$noentry	/* we have processed last component */
     1170 	     then do;
     1171 		code = 0;
     1172 		goto no_more_components;
     1173 	     end;
     1174 	else goto done;				/* msf_manager_ crapped out */
     1175 	component_ends_wo_NL = (initial_in_chars (initial_inlen) ^= NL);
     1176 	inlen = divide (bc, 9, 21, 0);
     1177 	goto process_one_component;			/* here we go again */
     1178 	
     1179 no_more_components:
     1180 	if store_len ^= 0
     1181 	     then do;
     1182 	     store = copy (" ", ind_minus_und) || store;/* indent */
     1183 	     call write (store);			/* write out last line */
     1184 	end;
     1185 	if lnctr ^= 0 & ^galley_mode			/* if a partial */
     1186 	     then do;				/* page has been written */
     1187 	     if pgno 
     1188 		then do;
     1189 		do k = 1 to ((pl - 5) - lnctr);
     1190 		     if filout 
     1191 			then call write_file (NL);	/* add blank line */
     1192 		     else do;
     1193 			ioxbuf = NL;
     1194 			call iox_$put_chars (iocbptr, addr (ioxbuf), 1, code);
     1195 			if code ^= 0
     1196 			     then goto done;
     1197 		     end;
     1198 		end;
     1199 		pgctr = pgctr + 1;			/* bump page counter */
     1200 		pgctra = ltrim (char (pgctr));
     1201 						/* and write page number */
     1202 		if filout 
     1203 		     then call write_file (indstr 
     1204 		     || copy (" ", divide (ll - length (pgctra), 2, 17, 0))
     1205 		     || pgctra || FF);
     1206 		else do;
     1207 		     ioxbuf = indstr 
     1208 			|| copy (" ", divide (ll - length (pgctra), 2, 17, 0))
     1209 			|| pgctra || copy (NL, 5);
     1210 		     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
     1211 		     if code ^= 0
     1212 			then goto done;
     1213 		end;
     1214 	     end;
     1215 	     else do;
     1216 		if filout & char_cnt ^= 1
     1217 		     then do;
     1218 		     outptr = addr (out_chars (char_cnt - 1)); /* back up outptr 1 position */
     1219 		     char_cnt = char_cnt - 1;
     1220 		     call write_file (FF);		/* replace trailing NL with FF */
     1221 		end;
     1222 		else if ^filout
     1223 		     then do k = 1 to (pl - lnctr);
     1224 		     ioxbuf = NL;
     1225 		     call iox_$put_chars (iocbptr, addr (ioxbuf), 1, code);
     1226 		     if code ^= 0
     1227 			then goto done;
     1228 		end;
     1229 	     end;
     1230 	end;
     1231 	if string_entry 
     1232 	     then outlen = char_cnt - 1;
     1233 
     1234 check_version_and_set_options:
     1235 	proc;
     1236 		
     1237 	if format_document_options.version_number = format_document_version_1
     1238 	     then do;				/* assign defaults */
     1239 	     dont_compress, breaking_words, maximum_line_length, 
     1240 		dont_break_indented_lines, using_sub_err, hyphenating = "0"b;
     1241 	     fill = "1"b;
     1242 	     default_syllable_size = 2;		/* old version has no syllable size, assign one */
     1243 	end;
     1244 	else if format_document_options.version_number = format_document_version_2
     1245 	     then do;				/* this guy knows what he is doing */
     1246 		dont_compress = format_document_options.switches.dont_compress_sw;
     1247 		breaking_words = format_document_options.switches.break_word_sw;
     1248 		maximum_line_length = format_document_options.switches.max_line_length_sw;
     1249 		dont_break_indented_lines = format_document_options.switches.dont_break_indented_lines_sw;
     1250 		using_sub_err = format_document_options.switches.sub_err_sw;
     1251 		fill = ^format_document_options.switches.dont_fill_sw;
     1252 		hyphenating = format_document_options.switches.hyphenation_sw;
     1253 		default_syllable_size = format_document_options.syllable_size;
     1254 	     end;
     1255 	else do;
     1256 	     code = error_table_$unimplemented_version;
     1257 	     goto done;
     1258 	end;
     1259 
     1260 	adjust = format_document_options.switches.adj_sw;
     1261 	galley_mode = format_document_options.switches.galley_sw;
     1262 	initial_ind = format_document_options.indentation;
     1263 	initial_line_length = format_document_options.line_length;
     1264 	literal_mode = format_document_options.literal_sw;
     1265 	ll = format_document_options.line_length;
     1266 	pgno = format_document_options.switches.pgno_sw;
     1267 
     1268      end check_version_and_set_options;
     1269 
     1270 write:	proc (line);
     1271 dcl  line char (*) varying parameter;
     1272 
     1273 	und = 0;					/* get rid of undent, it only applies to one line */
     1274 	ind_minus_und = ind;
     1275 	if lnctr = 0 & ^galley_mode
     1276 	     then do;				/* BEGIN PAGE */
     1277 	     if filout 
     1278 		then call write_file (copy (NL, 3));
     1279 	     else do;
     1280 		ioxbuf = copy (NL, 6);
     1281 		call iox_$put_chars (iocbptr, addr (ioxbuf), 6, code);
     1282 		if code ^= 0
     1283 		     then goto done;
     1284 	     end;
     1285 	     lnctr = 6;
     1286 	end;
     1287 
     1288 	if filout 				/* WRITE LINE */
     1289 	     then call write_file (indstr||line||NL);     /* add a newline */
     1290 	else do;
     1291 	     ioxbuf = indstr||line||NL;
     1292 	     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
     1293 	     if code ^= 0
     1294 		then goto done;
     1295 	end;
     1296 
     1297 	if ^galley_mode				/* END PAGE */
     1298 	     then do;
     1299 	     lnctr = lnctr + 1;			/* bump line counter */
     1300 	     if pgno
     1301 		then if lnctr = (pl - 7)
     1302 		then do;
     1303 		pgctr = pgctr + 1;   		/* bump page counter */
     1304 		lnctr = 0;			/* roll the line counter */
     1305 		pgctra = ltrim (char (pgctr));
     1306 
     1307 
     1308 		if filout				/* write page number */
     1309 		     then call write_file (copy (NL, 2) || indstr 
     1310 		     || copy (" ", divide (ll - length (pgctra), 2, 17, 0))
     1311 		     || pgctra || FF);
     1312 		else do;
     1313 		     ioxbuf = copy (NL, 2) || indstr
     1314 			|| copy (" ", divide (ll - length (pgctra), 2, 17, 0))
     1315 			|| pgctra || copy (NL, 5);
     1316 		     call iox_$put_chars (iocbptr, addr (ioxbuf), length (rtrim (ioxbuf)), code);
     1317 		     if code ^= 0
     1318 			then goto done;
     1319 		end;
     1320 	     end;
     1321 	     else;
     1322 	     else if lnctr = (pl - 6)
     1323 		then do;
     1324 		lnctr = 0;
     1325 		if filout & char_cnt ^= 1
     1326 		     then out_chars (char_cnt - 1) = FF; /* overwrite LF with FF */
     1327 		else if ^filout
     1328 		     then do;
     1329 		     ioxbuf = copy (NL, 6);
     1330 		     call iox_$put_chars (iocbptr, addr (ioxbuf), 6, code);
     1331 		     if code ^= 0
     1332 			then goto done;
     1333 		end;
     1334 	     end;
     1335 	end;
     1336      end write;
     1337 
     1338 write_file:
     1339      proc (text);
     1340 dcl  text char (*) parameter;
     1341 
     1342      tlen = length (text);
     1343      char_cnt = char_cnt + tlen;
     1344 
     1345      if string_entry
     1346 	then do;
     1347 	if (char_cnt - 1) > outstringlen		/* can't write past end of string */
     1348 	     then do;
     1349 	     space_available = outstringlen + tlen + 1 - char_cnt;	/* write what you can */
     1350 	     substr (outfile, 1, space_available) = substr (text, 1, space_available);
     1351 	     outlen = outstringlen;
     1352 	     code = error_table_$smallarg;		/* and go boom */
     1353 	     goto done;
     1354 	end;
     1355 	else substr (outfile, 1, tlen) = text;		/* normal write */
     1356      end;
     1357 
     1358      else if char_cnt > maxcnt			/* can't write past end of component */
     1359 	then do;
     1360 	space_available = tlen + maxcnt - char_cnt;	/* write what you can */
     1361 	substr (outfile, 1, space_available) = substr (text, 1, space_available);
     1362 	out_comp_no = out_comp_no + 1;		/* get another component */
     1363 	call msf_manager_$get_ptr (outfcbptr, out_comp_no, "1"b, outptr, bc, code);
     1364 	if outptr = null ()				/* msf_manager_ burped */
     1365 	     then do;
     1366 	     format_document_options.file_sw = "1"b;
     1367 	     goto done;
     1368 	end;
     1369 	initial_outptr = outptr;			/* write rest to next component */
     1370 	substr (outfile, 1, tlen - space_available) = substr (text, space_available + 1);
     1371 	char_cnt = (tlen - space_available) + 1;
     1372      end;
     1373      else substr (outfile, 1, tlen) = text;		/* normal write */
     1374 
     1375      outptr = addr (out_chars (char_cnt));		/* move output ptr to next available position */
     1376 end write_file;
     1377 
     1378 adjust_line: proc (adj_line, linelength);
     1379 
     1380 /* routine to fill spaces into line that is less than ll long */
     1381 dcl  adj_line char (508) varying parameter;
     1382 dcl  linelength fixed parameter;
     1383 
     1384 	     spaces = 0;
     1385 	     adj_line_out = adj_line;
     1386 	     pads = linelength - length (adj_line);	/* how many spaces to fill */
     1387 	     do i = verify (adj_line, " ") to length (adj_line);
     1388 		spindex = index (substr (adj_line, i), " ");
     1389 		if spindex = 0
     1390 		     then i = length (adj_line);
     1391 		else do;
     1392 		     spaces = spaces + 1;		/* add to count of spaces in line */
     1393 		     i = i + spindex - 1;
     1394 		     space_pos (spaces) = i;		/* mark position of space */
     1395 		end;
     1396 	     end;
     1397 
     1398 /* fill spaces in adjacent to existing spaces starting from left on first line
     1399*   (starting again on left if necessary) and then reverse the procedure to 
     1400*   start from the right the next time 
     1401**/
     1402 	     if spaces ^= 0 
     1403 		then do;
     1404 		if left 
     1405 		     then do i = 1 to pads;		/* adjust from left */
     1406 		     j = mod (i, spaces);
     1407 		     if j = 0 
     1408 			then j = spaces;
     1409 		     adj_line_out = substr (adj_line_out, 1, space_pos (j) + j - 1)||" "||substr (adj_line_out, space_pos (j) + j);
     1410 		     space_pos (j) = space_pos (j) + j;
     1411 		     left = "0"b;
     1412 		end;
     1413 		else do;				/* adjust from right */
     1414 		     k = spaces;
     1415 		     do i = pads to 1 by -1;
     1416 			if k = 0 
     1417 			     then k = spaces;
     1418 			adj_line_out = substr (adj_line_out, 1, space_pos (k))||substr (adj_line_out, space_pos (k));
     1419 			do j = k to spaces;
     1420 			     space_pos (j) = space_pos (j) + 1;
     1421 			end;
     1422 			left = "1"b;
     1423 			k = k - 1;
     1424 		     end;
     1425 		end;
     1426 	     end;
     1427 	     adj_line = adj_line_out;
     1428 	end adjust_line;
     1429 
     1430 look_for_hyphenation_routine: 
     1431 	     proc;
     1432 
     1433 	     on linkage_error 
     1434 		begin;
     1435 		hyphenating = "0"b;	
     1436 		hyphenation_routine_state = 2;	/* not found */
     1437 		call err_reporter (fdoc_et_$no_hyphenate_word);
     1438 		goto reversion;
     1439 	     end;
     1440 	     hyphenate_entry = hyphenate_word_;
     1441 	     hyphenation_routine_state = 1;		/* found */
     1442 reversion:
     1443 	     revert linkage_error;
     1444 	end look_for_hyphenation_routine;
     1445 
     1446 err_reporter:
     1447 	     proc (errcode);
     1448 dcl errcode fixed bin (35) parameter;
     1449 
     1450 	     error = "1"b;
     1451 	     errtxt = "";
     1452 
     1453 	     if format_document_options.error_sw
     1454 		then do;
     1455 		call convert_status_code_ (errcode, trash, errtxt);
     1456 		call ioa_$rs ("line ^d^-^a^[^s^;^/^a^]",
     1457 		     error_lines,
     1458 		     elen,
     1459 		     inplnctr,
     1460 		     errtxt,
     1461 		     ((^filout) & 
     1462 			((errcode = fdoc_et_$text_too_long_for_line)) | 
     1463 			(errcode = fdoc_et_$line_too_long) | 
     1464 			(errcode = fdoc_et_$no_hyphenate_word)),
     1465 		     buf);
     1466 
     1467 		call iox_$put_chars (iox_$error_output, addr (error_lines), elen, code);
     1468 		if code ^= 0
     1469 		     then goto done;
     1470 	     end;
     1471 	     
     1472 	     if using_sub_err
     1473 		then do;
     1474 		if errtxt ^= ""
     1475 		     then call convert_status_code_ (errcode, trash, errtxt);
     1476 		if errcode = fdoc_et_$line_length_too_small
     1477 		     then subcode = error_table_$fatal_error;
     1478 		else subcode = error_table_$recoverable_error;
     1479 		error_info.version_number = format_document_error_version_1;
     1480 		error_info.error_code = errcode;
     1481 		error_info.line_number = inplnctr;
     1482 		if errcode = fdoc_et_$no_hyphenate_word
     1483 		     then error_info.text_line = "";
     1484 		else error_info.text_line = buf;
     1485 		call sub_err_ (subcode, 
     1486 		     "format_document_", 
     1487 		     (ACTION_CAN_RESTART | ACTION_DEFAULT_RESTART | ACTION_QUIET_RESTART),
     1488 		     addr (error_info), 
     1489 		     retval,
     1490 		     errtxt);
     1491 	     end;
     1492 
     1493 	end err_reporter;
     1494 
     1495 done_proc:     
     1496 	proc;					/* clean up time */
     1497 
     1498 	if indptr ^= null ()
     1499 	     then free indstr;
     1500 	if code = 0 & error
     1501 	     then code = error_table_$recoverable_error;
     1502 	if infcbptr ^= null ()
     1503 	     then call msf_manager_$close (infcbptr);
     1504 	if outfcbptr ^= null ()
     1505 	     then do;
     1506 	     call tssi_$finish_file (outfcbptr, out_comp_no, ((char_cnt - 1) * 9), "101"b, aclinfoptr, temp_code);
     1507 	     if code = 0				/* don't want to clobber code so use a temporary */
     1508 		then code = temp_code;		/* and then assign it if code was zero */
     1509 	end;
     1510      end done_proc;
     1511      
     1512 done:
     1513 	call done_proc;
     1514 	
     1515      end format_document_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1151.3  format_document_.pl1              >udd>sm>ds>w>ml>format_document_.pl1
296          1    11/01/84  1614.0  format_document_options.incl.pl1  >ldd>incl>format_document_options.incl.pl1
298          2    04/13/83  1652.8  format_document_error.incl.pl1    >ldd>incl>format_document_error.incl.pl1
300          3    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CAN_RESTART                     constant        bit(36)                  initial dcl 3-7 ref 1485
ACTION_DEFAULT_RESTART                 constant        bit(36)                  initial dcl 3-7 ref 1485
ACTION_QUIET_RESTART                   constant        bit(36)                  initial dcl 3-7 ref 1485
BS                              012143 constant        char(1)                  initial packed unaligned dcl 262 ref 780 792 802 931
                                                                                  931 1051 1079 1090
BS_or_HT                               constant        char(2)                  initial packed unaligned dcl 263 ref 778
BS_or_HT_or_SP                  000054 constant        char(3)                  initial packed unaligned dcl 264 ref 788 790
BUFFER_SIZE                            constant        fixed bin(17,0)          initial dcl 265 ref 434
BUFFER_SIZE_PLUS_ONE                   constant        fixed bin(17,0)          initial dcl 266 ref 431 438 438 439
CR                              012142 constant        char(1)                  initial packed unaligned dcl 267 ref 772 773
CR_or_VT                               constant        char(2)                  initial packed unaligned dcl 268 ref 766
DEFAULT_LINE_LENGTH                    constant        fixed bin(17,0)          initial dcl 269 ref 590
DEFAULT_PAGE_LENGTH                    constant        fixed bin(17,0)          initial dcl 270 ref 415 609
FF                              000053 constant        char(1)                  initial packed unaligned dcl 271 set ref 1202 1220*
                                                                                  1308 1325
HT                                     constant        char(1)                  initial packed unaligned dcl 272 ref 468 798 814
HT_or_NL_or_SP                  000052 constant        char(3)                  initial packed unaligned dcl 274 ref 878 936 1130
HT_or_SP                               constant        char(2)                  initial packed unaligned dcl 273 ref 434 434 441 462
                                                                                  775
HYPHEN                          012141 constant        char(1)                  initial packed unaligned dcl 276 ref 982 1007
NL                              000051 constant        char(1)                  initial packed unaligned dcl 277 set ref 426 1175
                                                                                  1190* 1193 1207 1224 1277 1277 1280 1288 1291 1308
                                                                                  1313 1313 1329
VT                              012140 constant        char(1)                  initial packed unaligned dcl 279 ref 769 770
aclinfoptr                      000100 automatic       pointer                  dcl 136 set ref 334* 1506*
addr                                                   builtin function         dcl 286 ref 362 363 450 464 464 715 788 790 802 818
                                                                                  818 818 818 818 818 818 818 818 821 837 846 849
                                                                                  863 891 893 897 900 902 908 945 951 971 971 973
                                                                                  998 998 999 1050 1051 1057 1079 1079 1082 1084
                                                                                  1084 1090 1093 1122 1149 1154 1179 1194 1194 1210
                                                                                  1210 1218 1225 1225 1281 1281 1292 1292 1316 1316
                                                                                  1330 1330 1375 1467 1467 1485 1485
adj_line                               parameter       varying char(508)        dcl 1381 set ref 1378 1385 1386 1387 1387 1388 1389
                                                                                  1427*
adj_line_out                    000102 automatic       varying char(508)        dcl 137 set ref 1385* 1409* 1409 1409 1418* 1418
                                                                                  1418 1427
adj_sw                    3(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1260
adjust                          000302 automatic       bit(1)                   dcl 138 set ref 731* 956 989 1140 1260*
after                                                  builtin function         dcl 286 ref 470 479
bc                              000303 automatic       fixed bin(24,0)          dcl 139 set ref 325* 328 333 390* 393 398 1167* 1176
                                                                                  1363*
before                                                 builtin function         dcl 286 ref 470 472
blank_lines_to_be_written       000304 automatic       fixed bin(17,0)          dcl 140 set ref 693* 695* 737
break_word_sw             3(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1247
breaking_words                  000305 automatic       bit(1)                   dcl 141 set ref 444 1012 1095 1239* 1247*
bscnt                           000310 automatic       fixed bin(17,0)          dcl 144 set ref 1047* 1054* 1054 1090* 1090 1140
bsndx                           000306 automatic       fixed bin(17,0)          dcl 142 set ref 780* 781 783 786 788 790 792 792 793
                                                                                  795*
bsndx1                          000307 automatic       fixed bin(17,0)          dcl 143 set ref 792* 793 795
buf                             000311 automatic       varying char(256)        dcl 145 set ref 434* 441* 446* 462* 464 464 468* 468
                                                                                  469 470* 470 470 472 479 766 769 770* 770 772 773*
                                                                                  773 775* 775 778 780 786 788 790 792 798 802 811*
                                                                                  811 811 814 818 818 818 818 818 821 828 835 842*
                                                                                  846 854 860 865 1456* 1484
buf_chars                 1            based           char(1)                  array level 2 packed packed unaligned dcl 253 set
                                                                                  ref 464 788 790 802 818 818 818 818 846
buf_len                                based           fixed bin(35,0)          level 2 dcl 253 set ref 464 818 821*
buf_len21                       000412 automatic       fixed bin(21,0)          dcl 146 set ref 818* 821
buf_structure                          based           structure                level 1 unaligned dcl 253
canonicalize_                   000012 constant        entry                    external dcl 90 ref 818
char                                                   builtin function         dcl 286 ref 1200 1305
char_cnt                        000413 automatic       fixed bin(21,0)          dcl 147 set ref 401* 1216 1218 1219* 1219 1231 1325
                                                                                  1325 1343* 1343 1347 1349 1350 1355 1358 1360 1361
                                                                                  1370 1371* 1373 1375 1506
cleanup                         002046 stack reference condition                dcl 291 ref 321 366 386
code                                   parameter       fixed bin(35,0)          dcl 77 set ref 21 315* 322* 323 325* 330* 334* 335
                                                                                  342* 345 356* 359* 369 380* 387* 388 390* 395*
                                                                                  399* 478* 483* 493 496* 517 520* 548* 558* 567*
                                                                                  576* 583 586* 602 605* 629* 646* 654 658* 680 683*
                                                                                  709* 818* 819 923* 976* 977 1001* 1002 1167* 1168
                                                                                  1171* 1194* 1195 1210* 1211 1225* 1226 1256* 1281*
                                                                                  1282 1292* 1293 1316* 1317 1330* 1331 1352* 1363*
                                                                                  1467* 1468 1500 1500* 1507 1507*
component_ends_wo_NL            000414 automatic       bit(1)                   packed unaligned dcl 148 set ref 403* 857 859* 1175*
continued_line                  000415 automatic       bit(1)                   packed unaligned dcl 149 set ref 404* 428* 433* 464
                                                                                  1151
convert_status_code_            000014 constant        entry                    external dcl 92 ref 1455 1474
copy                                                   builtin function         dcl 286 ref 421 452 719 811 829 839 851 933 1037
                                                                                  1182 1202 1207 1207 1277 1277 1280 1308 1308 1313
                                                                                  1313 1313 1329
ctl                             000416 automatic       char(5)                  packed unaligned dcl 150 set ref 472* 473 485
ctl_index                       000420 automatic       fixed bin(17,0)          dcl 151 set ref 485* 486 491 725 725 728 728 731 731
                                                                                  734 734 737 741
ctl_list                        000024 constant        char(83)                 initial packed unaligned dcl 280 ref 485
current_syllable_size           000421 automatic       fixed bin(17,0)          dcl 152 set ref 405* 634* 675* 677* 968 979 1004
cv_dec_check_                   000016 constant        entry                    external dcl 94 ref 483
decat                                                  builtin function         dcl 286 ref 770 773
default_syllable_size           000422 automatic       fixed bin(17,0)          dcl 153 set ref 405 634 677 1242* 1253*
divide                                                 builtin function         dcl 286 ref 333 398 485 1176 1202 1207 1308 1313
dnamin                                 parameter       char                     packed unaligned dcl 78 set ref 21 322* 369 387*
dnamout                                parameter       char                     packed unaligned dcl 79 set ref 21 334*
dont_break_indented_lines       000423 automatic       bit(1)                   dcl 154 set ref 875 934 1128 1239* 1249*
dont_break_indented_lines_sw
                          3(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1249
dont_compress                   000424 automatic       bit(1)                   dcl 155 set ref 873 1239* 1246*
dont_compress_sw          3(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1246
dont_fill_sw              3(11)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1251
elen                            000425 automatic       fixed bin(21,0)          dcl 156 set ref 1456* 1467*
enamin                                 parameter       char                     packed unaligned dcl 80 set ref 21 322* 369 387*
enamout                                parameter       char                     packed unaligned dcl 81 set ref 21 334*
errcode                                parameter       fixed bin(35,0)          dcl 1448 set ref 1446 1455* 1456 1456 1456 1474*
                                                                                  1476 1480 1482
error                           000426 automatic       bit(1)                   dcl 157 set ref 306* 347* 371* 1450* 1500
error_code                1     002002 automatic       fixed bin(35,0)          level 2 dcl 237 set ref 1480*
error_info                      002002 automatic       structure                level 1 unaligned dcl 237 set ref 1485 1485
error_lines                     000427 automatic       char(508)                packed unaligned dcl 158 set ref 1456* 1467 1467
error_sw                  3(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1453
error_table_$fatal_error        000044 external static fixed bin(35,0)          dcl 110 ref 923 1476
error_table_$improper_data_format
                                000046 external static fixed bin(35,0)          dcl 111 ref 315 356 380
error_table_$noentry            000050 external static fixed bin(35,0)          dcl 112 ref 1168
error_table_$recoverable_error  000052 external static fixed bin(35,0)          dcl 113 ref 1478 1500
error_table_$smallarg           000042 external static fixed bin(35,0)          dcl 109 ref 1352
error_table_$unimplemented_version
                                000054 external static fixed bin(35,0)          dcl 114 ref 1256
error_table_$zero_length_seg    000056 external static fixed bin(35,0)          dcl 115 ref 330 395
errtxt                          000626 automatic       char(100)                dcl 159 set ref 1451* 1455* 1456* 1474 1474* 1485*
fdoc_et_$indent_too_far_left    000060 external static fixed bin(35,0)          dcl 116 set ref 532*
fdoc_et_$indent_too_far_right   000062 external static fixed bin(35,0)          dcl 117 set ref 539*
fdoc_et_$line_length_too_small  000064 external static fixed bin(35,0)          dcl 118 set ref 922* 1476
fdoc_et_$line_too_long          000066 external static fixed bin(35,0)          dcl 119 set ref 456* 1456
fdoc_et_$no_hyphenate_word      000070 external static fixed bin(35,0)          dcl 120 set ref 1437* 1456 1482
fdoc_et_$no_parameter_allowed   000072 external static fixed bin(35,0)          dcl 121 set ref 549* 559* 568* 577* 630* 647* 710*
fdoc_et_$no_sign_allowed        000074 external static fixed bin(35,0)          dcl 122 set ref 666* 690*
fdoc_et_$nonnumeric_parameter   000076 external static fixed bin(35,0)          dcl 123 set ref 497* 521* 587* 606* 659* 684*
fdoc_et_$page_length_lt_13      000100 external static fixed bin(35,0)          dcl 124 set ref 617*
fdoc_et_$page_length_lt_14      000102 external static fixed bin(35,0)          dcl 125 set ref 622*
fdoc_et_$page_width_exceeds_max 000104 external static fixed bin(35,0)          dcl 126 set ref 599*
fdoc_et_$text_too_long_for_line 000106 external static fixed bin(35,0)          dcl 127 set ref 1028* 1063* 1072* 1110* 1456
fdoc_et_$undent_too_far_left    000110 external static fixed bin(35,0)          dcl 128 set ref 506*
fdoc_et_$undent_too_far_right   000112 external static fixed bin(35,0)          dcl 129 set ref 511*
fdoc_et_$unsupported_control    000114 external static fixed bin(35,0)          dcl 130 set ref 475* 488*
file_sw                   3(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 set ref
                                                                                  311* 337* 352* 376* 1366*
fill                            000657 automatic       bit(1)                   dcl 160 set ref 734* 826 1241* 1251*
filout                          000660 automatic       bit(1)                   dcl 161 set ref 318* 360* 383* 750 1190 1202 1216
                                                                                  1222 1277 1288 1308 1325 1327 1456
fit                             000661 automatic       bit(1)                   dcl 162 set ref 1049* 1050 1082* 1084* 1119
format_document_error                  based           structure                level 1 dcl 2-9
format_document_error_version_1        constant        fixed bin(17,0)          initial dcl 2-16 ref 1479
format_document_options                based           structure                level 1 dcl 1-12
format_document_options_ptr     002054 automatic       pointer                  dcl 1-62 set ref 310* 311 313 337 351* 352 354 375*
                                                                                  376 378 633 1237 1244 1246 1247 1248 1249 1250
                                                                                  1251 1252 1253 1260 1261 1262 1263 1264 1265 1266
                                                                                  1366 1453
format_document_version_1              constant        fixed bin(17,0)          initial dcl 1-64 ref 1237
format_document_version_2              constant        fixed bin(17,0)          initial dcl 1-63 ref 1244
galley_mode                     000662 automatic       bit(1)                   dcl 163 set ref 741 1185 1261* 1275 1297
galley_sw                 3(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1261
h                               000663 automatic       fixed bin(17,0)          dcl 164 set ref 1089* 1090*
hyph_len                        000664 automatic       fixed bin(21,0)          dcl 165 set ref 972* 973 973* 976 976 999* 1001 1001
hyph_point                      000665 automatic       fixed bin(17,0)          dcl 166 set ref 976* 979 981 983 1001* 1004 1006
                                                                                  1008
hyph_ptr                        000666 automatic       pointer                  dcl 167 set ref 971* 976 998* 1001
hyph_space                      000670 automatic       fixed bin(17,0)          dcl 168 set ref 975* 976* 1000* 1001*
hyph_word                              based           char                     packed unaligned dcl 241 set ref 976* 1001*
hyphenate_entry                 000674 automatic       entry variable           dcl 173 set ref 1440*
hyphenate_word_                 000020 constant        entry                    external dcl 95 ref 976 1001 1440
hyphenating                     000671 automatic       bit(1)                   dcl 169 set ref 418 633* 635 638* 650* 670* 673* 968
                                                                                  996 1239* 1252* 1435*
hyphenation_routine_state       000672 automatic       fixed bin(17,0)          dcl 170 set ref 406* 635 638 671 673 1436* 1441*
hyphenation_sw            3(12)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 633
                                                                                  1252
i                               000700 automatic       fixed bin(17,0)          dcl 174 set ref 737* 746* 755* 801* 802 805* 805*
                                                                                  1387* 1388 1389* 1393* 1393 1394* 1404* 1406*
                                                                                  1415*
in_chars                               based           char(1)                  array packed unaligned dcl 243 set ref 878 936 1130
                                                                                  1149 1154
in_comp_no                      000701 automatic       fixed bin(17,0)          dcl 175 set ref 407* 1166* 1166 1167*
ind                             000702 automatic       fixed bin(17,0)          dcl 176 set ref 408* 500 504 507 509 512 529 725*
                                                                                  762 965 1018 1116 1274
ind_minus_und                   000703 automatic       fixed bin(17,0)          dcl 177 set ref 409* 452 719 762* 829 839 851 920
                                                                                  927 931 933 1037 1182 1274*
indentation               1            based           fixed bin(17,0)          level 2 dcl 1-12 ref 1262
index                                                  builtin function         dcl 286 ref 426 438 469 473 485 769 772 780 792 798
                                                                                  814 880 884 889 913 931 931 964 1018 1021 1022
                                                                                  1388
indptr                          000704 automatic       pointer                  dcl 178 set ref 307* 348* 372* 420* 421 1202 1207
                                                                                  1288 1291 1308 1313 1498 1498
indstr                                 based           char                     packed unaligned dcl 242 set ref 420 421* 1202 1207
                                                                                  1288 1291 1308 1313 1498
infcbptr                        000706 automatic       pointer                  dcl 179 set ref 308* 322* 325* 349* 373* 387* 390*
                                                                                  1167* 1502 1502*
infile                                 based           char                     packed unaligned dcl 245 ref 426 434 434 438 441 446
                                                                                  457 462 1153
initial_in_chars                       based           char(1)                  array packed unaligned dcl 246 ref 1175
initial_ind                     000710 automatic       fixed bin(17,0)          dcl 180 set ref 420 420 421 421 1202 1207 1262* 1288
                                                                                  1291 1308 1313 1498 1498
initial_inlen                   000711 automatic       fixed bin(21,0)          dcl 181 set ref 422* 1175
initial_inptr                   000712 automatic       pointer                  dcl 182 set ref 424* 1175
initial_line_length             000714 automatic       fixed bin(17,0)          dcl 183 set ref 595 598 1263*
initial_outptr                  000716 automatic       pointer                  dcl 184 set ref 341* 363* 1218 1325 1369* 1375
inlen                           000720 automatic       fixed bin(21,0)          dcl 185 set ref 333* 361* 398* 422 425 426 429 434
                                                                                  434 438 441 446 457 462 875 936 1130 1150* 1150
                                                                                  1153 1155* 1155 1176*
inplnctr                        000721 automatic       fixed bin(17,0)          dcl 186 set ref 410* 427* 427 1456* 1481
inptr                           000722 automatic       pointer                  dcl 187 set ref 325* 326 362* 390* 391 424 426 434
                                                                                  434 438 441 446 457 462 878 936 1130 1149* 1149
                                                                                  1153 1154* 1154 1167* 1168
instring                               parameter       char                     packed unaligned dcl 82 set ref 345 361 362
ioa_$rs                         000022 constant        entry                    external dcl 96 ref 1456
iocbptr                                parameter       pointer                  dcl 83 set ref 369 1194* 1210* 1225* 1281* 1292*
                                                                                  1316* 1330*
iox_$error_output               000116 external static pointer                  dcl 131 set ref 1467*
iox_$put_chars                  000024 constant        entry                    external dcl 97 ref 1194 1210 1225 1281 1292 1316
                                                                                  1330 1467
ioxbuf                          000724 automatic       char(508)                packed unaligned dcl 188 set ref 1193* 1194 1194
                                                                                  1207* 1210 1210 1210 1210 1224* 1225 1225 1280*
                                                                                  1281 1281 1291* 1292 1292 1292 1292 1313* 1316
                                                                                  1316 1316 1316 1329* 1330 1330
j                               001123 automatic       fixed bin(17,0)          dcl 189 set ref 1406* 1407 1407* 1409 1409 1409 1409
                                                                                  1410 1410 1410 1419* 1420 1420*
k                               001124 automatic       fixed bin(17,0)          dcl 190 set ref 1050* 1051 1053* 1053 1057 1061 1062
                                                                                  1067 1070 1071 1079 1079 1079* 1079 1082 1084 1084
                                                                                  1089 1093* 1097 1098* 1121 1122 1122 1189* 1222*
                                                                                  1414* 1416 1416* 1418 1418 1419 1423* 1423
last_blank                      001125 automatic       fixed bin(17,0)          dcl 191 set ref 1045* 1067* 1087 1089 1137 1139
left                            001126 automatic       bit(1)                   dcl 192 set ref 411* 1404 1411* 1422*
length                                                 builtin function         dcl 286 ref 361 364 434 480 500 524 545 555 564 573
                                                                                  590 609 626 643 663 675 687 693 705 786 835 927
                                                                                  956 1202 1207 1210 1210 1292 1292 1308 1313 1316
                                                                                  1316 1342 1386 1387 1389
line                                   parameter       varying char             dcl 1271 ref 1270 1288 1291
line_began_with_blank           001127 automatic       bit(1)                   dcl 193 set ref 824* 848* 875 934 1128
line_length               2            based           fixed bin(17,0)          level 2 dcl 1-12 ref 1263 1265
line_number               2     002002 automatic       fixed bin(17,0)          level 2 dcl 237 set ref 1481*
linelength                             parameter       fixed bin(17,0)          dcl 1382 ref 1378 1386
linkage_error                   000000 stack reference condition                dcl 291 ref 1433 1442
literal_mode                    001130 automatic       bit(1)                   dcl 194 set ref 464 1264*
literal_sw                3(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1264
ll                              001131 automatic       fixed bin(17,0)          dcl 195 set ref 446 447 509 512 537 540 590* 592*
                                                                                  592 594* 595 598* 920 927 931 945 951 953 954 956
                                                                                  956* 964 964 965 968 975 989* 1000 1014 1015 1068
                                                                                  1077 1114 1140 1202 1207 1265* 1308 1313
lnctr                           001132 automatic       fixed bin(17,0)          dcl 196 set ref 412* 744 746 752* 755 1185 1189 1222
                                                                                  1275 1285* 1299* 1299 1300 1304* 1322 1324*
long_line_and_no_blank          001133 automatic       bit(1)                   dcl 197 set ref 1048* 1059 1102* 1106
ltrim                                                  builtin function         dcl 286 ref 954 983 988 1022 1062 1071 1122 1139
                                                                                  1200 1305
max_line_length_sw        3(08)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1248
maxcnt                          001134 automatic       fixed bin(21,0)          dcl 198 set ref 413* 1358 1360
maximum_line_length             001135 automatic       bit(1)                   dcl 199 set ref 595 1239* 1248*
mbz                       3(13)        based           bit(23)                  level 3 packed packed unaligned dcl 1-12 ref 313 354
                                                                                  378
mod                                                    builtin function         dcl 286 ref 808 1406
msf_manager_$close              000026 constant        entry                    external dcl 98 ref 1502
msf_manager_$get_ptr            000030 constant        entry                    external dcl 99 ref 325 390 1167 1363
msf_manager_$open               000032 constant        entry                    external dcl 101 ref 322 387
new_adjust                      001136 automatic       bit(1)                   dcl 200 set ref 552* 562* 731
new_fill                        001137 automatic       bit(1)                   dcl 201 set ref 571* 580* 734
new_ind                         001140 automatic       fixed bin(17,0)          dcl 202 set ref 524* 529* 530 533* 536* 537 540* 725
new_und                         001141 automatic       fixed bin(17,0)          dcl 203 set ref 500* 503* 504 507* 509 512* 728
nlindex                         001142 automatic       fixed bin(17,0)          dcl 204 set ref 426* 429 429* 431 434 434 442* 447*
                                                                                  457 462 875 878 936 936 1130 1130 1146 1149 1150
null                                                   builtin function         dcl 286 ref 307 308 309 326 348 349 350 372 373 374
                                                                                  391 1168 1364 1498 1502 1504
optptr                                 parameter       pointer                  dcl 84 ref 21 310 345 351 369 375
out_chars                              based           char(1)                  array packed unaligned dcl 248 set ref 1218 1325*
                                                                                  1375
out_comp_no                     001143 automatic       fixed bin(17,0)          dcl 205 set ref 340* 1362* 1362 1363* 1506*
outfcbptr                       001344 automatic       pointer                  dcl 207 set ref 309* 334* 350* 374* 1363* 1504 1506*
outfile                                based           char                     packed unaligned dcl 250 set ref 1350* 1355* 1361*
                                                                                  1370* 1373*
outlen                                 parameter       fixed bin(21,0)          dcl 85 set ref 345 1231* 1351*
outline                         001144 automatic       varying char(508)        dcl 206 set ref 947* 949* 953* 955 956 956* 958*
                                                                                  981* 982* 982 987* 989* 1006* 1007* 1007 1014*
                                                                                  1021* 1025* 1031* 1061* 1064* 1070* 1073* 1097*
                                                                                  1099* 1108* 1111* 1121* 1125* 1137* 1140* 1142*
outptr                          001346 automatic       pointer                  dcl 208 set ref 334* 341 363* 1218* 1350 1355 1361
                                                                                  1363* 1364 1369 1370 1373 1375*
outstring                              parameter       char                     packed unaligned dcl 86 set ref 345 363 364
outstringlen                    001350 automatic       fixed bin(21,0)          dcl 209 set ref 364* 1347 1349 1351
pads                            001351 automatic       fixed bin(17,0)          dcl 210 set ref 1386* 1404 1415
param                           001352 automatic       varying char(100)        dcl 211 set ref 479* 480 482 483 500 524 545 555 564
                                                                                  573 590 609 626 643 663 675 687 693 705
paramfb                         001404 automatic       fixed bin(17,0)          dcl 212 set ref 483* 503 529 536 592 594 611 613 675
                                                                                  695
pgctr                           001405 automatic       fixed bin(17,0)          dcl 213 set ref 414* 1199* 1199 1200 1303* 1303 1305
pgctra                          001406 automatic       varying char(10)         dcl 214 set ref 1200* 1202 1202 1207 1207 1305* 1308
                                                                                  1308 1313 1313
pgno                            001412 automatic       bit(1)                   packed unaligned dcl 215 set ref 614 619 746 1187
                                                                                  1266* 1300
pgno_sw                   3            based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1266
pl                              001413 automatic       fixed bin(17,0)          dcl 216 set ref 415* 609* 611* 611 613* 614 616* 619
                                                                                  621* 746 752 755 1189 1222 1300 1322
retval                          001414 automatic       fixed bin(35,0)          dcl 217 set ref 1485*
reverse                                                builtin function         dcl 286 ref 438 964
rtrim                                                  builtin function         dcl 286 ref 434 434 441 462 775 927 947 953 981 987
                                                                                  1137 1210 1210 1292 1292 1316 1316
search                                                 builtin function         dcl 286 ref 766 778 788 790 878 936 972 1130
signed                          001415 automatic       bit(1)                   packed unaligned dcl 218 set ref 482* 527 592 611
                                                                                  663 687
space_available                 001416 automatic       fixed bin(17,0)          dcl 219 set ref 1349* 1350 1350 1360* 1361 1361 1370
                                                                                  1370 1371
space_pos                       001417 automatic       fixed bin(17,0)          array dcl 220 set ref 1394* 1409 1409 1410* 1410
                                                                                  1418 1418 1420* 1420
spaces                          001563 automatic       fixed bin(17,0)          dcl 221 set ref 1384* 1392* 1392 1394 1402 1406 1407
                                                                                  1414 1416 1419
spindex                         001564 automatic       fixed bin(17,0)          dcl 222 set ref 438* 439 441 442 880* 881 883* 884
                                                                                  885* 887* 887 889 889 891 893 895 897 900 900 900
                                                                                  902 903 903 905* 905 908 909 909 911* 911 913 916*
                                                                                  916 964* 965 965 968 971 972 973 975 981 983 987
                                                                                  988 1153* 1154 1155 1388* 1389 1393
spindex1                        001565 automatic       fixed bin(17,0)          dcl 223 set ref 884* 885 887 913* 914 916
store                           001566 automatic       varying char(508)        dcl 224 set ref 416* 450 452* 452 453* 454* 715 719*
                                                                                  719 720* 721* 828* 829* 829 830* 831* 837 839* 839
                                                                                  840* 843* 849 851* 851 852* 854* 860* 860 863 863*
                                                                                  863 865* 865 880 883 884 889 891 893 897 900 900*
                                                                                  900 900 902 903* 903 903 908 909* 909 909 913 927
                                                                                  931 931 933* 933 940* 941* 945 947 948* 951 953
                                                                                  954* 954 964 971 972 973 981 983* 983 987 988* 988
                                                                                  998 999 1006 1008* 1008 1014 1015* 1015 1018 1021
                                                                                  1021 1022* 1022 1022 1025 1026* 1037* 1037 1050
                                                                                  1051 1057 1061 1062* 1062 1070 1071* 1071 1079
                                                                                  1079 1082 1084 1084 1090 1093 1097 1098* 1098 1108
                                                                                  1109* 1116* 1116 1121 1122 1122* 1122 1124* 1133*
                                                                                  1134* 1137 1139* 1139 1179 1182* 1182 1183*
store_char                1            based           char(1)                  array level 2 packed packed unaligned dcl 256 set
                                                                                  ref 891 893 897 900 902 908 951 971 998 1051 1057
                                                                                  1079 1084 1090
store_len                              based           fixed bin(35,0)          level 2 dcl 256 ref 450 715 837 849 863 945 973 999
                                                                                  1050 1079 1082 1084 1093 1122 1179
store_structure                        based           structure                level 1 unaligned dcl 256
string_entry                    001766 automatic       bit(1)                   packed unaligned dcl 225 set ref 319* 365* 384* 1163
                                                                                  1231 1345
sub_err_                        000034 constant        entry                    external dcl 102 ref 1485
sub_err_sw                3(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 1250
subcode                         001767 automatic       fixed bin(35,0)          dcl 226 set ref 1476* 1478* 1485*
substr                                                 builtin function         dcl 286 set ref 434 434 438 441 446 457 462 482 485
                                                                                  792 811 811 884 889 900 900 903 903 909 909 913
                                                                                  953 954 964 972 981 983 987 988 1006 1008 1014
                                                                                  1015 1018 1021 1022 1061 1062 1070 1071 1097 1098
                                                                                  1116 1121 1122 1137 1139 1350* 1350 1355* 1361*
                                                                                  1361 1370* 1370 1373* 1388 1409 1409 1418 1418
switches                  3            based           structure                level 2 dcl 1-12
syllable_size             4            based           fixed bin(17,0)          level 2 dcl 1-12 ref 1253
sys_info$max_seg_size           000120 external static fixed bin(19,0)          dcl 132 ref 413 1350 1355 1361 1370 1373
tabfill                         001770 automatic       fixed bin(17,0)          dcl 227 set ref 808* 809 809* 811
tabndx                          001771 automatic       fixed bin(17,0)          dcl 228 set ref 798* 799 800 801 811 811 814*
temp_code                       001772 automatic       fixed bin(35,0)          dcl 229 set ref 1506* 1507
text                                   parameter       char                     packed unaligned dcl 1340 ref 1338 1342 1350 1355
                                                                                  1361 1370 1373
text_line                 3     002002 automatic       varying char(128)        level 2 dcl 237 set ref 1482* 1484*
tlen                            001773 automatic       fixed bin(17,0)          dcl 230 set ref 1342* 1343 1349 1355 1360 1370 1371
                                                                                  1373
translate                                              builtin function         dcl 286 ref 468
trash                           001774 automatic       char(8)                  dcl 231 set ref 1455* 1474*
tssi_$finish_file               000036 constant        entry                    external dcl 103 ref 1506
tssi_$get_file                  000040 constant        entry                    external dcl 105 ref 334
und                             001776 automatic       fixed bin(17,0)          dcl 232 set ref 417* 728* 762 1116 1273*
using_sub_err                   001777 automatic       bit(1)                   dcl 233 set ref 1239* 1250* 1472
verify                                                 builtin function         dcl 286 ref 482 883 891 897 1153 1387
version_number                  002002 automatic       fixed bin(17,0)          level 2 in structure "error_info" dcl 237
                                                                                  in procedure "format_document_" set ref 1479*
version_number                         based           fixed bin(17,0)          level 2 in structure "format_document_options"
                                                                                  dcl 1-12 in procedure "format_document_" ref 1237
                                                                                  1244
vlen                            002000 automatic       fixed bin(17,0)          dcl 234 set ref 1046* 1056* 1056 1068 1077 1114
vtabndx                         002001 automatic       fixed bin(17,0)          dcl 235 set ref 800* 804* 804 808

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CANT_RESTART                    internal static bit(36)                  initial dcl 3-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 3-7
format_document_error_ptr              automatic       pointer                  dcl 2-15

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_check                    004657 constant        label                    dcl 989 ref 984
adjust_line                     007747 constant        entry                    internal dcl 1378 ref 956 989 1140
bs_rtn                          005126 constant        label                    dcl 1037 ref 931
call_canon                      003211 constant        label                    dcl 818 ref 783 786 788 790
check_length                    004046 constant        label                    dcl 920 ref 832 844 875 878 914
check_version_and_set_options   006577 constant        entry                    internal dcl 1234 ref 312 353 377
compress_blanks                 003764 constant        label                    dcl 908 ref 895 897
continue                        006006 constant        label                    dcl 1146 ref 458 476 489 498 522 550 560 569 578 588
                                                                                  601 607 624 631 640 648 651 660 667 678 685 691
                                                                                  711 763 942 1035 1112 1117 1135
done                            006572 constant        label                    dcl 1512 ref 316 323 326 331 338 357 381 388 391 396
                                                                                  819 924 977 1002 1168 1195 1211 1226 1257 1282
                                                                                  1293 1317 1331 1353 1367 1468
done_proc                       010612 constant        entry                    internal dcl 1495 ref 321 366 386 1512
dont_canon                      003242 constant        label                    dcl 822 ref 816
err_reporter                    010307 constant        entry                    internal dcl 1446 ref 456 475 488 497 506 511 521
                                                                                  532 539 549 559 568 577 587 599 606 617 622 630
                                                                                  647 659 666 684 690 710 922 1028 1063 1072 1110
                                                                                  1437
format_document_                000134 constant        entry                    external dcl 21
look_for_hyphenation_routine    010234 constant        entry                    internal dcl 1430 ref 418 635 671
no_more_components              006116 constant        label                    dcl 1179 ref 1163 1172
no_more_data                    006043 constant        label                    dcl 1163 ref 1146
process                         000715 constant        label                    dcl 401 ref 343 367
process_backspaces_normally     005710 constant        label                    dcl 1137 ref 1130
process_break                   002324 constant        label                    dcl 715 ref 515 543 553 563 572 581 696 713
process_ctl                     000000 constant        label                    array(20) dcl 493 ref 491
process_normally                004207 constant        label                    dcl 945 ref 936
process_one_component           000765 constant        label                    dcl 422 ref 1177
process_text                    002552 constant        label                    dcl 766 ref 699
reversion                       010304 constant        label                    dcl 1442 ref 1438
still_in_write_loop_with_more_to_process
                                005124 constant        label                    dcl 1033 ref 1065 1074 1100 1144
string                          000410 constant        entry                    external dcl 345
switch                          000527 constant        entry                    external dcl 369
tab_check                       003054 constant        label                    dcl 798 ref 781 793
write                           006715 constant        entry                    internal dcl 1270 ref 453 457 720 739 748 753 757
                                                                                  830 840 842 852 940 949 958 1031 1064 1073 1099
                                                                                  1111 1125 1133 1142 1183
write_file                      007552 constant        entry                    internal dcl 1338 ref 1190 1202 1220 1277 1288 1308
write_here                      005114 constant        label                    dcl 1031 ref 1009

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12746       13070   12151       12756
Length     13450   12151       122         343     575           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
format_document_                   1166 external procedure  is an external procedure.  
on unit on line 321                  64 on unit               
on unit on line 366                  64 on unit               
on unit on line 386                  64 on unit               
check_version_and_set_options           internal procedure  shares stack frame of external procedure format_document_.  
write                                96 internal procedure  is called during a stack extension.  
write_file                           80 internal procedure  is called during a stack extension.  
adjust_line                             internal procedure  shares stack frame of external procedure format_document_.  
look_for_hyphenation_routine         70 internal procedure  enables or reverts conditions.  
on unit on line 1433                 70 on unit               
err_reporter                        108 internal procedure  is called by several nonquick procedures.  
done_proc                            84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
format_document_         000100 aclinfoptr                  format_document_
                         000102 adj_line_out                format_document_
                         000302 adjust                      format_document_
                         000303 bc                          format_document_
                         000304 blank_lines_to_be_written   format_document_
                         000305 breaking_words              format_document_
                         000306 bsndx                       format_document_
                         000307 bsndx1                      format_document_
                         000310 bscnt                       format_document_
                         000311 buf                         format_document_
                         000412 buf_len21                   format_document_
                         000413 char_cnt                    format_document_
                         000414 component_ends_wo_NL        format_document_
                         000415 continued_line              format_document_
                         000416 ctl                         format_document_
                         000420 ctl_index                   format_document_
                         000421 current_syllable_size       format_document_
                         000422 default_syllable_size       format_document_
                         000423 dont_break_indented_lines   format_document_
                         000424 dont_compress               format_document_
                         000425 elen                        format_document_
                         000426 error                       format_document_
                         000427 error_lines                 format_document_
                         000626 errtxt                      format_document_
                         000657 fill                        format_document_
                         000660 filout                      format_document_
                         000661 fit                         format_document_
                         000662 galley_mode                 format_document_
                         000663 h                           format_document_
                         000664 hyph_len                    format_document_
                         000665 hyph_point                  format_document_
                         000666 hyph_ptr                    format_document_
                         000670 hyph_space                  format_document_
                         000671 hyphenating                 format_document_
                         000672 hyphenation_routine_state   format_document_
                         000674 hyphenate_entry             format_document_
                         000700 i                           format_document_
                         000701 in_comp_no                  format_document_
                         000702 ind                         format_document_
                         000703 ind_minus_und               format_document_
                         000704 indptr                      format_document_
                         000706 infcbptr                    format_document_
                         000710 initial_ind                 format_document_
                         000711 initial_inlen               format_document_
                         000712 initial_inptr               format_document_
                         000714 initial_line_length         format_document_
                         000716 initial_outptr              format_document_
                         000720 inlen                       format_document_
                         000721 inplnctr                    format_document_
                         000722 inptr                       format_document_
                         000724 ioxbuf                      format_document_
                         001123 j                           format_document_
                         001124 k                           format_document_
                         001125 last_blank                  format_document_
                         001126 left                        format_document_
                         001127 line_began_with_blank       format_document_
                         001130 literal_mode                format_document_
                         001131 ll                          format_document_
                         001132 lnctr                       format_document_
                         001133 long_line_and_no_blank      format_document_
                         001134 maxcnt                      format_document_
                         001135 maximum_line_length         format_document_
                         001136 new_adjust                  format_document_
                         001137 new_fill                    format_document_
                         001140 new_ind                     format_document_
                         001141 new_und                     format_document_
                         001142 nlindex                     format_document_
                         001143 out_comp_no                 format_document_
                         001144 outline                     format_document_
                         001344 outfcbptr                   format_document_
                         001346 outptr                      format_document_
                         001350 outstringlen                format_document_
                         001351 pads                        format_document_
                         001352 param                       format_document_
                         001404 paramfb                     format_document_
                         001405 pgctr                       format_document_
                         001406 pgctra                      format_document_
                         001412 pgno                        format_document_
                         001413 pl                          format_document_
                         001414 retval                      format_document_
                         001415 signed                      format_document_
                         001416 space_available             format_document_
                         001417 space_pos                   format_document_
                         001563 spaces                      format_document_
                         001564 spindex                     format_document_
                         001565 spindex1                    format_document_
                         001566 store                       format_document_
                         001766 string_entry                format_document_
                         001767 subcode                     format_document_
                         001770 tabfill                     format_document_
                         001771 tabndx                      format_document_
                         001772 temp_code                   format_document_
                         001773 tlen                        format_document_
                         001774 trash                       format_document_
                         001776 und                         format_document_
                         001777 using_sub_err               format_document_
                         002000 vlen                        format_document_
                         002001 vtabndx                     format_document_
                         002002 error_info                  format_document_
                         002054 format_document_options_ptr format_document_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1
mdfx1               enable_op           shorten_stack       ext_entry_desc      int_entry           int_entry_desc
set_chars_eis       index_chars_eis     alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
canonicalize_                 convert_status_code_          cv_dec_check_                 hyphenate_word_
ioa_$rs                       iox_$put_chars                msf_manager_$close            msf_manager_$get_ptr
msf_manager_$open             pl1_decat_char_               sub_err_                      tssi_$finish_file
tssi_$get_file

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error      error_table_$improper_data_format                           error_table_$noentry
error_table_$recoverable_error                              error_table_$smallarg
error_table_$unimplemented_version                          error_table_$zero_length_seg  fdoc_et_$indent_too_far_left
fdoc_et_$indent_too_far_right fdoc_et_$line_length_too_small                              fdoc_et_$line_too_long
fdoc_et_$no_hyphenate_word    fdoc_et_$no_parameter_allowed fdoc_et_$no_sign_allowed      fdoc_et_$nonnumeric_parameter
fdoc_et_$page_length_lt_13    fdoc_et_$page_length_lt_14    fdoc_et_$page_width_exceeds_max
fdoc_et_$text_too_long_for_line                             fdoc_et_$undent_too_far_left  fdoc_et_$undent_too_far_right
fdoc_et_$unsupported_control  iox_$error_output             sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000126       306 000173       307 000174       308 000176       309 000177       310 000200       311 000202
    312 000204       313 000205       315 000211       316 000214       318 000215       319 000217       321 000220
    322 000242       323 000271       325 000273       326 000317       328 000323       330 000325       331 000330
    333 000331       334 000333       335 000370       337 000372       338 000375       340 000376       341 000377
    342 000401       343 000402       345 000403       347 000435       348 000436       349 000440       350 000441
    351 000442       352 000445       353 000447       354 000450       356 000454       357 000457       359 000460
    360 000461       361 000463       362 000465       363 000470       364 000474       365 000476       366 000477
    367 000521       369 000522       371 000554       372 000555       373 000557       374 000560       375 000561
    376 000564       377 000566       378 000567       380 000573       381 000576       383 000577       384 000600
    386 000601       387 000623       388 000652       390 000654       391 000700       393 000704       395 000706
    396 000711       398 000712       399 000714       401 000715       403 000717       404 000720       405 000721
    406 000723       407 000724       408 000725       409 000726       410 000727       411 000730       412 000732
    413 000733       414 000740       415 000741       416 000743       417 000744       418 000745       420 000753
    421 000761       422 000765       424 000767       425 000771       426 000774       427 001006       428 001007
    429 001010       431 001015       433 001017       434 001021       438 001047       439 001063       441 001065
    442 001105       443 001110       444 001111       446 001113       447 001123       448 001125       450 001126
    452 001130       453 001155       454 001166       456 001167       457 001176       458 001220       461 001222
    462 001223       464 001245       468 001261       469 001277       470 001312       471 001375       472 001377
    473 001411       475 001422       476 001431       478 001432       479 001433       480 001456       482 001460
    483 001471       484 001523       485 001524       486 001534       488 001535       489 001544       491 001545
    493 001546       496 001550       497 001551       498 001560       500 001561       503 001566       504 001570
    506 001572       507 001601       508 001603       509 001604       511 001610       512 001617       515 001622
    517 001623       520 001625       521 001626       522 001635       524 001636       527 001642       529 001644
    530 001647       532 001650       533 001657       535 001660       536 001661       537 001663       539 001666
    540 001675       543 001677       545 001700       548 001702       549 001703       550 001712       552 001713
    553 001715       555 001716       558 001720       559 001721       560 001730       562 001731       563 001732
    564 001733       567 001735       568 001736       569 001745       571 001746       572 001750       573 001751
    576 001753       577 001754       578 001763       580 001764       581 001765       583 001766       586 001770
    587 001771       588 002000       590 002001       592 002006       594 002013       595 002015       598 002022
    599 002024       601 002033       602 002034       605 002036       606 002037       607 002046       609 002047
    611 002054       613 002061       614 002063       616 002070       617 002072       618 002101       619 002102
    621 002107       622 002111       624 002120       626 002121       629 002123       630 002124       631 002133
    633 002134       634 002141       635 002143       638 002154       640 002157       643 002160       646 002162
    647 002163       648 002172       650 002173       651 002174       654 002175       658 002177       659 002200
    660 002207       663 002210       666 002214       667 002223       670 002224       671 002226       673 002235
    675 002240       677 002245       678 002247       680 002250       683 002252       684 002253       685 002262
    687 002263       690 002267       691 002276       693 002277       695 002304       696 002306       699 002307
    705 002310       709 002312       710 002313       711 002322       713 002323       715 002324       719 002326
    720 002353       721 002364       725 002365       728 002375       731 002404       734 002413       737 002422
    739 002433       740 002444       741 002447       744 002453       746 002455       748 002467       749 002500
    750 002503       752 002505       753 002510       754 002521       755 002522       757 002533       758 002544
    762 002546       763 002551       766 002552       769 002565       770 002600       771 002651       772 002653
    773 002666       774 002737       775 002741       778 002757       780 002772       781 003004       783 003005
    785 003007       786 003010       788 003013       790 003023       792 003034       793 003050       795 003052
    796 003053       798 003054       799 003066       800 003070       801 003071       802 003077       804 003103
    805 003105       807 003106       808 003110       809 003117       811 003123       814 003174       815 003207
    816 003210       818 003211       819 003236       821 003240       824 003242       826 003243       828 003245
    829 003252       830 003277       831 003310       832 003311       835 003312       837 003314       839 003316
    840 003343       842 003354       843 003364       844 003365       846 003366       848 003372       849 003374
    851 003376       852 003423       854 003434       855 003441       857 003442       859 003444       860 003445
    861 003457       863 003460       865 003471       873 003503       875 003505       878 003514       880 003525
    881 003537       883 003541       884 003554       885 003572       887 003575       889 003600       891 003621
    893 003636       895 003641       897 003644       900 003654       902 003716       903 003725       904 003757
    905 003761       906 003763       908 003764       909 003771       910 004017       911 004021       913 004022
    914 004041       916 004042       917 004045       920 004046       922 004052       923 004061       924 004064
    927 004065       931 004106       933 004127       934 004154       936 004161       940 004175       941 004205
    942 004206       945 004207       947 004214       948 004235       949 004236       950 004246       951 004247
    953 004254       954 004274       955 004331       956 004336       958 004345       960 004355       964 004356
    965 004372       968 004376       971 004407       972 004414       973 004434       975 004447       976 004452
    977 004500       979 004502       981 004506       982 004532       983 004541       984 004600       987 004601
    988 004622       989 004657       991 004663       996 004664       998 004666       999 004670      1000 004672
   1001 004674      1002 004723      1004 004725      1006 004730      1007 004737      1008 004746      1009 004760
   1012 004761      1014 004763      1015 004773      1016 005005      1018 005006      1021 005022      1022 005044
   1023 005076      1025 005077      1026 005104      1028 005105      1031 005114      1033 005124      1035 005125
   1037 005126      1045 005153      1046 005155      1047 005156      1048 005157      1049 005160      1050 005161
   1051 005173      1053 005201      1054 005202      1055 005203      1056 005204      1057 005205      1059 005212
   1061 005214      1062 005225      1063 005261      1064 005270      1065 005300      1067 005301      1068 005303
   1070 005306      1071 005317      1072 005353      1073 005362      1074 005372      1077 005373      1079 005376
   1082 005407      1084 005414      1087 005425      1089 005427      1090 005441      1092 005447      1093 005451
   1094 005453      1095 005454      1097 005456      1098 005466      1099 005500      1100 005510      1102 005511
   1104 005513      1106 005515      1108 005517      1109 005524      1110 005525      1111 005534      1112 005544
   1114 005545      1116 005550      1117 005570      1119 005571      1121 005573      1122 005604      1124 005644
   1125 005645      1126 005655      1128 005656      1130 005662      1133 005676      1134 005706      1135 005707
   1137 005710      1139 005733      1140 005765      1142 005775      1144 006005      1146 006006      1149 006010
   1150 006013      1151 006015      1153 006017      1154 006032      1155 006036      1159 006042      1163 006043
   1166 006045      1167 006046      1168 006071      1171 006101      1172 006102      1175 006103      1176 006112
   1177 006115      1179 006116      1182 006120      1183 006145      1185 006156      1187 006162      1189 006164
   1190 006175      1193 006210      1194 006213      1195 006235      1198 006237      1199 006241      1200 006242
   1202 006272      1206 006357      1207 006360      1210 006435      1211 006471      1214 006473      1216 006474
   1218 006501      1219 006506      1220 006510      1221 006520      1222 006521      1224 006533      1225 006536
   1226 006560      1228 006562      1231 006564      1512 006572      1515 006576      1234 006577      1237 006600
   1239 006603      1241 006611      1242 006613      1243 006615      1244 006616      1246 006620      1247 006625
   1248 006631      1249 006635      1250 006641      1251 006645      1252 006652      1253 006656      1254 006660
   1256 006661      1257 006664      1260 006665      1261 006672      1262 006676      1263 006700      1264 006702
   1265 006706      1266 006710      1268 006713      1270 006714      1273 006730      1274 006732      1275 006734
   1277 006740      1280 006760      1281 006767      1282 007010      1285 007016      1288 007021      1290 007067
   1291 007070      1292 007122      1293 007155      1297 007163      1299 007166      1300 007167      1303 007175
   1304 007176      1305 007177      1308 007227      1312 007332      1313 007333      1316 007426      1317 007461
   1321 007467      1322 007470      1324 007474      1325 007475      1327 007507      1329 007511      1330 007520
   1331 007542      1336 007550      1338 007551      1342 007565      1343 007567      1345 007570      1347 007572
   1349 007576      1350 007603      1351 007611      1352 007614      1353 007616      1355 007621      1356 007631
   1358 007632      1360 007635      1361 007641      1362 007647      1363 007650      1364 007672      1366 007677
   1367 007702      1369 007705      1370 007707      1371 007723      1372 007726      1373 007727      1375 007737
   1376 007746      1378 007747      1384 007751      1385 007752      1386 007760      1387 007763      1388 010003
   1389 010023      1392 010027      1393 010030      1394 010033      1396 010035      1402 010037      1404 010041
   1406 010053      1407 010056      1409 010061      1410 010127      1411 010132      1412 010133      1414 010136
   1415 010137      1416 010145      1418 010151      1419 010200      1420 010211      1421 010212      1422 010214
   1423 010216      1424 010220      1427 010223      1428 010232      1430 010233      1433 010241      1435 010255
   1436 010260      1437 010262      1438 010271      1440 010274      1441 010302      1442 010304      1444 010305
   1446 010306      1450 010314      1451 010317      1453 010322      1455 010326      1456 010341      1467 010432
   1468 010453      1472 010461      1474 010464      1476 010504      1478 010515      1479 010520      1480 010522
   1481 010524      1482 010526      1484 010533      1485 010543      1493 010610      1495 010611      1498 010617
   1500 010631      1502 010641      1504 010654      1506 010661      1507 010710      1510 010715


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
