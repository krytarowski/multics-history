	COMPILATION LISTING OF SEGMENT arith_op
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1621.5 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* this procedure compiles arithmetic expressions
       12*
       13*   Initial Version:  5 October, 1968 by BLW
       14*	Modified: 24 May, 1971 by BLW for Version II 
       15*	Modified: 21 January, 1973 by BLW
       16*	Modified:	8 November 1973 by RAB for fixed divide
       17*	Modified:	16 September 1974 by RAB for bug 1230 (float divide)
       18*	Modified:	24 September 1975 by RAB for bug 1424
       19*	Modified:	29 October 1975 by RAB to check p3 in q	
       20*	Modified: 2 April 1976 by RHS to improve code for constant*2
       21*	Modified:	9 March 1978 by RAB to check p3 in q for floating divide	*/
       22 
       23 arith_op:	proc(node_pts,refs,atom);
       24 
       25 dcl	node_pts	ptr,		/* points at operator node */
       26 	refs(3)	ptr,		/* ptrs to ref nodes of operands */
       27 	atom(3)	bit(1) aligned;	/* ON is operand is atomic */
       28 
       29 dcl	node_pt	ptr defined(node_pts),
       30 	ref(3)	ptr defined(refs);
       31 
       32 dcl	(p,p1,p2,p3,q2,q3) ptr,
       33 	complex_stuff$complex_stuff fixed bin ext,
       34 	based_int fixed bin(18) based,
       35 	(type1,type2,type3,scale1,scale2,scale3,op,k,rev,comp,max_type,op_code,n) fixed bin(15),
       36 	shift fixed bin,
       37 	(check_scale,check_type,mult_scaled,reversed) bit(1) aligned,
       38 	negate_op(4) fixed bin(15) int static initial(255,38,39,39),
       39 	load entry(ptr,fixed bin(15)),
       40 	power_of_two entry(fixed bin(18)) returns(fixed bin(18)),
       41 	c_a entry(fixed bin,fixed bin) returns(ptr),
       42 	expmac$interpret entry(fixed bin,ptr,(3) ptr,(3) bit(1) aligned),
       43 	expmac entry(fixed bin(15),ptr),
       44 	expmac$zero entry(fixed bin(15)),
       45 	expmac$abs entry(ptr,fixed bin),
       46 	compile_exp entry(ptr),
       47 	(compile_exp$save,compile_exp$save_exp,compile_exp$save_float_2,copy_temp) entry(ptr) returns(ptr);
       48 
       49 dcl	(fixed_to_float,float_to_fixed) entry(ptr),
       50 	compile_exp$save_fix_scaled entry(ptr,fixed bin(15),fixed bin(15)) returns(ptr),
       51 	aq_man$fix_scale entry(ptr,fixed bin(15),fixed bin(15));
       52 
       53 dcl	divide_fx1 init(535) fixed bin(15) int static;
       54 
       55 dcl	(addr,fixed,max,mod) builtin;
       56 
       57 dcl	1 arith_data$fixed(3) ext static,
       58 	2 left_type(2),
       59 	3 right_type(2),
       60 	4 body		fixed bin(15),
       61 	4 rev		fixed bin(15),
       62 	4 comp		fixed bin(15),
       63 
       64 	1 fix_info	based(p),
       65 	2 body		fixed bin(15),
       66 	2 rev		fixed bin(15),
       67 	2 comp		fixed bin(15);
       68 
       69 dcl (	add_op		init(1),
       70 	sub_op		init(2),
       71 	mult_op		init(3),
       72 	div_op		init(4)) fixed bin int static;
       73 
       74 
  1     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  1     2 
  1     3 dcl	1 reference		based aligned,
  1     4 	2 node_type		bit(9) unaligned,
  1     5 	2 array_ref		bit(1) unaligned,
  1     6 	2 varying_ref		bit(1) unaligned,
  1     7 	2 shared			bit(1) unaligned,
  1     8 	2 put_data_sw		bit(1) unaligned,
  1     9 	2 processed		bit(1) unaligned,
  1    10 	2 units			fixed(3) unaligned,
  1    11 	2 ref_count		fixed(17) unaligned,
  1    12 	2 c_offset		fixed(24),
  1    13 	2 c_length		fixed(24),
  1    14 	2 symbol			ptr unaligned,
  1    15 	2 qualifier		ptr unaligned,
  1    16 	2 offset			ptr unaligned,
  1    17 	2 length			ptr unaligned,
  1    18 	2 subscript_list		ptr unaligned,
  1    19 						/* these fields are used by the 645 code generator */
  1    20 	2 address			structure unaligned,
  1    21 	  3 base			bit(3),
  1    22 	  3 offset		bit(15),
  1    23 	  3 op			bit(9),
  1    24 	  3 no_address		bit(1),
  1    25 	  3 inhibit		bit(1),
  1    26 	  3 ext_base		bit(1),
  1    27 	  3 tag			bit(6),
  1    28 	2 info			structure unaligned,
  1    29 	  3 address_in		structure,
  1    30 	    4 b			dimension(0:7) bit(1),
  1    31 	    4 storage		bit(1),
  1    32 	  3 value_in		structure,
  1    33 	    4 a			bit(1),
  1    34 	    4 q			bit(1),
  1    35 	    4 aq			bit(1),
  1    36 	    4 string_aq		bit(1),
  1    37 	    4 complex_aq		bit(1),
  1    38 	    4 decimal_aq		bit(1),
  1    39 	    4 b			dimension(0:7) bit(1),
  1    40 	    4 storage		bit(1),
  1    41 	    4 indicators		bit(1),
  1    42 	    4 x			dimension(0:7) bit(1),
  1    43 	  3 other			structure,
  1    44 	    4 big_offset		bit(1),
  1    45 	    4 big_length		bit(1),
  1    46 	    4 modword_in_offset	bit(1),
  1    47 	2 data_type		fixed(5) unaligned,
  1    48 	2 bits			structure unaligned,
  1    49 	  3 padded_ref		bit(1),
  1    50 	  3 aligned_ref		bit(1),
  1    51 	  3 long_ref		bit(1),
  1    52 	  3 forward_ref		bit(1),
  1    53 	  3 ic_ref		bit(1),
  1    54 	  3 temp_ref		bit(1),
  1    55 	  3 defined_ref		bit(1),
  1    56 	  3 evaluated		bit(1),
  1    57 	  3 allocate		bit(1),
  1    58 	  3 allocated		bit(1),
  1    59 	  3 aliasable		bit(1),
  1    60 	  3 even			bit(1),
  1    61 	  3 perm_address		bit(1),
  1    62 	  3 aggregate		bit(1),
  1    63 	  3 hit_zero		bit(1),
  1    64 	  3 dont_save		bit(1),
  1    65 	  3 fo_in_qual		bit(1),
  1    66 	  3 hard_to_load		bit(1),
  1    67 	2 relocation		bit(12) unaligned,
  1    68 	2 more_bits		structure unaligned,
  1    69 	  3 substr		bit(1),
  1    70 	  3 padded_for_store_ref	bit(1),
  1    71 	  3 aligned_for_store_ref	bit(1),
  1    72 	  3 mbz			bit(15),
  1    73 	2 store_ins		bit(18) unaligned;
  1    74 
  1    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       75 
  2     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  2     2 
  2     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  2     4 
  2     5 /* format: style3 */
  2     6 dcl	1 operator	based aligned,
  2     7 	  2 node_type	bit (9) unaligned,
  2     8 	  2 op_code	bit (9) unaligned,
  2     9 	  2 shared	bit (1) unaligned,
  2    10 	  2 processed	bit (1) unaligned,
  2    11 	  2 optimized	bit (1) unaligned,
  2    12 	  2 number	fixed (14) unaligned,
  2    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  2    14 
  2    15 dcl	max_number_of_operands
  2    16 			fixed bin (15) int static options (constant) initial (32767);
  2    17 
  2    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       76 
  3     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  3     2 
  3     3 dcl	1 symbol			based aligned,
  3     4 	2 node_type		bit(9) unal,
  3     5 	2 source_id		structure unal,
  3     6 	  3 file_number		bit(8),
  3     7 	  3 line_number		bit(14),
  3     8 	  3 statement_number	bit(5),
  3     9 	2 location		fixed(18) unal unsigned,
  3    10 	2 allocated		bit(1) unal,
  3    11 	2 dcl_type		bit(3) unal,
  3    12 	2 reserved		bit(6) unal,
  3    13 	2 pix			unal,
  3    14 	  3 pic_fixed		bit(1) unal,
  3    15 	  3 pic_float		bit(1) unal,
  3    16 	  3 pic_char		bit(1) unal,
  3    17 	  3 pic_scale		fixed(7) unal,
  3    18 	  3 pic_size		fixed(7) unal,
  3    19 	2 level			fixed(8) unal,
  3    20 	2 boundary		fixed(3) unal,
  3    21 	2 size_units		fixed(3) unal,
  3    22 	2 scale			fixed(7) unal,
  3    23 	2 runtime			bit(18) unal,
  3    24 	2 runtime_offset		bit(18) unal,
  3    25 	2 block_node		ptr unal,
  3    26 	2 token			ptr unal,
  3    27 	2 next			ptr unal,
  3    28 	2 multi_use		ptr unal,
  3    29 	2 cross_references		ptr unal,
  3    30 	2 initial			ptr unal,
  3    31 	2 array			ptr unal,
  3    32 	2 descriptor		ptr unal,
  3    33 	2 equivalence		ptr unal,
  3    34 	2 reference		ptr unal,
  3    35 	2 general			ptr unal,
  3    36 	2 father			ptr unal,
  3    37 	2 brother			ptr unal,
  3    38 	2 son			ptr unal,
  3    39 	2 word_size		ptr unal,
  3    40 	2 bit_size		ptr unal,
  3    41 	2 dcl_size		ptr unal,
  3    42 	2 symtab_size		ptr unal,
  3    43 	2 c_word_size		fixed(24),
  3    44 	2 c_bit_size		fixed(24),
  3    45 	2 c_dcl_size		fixed(24),
  3    46 
  3    47 	2 attributes		structure aligned,
  3    48 	  3 data_type		structure unal,
  3    49 	    4 structure		bit(1) ,
  3    50 	    4 fixed		bit(1),
  3    51 	    4 float		bit(1),
  3    52 	    4 bit			bit(1),
  3    53 	    4 char		bit(1),
  3    54 	    4 ptr			bit(1),
  3    55 	    4 offset		bit(1),
  3    56 	    4 area		bit(1),
  3    57 	    4 label		bit(1),
  3    58 	    4 entry		bit(1),
  3    59 	    4 file		bit(1),
  3    60 	    4 arg_descriptor	bit(1),
  3    61 	    4 storage_block		bit(1),
  3    62 	    4 explicit_packed	bit(1), /* options(packed) */
  3    63 	    4 condition		bit(1),
  3    64 	    4 format		bit(1),
  3    65 	    4 builtin		bit(1),
  3    66 	    4 generic		bit(1),
  3    67 	    4 picture		bit(1),
  3    68 
  3    69 	  3 misc_attributes		structure unal,
  3    70 	    4 dimensioned		bit(1),
  3    71 	    4 initialed		bit(1),
  3    72 	    4 aligned		bit(1),
  3    73 	    4 unaligned		bit(1),
  3    74 	    4 signed		bit(1),
  3    75 	    4 unsigned		bit(1),
  3    76 	    4 precision		bit(1),
  3    77 	    4 varying		bit(1),
  3    78 	    4 local		bit(1),
  3    79 	    4 decimal		bit(1),
  3    80 	    4 binary		bit(1),
  3    81 	    4 real		bit(1),
  3    82 	    4 complex		bit(1),
  3    83 	    4 variable		bit(1),
  3    84 	    4 reducible		bit(1),
  3    85 	    4 irreducible		bit(1),
  3    86 	    4 returns		bit(1),
  3    87 	    4 position		bit(1),
  3    88 	    4 internal		bit(1),
  3    89 	    4 external		bit(1),
  3    90 	    4 like		bit(1),
  3    91 	    4 member		bit(1),
  3    92 	    4 non_varying		bit(1),
  3    93 	    4 options		bit(1),
  3    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  3    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  3    96 
  3    97 	  3 storage_class		structure unal,
  3    98 	    4 auto		bit(1),
  3    99 	    4 based		bit(1),
  3   100 	    4 static		bit(1),
  3   101 	    4 controlled		bit(1),
  3   102 	    4 defined		bit(1),
  3   103 	    4 parameter		bit(1),
  3   104 	    4 param_desc		bit(1),
  3   105 	    4 constant		bit(1),
  3   106 	    4 temporary		bit(1),
  3   107 	    4 return_value		bit(1),
  3   108 
  3   109 	  3 file_attributes		structure unal,
  3   110 	    4 print		bit(1),
  3   111 	    4 input		bit(1),
  3   112 	    4 output		bit(1),
  3   113 	    4 update		bit(1),
  3   114 	    4 stream		bit(1),
  3   115 	    4 reserved_1		bit(1),
  3   116 	    4 record		bit(1),
  3   117 	    4 sequential		bit(1),
  3   118 	    4 direct		bit(1),
  3   119 	    4 interactive		bit(1),		/* env(interactive) */
  3   120 	    4 reserved_2		bit(1),
  3   121 	    4 reserved_3		bit(1),
  3   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  3   123 	    4 keyed		bit(1),
  3   124 	    4 reserved_4		bit(1),
  3   125 	    4 environment		bit(1),
  3   126 
  3   127 	  3 compiler_developed	structure unal,
  3   128 	    4 aliasable		bit(1),
  3   129 	    4 packed		bit(1),
  3   130 	    4 passed_as_arg		bit(1),
  3   131 	    4 allocate		bit(1),
  3   132 	    4 set			bit(1),
  3   133 	    4 exp_extents		bit(1),
  3   134 	    4 refer_extents		bit(1),
  3   135 	    4 star_extents		bit(1),
  3   136 	    4 isub		bit(1),
  3   137 	    4 put_in_symtab		bit(1),
  3   138 	    4 contiguous		bit(1),
  3   139 	    4 put_data		bit(1),
  3   140 	    4 overlayed		bit(1),
  3   141 	    4 error		bit(1),
  3   142 	    4 symtab_processed	bit(1),
  3   143 	    4 overlayed_by_builtin	bit(1),
  3   144 	    4 defaulted		bit(1),
  3   145 	    4 connected		bit(1);
  3   146 
  3   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       77 
  4     1 dcl (	real_fix_bin_1		init(1),
  4     2 	real_fix_bin_2		init(2),
  4     3 	real_flt_bin_1		init(3),
  4     4 	real_flt_bin_2		init(4),
  4     5 	complex_fix_bin_1		init(5),
  4     6 	complex_fix_bin_2		init(6),
  4     7 	complex_flt_bin_1		init(7),
  4     8 	complex_flt_bin_2		init(8),
  4     9 	real_fix_dec		init(9),
  4    10 	real_flt_dec		init(10),
  4    11 	complex_fix_dec		init(11),
  4    12 	complex_flt_dec		init(12),
  4    13 	char_string		init(13),
  4    14 	bit_string		init(14),
  4    15 	label_constant		init(15),
  4    16 	local_label_variable	init(16),
  4    17 	label_variable		init(17),
  4    18 	entry_variable		init(18),
  4    19 	ext_entry_in		init(19),
  4    20 	ext_entry_out		init(20),
  4    21 	int_entry			init(21),
  4    22 	int_entry_other		init(22),
  4    23 	unpacked_ptr		init(23),
  4    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
       78 
  5     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
  5     2 
  5     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
  5     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
  5     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
  5     6 /* Modified: 26 July 82 BIM wordno, segno */
  5     7 
  5     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
  5     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
  5    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
  5    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
  5    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
  5    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
  5    14 
  5    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
  5    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
  5    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
  5    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
  5    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
  5    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
  5    21 
  5    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
  5    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
  5    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
  5    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
  5    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
  5    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
  5    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
  5    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
  5    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
  5    31 
  5    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
  5    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
  5    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
  5    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
  5    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
  5    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
  5    38 
  5    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
  5    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
  5    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
  5    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
  5    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
  5    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
  5    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
  5    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
  5    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
  5    48 
  5    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
  5    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
  5    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
  5    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
  5    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
  5    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
  5    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
  5    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
  5    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
  5    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
  5    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
  5    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
  5    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
  5    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
  5    63 
  5    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
  5    65*						   opnd(2) <- opnd(3) / 36		*/
  5    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
  5    67*						   opnd(2) <- opnd(3) / 4		*/
  5    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
  5    69*						   opnd(2) <- opnd(3) / 2		*/
  5    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
  5    71 
  5    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
  5    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
  5    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
  5    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
  5    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
  5    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
  5    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
  5    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
  5    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
  5    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
  5    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
  5    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
  5    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
  5    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
  5    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
  5    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
  5    88 
  5    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
  5    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
  5    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
  5    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
  5    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
  5    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
  5    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
  5    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
  5    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
  5    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
  5    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
  5   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
  5   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
  5   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
  5   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
  5   104 
  5   105 	index_fun		initial("010100000"b),	/* opnd(1) <- index(opnd(2),opnd(3))	*/
  5   106 	off_fun		initial("010100001"b),	/* opnd(1) <- offset(opnd(2),opnd(3))	*/
  5   107 	complex_fun	initial("010100010"b),	/* opnd(1) <- complex(opnd(2),opnd(3))	*/
  5   108 	conjg_fun		initial("010100011"b),	/* opnd(1) <- conjg(opnd(2),opnd(3))	*/
  5   109 	mod_fun		initial("010100100"b),	/* opnd(1) <- mod(opnd(2),opnd(3))	*/
  5   110 	repeat_fun	initial("010100101"b),	/* opnd(1) <- repeat(opnd(2),opnd(3))	*/
  5   111 	verify_fun	initial("010100110"b),	/* opnd(1) <- verify(opnd(2),opnd(3))	*/
  5   112 	translate_fun	initial("010100111"b),	/* opnd(1) <- translate(opnd(2),opnd(3))*/
  5   113 	real_fun   	initial("010101001"b),	/* opnd(1) <- real(opnd(2))		*/
  5   114 	imag_fun   	initial("010101010"b),	/* opnd(1) <- imag(opnd(2))		*/
  5   115 	length_fun	initial("010101011"b),	/* opnd(1) <- length(opnd(2))	*/
  5   116 	pl1_mod_fun	initial("010101100"b),	/* opnd(1) <- mod(opnd(2)) */
  5   117 	search_fun	initial("010101101"b),	/* opnd(1) <- search(opnd(2),opnd(3)) */
  5   118 	allocation_fun	initial("010101110"b),	/* opnd(1) <- allocation(opnd(2)) */
  5   119 	reverse_fun	initial("010101111"b),	/* opnd(1) <- reverse(opnd(2)) */
  5   120 
  5   121 	addr_fun		initial("010110000"b),	/* opnd(1) <- addr(opnd(2))		*/
  5   122 	addr_fun_bits	initial("010110001"b),	/* opnd(1) <- addr(opnd(2))		*/
  5   123 	ptr_fun		initial("010110010"b),	/* opnd(1) <- ptr(opnd(2),opnd(3))	*/
  5   124 	baseptr_fun	initial("010110011"b),	/* opnd(1) <- baseptr(opnd(2))	*/
  5   125 	addrel_fun	initial("010110100"b),	/* opnd(1) <- addrel(opnd(2),opnd(3))	*/
  5   126 	codeptr_fun	initial("010110101"b),	/* opnd(1) <- codeptr(opnd(2))	*/
  5   127 	environmentptr_fun	initial("010110110"b),	/* opnd(1) <- environmentptr(opnd(2))	*/
  5   128 	stackbaseptr_fun	initial("010110111"b),	/* opnd(1) is ptr to base of current stack	*/
  5   129 	stackframeptr_fun	initial("010111000"b),	/* opnd(1) is ptr to current block's stack frame	*/
  5   130 	setcharno_fun	initial("010111001"b),	/* opnd(1) <- opnd(2) with charno opnd(3) */
  5   131 	addcharno_fun	initial("010111010"b),	/* opnd(1) <- opnd(2) with charno = charno + opnd(3) */
  5   132 	setbitno_fun	initial("010111011"b),	/* setcharno for bitsno */
  5   133 	addbitno_fun	initial("010111100"b),	/* addcharno for bitno */
  5   134 
  5   135 	min_fun		initial("011000000"b),	/* opnd(1) <- min(opnd(1),opnd(2),...)	*/
  5   136 	max_fun		initial("011000001"b),	/* opnd(1) <- max(opnd(1),opnd(2),...)	*/
  5   137 
  5   138 	stack_ptr		initial("011010001"b),	/* opnd(1) <- stack frame ptr		*/
  5   139 	empty_area	initial("011010010"b),	/* empty opnd(1), length in words is opnd(2) */
  5   140 	enable_on		initial("011010100"b),	/* opnd(1) is the cond name
  5   141*						   opnd(2) is the file name
  5   142*						   opnd(3) is the block	*/
  5   143 	revert_on		initial("011010101"b),	/* opnd(1) is the cond name,
  5   144*						   opnd(2) is the file name	*/
  5   145 	signal_on		initial("011010110"b),	/* opnd(1) is the cond name
  5   146*						   opnd(2) is the file name */
  5   147 
  5   148 	lock_fun		initial("011010111"b),	/* opnd(1) <- stac(opnd(2),opnd(3))	*/
  5   149 	stacq_fun		initial("011011000"b),	/* opnd(1) is result, opnd(2) is ptr to lock word,
  5   150*						   opnd(3) is old value, (4) is new value. */
  5   151 	clock_fun		initial("011011001"b),	/* opnd(1) is the clock time		*/
  5   152 	vclock_fun	initial("011011010"b),	/* opnd(1) is the virtual clock time	*/
  5   153 
  5   154 	bound_ck		initial("011100000"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  5   155 	range_ck		initial("011100001"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  5   156 	loop		initial("011100010"b),	/* do opnd(1) for opnd(2) from opnd(3) to opnd(4) by 1,
  5   157*						   opnd(5) is the list */
  5   158 	join		initial("011100011"b),	/* do opnd(1), opnd(2) ... opnd(n)	*/
  5   159 	allot_based	initial("011100100"b),	/* allocate opnd(2) words in opnd(3), set opnd(1) */
  5   160 	free_based	initial("011100101"b),	/* free opnd(1) in opnd(3), length is opnd(2) words */
  5   161 
  5   162 	r_parn		initial("011110001"b),	/* format op code			*/
  5   163 	l_parn		initial("011110010"b),
  5   164 	r_format		initial("011110011"b),
  5   165 	c_format		initial("011110100"b),
  5   166 	f_format		initial("011110101"b),
  5   167 	e_format		initial("011110110"b),
  5   168 	b_format		initial("011110111"b),
  5   169 	a_format		initial("011111000"b),
  5   170 	x_format		initial("011111001"b),
  5   171 	skip_format	initial("011111010"b),
  5   172 	column_format	initial("011111011"b),
  5   173 	page_format	initial("011111100"b),
  5   174 	line_format	initial("011111101"b),
  5   175 	picture_format	initial("011111110"b),
  5   176 	bn_format		initial("011111111"b),	/* bit format, length(opnd(2)), radix factor(opnd(3)) */
  5   177 
  5   178 	get_list_trans	initial("100000000"b),	/* getlist(opnd(2) with desc(opnd(1)))	*/
  5   179 	get_edit_trans	initial("100000001"b),	/* getedit(opnd(2) with desc(opnd(1)))	*/
  5   180 	get_data_trans	initial("100000010"b),	/* getdata(opnd(1) to opnd(n))	*/
  5   181 	put_list_trans	initial("100000011"b),	/* putlist(opnd(2) with desc(opnd(1)))	*/
  5   182 	put_edit_trans	initial("100000100"b),	/* putedit(opnd(2) with desc(opnd(1)))	*/
  5   183 	put_data_trans	initial("100000101"b),	/* putdata(opnd(2)) with subscript-list opnd(1) */
  5   184 	terminate_trans	initial("100000110"b),	/* terminate stream transmission	*/
  5   185 	stream_prep	initial("100000111"b),	/* initiate stream transmission	*/
  5   186 	record_io		initial("100001000"b),	/* perform record io operation	*/
  5   187 	fortran_read	initial("100001001"b),	/* A complete read statement		*/
  5   188 	fortran_write	initial("100001010"b),	/* A complete write statement		*/
  5   189 	ftn_file_manip	initial("100001011"b),	/* endfile,backspace,rewind,etc.	*/
  5   190 	ftn_trans_loop	initial("100001100"b),	/* An implied do in i/o list		*/
  5   191 	put_control	initial("100001101"b),	/* put control opnd(1) opnd(2) times	*/
  5   192 	put_field		initial("100001110"b),	/* putlist(opnd(2)) of length(opnd(1))	*/
  5   193 	put_field_chk	initial("100001111"b),	/* putlist(op(2)) of len(op(1)) check char index(op(3)) */
  5   194 
  5   195 /* These operators are produced by the parse but are not used as input to the code generator.	*/
  5   196 /* They are processed by the semantic translator.						*/
  5   197 
  5   198 	return_value	initial("100010010"b),	/* return(opnd(1))			*/
  5   199 	allot_var		initial("100010011"b),	/* allot opnd(1) in opnd(2)		*/
  5   200 	free_var		initial("100010100"b),	/* free opnd(1) out of opnd(2)	*/
  5   201 	get_file		initial("100010101"b),	/* opnd(1) is filename,opnd(2) is copy	*/
  5   202 						/* opnd(3) is skip, opnd(4) is list	*/
  5   203 	get_string	initial("100010110"b),	/* opnd(1) is string,opnd(2) is list	*/
  5   204 	put_file		initial("100010111"b),	/* opnd(1) is filename,opnd(2) is page	*/
  5   205 						/* opnd(3) is skip,opnd(4) is line	*/
  5   206 	put_string	initial("100011000"b),	/* opnd(1) is string,opnd(2) is list	*/
  5   207 	open_file		initial("100011001"b),
  5   208 	close_file	initial("100011010"b),
  5   209 	read_file		initial("100011011"b),
  5   210 	write_file	initial("100011100"b),
  5   211 	locate_file	initial("100011101"b),
  5   212 	do_fun		initial("100011110"b),	/* opnd(1) is join of a list		*/
  5   213 						/* opnd(2) is control variable ref	*/
  5   214 						/* opnd(3) is specification operator	*/
  5   215 	do_spec		initial("100011111"b),	/* opnd(1) to opnd(2) by opnd(3) 	*/
  5   216 						/* repeat opnd(4) while opnd(5)	*/
  5   217 						/* opnd(6) is next specification	*/
  5   218 
  5   219 	rewrite_file	initial("100100000"b),
  5   220 	delete_file	initial("100100001"b),
  5   221 	unlock_file	initial("100100010"b),
  5   222 	lock_file		initial("100100011"b),
  5   223 	refer		initial("100100101"b),	/* opnd(1) refer(opnd(2))		*/
  5   224 	prefix_plus	initial("100100110"b),	/* opnd(1) <- +opnd(2)		*/
  5   225 	nop		initial("100100111"b),	/* no-op */
  5   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
  5   227 
  5   228 /* These operators are produced by the semantic translator in processing the math
  5   229*   builtin functions and are used as input to the code generator			*/
  5   230 
  5   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
  5   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
  5   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
  5   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
  5   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
  5   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
  5   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
  5   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
  5   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
  5   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
  5   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
  5   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
  5   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
  5   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
  5   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
  5   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
  5   247 
  5   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
  5   249 
  5   250 			bit(9) aligned internal static options(constant);
  5   251 
  5   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       79 
  6     1 dcl (	ldfx1		init(7),
  6     2 	ldfx2		init(8),		/* ldfx1+1 */
  6     3 	ldfl1		init(9),		/* ldfx1+2 */
  6     4 	ldfl2		init(10),		/* ldfx1+3 */
  6     5 	lcfx1		init(11),		/* ldfx1+4 */
  6     6 	lcfx2		init(12),		/* ldfx1+5 */
  6     7 	lcfl1		init(13),		/* ldfx1+6 */
  6     8 	lcfl2		init(14),		/* ldfx1+7 */
  6     9 
  6    10 	stfx1		init(15),
  6    11 	stfx2		init(16),		/* stfx1+1 */
  6    12 	stfl1		init(17),		/* stfx1+2 */
  6    13 	stfl2		init(18),		/* stfx1+3 */
  6    14 
  6    15 	adfx1		init(19),
  6    16 	adfx2		init(20),
  6    17 	adfx3		init(21),
  6    18 
  6    19 	sbfx1		init(22),
  6    20 	sbfx2		init(23),
  6    21 	sbfx3		init(24),
  6    22 
  6    23 	mpfx1		init(25),
  6    24 
  6    25 	dvfx1		init(26),
  6    26 
  6    27 	adfl1		init(27),
  6    28 	adfl2		init(28),		/* adfl1+1 */
  6    29 
  6    30 	sbfl1		init(29),		/* adfl1+2 */
  6    31 	sbfl2		init(30),		/* sbfl1+1 */
  6    32 
  6    33 	mpfl1		init(31),		/* adfl1+4 */
  6    34 	mpfl2		init(32),		/* mpfl1+1 */
  6    35 
  6    36 	dvfl1		init(33),		/* adfl1+6 */
  6    37 	dvfl2		init(34),		/* dvfl1+1 */
  6    38 
  6    39 	difl1		init(35),		/* dvfl1+2 */
  6    40 	difl2		init(36),		/* dvfl2+2 */
  6    41 
  6    42 	absfx1		init(126),
  6    43 	absfx2		init(127),	/* absfx1+1 */
  6    44 	absfl1		init(128),	/* absfx1+2 */
  6    45 	absfl2		init(129),	/* absfx1+3 */
  6    46 
  6    47 	mdfl1		init(269),
  6    48 	mdfl2		init(270),	/* mdfl1+1 */
  6    49 
  6    50 	mdfx1		init(271),
  6    51 	mdfx2		init(272),	/* mdfx1+1 */
  6    52 	mdfx3		init(273),	/* mdfx1+2 */
  6    53 	mdfx4		init(274),	/* mdfx1+3 */
  6    54 
  6    55 	test_ldfx1	init(328),
  6    56 	test_ldfl1	init(330),
  6    57 
  6    58 	rfb1_to_rfb2	init(88)) fixed bin(15) internal static options(constant);
       80 
  7     1 dcl (	neg		init(37),
  7     2 	negl		init(38),
  7     3 	fneg		init(39),
  7     4 
  7     5 	clear_aq		init(58),
  7     6 	clear_q		init(59),
  7     7 	blank_q		init(135),
  7     8 
  7     9 	als		init(134),
  7    10 	lrl		init(62),
  7    11 	lls		init(63)) fixed bin(15) internal static options(constant);
       81 
       82 
       83 dcl (	fx1_to_fl2	init(122),
       84 	fl2_to_fx2	init(125)) fixed bin(15) int static;
       85 
       86 
       87 begin:	p1 = ref(1);
       88 
       89 	reversed,
       90 	mult_scaled,
       91 	check_type,
       92 	check_scale = "0"b;
       93 
       94 	p2 = ref(2);
       95 
       96 	p = node_pt;
       97 	q2 = p -> operand(2);
       98 
       99 	if p1 -> reference.symbol -> symbol.complex
      100 	then do;
      101 	     call expmac$interpret(complex_stuff$complex_stuff,node_pt,refs,atom);
      102 	     return;
      103 	     end;
      104 
      105 	type1 = p1 -> reference.data_type;
      106 	type2 = p2 -> reference.data_type;
      107 
      108 	/* check for special attention */
      109 
      110 	if p -> operator.op_code = negate then goto neg_op;
      111 
      112 	p3 = ref(3);
      113 	q3 = p -> operand(3);
      114 
      115 	op_code = fixed(p -> operator.op_code,9) - 16;
      116 
      117 	type3 = p3 -> reference.data_type;
      118 
      119 	/* if p3 is in q, try to flip_rands */
      120 
      121 	if p3 -> reference.value_in.q
      122 	then if atom(2)
      123 	then if op_code ^= sub_op
      124 	then if op_code ^= div_op
      125 	then if atom(3)
      126 	then do;
      127 	     call flip_rands;
      128 	     reversed = "0"b;
      129 	     end;
      130 
      131 	/* get information for this combination of operator
      132*	   and data types */
      133 
      134 	if type1 >= real_flt_bin_1
      135 	then do;
      136 
      137 	     /* have floating point operation, we use the
      138*	        manner in which macro values are coded to
      139*	        calculate the appropriate macro to use */
      140 
      141 	     max_type = type1;
      142 	     rev, comp = 0;
      143 	     op = adfl1 + 2 * op_code - real_flt_bin_1 - 2;
      144 
      145 	     if op_code = 4
      146 	     then do;
      147 
      148 		/* have floating divide, must avoid FDV & FDI
      149*		   instructions for double precision result
      150*		   (fixes bug 1230) */
      151 
      152 		if type1 > type2
      153 		then do;
      154 		     atom(2) = "0"b;
      155 		     check_type = "1"b;
      156 		     end;
      157 
      158 		if type1 > type3
      159 		then do;
      160 		     atom(3) = "0"b;
      161 		     check_type = "1"b;
      162 		     end;
      163 
      164 		/* if p3 is in q, try to flip rands and use inverted divide */
      165 
      166 		if p3 -> reference.value_in.q & atom(2) & atom(3)
      167 		then do;
      168 		     call flip_rands;
      169 		     op = op + 2;
      170 		     end;
      171 		end;
      172 	     end;
      173 	else do;
      174 
      175 	     /* have fixed point operation; all division (except
      176*	        for fx1/fx1) is handled by external
      177*	        operator */
      178 
      179 	     scale1 = p1 -> reference.symbol -> symbol.scale;
      180 	     scale2 = p2 -> reference.symbol -> symbol.scale;
      181 	     scale3 = p3 -> reference.symbol -> symbol.scale;
      182 
      183 	     if op_code ^= div_op then goto normal;
      184 
      185 	     if scale1 ^= 0 then goto punt;
      186 	     if scale2 ^= 0 then goto punt;
      187 	     if scale3 ^= 0 then goto punt;
      188 
      189 
      190 	     if max(type1,type2,type3) = real_fix_bin_1
      191 	     then do;
      192 		k = type2;
      193 		goto gi;
      194 		end;
      195 
      196 punt:	     if ^ atom(3) then p3 = compile_exp$save(q3);
      197 	     if atom(2) then call load(p2,0); else call compile_exp(q2);
      198 	     op = divide_fx1 + 2*type2 + type3 - 3;
      199 	     shift = scale1 - (scale2 - scale3);
      200 	     call expmac(op,p3);
      201 	     call expmac$abs(addr(shift),1);
      202 	     return;
      203 
      204 normal:	     if op_code = mult_op 
      205 	     then do;
      206 		k = type2;
      207 		if scale1 ^= scale2 + scale3
      208 		     then mult_scaled = "1"b;
      209 		end;
      210 
      211 	     else do;
      212 		max_type = max(type2,type3);
      213 		if max_type = real_fix_bin_1 & type1 = real_fix_bin_2
      214 		then k = real_fix_bin_2; else k = type2;
      215 
      216 		if scale1 ^= scale2
      217 		then do;
      218 		     atom(2) = "0"b;
      219 		     check_scale = "1"b;
      220 		     end;
      221 
      222 		if scale1 ^= scale3
      223 		then do;
      224 		     atom(3) = "0"b;
      225 		     check_scale = "1"b;
      226 		     end;
      227 
      228 		end;
      229 
      230 gi:	     call get_information;
      231 	     end;
      232 
      233 	/* dispatch on form of operands */
      234 
      235 	goto arith_switch(fixed(atom(2) || atom(3),2));
      236 
      237 	/* both operands are atomic.  check to see if body of
      238*	   operation takes left operand instead of right */
      239 
      240 arith_switch(3):
      241 atm_atm:	if rev > 0
      242 	then do;
      243 faa:	     call flip_rands;
      244 	     goto aa_2;
      245 	     end;
      246 
      247 	if op_code = mult_op
      248 	then if type1 = real_fix_bin_1
      249 	     then if p2 -> reference.symbol -> symbol.constant
      250 		then if ^p3->reference.symbol->symbol.constant
      251 		     then goto faa;
      252 		     else if power_of_two(p2->reference.symbol->symbol.initial->based_int) ^= 0
      253 			then goto faa;
      254 
      255 	/* expand load(p2) and body(p3) */
      256 
      257 aa_2:	call load(p2,comp);
      258 
      259 aa_3:	if op_code <= sub_op
      260 	then do;
      261 	     if check_scale
      262 		then max_type = max(type2,type3);
      263 
      264 	     if max_type < type1
      265 		then call expmac$zero(rfb1_to_rfb2);
      266 	     end;
      267 
      268 	if type1 >= real_flt_bin_1 then op = op + type3;
      269 aa_4:	call expmac(op,p3);
      270 
      271 	if mult_scaled
      272 	then do;
      273 	     p1 -> reference.symbol -> symbol.scale = scale2 + scale3;
      274 	     call aq_man$fix_scale(p1,scale1,type1);
      275 	     p1 -> reference.symbol -> symbol.scale = scale1;
      276 	     end;
      277 
      278 	return;
      279 
      280 	/* expressions on both sides, the case real_fix_bin_1 - real_fix_bin_2
      281*	   is given special treatment */
      282 
      283 arith_switch(0):
      284 exp_exp:	if op_code ^= sub_op then goto ee_0;
      285 
      286 	if type1 >= real_flt_bin_1 then goto ee_0;
      287 
      288 	if type2 < type3 & ^ check_scale
      289 	then do;
      290 	     p2 = compile_exp$save(q2);
      291 	     call compile_exp(q3);
      292 	     call expmac$zero(negl);
      293 	     call expmac(adfx3,p2);
      294 	     return;
      295 	     end;
      296 
      297 	/* both operands are expressions, evaluate right expression
      298*	   and store in a temporary, then treat like exp_atm case */
      299 
      300 ee_0:	if rev > 0 then call flip_rands;
      301 
      302 	if check_scale & scale1 ^= scale3
      303 	then do;
      304 	     p3 = compile_exp$save_fix_scaled(q3,scale1,type1);
      305 	     type3 = type1;
      306 	     call get_info;
      307 	     if reversed
      308 	     then if rev = 0
      309 		then do;
      310 		     call flip_rands;
      311 		     go to atm_exp;
      312 		     end;
      313 	     end;
      314 	else if check_type & type1 > type3
      315 	     then do;
      316 		p3 = compile_exp$save_float_2(q3);
      317 		type3 = type1;
      318 		end;
      319 	     else p3 = compile_exp$save(q3);
      320 
      321 	goto ea_0;
      322 
      323 	/* left operand is atomic, right is an expression. */
      324 
      325 arith_switch(2):
      326 atm_exp:	goto ae_switch(op_code);
      327 
      328 	/* operation is addtion */
      329 
      330 ae_switch(1):
      331 ae_add:	call flip_rands;
      332 	goto ea_0;
      333 
      334 	/* operation is multiplication */
      335 
      336 ae_switch(3):
      337 ae_mpy:	if type2 = real_fix_bin_1
      338 	then if type3 = real_fix_bin_2
      339 	     then rev = 1; else;
      340 	else if type2 = real_fix_bin_2
      341 	     then if type3 = real_fix_bin_1
      342 		then rev = 0;
      343 
      344 	goto ae_gen;
      345 
      346 	/* operation is subtraction, evaluate expression and
      347*	   save if fixed single */
      348 
      349 ae_switch(2):
      350 ae_sub:	if type3 = real_fix_bin_1
      351 	then do;
      352 ae_sub_1:	     if check_scale & scale1 ^= scale3
      353 	     then do;
      354 		p3 = compile_exp$save_fix_scaled(q3,scale1,type1);
      355 		type3 = type1;
      356 		call get_info;
      357 		end;
      358 	     else p3 = compile_exp$save(q3);
      359 
      360 	     goto aa_2;
      361 	     end;
      362 
      363 	call compile_exp(q3);
      364 
      365 	if check_scale & scale1 ^= scale3
      366 	then do;
      367 	     call aq_man$fix_scale(p3,scale1,type1);
      368 	     type3 = type1;
      369 	     call get_info;
      370 	     end;
      371 
      372 	k = 1 - mod(type2,2);
      373 	if type3 >= real_flt_bin_1
      374 	then op = adfl1 + k;
      375 	else op = adfx3 - k;
      376 
      377 	/* we use the fact that:
      378*	     real_fix_bin_2 = real_fix_bin_1+1
      379*	     real_flt_bin_2 = real_flt_bin_1+1
      380*	   and the fact that:
      381*	     mod(real_fix_bin_1,2) = mod(real_fix_bin_2,2) = 1;
      382*
      383*	   Thus we generate op for single precision atom,
      384*	   and op+|-1 for double precision atom      */
      385 
      386 	call expmac$zero(negate_op(type3));
      387 	call expmac(op,p2);
      388 	return;
      389 
      390 	/* operation is division.  evaluate expression and
      391*	   save if fixed point or use inverse divide if floating */
      392 
      393 ae_switch(4):
      394 ae_div:	if type1 <= real_fix_bin_2
      395 	then do;
      396 	     p3 = compile_exp$save(q3);
      397 	     goto aa_2;
      398 	     end;
      399 
      400 	op = op+2;
      401 
      402 	/* for general operation, reverse operands */
      403 
      404 ae_gen:	call flip_rands;
      405 
      406 	/* left operand is an expression, right is atomic. */
      407 
      408 arith_switch(1):
      409 exp_atm:	if check_scale & scale1 ^= scale2
      410 	then do;
      411 	     type2 = type1;
      412 	     call get_info;
      413 	     end;
      414 
      415 	if rev > 0
      416 	then do;
      417 	     if check_scale & scale1 ^= scale2
      418 	     then p2 = compile_exp$save_fix_scaled(q2,scale1,type1);
      419 	     else p2 = compile_exp$save(q2);
      420 
      421 	     call flip_rands;
      422 	     goto aa_2;
      423 	     end;
      424 
      425 ea_0:	call compile_exp(q2);
      426 
      427 	if check_scale & scale1 ^= scale2
      428 	then do;
      429 	     call aq_man$fix_scale(p2,scale1,type1);
      430 	     type2 = type1;
      431 	     call get_info;
      432 	     end;
      433 
      434 	if op_code = add_op
      435 	then do;
      436 	     if type2 ^= real_fix_bin_1 then goto aa_3;
      437 	     if type3 ^= real_fix_bin_2 then goto aa_3;
      438 	     call expmac$zero(rfb1_to_rfb2);
      439 	     op = adfx2;
      440 	     goto aa_4;
      441 	     end;
      442 
      443 	if comp > 0 then call expmac$zero(negate_op(type2));
      444 	goto aa_3;
      445 
      446 	/* negation operator */
      447 
      448 neg_op:	if atom(2)
      449 	then do;
      450 
      451 	     /* set k = 3 if double length atom and 1 otherwise */
      452 
      453 	     if mod(type2,2) = 0 then k = 3; else k = 1;
      454 	     call load(p2,k);
      455 	     end;
      456 	else do;
      457 
      458 	     /* have expression */
      459 
      460 	     call compile_exp(q2);
      461 	     call expmac$zero(negate_op(type1));
      462 	     end;
      463 	return;
      464 
      465 flip_rands:    proc;
      466 	
      467 	     /* this procedure is called to reverse the operands of a node */
      468 	
      469 	     dcl p ptr,t fixed bin,b bit(1) aligned;
      470 	
      471 	     p = p2; p2 = p3; p3 = p;
      472 	     p = q2; q2 = q3; q3 = p;
      473 	     t = type2; type2 = type3; type3 = t;
      474 	     t = scale2; scale2 = scale3; scale3 = t;
      475 	     b = atom(2); atom(2) = atom(3); atom(3) = b;
      476 	     reversed = ^ reversed;
      477 	
      478 	     end;
      479 
      480 get_info:	     proc;
      481 
      482 dcl	     j fixed bin,
      483 	     info_pt ptr;
      484 
      485 	     j = type2;
      486 	     goto common;
      487 
      488 get_information: entry;
      489 
      490 	     j = k;
      491 
      492 common:	     info_pt = addr(arith_data$fixed(op_code).left_type(j).
      493 	      right_type(type3));
      494 	     op = info_pt -> fix_info.body;
      495 	     rev = info_pt -> fix_info.rev;
      496 	     comp = info_pt -> fix_info.comp;
      497 	     end;
      498 
      499 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1007.8  arith_op.pl1                      >spec>on>pl128d>arith_op.pl1
75           1    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
76           2    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
77           3    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
78           4    05/03/76  1320.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
79           5    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
80           6    05/03/76  1320.4  645op2.incl.pl1                   >ldd>include>645op2.incl.pl1
81           7    05/03/76  1320.4  645op3.incl.pl1                   >ldd>include>645op3.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
add_op                                 constant        fixed bin(17,0)          initial dcl 69 ref 434
addr                                                   builtin function         dcl 55 ref 201 201 492
adfl1                                  constant        fixed bin(15,0)          initial dcl 6-1 ref 143 373
adfx2                                  constant        fixed bin(15,0)          initial dcl 6-1 ref 439
adfx3                           000012 constant        fixed bin(15,0)          initial dcl 6-1 set ref 293* 375
aq_man$fix_scale                000042 constant        entry                    external dcl 49 ref 274 367 429
arith_data$fixed                000044 external static structure                array level 1 unaligned dcl 57
atom                                   parameter       bit(1)                   array dcl 25 set ref 23 101* 121 121 154* 160* 166
                                                                                  166 196 197 218* 224* 235 235 448 475 475* 475
                                                                                  475*
attributes               31            based           structure                level 2 dcl 3-3
b                               000147 automatic       bit(1)                   dcl 469 set ref 475* 475
based_int                              based           fixed bin(18,0)          dcl 32 set ref 252*
body                                   based           fixed bin(15,0)          level 2 dcl 57 ref 494
check_scale                     000131 automatic       bit(1)                   dcl 32 set ref 89* 219* 225* 261 288 302 352 365 408
                                                                                  417 427
check_type                      000132 automatic       bit(1)                   dcl 32 set ref 89* 155* 161* 314
comp                            000125 automatic       fixed bin(15,0)          dcl 32 in procedure "arith_op" set ref 142* 257* 443
                                                                                  496*
comp                      2            based           fixed bin(15,0)          level 2 in structure "fix_info" dcl 57 in procedure
                                                                                  "arith_op" ref 496
compile_exp                     000032 constant        entry                    external dcl 32 ref 197 291 363 425 460
compile_exp$save                000034 constant        entry                    external dcl 32 ref 196 290 319 358 396 419
compile_exp$save_fix_scaled     000040 constant        entry                    external dcl 49 ref 304 354 417
compile_exp$save_float_2        000036 constant        entry                    external dcl 32 ref 316
complex                  31(31)        based           bit(1)                   level 4 packed unaligned dcl 3-3 ref 99
complex_stuff$complex_stuff     000014 external static fixed bin(17,0)          dcl 32 set ref 101*
constant                 32(16)        based           bit(1)                   level 4 packed unaligned dcl 3-3 ref 247 247
data_type                12            based           fixed bin(5,0)           level 2 packed unaligned dcl 1-3 ref 105 106 117
div_op                                 constant        fixed bin(17,0)          initial dcl 69 ref 121 183
divide_fx1                             constant        fixed bin(15,0)          initial dcl 53 ref 198
expmac                          000024 constant        entry                    external dcl 32 ref 200 269 293 387
expmac$abs                      000030 constant        entry                    external dcl 32 ref 201
expmac$interpret                000022 constant        entry                    external dcl 32 ref 101
expmac$zero                     000026 constant        entry                    external dcl 32 ref 264 292 386 438 443 461
fix_info                               based           structure                level 1 unaligned dcl 57
fixed                                                  builtin function         dcl 55 ref 115 235
info                     11            based           structure                level 2 packed unaligned dcl 1-3
info_pt                         000160 automatic       pointer                  dcl 482 set ref 492* 494 495 496
initial                  11            based           pointer                  level 2 packed unaligned dcl 3-3 ref 252
j                               000156 automatic       fixed bin(17,0)          dcl 482 set ref 485* 490* 492
k                               000123 automatic       fixed bin(15,0)          dcl 32 set ref 192* 206* 213* 214* 372* 373 375 453*
                                                                                  453* 454* 490
left_type                       000044 external static structure                array level 2 unaligned dcl 57
load                            000016 constant        entry                    external dcl 32 ref 197 257 454
max                                                    builtin function         dcl 55 ref 190 212 261
max_type                        000126 automatic       fixed bin(15,0)          dcl 32 set ref 141* 212* 213 261* 264
misc_attributes          31(19)        based           structure                level 3 packed unaligned dcl 3-3
mod                                                    builtin function         dcl 55 ref 372 453
mult_op                                constant        fixed bin(17,0)          initial dcl 69 ref 204 247
mult_scaled                     000133 automatic       bit(1)                   dcl 32 set ref 89* 207* 271
negate                                 constant        bit(9)                   initial dcl 5-8 ref 110
negate_op                       000010 internal static fixed bin(15,0)          initial array dcl 32 set ref 386* 443* 461*
negl                            000010 constant        fixed bin(15,0)          initial dcl 7-1 set ref 292*
node_pt                                defined         pointer                  dcl 29 set ref 96 101*
node_pts                               parameter       pointer                  dcl 25 ref 23 96 96 101 101
op                              000122 automatic       fixed bin(15,0)          dcl 32 set ref 143* 169* 169 198* 200* 268* 268 269*
                                                                                  373* 375* 387* 400* 400 439* 494*
op_code                   0(09)        based           bit(9)                   level 2 in structure "operator" packed unaligned
                                                                                  dcl 2-6 in procedure "arith_op" ref 110 115
op_code                         000127 automatic       fixed bin(15,0)          dcl 32 in procedure "arith_op" set ref 115* 121 121
                                                                                  143 145 183 204 247 259 283 325 434 492
operand                   1            based           pointer                  array level 2 packed unaligned dcl 2-6 ref 97 113
operator                               based           structure                level 1 dcl 2-6
p                               000144 automatic       pointer                  dcl 469 in procedure "flip_rands" set ref 471* 471
                                                                                  472* 472
p                               000100 automatic       pointer                  dcl 32 in procedure "arith_op" set ref 96* 97 110
                                                                                  113 115
p1                              000102 automatic       pointer                  dcl 32 set ref 87* 99 105 179 273 274* 275
p2                              000104 automatic       pointer                  dcl 32 set ref 94* 106 180 197* 247 252 257* 290*
                                                                                  293* 387* 417* 419* 429* 454* 471 471*
p3                              000106 automatic       pointer                  dcl 32 set ref 112* 117 121 166 181 196* 200* 247
                                                                                  269* 304* 316* 319* 354* 358* 367* 396* 471 471*
power_of_two                    000020 constant        entry                    external dcl 32 ref 252
q                        11(10)        based           bit(1)                   level 4 packed unaligned dcl 1-3 ref 121 166
q2                              000110 automatic       pointer                  dcl 32 set ref 97* 197* 290* 417* 419* 425* 460* 472
                                                                                  472*
q3                              000112 automatic       pointer                  dcl 32 set ref 113* 196* 291* 304* 316* 319* 354*
                                                                                  358* 363* 396* 472 472*
real_fix_bin_1                         constant        fixed bin(15,0)          initial dcl 4-1 ref 190 213 247 336 340 349 436
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 4-1 ref 213 213 336 340 393 437
real_flt_bin_1                         constant        fixed bin(15,0)          initial dcl 4-1 ref 134 143 268 286 373
ref                                    defined         pointer                  array dcl 29 ref 87 94 112
reference                              based           structure                level 1 dcl 1-3
refs                                   parameter       pointer                  array dcl 25 set ref 23 87 87 94 94 101* 112 112
rev                             000124 automatic       fixed bin(15,0)          dcl 32 in procedure "arith_op" set ref 142* 240 300
                                                                                  307 336* 340* 415 495*
rev                       1            based           fixed bin(15,0)          level 2 in structure "fix_info" dcl 57 in procedure
                                                                                  "arith_op" ref 495
reversed                        000134 automatic       bit(1)                   dcl 32 set ref 89* 128* 307 476* 476
rfb1_to_rfb2                    000011 constant        fixed bin(15,0)          initial dcl 6-1 set ref 264* 438*
right_type                      000044 external static structure                array level 3 unaligned dcl 57 set ref 492
scale                     2(28)        based           fixed bin(7,0)           level 2 packed unaligned dcl 3-3 set ref 179 180 181
                                                                                  273* 275*
scale1                          000117 automatic       fixed bin(15,0)          dcl 32 set ref 179* 185 199 207 216 222 274* 275 302
                                                                                  304* 352 354* 365 367* 408 417 417* 427 429*
scale2                          000120 automatic       fixed bin(15,0)          dcl 32 set ref 180* 186 199 207 216 273 408 417 427
                                                                                  474 474*
scale3                          000121 automatic       fixed bin(15,0)          dcl 32 set ref 181* 187 199 207 222 273 302 352 365
                                                                                  474 474*
shift                           000130 automatic       fixed bin(17,0)          dcl 32 set ref 199* 201 201
storage_class            32(09)        based           structure                level 3 packed unaligned dcl 3-3
sub_op                                 constant        fixed bin(17,0)          initial dcl 69 ref 121 259 283
symbol                                 based           structure                level 1 dcl 3-3 in procedure "arith_op"
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 1-3 in procedure "arith_op" ref 99 179 180 181
                                                                                  247 247 252 273 275
t                               000146 automatic       fixed bin(17,0)          dcl 469 set ref 473* 473 474* 474
type1                           000114 automatic       fixed bin(15,0)          dcl 32 set ref 105* 134 141 152 158 190 213 247 264
                                                                                  268 274* 286 304* 305 314 317 354* 355 367* 368
                                                                                  393 411 417* 429* 430 461
type2                           000115 automatic       fixed bin(15,0)          dcl 32 set ref 106* 152 190 192 198 206 212 214 261
                                                                                  288 336 340 372 411* 430* 436 443 453 473 473* 485
type3                           000116 automatic       fixed bin(15,0)          dcl 32 set ref 117* 158 190 198 212 261 268 288 305*
                                                                                  314 317* 336 340 349 355* 368* 373 386 437 473
                                                                                  473* 492
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 1-3

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 5-8
abs_fun                                internal static bit(9)                   initial dcl 5-8
absfl1                                 internal static fixed bin(15,0)          initial dcl 6-1
absfl2                                 internal static fixed bin(15,0)          initial dcl 6-1
absfx1                                 internal static fixed bin(15,0)          initial dcl 6-1
absfx2                                 internal static fixed bin(15,0)          initial dcl 6-1
acos_fun                               internal static bit(9)                   initial dcl 5-8
acosd_fun                              internal static bit(9)                   initial dcl 5-8
add                                    internal static bit(9)                   initial dcl 5-8
addbitno_fun                           internal static bit(9)                   initial dcl 5-8
addcharno_fun                          internal static bit(9)                   initial dcl 5-8
addr_fun                               internal static bit(9)                   initial dcl 5-8
addr_fun_bits                          internal static bit(9)                   initial dcl 5-8
addrel_fun                             internal static bit(9)                   initial dcl 5-8
adfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
adfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
allocation_fun                         internal static bit(9)                   initial dcl 5-8
allot_auto                             internal static bit(9)                   initial dcl 5-8
allot_based                            internal static bit(9)                   initial dcl 5-8
allot_ctl                              internal static bit(9)                   initial dcl 5-8
allot_var                              internal static bit(9)                   initial dcl 5-8
als                                    internal static fixed bin(15,0)          initial dcl 7-1
and_bits                               internal static bit(9)                   initial dcl 5-8
asin_fun                               internal static bit(9)                   initial dcl 5-8
asind_fun                              internal static bit(9)                   initial dcl 5-8
assign                                 internal static bit(9)                   initial dcl 5-8
assign_by_name                         internal static bit(9)                   initial dcl 5-8
assign_round                           internal static bit(9)                   initial dcl 5-8
assign_size_ck                         internal static bit(9)                   initial dcl 5-8
assign_zero                            internal static bit(9)                   initial dcl 5-8
atan_fun                               internal static bit(9)                   initial dcl 5-8
atand_fun                              internal static bit(9)                   initial dcl 5-8
b_format                               internal static bit(9)                   initial dcl 5-8
baseno_fun                             internal static bit(9)                   initial dcl 5-8
baseptr_fun                            internal static bit(9)                   initial dcl 5-8
bit_pointer                            internal static bit(9)                   initial dcl 5-8
bit_string                             internal static fixed bin(15,0)          initial dcl 4-1
bit_to_char                            internal static bit(9)                   initial dcl 5-8
bit_to_word                            internal static bit(9)                   initial dcl 5-8
bitno_fun                              internal static bit(9)                   initial dcl 5-8
blank_q                                internal static fixed bin(15,0)          initial dcl 7-1
bn_format                              internal static bit(9)                   initial dcl 5-8
bool_fun                               internal static bit(9)                   initial dcl 5-8
bound_ck                               internal static bit(9)                   initial dcl 5-8
byte_fun                               internal static bit(9)                   initial dcl 5-8
c_a                             000000 constant        entry                    external dcl 32
c_format                               internal static bit(9)                   initial dcl 5-8
cat_string                             internal static bit(9)                   initial dcl 5-8
ceil_fun                               internal static bit(9)                   initial dcl 5-8
char_string                            internal static fixed bin(15,0)          initial dcl 4-1
char_to_word                           internal static bit(9)                   initial dcl 5-8
charno_fun                             internal static bit(9)                   initial dcl 5-8
clear_aq                               internal static fixed bin(15,0)          initial dcl 7-1
clear_q                                internal static fixed bin(15,0)          initial dcl 7-1
clock_fun                              internal static bit(9)                   initial dcl 5-8
close_file                             internal static bit(9)                   initial dcl 5-8
codeptr_fun                            internal static bit(9)                   initial dcl 5-8
column_format                          internal static bit(9)                   initial dcl 5-8
compile_exp$save_exp            000000 constant        entry                    external dcl 32
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_bin_1                      internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 4-1
complex_fun                            internal static bit(9)                   initial dcl 5-8
conjg_fun                              internal static bit(9)                   initial dcl 5-8
copy_string                            internal static bit(9)                   initial dcl 5-8
copy_temp                       000000 constant        entry                    external dcl 32
copy_words                             internal static bit(9)                   initial dcl 5-8
cos_fun                                internal static bit(9)                   initial dcl 5-8
cosd_fun                               internal static bit(9)                   initial dcl 5-8
delete_file                            internal static bit(9)                   initial dcl 5-8
desc_size                              internal static bit(9)                   initial dcl 5-8
difl1                                  internal static fixed bin(15,0)          initial dcl 6-1
difl2                                  internal static fixed bin(15,0)          initial dcl 6-1
digit_to_bit                           internal static bit(9)                   initial dcl 5-8
div                                    internal static bit(9)                   initial dcl 5-8
do_fun                                 internal static bit(9)                   initial dcl 5-8
do_spec                                internal static bit(9)                   initial dcl 5-8
dvfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
dvfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
dvfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
e_format                               internal static bit(9)                   initial dcl 5-8
empty_area                             internal static bit(9)                   initial dcl 5-8
enable_on                              internal static bit(9)                   initial dcl 5-8
entry_variable                         internal static fixed bin(15,0)          initial dcl 4-1
environmentptr_fun                     internal static bit(9)                   initial dcl 5-8
equal                                  internal static bit(9)                   initial dcl 5-8
ex_prologue                            internal static bit(9)                   initial dcl 5-8
exp                                    internal static bit(9)                   initial dcl 5-8
exp_fun                                internal static bit(9)                   initial dcl 5-8
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 4-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 4-1
f_format                               internal static bit(9)                   initial dcl 5-8
fixed_to_float                  000000 constant        entry                    external dcl 49
fl2_to_fx2                             internal static fixed bin(15,0)          initial dcl 83
float_to_fixed                  000000 constant        entry                    external dcl 49
floor_fun                              internal static bit(9)                   initial dcl 5-8
fneg                                   internal static fixed bin(15,0)          initial dcl 7-1
fortran_read                           internal static bit(9)                   initial dcl 5-8
fortran_write                          internal static bit(9)                   initial dcl 5-8
free_based                             internal static bit(9)                   initial dcl 5-8
free_ctl                               internal static bit(9)                   initial dcl 5-8
free_var                               internal static bit(9)                   initial dcl 5-8
ftn_file_manip                         internal static bit(9)                   initial dcl 5-8
ftn_trans_loop                         internal static bit(9)                   initial dcl 5-8
fx1_to_fl2                             internal static fixed bin(15,0)          initial dcl 83
get_data_trans                         internal static bit(9)                   initial dcl 5-8
get_edit_trans                         internal static bit(9)                   initial dcl 5-8
get_file                               internal static bit(9)                   initial dcl 5-8
get_list_trans                         internal static bit(9)                   initial dcl 5-8
get_string                             internal static bit(9)                   initial dcl 5-8
greater_or_equal                       internal static bit(9)                   initial dcl 5-8
greater_than                           internal static bit(9)                   initial dcl 5-8
half_to_word                           internal static bit(9)                   initial dcl 5-8
imag_fun                               internal static bit(9)                   initial dcl 5-8
index_after_fun                        internal static bit(9)                   initial dcl 5-8
index_before_fun                       internal static bit(9)                   initial dcl 5-8
index_fun                              internal static bit(9)                   initial dcl 5-8
index_rev_fun                          internal static bit(9)                   initial dcl 5-8
int_entry                              internal static fixed bin(15,0)          initial dcl 4-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 4-1
join                                   internal static bit(9)                   initial dcl 5-8
jump                                   internal static bit(9)                   initial dcl 5-8
jump_false                             internal static bit(9)                   initial dcl 5-8
jump_if_eq                             internal static bit(9)                   initial dcl 5-8
jump_if_ge                             internal static bit(9)                   initial dcl 5-8
jump_if_gt                             internal static bit(9)                   initial dcl 5-8
jump_if_le                             internal static bit(9)                   initial dcl 5-8
jump_if_lt                             internal static bit(9)                   initial dcl 5-8
jump_if_ne                             internal static bit(9)                   initial dcl 5-8
jump_true                              internal static bit(9)                   initial dcl 5-8
l_parn                                 internal static bit(9)                   initial dcl 5-8
label_constant                         internal static fixed bin(15,0)          initial dcl 4-1
label_variable                         internal static fixed bin(15,0)          initial dcl 4-1
lcfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
lcfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
lcfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
lcfx2                                  internal static fixed bin(15,0)          initial dcl 6-1
ldfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
ldfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
ldfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
ldfx2                                  internal static fixed bin(15,0)          initial dcl 6-1
length_fun                             internal static bit(9)                   initial dcl 5-8
less_or_equal                          internal static bit(9)                   initial dcl 5-8
less_than                              internal static bit(9)                   initial dcl 5-8
line_format                            internal static bit(9)                   initial dcl 5-8
lls                                    internal static fixed bin(15,0)          initial dcl 7-1
local_label_variable                   internal static fixed bin(15,0)          initial dcl 4-1
locate_file                            internal static bit(9)                   initial dcl 5-8
lock_file                              internal static bit(9)                   initial dcl 5-8
lock_fun                               internal static bit(9)                   initial dcl 5-8
log10_fun                              internal static bit(9)                   initial dcl 5-8
log2_fun                               internal static bit(9)                   initial dcl 5-8
log_fun                                internal static bit(9)                   initial dcl 5-8
loop                                   internal static bit(9)                   initial dcl 5-8
lrl                                    internal static fixed bin(15,0)          initial dcl 7-1
make_desc                              internal static bit(9)                   initial dcl 5-8
max_fun                                internal static bit(9)                   initial dcl 5-8
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 2-15
mdfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
mdfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
mdfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
mdfx2                                  internal static fixed bin(15,0)          initial dcl 6-1
mdfx3                                  internal static fixed bin(15,0)          initial dcl 6-1
mdfx4                                  internal static fixed bin(15,0)          initial dcl 6-1
min_fun                                internal static bit(9)                   initial dcl 5-8
mod_bit                                internal static bit(9)                   initial dcl 5-8
mod_byte                               internal static bit(9)                   initial dcl 5-8
mod_fun                                internal static bit(9)                   initial dcl 5-8
mod_half                               internal static bit(9)                   initial dcl 5-8
mod_word                               internal static bit(9)                   initial dcl 5-8
mpfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
mpfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
mpfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
mult                                   internal static bit(9)                   initial dcl 5-8
n                                      automatic       fixed bin(15,0)          dcl 32
neg                                    internal static fixed bin(15,0)          initial dcl 7-1
nop                                    internal static bit(9)                   initial dcl 5-8
not_bits                               internal static bit(9)                   initial dcl 5-8
not_equal                              internal static bit(9)                   initial dcl 5-8
off_fun                                internal static bit(9)                   initial dcl 5-8
open_file                              internal static bit(9)                   initial dcl 5-8
or_bits                                internal static bit(9)                   initial dcl 5-8
pack                                   internal static bit(9)                   initial dcl 5-8
packed_ptr                             internal static fixed bin(15,0)          initial dcl 4-1
page_format                            internal static bit(9)                   initial dcl 5-8
param_desc_ptr                         internal static bit(9)                   initial dcl 5-8
param_ptr                              internal static bit(9)                   initial dcl 5-8
picture_format                         internal static bit(9)                   initial dcl 5-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 5-8
prefix_plus                            internal static bit(9)                   initial dcl 5-8
ptr_fun                                internal static bit(9)                   initial dcl 5-8
put_control                            internal static bit(9)                   initial dcl 5-8
put_data_trans                         internal static bit(9)                   initial dcl 5-8
put_edit_trans                         internal static bit(9)                   initial dcl 5-8
put_field                              internal static bit(9)                   initial dcl 5-8
put_field_chk                          internal static bit(9)                   initial dcl 5-8
put_file                               internal static bit(9)                   initial dcl 5-8
put_list_trans                         internal static bit(9)                   initial dcl 5-8
put_string                             internal static bit(9)                   initial dcl 5-8
r_format                               internal static bit(9)                   initial dcl 5-8
r_parn                                 internal static bit(9)                   initial dcl 5-8
range_ck                               internal static bit(9)                   initial dcl 5-8
rank_fun                               internal static bit(9)                   initial dcl 5-8
read_file                              internal static bit(9)                   initial dcl 5-8
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 4-1
real_flt_bin_2                         internal static fixed bin(15,0)          initial dcl 4-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 4-1
real_fun                               internal static bit(9)                   initial dcl 5-8
record_io                              internal static bit(9)                   initial dcl 5-8
refer                                  internal static bit(9)                   initial dcl 5-8
rel_fun                                internal static bit(9)                   initial dcl 5-8
repeat_fun                             internal static bit(9)                   initial dcl 5-8
return_bits                            internal static bit(9)                   initial dcl 5-8
return_string                          internal static bit(9)                   initial dcl 5-8
return_value                           internal static bit(9)                   initial dcl 5-8
return_words                           internal static bit(9)                   initial dcl 5-8
reverse_fun                            internal static bit(9)                   initial dcl 5-8
revert_on                              internal static bit(9)                   initial dcl 5-8
rewrite_file                           internal static bit(9)                   initial dcl 5-8
round_fun                              internal static bit(9)                   initial dcl 5-8
sbfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
sbfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
sbfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
sbfx2                                  internal static fixed bin(15,0)          initial dcl 6-1
sbfx3                                  internal static fixed bin(15,0)          initial dcl 6-1
search_fun                             internal static bit(9)                   initial dcl 5-8
search_rev_fun                         internal static bit(9)                   initial dcl 5-8
segno_fun                              internal static bit(9)                   initial dcl 5-8
setbitno_fun                           internal static bit(9)                   initial dcl 5-8
setcharno_fun                          internal static bit(9)                   initial dcl 5-8
sign_fun                               internal static bit(9)                   initial dcl 5-8
signal_on                              internal static bit(9)                   initial dcl 5-8
sin_fun                                internal static bit(9)                   initial dcl 5-8
sind_fun                               internal static bit(9)                   initial dcl 5-8
skip_format                            internal static bit(9)                   initial dcl 5-8
sqrt_fun                               internal static bit(9)                   initial dcl 5-8
stack_ptr                              internal static bit(9)                   initial dcl 5-8
stackbaseptr_fun                       internal static bit(9)                   initial dcl 5-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 5-8
stacq_fun                              internal static bit(9)                   initial dcl 5-8
std_arg_list                           internal static bit(9)                   initial dcl 5-8
std_call                               internal static bit(9)                   initial dcl 5-8
std_entry                              internal static bit(9)                   initial dcl 5-8
std_return                             internal static bit(9)                   initial dcl 5-8
stfl1                                  internal static fixed bin(15,0)          initial dcl 6-1
stfl2                                  internal static fixed bin(15,0)          initial dcl 6-1
stfx1                                  internal static fixed bin(15,0)          initial dcl 6-1
stfx2                                  internal static fixed bin(15,0)          initial dcl 6-1
stop                                   internal static bit(9)                   initial dcl 5-8
stream_prep                            internal static bit(9)                   initial dcl 5-8
sub                                    internal static bit(9)                   initial dcl 5-8
tan_fun                                internal static bit(9)                   initial dcl 5-8
tand_fun                               internal static bit(9)                   initial dcl 5-8
terminate_trans                        internal static bit(9)                   initial dcl 5-8
test_ldfl1                             internal static fixed bin(15,0)          initial dcl 6-1
test_ldfx1                             internal static fixed bin(15,0)          initial dcl 6-1
translate_fun                          internal static bit(9)                   initial dcl 5-8
trunc_fun                              internal static bit(9)                   initial dcl 5-8
unlock_file                            internal static bit(9)                   initial dcl 5-8
unpack                                 internal static bit(9)                   initial dcl 5-8
unpacked_ptr                           internal static fixed bin(15,0)          initial dcl 4-1
vclock_fun                             internal static bit(9)                   initial dcl 5-8
verify_fun                             internal static bit(9)                   initial dcl 5-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 5-8
verify_rev_fun                         internal static bit(9)                   initial dcl 5-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 5-8
word_to_mod2                           internal static bit(9)                   initial dcl 5-8
word_to_mod4                           internal static bit(9)                   initial dcl 5-8
word_to_mod8                           internal static bit(9)                   initial dcl 5-8
wordno_fun                             internal static bit(9)                   initial dcl 5-8
write_file                             internal static bit(9)                   initial dcl 5-8
x_format                               internal static bit(9)                   initial dcl 5-8
xor_bits                               internal static bit(9)                   initial dcl 5-8

NAMES DECLARED BY EXPLICIT CONTEXT.
aa_2                            000533 constant        label                    dcl 257 ref 244 360 397 422
aa_3                            000544 constant        label                    dcl 259 ref 436 437 444
aa_4                            000575 constant        label                    dcl 269 ref 440
ae_add                          001011 constant        label                    dcl 330
ae_div                          001173 constant        label                    dcl 393
ae_gen                          001212 constant        label                    dcl 404 ref 344
ae_mpy                          001013 constant        label                    dcl 336
ae_sub                          001033 constant        label                    dcl 349
ae_sub_1                        001036 constant        label                    dcl 352
ae_switch                       000004 constant        label                    array(4) dcl 330 ref 325
arith_op                        000031 constant        entry                    external dcl 23
arith_switch                    000000 constant        label                    array(0:3) dcl 240 ref 235
atm_atm                         000473 constant        label                    dcl 240
atm_exp                         001007 constant        label                    dcl 325 ref 311
begin                           000036 constant        label                    dcl 87
common                          001476 constant        label                    dcl 492 ref 486
ea_0                            001263 constant        label                    dcl 425 ref 321 332
ee_0                            000715 constant        label                    dcl 300 ref 283 286
exp_atm                         001213 constant        label                    dcl 408
exp_exp                         000641 constant        label                    dcl 283
faa                             000475 constant        label                    dcl 243 ref 247 252
flip_rands                      001420 constant        entry                    internal dcl 465 ref 127 168 243 300 310 330 404 421
get_info                        001467 constant        entry                    internal dcl 480 ref 306 356 369 412 431
get_information                 001473 constant        entry                    internal dcl 488 ref 230
gi                              000457 constant        label                    dcl 230 ref 193
neg_op                          001353 constant        label                    dcl 448 ref 110
normal                          000406 constant        label                    dcl 204 ref 183
punt                            000276 constant        label                    dcl 196 ref 185 186 187

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1670        1736    1524        1700
Length      2262    1524        46         307     144           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
arith_op                            130 external procedure  is an external procedure.  
flip_rands                              internal procedure  shares stack frame of external procedure arith_op.  
get_info                                internal procedure  shares stack frame of external procedure arith_op.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 negate_op                   arith_op

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
arith_op                 000100 p                           arith_op
                         000102 p1                          arith_op
                         000104 p2                          arith_op
                         000106 p3                          arith_op
                         000110 q2                          arith_op
                         000112 q3                          arith_op
                         000114 type1                       arith_op
                         000115 type2                       arith_op
                         000116 type3                       arith_op
                         000117 scale1                      arith_op
                         000120 scale2                      arith_op
                         000121 scale3                      arith_op
                         000122 op                          arith_op
                         000123 k                           arith_op
                         000124 rev                         arith_op
                         000125 comp                        arith_op
                         000126 max_type                    arith_op
                         000127 op_code                     arith_op
                         000130 shift                       arith_op
                         000131 check_scale                 arith_op
                         000132 check_type                  arith_op
                         000133 mult_scaled                 arith_op
                         000134 reversed                    arith_op
                         000144 p                           flip_rands
                         000146 t                           flip_rands
                         000147 b                           flip_rands
                         000156 j                           get_info
                         000160 info_pt                     get_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aq_man$fix_scale              compile_exp                   compile_exp$save              compile_exp$save_fix_scaled
compile_exp$save_float_2      expmac                        expmac$abs                    expmac$interpret
expmac$zero                   load                          power_of_two

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
arith_data$fixed              complex_stuff$complex_stuff




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000025        87 000036        89 000042        94 000046        96 000051        97 000054        99 000056
    101 000063       102 000077       105 000100       106 000104       110 000110       112 000116       113 000121
    115 000124       117 000127       121 000132       127 000151       128 000152       134 000153       141 000156
    142 000157       143 000161       145 000165       152 000170       154 000173       155 000176       158 000200
    160 000202       161 000205       166 000207       168 000223       169 000224       172 000226       179 000227
    180 000235       181 000243       183 000251       185 000254       186 000256       187 000260       190 000262
    192 000273       193 000275       196 000276       197 000314       197 000334       198 000343       199 000351
    200 000357       201 000370       202 000405       204 000406       206 000410       207 000412       209 000420
    212 000421       213 000426       214 000436       216 000440       218 000443       219 000446       222 000450
    224 000452       225 000455       230 000457       235 000460       240 000473       243 000475       244 000476
    247 000477       252 000517       257 000533       259 000544       261 000547       264 000556       268 000570
    269 000575       271 000606       273 000610       274 000617       275 000632       278 000640       283 000641
    286 000644       288 000647       290 000654       291 000665       292 000674       293 000703       294 000714
    300 000715       302 000720       304 000725       305 000742       306 000744       307 000745       310 000751
    311 000752       313 000753       314 000754       316 000761       317 000772       318 000774       319 000775
    321 001006       325 001007       330 001011       332 001012       336 001013       339 001023       340 001024
    344 001032       349 001033       352 001036       354 001043       355 001060       356 001062       357 001063
    358 001064       360 001075       363 001076       365 001105       367 001112       368 001125       369 001127
    372 001130       373 001137       375 001146       386 001151       387 001161       388 001172       393 001173
    396 001176       397 001207       400 001210       404 001212       408 001213       411 001220       412 001222
    415 001223       417 001225       419 001250       421 001261       422 001262       425 001263       427 001272
    429 001277       430 001312       431 001314       434 001315       436 001320       437 001323       438 001326
    439 001335       440 001337       443 001340       444 001352       448 001353       453 001357       453 001366
    454 001370       455 001400       460 001401       461 001407       463 001417       465 001420       471 001421
    471 001423       471 001425       472 001427       472 001431       472 001433       473 001435       473 001437
    473 001441       474 001443       474 001445       474 001447       475 001451       475 001456       475 001461
    476 001463       478 001466       480 001467       485 001470       486 001472       488 001473       490 001474
    492 001476       494 001514       495 001516       496 001520       497 001522


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
