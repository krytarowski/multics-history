	COMPILATION LISTING OF SEGMENT do
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/15/86  1409.6 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 /****^		DO/EXECUTE_STRING/SUBSTITUTE_ARGUMENTS
       11*
       12*      Command/requests to expand specified string by substituting
       13*      arguments, and optionally executing the expansion.
       14*
       15*      Created:  30 October 1973 by BLW.
       16*      Modified: 31 December 1974 by Steve Herbst to remove string parameter.
       17*      Modified: 16 December 1975 by Steve Herbst to add &f and &n.
       18*      Modified: 3 March 1976 by Steve Herbst to add &qf and &rf.
       19*      Modified: 3 August 1976 by Steve Herbst to accept any number of
       20*	      mode-changing control arguments.
       21*      Modified: 15 October 1976 by Steve Herbst to fix bug with &f.
       22*      Modified: 16 February 1982 by G. Palter to add ssu_do_request_ and
       23*	      convert to use a standalone subsystem invocation.
       24*      Modified: 28 April 1982 by G. Dixon to allow AF first arg to begin with
       25*	      minus.
       26*      Modified: 8 September 1982 by G. Palter to propagate subsystem/request
       27*	      line aborts. */
       28 
       29 
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(86-08-11,JSLove), approve(86-08-12,MCR7520),
       33*     audit(86-08-14,FCSmith), install(86-10-01,MR12.0-1170):
       34*     Changed to permit control arguments and the control string in the same
       35*     invocation. Added -control_string (-cs) option to permit control string to
       36*     begin with a hyphen.  Added -inhibit_error and -no_inhibit_error as
       37*     synonyms of -absentee and -interactive, respectively. Added -abort_line
       38*     (-abl) mode for subsystem execution.  Improved expansion error
       39*     diagnostics. Changed handling of &r1&r2 to eliminate spurious quote. Added
       40*     &control_string construct and handling of "zeroth" argument.
       41*  2) change(86-08-11,JSLove), approve(86-08-12,MCR7519),
       42*     audit(86-08-14,FCSmith), install(86-10-01,MR12.0-1170):
       43*     Added execute_string and substitute_arguments entries. At this time,
       44*     substantial changes were required to permit the expansion of the
       45*     execute_string AF's -error_value.  Other changes were made for clarity,
       46*     coding standards, performance, robustness and minimizing the stack frame
       47*     size.   The complete set of changes amount to a substantial rewrite,
       48*     including: Removed standalone subsystem invocation.  Changed to allocate
       49*     expanded buffer rather than growing stack frame.  Changed to use PL/I "on"
       50*     statement to set handlers rather than the condition_ subroutine.
       51*  3) change(86-10-09,JSLove), approve(86-10-13,MCR7519),
       52*     audit(86-10-13,Parisek), install(86-10-15,MR12.0-1186):
       53*     Post-installation Bug Fix: changed error message associated with request
       54*     line aborts to not report ssu_et_$request_line_aborted in brief mode.
       55*                                                   END HISTORY COMMENTS */
       56 
       57 
       58 
       59 /* format: style3,ifthenstmt,indcomtxt,indproc,idind30 */
       60 
       61 do:
       62      procedure () options (variable);
       63 
       64 declare	P_info_ptr		ptr parameter,	/* subsystem request -> subsystem's internal data */
       65 	P_sci_ptr			ptr parameter;	/* subsystem request -> SCI of subsystem */
       66 
       67 declare	(addcharno, addr, addwordno, binary, copy, divide, hbound, index, lbound, length, ltrim, maxlength, min, mod,
       68 	null, rtrim, substr, verify)	builtin;
       69 
       70 declare	(active_function_error, any_other, area, cleanup)
       71 				condition;
       72 
       73 declare	abort_line		bit (1) aligned,
       74 	allocated_buffer_max_len	fixed bin (21),
       75 	allocated_buffer_ptr	ptr,
       76 	arg_count			fixed bin (17),
       77 	arg_list_ptr		ptr,
       78 	arg_offset		fixed bin (17),
       79 	entrypoint		fixed bin (2),
       80 	error_value_len		fixed bin (21),
       81 	error_value_ptr		ptr,
       82 	execute			bit (1) aligned,
       83 	expansion_buffer		char (256) varying,
       84 	expansion_max_len		fixed bin (21),
       85 	expansion_ptr		ptr,
       86 	inhibit_error		bit (1) aligned,
       87 	rescan_type		fixed bin (17),
       88 	return_value_max_len	fixed bin (21),
       89 	return_value_ptr		ptr,
       90 	sci_ptr			ptr,
       91 	status			fixed bin (35),
       92 	trace			bit (1) aligned,
       93 	unique			char (15) aligned;
       94 
       95 declare	allocated_buffer		char (allocated_buffer_max_len) varying based (allocated_buffer_ptr),
       96 	command			char (length (expansion)) based (addwordno (addr (expansion), 1)),
       97 	expansion			char (expansion_max_len) varying based (expansion_ptr),
       98 	return_value		char (return_value_max_len) varying based (return_value_ptr),
       99 	system_area		area based (get_system_free_area_ ());
      100 
      101 declare	abort_line_mode		(2) bit (1) aligned static initial ((2) ("1"b)),
      102 	execute_mode		(2) bit (1) aligned static initial ((2) ("1"b)),
      103 	inhibit_error_mode		(2) bit (1) aligned static initial ((2) ("0"b)),
      104 	trace_mode		(3) bit (1) aligned static initial ((3) ("0"b));
      105 
      106 declare	AMPERSAND			char (1) static options (constant) initial ("&"),
      107 	BLANK			char (1) static options (constant) initial (" "),
      108 	QUOTE			char (1) static options (constant) initial (""""),
      109 	WHITE			char (5) static options (constant) initial ("
      110 	 ");					/* FF VT NL HT SPACE				*/
      111 
      112 declare	(
      113 	DO_ENTRY			initial (1),
      114 	EXECUTE_ENTRY		initial (2),
      115 	SUBSTITUTE_ENTRY		initial (3)
      116 	)			fixed bin (2) static options (constant);
      117 
      118 declare	(
      119 	ILLEGAL_CHARACTER		initial (1),
      120 	ILLEGAL_END_CONTROL_STRING	initial (2),
      121 	ILLEGAL_END_ERROR_VALUE	initial (3),
      122 	ILLEGAL_INTEGER		initial (4),
      123 	ILLEGAL_KEYWORD		initial (5),
      124 	ILLEGAL_UNCLOSED		initial (6)
      125 	)			fixed bin (3) static options (constant);
      126 
      127 declare	(
      128 	NO_QUOTE_MODIFIER		initial (1),
      129 	PROTECT_QUOTES_MODIFIER	initial (2),
      130 	REQUOTE_MODIFIER		initial (3)
      131 	)			fixed bin (2) static options (constant);
      132 
      133 declare	MY_NAME			(3) char (20) static options (constant)
      134 				initial ("do", "execute_string", "substitute_arguments"),
      135 	MY_SHORT_NAME		(3) char (4) varying static options (constant) initial ("do", "exs", "sbag");
      136 
      137 declare	(
      138 	PARSER_EXPLICIT_CONTROL_STRING
      139 				initial (1),
      140 	PARSER_FOUND_CONTROL_STRING	initial (2),
      141 	PARSER_WANTS_CONTROL_STRING	initial (3),
      142 	PARSER_WANTS_ERROR_VALUE	initial (4)
      143 	)			fixed bin (3) static options (constant);
      144 
      145 declare	REASONS			(6) char (85) varying static options (constant)
      146 				initial ("An invalid character terminates substitution construct ^a.",
      147 				"Substitution construct ^a is incomplete at the end of the control string.",
      148 				"Substitution construct ^a is incomplete at the end of the error value.",
      149 				"The parenthesized part of substitution construct ^a must be an unsigned integer.",
      150 				"^a is not a valid substitution construct.",
      151 				"There is no "")"" terminating substitution construct ^a.");
      152 
      153 declare	SPECIAL_CONDITIONS		(5) char (24) varying static options (constant)
      154 				initial ("alrm", "cput", "quit", "program_interrupt", "record_quota_overflow");
      155 
      156 declare	(
      157 	COMMAND_USAGE		char (39) initial ("{-control_args} {control_string {args}}"),
      158 	EXS_AF_USAGE		char (37) initial ("{-control_args} control_string {args}"),
      159 	SBAG_AF_USAGE		char (21) initial ("control_string {args}") char (21)
      160 	)			static options (constant);
      161 
      162 declare	NO_FROM_WARNING		char (95) static options (constant)
      163 				initial ("""&^[q^;r^]f&n"" must be used instead of argument designator ^a.^[
      164 	Type ""start"" to continue.^]");
      165 
      166 declare	TRUNCATION_WARNING		char (127) static options (constant) initial ("
      167 	Only the first ^d characters of the expanded ^[error value^;control string^]
      168 	can be returned.^[  Type ""start"" to continue.^]");
      169 
      170 declare	(
      171 	error_table_$badopt,
      172 	error_table_$command_line_overflow,
      173 	error_table_$inconsistent,
      174 	error_table_$noarg,
      175 	error_table_$not_act_fnc,
      176 	ssu_et_$null_request_line,
      177 	ssu_et_$request_line_aborted,
      178 	ssu_et_$subsystem_aborted
      179 	)			fixed bin (35) external;
      180 
      181 declare	iox_$error_output		ptr external;
      182 
      183 declare	active_fnc_err_		entry () options (variable),
      184 	active_fnc_err_$suppress_name entry () options (variable),
      185 	com_err_			entry () options (variable),
      186 	com_err_$suppress_name	entry () options (variable),
      187 	condition_interpreter_	entry (ptr, ptr, fixed bin (17), fixed bin (17), ptr, char (*), ptr, ptr),
      188 	continue_to_signal_		entry (fixed bin (35)),
      189 	cu_$af_return_arg_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
      190 	cu_$arg_list_ptr		entry () returns (ptr),
      191 	cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
      192 	cu_$cp			entry (ptr, fixed bin (21), fixed bin (35)),
      193 	cu_$evaluate_active_string	entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
      194 	find_condition_info_	entry (ptr, ptr, fixed bin (35)),
      195 	get_system_free_area_	entry () returns (ptr),
      196 	ioa_			entry () options (variable),
      197 	ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
      198 				bit (1) aligned),
      199 	ioa_$ioa_switch		entry () options (variable),
      200 	requote_string_		entry (char (*)) returns (char (*)),
      201 	ssu_$abort_line		entry () options (variable),
      202 	ssu_$abort_subsystem	entry () options (variable),
      203 	ssu_$arg_ptr		entry (ptr, fixed bin (17), ptr, fixed bin (21)),
      204 	ssu_$evaluate_active_string	entry (ptr, ptr, char (*), fixed bin (17), char (*) var, fixed bin (35)),
      205 	ssu_$execute_line		entry (ptr, ptr, fixed bin (21), fixed bin (35)),
      206 	ssu_$get_subsystem_and_request_name
      207 				entry (ptr) returns (char (72) varying),
      208 	ssu_$get_request_name	entry (ptr) returns (char (32)),
      209 	ssu_$print_message		entry () options (variable),
      210 	ssu_$return_arg		entry (ptr, fixed bin (17), bit (1) aligned, ptr, fixed bin (21)),
      211 	unique_chars_		entry (bit (*) aligned) returns (char (15) aligned);
      212 
  1     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      213 
      214 
  2     1 /* BEGIN INCLUDE FILE ... cp_active_string_types.incl.pl1 */
  2     2 /* Created:  5 May 1980 by G. Palter */
  2     3 
  2     4 /* Types of active strings recognized by active string evaluation entries of the Multics command processor */
  2     5 
  2     6 dcl (DEFAULT_ACTIVE_STRING		initial (0),	/* default type: same as NORMAL_ACTIVE_STRING */
  2     7      NORMAL_ACTIVE_STRING		initial (1),	/* normal active string: [...] */
  2     8      TOKENS_ONLY_ACTIVE_STRING	initial (2),	/* rescan active string for whitespace and quotes: |[...] */
  2     9      ATOMIC_ACTIVE_STRING		initial (3))	/* do not rescan anything in value: ||[...] */
  2    10 	fixed binary static options (constant);
  2    11 
  2    12 /* END INCLUDE FILE ... cp_active_string_types.incl.pl1 */
      215 
      216 
      217 /* do: entry () options (variable); */
      218 
      219 	entrypoint = DO_ENTRY;			/* Execute as command, Substitute as AF */
      220 
      221 	go to STANDALONE;
      222 
      223 exs:
      224 execute_string:
      225      entry () options (variable);
      226 
      227 	entrypoint = EXECUTE_ENTRY;
      228 
      229 	go to STANDALONE;
      230 
      231 sbag:
      232 substitute_args:
      233 substitute_arguments:
      234      entry () options (variable);
      235 
      236 	entrypoint = SUBSTITUTE_ENTRY;
      237 
      238 STANDALONE:
      239 	sci_ptr = null ();
      240 
      241 	go to COMMON;
      242 
      243 ssu_do_request_:
      244      entry (P_sci_ptr, P_info_ptr);
      245 
      246 	entrypoint = DO_ENTRY;
      247 
      248 	go to SUBSYSTEM;
      249 
      250 ssu_execute_string_request_:
      251      entry (P_sci_ptr, P_info_ptr);
      252 
      253 	entrypoint = EXECUTE_ENTRY;
      254 
      255 	go to SUBSYSTEM;
      256 
      257 ssu_substitute_args_request_:
      258      entry (P_sci_ptr, P_info_ptr);
      259 
      260 	entrypoint = SUBSTITUTE_ENTRY;
      261 
      262 SUBSYSTEM:
      263 	sci_ptr = P_sci_ptr;
      264 
      265 	go to COMMON;
      266 
      267 /* Actual work starts here */
      268 
      269 COMMON:
      270 	allocated_buffer_max_len, error_value_len = 0;
      271 	allocated_buffer_ptr, arg_list_ptr, error_value_ptr = null ();
      272 	expansion_max_len = maxlength (expansion_buffer);
      273 	expansion_ptr = addr (expansion_buffer);
      274 	trace = trace_mode (entrypoint);
      275 	unique = "";
      276 
      277 	on cleanup
      278 	     begin;
      279 		if allocated_buffer_ptr ^= null () then free allocated_buffer in (system_area);
      280 	     end;
      281 
      282 	if sci_ptr = null ()
      283 	then call check_arguments (cu_$arg_list_ptr ());
      284 	else call ssu_$return_arg (sci_ptr, arg_count, ("0"b), return_value_ptr, return_value_max_len);
      285 
      286 	if return_value_ptr = null ()
      287 	then go to COMMAND (entrypoint);
      288 	else go to FUNCTION (entrypoint);
      289 
      290 COMMAND (1):					/* "do" */
      291 COMMAND (2):					/* "execute_string" */
      292 	call execute_string_command ();
      293 
      294 	if ^execute then go to EGRESS;
      295 
      296 	if inhibit_error then on any_other call any_other_handler ();
      297 
      298 	if sci_ptr = null ()
      299 	then call cu_$cp (addr (command), length (command), status);
      300 	else call ssu_$execute_line (sci_ptr, addr (command), length (command), status);
      301 
      302 	revert any_other;
      303 
      304 	if status ^= 0 then call execute_string_command_error ();
      305 
      306 	go to EGRESS;
      307 
      308 COMMAND (3):					/* "substitute_arguments" */
      309 	call substitute_args_command ();
      310 
      311 EGRESS:						/* Common exit and error abort point */
      312 	revert active_function_error, any_other;
      313 
      314 	if allocated_buffer_ptr ^= null () then free allocated_buffer in (system_area);
      315 
      316 	return;
      317 
      318 FUNCTION (1):					/* "do" */
      319 FUNCTION (3):					/* "substitute_arguments" */
      320 	call substitute_args_function ();
      321 
      322 	go to EGRESS;
      323 
      324 FUNCTION (2):					/* "execute_string" */
      325 	call execute_string_function ();
      326 
      327 	if error_value_ptr ^= null ()
      328 	then do;
      329 		if sci_ptr = null () then on active_function_error call active_function_error_handler ();
      330 		if inhibit_error then on any_other call any_other_handler ();
      331 	     end;
      332 
      333 	if sci_ptr = null ()
      334 	then call cu_$evaluate_active_string (null (), command, rescan_type, return_value, status);
      335 	else call ssu_$evaluate_active_string (sci_ptr, null (), command, rescan_type, return_value, status);
      336 
      337 	revert active_function_error, any_other;
      338 
      339 	if status ^= 0 then call execute_string_function_error ();
      340 
      341 	go to EGRESS;
      342 
      343 SUBSTITUTE_ERROR_VALUE:
      344 	revert active_function_error, any_other;
      345 
      346 	call expand_error_value ();
      347 
      348 	go to EGRESS;
      349 
      350 /**** Handler for errors during execution of an active function.  Only
      351*      errors reported by the active function are caught by this handler, as
      352*      opposed to faults which might occur during its execution. */
      353 
      354 active_function_error_handler:
      355      procedure ();
      356 
      357 declare	1 CI			aligned like condition_info;
      358 
      359 	if trace
      360 	then do;
      361 		CI.version = condition_info_version_1;
      362 		call find_condition_info_ (null (), addr (CI), (0));
      363 		call condition_interpreter_ (null (), null (), 0, 0, CI.mc_ptr, (CI.condition_name), CI.wc_ptr,
      364 		     CI.info_ptr);
      365 	     end;
      366 
      367 	go to SUBSTITUTE_ERROR_VALUE;
      368 
      369      end active_function_error_handler;
      370 
      371 /**** Handler for unexpected conditions during execution of the command,
      372*      active function or request line.  Certain conditions are ignored
      373*      (i.e., passed on to other handlers). */
      374 
      375 any_other_handler:
      376      procedure ();
      377 
      378 declare	conditionx		fixed bin (17);
      379 
      380 declare	1 CI			aligned like condition_info;
      381 
      382 	CI.version = condition_info_version_1;
      383 	call find_condition_info_ (null (), addr (CI), (0));
      384 
      385 	if length (CI.condition_name) > length ("command_")
      386 	then if substr (CI.condition_name, 1, length ("command_")) = "command_" then go to CONTINUE;
      387 
      388 	do conditionx = lbound (SPECIAL_CONDITIONS, 1) to hbound (SPECIAL_CONDITIONS, 1);
      389 
      390 	     if CI.condition_name = SPECIAL_CONDITIONS (conditionx) then go to CONTINUE;
      391 	end;
      392 
      393 	if return_value_ptr = null () | trace
      394 	then call condition_interpreter_ (null (), null (), 0, 0, CI.mc_ptr, (CI.condition_name), CI.wc_ptr,
      395 		CI.info_ptr);
      396 
      397 	if error_value_ptr ^= null ()
      398 	then go to SUBSTITUTE_ERROR_VALUE;
      399 	else go to EGRESS;
      400 
      401 CONTINUE:
      402 	call continue_to_signal_ ((0));
      403 
      404 	return;
      405 
      406      end any_other_handler;
      407 
      408 /**** Get argument count and active function return value for non-SSU case. */
      409 
      410 check_arguments:
      411      procedure (P_arg_list_ptr) options (non_quick);
      412 
      413 declare	P_arg_list_ptr		ptr parameter;
      414 
      415 	arg_list_ptr = P_arg_list_ptr;
      416 
      417 	call cu_$af_return_arg_rel (arg_count, return_value_ptr, return_value_max_len, status, arg_list_ptr);
      418 	if status = 0 then return;
      419 	if status = error_table_$not_act_fnc then return;
      420 
      421 	call com_err_ (status, MY_NAME (entrypoint), "Can't get argument count.");
      422 
      423 	go to EGRESS;
      424 
      425      end check_arguments;
      426 
      427 execute_string_command:
      428      procedure () options (non_quick);
      429 
      430 declare	arg_len			fixed bin (21),
      431 	arg_ptr			ptr,
      432 	argx			fixed bin (17),
      433 	control_string_len		fixed bin (21),
      434 	control_string_ptr		ptr,
      435 	parser			fixed bin (3),
      436 	saved_parser		fixed bin (3);
      437 
      438 declare	arg			char (arg_len) based (arg_ptr),
      439 	control_string		char (control_string_len) based (control_string_ptr);
      440 
      441 	if arg_count = 0 then call usage (COMMAND_USAGE);
      442 
      443 	abort_line = abort_line_mode (entrypoint);
      444 	execute = execute_mode (entrypoint);
      445 	inhibit_error = inhibit_error_mode (entrypoint);
      446 	parser = PARSER_WANTS_CONTROL_STRING;
      447 
      448 	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);
      449 
      450 	     call get_argument (argx);
      451 
      452 	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
      453 	     else if substr (arg, 1, min (1, length (arg))) = "-"
      454 	     then if arg = "-abort_line" | arg = "-abl" then abort_line = "1"b;
      455 		else if arg = "-brief" | arg = "-bf" then trace = "0"b;
      456 		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
      457 		else if arg = "-go" then execute = "1"b;
      458 		else if arg = "-inhibit_error" | arg = "-ihe" | arg = "-absentee" | arg = "-abs"
      459 		then inhibit_error = "1"b;
      460 		else if arg = "-long" | arg = "-lg" then trace = "1"b;
      461 		else if arg = "-no_abort_line" | arg = "-nabl" then abort_line = "0"b;
      462 		else if arg = "-no_go" | arg = "-nogo" then execute = "0"b;
      463 		else if arg = "-no_inhibit_error" | arg = "-nihe" | arg = "-interactive" | arg = "-ia"
      464 		then inhibit_error = "0"b;
      465 		else go to BADOPT;
      466 	     else parser = PARSER_FOUND_CONTROL_STRING;
      467 	end;
      468 
      469 	if parser = PARSER_WANTS_CONTROL_STRING
      470 	then do;
      471 		abort_line_mode (entrypoint) = abort_line;
      472 		execute_mode (entrypoint) = execute;
      473 		inhibit_error_mode (entrypoint) = inhibit_error;
      474 		trace_mode (entrypoint) = trace;
      475 		go to EGRESS;
      476 	     end;
      477 
      478 	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;
      479 
      480 	arg_offset = argx - 1;
      481 
      482 	call expand ();
      483 
      484 	return;
      485 
      486 execute_string_function:
      487      entry ();
      488 
      489 	inhibit_error = "0"b;
      490 	parser = PARSER_WANTS_CONTROL_STRING;
      491 	rescan_type = ATOMIC_ACTIVE_STRING;
      492 
      493 	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);
      494 
      495 	     call get_argument (argx);
      496 
      497 	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
      498 	     else if parser = PARSER_WANTS_ERROR_VALUE
      499 	     then do;
      500 		     error_value_len = arg_len;
      501 		     error_value_ptr = arg_ptr;
      502 		     parser = saved_parser;
      503 		end;
      504 	     else if substr (arg, 1, min (1, length (arg))) = "-"
      505 	     then if arg = "-brief" | arg = "-bf" then trace = "0"b;
      506 		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
      507 		else if arg = "-error_value" | arg = "-erv"
      508 		then do;
      509 			saved_parser = parser;
      510 			parser = PARSER_WANTS_ERROR_VALUE;
      511 		     end;
      512 		else if arg = "-inhibit_error" | arg = "-ihe" then inhibit_error = "1"b;
      513 		else if arg = "-long" | arg = "-lg" then trace = "1"b;
      514 		else if arg = "-no_inhibit_error" | arg = "-nihe" then inhibit_error = "0"b;
      515 		else if arg = "-no_rescan" | arg = "-nrsc" then rescan_type = ATOMIC_ACTIVE_STRING;
      516 		else if arg = "-rescan" | arg = "-rsc" then rescan_type = NORMAL_ACTIVE_STRING;
      517 		else if arg = "-rescan_tokens" | arg = "-rsct" then rescan_type = TOKENS_ONLY_ACTIVE_STRING;
      518 		else go to BADOPT;
      519 	     else parser = PARSER_FOUND_CONTROL_STRING;
      520 	end;
      521 
      522 	if parser = PARSER_WANTS_CONTROL_STRING then call usage (EXS_AF_USAGE);
      523 
      524 	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;
      525 
      526 	if error_value_ptr = null () & inhibit_error
      527 	then call error (error_table_$inconsistent, "-inhibit_error without -error_value");
      528 
      529 	if error_value_ptr ^= null () then inhibit_error = inhibit_error | inhibit_error_mode (entrypoint);
      530 
      531 	arg_offset = argx - 1;
      532 
      533 	call expand ();
      534 
      535 	return;
      536 
      537 execute_string_command_error:
      538      entry ();
      539 
      540 	if sci_ptr = null ()
      541 	then do;
      542 		if status = 100 | ^trace then return;
      543 	     end;
      544 	else if status = ssu_et_$null_request_line then return;
      545 	else if status = ssu_et_$subsystem_aborted then call ssu_$abort_subsystem (sci_ptr);
      546 	else if status = ssu_et_$request_line_aborted & ^trace
      547 	then if abort_line
      548 	     then call ssu_$abort_line (sci_ptr);
      549 	     else return;
      550 
      551 	if abort_line then call error (status, "Executing ^a.", requote_string_ (command));
      552 
      553 	call warn (status, "Executing ^a.", requote_string_ (command));
      554 
      555 	return;
      556 
      557 execute_string_function_error:
      558      entry ();
      559 
      560 	if error_value_ptr = null ()
      561 	then do;
      562 		if status = error_table_$command_line_overflow
      563 		then do;
      564 			call warn (status, "Result truncated to ^d characters^[ evaluating ^a^].",
      565 			     return_value_max_len, trace, requote_string_ (command));
      566 			return;
      567 		     end;
      568 
      569 		if sci_ptr ^= null ()
      570 		then if status = ssu_et_$subsystem_aborted then call ssu_$abort_subsystem (sci_ptr);
      571 		     else if status = ssu_et_$request_line_aborted & ^trace then call ssu_$abort_line (sci_ptr);
      572 
      573 		if trace then call error (status, "Evaluating ^a.", requote_string_ (command));
      574 
      575 		return;
      576 	     end;
      577 
      578 expand_error_value:
      579      entry ();
      580 
      581 	arg_len = error_value_len;
      582 	arg_ptr = error_value_ptr;
      583 
      584 	expansion_max_len = return_value_max_len;
      585 	expansion_ptr = return_value_ptr;
      586 
      587 	call expand ();
      588 
      589 	return;
      590 
      591 /**** This case is used only by the substitute_arguments command, and
      592*      accepts fewer control arguments than the execute_string cases.  The
      593*      substitute_arguments command and active function have only the
      594*      long/brief mode, since the other modes relate to execution of the
      595*      expansion. */
      596 
      597 substitute_args_command:
      598      entry ();
      599 
      600 	if arg_count = 0 then call usage (COMMAND_USAGE);
      601 
      602 	parser = PARSER_WANTS_CONTROL_STRING;
      603 
      604 	do argx = 1 to arg_count while (parser ^= PARSER_FOUND_CONTROL_STRING);
      605 
      606 	     call get_argument (argx);
      607 
      608 	     if parser = PARSER_EXPLICIT_CONTROL_STRING then parser = PARSER_FOUND_CONTROL_STRING;
      609 	     else if substr (arg, 1, min (1, length (arg))) = "-"
      610 	     then if arg = "-brief" | arg = "-bf" then trace = "0"b;
      611 		else if arg = "-control_string" | arg = "-cs" then parser = PARSER_EXPLICIT_CONTROL_STRING;
      612 		else if arg = "-long" | arg = "-lg" then trace = "1"b;
      613 		else go to BADOPT;
      614 	     else parser = PARSER_FOUND_CONTROL_STRING;
      615 	end;
      616 
      617 	if parser = PARSER_WANTS_CONTROL_STRING
      618 	then do;
      619 		trace_mode (entrypoint) = trace;
      620 		go to EGRESS;
      621 	     end;
      622 
      623 	if parser ^= PARSER_FOUND_CONTROL_STRING then go to NOARG;
      624 
      625 	arg_offset = argx - 1;
      626 
      627 	call expand ();
      628 
      629 	call ioa_ ("^a", expansion);
      630 
      631 	return;
      632 
      633 /**** This case is very simple.  No control arguments are accepted.  The
      634*      command processor has already allocated a large but non-expandable
      635*      buffer for the expanded string.  We check that we have at least the
      636*      one required argument, and if so, we set up the environment for
      637*      expansion appropriately, do the expansion, and return. */
      638 
      639 substitute_args_function:
      640      entry ();
      641 
      642 	if arg_count = 0 then call usage (SBAG_AF_USAGE);
      643 
      644 	arg_offset, argx = 1;
      645 
      646 	call get_argument (argx);
      647 
      648 	expansion_max_len = return_value_max_len;
      649 	expansion_ptr = return_value_ptr;
      650 
      651 	call expand ();
      652 
      653 	return;
      654 
      655 BADOPT:
      656 	call error (error_table_$badopt, "^a", requote_string_ (arg));
      657 
      658 NOARG:
      659 	call error (error_table_$noarg, "Following ^a.", requote_string_ (arg));
      660 
      661 error:
      662 	procedure () options (variable);
      663 
      664 declare	arg_list_ptr		ptr,
      665 	buffer			char (256),
      666 	buffer_used		fixed bin (21),
      667 	fatal			bit (1) aligned,
      668 	status_ptr		ptr;
      669 
      670 declare	buffer_overlay		char (buffer_used) based (addr (buffer)),
      671 	status			fixed bin (35) based (status_ptr);
      672 
      673 	     fatal = "1"b;
      674 
      675 	     go to COMMON;
      676 
      677 warn:
      678 	entry () options (variable);
      679 
      680 	     fatal = "0"b;
      681 
      682 COMMON:
      683 	     arg_list_ptr = cu_$arg_list_ptr ();
      684 	     call cu_$arg_ptr_rel (1, status_ptr, (0), (0), arg_list_ptr);
      685 	     call ioa_$general_rs (arg_list_ptr, 2, 3, buffer, buffer_used, "0"b, "0"b);
      686 
      687 	     if sci_ptr = null ()
      688 	     then do;
      689 		     if return_value_ptr = null ()
      690 		     then call com_err_ (status, MY_NAME (entrypoint), "^a", buffer_overlay);
      691 		     else call active_fnc_err_ (status, MY_NAME (entrypoint), "^a", buffer_overlay);
      692 		     if fatal then go to EGRESS;
      693 		end;
      694 	     else if fatal then call ssu_$abort_line (sci_ptr, status, "^a", buffer_overlay);
      695 	     else call ssu_$print_message (sci_ptr, status, "^a", buffer_overlay);
      696 
      697 	     return;
      698 
      699 	end error;
      700 
      701 /**** Expand the control string into the expansion.  For simplicity,
      702*      expansion is a varying character string so that PL/I concatenation
      703*      can be used.  The substitution constructs are mostly recognized a
      704*      character at a time by indexing into lists of the characters which
      705*      are presently valid and dispatching on the position of the current
      706*      character in the list.  This is very efficient. */
      707 
      708 expand:
      709 	procedure ();
      710 
      711 declare	buffer_overflow		bit (1) aligned,
      712 	command_name		char (72) varying,
      713 	construct_pos		fixed bin (21),
      714 	control_string_pos		fixed bin (21),
      715 	nstring			picture "zzzz9",
      716 	from_sw			bit (1) aligned,
      717 	parm_count		fixed bin (17),
      718 	quote_multiplier		fixed bin (21),
      719 	quote_scan_pos		fixed bin (21),
      720 	requote_last		bit (1) aligned,
      721 	requote_sw		fixed bin (2),
      722 	skip			fixed bin (21),
      723 	string_len		fixed bin (21),
      724 	string_ptr		ptr;
      725 
      726 declare	construct			char (control_string_pos - construct_pos)
      727 				based (addcharno (addr (control_string), construct_pos)),
      728 	string			char (string_len) based (string_ptr);
      729 
      730 	     buffer_overflow, from_sw = "0"b;
      731 	     control_string_len = arg_len;
      732 	     control_string_pos, quote_scan_pos = 0;
      733 	     control_string_ptr = arg_ptr;
      734 	     expansion = "";
      735 	     parm_count = arg_count - arg_offset;
      736 	     quote_multiplier = 1;
      737 	     requote_last = "0"b;
      738 	     requote_sw = NO_QUOTE_MODIFIER;
      739 
      740 	     do while (control_string_pos < length (control_string));
      741 
      742 		string_len = index (substr (control_string, control_string_pos + 1), AMPERSAND) - 1;
      743 		if string_len < 0 then string_len = length (control_string) - control_string_pos;
      744 
      745 		if string_len > 0
      746 		then do;
      747 			string_ptr = addcharno (control_string_ptr, control_string_pos);
      748 			call add_string ();
      749 			control_string_pos = control_string_pos + string_len;
      750 		     end;
      751 
      752 		if control_string_pos >= length (control_string) then go to EXPANDED;
      753 
      754 		construct_pos = control_string_pos;
      755 		control_string_pos = control_string_pos + length (AMPERSAND) + 1;
      756 
      757 		if control_string_pos > length (control_string) then go to END;
      758 
      759 		argx = index ("0123456789!(&&cfnqr", substr (control_string, control_string_pos, 1)) - 1;
      760 		go to DISPATCH (argx);
      761 
      762 DISPATCH (-1):					/* illegal -- character not in dispatch string */
      763 		call illegal (ILLEGAL_CHARACTER);
      764 
      765 DISPATCH (0):					/* A digit has been found.  The number of the */
      766 DISPATCH (1):					/* parameter to be substituted is in argx. */
      767 DISPATCH (2):					/* Here we handle the from_sw processing, and */
      768 DISPATCH (3):					/* the requote_sw processing is handled in */
      769 DISPATCH (4):					/* expand_arg. */
      770 DISPATCH (5):
      771 DISPATCH (6):
      772 DISPATCH (7):
      773 DISPATCH (8):
      774 DISPATCH (9):
      775 		if from_sw
      776 		then do;
      777 			if argx = 0 then argx = 1;	/* &f0 => &f1 */
      778 
      779 			from_sw = "0"b;		/* Reset for next construct */
      780 
      781 			do argx = argx to parm_count;
      782 
      783 			     call expand_arg ();
      784 
      785 			     if argx < parm_count
      786 			     then do;
      787 				     string_len = length (BLANK);
      788 				     string_ptr = addr (BLANK);
      789 				     call add_string ();
      790 				end;
      791 			end;
      792 		     end;
      793 		else if argx <= parm_count then call expand_arg ();
      794 
      795 		requote_sw = NO_QUOTE_MODIFIER;	/* Reset for next expansion */
      796 
      797 		go to SCAN_NEXT;
      798 
      799 DISPATCH (10):					/* &! -- Substitute a unique string */
      800 		if unique = "" then unique = unique_chars_ (""b);
      801 		string_len = length (unique);
      802 		string_ptr = addr (unique);
      803 		call add_string ();
      804 		go to SCAN_NEXT;
      805 
      806 DISPATCH (11):					/* &( -- Begin a parenthesized parameter index */
      807 		string_len = index (substr (control_string, control_string_pos + 1), ")") - 1;
      808 		if string_len < 0 then call illegal (ILLEGAL_UNCLOSED);
      809 		string_ptr = addcharno (control_string_ptr, control_string_pos);
      810 		control_string_pos = control_string_pos + string_len + length (")");
      811 
      812 		string_len = length (rtrim (string, WHITE));
      813 		if string_len = 0 then call illegal (ILLEGAL_INTEGER);
      814 
      815 		skip = verify (string, WHITE) - 1;
      816 		string_len = string_len - skip;
      817 		string_ptr = addcharno (string_ptr, skip);
      818 		if verify (string, "0123456789") ^= 0 then call illegal (ILLEGAL_INTEGER);
      819 		if length (ltrim (string, "0")) > 5
      820 		then argx = parm_count + 1;
      821 		else argx = binary (string, 17, 0);
      822 
      823 		go to DISPATCH (0);
      824 
      825 DISPATCH (12):					/* && -- A literal ampersand */
      826 		string_len = length (AMPERSAND);
      827 		string_ptr = addr (AMPERSAND);
      828 		call add_string ();
      829 
      830 		go to SCAN_NEXT;
      831 
      832 DISPATCH (13):					/* &f&, &q&, &qf&, &r&, &rf& -- The last parameter */
      833 		if control_string_pos + length ("n") > length (control_string) then go to END;
      834 		control_string_pos = control_string_pos + length ("n");
      835 		if substr (control_string, control_string_pos, length ("n")) ^= "n"
      836 		then call illegal (ILLEGAL_CHARACTER);
      837 
      838 		if ^from_sw
      839 		then do;
      840 			call warn (0, NO_FROM_WARNING, requote_sw = PROTECT_QUOTES_MODIFIER,
      841 			     requote_string_ (construct), return_value_ptr ^= null () & sci_ptr = null ());
      842 			from_sw = "1"b;
      843 		     end;
      844 
      845 		argx = parm_count;
      846 
      847 		go to DISPATCH (0);
      848 
      849 DISPATCH (14):					/* &c -- begins &control_string */
      850 		control_string_pos = control_string_pos + length ("ontrol_string");
      851 		if control_string_pos > length (control_string) then call illegal (ILLEGAL_KEYWORD);
      852 		if substr (control_string, construct_pos + 2, length ("control_string")) ^= "control_string"
      853 		then call illegal (ILLEGAL_KEYWORD);
      854 
      855 		argx = 0;
      856 		requote_sw = PROTECT_QUOTES_MODIFIER;
      857 
      858 		go to DISPATCH (0);
      859 
      860 DISPATCH (15):					/* &f, &qf and &rf -- Substitute a range of parameters */
      861 		from_sw = "1"b;
      862 
      863 		if control_string_pos >= length (control_string) then go to END;
      864 		control_string_pos = control_string_pos + 1;
      865 
      866 		argx = index ("01234567899((&", substr (control_string, control_string_pos, 1)) - 1;
      867 		go to DISPATCH (argx);
      868 
      869 DISPATCH (16):					/* &n -- Substitute the number of optional arguments */
      870 		nstring = parm_count;
      871 		string_len = verify (nstring, BLANK) - 1;
      872 		string_ptr = addcharno (addr (nstring), string_len);
      873 		string_len = length (nstring) - string_len;
      874 		call add_string ();
      875 
      876 		go to SCAN_NEXT;
      877 
      878 DISPATCH (17):					/* &q -- Protect quotes in the parameter */
      879 		requote_sw = PROTECT_QUOTES_MODIFIER;
      880 		go to AFTER_QUOTE_MODIFIER;
      881 
      882 DISPATCH (18):					/* &r -- Requote the parameter */
      883 		requote_sw = REQUOTE_MODIFIER;
      884 
      885 AFTER_QUOTE_MODIFIER:
      886 		if control_string_pos >= length (control_string) then go to END;
      887 		control_string_pos = control_string_pos + 1;
      888 
      889 		argx = index ("01234567899((&&f", substr (control_string, control_string_pos, 1)) - 1;
      890 		go to DISPATCH (argx);
      891 
      892 SCAN_NEXT:
      893 	     end;
      894 
      895 
      896 /**** Argument substitution is completed. */
      897 
      898 EXPANDED:
      899 	     if trace
      900 	     then do;
      901 		     if sci_ptr = null ()
      902 		     then command_name = MY_NAME (entrypoint);
      903 		     else command_name = ssu_$get_subsystem_and_request_name (sci_ptr);
      904 		     call ioa_$ioa_switch (iox_$error_output, "^[[^a^[ -error_value^]]^;^a^s^]: (^d) ^a",
      905 			return_value_ptr ^= null (), command_name,
      906 			return_value_ptr = expansion_ptr & entrypoint = EXECUTE_ENTRY, length (command),
      907 			requote_string_ (command));
      908 		end;
      909 
      910 	     return;
      911 
      912 
      913 /**** The end of the string beging expanded was found after an ampersand
      914*      was encountered but before a valid substitution construct was
      915*      completed. */
      916 
      917 END:
      918 	     if entrypoint = EXECUTE_ENTRY & expansion_ptr = return_value_ptr
      919 	     then call illegal (ILLEGAL_END_ERROR_VALUE);
      920 	     else call illegal (ILLEGAL_END_CONTROL_STRING);
      921 
      922 /**** These operations are gathered in a subroutine to reduce code size in
      923*      exchange for a very slight performance penalty.  The overlay is used
      924*      to add QUOTE characters to the string in order to avoid a stack
      925*      extension. */
      926 
      927 add_quotes:
      928 	     procedure ();
      929 
      930 declare	old_len			fixed bin (21);
      931 
      932 declare	1 expansion_overlay		aligned based (expansion_ptr),
      933 	  2 len			fixed bin (21),
      934 	  2 str			char (0 refer (expansion_overlay.len));
      935 
      936 		call check_buffer ();
      937 
      938 		old_len = expansion_overlay.len;
      939 		expansion_overlay.len = expansion_overlay.len + string_len;
      940 		substr (expansion_overlay.str, old_len + 1, string_len) = copy (QUOTE, string_len);
      941 
      942 		if buffer_overflow then go to EXPANDED;
      943 
      944 		return;
      945 
      946 add_string:
      947 	     entry ();
      948 
      949 		call check_buffer ();
      950 
      951 		expansion = expansion || string;
      952 
      953 		if buffer_overflow then go to EXPANDED;
      954 
      955 		return;
      956 
      957 	     end add_quotes;
      958 
      959 /**** The expansion has become too large for the expansion buffer.
      960*      Allocate a bigger buffer, and free the old one if it was allocated.
      961*      The initial buffer is automatic, and must be not be freed. */
      962 
      963 allocate_buffer:
      964 	     procedure ();
      965 
      966 declare	new_buffer_ptr		ptr,
      967 	old_buffer_max_len		fixed bin (21);
      968 
      969 		new_buffer_ptr = null ();
      970 		old_buffer_max_len = allocated_buffer_max_len;
      971 
      972 		on cleanup
      973 		     begin;
      974 			if new_buffer_ptr ^= null () & new_buffer_ptr ^= allocated_buffer_ptr
      975 			then free new_buffer_ptr -> allocated_buffer in (system_area);
      976 		     end;
      977 
      978 		on area go to AREA_HANDLER;
      979 
      980 		allocated_buffer_max_len =
      981 		     maxlength (expansion) + string_len + length (control_string) + 8 * parm_count;
      982 
      983 		allocate allocated_buffer in (system_area) set (new_buffer_ptr);
      984 
      985 		new_buffer_ptr -> allocated_buffer = expansion;
      986 		expansion_max_len = allocated_buffer_max_len;
      987 
      988 		if allocated_buffer_ptr ^= null ()
      989 		then do;
      990 			allocated_buffer_max_len = old_buffer_max_len;
      991 			free allocated_buffer in (system_area);
      992 		     end;
      993 
      994 		allocated_buffer_ptr, expansion_ptr = new_buffer_ptr;
      995 
      996 		return;
      997 
      998 AREA_HANDLER:
      999 		call error (0, "Can't allocate a buffer large enough to hold the expanded control string.");
     1000 
     1001 	     end allocate_buffer;
     1002 
     1003 /**** Ensure that there is sufficient space in the expansion buffer to
     1004*      permit the addition of string_len characters to the buffer.  If there
     1005*      is not, grow the buffer if possible.  The case where we can't try to
     1006*      grow the buffer is when the buffer is the active function return
     1007*      value.  Since the command processor can't accept a bigger value, we
     1008*      announce that the string was truncated and set string_len to what
     1009*      will actually fit.  Setting buffer_overflow will cause termination of
     1010*      the expansion after the characters have been appended.  Note that
     1011*      ssu_$print_message will only return for active functions after the
     1012*      user issues "start", but not for the subsystem active request case.
     1013*      The only cases where expansion is directlyt overlayed on the return
     1014*      value are the do/sbag active function and the -error_value for
     1015*      execute_string. */
     1016 
     1017 check_buffer:
     1018 	     procedure ();
     1019 
     1020 		if length (string) ^= 0 then requote_last = "0"b;
     1021 
     1022 		if length (expansion) + length (string) <= maxlength (expansion) then return;
     1023 
     1024 		if expansion_ptr = return_value_ptr
     1025 		then do;
     1026 			buffer_overflow = "1"b;
     1027 			string_len = maxlength (expansion) - length (expansion);
     1028 			call warn (error_table_$command_line_overflow, TRUNCATION_WARNING, expansion_max_len,
     1029 			     entrypoint = EXECUTE_ENTRY, return_value_ptr ^= null () & sci_ptr = null ());
     1030 			return;
     1031 		     end;
     1032 
     1033 		call allocate_buffer ();		/* Make it bigger */
     1034 
     1035 		return;
     1036 
     1037 	     end check_buffer;
     1038 
     1039 /**** Get the substitution parameter which is argx after the control
     1040*      string, and append it to the expansion with appropriate quote
     1041*      processing.  If no quote modifier was specified, then no special
     1042*      processing is required.  Otherwise, the string up to this point must
     1043*      be scanned to determine the current quote level.  Then the parameter
     1044*      is appended with optional requotinq and quotes doubled according to
     1045*      the quote level. */
     1046 
     1047 expand_arg:
     1048 	     procedure ();
     1049 
     1050 declare	arg_pos			fixed bin (21);
     1051 
     1052 		call get_argument (argx + arg_offset);
     1053 
     1054 		if requote_sw = NO_QUOTE_MODIFIER
     1055 		then do;
     1056 			string_len = arg_len;
     1057 			string_ptr = arg_ptr;
     1058 			call add_string ();
     1059 			return;
     1060 		     end;
     1061 
     1062 		do while (quote_scan_pos < length (expansion));
     1063 
     1064 		     string_len = index (substr (expansion, quote_scan_pos + 1), QUOTE) - 1;
     1065 		     if string_len < 0 then string_len = length (expansion) - quote_scan_pos;
     1066 
     1067 		     quote_scan_pos = quote_scan_pos + string_len;
     1068 		     if quote_scan_pos < length (expansion)
     1069 		     then do;
     1070 			     string_len = verify (substr (expansion, quote_scan_pos + 1), QUOTE) - 1;
     1071 			     if string_len < 0 then string_len = length (expansion) - quote_scan_pos;
     1072 			     quote_scan_pos = quote_scan_pos + string_len;
     1073 
     1074 			     if mod (string_len, quote_multiplier) = 0
     1075 			     then do while (mod (string_len, 2 * quote_multiplier) ^= 0);
     1076 				     string_len = string_len - quote_multiplier;
     1077 				     quote_multiplier = 2 * quote_multiplier;
     1078 				end;
     1079 			     else do while (string_len ^= 0);
     1080 				     quote_multiplier = divide (quote_multiplier, 2, 21, 0);
     1081 				     string_len = mod (string_len, quote_multiplier);
     1082 				end;
     1083 			end;
     1084 		end;
     1085 
     1086 		if requote_sw = REQUOTE_MODIFIER
     1087 		then do;
     1088 			if requote_last
     1089 			then expansion = substr (expansion, 1, length (expansion) - quote_multiplier);
     1090 			else do;
     1091 				string_len = quote_multiplier;
     1092 				call add_quotes ();
     1093 			     end;
     1094 			quote_multiplier = 2 * quote_multiplier;
     1095 		     end;
     1096 
     1097 		if quote_multiplier = 1
     1098 		then do;
     1099 			string_len = arg_len;
     1100 			string_ptr = arg_ptr;
     1101 			call add_string ();
     1102 		     end;
     1103 		else do;
     1104 			arg_pos = 0;
     1105 
     1106 			do while (arg_pos < length (arg));
     1107 
     1108 			     string_len = index (substr (arg, arg_pos + 1), QUOTE) - 1;
     1109 			     if string_len < 0 then string_len = length (arg) - arg_pos;
     1110 			     if string_len > 0
     1111 			     then do;
     1112 				     string_ptr = addcharno (addr (arg), arg_pos);
     1113 				     call add_string ();
     1114 				     arg_pos = arg_pos + string_len;
     1115 				end;
     1116 
     1117 			     if arg_pos < length (arg)
     1118 			     then do;
     1119 				     string_len = verify (substr (arg, arg_pos + 1), QUOTE) - 1;
     1120 				     if string_len < 0 then string_len = length (arg) - arg_pos;
     1121 				     arg_pos = arg_pos + string_len;
     1122 
     1123 				     string_len = string_len * quote_multiplier;
     1124 				     call add_quotes ();
     1125 				end;
     1126 			end;
     1127 		     end;
     1128 
     1129 		if requote_sw = REQUOTE_MODIFIER
     1130 		then do;
     1131 			string_len, quote_multiplier = divide (quote_multiplier, 2, 17, 0);
     1132 			call add_quotes ();
     1133 			requote_last = "1"b;	/* Remember ending quotes in case of &r1&r2 */
     1134 		     end;
     1135 
     1136 		quote_scan_pos = length (expansion);	/* Don't let protected expansion affect quote depth */
     1137 
     1138 		return;
     1139 
     1140 	     end expand_arg;
     1141 
     1142 /**** This routine is invoked if an illegal construct is found.  To keep
     1143*      the stack frame from becoming unreasonably large, the various control
     1144*      strings are stored in an array so that they can be passed by
     1145*      reference. */
     1146 
     1147 illegal:
     1148 	     procedure (reason);
     1149 
     1150 declare	reason			fixed bin (3) parameter;
     1151 
     1152 		if control_string_pos > length (control_string) then control_string_pos = length (control_string);
     1153 
     1154 		expansion_buffer = requote_string_ (construct);
     1155 
     1156 		call error (0, REASONS (reason), expansion_buffer);
     1157 
     1158 	     end illegal;
     1159 
     1160 	end expand;
     1161 
     1162 /**** Get an argument from the argument list.  Note that SSU reserves the
     1163*      right to change the argument list format (the entry is replaceable),
     1164*      so we can't obtain a pointer to the SSU arglist and use the cu_
     1165*      entrypoints. */
     1166 
     1167 get_argument:
     1168 	procedure (P_argx);
     1169 
     1170 declare	P_argx			fixed bin (17) parameter;
     1171 
     1172 	     if sci_ptr = null ()
     1173 	     then do;
     1174 		     call cu_$arg_ptr_rel (P_argx, arg_ptr, arg_len, status, arg_list_ptr);
     1175 		     if status ^= 0 then call error (status, "Can't get argument #^d.", P_argx);
     1176 		end;
     1177 	     else call ssu_$arg_ptr (sci_ptr, P_argx, arg_ptr, arg_len);
     1178 
     1179 	     return;
     1180 
     1181 	end get_argument;
     1182 
     1183 /**** An error in usage has been detected, probably a missing control
     1184*      string.  This internal procedure replaces ssu_$abort_line for this
     1185*      purpose because the standard for usage messages for commands and
     1186*      active functions is to call the appropriate $suppress_name
     1187*      entrypoint.  It also permits the short names to be used in the usage
     1188*      messages for the command and active function cases.  For the
     1189*      subsystem cases, the standard action of ssu_$abort_line is used,
     1190*      because it is desirable to give the subsystem name.  Unfortunately,
     1191*      at this writing there is no easy way to get the short name of the
     1192*      request for use in the error message. */
     1193 
     1194 usage:
     1195 	procedure (usage_string);
     1196 
     1197 declare	usage_string		char (*) parameter;
     1198 
     1199 	     expansion_buffer = "Usage:  ";
     1200 	     if return_value_ptr ^= null () then expansion_buffer = expansion_buffer || "[";
     1201 	     if sci_ptr = null ()
     1202 	     then expansion_buffer = expansion_buffer || MY_SHORT_NAME (entrypoint);
     1203 	     else expansion_buffer = expansion_buffer || rtrim (ssu_$get_request_name (sci_ptr));
     1204 	     expansion_buffer = expansion_buffer || BLANK;
     1205 	     expansion_buffer = expansion_buffer || usage_string;
     1206 	     if return_value_ptr ^= null () then expansion_buffer = expansion_buffer || "]";
     1207 
     1208 	     if sci_ptr = null ()
     1209 	     then if return_value_ptr = null ()
     1210 		then call com_err_$suppress_name (0, MY_NAME (entrypoint), "^a", expansion_buffer);
     1211 		else call active_fnc_err_$suppress_name (0, MY_NAME (entrypoint), "^a", expansion_buffer);
     1212 	     else call ssu_$abort_line (sci_ptr, 0, "^a", expansion_buffer);
     1213 
     1214 	     go to EGRESS;
     1215 
     1216 	end usage;
     1217 
     1218      end execute_string_command;
     1219 
     1220      end do;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/15/86  1407.9  do.pl1                            >spec>install>1186>do.pl1
213          1    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
215          2    09/22/80  1256.7  cp_active_string_types.incl.pl1   >ldd>include>cp_active_string_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AMPERSAND                       000462 constant        char(1)                  initial unaligned dcl 106 set ref 742 755 825 827
ATOMIC_ACTIVE_STRING                   constant        fixed bin(17,0)          initial dcl 2-6 ref 491 515
BLANK                           000463 constant        char(1)                  initial unaligned dcl 106 set ref 787 788 871 1204
CI                              000102 automatic       structure                level 1 dcl 380 in procedure "any_other_handler" set
                                                                                  ref 383 383
CI                              000106 automatic       structure                level 1 dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 362 362
COMMAND_USAGE                   000142 constant        char(39)                 initial unaligned dcl 156 set ref 441* 600*
DO_ENTRY                               constant        fixed bin(2,0)           initial dcl 112 ref 219 246
EXECUTE_ENTRY                          constant        fixed bin(2,0)           initial dcl 112 ref 227 253 904 917 1028
EXS_AF_USAGE                    000130 constant        char(37)                 initial unaligned dcl 156 set ref 522*
ILLEGAL_CHARACTER                      constant        fixed bin(3,0)           initial dcl 118 set ref 762* 835*
ILLEGAL_END_CONTROL_STRING             constant        fixed bin(3,0)           initial dcl 118 set ref 920*
ILLEGAL_END_ERROR_VALUE                constant        fixed bin(3,0)           initial dcl 118 set ref 917*
ILLEGAL_INTEGER                        constant        fixed bin(3,0)           initial dcl 118 set ref 813* 818*
ILLEGAL_KEYWORD                        constant        fixed bin(3,0)           initial dcl 118 set ref 851* 852*
ILLEGAL_UNCLOSED                000456 constant        fixed bin(3,0)           initial dcl 118 set ref 808*
MY_NAME                         000437 constant        char(20)                 initial array unaligned dcl 133 set ref 421* 689*
                                                                                  691* 901 1208* 1211*
MY_SHORT_NAME                   000431 constant        varying char(4)          initial array dcl 133 ref 1201
NORMAL_ACTIVE_STRING                   constant        fixed bin(17,0)          initial dcl 2-6 ref 516
NO_FROM_WARNING                 000072 constant        char(95)                 initial unaligned dcl 162 set ref 840*
NO_QUOTE_MODIFIER                      constant        fixed bin(2,0)           initial dcl 127 ref 738 795 1054
PARSER_EXPLICIT_CONTROL_STRING         constant        fixed bin(3,0)           initial dcl 137 ref 452 456 497 506 608 611
PARSER_FOUND_CONTROL_STRING            constant        fixed bin(3,0)           initial dcl 137 ref 448 452 466 478 493 497 519 524
                                                                                  604 608 614 623
PARSER_WANTS_CONTROL_STRING            constant        fixed bin(3,0)           initial dcl 137 ref 446 469 490 522 602 617
PARSER_WANTS_ERROR_VALUE               constant        fixed bin(3,0)           initial dcl 137 ref 498 510
PROTECT_QUOTES_MODIFIER                constant        fixed bin(2,0)           initial dcl 127 ref 840 856 878
P_arg_list_ptr                         parameter       pointer                  dcl 413 ref 410 415
P_argx                                 parameter       fixed bin(17,0)          dcl 1170 set ref 1167 1174* 1175* 1177*
P_info_ptr                             parameter       pointer                  dcl 64 ref 243 250 257
P_sci_ptr                              parameter       pointer                  dcl 64 ref 243 250 257 262
QUOTE                                  constant        char(1)                  initial unaligned dcl 106 ref 940 1064 1070 1108
                                                                                  1119
REASONS                         000217 constant        varying char(85)         initial array dcl 145 set ref 1156*
REQUOTE_MODIFIER                       constant        fixed bin(2,0)           initial dcl 127 ref 882 1086 1129
SBAG_AF_USAGE                   000122 constant        char(21)                 initial unaligned dcl 156 set ref 642*
SPECIAL_CONDITIONS              000154 constant        varying char(24)         initial array dcl 153 ref 388 388 390
SUBSTITUTE_ENTRY                       constant        fixed bin(2,0)           initial dcl 112 ref 236 260
TOKENS_ONLY_ACTIVE_STRING              constant        fixed bin(17,0)          initial dcl 2-6 ref 517
TRUNCATION_WARNING              000032 constant        char(127)                initial unaligned dcl 166 set ref 1028*
WHITE                           000460 constant        char(5)                  initial unaligned dcl 106 ref 812 815
abort_line                      000122 automatic       bit(1)                   dcl 73 set ref 443* 453* 461* 471 546 551
abort_line_mode                 000010 internal static bit(1)                   initial array dcl 101 set ref 443 471*
active_fnc_err_                 000044 constant        entry                    external dcl 183 ref 691
active_fnc_err_$suppress_name   000046 constant        entry                    external dcl 183 ref 1211
active_function_error           000100 stack reference condition                dcl 70 ref 311 329 337 343
addcharno                                              builtin function         dcl 67 ref 747 809 817 840 872 1112 1154
addr                                                   builtin function         dcl 67 ref 273 298 298 298 298 298 298 300 300 300
                                                                                  300 300 300 333 335 362 362 383 383 551 553 564
                                                                                  573 689 691 694 695 788 802 827 840 872 904 904
                                                                                  904 1112 1154
addwordno                                              builtin function         dcl 67 ref 298 298 298 298 300 300 300 300 333 335
                                                                                  551 553 564 573 904 904 904
allocated_buffer                       based           varying char             dcl 95 set ref 279 314 974 983 985* 991
allocated_buffer_max_len        000123 automatic       fixed bin(21,0)          dcl 73 set ref 269* 279 314 970 974 980* 983 985 986
                                                                                  990* 991
allocated_buffer_ptr            000124 automatic       pointer                  dcl 73 set ref 271* 279 279 314 314 974 988 991 994*
any_other                       000106 stack reference condition                dcl 70 ref 296 302 311 330 337 343
area                            000000 stack reference condition                dcl 70 ref 978
arg                                    based           char                     unaligned dcl 438 set ref 453 453 453 453 455 455
                                                                                  456 456 457 458 458 458 458 460 460 461 461 462
                                                                                  462 463 463 463 463 504 504 504 504 506 506 507
                                                                                  507 512 512 513 513 514 514 515 515 516 516 517
                                                                                  517 609 609 609 609 611 611 612 612 655* 658* 1106
                                                                                  1108 1109 1112 1117 1119 1120
arg_count                       000126 automatic       fixed bin(17,0)          dcl 73 set ref 284* 417* 441 448 493 600 604 642 735
arg_len                         000100 automatic       fixed bin(21,0)          dcl 430 set ref 453 453 453 453 455 455 456 456 457
                                                                                  458 458 458 458 460 460 461 461 462 462 463 463
                                                                                  463 463 500 504 504 504 504 506 506 507 507 512
                                                                                  512 513 513 514 514 515 515 516 516 517 517 581*
                                                                                  609 609 609 609 611 611 612 612 655 655 658 658
                                                                                  731 1056 1099 1106 1108 1109 1112 1117 1119 1120
                                                                                  1174* 1177*
arg_list_ptr                    000100 automatic       pointer                  dcl 664 in procedure "error" set ref 682* 684* 685*
arg_list_ptr                    000130 automatic       pointer                  dcl 73 in procedure "do" set ref 271* 415* 417*
                                                                                  1174*
arg_offset                      000132 automatic       fixed bin(17,0)          dcl 73 set ref 480* 531* 625* 644* 735 1052
arg_pos                         000214 automatic       fixed bin(21,0)          dcl 1050 set ref 1104* 1106 1108 1109 1112 1114*
                                                                                  1114 1117 1119 1120 1121* 1121
arg_ptr                         000102 automatic       pointer                  dcl 430 set ref 453 453 453 453 455 455 456 456 457
                                                                                  458 458 458 458 460 460 461 461 462 462 463 463
                                                                                  463 463 501 504 504 504 504 506 506 507 507 512
                                                                                  512 513 513 514 514 515 515 516 516 517 517 582*
                                                                                  609 609 609 609 611 611 612 612 655 658 733 1057
                                                                                  1100 1106 1108 1109 1112 1117 1119 1120 1174*
                                                                                  1177*
argx                            000104 automatic       fixed bin(17,0)          dcl 430 set ref 448* 450* 480 493* 495* 531 604*
                                                                                  606* 625 644* 646* 759* 760 777 777* 781* 781*
                                                                                  785* 793 819* 821* 845* 855* 866* 867 889* 890
                                                                                  1052
binary                                                 builtin function         dcl 67 ref 821
buffer                          000102 automatic       char(256)                unaligned dcl 664 set ref 685* 689 691 694 695
buffer_overflow                 000124 automatic       bit(1)                   dcl 711 set ref 730* 942 953 1026*
buffer_overlay                         based           char                     unaligned dcl 670 set ref 689* 691* 694* 695*
buffer_used                     000202 automatic       fixed bin(21,0)          dcl 664 set ref 685* 689 689 691 691 694 694 695 695
cleanup                         000114 stack reference condition                dcl 70 ref 277 972
com_err_                        000050 constant        entry                    external dcl 183 ref 421 689
com_err_$suppress_name          000052 constant        entry                    external dcl 183 ref 1208
command                                based           char                     unaligned dcl 95 set ref 298 298 298 298 300 300 300
                                                                                  300 333* 335* 551* 553* 564* 573* 904 904 904*
command_name                    000125 automatic       varying char(72)         dcl 711 set ref 901* 903* 904*
condition_info                         based           structure                level 1 dcl 1-14
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 1-30 ref 361 382
condition_interpreter_          000054 constant        entry                    external dcl 183 ref 363 393
condition_name            3     000102 automatic       varying char(32)         level 2 in structure "CI" dcl 380 in procedure
                                                                                  "any_other_handler" set ref 385 385 390 393
condition_name            3     000106 automatic       varying char(32)         level 2 in structure "CI" dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 363
conditionx                      000100 automatic       fixed bin(17,0)          dcl 378 set ref 388* 390*
construct                              based           char                     unaligned dcl 726 set ref 840* 1154*
construct_pos                   000150 automatic       fixed bin(21,0)          dcl 711 set ref 754* 840 840 840 852 1154 1154 1154
continue_to_signal_             000056 constant        entry                    external dcl 183 ref 401
control_string                         based           char                     unaligned dcl 438 set ref 740 742 743 752 757 759
                                                                                  806 832 835 840 851 852 863 866 885 889 980 1152
                                                                                  1152 1154
control_string_len              000105 automatic       fixed bin(21,0)          dcl 430 set ref 731* 740 742 743 752 757 759 806 832
                                                                                  835 840 851 852 863 866 885 889 980 1152 1152 1154
control_string_pos              000151 automatic       fixed bin(21,0)          dcl 711 set ref 732* 740 742 743 747 749* 749 752
                                                                                  754 755* 755 757 759 806 809 810* 810 832 834* 834
                                                                                  835 840 840 849* 849 851 863 864* 864 866 885 887*
                                                                                  887 889 1152 1152* 1154 1154
control_string_ptr              000106 automatic       pointer                  dcl 430 set ref 733* 740 742 743 747 752 757 759 806
                                                                                  809 832 835 840 851 852 863 866 885 889 980 1152
                                                                                  1152 1154
copy                                                   builtin function         dcl 67 ref 940
cu_$af_return_arg_rel           000060 constant        entry                    external dcl 183 ref 417
cu_$arg_list_ptr                000062 constant        entry                    external dcl 183 ref 282 282 682
cu_$arg_ptr_rel                 000064 constant        entry                    external dcl 183 ref 684 1174
cu_$cp                          000066 constant        entry                    external dcl 183 ref 298
cu_$evaluate_active_string      000070 constant        entry                    external dcl 183 ref 333
divide                                                 builtin function         dcl 67 ref 1080 1131
entrypoint                      000133 automatic       fixed bin(2,0)           dcl 73 set ref 219* 227* 236* 246* 253* 260* 274 286
                                                                                  288 421 443 444 445 471 472 473 474 529 619 689
                                                                                  691 901 904 917 1028 1201 1208 1211
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 170 set ref 655*
error_table_$command_line_overflow
                                000024 external static fixed bin(35,0)          dcl 170 set ref 562 1028*
error_table_$inconsistent       000026 external static fixed bin(35,0)          dcl 170 set ref 526*
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 170 set ref 658*
error_table_$not_act_fnc        000032 external static fixed bin(35,0)          dcl 170 ref 419
error_value_len                 000134 automatic       fixed bin(21,0)          dcl 73 set ref 269* 500* 581
error_value_ptr                 000136 automatic       pointer                  dcl 73 set ref 271* 327 397 501* 526 529 560 582
execute                         000140 automatic       bit(1)                   dcl 73 set ref 294 444* 457* 462* 472
execute_mode                    000012 internal static bit(1)                   initial array dcl 101 set ref 444 472*
expansion                              based           varying char             dcl 95 set ref 298 298 298 298 298 298 298 298 300
                                                                                  300 300 300 300 300 300 300 333 333 333 335 335
                                                                                  335 551 551 551 553 553 553 564 564 564 573 573
                                                                                  573 629* 734* 904 904 904 904 904 904 904 951* 951
                                                                                  980 985 1022 1022 1027 1027 1062 1064 1065 1068
                                                                                  1070 1071 1088* 1088 1088 1136
expansion_buffer                000141 automatic       varying char(256)        dcl 73 set ref 272 273 1154* 1156* 1199* 1200* 1200
                                                                                  1201* 1201 1203* 1203 1204* 1204 1205* 1205 1206*
                                                                                  1206 1208* 1211* 1212*
expansion_max_len               000242 automatic       fixed bin(21,0)          dcl 73 set ref 272* 584* 629 648* 734 951 980 986*
                                                                                  1022 1027 1028* 1088
expansion_overlay                      based           structure                level 1 dcl 932
expansion_ptr                   000244 automatic       pointer                  dcl 73 set ref 273* 298 298 298 298 298 298 298 298
                                                                                  300 300 300 300 300 300 300 300 333 333 333 335
                                                                                  335 335 551 551 551 553 553 553 564 564 564 573
                                                                                  573 573 585* 629 649* 734 904 904 904 904 904 904
                                                                                  904 904 917 938 939 939 940 951 951 980 985 994*
                                                                                  1022 1022 1024 1027 1027 1062 1064 1065 1068 1070
                                                                                  1071 1088 1088 1088 1136
fatal                           000203 automatic       bit(1)                   dcl 664 set ref 673* 680* 692 694
find_condition_info_            000072 constant        entry                    external dcl 183 ref 362 383
from_sw                         000154 automatic       bit(1)                   dcl 711 set ref 730* 765 779* 838 842* 860*
get_system_free_area_           000074 constant        entry                    external dcl 183 ref 279 314 974 983 991
hbound                                                 builtin function         dcl 67 ref 388
index                                                  builtin function         dcl 67 ref 742 759 806 866 889 1064 1108
info_ptr                 14     000102 automatic       pointer                  level 2 in structure "CI" dcl 380 in procedure
                                                                                  "any_other_handler" set ref 393*
info_ptr                 14     000106 automatic       pointer                  level 2 in structure "CI" dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 363*
inhibit_error                   000246 automatic       bit(1)                   dcl 73 set ref 296 330 445* 458* 463* 473 489* 512*
                                                                                  514* 526 529* 529
inhibit_error_mode              000014 internal static bit(1)                   initial array dcl 101 set ref 445 473* 529
ioa_                            000076 constant        entry                    external dcl 183 ref 629
ioa_$general_rs                 000100 constant        entry                    external dcl 183 ref 685
ioa_$ioa_switch                 000102 constant        entry                    external dcl 183 ref 904
iox_$error_output               000042 external static pointer                  dcl 181 set ref 904*
lbound                                                 builtin function         dcl 67 ref 388
len                                    based           fixed bin(21,0)          level 2 dcl 932 set ref 938 939* 939 940
length                                                 builtin function         dcl 67 ref 298 298 298 298 298 298 300 300 300 300
                                                                                  300 300 333 333 335 335 385 385 385 453 504 551
                                                                                  551 553 553 564 564 573 573 609 740 743 752 755
                                                                                  757 787 801 810 812 819 825 832 832 834 835 849
                                                                                  851 852 863 873 885 904 904 904 904 904 904 980
                                                                                  1020 1022 1022 1027 1062 1065 1068 1071 1088 1106
                                                                                  1109 1117 1120 1136 1152 1152
ltrim                                                  builtin function         dcl 67 ref 819
maxlength                                              builtin function         dcl 67 ref 272 980 1022 1027
mc_ptr                          000102 automatic       pointer                  level 2 in structure "CI" dcl 380 in procedure
                                                                                  "any_other_handler" set ref 393*
mc_ptr                          000106 automatic       pointer                  level 2 in structure "CI" dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 363*
min                                                    builtin function         dcl 67 ref 453 504 609
mod                                                    builtin function         dcl 67 ref 1074 1074 1081
new_buffer_ptr                  000100 automatic       pointer                  dcl 966 set ref 969* 974 974 974 983* 985 994
nstring                         000152 automatic       picture(5)               unaligned dcl 711 set ref 869* 871 872 873
null                                                   builtin function         dcl 67 ref 238 271 279 282 286 298 314 327 329 333
                                                                                  333 333 335 335 362 362 363 363 363 363 383 383
                                                                                  393 393 393 393 393 397 526 529 540 560 569 687
                                                                                  689 840 840 901 904 969 974 988 1028 1028 1172
                                                                                  1200 1201 1206 1208 1208
old_buffer_max_len              000102 automatic       fixed bin(21,0)          dcl 966 set ref 970* 990
old_len                         000176 automatic       fixed bin(21,0)          dcl 930 set ref 938* 940
parm_count                      000155 automatic       fixed bin(17,0)          dcl 711 set ref 735* 781 785 793 819 845 869 980
parser                          000110 automatic       fixed bin(3,0)           dcl 430 set ref 446* 448 452 452* 456* 466* 469 478
                                                                                  490* 493 497 497* 498 502* 506* 509 510* 519* 522
                                                                                  524 602* 604 608 608* 611* 614* 617 623
quote_multiplier                000156 automatic       fixed bin(21,0)          dcl 711 set ref 736* 1074 1074 1076 1077* 1077 1080*
                                                                                  1080 1081 1088 1091 1094* 1094 1097 1123 1131
                                                                                  1131*
quote_scan_pos                  000157 automatic       fixed bin(21,0)          dcl 711 set ref 732* 1062 1064 1065 1067* 1067 1068
                                                                                  1070 1071 1072* 1072 1136*
reason                                 parameter       fixed bin(3,0)           dcl 1150 ref 1147 1156
requote_last                    000160 automatic       bit(1)                   dcl 711 set ref 737* 1020* 1088 1133*
requote_string_                 000104 constant        entry                    external dcl 183 ref 551 553 564 573 655 658 840 904
                                                                                  1154
requote_sw                      000161 automatic       fixed bin(2,0)           dcl 711 set ref 738* 795* 840 856* 878* 882* 1054
                                                                                  1086 1129
rescan_type                     000247 automatic       fixed bin(17,0)          dcl 73 set ref 333* 335* 491* 515* 516* 517*
return_value                           based           varying char             dcl 95 set ref 333* 335*
return_value_max_len            000250 automatic       fixed bin(21,0)          dcl 73 set ref 284* 333 335 417* 564* 584 648
return_value_ptr                000252 automatic       pointer                  dcl 73 set ref 284* 286 333 335 393 417* 585 649 689
                                                                                  840 904 904 917 1024 1028 1200 1206 1208
rtrim                                                  builtin function         dcl 67 ref 812 1203
saved_parser                    000111 automatic       fixed bin(3,0)           dcl 430 set ref 502 509*
sci_ptr                         000254 automatic       pointer                  dcl 73 set ref 238* 262* 282 284* 298 300* 329 333
                                                                                  335* 540 545* 546* 569 569* 571* 687 694* 695* 840
                                                                                  901 903* 1028 1172 1177* 1201 1203* 1208 1212*
skip                            000162 automatic       fixed bin(21,0)          dcl 711 set ref 815* 816 817
ssu_$abort_line                 000106 constant        entry                    external dcl 183 ref 546 571 694 1212
ssu_$abort_subsystem            000110 constant        entry                    external dcl 183 ref 545 569
ssu_$arg_ptr                    000112 constant        entry                    external dcl 183 ref 1177
ssu_$evaluate_active_string     000114 constant        entry                    external dcl 183 ref 335
ssu_$execute_line               000116 constant        entry                    external dcl 183 ref 300
ssu_$get_request_name           000122 constant        entry                    external dcl 183 ref 1203
ssu_$get_subsystem_and_request_name
                                000120 constant        entry                    external dcl 183 ref 903
ssu_$print_message              000124 constant        entry                    external dcl 183 ref 695
ssu_$return_arg                 000126 constant        entry                    external dcl 183 ref 284
ssu_et_$null_request_line       000034 external static fixed bin(35,0)          dcl 170 ref 544
ssu_et_$request_line_aborted    000036 external static fixed bin(35,0)          dcl 170 ref 546 571
ssu_et_$subsystem_aborted       000040 external static fixed bin(35,0)          dcl 170 ref 545 569
status                          000256 automatic       fixed bin(35,0)          dcl 73 in procedure "do" set ref 298* 300* 304 333*
                                                                                  335* 339 417* 418 419 421* 542 544 545 546 551*
                                                                                  553* 562 564* 569 571 573* 1174* 1175 1175*
status                                 based           fixed bin(35,0)          dcl 670 in procedure "error" set ref 689* 691* 694*
                                                                                  695*
status_ptr                      000204 automatic       pointer                  dcl 664 set ref 684* 689 691 694 695
str                       1            based           char                     level 2 dcl 932 set ref 940*
string                                 based           char                     unaligned dcl 726 ref 812 815 818 819 821 951 1020
                                                                                  1022
string_len                      000163 automatic       fixed bin(21,0)          dcl 711 set ref 742* 743 743* 745 749 787* 801* 806*
                                                                                  808 810 812* 812 813 815 816* 816 818 819 821 825*
                                                                                  871* 872 873* 873 939 940 940 951 980 1020 1022
                                                                                  1027* 1056* 1064* 1065 1065* 1067 1070* 1071 1071*
                                                                                  1072 1074 1074 1076* 1076 1079 1081* 1081 1091*
                                                                                  1099* 1108* 1109 1109* 1110 1114 1119* 1120 1120*
                                                                                  1121 1123* 1123 1131*
string_ptr                      000164 automatic       pointer                  dcl 711 set ref 747* 788* 802* 809* 812 815 817* 817
                                                                                  818 819 821 827* 872* 951 1020 1022 1057* 1100*
                                                                                  1112*
substr                                                 builtin function         dcl 67 set ref 385 453 504 609 742 759 806 835 852
                                                                                  866 889 940* 1064 1070 1088 1108 1119
system_area                            based           area(1024)               dcl 95 ref 279 314 974 983 991
trace                           000257 automatic       bit(1)                   dcl 73 set ref 274* 359 393 455* 460* 474 504* 513*
                                                                                  542 546 564* 571 573 609* 612* 619 898
trace_mode                      000016 internal static bit(1)                   initial array dcl 101 set ref 274 474* 619*
unique                          000260 automatic       char(15)                 dcl 73 set ref 275* 799 799* 801 802
unique_chars_                   000130 constant        entry                    external dcl 183 ref 799
usage_string                           parameter       char                     unaligned dcl 1197 ref 1194 1205
verify                                                 builtin function         dcl 67 ref 815 818 871 1070 1119
version                   2     000106 automatic       fixed bin(17,0)          level 2 in structure "CI" dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 361*
version                   2     000102 automatic       fixed bin(17,0)          level 2 in structure "CI" dcl 380 in procedure
                                                                                  "any_other_handler" set ref 382*
wc_ptr                   16     000106 automatic       pointer                  level 2 in structure "CI" dcl 357 in procedure
                                                                                  "active_function_error_handler" set ref 363*
wc_ptr                   16     000102 automatic       pointer                  level 2 in structure "CI" dcl 380 in procedure
                                                                                  "any_other_handler" set ref 393*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_ACTIVE_STRING                  internal static fixed bin(17,0)          initial dcl 2-6
condition_info_ptr                     automatic       pointer                  dcl 1-10

NAMES DECLARED BY EXPLICIT CONTEXT.
AFTER_QUOTE_MODIFIER            005235 constant        label                    dcl 885 ref 880
AREA_HANDLER                    005702 constant        label                    dcl 998 ref 978
BADOPT                          004015 constant        label                    dcl 655 ref 463 517 612
COMMAND                         000000 constant        label                    array(3) dcl 290 ref 286
COMMON                          001147 constant        label                    dcl 269 in procedure "do" ref 241 265
COMMON                          004152 constant        label                    dcl 682 in procedure "error" ref 675
CONTINUE                        002170 constant        label                    dcl 401 ref 385 390
DISPATCH                        000006 constant        label                    array(-1:18) dcl 762 ref 760 823 847 858 867 890
EGRESS                          001425 constant        label                    dcl 311 ref 294 306 322 341 348 399 423 475 620 692
                                                                                  1214
END                             005421 constant        label                    dcl 917 ref 757 832 863 885
EXPANDED                        005254 constant        label                    dcl 898 ref 752 942 953
FUNCTION                        000003 constant        label                    array(3) dcl 318 ref 288
NOARG                           004060 constant        label                    dcl 658 ref 478 524 623
SCAN_NEXT                       005254 constant        label                    dcl 892 ref 797 804 830 876
STANDALONE                      001100 constant        label                    dcl 238 ref 221 229
SUBSTITUTE_ERROR_VALUE          001673 constant        label                    dcl 343 ref 367 397
SUBSYSTEM                       001142 constant        label                    dcl 262 ref 248 255
active_function_error_handler   001702 constant        entry                    internal dcl 354 ref 329
add_quotes                      005437 constant        entry                    internal dcl 927 ref 1092 1124 1132
add_string                      005456 constant        entry                    internal dcl 946 ref 748 789 803 828 874 1058 1101
                                                                                  1113
allocate_buffer                 005501 constant        entry                    internal dcl 963 ref 1033
any_other_handler               002013 constant        entry                    internal dcl 375 ref 296 330
check_arguments                 002202 constant        entry                    internal dcl 410 ref 282
check_buffer                    005724 constant        entry                    internal dcl 1017 ref 936 949
do                              001022 constant        entry                    external dcl 61
error                           004133 constant        entry                    internal dcl 661 ref 526 551 573 655 658 998 1156
                                                                                  1175
execute_string                  001033 constant        entry                    external dcl 223
execute_string_command          002271 constant        entry                    internal dcl 427 ref 290
execute_string_command_error    003115 constant        entry                    internal dcl 537 ref 304
execute_string_function         002576 constant        entry                    internal dcl 486 ref 324
execute_string_function_error   003334 constant        entry                    internal dcl 557 ref 339
expand                          004453 constant        entry                    internal dcl 708 ref 482 533 587 627 651
expand_arg                      006023 constant        entry                    internal dcl 1047 ref 783 793
expand_error_value              003553 constant        entry                    internal dcl 578 ref 346
exs                             001042 constant        entry                    external dcl 223
get_argument                    006412 constant        entry                    internal dcl 1167 ref 450 495 606 646 1052
illegal                         006312 constant        entry                    internal dcl 1147 ref 762 808 813 818 835 851 852
                                                                                  917 920
sbag                            001071 constant        entry                    external dcl 231
ssu_do_request_                 001107 constant        entry                    external dcl 243
ssu_execute_string_request_     001121 constant        entry                    external dcl 250
ssu_substitute_args_request_    001133 constant        entry                    external dcl 257
substitute_args                 001062 constant        entry                    external dcl 231
substitute_args_command         003574 constant        entry                    internal dcl 597 ref 308
substitute_args_function        003765 constant        entry                    internal dcl 639 ref 318
substitute_arguments            001053 constant        entry                    external dcl 231
usage                           006507 constant        entry                    internal dcl 1194 ref 441 522 600 642
warn                            004144 constant        entry                    internal dcl 677 ref 553 564 840 1028

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10432       10564    7500       10442
Length     11150    7500       132         347     731          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
do                                  262 external procedure  is an external procedure.  
on unit on line 277                  70 on unit               
on unit on line 296                  64 on unit               
on unit on line 329                 148 on unit               
on unit on line 330                  64 on unit               
active_function_error_handler           internal procedure  shares stack frame of on unit on line 329.  
any_other_handler                   144 internal procedure  is called by several nonquick procedures.  
check_arguments                      90 internal procedure  is declared options(non_quick).  
execute_string_command              540 internal procedure  is declared options(non_quick).  
error                               184 internal procedure  is called during a stack extension, and is declared options(variable).  
expand                                  internal procedure  shares stack frame of internal procedure execute_string_command.  
add_quotes                              internal procedure  shares stack frame of internal procedure execute_string_command.  
allocate_buffer                     120 internal procedure  enables or reverts conditions.  
on unit on line 972                  70 on unit               
on unit on line 978                  64 on unit               
check_buffer                            internal procedure  shares stack frame of internal procedure execute_string_command.  
expand_arg                              internal procedure  shares stack frame of internal procedure execute_string_command.  
illegal                                 internal procedure  shares stack frame of internal procedure execute_string_command.  
get_argument                            internal procedure  shares stack frame of internal procedure execute_string_command.  
usage                                   internal procedure  shares stack frame of internal procedure execute_string_command.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 abort_line_mode             do
000012 execute_mode                do
000014 inhibit_error_mode          do
000016 trace_mode                  do

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
allocate_buffer          000100 new_buffer_ptr              allocate_buffer
                         000102 old_buffer_max_len          allocate_buffer
any_other_handler        000100 conditionx                  any_other_handler
                         000102 CI                          any_other_handler
do                       000122 abort_line                  do
                         000123 allocated_buffer_max_len    do
                         000124 allocated_buffer_ptr        do
                         000126 arg_count                   do
                         000130 arg_list_ptr                do
                         000132 arg_offset                  do
                         000133 entrypoint                  do
                         000134 error_value_len             do
                         000136 error_value_ptr             do
                         000140 execute                     do
                         000141 expansion_buffer            do
                         000242 expansion_max_len           do
                         000244 expansion_ptr               do
                         000246 inhibit_error               do
                         000247 rescan_type                 do
                         000250 return_value_max_len        do
                         000252 return_value_ptr            do
                         000254 sci_ptr                     do
                         000256 status                      do
                         000257 trace                       do
                         000260 unique                      do
error                    000100 arg_list_ptr                error
                         000102 buffer                      error
                         000202 buffer_used                 error
                         000203 fatal                       error
                         000204 status_ptr                  error
execute_string_command   000100 arg_len                     execute_string_command
                         000102 arg_ptr                     execute_string_command
                         000104 argx                        execute_string_command
                         000105 control_string_len          execute_string_command
                         000106 control_string_ptr          execute_string_command
                         000110 parser                      execute_string_command
                         000111 saved_parser                execute_string_command
                         000124 buffer_overflow             expand
                         000125 command_name                expand
                         000150 construct_pos               expand
                         000151 control_string_pos          expand
                         000152 nstring                     expand
                         000154 from_sw                     expand
                         000155 parm_count                  expand
                         000156 quote_multiplier            expand
                         000157 quote_scan_pos              expand
                         000160 requote_last                expand
                         000161 requote_sw                  expand
                         000162 skip                        expand
                         000163 string_len                  expand
                         000164 string_ptr                  expand
                         000176 old_len                     add_quotes
                         000214 arg_pos                     expand_arg
on unit on line 329      000106 CI                          active_function_error_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           mdfx1
enable_op           shorten_stack       ext_entry           int_entry           any_to_any_truncate_op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               active_fnc_err_$suppress_name com_err_                      com_err_$suppress_name
condition_interpreter_        continue_to_signal_           cu_$af_return_arg_rel         cu_$arg_list_ptr
cu_$arg_ptr_rel               cu_$cp                        cu_$evaluate_active_string    find_condition_info_
get_system_free_area_         ioa_                          ioa_$general_rs               ioa_$ioa_switch
requote_string_               ssu_$abort_line               ssu_$abort_subsystem          ssu_$arg_ptr
ssu_$evaluate_active_string   ssu_$execute_line             ssu_$get_request_name
ssu_$get_subsystem_and_request_name                         ssu_$print_message            ssu_$return_arg
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$command_line_overflow                          error_table_$inconsistent
error_table_$noarg            error_table_$not_act_fnc      iox_$error_output             ssu_et_$null_request_line
ssu_et_$request_line_aborted  ssu_et_$subsystem_aborted




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     61 001021       219 001027       221 001031       223 001032       227 001047       229 001051       231 001052
    236 001076       238 001100       241 001102       243 001103       246 001114       248 001116       250 001117
    253 001126       255 001130       257 001131       260 001140       262 001142       265 001146       269 001147
    271 001151       272 001155       273 001157       274 001161       275 001165       277 001170       279 001204
    280 001226       282 001227       284 001251       286 001272       288 001300       290 001302       294 001306
    296 001310       298 001334       300 001364       302 001411       304 001412       306 001420       308 001421
    311 001425       314 001427       316 001450       318 001451       322 001455       324 001456       327 001462
    329 001466       330 001510       333 001534       335 001610       337 001662       339 001664       341 001672
    343 001673       346 001675       348 001701       354 001702       359 001703       361 001707       362 001711
    363 001731       365 002006       367 002007       375 002012       382 002020       383 002022       385 002041
    388 002047       390 002055       391 002065       393 002067       397 002154       399 002165       401 002170
    404 002200       410 002201       415 002207       417 002214       418 002232       419 002235       421 002240
    423 002265       427 002270       441 002276       443 002304       444 002311       445 002313       446 002315
    448 002317       450 002332       452 002334       453 002342       455 002370       456 002403       457 002416
    458 002426       460 002452       461 002466       462 002501       463 002514       466 002537       467 002541
    469 002543       471 002546       472 002553       473 002555       474 002557       475 002562       478 002565
    480 002567       482 002573       484 002574       486 002575       489 002603       490 002605       491 002607
    493 002611       495 002624       497 002626       498 002634       500 002636       501 002641       502 002643
    503 002645       504 002646       506 002673       507 002706       509 002716       510 002720       511 002722
    512 002723       513 002737       514 002753       515 002766       516 003002       517 003016       519 003032
    520 003034       522 003036       524 003044       526 003047       529 003076       531 003107       533 003112
    535 003113       537 003114       540 003122       542 003127       543 003135       544 003136       545 003142
    546 003155       549 003175       551 003176       553 003254       555 003331       557 003333       560 003341
    562 003346       564 003352       566 003431       569 003433       571 003453       573 003470       575 003547
    578 003551       581 003560       582 003563       584 003565       585 003567       587 003571       589 003572
    597 003573       600 003601       602 003607       604 003611       606 003624       608 003626       609 003634
    611 003661       612 003674       614 003710       615 003712       617 003714       619 003717       620 003725
    623 003730       625 003732       627 003736       629 003737       631 003763       639 003764       642 003772
    644 004000       646 004004       648 004006       649 004011       651 004013       653 004014       655 004015
    658 004060      1218 004130       661 004132       673 004140       675 004142       677 004143       680 004151
    682 004152       684 004161       685 004204       687 004252       689 004260       691 004321       692 004355
    693 004362       694 004363       695 004420       697 004452       708 004453       730 004454       731 004456
    732 004460       733 004462       734 004464       735 004466       736 004471       737 004473       738 004474
    740 004476       742 004501       743 004515       745 004521       747 004522       748 004526       749 004527
    752 004531       754 004534       755 004535       757 004537       759 004541       760 004552       762 004553
    765 004555       777 004557       779 004563       781 004564       783 004573       785 004574       787 004577
    788 004601       789 004603       791 004604       792 004606       793 004607       795 004613       797 004615
    799 004616       801 004640       802 004642       803 004645       804 004646       806 004647       808 004663
    809 004666       810 004672       812 004675       813 004707       815 004713       816 004726       817 004730
    818 004733       819 004750       821 004771       823 005001       825 005002       827 005004       828 005006
    830 005007       832 005010       834 005014       835 005015       838 005025       840 005027       842 005126
    845 005131       847 005133       849 005134       851 005136       852 005143       855 005153       856 005154
    858 005156       860 005157       863 005161       864 005164       866 005165       867 005177       869 005200
    871 005210       872 005221       873 005224       874 005226       876 005227       878 005230       880 005232
    882 005233       885 005235       887 005240       889 005241       890 005253       898 005254       901 005260
    903 005276       904 005307       908 005417       910 005420       917 005421       920 005434      1160 005436
    927 005437       936 005440       938 005441       939 005444       940 005446       942 005453       944 005455
    946 005456       949 005457       951 005460       953 005475       955 005477       963 005500       969 005506
    970 005510       972 005514       974 005530       976 005560       978 005561       980 005600       983 005612
    985 005633       986 005646       988 005650       990 005654       991 005656       994 005674       996 005701
    998 005702      1001 005723      1017 005724      1020 005725      1022 005730      1024 005735      1026 005741
   1027 005743      1028 005746      1030 006015      1033 006016      1035 006022      1047 006023      1052 006024
   1054 006032      1056 006035      1057 006037      1058 006041      1059 006042      1062 006043      1064 006050
   1065 006064      1067 006070      1068 006071      1070 006074      1071 006110      1072 006114      1074 006115
   1076 006127      1077 006131      1078 006133      1079 006135      1080 006140      1081 006143      1082 006147
   1084 006150      1086 006151      1088 006154      1091 006165      1092 006167      1094 006170      1097 006173
   1099 006176      1100 006200      1101 006202      1102 006203      1104 006204      1106 006205      1108 006211
   1109 006225      1110 006231      1112 006232      1113 006237      1114 006241      1117 006243      1119 006246
   1120 006263      1121 006267      1123 006270      1124 006272      1126 006273      1129 006274      1131 006277
   1132 006303      1133 006304      1136 006306      1138 006311      1147 006312      1152 006314      1154 006321
   1156 006364      1158 006411      1167 006412      1172 006414      1174 006421      1175 006440      1176 006467
   1177 006470      1179 006506      1194 006507      1199 006520      1200 006525      1201 006540      1203 006563
   1204 006621      1205 006630      1206 006644      1208 006657      1211 006722      1212 006755      1214 007005


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
