	COMPILATION LISTING OF SEGMENT probe_break_handler_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1232.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_break_handler_:
       26   proc ();
       27 
       28 
       29   call probe_error_$malfunction ();	/* dummy entry */
       30 
       31   /* *	This procedure contains the routines which are called by the code sequences
       32*   *	in the break map header. It sets up a new probe_info structure, and interprets
       33*   *	the breakpoint request list. */
       34 
       35   /* Changed to ignore 2 breaks in a row in probe itself, for debugging 10/07/81 S. Herbst */
       36   /* Changed to reset a temporary break when it hits one 12/10/81 S. Herbst */
       37   /* Fixed to ignore break if break segment not found. 05/13/83 S. Herbst */
       38   /* Do "start" control order on output switch before returning to prevent losing wakeups 09/02/83 S. Herbst */
       39   /* Changed to apply RETURN_PTR_MASK to stack_frame.return_ptr (see incl comment) 03/06/84 S. Herbst */
       40   /* Changed to call probe_break_mgr_$reset_all_pause_breaks on cleanup 04/19/84 S. Herbst */
       41 
       42   dcl PAUSE_LINE		char (6) int static options (constant)
       43 			init ("pause
       44 ");
       45 
       46   dcl bp			ptr;
       47   dcl p			ptr;
       48   dcl code		fixed bin (35);
       49   dcl callers_frame		pointer;
       50 
       51   dcl 1 based_instruction	aligned based,
       52        2 offset		bit (18) unal,
       53        2 misc		bit (18) unal;
       54 				/* opcode and modifier */
       55 
       56   dcl com_err_		entry options (variable);
       57   dcl iox_$control		entry (ptr, char (*), ptr, fixed bin (35));
       58 
       59   dcl probe_break_mgr_$reset_all_pause_breaks
       60 			entry (ptr);
       61   dcl probe_break_mgr_$reset_break_at_line
       62 			entry (ptr, ptr, fixed bin, bit (1) aligned,
       63 			fixed bin (35));
       64   dcl probe_error_		entry options (variable);
       65   dcl probe_error_$malfunction
       66 			entry options (variable);
       67   dcl probe_listen_$interpret_line
       68 			entry (ptr, ptr, fixed bin (21), fixed bin (35))
       69 			;
       70   dcl probe_seg_info_	entry (ptr, ptr, fixed bin (35)) returns (ptr);
       71 
       72   dcl probe_subsys_util_$create_invocation
       73 			entry (fixed bin, ptr, fixed bin (35));
       74   dcl probe_subsys_util_$destroy_invocation
       75 			entry (ptr);
       76 
       77   dcl (probe_et_$old_break)	fixed bin (35) external static;
       78 
       79   dcl cleanup		condition;
       80 
       81   dcl (addr, addrel, baseno, length, null, pointer, size, stackframeptr,
       82       unspec)		builtin;
       83 				/*  */
       84 
       85 probe_break_handler_$break_type_1:
       86   entry ();
       87 
       88   /* *	This is the entry for type 1 (standard) breaks */
       89 
       90   probe_info_ptr = null ();
       91 
       92   on cleanup
       93     begin;
       94     call probe_break_mgr_$reset_all_pause_breaks (probe_info_ptr);
       95     call clean_things_up ();
       96   end;
       97 
       98   call probe_subsys_util_$create_invocation (probe_info_version,
       99        probe_info_ptr, code);
      100   if code ^= 0 then do;		/* MOBY lossage */
      101       call com_err_ (code, "probe",
      102 	 "Unable to initialize probe for breakpoint; break ignored.");
      103       call clean_things_up ();
      104       return;
      105     end;
      106 
      107   if probe_info.break_segment_ptr = null
      108     then go to IGNORE_BREAK;		/* rather than blow up later */
      109 
      110   probe_info.abort_probe_label = BREAK_TYPE_1_RETURNS;
      111 				/* for handling initialization errors, mostly */
      112   probe_info.abort_line_label = BREAK_TYPE_1_RETURNS;
      113   probe_info.current_stack_frame = stackframeptr ();
      114 
      115   callers_frame = stackframeptr () -> stack_frame.prev_sp;
      116 				/* frame of caller - routine that took break */
      117 
      118   break_extension_info_ptr =
      119        addrel (stackframeptr (), -size (probe_break_extension));
      120 
      121   p = probe_break_extension.slot_return_addr;
      122 				/* instruction after call to map seq. */
      123 
      124   /* FOR DEBUGGING: Ignore second recursive break in probe itself */
      125 
      126   if ^probe_static_info.recursive_breaks_sw
      127     then
      128          if baseno (p) = probe_static_info.probe_segno
      129 	 then
      130 	      if probe_static_info.last_break_segno
      131 		 = probe_static_info.probe_segno
      132 	        then
      133 		   go to IGNORE_BREAK;
      134 				/* skip the second break in a row in probe itself */
      135 
      136   probe_static_info.last_break_segno = baseno (p);
      137 
      138   if p -> based_instruction.misc ^= NOP_code
      139     then call probe_error_ (probe_info_ptr, probe_et_$old_break);
      140 
      141   bsp = pointer (p, p -> based_instruction.offset);
      142 				/* to break slot */
      143   stp = pointer (bsp, break_slot.statement_item_offset);
      144 				/* set up statement item */
      145   ent = pointer (probe_info.break_segment_ptr, statement_item.proc_entry);
      146 
      147   /* some consistency checks here */
      148 
      149   if ent = null
      150     then go to IGNORE_BREAK;
      151   if procedure_entry.time_stamp ^= statement_item.identifier
      152     then do;			/* probably set by someone else  - we shall ignore it */
      153 IGNORE_BREAK:
      154       call clean_things_up ();
      155       return;
      156     end;
      157 
      158   current_source.stmnt_map_entry_index = statement_item.number;
      159   current_source.instruction_ptr = pointer (bsp, break_slot.location);
      160   current_source.stack_ptr = callers_frame;
      161 
      162   /* now to get entry ptr - someday this should be stored in proc_entry */
      163 
      164   if break_slot.symbol_block_offset = "0"b
      165     then do;			/* someday, this will happen, when breaks can be set ala debug */
      166       current_source.block_ptr = null ();
      167       current_source.entry_ptr = callers_frame -> stack_frame.entry_ptr;
      168     end;
      169     else do;
      170       current_source.block_ptr, bp =
      171 	 pointer (bsp, break_slot.symbol_block_offset);
      172 
      173       if bp -> runtime_block.quick then do;
      174 	p = null ();		/* havent got entry yet */
      175 	if bp -> runtime_block.entry_info ^= "0"b then do;
      176 	    p = addrel (callers_frame, bp -> runtime_block.entry_info);
      177 				/* pt to entry_info */
      178 	    p = addrel (p -> quick_entry.return, -1);
      179 				/* pt to call to this block */
      180 	    p = addrel (p, p -> based_instruction.offset);
      181 				/* assume it is a relative TRA NNN,ic */
      182 
      183 	    /* now i think for fortran, this is instead a pl1_op call  so this kludeg ahead... */
      184 
      185 	    if baseno (p) ^= baseno (bp)
      186 				/* our return isn't into same seg we started  in */
      187 	      then p = null ();	/* show failure */
      188 	  end;
      189 	if p = null () /* fortran, or no entry info */
      190 	  then do;
      191 	    p = addrel (bp, bp -> runtime_block.first);
      192 				/* pt to statement_map for first stmt */
      193 	    p = pointer (p, p -> statement_map.location);
      194 	  end;
      195         end;			/* quick */
      196         else p = callers_frame -> stack_frame.entry_ptr;
      197 
      198       current_source.entry_ptr = p;
      199     end;				/* non-null bp */
      200 
      201 
      202   current_source.seg_info_ptr =
      203        probe_seg_info_ (probe_info_ptr, (current_source.entry_ptr), (0));
      204 
      205   /*  In old probe, when the break was encountered, a ptr to the break map was saved in seg_info.break_info
      206*   But we don't need it anymore --- I hope --- */
      207 
      208 
      209 
      210   /* *Note that the return loc in frame will be into break map, not text, and stu_ gets
      211*   *confused, so fudge it (remember stack_frame_exit gives return loc - 1). Record
      212*   *information about the break, to make it restartable. We will want to return to the
      213*   *spot in the break map, unless it gets changed by resetting an active break, but
      214*   *make it look otherwise for a while. */
      215 
      216   probe_info.break_slot_ptr = bsp;
      217   unspec (probe_info.real_break_return_loc) =
      218        unspec (callers_frame -> stack_frame.return_ptr) & RETURN_PTR_MASK;
      219   callers_frame -> stack_frame.return_ptr =
      220        addrel (current_source.instruction_ptr, 1);
      221 
      222   probe_info.return_method = RETURN_TO_BREAK;
      223 				/* remember how we got here */
      224 
      225 
      226   initial_source = current_source;
      227   probe_info.language_type =
      228        current_source.seg_info_ptr -> seg_info.language_type;
      229 
      230   probe_static_info.stack_info.good_stack = "0"b;
      231 				/* the stack has changed, after all */
      232 
      233   if bsp -> break_slot.command_list = PAUSE_LINE then do;
      234 				/* reset if temporary break */
      235       call probe_break_mgr_$reset_break_at_line (probe_info_ptr,
      236 	 probe_info.ptr_to_current_source, BREAK_BEFORE, "0"b, (0));
      237 
      238       call probe_listen_$interpret_line (probe_info_ptr, addr (PAUSE_LINE),
      239 	 length (PAUSE_LINE), (0));
      240     end;
      241 
      242     else call probe_listen_$interpret_line (probe_info_ptr,
      243 	    addr (bsp -> break_slot.command_list),
      244 	    (bsp -> break_slot.count), (0));
      245 
      246 BREAK_TYPE_1_RETURNS:
      247   call clean_things_up ();		/* clean up */
      248   return;				/* return to program causing the break */
      249 
      250 
      251 
      252 
      253 
      254 
      255 clean_things_up:
      256   proc ();
      257 
      258   if probe_info_ptr ^= null () then do; /* do some things, if we can */
      259       if addr (probe_static_info) ^= null ()
      260         then /* invalidate the saved stack */
      261 	   probe_static_info.good_stack = "0"b;
      262 
      263       if probe_info.return_method = RETURN_TO_BREAK
      264         then /* only true if break info is also valid */
      265 	   callers_frame -> stack_frame.return_ptr =
      266 	        probe_info.real_break_return_loc;
      267     end;				/* repair damage done earlier */
      268 
      269   call probe_subsys_util_$destroy_invocation (probe_info_ptr);
      270 
      271   call iox_$control (probe_info.output_switch, "start", null, 0);
      272 				/* prevent wakeups from being lost while break is executing */
      273   return;
      274   end;				/* internal procedure clean_things_up */
      275 
      276 
      277   /*	INCLUDE FILES	*/
      278 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      279 
      280 
      281   /* ;;;;;;; */
      282 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      283 
      284 
      285   /* ;;;;;;; */
      286 
  3     1 /*	BEGIN INCLUDE FILE ... probe_modes.incl.pl1
  3     2*
  3     3*   this structure is part of the per-user data base, which alledgedly is
  3     4*   kept in person_id.probe  no probe code other than probe_modes_mgr_
  3     5*   should set these modes, or refer to them BY NAME in communication
  3     6*   with the user  I do not even promise a one-to-one correspondance
  3     7*   between the modes the user can set and the names here
  3     8*
  3     9*   James R. Davis 12 July 79 */
  3    10 /* Added meter 09/23/82 S. Herbst */
  3    11 /* Added truncate_strings 05/21/84 S. Herbst */
  3    12 
  3    13 
  3    14 dcl 1 probe_modes aligned based (probe_info.modes_ptr),
  3    15     2 len_modes,
  3    16       3 error_messages fixed bin,			/* for use by probe_error_ */
  3    17       3 qualification fixed bin,			/* for use by probe_print_value_ */
  3    18       3 value_print fixed bin,			/* for probe_print_value_ */
  3    19       3 pad (5) fixed bin,				/* for use by probe_mxyzptlk */
  3    20     2 value_separator char (32) varying,
  3    21     2 bits,
  3    22       3 use_exclude_names bit (1) unal,
  3    23       3 debug_modes_set bit (1) unaligned,		/* whether any of the *MAGIC* modes are set */
  3    24       3 ignore_faults bit (1) unaligned,
  3    25       3 octal_bitstrings bit (1) unal,			/* for Olin Sibert */
  3    26       3 catch_errors bit (1) unaligned, 		/* calls to probe_error_ will call cu_$cl */
  3    27       3 catch_error_once bit (1) unaligned,		/* next call to probe_error_ will call cu_$cl */
  3    28       3 debug_breaks bit (1) unaligned, 		/* causes various things to happen at breakpoints */
  3    29       3 use_prompt bit (1) unaligned,			/* whether to use the prompt */
  3    30       3 debug bit (1) unaligned,			/* controls printing of random debugging information */
  3    31       3 meter bit (1) unaligned,			/* controls printing of time, vcpu, pf's at halt */
  3    32       3 truncate_strings bit (1) unaligned,		/* controls value req printing only 1st 200 chars/bits */
  3    33       3 pad bit (25) unaligned;
  3    34 
  3    35 dcl (BRIEF_mode_type init (1),
  3    36      SHORT_mode_type init (2),
  3    37      LONG_mode_type init (3)) fixed bin internal static options (constant);
  3    38 
  3    39 /* END INCLUDE FILE ... probe_modes.incl.pl1 */
  3    40 
      287 
      288 
      289   /* ;;;;;;; */
      290 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      291 
      292 
      293   /* ;;;;;;; */
      294 
  5     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  5     2*
  5     3*   25 June 79 JRDavis
  5     4*
  5     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  5     6*	correction per file.
  5     7**/
  5     8 
  5     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  5    10     2 language_type fixed bin,			/* language of source program */
  5    11     2 bits aligned,
  5    12       3 ignore_case bit (1) unal,
  5    13       3 bound_segment bit (1) unaligned,
  5    14       3 component bit (1) unaligned,
  5    15       3 pad bit (33) unal,
  5    16     2 names,					/* where to find it */
  5    17       3 directory_name character (168) unal,		/* what directory */
  5    18       3 entry_name character (32) unal,			/* what segment */
  5    19       3 segname character (32) unal,			/* procedure segname definition */
  5    20     2 identifier fixed bin (71),			/* time of object creation */
  5    21     2 pointers,					/* location of various parts of segment */
  5    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  5    23       3 original_source_ptr ptr unal,			/* to segment source map */
  5    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  5    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  5    26*						   bound ones, -> break_map !obsolete, I think! */
  5    27       3 chain ptr unal,				/* to entry for next component if bound */
  5    28       3 linkage_ptr ptr unal,				/* to linkage section */
  5    29     2 bounds aligned,				/* structure of bounds information */
  5    30       3 text_bounds,
  5    31         4 start fixed bin (35),
  5    32         4 end fixed bin (35),
  5    33       3 symbol_bounds,
  5    34         4 start fixed bin (35),
  5    35         4 end fixed bin (35),
  5    36     2 map_size fixed bin,				/* size of statement map */
  5    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  5    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  5    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  5    40     2 pad (1) fixed bin (35),
  5    41 
  5    42     2 nfiles fixed bin,
  5    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  5    44       3 file_pointers ptr unal,
  5    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  5    46 
  5    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  5    48 
  5    49 
  5    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      295 
      296 
      297   /* ;;;;;;; */
      298 
  6     1 /* BEGIN INCLUDE FILE ...  probe_break_slot.incl.pl1
  6     2*
  6     3*   This is separate from probe_break_info.incl.pl1 because many programs
  6     4*   need to get at a break_slot, but don't deserve to see the rest of that information
  6     5*
  6     6**/
  6     7 
  6     8 dcl 1 break_slot based (bsp) aligned,			/* describes (and handles) each probe break */
  6     9     2 item_type fixed bin,				/* 0 -> break_slot type code */
  6    10     2 breakmap_header_offset bit (18) unal,		/* to break map header, chain is not used */
  6    11     2 statement_item_offset bit (18) unal,
  6    12     2 size fixed bin,				/* number of words in the break_slot */
  6    13     2 sequence (0:7),				/* "before" or "after" instructions to "trap" the break */
  6    14       3 offset bit (18) unaligned,			/* address portion, some patched */
  6    15       3 skip bit (18) unaligned,			/* op code portion */
  6    16     2 old_instruction bit (36) aligned,			/* instruction that was replaced by break */
  6    17     2 symbol_block_offset bit (18) unal,		/*  for containing block */
  6    18     2 location bit (18) unal,				/* offset of instruction that was replaced by break */
  6    19     2 type fixed bin,				/* 0 -> after, 1 -> before */
  6    20     2 count fixed bin,				/* number of characters in command list */
  6    21     2 command_list character (0 refer (break_slot.count));	/* command list associated with break */
  6    22 
  6    23 dcl bsp ptr;
  6    24 
  6    25 dcl (BREAK_AFTER init (0),
  6    26      BREAK_BEFORE init (1),
  6    27      BREAK_AT init (2)) fixed bin internal static options (constant);
  6    28 
  6    29 dcl  PLACE (0:2) char (8) aligned internal static options (constant) init ("after", "before", "at");
  6    30 
  6    31 /* END INCLUDE FILE ... probe_break_slot.incl.pl1 */
      299 
  7     1 /*	BEGIN INCLUDE FILE probe_break_info.incl.pl1
  7     2*   Removed from probe_break_mgr_, 05/18/79 WOS
  7     3*
  7     4*   Some of these things are found only in the probe segment (the break segment)
  7     5*   such as "break_segment", "procedure_entry".
  7     6*   If "macro_item" or   "symbol_item" were used, they'd go there, too.
  7     7*   If probe_modes were kept in   the probe seg, they'd go there too.
  7     8*   In the break_map of an object seg go "break_map", and "statement_item" and
  7     9*   "break_slot" (there are two flavors of break_slot, one for "before",
  7    10*   and one for "after".  The astute reader will notice that they are both the
  7    11*   same , except in how they arrange the eight words in "sequence".  For cases
  7    12*   where what is of interest is not in those eigth words, the more general "break_slot"
  7    13*   structure may be used.  It may come to pass in the future that before and after will
  7    14*   look different, of course.
  7    15*
  7    16*   James R. Davis 23 Sept 79
  7    17*
  7    18*   "symbol_item" removed, because probe variables are implemented differently
  7    19*   then JMB seemed to envision.  SYMBOL_ITEM is left for compatibility, but not used
  7    20**/
  7    21 
  7    22 dcl 1 break_segment based (break_segp) aligned,		/* declaration of header for break segment */
  7    23     2 version fixed bin initial (2),			/* version number */
  7    24     2 name character (8) initial ("breakseg"),
  7    25     2 upper_bound bit (18) unal,			/* as described above */
  7    26     2 word_count bit (18) unal,
  7    27     2 first_free_item bit (18) unal,
  7    28     2 first_procedure_entry bit (18) unal,		/* the break procedure only has procedure entries */
  7    29     2 first_symbol bit (18) unal,			/* can be deleted */
  7    30     2 first_macro bit (18) unal;
  7    31 
  7    32 dcl  break_segp pointer;
  7    33 
  7    34 dcl 1 break_map based (bmp) aligned,			/* declaration of header for break map */
  7    35     2 version fixed bin initial (2),			/* version number */
  7    36     2 name character (8) initial ("breakmap"),
  7    37     2 upper_bound bit (18) unal,
  7    38     2 word_count bit (18) unal,
  7    39     2 first_free_item bit (18) unal,			/* as above */
  7    40     2 symbol_header bit (18) unal,			/* to symbol section of entire object seg */
  7    41     2 initial_word_count fixed bin (35),		/* low water mark for allocations */
  7    42     2 identifier fixed bin (71),			/* unique id of entire segment */
  7    43     2 map_sequence pointer;				/* beginning of code to call break handler */
  7    44 						/* pointer to align on double word */
  7    45 
  7    46 dcl 1 item based aligned,				/* canonical declaration for all items */
  7    47     2 item_type fixed bin,				/* separates different types */
  7    48     2 unused bit (18) unaligned,
  7    49     2 chain bit (18) unaligned,			/* to next item of same type or (18)"0"b */
  7    50     2 size fixed bin;				/* number of words occupied by this item */
  7    51 
  7    52 dcl 1 free_item based aligned,			/* little bundle of free storage */
  7    53     2 size fixed bin,				/* number free words contained here */
  7    54     2 unused bit (18) unaligned,
  7    55     2 chain bit (18) unaligned,
  7    56     2 zeros bit (0);				/* area to zero out when freed */
  7    57 
  7    58 dcl 1 procedure_entry based (ent) aligned,		/* one entry for each procedure that has breaks */
  7    59     2 item_type fixed bin initial (PROCEDURE_ITEM),	/* as for all other items */
  7    60     2 unused bit (18) unaligned,
  7    61     2 chain bit (18) unaligned,
  7    62     2 size fixed bin,
  7    63     2 directory character (168) unal,			/* directory portion of segment pathname */
  7    64     2 entry character (32) unal,			/* entry portion of pathname */
  7    65     2 segname character (32) unal,			/* name of "main" entry */
  7    66     2 pad fixed bin (71),				/* formerly time of proc. creation */
  7    67     2 time_stamp fixed bin (71),			/* time of creation of containing seg. */
  7    68     2 first_statement bit (18) unal,			/* chain of statements with breaks */
  7    69     2 first_symbol bit (18) unal,			/* not used */
  7    70     2 first_macro bit (18) unal,
  7    71     2 first_debug_break bit (18) unal,			/* chain of debug style breaks (not used yet) */
  7    72     2 break_map bit (18) unal,			/* offset in object seg of break map */
  7    73     2 statement_map bit (18) unal,			/* offset in object seg of map for this proc */
  7    74     2 statement_map_size bit (18) unal,			/* number of entries in map */
  7    75     2 source_map bit (18) unal,			/* offset of source map for proc */
  7    76     2 symbol_header bit (18) unal,			/* offset of symbol section for this proc */
  7    77     2 bounds aligned,				/* structure of bounds information */
  7    78       3 text_bounds,
  7    79         4 start fixed bin (35),
  7    80         4 end fixed bin (35),
  7    81       3 symbol_bounds,
  7    82         4 start fixed bin (35),
  7    83         4 end fixed bin (35),
  7    84     2 language_type fixed bin;			/* code for language of source program */
  7    85 
  7    86 dcl 1 statement_item based (stp) aligned,		/* each statement with a break has a map entry */
  7    87     2 item_type fixed bin initial (STATEMENT_ITEM),
  7    88     2 unused bit (18) unaligned,
  7    89     2 chain bit (18) unaligned,
  7    90     2 size fixed bin,
  7    91     2 identifier fixed bin (71),			/* id of proc this stmt is in */
  7    92     2 proc_entry bit (18) unal,			/* offset of proc entry in break seg */
  7    93     2 number fixed bin,				/* statement number */
  7    94     2 slots (0:1) bit (18);				/* offset of break slots for insert and append */
  7    95 
  7    96 /* unused, here only as indication of what JMB (Amen!) may have had in mind 
  7    97*   for probe macros.  For the record, it looked like he was going to do
  7    98*   probe variables in a similar way, and they are not done the way he seemed
  7    99*  to envision.
  7   100**/
  7   101 
  7   102 dcl 1 macro_item based aligned,			/* definition of a probe macro */
  7   103     2 item_type fixed bin initial (MACRO_ITEM),
  7   104     2 unused bit (18) unaligned,
  7   105     2 chain bit (18) unaligned,
  7   106     2 size fixed bin,
  7   107     2 name character (32),				/* macro name */
  7   108     2 count fixed bin,				/* number of characters in command list */
  7   109     2 command_list character (0);			/* place to put command list */
  7   110 
  7   111 
  7   112 dcl 1 break_slot_before aligned based (before_slot_ptr),
  7   113     2 item_type fixed bin init (BREAK_ITEM),
  7   114     2 breakmap_header_offset bit (18) unal,
  7   115     2 statement_item_offset bit (18) unal,
  7   116     2 size fixed bin,
  7   117     2 sequence,					/* eight words */
  7   118       3 word0 bit (36) init (SPRI_wd),
  7   119       3 word1,
  7   120         4 map_seq_offset bit (18) unal,
  7   121         4 opcode bit (18) unal init (TSPLB_code),
  7   122       3 word2,
  7   123         4 slot_offset bit (18) unal,
  7   124         4 opcode bit (18) unal init (NOP_code),
  7   125       3 moved_instruction bit (36),			/* first instr. of line, executed after break has occured */
  7   126       3 moved_descs (3),				/* descriptors if needed */
  7   127         4 offset bit (18) unal init (0),
  7   128         4 opcode bit (18) unal init (NOP_code),		/* and harmless NOP if not */
  7   129       3 return,
  7   130         4 offset bit (18) unal,			/* patched to be place to return to after break */
  7   131         4 opcode bit (18) unal init (TRA_code),
  7   132     2 old_instruction bit (36),			/* former occupant, sans relocation */
  7   133     2 symbol_block_offset bit (18) unal,
  7   134     2 location bit (18) unal,
  7   135     2 type fixed bin init (BREAK_BEFORE),
  7   136     2 count fixed bin,
  7   137     2 command_list char (command_list_size refer (break_slot_before.count));
  7   138 
  7   139 dcl 1 break_slot_after aligned based (after_slot_ptr),
  7   140     2 item_type fixed bin init (BREAK_ITEM),
  7   141     2 breakmap_header_offset bit (18) unal,
  7   142     2 statement_item_offset bit (18) unal,
  7   143     2 size fixed bin,
  7   144     2 sequence,
  7   145       3 moved_instruction bit (36),			/* happens before the break occurs */
  7   146       3 moved_descs (3),
  7   147         4 offset bit (18) unal init ((3)0),
  7   148         4 opcode bit (18) unal init ((3) NOP_code),
  7   149       3 word4 bit (36) init (SPRI_wd),
  7   150       3 word5,
  7   151         4 map_seq_offset bit (18) unal,
  7   152         4 opcode bit (18) unal init (TSPLB_code),
  7   153       3 word6,
  7   154         4 slot_offset bit (18) unal,
  7   155         4 opcode bit (18) unal init (NOP_code),
  7   156       3 return,
  7   157         4 offset bit (18) unal,
  7   158         4 opcode bit (18) unal init (TRA_code),
  7   159     2 old_instruction bit (36),			/* former occupant, sans relocation */
  7   160     2 symbol_block_offset bit (18) unal,
  7   161     2 location bit (18) unal,
  7   162     2 type fixed bin init (BREAK_AFTER),
  7   163     2 count fixed bin,
  7   164     2 command_list char (command_list_size refer (break_slot_before.count));
  7   165 
  7   166 
  7   167 /* we need these next two because PL/I wont take size(break_slot_before.sequence) */
  7   168 dcl size_of_after_sequence fixed bin internal static init (8) options (constant);
  7   169 dcl size_of_before_sequence fixed bin internal static init (8)  options (constant);
  7   170 
  7   171 
  7   172 dcl (BREAK_ITEM init (0),
  7   173      STATEMENT_ITEM init (1),
  7   174      SYMBOL_ITEM init (2),				/* will never be used */
  7   175      MACRO_ITEM init (3),				/* not used now */
  7   176      PROCEDURE_ITEM init (4)) fixed bin internal static options (constant);
  7   177 
  7   178 dcl  command_list_size fixed bin (21);
  7   179 
  7   180 dcl (ent, bmp, stp, before_slot_ptr, after_slot_ptr) ptr;
  7   181 
  7   182 dcl  SPRI_wd bit (36) init ("600022254120"b3);		/* spri sp|stack_frame.next_sp,* */
  7   183 
  7   184 dcl (NOP_code init ("011003"b3),
  7   185      TSPLB_code init ("671000"b3),
  7   186      TRA_code init ("710000"b3)) internal static options (constant) bit (18) unal;
  7   187 
  7   188 
  7   189 /* END INCLUDE FILE  ... probe_break_info.incl.pl1 */
      300 
  8     1 /* BEGIN INCLUDE FILE ... probe_break_extension.incl.pl1
  8     2*
  8     3*   Written 11 Sept 79 by James R. Davis
  8     4*
  8     5*   When a break occurs, the callers stack is grown to accomidate this structure.
  8     6*   It is used to  restart the break.  The "machine builtins" will use this
  8     7*   structure someday
  8     8*
  8     9**/
  8    10 
  8    11 dcl 1 probe_break_extension aligned based (break_extension_info_ptr),
  8    12     2 prs (0:7) ptr,				/* 0 -15 */
  8    13     2 regs aligned,					/* 16 -23 */
  8    14       3 x (0:7) bit (18) unal,
  8    15       3 a bit (36) aligned,				/* 20 */
  8    16       3 q bit (36) aligned,				/* 21 */
  8    17       3 ext,
  8    18         4 e bit (8) unal,
  8    19         4 pad1 bit (28) unal,
  8    20       3 time_and_ralr,				/* 23 */
  8    21         4 tr bit (27) unal,
  8    22         4 pad2 bit (6) unal,
  8    23         4 ralr bit (3) unal,
  8    24     2 unused1 bit (36),				/* 24 */
  8    25     2 unused2 bit (36),				/* 25 */
  8    26     2 indicators bit (36),				/* 26 */
  8    27     2 unused3 bit (36),				/* 27 */
  8    28     2 slot_return_addr ptr,				/* 28,	 29 */
  8    29     2 old_retptr_value ptr;				/* 30, 31 */
  8    30 
  8    31 dcl  break_extension_info_ptr ptr;
  8    32 
  8    33 /* END INCLUDE FILE  probe_break_extension.incl.pl1 */
  8    34 
      301 
      302 
      303   /* ;;;;;;; */
      304 
  9     1 /*	BEGIN INCLUDE FILE probe_info_constants.incl.pl1	*/
  9     2 /*	Created: 06/25/79 W. Olin Sibert		*/
  9     3 
  9     4 dcl (RETURN_TO_CALLER init (1),			/* return methods */
  9     5      RETURN_TO_FRAME init (2),
  9     6      RETURN_TO_CONDITION init (3),
  9     7      RETURN_TO_BREAK init (4)) fixed bin internal static options (constant);
  9     8 
  9     9 dcl (ENTRY_AT_CALL init (1),				/* entered by a call to probe */
  9    10      ENTRY_AT_BREAK init (2), 			/* entered by a call to probe$break */
  9    11      ENTRY_AT_HALT init (3)) fixed bin internal static options (constant); /* entered by a call to probe$halt */
  9    12 
  9    13 dcl (CONSOLE_INPUT init (1),
  9    14      BREAK_INPUT init (2),
  9    15      MACRO_INPUT init (3)) fixed bin internal static options (constant);
  9    16 
  9    17 /*	END INCLUDE FILE probe_info_constants.incl.pl1	*/
      305 
      306 
      307   /* ;;;;;;; */
      308 
 10     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
 10     2 
 10     3 dcl	1 runtime_symbol	aligned based,
 10     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
 10     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
 10     6 	2 array_units	unal bit(2),
 10     7 	2 units		unal bit(2),	/* addressing units */
 10     8 	2 type		unal bit(6),	/* data type */
 10     9 	2 level		unal bit(6),	/* structure level */
 10    10 	2 ndims		unal bit(6),	/* number of dimensions */
 10    11 	2 bits		unal,
 10    12 	  3 aligned	bit(1),
 10    13 	  3 packed	bit(1),
 10    14 	  3 simple	bit(1),
 10    15 	2 skip		unal bit(1),
 10    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
 10    17 	2 name		unal bit(18),	/* rel ptr to acc name */
 10    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
 10    19 	2 father		unal bit(18),	/* rel ptr to father entry */
 10    20 	2 son		unal bit(18),	/* rel ptr to son entry */
 10    21 	2 address		unal,
 10    22 	  3 location	bit(18),		/* location in storage class */
 10    23 	  3 class		bit(4),		/* storage class */
 10    24 	  3 next		bit(14),		/* rel ptr to next of same class */
 10    25 	2 size		fixed bin(35),	/* encoded string|arith size */
 10    26 	2 offset		fixed bin(35),	/* encoded offset from address */
 10    27 	2 virtual_org	fixed bin(35),
 10    28 	2 bounds(1),
 10    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
 10    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
 10    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
 10    32 
 10    33 dcl	1 runtime_bound	based,
 10    34 	2 lower		fixed bin(35),
 10    35 	2 upper		fixed bin(35),
 10    36 	2 multiplier	fixed bin(35);
 10    37 
 10    38 dcl	1 runtime_block	aligned based,
 10    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
 10    40 	2 quick		unal bit(1),	/* "1"b if quick block */
 10    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
 10    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
 10    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
 10    44 	2 skip		unal bit(1),
 10    45 	2 type		unal bit(6),	/* = 0 for a block node */
 10    46 	2 number		unal bit(6),	/* begin block number */
 10    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
 10    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
 10    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
 10    50 	2 father		unal bit(18),	/* rel ptr to father block */
 10    51 	2 son		unal bit(18),	/* rel ptr to son block */
 10    52 	2 map		unal,
 10    53 	  3 first		bit(18),		/* rel ptr to first word of map */
 10    54 	  3 last		bit(18),		/* rel ptr to last word of map */
 10    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
 10    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
 10    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
 10    58*					   on start list with length >= 2**i */
 10    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
 10    60*					   on list with length >= 2 ** i */
 10    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
 10    62 
 10    63 dcl	1 runtime_token	aligned based,
 10    64 	2 next		unal bit(18),	/* rel ptr to next token */
 10    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
 10    66 	2 name,				/* ACC */
 10    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
 10    68 	  3 string	unal char(n refer(runtime_token.size));
 10    69 
 10    70 dcl	1 encoded_value	aligned based,
 10    71 	2 flag		bit (2) unal,
 10    72 	2 code		bit (4) unal,
 10    73 	2 n1		bit (6) unal,
 10    74 	2 n2		bit (6) unal,
 10    75 	2 n3		bit (18) unal;
 10    76 
 10    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      309 
      310 
      311   /* ;;;;;;; */
      312 
 11     1 dcl	1 statement_map	aligned based,
 11     2 	2 location	bit(18) unaligned,
 11     3 	2 source_id	unaligned,
 11     4 	  3 file		bit(8),
 11     5 	  3 line		bit(14),
 11     6 	  3 statement	bit(5),
 11     7 	2 source_info	unaligned,
 11     8 	  3 start		bit(18),
 11     9 	  3 length	bit(9);
      313 
      314 
      315   /* ;;;;;;; */
      316 
 12     1 dcl	1 quick_entry	aligned based,
 12     2 	2 return		ptr,
 12     3 	2 argptr		ptr,
 12     4 	2 descptr		ptr;
      317 
      318 
      319   /* ;;;;;;; */
      320 
 13     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 13     2 
 13     3 /* format: off */
 13     4 
 13     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 13     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 13     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 13     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 13     9 
 13    10 
 13    11 /****^  HISTORY COMMENTS:
 13    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 13    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 13    14*     Modified to add constants for the translator_id field in the stack_frame
 13    15*     structure.
 13    16*                                                   END HISTORY COMMENTS */
 13    17 
 13    18 
 13    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 13    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 13    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 13    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 13    23 
 13    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 13    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 13    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 13    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 13    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 13    29 
 13    30 
 13    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 13    32 
 13    33 dcl  stack_frame_min_length fixed bin static init(48);
 13    34 
 13    35 
 13    36 dcl 1 stack_frame based(sp) aligned,
 13    37     2 pointer_registers(0 : 7) ptr,
 13    38     2 prev_sp pointer,
 13    39     2 next_sp pointer,
 13    40     2 return_ptr pointer,
 13    41     2 entry_ptr pointer,
 13    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 13    43     2 arg_ptr pointer,
 13    44     2 static_ptr ptr unaligned,
 13    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 13    46     2 on_unit_relp1 bit(18) unaligned,
 13    47     2 on_unit_relp2 bit(18) unaligned,
 13    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 13    49*						   0 => PL/I version II
 13    50*						   1 => ALM
 13    51*						   2 => PL/I version I   
 13    52*						   3 => signal caller frame
 13    53*						   4 => signaller frame */
 13    54     2 operator_return_offset bit(18) unaligned,
 13    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 13    56     2 a bit(36),					/* accumulator */
 13    57     2 q bit(36),					/* q-register */
 13    58     2 e bit(36),					/* exponent */
 13    59     2 timer bit(27) unaligned,				/* timer */
 13    60     2 pad bit(6) unaligned,
 13    61     2 ring_alarm_reg bit(3) unaligned;
 13    62 
 13    63 
 13    64 dcl 1 stack_frame_flags based(sp) aligned,
 13    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 13    66     2 xx0 bit(22) unal,
 13    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 13    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 13    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 13    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 13    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 13    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 13    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 13    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 13    75     2 xx0a bit(6) unal,
 13    76     2 xx1 fixed bin,
 13    77     2 xx2 fixed bin,
 13    78     2 xx3 bit(25) unal,
 13    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 13    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 13    81     2 xx3a bit(9) unaligned,
 13    82     2 xx4(9) bit(72) aligned,
 13    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 13    84*						*  operator puts a pointer to the base of
 13    85*						*  the calling procedure here. (text base ptr)  */
 13    86     2 xx5 bit(72) aligned,
 13    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 13    88 
 13    89 /* format: on */
 13    90 
 13    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      321 
      322 
      323   end;				/* probe_break_handler_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1225.3  probe_break_handler_.pl1          >spec>install>MR12.2-1194>probe_break_handler_.pl1
279          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
283          2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
287          3    12/04/84  2012.2  probe_modes.incl.pl1              >ldd>include>probe_modes.incl.pl1
291          4    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
295          5    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
299          6    07/15/80  1728.8  probe_break_slot.incl.pl1         >ldd>include>probe_break_slot.incl.pl1
300          7    07/15/80  1728.8  probe_break_info.incl.pl1         >ldd>include>probe_break_info.incl.pl1
301          8    11/26/79  1321.0  probe_break_extension.incl.pl1    >ldd>include>probe_break_extension.incl.pl1
305          9    11/26/79  1320.9  probe_info_constants.incl.pl1     >ldd>include>probe_info_constants.incl.pl1
309         10    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
313         11    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
317         12    05/06/74  1743.0  quick_entry.incl.pl1              >ldd>include>quick_entry.incl.pl1
321         13    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAK_AFTER                            internal static fixed bin(17,0)          initial dcl 6-25 ref 7-139
BREAK_BEFORE                    000010 constant        fixed bin(17,0)          initial dcl 6-25 set ref 7-112 235*
NOP_code                               constant        bit(18)                  initial packed unaligned dcl 7-184 ref 138
PAUSE_LINE                      000002 constant        char(6)                  initial packed unaligned dcl 42 set ref 233 238 238
                                                                                  238 238
RETURN_PTR_MASK                 000000 constant        bit(72)                  initial packed unaligned dcl 13-19 ref 217
RETURN_TO_BREAK                        constant        fixed bin(17,0)          initial dcl 9-4 ref 222 263
SPRI_wd                         000126 automatic       bit(36)                  initial packed unaligned dcl 7-182 set ref 7-182*
abort_line_label        226            based           label variable           level 3 dcl 1-18 set ref 112*
abort_probe_label       222            based           label variable           level 3 dcl 1-18 set ref 110*
addr                                                   builtin function         dcl 81 ref 238 238 242 242 259
addrel                                                 builtin function         dcl 81 ref 118 176 178 180 191 219
based_instruction                      based           structure                level 1 dcl 51
baseno                                                 builtin function         dcl 81 ref 126 136 185 185
block_ptr                 4            based           pointer                  level 2 dcl 4-13 set ref 166* 170*
bp                              000100 automatic       pointer                  dcl 46 set ref 170* 173 175 176 185 191 191
break_extension_info_ptr        000130 automatic       pointer                  dcl 8-31 set ref 118* 118 121
break_info               50            based           structure                level 2 dcl 1-18
break_segment_ptr        56            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 107 145
break_slot                             based           structure                level 1 dcl 6-8
break_slot_ptr           50            based           pointer                  level 3 dcl 1-18 set ref 216*
bsp                             000120 automatic       pointer                  dcl 6-23 set ref 141* 143 143 159 159 164 170 170
                                                                                  216 233 242 242 242
callers_frame                   000106 automatic       pointer                  dcl 49 set ref 115* 160 167 176 196 217 219 263
cleanup                         000110 stack reference condition                dcl 79 ref 92
code                            000104 automatic       fixed bin(35,0)          dcl 48 set ref 98* 100 101*
com_err_                        000010 constant        entry                    external dcl 56 ref 101
command_list             17            based           char                     level 2 dcl 6-8 set ref 233 242 242
count                    16            based           fixed bin(17,0)          level 2 dcl 6-8 ref 233 242 242 242
current_source                         based           structure                level 1 dcl 4-13 set ref 226
current_stack_frame      17            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref
                                                                                  113*
ent                             000122 automatic       pointer                  dcl 7-180 set ref 145* 149 151
entry_info                4            based           bit(18)                  level 2 packed packed unaligned dcl 10-38 ref 175
                                                                                  176
entry_ptr                10            based           pointer                  level 2 in structure "current_source" dcl 4-13
                                                                                  in procedure "probe_break_handler_" set ref 167*
                                                                                  198* 202
entry_ptr                26            based           pointer                  level 2 in structure "stack_frame" dcl 13-36
                                                                                  in procedure "probe_break_handler_" ref 167 196
first                     3            based           bit(18)                  level 3 packed packed unaligned dcl 10-38 ref 191
flags                    52            based           structure                level 3 dcl 2-8
good_stack               52            based           bit(1)                   level 4 packed packed unaligned dcl 2-8 set ref 230*
                                                                                  259*
identifier                4            based           fixed bin(71,0)          level 2 dcl 7-86 ref 151
initial_source                         based           structure                level 1 dcl 4-14 set ref 226*
instruction_ptr           2            based           pointer                  level 2 dcl 4-13 set ref 159* 219
io_switches              66            based           structure                level 2 dcl 1-18
iox_$control                    000012 constant        entry                    external dcl 57 ref 271
language_type            21            based           fixed bin(17,0)          level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_break_handler_" set ref 227*
language_type                          based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 5-9 in procedure
                                                                                  "probe_break_handler_" ref 227
last_break_segno         47            based           bit(18)                  level 2 dcl 2-8 set ref 126 136*
length                                                 builtin function         dcl 81 ref 238 238
listener_info           210            based           structure                level 2 dcl 1-18
location                 14(18)        based           bit(18)                  level 2 in structure "break_slot" packed packed
                                                                                  unaligned dcl 6-8 in procedure
                                                                                  "probe_break_handler_" ref 159
location                               based           bit(18)                  level 2 in structure "statement_map" packed packed
                                                                                  unaligned dcl 11-1 in procedure
                                                                                  "probe_break_handler_" ref 193
map                       3            based           structure                level 2 packed packed unaligned dcl 10-38
misc                      0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 51 ref 138
null                                                   builtin function         dcl 81 ref 90 107 149 166 174 185 189 258 259 271
                                                                                  271
number                    7            based           fixed bin(17,0)          level 2 dcl 7-86 ref 158
offset                                 based           bit(18)                  level 2 packed packed unaligned dcl 51 ref 141 180
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 271*
p                               000102 automatic       pointer                  dcl 47 set ref 121* 126 136 138 141 141 174* 176*
                                                                                  178* 178 180* 180 180 185 185* 189 191* 193* 193
                                                                                  193 196* 198
pointer                                                builtin function         dcl 81 ref 141 143 145 159 170 193
prev_sp                  20            based           pointer                  level 2 dcl 13-36 ref 115
probe_area_info          56            based           structure                level 2 dcl 1-18
probe_break_extension                  based           structure                level 1 dcl 8-11 ref 118
probe_break_mgr_$reset_all_pause_breaks
                                000014 constant        entry                    external dcl 59 ref 94
probe_break_mgr_$reset_break_at_line
                                000016 constant        entry                    external dcl 61 ref 235
probe_error_                    000020 constant        entry                    external dcl 64 ref 138
probe_error_$malfunction        000022 constant        entry                    external dcl 65 ref 29
probe_et_$old_break             000034 external static fixed bin(35,0)          dcl 77 set ref 138*
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000116 automatic       pointer                  dcl 1-86 set ref 90* 94* 98* 107 110 112 113 126 126
                                                                                  126 126 136 138* 145 158 159 160 166 167 170 198
                                                                                  202 202* 202 216 217 219 222 226 226 227 227 230
                                                                                  235* 235 238* 242* 258 259 259 263 263 269* 271
probe_info_version              000010 constant        fixed bin(17,0)          initial dcl 1-88 set ref 98*
probe_listen_$interpret_line    000024 constant        entry                    external dcl 67 ref 238 242
probe_seg_info_                 000026 constant        entry                    external dcl 70 ref 202
probe_segno              46            based           bit(18)                  level 2 dcl 2-8 set ref 126 126
probe_static_info                      based           structure                level 1 dcl 2-8 set ref 259
probe_subsys_util_$create_invocation
                                000030 constant        entry                    external dcl 72 ref 98
probe_subsys_util_$destroy_invocation
                                000032 constant        entry                    external dcl 74 ref 269
proc_entry                6            based           bit(18)                  level 2 packed packed unaligned dcl 7-86 ref 145
procedure_entry                        based           structure                level 1 dcl 7-58
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 set ref 158 159 160 166 167 170 198
                                                                                  202 202 219 226 227 235*
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 ref 226
quick                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 10-38 ref 173
quick_entry                            based           structure                level 1 dcl 12-1
random_info              17            based           structure                level 2 dcl 1-18
real_break_return_loc
                         54            based           pointer                  level 3 dcl 1-18 set ref 217* 263
recursive_breaks_sw      36(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-8 set ref 126
return                                 based           pointer                  level 2 dcl 12-1 ref 178
return_method            22            based           fixed bin(17,0)          level 3 dcl 1-18 set ref 222* 263
return_ptr               24            based           pointer                  level 2 dcl 13-36 set ref 217 219* 263*
runtime_block                          based           structure                level 1 dcl 10-38
seg_info                               based           structure                level 1 dcl 5-9
seg_info_ptr             12            based           pointer                  level 2 dcl 4-13 set ref 202* 227
size                                                   builtin function         dcl 81 ref 118
slot_return_addr         34            based           pointer                  level 2 dcl 8-11 ref 121
source_info                            based           structure                level 1 dcl 4-5
stack_frame                            based           structure                level 1 dcl 13-36
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                 6            based           pointer                  level 2 dcl 4-13 set ref 160*
stackframeptr                                          builtin function         dcl 81 ref 113 115 118
statement_item                         based           structure                level 1 dcl 7-86
statement_item_offset
                          1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-8 ref 143
statement_map                          based           structure                level 1 dcl 11-1
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 126 126
                                                                                  126 126 136 230 259 259
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 4-13 set ref 158*
stp                             000124 automatic       pointer                  dcl 7-180 set ref 143* 145 151 158
switches                 36            based           structure                level 2 dcl 2-8
symbol_block_offset      14            based           bit(18)                  level 2 packed packed unaligned dcl 6-8 ref 164 170
time_stamp              100            based           fixed bin(71,0)          level 2 dcl 7-58 ref 151
unspec                                                 builtin function         dcl 81 set ref 217* 217

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BREAK_AT                               internal static fixed bin(17,0)          initial dcl 6-25
BREAK_INPUT                            internal static fixed bin(17,0)          initial dcl 9-13
BREAK_ITEM                             internal static fixed bin(17,0)          initial dcl 7-172
BRIEF_mode_type                        internal static fixed bin(17,0)          initial dcl 3-35
CONSOLE_INPUT                          internal static fixed bin(17,0)          initial dcl 9-13
ENTRY_AT_BREAK                         internal static fixed bin(17,0)          initial dcl 9-9
ENTRY_AT_CALL                          internal static fixed bin(17,0)          initial dcl 9-9
ENTRY_AT_HALT                          internal static fixed bin(17,0)          initial dcl 9-9
LONG_mode_type                         internal static fixed bin(17,0)          initial dcl 3-35
MACRO_INPUT                            internal static fixed bin(17,0)          initial dcl 9-13
MACRO_ITEM                             internal static fixed bin(17,0)          initial dcl 7-172
PLACE                                  internal static char(8)                  initial array dcl 6-29
PROCEDURE_ITEM                         internal static fixed bin(17,0)          initial dcl 7-172
RETURN_TO_CALLER                       internal static fixed bin(17,0)          initial dcl 9-4
RETURN_TO_CONDITION                    internal static fixed bin(17,0)          initial dcl 9-4
RETURN_TO_FRAME                        internal static fixed bin(17,0)          initial dcl 9-4
SHORT_mode_type                        internal static fixed bin(17,0)          initial dcl 3-35
STATEMENT_ITEM                         internal static fixed bin(17,0)          initial dcl 7-172
SYMBOL_ITEM                            internal static fixed bin(17,0)          initial dcl 7-172
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 13-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 13-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 13-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 13-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 13-27
TRA_code                               internal static bit(18)                  initial packed unaligned dcl 7-184
TSPLB_code                             internal static bit(18)                  initial packed unaligned dcl 7-184
after_slot_ptr                         automatic       pointer                  dcl 7-180
before_slot_ptr                        automatic       pointer                  dcl 7-180
bmp                                    automatic       pointer                  dcl 7-180
break_map                              based           structure                level 1 dcl 7-34
break_segment                          based           structure                level 1 dcl 7-22
break_segp                             automatic       pointer                  dcl 7-32
break_slot_after                       based           structure                level 1 dcl 7-139
break_slot_before                      based           structure                level 1 dcl 7-112
command_list_size                      automatic       fixed bin(21,0)          dcl 7-178
encoded_value                          based           structure                level 1 dcl 10-70
expression_area                        based           area(1024)               dcl 1-95
free_item                              based           structure                level 1 dcl 7-52
item                                   based           structure                level 1 dcl 7-46
macro_item                             based           structure                level 1 dcl 7-102
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_modes                            based           structure                level 1 dcl 3-14
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
runtime_bound                          based           structure                level 1 unaligned dcl 10-33
runtime_symbol                         based           structure                level 1 dcl 10-3
runtime_token                          based           structure                level 1 dcl 10-63
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 5-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
size_of_after_sequence                 internal static fixed bin(17,0)          initial dcl 7-168
size_of_before_sequence                internal static fixed bin(17,0)          initial dcl 7-169
sp                                     automatic       pointer                  dcl 13-31
stack_frame_flags                      based           structure                level 1 dcl 13-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 13-33
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
BREAK_TYPE_1_RETURNS            000603 constant        label                    dcl 246 ref 110 112
IGNORE_BREAK                    000310 constant        label                    dcl 153 ref 107 126 149
clean_things_up                 000611 constant        entry                    internal dcl 255 ref 95 103 153 246
probe_break_handler_            000047 constant        entry                    external dcl 25
probe_break_handler_$break_type_1
                                000064 constant        entry                    external dcl 85

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1140        1176     711        1150
Length      1660     711        36         445     227           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_break_handler_                134 external procedure  is an external procedure.  
on unit on line 92                   68 on unit               
clean_things_up                      94 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_break_handler_     000100 bp                          probe_break_handler_
                         000102 p                           probe_break_handler_
                         000104 code                        probe_break_handler_
                         000106 callers_frame               probe_break_handler_
                         000116 probe_info_ptr              probe_break_handler_
                         000120 bsp                         probe_break_handler_
                         000122 ent                         probe_break_handler_
                         000124 stp                         probe_break_handler_
                         000126 SPRI_wd                     probe_break_handler_
                         000130 break_extension_info_ptr    probe_break_handler_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      iox_$control                  probe_break_mgr_$reset_all_pause_breaks
probe_break_mgr_$reset_break_at_line                        probe_error_                  probe_error_$malfunction
probe_listen_$interpret_line  probe_seg_info_               probe_subsys_util_$create_invocation
probe_subsys_util_$destroy_invocation

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$old_break




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7  182 000042        25 000046        29 000055        85 000062        90 000072        92 000074        94 000110
     95 000117        96 000124        98 000125       100 000140       101 000142       103 000170       104 000174
    107 000175       110 000201       112 000204       113 000207       115 000211       118 000213       121 000216
    126 000220       136 000234       138 000237       141 000260       143 000265       145 000272       149 000300
    151 000304       153 000310       155 000314       158 000315       159 000320       160 000325       164 000330
    166 000335       167 000340       168 000344       170 000345       173 000353       174 000356       175 000360
    176 000364       178 000367       180 000372       185 000376       189 000407       191 000413       193 000421
    195 000425       196 000426       198 000431       202 000434       216 000455       217 000460       219 000466
    222 000472       226 000474       227 000501       230 000503       233 000506       235 000514       238 000536
    240 000560       242 000561       246 000603       248 000607       255 000610       258 000616       259 000623
    263 000636       269 000645       271 000653       273 000706


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
