	COMPILATION LISTING OF SEGMENT mrds_dm_close
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1344.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1976 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /* DESCRIPTION:
       20*
       21*   This procedure closes a data model that  has  been  opened  by  a
       22*   previous call to either the dmd_ or the mmi_ opening entry.
       23*
       24*   There are three entries. mrds_dm_close for use by internal  mrds.
       25*   close_dm  for  external use by dmd_. close_model for external use
       26*   bu mmi_. The external entries check for the user be a DBA if  the
       27*   database is secured.
       28*
       29**/
       30 
       31 /* PARAMETERS:
       32*
       33*   data_model_ptr - - (input) ptr, for the mrds_dm_close and close_dm entries,
       34*   the pointer returned by a call to dmd_$open
       35*
       36*   open_name - - (input) char(*), for the close_model entry,
       37*   the open name used in the call to mmi_$open_model
       38*
       39*   code - - (output) fixed bin (35), the error status encoding
       40*
       41**/
       42 
       43 /* HISTORY:
       44*
       45*   Modified by J. A. Weeldreyer to  add  abort  entry  --  November,
       46*   1976.
       47*
       48*   Modified by Oris Friesen to accomodate new version data bases  --
       49*   October 1978
       50*
       51*   Modified by R. Lackey June 1979 to ad mode to get_opening
       52*
       53*   Modified by Jim Gray - - Feb. 1980, to call the  old  version  of
       54*   close_dm,  if  the  data_model_ptr  points  to an iocb_ptr in the
       55*   area_linker, since this means data_model vfile of the old version
       56*   was used.
       57*
       58*   81-02-12 Jim Gray : added  need  for  caller  to  be  DBA  if  db
       59*   secured, and call made to external dmd_$close_dm which should not
       60*   be used by mrds. internal mrds should only call rmds_dm_close.
       61*
       62*   81-04-22 Jim Gray : added close_model entry for mmi_, and removed
       63*   use   of   mrds_dm_open_table_mgr   to   remove   opening  number
       64*   restrictions.
       65*
       66*   83-06-21 Davids: Removed check for old version database and the call
       67*   to v1 code if it was an old version db (old version dbs can no longer
       68*   be opened)
       69**/
       70 
       71 /* BEGIN CHANGE 81-02-12 *********************************************** */
       72 
       73 mrds_dm_close: procedure (data_model_ptr_a, code_a);
       74 
       75 /* entry to be used by internal mrds calls */
       76 
       77 	internal_call = "1"b;
       78 
       79 	data_model_ptr = data_model_ptr_a;
       80 
       81 	call common ();
       82 
       83 	code_a = code;
       84 
       85 	return;
       86 
       87 
       88 
       89 
       90 close_dm: entry (data_model_ptr_b, code_b);
       91 
       92 /* entry to be used by external dmd_ callers,
       93*   user must be a DBA if db is secured */
       94 
       95 	internal_call = "0"b;
       96 
       97 	data_model_ptr = data_model_ptr_b;
       98 
       99 	call common ();
      100 
      101 	code_b = code;
      102 
      103 	return;
      104 
      105 /* END CHANGE 81-02-12 ******************************************** */
      106 
      107 /* BEGIN CHANGE 81-04-22 ********************************************** */
      108 
      109 close_model: entry (open_name, code_c);
      110 
      111 /* this entry closes a model that has been opened by a call to
      112*   mmi_$open_model, by disassociating the open name from the model pointer
      113*   It uses the close_dm entry so that the user must be a DBA,
      114*   if the database has been secured. */
      115 
      116 	call mu_open_name_manager$get_model_pointer (open_name, model_type, model_ptr, code_c);
      117 	if code_c = 0 then do;
      118 
      119 		call close_dm (model_ptr, code_c);
      120 		if code_c = 0 then do;
      121 
      122 			call mu_open_name_manager$delete_open_name (open_name, code_c);
      123 
      124 		     end;
      125 
      126 	     end;
      127 
      128 	return;
      129 
      130 /* END CHANGE 81-04-22 *********************************************** */
      131 
      132 common: procedure ();
      133 
      134 	code = 0;
      135 	call hcs_$fs_get_path_name (data_model_ptr, db_path, ldn, model_name, code);
      136 	if code ^= 0 then goto exit;
      137 
      138 /* check for user being a DBA if database is secured */
      139 
      140 	if ^internal_call then
      141 	     call secured_db_check ();
      142 
      143 exit:	return;
      144 
      145      end;
      146 
      147 /* BEGIN CHANGE 81-02-12 ********************************************* */
      148 
      149 secured_db_check: procedure ();
      150 
      151 /* routine to check for the database being is a secured state,
      152*   and if so, that the user is a DBA, and thus may use the external entry */
      153 
      154 	if code ^= 0 then ;
      155 	else if internal_call then ;
      156 	else do;
      157 
      158 /* get the secured state of the dataabase */
      159 
      160 		call mrds_dm_db_secured$get_secured_status (data_model_ptr, addr (local_area),
      161 		     database_state_structure_version, database_state_ptr, code);
      162 		if code ^= 0 then
      163 
      164 		     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      165 			"Unable to get the secured state of database """, db_path, """.");
      166 
      167 		else if ^database_state.secured then ;
      168 		else do;
      169 
      170 /* database secured, see if the user is a DBA */
      171 
      172 			call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      173 			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      174 			if code ^= 0 then
      175 
      176 			     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      177 				"Unable to get user class for database """, db_path, """.");
      178 
      179 			else if mrds_authorization.administrator then ;
      180 			else do;
      181 
      182 /* not DBA on secured db, issue error */
      183 
      184 				code = error_table_$insufficient_access;
      185 				call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a ^a",
      186 				     "The database """, db_path, """ has been secured,",
      187 				     "so the caller must be a DBA to use direct model access.");
      188 
      189 			     end;
      190 
      191 		     end;
      192 
      193 	     end;
      194 
      195 	if code ^= 0 then
      196 	     data_model_ptr = null ();
      197 
      198      end;
      199 
      200 /* END CHANGE 81-02-12 ************************************************ */
      201 
      202 	declare NULL_OFFSET		 bit (18) init ((18)"1"b); /* mrds version of null offset */
      203 	declare caller_name		 char (32) init ("mrds_dm_open"); /* name of calling routine */
      204 	declare code		 fixed bin (35);	/* a standard Multics system status code */
      205 	declare code_a		 fixed bin (35);	/* temp for mrds_dm_close entry */
      206 	declare code_b		 fixed bin (35);	/* temp for close_dm entry */
      207 	declare code_c		 fixed bin (35);	/* error code for the close_model entry */
      208 	declare continue		 char (1) init ("c"); /* dont stop after print mesg */
      209 	declare data_model_ptr	 ptr;		/* pointer to the data_model to be closed */
      210 	declare data_model_ptr_a	 ptr;		/* temp for rmds_dm_close entry */
      211 	declare data_model_ptr_b	 ptr;		/* temp for close_dm entry */
      212 	declare db_path		 char (168);
      213 	declare error_table_$insufficient_access fixed bin (35) ext; /* not DBA and db secured */
      214 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      215 	declare info_ptr		 ptr init (null ());/* unused */
      216 	declare internal_call	 bit (1);		/* on => called from mrds, not by dmd_ */
      217 	declare ldn		 fixed bin;
      218 	declare local_area		 area (1024);	/* space for db state, and user class info */
      219 	declare mu_open_name_manager$delete_open_name entry (char (*), fixed bin (35)); /* disassociates open name */
      220 	declare mu_open_name_manager$get_model_pointer entry (char (*), char (1), ptr, fixed bin (35)); /* gets model ptr from open name */
      221 	declare model_name		 char (32);
      222 	declare model_ptr		 ptr;
      223 	declare model_type		 char (1);	/* type of opening */
      224 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if DBA */
      225 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
      226 	declare open_name		 char (*);	/* opening association name */
      227 	declare return_value	 fixed bin (35) init (0); /* unused */
      228 	declare sub_err_		 entry options (variable); /* reports errors */
      229 	declare (addr, empty, null, rtrim) builtin;
      230 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      231 
      232 
  2     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  2     6*
  2     7**/
  2     8 
  2     9 /* DESCRIPTION:
  2    10*
  2    11*   this structure returns the callers user_class
  2    12*   either database administrator or normal user.
  2    13*   Note that these separate classes were used to allow
  2    14*   future expansion to the user classes, rather than
  2    15*   make them logical "not"'s of one another.
  2    16*   NOTE: a DBA is always also a normal user, thus if the caller
  2    17*   is a DBA, his normal_user bit will be on also.
  2    18*
  2    19**/
  2    20 
  2    21 
  2    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  2    23         2 version fixed bin,				/* version number of this structure */
  2    24         2 administrator bit (1) unal,			/* caller is a DBA */
  2    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  2    26         2 mbz bit (34) unal ;
  2    27 
  2    28 
  2    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  2    30 
  2    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  2    32 
  2    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      233 
      234 
  3     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  3     6*
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   This structure returns the database state (secured or unsecured)
  3    12*   for determining how commands and subroutines will behave for each case.
  3    13*   The secured bit was kept separate from the unsecured,
  3    14*   rather than it's logical "not", to allow for future extensibility
  3    15*   of database secured states.
  3    16*
  3    17**/
  3    18 
  3    19 
  3    20 declare 1 database_state aligned based (database_state_ptr),
  3    21         2 version fixed bin,				/* version number of this structure */
  3    22         2 unsecured bit (1) unal,			/* database not secured */
  3    23         2 secured bit (1) unal,			/* database has been secured */
  3    24         2 mbz bit (34) unal ;
  3    25 
  3    26 
  3    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  3    28 
  3    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  3    30 
  3    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      235 
      236 
      237      end mrds_dm_close;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1145.0  mrds_dm_close.pl1                 >special_ldd>install>MR12.0-1187>mrds_dm_close.pl1
231          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
233          2    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
235          3    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFFSET                     000100 automatic       bit(18)                  initial unaligned dcl 202 set ref 202*
addr                                                   builtin function         dcl 229 ref 160 160 172 172
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 2-22 ref 179
caller_name                     000101 automatic       char(32)                 initial unaligned dcl 203 set ref 162* 174* 185*
                                                                                  203*
code                            000111 automatic       fixed bin(35,0)          dcl 204 set ref 83 101 134* 135* 136 154 160* 162
                                                                                  162* 172* 174 174* 184* 185* 195
code_a                                 parameter       fixed bin(35,0)          dcl 205 set ref 73 83*
code_b                                 parameter       fixed bin(35,0)          dcl 206 set ref 90 101*
code_c                                 parameter       fixed bin(35,0)          dcl 207 set ref 109 116* 117 119* 120 122*
continue                        000112 automatic       char(1)                  initial unaligned dcl 208 set ref 162* 174* 185*
                                                                                  208*
data_model_ptr                  000114 automatic       pointer                  dcl 209 set ref 79* 97* 135* 160* 195*
data_model_ptr_a                       parameter       pointer                  dcl 210 ref 73 79
data_model_ptr_b                       parameter       pointer                  dcl 211 ref 90 97
database_state                         based           structure                level 1 dcl 3-20
database_state_ptr              002212 automatic       pointer                  dcl 3-27 set ref 160* 167
database_state_structure_version
                                000020 constant        fixed bin(17,0)          initial dcl 3-29 set ref 160*
db_path                         000116 automatic       char(168)                unaligned dcl 212 set ref 135* 162* 172 172 174*
                                                                                  185*
empty                                                  builtin function         dcl 229 ref 218
error_table_$insufficient_access
                                000010 external static fixed bin(35,0)          dcl 213 ref 184
hcs_$fs_get_path_name           000012 constant        entry                    external dcl 214 ref 135
info_ptr                        000170 automatic       pointer                  initial dcl 215 set ref 162* 174* 185* 215*
internal_call                   000172 automatic       bit(1)                   unaligned dcl 216 set ref 77* 95* 140 155
ldn                             000173 automatic       fixed bin(17,0)          dcl 217 set ref 135*
local_area                      000174 automatic       area(1024)               dcl 218 set ref 160 160 172 172 218*
model_name                      002174 automatic       char(32)                 unaligned dcl 221 set ref 135*
model_ptr                       002204 automatic       pointer                  dcl 222 set ref 116* 119*
model_type                      002206 automatic       char(1)                  unaligned dcl 223 set ref 116*
mrds_authorization                     based           structure                level 1 dcl 2-22
mrds_authorization_ptr          002210 automatic       pointer                  dcl 2-29 set ref 172* 179
mrds_authorization_structure_version
                                000020 constant        fixed bin(17,0)          initial dcl 2-31 set ref 172*
mrds_dm_authorization$get_user_class
                                000020 constant        entry                    external dcl 224 ref 172
mrds_dm_db_secured$get_secured_status
                                000022 constant        entry                    external dcl 225 ref 160
mu_open_name_manager$delete_open_name
                                000014 constant        entry                    external dcl 219 ref 122
mu_open_name_manager$get_model_pointer
                                000016 constant        entry                    external dcl 220 ref 116
null                                                   builtin function         dcl 229 ref 195 215
open_name                              parameter       char                     unaligned dcl 226 set ref 109 116* 122*
return_value                    002207 automatic       fixed bin(35,0)          initial dcl 227 set ref 162* 174* 185* 227*
rtrim                                                  builtin function         dcl 229 ref 172 172
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 3-20 ref 167
sub_err_                        000024 constant        entry                    external dcl 228 ref 162 174 185

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
db_model                               based           structure                level 1 dcl 1-72
dbm_ptr                                automatic       pointer                  dcl 1-106
di_ptr                                 automatic       pointer                  dcl 1-155
domain_info                            based           structure                level 1 dcl 1-125
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
close_dm                        000160 constant        entry                    external dcl 90 ref 119
close_model                     000204 constant        entry                    external dcl 109
common                          000304 constant        entry                    internal dcl 132 ref 81 99
exit                            000344 constant        label                    dcl 143 ref 136
mrds_dm_close                   000135 constant        entry                    external dcl 73
secured_db_check                000345 constant        entry                    internal dcl 149 ref 140

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1110        1136     732        1120
Length      1400     732        26         226     155           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_close                      1336 external procedure  is an external procedure.  
common                                  internal procedure  shares stack frame of external procedure mrds_dm_close.  
secured_db_check                        internal procedure  shares stack frame of external procedure mrds_dm_close.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_close            000100 NULL_OFFSET                 mrds_dm_close
                         000101 caller_name                 mrds_dm_close
                         000111 code                        mrds_dm_close
                         000112 continue                    mrds_dm_close
                         000114 data_model_ptr              mrds_dm_close
                         000116 db_path                     mrds_dm_close
                         000170 info_ptr                    mrds_dm_close
                         000172 internal_call               mrds_dm_close
                         000173 ldn                         mrds_dm_close
                         000174 local_area                  mrds_dm_close
                         002174 model_name                  mrds_dm_close
                         002204 model_ptr                   mrds_dm_close
                         002206 model_type                  mrds_dm_close
                         002207 return_value                mrds_dm_close
                         002210 mrds_authorization_ptr      mrds_dm_close
                         002212 database_state_ptr          mrds_dm_close

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_in         call_ext_out_desc   call_ext_out        return_mac          shorten_stack
ext_entry           ext_entry_desc      op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$fs_get_path_name         mrds_dm_authorization$get_user_class
mrds_dm_db_secured$get_secured_status                       mu_open_name_manager$delete_open_name
mu_open_name_manager$get_model_pointer                      sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$insufficient_access




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    202 000112       203 000114       208 000117       215 000121       218 000123       227 000126        73 000131
     77 000143        79 000145        81 000151        83 000152        85 000155        90 000156        95 000166
     97 000167        99 000173       101 000174       103 000177       109 000200       116 000220       117 000247
    119 000252       120 000262       122 000265       128 000303       132 000304       134 000305       135 000306
    136 000337       140 000341       143 000344       149 000345       154 000346       155 000351       160 000354
    162 000375       167 000457       172 000464       174 000536       179 000621       184 000626       185 000631
    195 000725       198 000731


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
