	COMPILATION LISTING OF SEGMENT rlm_put_tuple
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/06/86  1302.1 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: style2,ind3 */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-02-04,Spitzer), approve(86-02-27,MCR7349),
       12*     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
       13*     Added the list entry which puts multiple tuples. This is the target
       14*     of relation_manager_$put_tuples.  Also changed the "s" to
       15*     ACTION_CANT_RESTART in each sub_err_ call.
       16*  2) change(86-04-24,Pierret), approve(86-04-24,MCR7349),
       17*     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
       18*     In response to audit comments:
       19*      (1) Added declaration for hbound.
       20*      (2) Changed rlm_put_tuple proc statement to rlm_put_tuple$list.
       21*      (3) Removed dm_range_constants.incl.pl1.
       22*      (4) Declared "constants" as options(constant).
       23*      (5) Used %page instead of FormFeed.
       24*      (6) Added CHECK_PTR_NULL routine to check if pointers are null. Also
       25*      (7) Added null pointer check for relation_cursor_ptr in $list.
       26*      (8) Added use of ERROR_RETURN after call to rlm_opening_info$get.
       27*      (9) Made all returns go through RETURN procedure.
       28*      (10) Moved allocation of simple_typed_vector into INITIALIZE so that only
       29*           one is allocated instead of one for each tuple put.
       30*      (11) Verified type of simple_typed_vector.
       31*      (12) Added freeing of search_specification to FINISH procedure.
       32*  3) change(86-04-25,Pierret), approve(86-04-25,MCR7349),
       33*     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
       34*     More audit changes:  Added SETUP_CURSORS and SETUP_VECTOR, both called
       35*     from the main procedure after the cleanup handler is established, which
       36*     setup record and index cursors and allocate the simple_typed_vector for
       37*     later use.  Previously cursors were being set up in each invocation of
       38*     PUT_SINGLE_TUPLE and the simple_typed_vector was being alloated before the
       39*     cleanup handler was established.  Also moved the cleanup establishment
       40*     from PUT_SINGLE_TUPLE to the main procedure immediately after each call to
       41*     INITIALIZE.  Removed the SET_RECORD_COLLECTION_CURSOR_PTR and
       42*     SET_CURSOR_PTR_FOR_THIS_INDEX routines, incorporating them into
       43*     SETUP_CURSORS.
       44*     Removed declaration of unused constants.
       45*     Changed the FormFeed in the history section to the literal "FormFeed".
       46*     Changed the call to CHECK_PTR_NULL in $list tuple loop to use the name
       47*     "typed_vector_list.vector_ptr("||ltrim(char(tuple_loop))||")" instead of
       48*     "input_typed_vector_ptr".
       49*                                                   END HISTORY COMMENTS */
       50 
       51 
       52 /* DESCRIPTION
       53*
       54*   This module implements the relation_manager_ entries
       55*   put_tuple and put_tuples.  In both cases if an error other
       56*   than dm_error_$key_duplication is encountered it is the
       57*   responsibility of the caller to roll back the transaction in
       58*   order to restore the relation to a consistent state.  If a
       59*   key duplication is encountered - which is not a real error -
       60*   this module rolls back any modifications it may have made in
       61*   storing the tuple which encounterd the key duplication.  In
       62*   the case of the list entry, processing stops when a key
       63*   duplication occurs, leaving the prior tuples stored intact
       64*   and returning to the caller a list of tuple_ids for the
       65*   tuples stored.
       66*   
       67*   In order to store the keys a simple_typed_vector must be
       68*   built to hold the values of the fields in the key plus a
       69*   field for the tuple id.  One vector is allocated large enough
       70*   to hold all of the attributes in the tuple plus 1 for the
       71*   tuple id.  This then is large enough to hold the largest
       72*   possible key.  Before each key is built,
       73*   simple_typed_vector.value_ptr(*) is set to null.  While
       74*   building the key value_ptrs are set to point to the
       75*   appropriate value supplied in the input_simple_typed_vector
       76*   which describes the tuple being stored.  Those that are left
       77*   null are ignored by the index_manager_ when the key is put.
       78*   When the simple_typed_vector is freed the values to which it
       79*   points must not also be freed as they are under the control
       80*   of the caller.
       81*   
       82*   During ROLLBACK a search_specification is built to identify
       83*   the keys which must be deleted.  Again the values used are
       84*   the values supplied by the caller.  When the specification is
       85*   freed the values to which it points must not also be freed as
       86*   the values are under the control of the caller.
       87*
       88*   There are three ways to exit this module.  Normal exit is by
       89*   calling the RETURN routine which does a non-local goto to the 
       90*   label MAIN_RETURN which returns.  Most error exits are by
       91*   calling the ERROR_RETURN routine which sets the error code and
       92*   calls the RETURN routine.  Programming errors are reported via
       93*   sub_err_.  Currently the programming errors detected deal with
       94*   bad arguments supplied by the caller: null pointers and incorrect
       95*   versions of structures.
       96**/
       97 
       98 /* HISTORY PRIOR TO MR11 INSTALLATION:
       99*Written by Matthew Pierret, 05/03/82.
      100*Modified:
      101*09/30/82 by Matthew Pierret:  Changed to use the area pointed to by 
      102*            dm_data_$area_ptr.
      103*10/13/82 by Matthew Pierret:  Changed to correctly set the number_of_dimensions
      104*            in simple_typed_vector before calling im_put_key.
      105*12/07/82 by Lindsey Spratt:  Changed to initialize the simple_typed_vector_ptr
      106*	  to null.
      107*02/01/83 by Lindsey Spratt:  Changed to convert dm_error_$key_duplication to
      108*	  mrds_error_$dup_store for external consumption.
      109*03/04/83 by Matthew Pierret: Changed to use the structures attribute_info,
      110*            relation_opening_info, and index_attribute_map instead of the
      111*            previously kept relation_info structure. Changed CHECK_VERSION
      112*            CHECK_VERSION_FB, and added a new CHECK_VERSION which checks
      113*            char(8)aligned versions. Removed references to dm_data$area_ptr.
      114*            The subroutine get_dm_free_area_ is used to get the pointer to 
      115*            the dm_area; this pointer (dm_area_ptr) is "internal static"
      116*            to reduce on the number of calls to get_dm_free_area_.
      117*03/10/83 by Matthew Pierret: Changed to not assume that all entries in 
      118*            index_attribute_map contain an index.
      119*05/23/83 by Matthew Pierret: Changed to use a relation_cursor. Added an
      120*            ERROR_RETURN subroutine and replaced the 
      121*            "do;call FINISH;return;end" cliche with "call ERROR_RETURN (code)"
      122*            Added a cleanup handler.
      123*06/27/83 by Lindsey L. Spratt:  Changed to use the version 2 relation_cursor.
      124*           Fixed the ROLLBACK procedure to delete keys for the current tuple
      125*            when a keydup is found.
      126*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.
      127**/
      128 
      129 rlm_put_tuple$list:
      130    proc (p_relation_cursor_ptr, p_typed_vector_list_ptr, p_element_id_list_ptr, p_number_of_tuples_put, p_code);
      131 
      132 
      133 /* START OF DECLARATIONS */
      134 /* Parameter */
      135 
      136       dcl	    p_typed_vector_ptr     ptr;
      137       dcl	    p_typed_vector_list_ptr
      138 			       ptr;
      139       dcl	    p_element_id_list_ptr  ptr;
      140       dcl	    p_number_of_tuples_put fixed bin (35);
      141       dcl	    p_relation_cursor_ptr  ptr;
      142       dcl	    p_tuple_id	       bit (36) aligned;
      143       dcl	    p_code	       fixed bin (35);
      144 
      145 /* Automatic */
      146 
      147       dcl	    input_simple_typed_vector_ptr
      148 			       ptr;
      149       dcl	    (record_collection_cursor_ptr, index_cursor_ptr)
      150 			       ptr init (null);
      151       dcl	    key_field_idx	       fixed bin;
      152       dcl	    index_idx	       fixed bin;
      153       dcl	    tuple_id	       bit (36) aligned;
      154       dcl	    tuple_loop	       fixed bin (35);
      155 
      156 /* Based */
      157 
      158       dcl	    dm_area	       area (sys_info$max_seg_size) based (dm_area_ptr);
      159 
      160 /* Builtin */
      161 
      162       dcl	    (addr, char, hbound, ltrim, null)
      163 			       builtin;
      164 
      165 /* Condition */
      166 
      167       dcl	    cleanup	       condition;
      168 
      169 /* Constant */
      170 
      171       dcl	    myname	       init ("rlm_put_tuple") char (32) varying internal static options (constant);
      172       dcl	    RANDOM_RECORD_ID       init ("000000000000"b3) bit (36) aligned internal static options (constant);
      173 
      174 /* Entry */
      175 
      176       dcl	    get_dm_free_area_      entry () returns (ptr);
      177       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      178       dcl	    index_manager_$put_key entry (ptr, ptr, fixed bin (35));
      179       dcl	    index_manager_$create_cursor
      180 			       entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
      181       dcl	    sub_err_	       entry () options (variable);
      182 
      183 /* External */
      184 
      185       dcl	    error_table_$bad_arg   ext fixed bin (35);
      186       dcl	    dm_error_$key_duplication
      187 			       ext fixed bin (35);
      188       dcl	    error_table_$unimplemented_version
      189 			       ext fixed bin (35);
      190       dcl	    sys_info$max_seg_size  ext fixed bin (35);
      191 
      192 /* Static */
      193 
      194       dcl	    dm_area_ptr	       ptr static init (null);
      195 
      196 /* END OF DECLARATIONS */
      197 
      198 /* format: ^indblkcom,indcomtxt */
      199 
      200 /* Entry statement repeated for reader.
      201*
      202*   list: entry
      203*   (p_relation_cursor_ptr, p_typed_vector_list_ptr, p_element_id_list_ptr, p_number_of_tuples_put, p_code);
      204*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   */
      205       p_code = 0;
      206       p_number_of_tuples_put = 0;
      207 
      208       relation_cursor_ptr = p_relation_cursor_ptr;
      209       call CHECK_PTR_NULL ("relation_cursor_ptr", relation_cursor_ptr);
      210       call CHECK_VERSION ("relation_cursor", (relation_cursor.version), (RELATION_CURSOR_VERSION_2));
      211 
      212       typed_vector_list_ptr = p_typed_vector_list_ptr;
      213       call CHECK_PTR_NULL ("typed_vector_list_ptr", typed_vector_list_ptr);
      214       call CHECK_VERSION_FB ("typed_vector_list", (typed_vector_list.version), (TYPED_VECTOR_LIST_VERSION_1));
      215 
      216       element_id_list_ptr = p_element_id_list_ptr;
      217       call CHECK_PTR_NULL ("element_id_list_ptr", element_id_list_ptr);
      218       call CHECK_VERSION_FB ("element_id_list", element_id_list.version, ELEMENT_ID_LIST_VERSION_1);
      219       if element_id_list.number_of_elements < typed_vector_list.number_of_vectors
      220       then call sub_err_ (error_table_$bad_arg, myname, ACTION_CANT_RESTART, null, 0,
      221 	      "There were not enough entries in the element_id_list structure to contain the tuple id's of the tuples stored."
      222 	      );
      223 
      224       call INITIALIZE;
      225 
      226       on cleanup call FINISH;
      227 
      228       call SETUP_CURSORS;
      229       call SETUP_VECTOR;
      230 
      231       element_id_list.id (*) = "0"b;
      232 
      233       do tuple_loop = 1 to typed_vector_list.number_of_vectors;
      234          input_simple_typed_vector_ptr = typed_vector_list.vector_ptr (tuple_loop);
      235 
      236          call CHECK_PTR_NULL ("typed_vector_list.vector_ptr(" || ltrim (char (tuple_loop)) || ")",
      237 	    input_simple_typed_vector_ptr);
      238 
      239          call CHECK_VERSION_FB ("simple_typed_vector", (input_simple_typed_vector_ptr -> simple_typed_vector.type),
      240 	    (SIMPLE_TYPED_VECTOR_TYPE));
      241 
      242          call PUT_SINGLE_TUPLE;
      243          element_id_list.id (tuple_loop) = tuple_id;
      244 
      245          p_number_of_tuples_put = p_number_of_tuples_put + 1;
      246       end;					/* do tuple_loop */
      247 
      248       call RETURN;
      249 
      250 single:
      251    entry (p_relation_cursor_ptr, p_typed_vector_ptr, p_tuple_id, p_code);
      252 
      253 
      254       p_code = 0;
      255       p_tuple_id = "0"b;
      256 
      257       input_simple_typed_vector_ptr = p_typed_vector_ptr;
      258       call CHECK_PTR_NULL ("typed_vector_ptr", input_simple_typed_vector_ptr);
      259       call CHECK_VERSION_FB ("simple_typed_vector", (input_simple_typed_vector_ptr -> simple_typed_vector.type),
      260 	 (SIMPLE_TYPED_VECTOR_TYPE));
      261 
      262       relation_cursor_ptr = p_relation_cursor_ptr;
      263       call CHECK_PTR_NULL ("relation_cursor_ptr", relation_cursor_ptr);
      264       call CHECK_VERSION ("relation_cursor", (relation_cursor.version), (RELATION_CURSOR_VERSION_2));
      265 
      266       call INITIALIZE;
      267 
      268       on cleanup call FINISH;
      269 
      270       call SETUP_CURSORS;
      271       call SETUP_VECTOR;
      272 
      273       call PUT_SINGLE_TUPLE;
      274 
      275       p_tuple_id = tuple_id;
      276 
      277       call RETURN ();
      278 
      279 MAIN_RETURN:
      280       return;
      281 
      282 RETURN:
      283    proc ();
      284       call FINISH ();
      285       goto MAIN_RETURN;
      286    end RETURN;
      287 
      288 
      289 ERROR_RETURN:
      290    proc (er_code);
      291 
      292       dcl	    er_code	       fixed bin (35);
      293 
      294       p_code = er_code;
      295       call RETURN;
      296 
      297    end ERROR_RETURN;
      298 
      299 PUT_SINGLE_TUPLE:
      300    proc ();
      301 
      302 /*  Put the tuple in the record collection. */
      303 
      304       call record_manager_$put_record_by_id (RANDOM_RECORD_ID, input_simple_typed_vector_ptr,
      305 	 (0) /* relation_header.minimum_free_space */, record_collection_cursor_ptr, tuple_id, p_code);
      306       if p_code ^= 0
      307       then call ERROR_RETURN (p_code);
      308 
      309    /*** Store a key for this tuple for each index in the relation.  Construct
      310*        the keys based on the values in the input_simple_typed_vector.  If
      311*        a duplication error results, back out the modifications by deleting the
      312*        keys and tuple already stored. */
      313 
      314 
      315 PUT_KEY_FOR_EACH_INDEX_LOOP:
      316       do index_idx = 1 to index_attribute_map.number_of_indices;
      317          if index_attribute_map.index (index_idx).number_of_attributes > 0
      318          then
      319 	  do;
      320 	     simple_typed_vector.number_of_dimensions = index_attribute_map.index (index_idx).number_of_attributes + 1;
      321 	     simple_typed_vector.value_ptr = null;
      322 	     do key_field_idx = 1 to index_attribute_map.index (index_idx).number_of_attributes;
      323 	        simple_typed_vector.value_ptr (key_field_idx) =
      324 		   input_simple_typed_vector_ptr
      325 		   -> simple_typed_vector
      326 		   .value_ptr (index_attribute_map.index (index_idx).attribute_id (key_field_idx));
      327 	     end;
      328 
      329 	     simple_typed_vector.value_ptr (key_field_idx) = addr (tuple_id);
      330 						/* The last field is always the tuple id */
      331 
      332 	     index_cursor_ptr = index_cursor_array.cursor_ptr (index_idx);
      333 
      334 	     call index_manager_$put_key (simple_typed_vector_ptr, index_cursor_ptr, p_code);
      335 	     ;
      336 	     if p_code ^= 0
      337 	     then
      338 	        do;
      339 		 if p_code = dm_error_$key_duplication
      340 		 then call ROLLBACK (index_idx - 1);
      341 		 call ERROR_RETURN (p_code);
      342 	        end;
      343 	  end;
      344 
      345       end PUT_KEY_FOR_EACH_INDEX_LOOP;
      346 
      347       return;
      348    end PUT_SINGLE_TUPLE;
      349 
      350 INITIALIZE:
      351    proc ();
      352 
      353       if dm_area_ptr = null
      354       then dm_area_ptr = get_dm_free_area_ ();
      355 
      356 /* Get and verify the opening info structures necessary for this operation. */
      357 
      358       call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, p_code);
      359       if p_code ^= 0
      360       then call ERROR_RETURN (p_code);			/* relation isn't open */
      361 
      362       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      363 
      364       relation_header_ptr = relation_opening_info.relation_header_ptr;
      365       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      366 
      367       index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      368       call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      369 
      370       index_cursor_array_ptr = relation_opening_info.per_process.index_cursor_array_ptr;
      371       call CHECK_VERSION ("index_cursor_array", index_cursor_array.version, INDEX_CURSOR_ARRAY_VERSION_1);
      372 
      373       search_specification_ptr = null;			/* for FINISH */
      374       simple_typed_vector_ptr = null;			/* for FINISH */
      375       record_collection_cursor_ptr = null;		/* for FINISH */
      376 
      377       return;
      378    end INITIALIZE;
      379 
      380 
      381 FINISH:
      382    proc ();
      383 
      384       if simple_typed_vector_ptr ^= null
      385       then free simple_typed_vector in (dm_area);
      386 
      387       if search_specification_ptr ^= null ()
      388       then free search_specification in (dm_area);
      389 
      390       if record_collection_cursor_ptr ^= null
      391       then call record_manager_$destroy_cursor (record_collection_cursor_ptr, (0));
      392 
      393    end FINISH;
      394 
      395       ;
      396 ROLLBACK:
      397    proc (rb_p_number_of_keys);
      398 
      399       dcl	    rb_p_number_of_keys    fixed bin;
      400       dcl	    rb_index_idx	       fixed bin (17);
      401       dcl	    rb_key_field_idx       fixed bin (17);
      402       dcl	    rb_code	       fixed bin (35);
      403       dcl	    rb_index_cursor_ptr    ptr;
      404       dcl	    index_manager_$delete_key
      405 			       entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
      406 
      407       ss_number_of_and_groups = 1;
      408       ss_maximum_number_of_constraints = index_attribute_map.maximum_number_of_attributes_per_index + 1;
      409       alloc search_specification in (dm_area);
      410       search_specification.head.version = SPECIFICATION_VERSION_4;
      411       search_specification.head.subset_specification_ptr = null;
      412       search_specification.head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE;
      413       search_specification.head.pad = "0"b;
      414 
      415 /* Set the operator code to "=" for all constraints. */
      416 
      417       search_specification.and_group (1).constraint (*).operator_code = EQUAL_OPERATOR_CODE;
      418       search_specification.and_group (1).constraint (*).value_field_id = -1;
      419 
      420 /* All of the key searches have the same record id, so the value ptr is set
      421*   outside of the RB_INDEX_LOOP.  The field_id of the record id field changes
      422*   for each index, so this must be set inside the loop.
      423**/
      424 
      425       search_specification.and_group (1).constraint (1).value_ptr = addr (tuple_id);
      426 
      427 RB_INDEX_LOOP:
      428       do rb_index_idx = 1 to rb_p_number_of_keys;
      429          if index_attribute_map.index (rb_index_idx).number_of_attributes > 0
      430          then
      431 RB_DELETE_KEY:
      432 	  do;
      433 	     search_specification.and_group (1).number_of_constraints =
      434 		index_attribute_map.index (rb_index_idx).number_of_attributes + 1;
      435 	     search_specification.and_group (1).constraint (1).field_id =
      436 		search_specification.and_group (1).number_of_constraints;
      437 RB_KEY_FIELD_LOOP:
      438 	     do rb_key_field_idx = 1 to index_attribute_map.index (rb_index_idx).number_of_attributes;
      439 	        search_specification.and_group (1).constraint (rb_key_field_idx + 1).field_id = rb_key_field_idx;
      440 	        search_specification.and_group (1).constraint (rb_key_field_idx + 1).value_ptr =
      441 		   input_simple_typed_vector_ptr
      442 		   -> simple_typed_vector
      443 		   .value_ptr (index_attribute_map.index (rb_index_idx).attribute_id (rb_key_field_idx));
      444 	     end RB_KEY_FIELD_LOOP;
      445 
      446 	     rb_index_cursor_ptr = index_cursor_array (rb_index_idx).cursor_ptr;
      447 
      448 	     call index_manager_$delete_key (search_specification_ptr, dm_area_ptr, rb_index_cursor_ptr, (0), rb_code);
      449 	     ;
      450 	  end RB_DELETE_KEY;
      451       end RB_INDEX_LOOP;
      452 
      453 
      454       call record_manager_$delete_record_by_id (tuple_id, record_collection_cursor_ptr, rb_code);
      455 
      456       free search_specification in (dm_area);
      457       return;
      458 
      459    end ROLLBACK;
      460 
      461 CHECK_VERSION:
      462    proc (p_structure_name, p_received_version, p_expected_version);
      463 
      464       dcl	    p_received_version     char (8) aligned;
      465       dcl	    p_expected_version     char (8) aligned;
      466       dcl	    p_structure_name       char (*);
      467 
      468       if p_received_version ^= p_expected_version
      469       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      470 	      "^/Expected version ^8a of the ^a structure.
      471 Received version ^8a, instead.", p_expected_version, p_structure_name, p_received_version);
      472 
      473    end CHECK_VERSION;
      474 
      475 CHECK_VERSION_FB:
      476    proc (p_structure_name, p_received_version, p_expected_version);
      477 
      478       dcl	    p_received_version     fixed bin (35);
      479       dcl	    p_expected_version     fixed bin (35);
      480       dcl	    p_structure_name       char (*);
      481 
      482       if p_received_version ^= p_expected_version
      483       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      484 	      "^/Expected version ^d of the ^a structure.
      485 Received version ^d, instead.", p_expected_version, p_structure_name, p_received_version);
      486 
      487    end CHECK_VERSION_FB;
      488 
      489 CHECK_PTR_NULL:
      490    proc (cpn_p_ptr_name, cpn_p_ptr);
      491 
      492       dcl	    cpn_p_ptr_name	       char (*) parameter;
      493       dcl	    cpn_p_ptr	       ptr;
      494 
      495       if cpn_p_ptr = null ()
      496       then call sub_err_ (error_table_$bad_arg, myname, ACTION_CANT_RESTART, null, 0, "A null value was supplied for ^a.",
      497 	      cpn_p_ptr_name);
      498 
      499    end CHECK_PTR_NULL;
      500 
      501 SETUP_CURSORS:
      502    proc ();
      503 
      504 /* This routine sets up a cursor for the record collection and one cursor
      505*   for each index of the relation.  The record cursor is always created
      506*   (and deleted later in FINISH).  An index cursor is created for each
      507*   index which needs one, that is for each that does not already have a
      508*   cursor in the index_cursor_array.  This array is part of the relation's
      509*   opening info.  When a cursor is created for an index to be used internally
      510*   a pointer to the cursor is put in the index_cursor_array so that it can be
      511*   used again later.  No index cursors created here will be destroyed. */
      512 
      513       dcl	    sc_code	       fixed bin (35) init (0);
      514       dcl	    sc_index_idx	       fixed bin;
      515 
      516       call record_manager_$create_cursor (relation_cursor.file_opening_id, relation_header.record_collection_id,
      517 	 relation_cursor.work_area_ptr, record_collection_cursor_ptr, sc_code);
      518       if sc_code ^= 0
      519       then call ERROR_RETURN (sc_code);
      520 
      521       do sc_index_idx = 1 to hbound (index_attribute_map.index, 1);
      522          if index_attribute_map.index (sc_index_idx).number_of_attributes > 0
      523          then if index_cursor_array.cursor_ptr (sc_index_idx) = null
      524 	    then
      525 	       do;
      526 		call index_manager_$create_cursor (relation_cursor.file_opening_id,
      527 		     index_attribute_map.index (sc_index_idx).collection_id, dm_area_ptr,
      528 		     index_cursor_array.cursor_ptr (sc_index_idx), sc_code);
      529 		if sc_code ^= 0
      530 		then call ERROR_RETURN (sc_code);
      531 	       end;
      532       end;
      533 
      534    end SETUP_CURSORS;
      535 
      536 SETUP_VECTOR:
      537    proc ();
      538 
      539       stv_number_of_dimensions = index_attribute_map.maximum_number_of_attributes_per_index + 1;
      540       alloc simple_typed_vector in (dm_area);
      541       simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      542 
      543    end SETUP_VECTOR;
      544 
  1     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*          The element_id_list structure contains an array of element 
  1     5*     identifiers.  These identifiers are used as tuple, record or 
  1     6*     element identifiers.  This structure is used across the relation_manager_,
  1     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  1     8*     version should be changed to be char(8)aligned, when such a conversion
  1     9*     can be coordinated with the other structures used at these interfaces.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 06/06/82.
  1    14*Modified:
  1    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  1    16*            Did not change version.
  1    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  1    18**/
  1    19 
  1    20 /* format: style2,ind3 */
  1    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  1    22 	     2 version	      fixed bin (35),
  1    23 	     2 number_of_elements fixed bin (35),
  1    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  1    25 
  1    26      dcl	   element_id_list_ptr    ptr;
  1    27      dcl	   eil_number_of_elements fixed bin (35);
  1    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  1    29 			      init (1) fixed bin (35);
  1    30 
  1    31 
  1    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      545 
      546 
  2     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  2     2 
  2     3 /* Written by Lindsey Spratt, 07/07/82
  2     4*Modified:
  2     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  2     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  2     7*	  bit(1) arrays for determining if a given operator code "uses" a
  2     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  2     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  2    10**/
  2    11 
  2    12 /* format: style2,ind3 */
  2    13      dcl	   (
  2    14 	   EQUAL_OPERATOR_CODE    init (1),
  2    15 	   GREATER_OPERATOR_CODE  init (2),
  2    16 	   LESS_OPERATOR_CODE     init (7),
  2    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  2    18 			      init (8),
  2    19 	   NOT_EQUAL_OPERATOR_CODE
  2    20 			      init (5),
  2    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  2    22 			      init (3),
  2    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  2    24 			      init (6),
  2    25 	   EQUAL_IDX	      init (18),
  2    26 	   GREATER_IDX	      init (17),
  2    27 	   NOT_IDX	      init (16),
  2    28 	   REGULAR_EXPRESSION_IDX init (15)
  2    29 	   )		      fixed bin internal static options (constant);
  2    30 
  2    31      dcl	   (
  2    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  2    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  2    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  2    35 			      (25) (1)"0"b),
  2    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  2    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  2    38 			      (19) (1)"0"b)
  2    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  2    40 
  2    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      547 
      548 
  3     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
  3     2 
  3     3 /* This include file contains declarations of record_manager_ entry points. */
  3     4 
  3     5 /* HISTORY:
  3     6*Written by Matthew Pierret 05/12/82.
  3     7*Modified:
  3     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
  3     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
  3    10*            $get_records_and_ids_by_interval.
  3    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
  3    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
  3    13*            rcm_$destroy_cursor.
  3    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
  3    15*            added a ptr parameter. 
  3    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
  3    17*            rcm_$=_by_interval.
  3    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
  3    19*            record_manager_.alm) and changed the declarations of
  3    20*            those that used to pass a typed_vector_type and a
  3    21*            typed_vector_array_version.
  3    22*04/26/84 by Lee Baldwin:  Changed the arg list of
  3    23*            $get_record_count_by_interval to not take a work_area_ptr.
  3    24**/
  3    25 
  3    26 /* format: style2,ind3 */
  3    27      dcl	   record_manager_$create_collection
  3    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
  3    29      dcl	   record_manager_$create_cursor
  3    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
  3    31      dcl	   record_manager_$destroy_collection
  3    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  3    33      dcl	   record_manager_$destroy_cursor
  3    34 			      entry (ptr, fixed bin (35));
  3    35 
  3    36      dcl	   record_manager_$get_record_by_id
  3    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
  3    38      dcl	   record_manager_$get_records_by_id_list
  3    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  3    40      dcl	   record_manager_$get_records_by_spec
  3    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  3    42      dcl	   record_manager_$get_records_by_interval
  3    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  3    44      dcl	   record_manager_$get_records_and_ids_by_spec
  3    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  3    46      dcl	   record_manager_$get_records_and_ids_by_interval
  3    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
  3    48      dcl	   record_manager_$get_record_ids_by_spec
  3    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
  3    50      dcl	   record_manager_$get_record_ids_by_interval
  3    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  3    52      dcl	   record_manager_$get_record_count
  3    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  3    54      dcl	   record_manager_$get_record_count_by_interval
  3    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  3    56 
  3    57      dcl	   record_manager_$put_record_by_id
  3    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
  3    59 
  3    60      dcl	   record_manager_$put_records_by_id
  3    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  3    62 
  3    63      dcl	   record_manager_$delete_record_by_id
  3    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
  3    65 
  3    66      dcl	   record_manager_$delete_records_by_id_list
  3    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  3    68 
  3    69      dcl	   record_manager_$delete_records_by_spec
  3    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  3    71 
  3    72      dcl	   record_manager_$modify_record_by_id
  3    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  3    74 
  3    75      dcl	   record_manager_$modify_records_by_id_list
  3    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  3    77 
  3    78      dcl	   record_manager_$modify_records_by_spec
  3    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  3    80 
  3    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
      549 
      550 
  4     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  4     2 
  4     3 /* Written by Matthew Pierret, 09/08/82. 
  4     4*Modified:
  4     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  4     6*            transaction_id.
  4     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  4     8*            relation_info).
  4     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  4    10**/
  4    11 
  4    12 
  4    13 /* format: style2,ind3 */
  4    14 
  4    15      dcl	   1 relation_opening_info
  4    16 			      aligned based (relation_opening_info_ptr),
  4    17 	     2 version	      char (8),
  4    18 	     2 per_process,
  4    19 	       3 current_transaction_id
  4    20 			      bit (36) aligned init ("0"b),
  4    21 	       3 current_rollback_count
  4    22 			      fixed bin (35) init (0),
  4    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  4    24 	       3 number_of_openings
  4    25 			      fixed bin (17) aligned init (0),
  4    26 	       3 lock_advice      aligned,
  4    27 	         4 this_process   bit (2) unaligned init ("0"b),
  4    28 	         4 other_processes
  4    29 			      bit (2) unaligned init ("0"b),
  4    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  4    31 	       3 record_cursor_ptr
  4    32 			      ptr init (null),
  4    33 	       3 index_cursor_array_ptr
  4    34 			      ptr init (null),
  4    35 	     2 relation_header_ptr
  4    36 			      ptr init (null),
  4    37 	     2 attribute_info_ptr ptr init (null),
  4    38 	     2 index_attribute_map_ptr
  4    39 			      ptr init (null);
  4    40 
  4    41      dcl	   relation_opening_info_ptr
  4    42 			      ptr;
  4    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  4    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  4    45 
  4    46 
  4    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      551 
      552 
  5     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 1982.
  5     5*Modified:
  5     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  5     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  5     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  5     9*            RELATION_HEADER_VERSION_3.
  5    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  5    11**/
  5    12 
  5    13 /* format: style2,ind3 */
  5    14 
  5    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  5    16 	     2 version	      char (8),
  5    17 	     2 header_info_update_count
  5    18 			      fixed bin (35) aligned init (0),
  5    19 	     2 record_collection_id
  5    20 			      bit (36) aligned init ("0"b),
  5    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  5    22 	     2 attribute_info_element_id
  5    23 			      bit (36) aligned init ("0"b),
  5    24 	     2 index_attribute_map_element_id
  5    25 			      bit (36) aligned init ("0"b),
  5    26 	     2 caller_header_element_id
  5    27 			      bit (36) aligned init ("0"b);
  5    28 
  5    29      dcl	   relation_header_ptr    ptr init (null);
  5    30      dcl	   RELATION_HEADER_VERSION_3
  5    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  5    32 
  5    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      553 
      554 
  6     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION
  6     4*        
  6     5*   Relation index components.  This info is kept in the header
  6     6*   collection of existing files, therefore this incl should not be changed.
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*Written by Matthew Pierret, 01/15/83.
  6    11*Modified:
  6    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  6    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  6    14*   which were incompatible with existing DM files.        
  6    15**/
  6    16 
  6    17 /* format: style2,ind3 */
  6    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  6    19 	     2 version	      char (8),
  6    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  6    21 	     2 maximum_number_of_indices
  6    22 			      fixed bin (17) unal,
  6    23 	     2 maximum_number_of_attributes_per_index
  6    24 			      fixed bin (17) unal,
  6    25 	     2 mbz	      fixed bin (17) unal,
  6    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  6    27 	       3 collection_id    bit (36) aligned,
  6    28 	       3 style	      fixed bin (17) unal,
  6    29 	       3 number_of_duplication_fields
  6    30 			      fixed bin (17) unal,
  6    31 	       3 number_of_attributes
  6    32 			      fixed bin (17) unal,
  6    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  6    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  6    35 			      bin (17) unal;
  6    36 
  6    37      dcl	   index_attribute_map_ptr
  6    38 			      ptr init (null);
  6    39      dcl	   iam_maximum_number_of_indices
  6    40 			      fixed bin (17);
  6    41      dcl	   iam_maximum_number_of_attributes_per_index
  6    42 			      fixed bin (17);
  6    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  6    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  6    45      dcl	   INITIAL_NUMBER_OF_INDICES
  6    46 			      init (5) fixed bin (17);
  6    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  6    48 			      init (0) fixed bin (17);
  6    49 
  6    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      555 
      556 
  7     1 /* BEGIN INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
  7     2 
  7     3 /* HISTORY:
  7     4*Written by Matthew Pierret, 03/02/83. 
  7     5*Modified:
  7     6*10/30/84 by Stanford S. Cox: Changed to not init version.
  7     7**/
  7     8 
  7     9 /* format: style2,ind3 */
  7    10 
  7    11      dcl	   1 index_cursor_array   aligned based (index_cursor_array_ptr),
  7    12 	     2 version	      char (8),
  7    13 	     2 number_of_indices  fixed bin (35),
  7    14 	     2 mbz	      fixed bin (35) init (0),
  7    15 	     2 cursor_ptr	      (ica_number_of_indices refer (index_cursor_array.number_of_indices)) ptr;
  7    16 
  7    17      dcl	   index_cursor_array_ptr ptr init (null);
  7    18      dcl	   ica_number_of_indices  fixed bin (35) init (0);
  7    19      dcl	   INDEX_CURSOR_ARRAY_VERSION_1
  7    20 			      init ("ixcrsra1") char (8) aligned internal static options (constant);
  7    21 
  7    22 
  7    23 /* END INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
      557 
      558 
  8     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*Written by Matthew Pierret, 05/19/83. 
  8     6*Modified:
  8     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  8     8*            structure, to add the search_index_and_record_collection flag.
  8     9*            This flag is only meaningful when doing a relative search.  It is
  8    10*            used by rlm_general_search to know what state the
  8    11*            internal_search_specification was left in (suitable for searching
  8    12*            the index or suitable for searching the records).
  8    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  8    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  8    15**/
  8    16 
  8    17 /* format: style2,ind3 */
  8    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  8    19 	     2 version	      char (8),		/* version of this structure */
  8    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  8    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  8    22 						/* opening id of file in which relation resides */
  8    23 	     2 flags	      aligned,
  8    24 	       3 current_state_is_consistent
  8    25 			      bit (1) unal init ("0"b),
  8    26 						/* On if all values in current are insynch */
  8    27 	       3 mbz	      bit (35) unal init ("0"b),
  8    28 						/* must be zero */
  8    29 	     2 current,				/* current position in search */
  8    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  8    31 						/* in relation_search_specification */
  8    32 	       3 flags	      aligned,
  8    33 	         4 search_index_and_record_collection
  8    34 			      bit (1) unal init ("0"b),
  8    35 	         4 mbz	      bit (35) unal init ("0"b),
  8    36 	       3 collection_id    bit (36) aligned init ("0"b),
  8    37 						/* that cursor is define over */
  8    38 	       3 specification_ptr
  8    39 			      ptr init (null),	/* points to index or record specification */
  8    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  8    41 
  8    42      dcl	   relation_cursor_ptr    ptr init (null);
  8    43      dcl	   RELATION_CURSOR_VERSION_2
  8    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  8    45 
  8    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
      559 
      560 
  9     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  9     2 
  9     3 /* HISTORY:
  9     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  9     5*Modified:
  9     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  9     7**/
  9     8 
  9     9 /* format: style2,ind3 */
  9    10      dcl	   1 specification_head   based (specification_head_ptr),
  9    11 	     2 version	      fixed bin (35),
  9    12 	     2 type	      fixed bin (17) unal,
  9    13 	     2 pad	      bit (18) unal,
  9    14 	     2 subset_specification_ptr
  9    15 			      ptr;
  9    16 
  9    17 
  9    18      dcl	   specification_head_ptr ptr;
  9    19      dcl	   SPECIFICATION_VERSION_4
  9    20 			      init (4) fixed bin (35) internal static options (constant);
  9    21 
  9    22      dcl	   (
  9    23 	   SEARCH_SPECIFICATION_TYPE
  9    24 			      init (1),
  9    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  9    26 			      init (1),
  9    27 	   NUMERIC_SPECIFICATION_TYPE
  9    28 			      init (2),
  9    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  9    30 			      init (2),
  9    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  9    32 			      init (3),
  9    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  9    34 			      init (4),
  9    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    36 			      init (5),
  9    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    38 			      init (6),
  9    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    40 			      init (7),
  9    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    42 			      init (8)
  9    43 	   )		      fixed bin (17) internal static options (constant);
  9    44 
  9    45 
  9    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      561 
      562 
 10     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*          The specification structure is used to identify sets items based on
 10     6*     the value of some of the contents of the items (the
 10     7*     search_specification), or based on the ordinal position (the
 10     8*     numeric_specification) of the first or last item in the desired set of
 10     9*     items in the set of all possible items.  It is used with the relation,
 10    10*     index and record managers.  The items for these three managers are
 10    11*     tuples, keys and records, respectively.  The sets of "all possible
 10    12*     items", for determination of ordinal position for these three managers
 10    13*     are: a relation, an index, and a record collection, respectively.
 10    14*     
 10    15*          The specification_head structure, in dm_specification_head.incl.pl1,
 10    16*     must be included in any program which uses this (the
 10    17*     dm_specification.incl.pl1) include file.
 10    18**/
 10    19 
 10    20 /* HISTORY:
 10    21*
 10    22*Written by Lindsey Spratt, 05/19/82.
 10    23*Modified:
 10    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
 10    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
 10    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
 10    27*	  Changed the version to 3.
 10    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
 10    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
 10    30*            Moved range type constants into dm_range_constants.incl.pl1.
 10    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
 10    32*            intra-key/record compares.
 10    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
 10    34*            Added a DESCRIPTION comment.
 10    35**/
 10    36 
 10    37 /* format: style2,ind3 */
 10    38      dcl	   1 search_specification based (search_specification_ptr),
 10    39 	     2 head	      like specification_head,
 10    40 	     2 maximum_number_of_constraints
 10    41 			      fixed bin (17) unal,
 10    42 	     2 number_of_and_groups
 10    43 			      fixed bin (17) unal,
 10    44 	     2 range	      unal,
 10    45 	       3 type	      fixed bin (17),
 10    46 	       3 size	      fixed bin (17),
 10    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
 10    48 	       3 number_of_constraints
 10    49 			      fixed bin (17) unal,
 10    50 	       3 constraint	      (ss_maximum_number_of_constraints
 10    51 			      refer (search_specification.maximum_number_of_constraints)),
 10    52 	         4 field_id	      fixed bin (17) unal,
 10    53 	         4 operator_code  fixed bin (17) unal,
 10    54 	         4 value_field_id fixed bin (17) unal,
 10    55 	         4 pad	      bit (18) unal,
 10    56 	         4 value_ptr      ptr unal;
 10    57 
 10    58      dcl	   search_specification_ptr
 10    59 			      ptr;
 10    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
 10    61 			      fixed bin (17);
 10    62 
 10    63      dcl	   1 numeric_specification
 10    64 			      based (numeric_specification_ptr),
 10    65 	     2 head	      like specification_head,
 10    66 	     2 range_size	      fixed bin (35) aligned,
 10    67 	     2 position_number    fixed bin (17) unal,
 10    68 	     2 pad	      bit (18) unal;
 10    69 
 10    70      dcl	   numeric_specification_ptr
 10    71 			      ptr;
 10    72 
 10    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      563 
      564 
 11     1 /*  BEGIN INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3 /* Written by R. Harvey, 09/24/82 
 11     4*Modified:
 11     5*09/27/82 by Matthew Pierret:  Changed "max" to "maximum", tvl_number_of_vectors
 11     6*            to tvl_maximum_number_of_vectors.
 11     7**/
 11     8 
 11     9 /* format: style2,ind3 */
 11    10      dcl	   1 typed_vector_list    aligned based (typed_vector_list_ptr),
 11    11 	     2 version	      fixed bin (17),
 11    12 	     2 maximum_number_of_vectors
 11    13 			      fixed bin (35),	/* vectors available */
 11    14 	     2 number_of_vectors  fixed bin (35),	/* number of vector_ptrs used */
 11    15 	     2 pad	      fixed bin (35),	/* (even word boundary) */
 11    16 	     2 vector_ptr	      (tvl_maximum_number_of_vectors refer (typed_vector_list.maximum_number_of_vectors)) ptr;
 11    17 
 11    18      dcl	   typed_vector_list_ptr  ptr;
 11    19      dcl	   TYPED_VECTOR_LIST_VERSION_1
 11    20 			      fixed bin (17) int static options (constant) init (1);
 11    21      dcl	   tvl_maximum_number_of_vectors  fixed bin (35);
 11    22 
 11    23 /*  END INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      565 
      566 
 12     1 /* ***********************************************************
 12     2*   *                                                         *
 12     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 12     4*   *                                                         *
 12     5*   *********************************************************** */
 12     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 12     7 
 12     8 /* Written by Lindsey Spratt, 04/02/82.
 12     9*Modified:
 12    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 12    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 12    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 12    13*	  type.
 12    14**/
 12    15 
 12    16 /* format: style2,ind3 */
 12    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 12    18 	     2 type	      fixed bin (17) unal,
 12    19 	     2 number_of_dimensions
 12    20 			      fixed bin (17) unal,
 12    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 12    22 	       3 value_ptr	      ptr unaligned;
 12    23 
 12    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 12    25 	     2 type	      fixed bin (17) unal,
 12    26 	     2 number_of_dimensions
 12    27 			      fixed bin (17) unal,
 12    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 12    29 	       3 identifier	      fixed bin (17) unal,
 12    30 	       3 pad	      bit (18) unal,
 12    31 	       3 value_ptr	      ptr unal;
 12    32 
 12    33      dcl	   simple_typed_vector_ptr
 12    34 			      ptr;
 12    35      dcl	   stv_number_of_dimensions
 12    36 			      fixed bin (17);
 12    37 
 12    38      dcl	   general_typed_vector_ptr
 12    39 			      ptr;
 12    40      dcl	   gtv_number_of_dimensions
 12    41 			      fixed bin (17);
 12    42 
 12    43      dcl	   (
 12    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 12    45 			      init (1),		/* value_ptr was aligned. */
 12    46 	   GENERAL_TYPED_VECTOR_TYPE
 12    47 			      init (2),
 12    48 	   SIMPLE_TYPED_VECTOR_TYPE
 12    49 			      init (3)
 12    50 	   )		      fixed bin (17) internal static options (constant);
 12    51 
 12    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      567 
      568 
 13     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 13     2 /* format: style3 */
 13     3 
 13     4 /* These constants are to be used for the flags argument of sub_err_ */
 13     5 /* They are just "string (condition_info_header.action_flags)" */
 13     6 
 13     7 declare	(
 13     8 	ACTION_CAN_RESTART	init (""b),
 13     9 	ACTION_CANT_RESTART init ("1"b),
 13    10 	ACTION_DEFAULT_RESTART
 13    11 			init ("01"b),
 13    12 	ACTION_QUIET_RESTART
 13    13 			init ("001"b),
 13    14 	ACTION_SUPPORT_SIGNAL
 13    15 			init ("0001"b)
 13    16 	)		bit (36) aligned internal static options (constant);
 13    17 
 13    18 /* End include file */
      569 
      570 
      571    end rlm_put_tuple$list;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/86  1257.9  rlm_put_tuple.pl1                 >spec>install>1054>rlm_put_tuple.pl1
545          1    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
547          2    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
549          3    01/07/85  0859.3  dm_rcdmgr_entry_dcls.incl.pl1     >ldd>include>dm_rcdmgr_entry_dcls.incl.pl1
551          4    01/07/85  0859.6  dm_rlm_opening_info.incl.pl1      >ldd>include>dm_rlm_opening_info.incl.pl1
553          5    01/07/85  0859.4  dm_rlm_header.incl.pl1            >ldd>include>dm_rlm_header.incl.pl1
555          6    01/07/85  0901.7  dm_rlm_index_attr_map.incl.pl1    >ldd>include>dm_rlm_index_attr_map.incl.pl1
557          7    01/07/85  0859.5  dm_rlm_idx_cursor_array.incl.pl1  >ldd>include>dm_rlm_idx_cursor_array.incl.pl1
559          8    03/06/85  1031.5  dm_rlm_cursor.incl.pl1            >ldd>include>dm_rlm_cursor.incl.pl1
561          9    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
563         10    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
565         11    10/14/83  1609.1  dm_typed_vector_list.incl.pl1     >ldd>include>dm_typed_vector_list.incl.pl1
567         12    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
569         13    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     constant        fixed bin(17,0)          initial dcl 9-22 ref 412
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 13-7 set ref 219* 468* 482* 495*
ELEMENT_ID_LIST_VERSION_1       000122 automatic       fixed bin(35,0)          initial dcl 1-28 set ref 218* 1-28*
EQUAL_OPERATOR_CODE                    constant        fixed bin(17,0)          initial dcl 2-13 ref 417
INDEX_ATTRIBUTE_MAP_VERSION_2   000006 constant        char(8)                  initial dcl 6-43 set ref 368*
INDEX_CURSOR_ARRAY_VERSION_1    000004 constant        char(8)                  initial dcl 7-19 set ref 371*
INITIAL_NUMBER_OF_INDICES       000132 automatic       fixed bin(17,0)          initial dcl 6-45 set ref 6-45*
RANDOM_RECORD_ID                000045 constant        bit(36)                  initial dcl 172 set ref 304*
RELATION_CURSOR_VERSION_2       000002 constant        char(8)                  initial dcl 8-43 ref 210 264
RELATION_HEADER_VERSION_3       000010 constant        char(8)                  initial dcl 5-30 set ref 365*
RELATION_OPENING_INFO_VERSION_2 000012 constant        char(8)                  initial dcl 4-43 set ref 362*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 12-43 ref 239 259 541
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 9-19 ref 410
TYPED_VECTOR_LIST_VERSION_1            constant        fixed bin(17,0)          initial dcl 11-19 ref 214
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000133 automatic       fixed bin(17,0)          initial dcl 6-47 set ref 6-47*
addr                                                   builtin function         dcl 162 ref 329 425
and_group                 6            based           structure                array level 2 packed unaligned dcl 10-38
attribute_id              6(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 6-18 ref 323 440
char                                                   builtin function         dcl 162 ref 236
cleanup                         000112 stack reference condition                dcl 167 ref 226 268
collection_id             4            based           bit(36)                  array level 3 dcl 6-18 set ref 526*
constraint                6(18)        based           structure                array level 3 packed unaligned dcl 10-38
cpn_p_ptr                              parameter       pointer                  dcl 493 ref 489 495
cpn_p_ptr_name                         parameter       char                     unaligned dcl 492 set ref 489 495*
cursor_ptr                4            based           pointer                  array level 2 dcl 7-11 set ref 332 446 522 526*
dimension                 1            based           structure                array level 2 packed unaligned dcl 12-17
dm_area                                based           area                     dcl 158 ref 384 387 409 456 540
dm_area_ptr                     000010 internal static pointer                  initial dcl 194 set ref 353 353* 384 387 409 448*
                                                                                  456 526* 540
dm_error_$key_duplication       000026 external static fixed bin(35,0)          dcl 186 ref 339
element_id_list                        based           structure                level 1 dcl 1-21
element_id_list_ptr             000120 automatic       pointer                  dcl 1-26 set ref 216* 217* 218 219 231 243
er_code                                parameter       fixed bin(35,0)          dcl 292 ref 289 294
error_table_$bad_arg            000024 external static fixed bin(35,0)          dcl 185 set ref 219* 495*
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 188 set ref 468* 482*
field_id                  6(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 10-38 set ref
                                                                                  435* 439*
file_opening_id           4            based           bit(36)                  initial level 2 dcl 8-18 set ref 358* 516* 526*
get_dm_free_area_               000012 constant        entry                    external dcl 176 ref 353
hbound                                                 builtin function         dcl 162 ref 521
head                                   based           structure                level 2 unaligned dcl 10-38
ica_number_of_indices           000136 automatic       fixed bin(35,0)          initial dcl 7-18 set ref 7-18*
id                        2            based           bit(36)                  array level 2 dcl 1-21 set ref 231* 243*
index                     4            based           structure                array level 2 dcl 6-18 set ref 521
index_attribute_map                    based           structure                level 1 dcl 6-18
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_put_tuple$list" ref 367
index_attribute_map_ptr         000130 automatic       pointer                  initial dcl 6-37 in procedure "rlm_put_tuple$list"
                                                                                  set ref 6-37* 315 317 320 322 323 367* 368 408 429
                                                                                  433 437 440 521 522 526 539
index_cursor_array                     based           structure                level 1 dcl 7-11
index_cursor_array_ptr
                         12            based           pointer                  initial level 3 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_put_tuple$list" ref 370
index_cursor_array_ptr          000134 automatic       pointer                  initial dcl 7-17 in procedure "rlm_put_tuple$list"
                                                                                  set ref 7-17* 332 370* 371 446 522 526
index_cursor_ptr                000104 automatic       pointer                  initial dcl 149 set ref 149* 332* 334*
index_idx                       000107 automatic       fixed bin(17,0)          dcl 152 set ref 315* 317 320 322 323 332 339*
index_manager_$create_cursor    000020 constant        entry                    external dcl 179 ref 526
index_manager_$delete_key       000042 constant        entry                    external dcl 404 ref 448
index_manager_$put_key          000016 constant        entry                    external dcl 178 ref 334
input_simple_typed_vector_ptr   000100 automatic       pointer                  dcl 147 set ref 234* 236* 239 257* 258* 259 304* 323
                                                                                  440
key_field_idx                   000106 automatic       fixed bin(17,0)          dcl 151 set ref 322* 323 323* 329
ltrim                                                  builtin function         dcl 162 ref 236
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-18 ref 317 317 320
                                                                                  320 322 322 323 323 408 429 429 433 433 437 437
                                                                                  440 440 522 522 526 526 539
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-38 set ref 387 409*
                                                                                  417 417 417 418 418 418 425 425 433 433 435 435
                                                                                  435 435 439 439 440 440 456
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-18 ref 521
myname                          000014 constant        varying char(32)         initial dcl 171 set ref 219* 468* 482* 495*
null                                                   builtin function         dcl 162 ref 149 149 219 219 5-29 6-37 7-17 8-42 321
                                                                                  353 373 374 375 384 387 390 411 468 468 482 482
                                                                                  495 495 495 522
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 10-38 set ref 387 409*
                                                                                  456
number_of_attributes      6            based           fixed bin(17,0)          array level 3 packed unaligned dcl 6-18 ref 317 320
                                                                                  322 429 433 437 522
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 packed unaligned dcl 10-38 set ref
                                                                                  433* 435
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 12-17 set ref 320* 321
                                                                                  384 540*
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 1-21 ref 219 231
number_of_indices         2            based           fixed bin(17,0)          initial level 2 packed unaligned dcl 6-18 ref 315
number_of_vectors         2            based           fixed bin(35,0)          level 2 dcl 11-10 ref 219 233
operator_code             7            based           fixed bin(17,0)          array level 4 packed unaligned dcl 10-38 set ref
                                                                                  417*
p_code                                 parameter       fixed bin(35,0)          dcl 143 set ref 129 205* 250 254* 294* 304* 306 306*
                                                                                  334* 336 339 341* 358* 359 359*
p_element_id_list_ptr                  parameter       pointer                  dcl 139 ref 129 216
p_expected_version                     parameter       fixed bin(35,0)          dcl 479 in procedure "CHECK_VERSION_FB" set ref 475
                                                                                  482 482*
p_expected_version                     parameter       char(8)                  dcl 465 in procedure "CHECK_VERSION" set ref 461 468
                                                                                  468*
p_number_of_tuples_put                 parameter       fixed bin(35,0)          dcl 140 set ref 129 206* 245* 245
p_received_version                     parameter       char(8)                  dcl 464 in procedure "CHECK_VERSION" set ref 461 468
                                                                                  468*
p_received_version                     parameter       fixed bin(35,0)          dcl 478 in procedure "CHECK_VERSION_FB" set ref 475
                                                                                  482 482*
p_relation_cursor_ptr                  parameter       pointer                  dcl 141 ref 129 208 250 262
p_structure_name                       parameter       char                     unaligned dcl 466 in procedure "CHECK_VERSION" set
                                                                                  ref 461 468*
p_structure_name                       parameter       char                     unaligned dcl 480 in procedure "CHECK_VERSION_FB"
                                                                                  set ref 475 482*
p_tuple_id                             parameter       bit(36)                  dcl 142 set ref 250 255* 275*
p_typed_vector_list_ptr                parameter       pointer                  dcl 137 ref 129 212
p_typed_vector_ptr                     parameter       pointer                  dcl 136 ref 250 257
pad                       1(18)        based           bit(18)                  level 3 packed unaligned dcl 10-38 set ref 413*
per_process               2            based           structure                level 2 dcl 4-15
rb_code                         000266 automatic       fixed bin(35,0)          dcl 402 set ref 448* 454*
rb_index_cursor_ptr             000270 automatic       pointer                  dcl 403 set ref 446* 448*
rb_index_idx                    000264 automatic       fixed bin(17,0)          dcl 400 set ref 427* 429 433 437 440 446*
rb_key_field_idx                000265 automatic       fixed bin(17,0)          dcl 401 set ref 437* 439 439 440 440*
rb_p_number_of_keys                    parameter       fixed bin(17,0)          dcl 399 ref 396 427
record_collection_cursor_ptr    000102 automatic       pointer                  initial dcl 149 set ref 149* 304* 375* 390 390* 454*
                                                                                  516*
record_collection_id      3            based           bit(36)                  initial level 2 dcl 5-15 set ref 516*
record_manager_$create_cursor   000032 constant        entry                    external dcl 3-29 ref 516
record_manager_$delete_record_by_id
                                000040 constant        entry                    external dcl 3-63 ref 454
record_manager_$destroy_cursor  000034 constant        entry                    external dcl 3-33 ref 390
record_manager_$put_record_by_id
                                000036 constant        entry                    external dcl 3-57 ref 304
relation_cursor                        based           structure                level 1 dcl 8-18
relation_cursor_ptr             000140 automatic       pointer                  initial dcl 8-42 set ref 208* 209* 210 262* 263* 264
                                                                                  8-42* 358 516 516 526
relation_header                        based           structure                level 1 dcl 5-15
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_put_tuple$list" ref 364
relation_header_ptr             000126 automatic       pointer                  initial dcl 5-29 in procedure "rlm_put_tuple$list"
                                                                                  set ref 5-29* 364* 365 516
relation_opening_info                  based           structure                level 1 dcl 4-15
relation_opening_info_ptr       000124 automatic       pointer                  dcl 4-41 set ref 358* 362 364 367 370
rlm_opening_info$get            000014 constant        entry                    external dcl 177 ref 358
sc_code                         000340 automatic       fixed bin(35,0)          initial dcl 513 set ref 513* 516* 518 518* 526* 529
                                                                                  529*
sc_index_idx                    000341 automatic       fixed bin(17,0)          dcl 514 set ref 521* 522 522 526 526*
search_specification                   based           structure                level 1 unaligned dcl 10-38 set ref 387 409 456
search_specification_ptr        000142 automatic       pointer                  dcl 10-58 set ref 373* 387 387 409* 410 411 412 413
                                                                                  417 418 425 433 435 435 439 440 448* 456
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 12-17 set ref 384 540
simple_typed_vector_ptr         000150 automatic       pointer                  dcl 12-33 set ref 320 321 323 329 334* 374* 384 384
                                                                                  540* 541
specification_head                     based           structure                level 1 unaligned dcl 9-10
ss_maximum_number_of_constraints
                                000145 automatic       fixed bin(17,0)          dcl 10-60 set ref 408* 409 409
ss_number_of_and_groups         000144 automatic       fixed bin(17,0)          dcl 10-60 set ref 407* 409 409
stv_number_of_dimensions        000152 automatic       fixed bin(17,0)          dcl 12-35 set ref 539* 540 540
sub_err_                        000022 constant        entry                    external dcl 181 ref 219 468 482 495
subset_specification_ptr
                          2            based           pointer                  level 3 dcl 10-38 set ref 411*
tuple_id                        000110 automatic       bit(36)                  dcl 153 set ref 243 275 304* 329 425 454*
tuple_loop                      000111 automatic       fixed bin(35,0)          dcl 154 set ref 233* 234 236 243*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 12-17 in procedure
                                                                                  "rlm_put_tuple$list" set ref 239 259 541*
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 10-38 in procedure
                                                                                  "rlm_put_tuple$list" set ref 412*
typed_vector_list                      based           structure                level 1 dcl 11-10
typed_vector_list_ptr           000146 automatic       pointer                  dcl 11-18 set ref 212* 213* 214 219 233 234
value_field_id            7(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 10-38 set ref
                                                                                  418*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 12-17 in procedure
                                                                                  "rlm_put_tuple$list" set ref 321* 323* 323 329*
                                                                                  440
value_ptr                10(18)        based           pointer                  array level 4 in structure "search_specification"
                                                                                  packed unaligned dcl 10-38 in procedure
                                                                                  "rlm_put_tuple$list" set ref 425* 440*
vector_ptr                4            based           pointer                  array level 2 dcl 11-10 ref 234
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_put_tuple$list" set ref
                                                                                  362*
version                                based           char(8)                  level 2 in structure "relation_header" dcl 5-15
                                                                                  in procedure "rlm_put_tuple$list" set ref 365*
version                                based           fixed bin(17,0)          level 2 in structure "typed_vector_list" dcl 11-10
                                                                                  in procedure "rlm_put_tuple$list" ref 214
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 1-21
                                                                                  in procedure "rlm_put_tuple$list" set ref 218*
version                                based           fixed bin(35,0)          level 3 in structure "search_specification"
                                                                                  dcl 10-38 in procedure "rlm_put_tuple$list" set
                                                                                  ref 410*
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 8-18
                                                                                  in procedure "rlm_put_tuple$list" ref 210 264
version                                based           char(8)                  level 2 in structure "index_cursor_array" dcl 7-11
                                                                                  in procedure "rlm_put_tuple$list" set ref 371*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 6-18
                                                                                  in procedure "rlm_put_tuple$list" set ref 368*
work_area_ptr             2            based           pointer                  initial level 2 dcl 8-18 set ref 516*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 9-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 13-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 13-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 13-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 13-7
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 2-13
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 12-43
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 2-13
GREATER_OPERATOR_CODE                  internal static fixed bin(17,0)          initial dcl 2-13
GREATER_OR_EQUAL_OPERATOR_CODE         internal static fixed bin(17,0)          initial dcl 2-13
LESS_OPERATOR_CODE                     internal static fixed bin(17,0)          initial dcl 2-13
LESS_OR_EQUAL_OPERATOR_CODE            internal static fixed bin(17,0)          initial dcl 2-13
NOT_EQUAL_OPERATOR_CODE                internal static fixed bin(17,0)          initial dcl 2-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 2-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 9-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 12-43
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 2-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 2-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 9-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 9-22
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array unaligned dcl 2-31
USES_GREATER_OPERATOR                  internal static bit(1)                   initial array unaligned dcl 2-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array unaligned dcl 2-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array unaligned dcl 2-31
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 1-27
general_typed_vector                   based           structure                level 1 packed unaligned dcl 12-24
general_typed_vector_ptr               automatic       pointer                  dcl 12-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 12-40
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 6-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 6-39
numeric_specification                  based           structure                level 1 unaligned dcl 10-63
numeric_specification_ptr              automatic       pointer                  dcl 10-70
record_manager_$create_collection
                                000000 constant        entry                    external dcl 3-27
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 3-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 3-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 3-31
record_manager_$get_record_by_id
                                000000 constant        entry                    external dcl 3-36
record_manager_$get_record_count
                                000000 constant        entry                    external dcl 3-52
record_manager_$get_record_count_by_interval
                                000000 constant        entry                    external dcl 3-54
record_manager_$get_record_ids_by_interval
                                000000 constant        entry                    external dcl 3-50
record_manager_$get_record_ids_by_spec
                                000000 constant        entry                    external dcl 3-48
record_manager_$get_records_and_ids_by_interval
                                000000 constant        entry                    external dcl 3-46
record_manager_$get_records_and_ids_by_spec
                                000000 constant        entry                    external dcl 3-44
record_manager_$get_records_by_id_list
                                000000 constant        entry                    external dcl 3-38
record_manager_$get_records_by_interval
                                000000 constant        entry                    external dcl 3-42
record_manager_$get_records_by_spec
                                000000 constant        entry                    external dcl 3-40
record_manager_$modify_record_by_id
                                000000 constant        entry                    external dcl 3-72
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 3-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 3-78
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 3-60
specification_head_ptr                 automatic       pointer                  dcl 9-18
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 190
tvl_maximum_number_of_vectors          automatic       fixed bin(35,0)          dcl 11-21

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_PTR_NULL                  002446 constant        entry                    internal dcl 489 ref 209 213 217 236 258 263
CHECK_VERSION                   002247 constant        entry                    internal dcl 461 ref 210 264 362 365 368 371
CHECK_VERSION_FB                002351 constant        entry                    internal dcl 475 ref 214 218 239 259
ERROR_RETURN                    001144 constant        entry                    internal dcl 289 ref 306 341 359 518 529
FINISH                          001623 constant        entry                    internal dcl 381 ref 226 268 284
INITIALIZE                      001425 constant        entry                    internal dcl 350 ref 224 266
MAIN_RETURN                     001135 constant        label                    dcl 279 ref 285
PUT_KEY_FOR_EACH_INDEX_LOOP     001205 constant        label                    dcl 315
PUT_SINGLE_TUPLE                001152 constant        entry                    internal dcl 299 ref 242 273
RB_DELETE_KEY                   002063 constant        label                    dcl 429
RB_INDEX_LOOP                   002032 constant        label                    dcl 427
RB_KEY_FIELD_LOOP               002072 constant        label                    dcl 437
RETURN                          001136 constant        entry                    internal dcl 282 ref 248 277 295
ROLLBACK                        001713 constant        entry                    internal dcl 396 ref 339
SETUP_CURSORS                   002535 constant        entry                    internal dcl 501 ref 228 270
SETUP_VECTOR                    002657 constant        entry                    internal dcl 536 ref 229 271
rlm_put_tuple$list              000321 constant        entry                    external dcl 129
single                          000762 constant        entry                    external dcl 250

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3300        3344    3034        3310
Length      4050    3034        44         470     243           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_put_tuple$list                  544 external procedure  is an external procedure.  
on unit on line 226                  64 on unit               
on unit on line 268                  64 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
PUT_SINGLE_TUPLE                        internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
INITIALIZE                              internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
FINISH                               72 internal procedure  is called by several nonquick procedures.  
ROLLBACK                                internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
CHECK_PTR_NULL                      108 internal procedure  is called during a stack extension.  
SETUP_CURSORS                           internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  
SETUP_VECTOR                            internal procedure  shares stack frame of external procedure rlm_put_tuple$list.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dm_area_ptr                 rlm_put_tuple$list

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_put_tuple$list       000100 input_simple_typed_vector_ptr
                                                            rlm_put_tuple$list
                         000102 record_collection_cursor_ptr
                                                            rlm_put_tuple$list
                         000104 index_cursor_ptr            rlm_put_tuple$list
                         000106 key_field_idx               rlm_put_tuple$list
                         000107 index_idx                   rlm_put_tuple$list
                         000110 tuple_id                    rlm_put_tuple$list
                         000111 tuple_loop                  rlm_put_tuple$list
                         000120 element_id_list_ptr         rlm_put_tuple$list
                         000122 ELEMENT_ID_LIST_VERSION_1   rlm_put_tuple$list
                         000124 relation_opening_info_ptr   rlm_put_tuple$list
                         000126 relation_header_ptr         rlm_put_tuple$list
                         000130 index_attribute_map_ptr     rlm_put_tuple$list
                         000132 INITIAL_NUMBER_OF_INDICES   rlm_put_tuple$list
                         000133 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_put_tuple$list
                         000134 index_cursor_array_ptr      rlm_put_tuple$list
                         000136 ica_number_of_indices       rlm_put_tuple$list
                         000140 relation_cursor_ptr         rlm_put_tuple$list
                         000142 search_specification_ptr    rlm_put_tuple$list
                         000144 ss_number_of_and_groups     rlm_put_tuple$list
                         000145 ss_maximum_number_of_constraints
                                                            rlm_put_tuple$list
                         000146 typed_vector_list_ptr       rlm_put_tuple$list
                         000150 simple_typed_vector_ptr     rlm_put_tuple$list
                         000152 stv_number_of_dimensions    rlm_put_tuple$list
                         000264 rb_index_idx                ROLLBACK
                         000265 rb_key_field_idx            ROLLBACK
                         000266 rb_code                     ROLLBACK
                         000270 rb_index_cursor_ptr         ROLLBACK
                         000340 sc_code                     SETUP_CURSORS
                         000341 sc_index_idx                SETUP_CURSORS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return              enable              shorten_stack       ext_entry
int_entry           int_entry_desc      alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_dm_free_area_             index_manager_$create_cursor  index_manager_$delete_key     index_manager_$put_key
record_manager_$create_cursor record_manager_$delete_record_by_id
record_manager_$destroy_cursor                              record_manager_$put_record_by_id
rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$key_duplication     error_table_$bad_arg          error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    149 000273    1   28 000276    5   29 000300    6   37 000302    6   45 000303    6   47 000305    7   17 000306
 7   18 000310    8   42 000311       129 000314       205 000332       206 000333       208 000335       209 000340
    210 000357       212 000374       213 000400       214 000422       216 000437       217 000443       218 000462
    219 000505       224 000555       226 000556       228 000600       229 000601       231 000602       233 000613
    234 000623       236 000627       239 000711       242 000734       243 000735       245 000741       246 000746
    248 000753       250 000754       254 000773       255 000774       257 000776       258 001001       259 001021
    262 001043       263 001047       264 001066       266 001103       268 001104       270 001126       271 001127
    273 001130       275 001131       277 001134       279 001135       282 001136       284 001137       285 001143
    289 001144       294 001146       295 001150       297 001151       299 001152       304 001153       306 001175
    315 001205       317 001217       320 001237       321 001246       322 001271       323 001311       327 001351
    329 001353       332 001361       334 001366       336 001402       339 001404       341 001414       345 001422
    347 001424       350 001425       353 001426       358 001441       359 001455       362 001465       364 001512
    365 001515       367 001540       368 001543       370 001565       371 001570       373 001615       374 001617
    375 001620       377 001621       381 001622       384 001630       387 001646       390 001673       393 001712
    396 001713       407 001715       408 001717       409 001724       410 001746       411 001750       412 001752
    413 001755       417 001757       418 002005       425 002024       427 002032       429 002043       433 002063
    435 002067       437 002072       439 002111       440 002123       444 002162       446 002164       448 002171
    451 002211       454 002213       456 002226       457 002246       461 002247       468 002260       473 002350
    475 002351       482 002362       487 002444       489 002445       495 002461       499 002534       501 002535
    513 002536       516 002537       518 002560       521 002564       522 002577       526 002626       529 002650
    532 002654       534 002656       536 002657       539 002660       540 002665       541 002702       543 002705


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
