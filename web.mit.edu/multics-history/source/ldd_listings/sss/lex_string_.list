	COMPILATION LISTING OF SEGMENT lex_string_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/01/84  0918.2 mst Thu
	    Options: optimize map

        1 /* ***************************************************************
        2*   *                                                             *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982     *
        4*   *                                                             *
        5*   * Copyright (c) 1975 by Massachusetts Institute of Technology *
        6*   *                                                             *
        7*   *************************************************************** */
        8 
        9 
       10 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       11 	/*									*/
       12 	/* Name:  lex_string_							*/
       13 	/*									*/
       14 	/*    This procedure implements the scanning function for reduction_compiler translators. */
       15 	/*									*/
       16 	/* Status:								*/
       17 	/* 1) Modified:  September 8, 1984 by G. C. Dixon: fix reference thru unset pointer	*/
       18 	/*    (phx18140); change to remove compilation warnings.				*/
       19 	/*									*/
       20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       21 
       22 	
       23 
       24 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       25 
       26 lex_string_:
       27 	procedure	(APstr, ALstr, Parea, AS,
       28 		 Aquote_open, Aquote_close, Acomment_open, Acomment_close, Astmt_delim, breaks,
       29 		 ignored_breaks, lex_delims, lex_control_chars, APstmt, APtoken, code);
       30 
       31      dcl						/*	PARAMETERS			*/
       32 	APstr			ptr,		/* ptr to characters to be ignored, followed by	*/
       33 						/* string to be lexed. (In)			*/
       34 	ALstr			fixed bin(21),	/* length of string to be lexed. (In)		*/
       35 	ALstr_ignore		fixed bin(21),	/* number of characters to be ignored,		*/
       36 						/* prior to the string. (In)			*/
       37 	Parea			ptr,		/* ptr to temporary segment in which tokens are	*/
       38 						/* to be created.  The temporary segment must be	*/
       39 						/* one created by translator_temp_. (In)	*/
       40 	AS			bit(*),		/* control switches (see S and Signore). (In)	*/
       41 	Aquote_open		char(*),		/* opening delimiter of quoted strings. (In)	*/
       42 	Aquote_close		char(*),		/* closing delimiter of quoted strings. (In)	*/
       43 	Acomment_open		char(*),		/* delimiter of comment's beginning. (In)	*/
       44 	Acomment_close		char(*),		/* delimiter of comment's ending. (In)		*/
       45 	Astmt_delim		char(*),		/* delimiter of statement's ending. (In)	*/
       46 	breaks			char(*) var aligned,/* list of break characters. (In)		*/
       47 	ignored_breaks		char(*) var aligned,/* chars in the break list for which no output	*/
       48 						/* token is to be created. (In)		*/
       49 	lex_delims		char(*) var aligned,/* string of all possible lexical delimiter chars.*/
       50 						/* (In)					*/
       51 	lex_control_chars		char(*) var aligned,/* string of control chars (1/lex_delim-char).(In)*/
       52 	APstmt			ptr,		/* ptr to chain of statement descriptors. (Out)	*/
       53 	APtoken			ptr,		/* ptr to chain of token descriptors. (Out)	*/
       54 	code			fixed bin(35);	/* a status code. (Out)			*/
       55 
       56      dcl						/*	AUTOMATIC VARIABLES			*/
       57 	Lquote_copy		fixed bin(21),	/* length of copy of a quoted string with	*/
       58 						/* doubled quotes removed.			*/
       59 	Lquote_incr		fixed bin(21),	/* length of part of quoted string between 2	*/
       60 						/* doubled quotes.				*/
       61 	Lquote_str		fixed bin(21),	/* length of entire quoted string.		*/
       62 	Lstr			fixed bin(21),	/* length of unlexed part of string. (in chars)	*/
       63 	Lstr_search		fixed bin(21),	/* length of unlexed string beyond false delim.	*/
       64 	Ndoubled_quotes		fixed bin,	/* number of doubled quotes in quoted string.	*/
       65 	Nlines			fixed bin(21),	/* number of lines lexed so far.		*/
       66 	Nstmt			fixed bin,	/* number stmts lexed so far in line being parsed.*/
       67 	Ntokens_in_stmt		fixed bin,	/* number of tokens in statement when last 	*/
       68 						/* comment was lexed (or, if stmts aren't being	*/
       69 						/* output, then total number of tokens lexed).	*/
       70 	Pquote_copy		ptr,		/* ptr to copy of quoted string.		*/
       71 	Pquote_str		ptr,		/* ptr to quoted string.			*/
       72 	Pstr			ptr,		/* ptr to unlexed part of string.		*/
       73 	Pstr_search		ptr,		/* ptr to unlexed string beyond false delim.	*/
       74 	Sarg			bit(36) aligned,	/* aligned fixed-length copy of AS.		*/
       75 	1 Snew_line		aligned,
       76 	  2 quote_open		bit(1),		/* on if open quote delimiter contains new-line.	*/
       77 	  2 quote_close		bit(1),		/* on if close quote delimiter contains new-line.	*/
       78 	  2 comm_open		bit(1),		/* on if comment open delim contains new-line.	*/
       79 	  2 comm_close		bit(1),		/* on if comment close delim contains new-line.	*/
       80 	  2 stmt_delim		bit(1),		/* on if stmt delim contains new-line.		*/
       81 	Sreuse_token		bit(1) aligned init ("0"b),
       82 						/* on if a token was unmade, and can be reused.	*/
       83 	ch			char(1) aligned,	/* a character temp.			*/
       84 	comment_close		char(4) varying aligned,
       85 	comment_open		char(4) varying aligned,
       86 						/* aligned fixed-length copy of Acomment_open.	*/
       87 	delim_control_char		char(1) aligned,	/* a break control character (see delim).	*/
       88 	doubled_quote		char(8) varying aligned,
       89 						/* representation of quoting delimiter within a	*/
       90 						/* quoted string.				*/
       91 						/* aligned fixed-length copy of Acomment_close.	*/
       92 	i			fixed bin(21),	/* string index.				*/
       93 	j			fixed bin,	/* string index.				*/
       94 	k			fixed bin(21),	/* string index.				*/
       95 	l			fixed bin(21),	/* string index.				*/
       96 	quote_close		char(4) varying aligned,
       97 						/* aligned fixed-length copy of Aquote_close.	*/
       98 	quote_open		char(4) varying aligned,
       99 						/* aligned fixed-length copy of Aquote_open.	*/
      100 	spec_lex_control_chars	char(36) varying aligned,
      101 						/* control chars for delimiters in next variable.	*/
      102 	spec_lex_delims		char(36) varying aligned,
      103 						/* delimiter characters: 1st char of quote, stmt,	*/
      104 						/* comment-open and comment-close delimiters.	*/
      105 	stmt_delim		char(4) varying aligned;
      106 						/* aligned fixed-length copy of stmt_delim.	*/
      107 
      108      dcl						/*	BASED VARIABLES			*/
      109 	1 S			unaligned based (addr (Sarg)),
      110 						/* input argument switches for lex_string_.	*/
      111 	  2 output_stmts		bit(1),		/* on if stmt descriptors are to be output.	*/
      112 	  2 output_comments		bit(1),		/* on if comment tokens are to be output.	*/
      113 	  2 retain_doubled_quotes	bit(1),		/* on if doubled quoting delimiters within a	*/
      114 						/* quoted string are to be retained instead of	*/
      115 						/* being converted to single quotes.		*/
      116 	  2 equate_comment_close_stmt_delim		/* on if comment_close and stmt delims are equal,	*/
      117 				bit(1),		/* and if a comment_close delim is also to be	*/
      118 						/* treated as a stmt delim.			*/
      119 	1 Signore			unaligned based (addr (Sarg)),
      120 						/* input argument switches for init_lex_delims 	*/
      121 	  2 quote			bit(1),		/* on if quoting delimiters are not to be output	*/
      122 						/* as tokens.				*/
      123 	  2 stmt			bit(1),		/* on if statement delimiters are not to be	*/
      124 						/* output as tokens.			*/
      125 	1 delim			unaligned based (addr (delim_control_char)),
      126 						/* switches overlaying delimiter control chars.	*/
      127 	  2 white_space,				/* switch on if char cannot appear at beginning	*/
      128 	    3 S			bit(1),		/* of a stmt (ie, stmt adjusted to exclude char).	*/
      129 	  2 new_line,				/* switch on if delimiter char is a new-line.	*/
      130 	    3 S			bit(1),
      131 	  2 comment_open,				/* switch on if delimiter char is 1st char	*/
      132 	    3 S			bit(1),		/* of a comment-open delimiter.		*/
      133 	  2 quote_open,				/* switch on if delimiter char is 1st char	*/
      134 	    3 S			bit(1),		/* of an open quote delimiter.		*/
      135 	    3 Signore		bit(1),		/* on if quoting delimiter is not to be output	*/
      136 						/* as a token.				*/
      137 	  2 stmt,					/* switch on if delimiter char is 1st char	*/
      138 	    3 S			bit(1),		/* of a statement delimiter.			*/
      139 	    3 Signore		bit(1),		/* on if statement delimiter is not to be output	*/
      140 						/* as a token.				*/
      141 	  2 break,
      142 	    3 S			bit(1),		/* switch on if delimiter char is a break.	*/
      143 	    3 Signore		bit(1),		/* on if break char is not to be output as a token*/
      144 	first_str_char		char(1) based (Pstr),
      145 						/* first char of unparsed remainder of string.	*/
      146 	quote_copy		char(Lquote_copy) based (Pquote_copy),
      147 						/* copy of quoted string in which doubled quotes	*/
      148 						/* have been converted to single quotes.	*/
      149 	quote_copy_array (Lquote_copy)
      150 				char(1) based (Pquote_copy),
      151 						/* array overlaying quote_copy.		*/
      152 	quote_str			char(Lquote_str) based (Pquote_str),
      153 						/* the original quoted string.		*/
      154 	quote_str_array (Lquote_str)	char(1) based (Pquote_str),
      155 						/* array overlaying quote_str.		*/
      156 	str			char(Lstr) based (Pstr),
      157 						/* remainder of string to be lexed.		*/
      158 	str_array (Lstr)		char(1) based (Pstr),
      159 						/* remainder of string to be lexed, as an array.	*/
      160 	str_search		char(Lstr_search) based (Pstr_search);
      161 						/* remainder of string to be lexed beyond a false	*/
      162 						/*   delimiter.				*/
      163 
      164 		/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  1     2 	
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     4 	/*							*/
  1     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  1     6 	/*							*/
  1     7 	/*      This include segment defines the structure of the token	*/
  1     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  1     9 	/* by the lex_string_ program.				*/
  1    10 	/*							*/
  1    11 	/* Status:						*/
  1    12 	/*							*/
  1    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  1    14 	/*							*/
  1    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    16 	
  1    17 	
  1    18 	
  1    19 	
  1    20      dcl	
  1    21 	1 comment			aligned based (Pcomment),
  1    22 						/* descriptor for a comment.			*/
  1    23 	  2 group1		unaligned,
  1    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  1    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  1    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  1    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  1    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  1    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  1    30 	  2 group2		unaligned,
  1    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  1    32 	    3 S,					/* switches:				*/
  1    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  1    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  1    35 	      4 pad		bit(16),
  1    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  1    37 						/* body of comment.				*/
  1    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  1    39 	
  1    40      dcl	
  1    41 	1 stmt			aligned based (Pstmt),
  1    42 						/* descriptor for a statement.		*/
  1    43 	  2 group1		unaligned,
  1    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  1    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  1    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  1    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  1    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  1    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  1    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  1    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  1    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  1    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  1    54 	  2 group2		unaligned,
  1    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  1    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  1    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  1    58 						/* (the number includes this stmt.)		*/
  1    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  1    60 	    3 S,					/* switches:				*/
  1    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  1    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  1    63 	      4 pad		bit(34),
  1    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  1    65 						/* text of the statement.			*/
  1    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  1    67 	
  1    68      dcl	
  1    69 	1 token			aligned based (Ptoken),
  1    70 						/* descriptor for a token.			*/
  1    71 	  2 group1		unaligned,
  1    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  1    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  1    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  1    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  1    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  1    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  1    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  1    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  1    80 	  2 group2		unaligned,
  1    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  1    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  1    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  1    84 	    3 S,					/* switches:				*/
  1    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  1    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  1    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  1    88 						/* string (as doubled quotes on input.)		*/
  1    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  1    90 						/* string has been lexed into a token.		*/
  1    91 	      4 pad2		bit(32),
  1    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  1    93 						/* value of the token.			*/
  1    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  1    95 
  1    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
      164 
      165 
      166      dcl						/*	BUILTIN FUNCTIONS			*/
      167 	(addr, collate, copy, index, length, min, null, search, size, string, substr)
      168 				builtin;
      169 
      170      dcl						/*	STATIC VARIABLES			*/
      171 	NL			char(1) aligned int static init ("
      172 "),
      173 	NP			char(1) aligned int static init (""),
      174          (error_table_$no_stmt_delim,
      175 	error_table_$unbalanced_quotes,
      176 	error_table_$zero_length_seg)	fixed bin(35) ext static,
      177 	max_Lvalue		fixed bin(18) int static init (262143);
      178 						/* 2**18 - 1;  the largest value which can be	*/
      179 						/* stored in a fixed bin(18) number.		*/
      180 
      181 	Nlines = 1;				/* Perform initialization for old entry point.	*/
      182 	Pstr = APstr;
      183 	Lstr = ALstr;
      184 	go to init;
      185 
      186 
      187 lex:	entry    (APstr, ALstr, ALstr_ignore, Parea, AS,
      188 		Aquote_open, Aquote_close, Acomment_open, Acomment_close, Astmt_delim, breaks,
      189 		ignored_breaks, lex_delims, lex_control_chars, APstmt, APtoken, code);
      190 
      191 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      192 	/*							*/
      193 	/* PRE-INITIALIZATION:					*/
      194 	/*							*/
      195 	/*  1) Count the number of <new-line> characters in the lines to be	*/
      196 	/*     ignored, so we can put correct line numbers into the tokens.	*/
      197 	/*							*/
      198 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      199 
      200 	Nlines = 1;
      201 	Pstr = APstr;
      202 	Lstr = ALstr_ignore;
      203 	do while (Lstr > 0);
      204 	     i = index(str,NL);
      205 	     if i = 0 then do;
      206 		Pstr = addr(str_array(Lstr+1));
      207 		Lstr = 0;
      208 		end;
      209 	     else do;
      210 		Nlines = Nlines + 1;
      211 		Pstr = addr(str_array(i+1));
      212 		Lstr = Lstr - i;
      213 		end;
      214 	     end;
      215 	Lstr = ALstr;
      216 
      217 
      218 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      219 	/*							*/
      220 	/* INITIALIZATION:						*/
      221 	/*							*/
      222 	/*  1) Copy arguments.					*/
      223 	/*  2) If creating statement (stmt) descriptors, as well as token	*/
      224 	/*     descriptors, create the first stmt descriptor.		*/
      225 	/*  3) Set switches if quoting, comment-open, comment-close, or stmt	*/
      226 	/*     delimiters contains a new-line character.			*/
      227 	/*							*/
      228 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      229 
      230 init:	Sarg = AS;
      231 	S.output_comments = S.output_comments & S.output_stmts;
      232 	quote_open = Aquote_open;
      233 	quote_close = Aquote_close;
      234 	doubled_quote = quote_close;
      235 	doubled_quote = doubled_quote || quote_close;
      236 	comment_open = Acomment_open;
      237 	comment_close = Acomment_close;
      238 	stmt_delim = Astmt_delim;
      239 
      240 	if S.output_stmts & (length(stmt_delim) > 0) then do;
      241 		/* stmt descriptors being output.			*/
      242 	     Pstmt = allocate (Parea, size(stmt));
      243 	     stmt.version = 1;
      244 	     stmt.size = size(stmt);
      245 	     stmt.Pnext = null;
      246 	     stmt.Plast = null;
      247 	     stmt.Pvalue = Pstr;
      248 	     stmt.Lvalue = Lstr;
      249 		/* Length of stmt will be computed by subtracting characters*/
      250 		/* remaining in string being lexed (str) after last token	*/
      251 		/* of stmt is lexed from chars in str before first token	*/
      252 		/* of stmt is lexed.  stmt_ subroutine does computation.	*/
      253 	     stmt.Pfirst_token = null;
      254 	     stmt.Plast_token = null;
      255 	     stmt.Ntokens = 0;
      256 		/* token_ subroutine fills in last 3 values.		*/
      257 	     stmt.Puser = null;
      258 	     stmt.semant_type = 0;
      259 	     stmt.Pcomments = null;
      260 	     stmt.line_no = Nlines;
      261 	     stmt.Istmt_in_line = 1;
      262 	     string(stmt.group2.S) = "0"b;
      263 	     APstmt = Pstmt;
      264 	     end;
      265 	else do;	/* No stmt descriptors being output.			*/
      266 	     APstmt = null;
      267 	     Ntokens_in_stmt = 0;
      268 	     end;
      269 		/* str has not yet ended with a stmt delimiter.		*/
      270 	APtoken = null;
      271 	code = 0;
      272 
      273 	string(Snew_line) = "0"b;
      274 	if length(quote_open) > 0 then
      275 	     if index(quote_open,NL) > 0 then
      276 		Snew_line.quote_open = "1"b;
      277 	if length(quote_close) > 0 then
      278 	     if index(quote_close,NL) > 0 then
      279 		Snew_line.quote_close = "1"b;
      280 	if length(comment_open) > 0 then
      281 	     if index(comment_open,NL) > 0 then
      282 		Snew_line.comm_open = "1"b;
      283 	if length(comment_close) > 0 then
      284 	     if index(comment_close,NL) > 0 then
      285 		Snew_line.comm_close = "1"b;
      286 	if length(stmt_delim) > 0 then
      287 	     if index(stmt_delim,NL) > 0 then
      288 		Snew_line.stmt_delim = "1"b;
      289 	if S.equate_comment_close_stmt_delim then
      290 	     if comment_close = stmt_delim then
      291 		if length(stmt_delim) > 0 then;
      292 		else S.equate_comment_close_stmt_delim = "0"b;
      293 	     else S.equate_comment_close_stmt_delim = "0"b;
      294 		/* Begin lexing the first line.			*/
      295 
      296 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      297 	/*							*/
      298 	/* PERFORM LEXICAL ANALYSIS:					*/
      299 	/*							*/
      300 	/*  1) str overlays only the characters at the end of the input	*/
      301 	/*     which remain to be lexed.  The address and length of		*/
      302 	/*     str are adjusted after each token is lexed to cause str to	*/
      303 	/*     overlay only the unlexed characters of interest to the lexer.	*/
      304 	/*  2) str is repeatedly lexed for tokens until it is exhausted.	*/
      305 	/*  3) Lexing is performed by searching for lexical delimiters in str.*/
      306 	/*  4) For each lexical delimiter found, the following is done:	*/
      307 	/*     a) If the delimiter is not at the very beginning of str, then	*/
      308 	/*	a token preceeds it.  Create a descriptor for this token.	*/
      309 	/*     b) Access the control character for the found delimiter.  This	*/
      310 	/*	character is a group of bits (see delim) which specify	*/
      311 	/*	what type of delimiter was found, and whether or not the	*/
      312 	/*	delimiter should be ignored or should be represented by a	*/
      313 	/*	token.  Delimiter types include: quoting char, comment	*/
      314 	/*	opening char, comment closing char, and stmt delimiter, or	*/
      315 	/*	a regular break character or new-line character.		*/
      316 	/*     c)	If the delimiter is a new-line char, increment the line	*/
      317 	/*	counter.  If the new-line occurs at the beginning of a stmt,*/
      318 	/*	update stmt descriptors line-no-of-stmt value.		*/
      319 	/*     d) If delimiter is a quoting char (or 1st char of a multi-char	*/
      320 	/*	quoting delimiter), then process the quoted string and the	*/
      321 	/*	trailing quoting character(s).			*/
      322 	/*     e) If delimiter is a comment opening char (or 1st char of a	*/
      323 	/*	multi-char comment opening delimiter), then process the	*/
      324 	/*	comment, including the comment closing character(s).	*/
      325 	/*     f) If the delimiter is a stmt termination delimiter, then	*/
      326 	/*	perform stmt termination functions and new stmt initiation	*/
      327 	/*	functions, creating a token for stmt terminator if req'd.	*/
      328 	/*     g) If the delimiter is a regular break, create a token for it	*/
      329 	/*	unless it is to be ignored.  If an ignored break is a	*/
      330 	/*	white-space char and it appears at the beginning of a stmt,	*/
      331 	/*	exclude it from the body of the stmt.			*/
      332 	/*  5) If no more delimiters are found but some part of str remains,	*/
      333 	/*     it is considered to be a token;  build a token descriptor.	*/
      334 	/*							*/
      335 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      336 
      337 LEX:
      338 	do while (Lstr > 0);
      339 	     i = search(str, lex_delims);
      340 RE_LEX:	     if i = 0 then do;
      341 		/* No more delimiters, but some of str left.  It's a token.	*/
      342 		call token_(Pstr, Lstr);
      343 		Lstr = 0;
      344 		go to END_LEX;
      345 		end;
      346 
      347 	     if i > 1 then do;
      348 		/* Token appears before delimiter.			*/
      349 		call token_(Pstr, i-1);
      350 		Pstr = addr(str_array(i));
      351 		Lstr = Lstr - (i-1);
      352 		/* Adjust str to overlay part of str beyond token.	*/
      353 		end;
      354 
      355 	     delim_control_char = substr(lex_control_chars, index(lex_delims, first_str_char), 1);
      356 
      357 	     if delim.quote_open.S then
      358 		if length(quote_open) = 1 then do;
      359 		     call quote_;
      360 		     go to END_LEX;
      361 		     end;
      362 		else if Lstr >= length(quote_open) then
      363 		     if substr(str,1,length(quote_open)) = quote_open then do;
      364 			call quote_;
      365 			go to END_LEX;
      366 			end;
      367 
      368 	     if delim.comment_open.S then
      369 		if length(comment_open) = 1 then do;
      370 		     call comment_;
      371 		     go to END_LEX;
      372 		     end;
      373 		else if Lstr >= length(comment_open) then
      374 		     if substr(str,1,length(comment_open)) = comment_open then do;
      375 			call comment_;
      376 			go to END_LEX;
      377 			end;
      378 
      379 	     if delim.stmt.S then
      380 		if length(stmt_delim) = 1 then do;
      381 		     call stmt_;
      382 		     go to END_LEX;
      383 		     end;
      384 		else if Lstr >= length(stmt_delim) then
      385 		     if substr(str,1,length(stmt_delim)) = stmt_delim then do;
      386 			call stmt_;
      387 			go to END_LEX;
      388 			end;
      389 
      390 	     if delim.new_line.S then do;
      391 		Nlines = Nlines + 1;
      392 		if S.output_stmts then
      393 		     if stmt.Pvalue = Pstr then do;
      394 			stmt.line_no = stmt.line_no + 1;
      395 			stmt.Istmt_in_line = 1;
      396 			end;
      397 		end;
      398 
      399 	     if delim.white_space.S then
      400 		if S.output_stmts then
      401 		     if stmt.Pvalue = Pstr then do;
      402 			stmt.Pvalue = addr(str_array(2));
      403 			stmt.Lvalue = stmt.Lvalue - 1;
      404 			end;
      405 
      406 	     if delim.break.S then do;
      407 		if delim.break.Signore then;
      408 		else
      409 		     call token_(Pstr, 1);
      410 		if Lstr = 1 then
      411 		/* avoid performing substr beyond end of str.		*/
      412 		     Lstr = 0;
      413 		else do;
      414 		     Pstr = addr(str_array(2));
      415 		     Lstr = Lstr - 1;
      416 		     end;
      417 		go to END_LEX;
      418 		end;
      419 
      420 		/* The break character which was found is not a real 	*/
      421 		/* delimiter, but is just the first character of a comment,	*/
      422 		/* quoting, or statement delimiter.  Ignore it.		*/
      423 	     if i > 1 then call unmake_token_;
      424 		/* get rid of any token thought to precede the break.	*/
      425 	     Pstr_search = addr(str_array(i+1));
      426 	     Lstr_search = Lstr - i;
      427 	     k = search(str_search,lex_delims) + i;
      428 	     if k = i then
      429 		i = 0;
      430 	     else
      431 		i = k;
      432 	     go to RE_LEX;
      433 
      434 END_LEX:
      435 	     end LEX;
      436 
      437 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      438 	/*							*/
      439 	/* TERMINATION:						*/
      440 	/*							*/
      441 	/*  1) If stmt's are being delimited but string being lexed did not	*/
      442 	/*     end with a stmt delimiter, return an error code.		*/
      443 	/*     If it did end with a stmt delimiter, get rid of the last stmt	*/
      444 	/*     descriptor (the newest one which is empty), and make the stmt	*/
      445 	/*     descriptor for the stmt containing the last stmt delimiter be	*/
      446 	/*     the last stmt descriptor.				*/
      447 	/*  2) Return ptr-to/length-of unused portion of output storage area.	*/
      448 	/*							*/
      449 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      450 
      451 	if length(stmt_delim) > 0 then
      452 	     if APtoken = null then do;
      453 		code = error_table_$zero_length_seg;
      454 		if S.output_stmts then
      455 		     APstmt = null;
      456 		end;
      457 	     else if token.S.end_of_stmt then
      458 		if S.output_stmts then do;
      459 		     Pstmt = stmt.Plast;
      460 		     stmt.Pnext = null;
      461 		     end;
      462 		else;
      463 	     else
      464 		code = error_table_$no_stmt_delim;
      465 	else if APtoken = null then
      466 	     code = error_table_$zero_length_seg;
      467 
      468 	return;
      469 
      470 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      471 
      472 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      473 
      474 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      475 	/*							*/
      476 	/* COMMENTS:						*/
      477 	/*							*/
      478 	/*  1) Process comments in three parts:  the comment opening	*/
      479 	/*     delimiter;  the comment;  the comment closing delimiter.	*/
      480 	/*  2) Skip over the comment opening delimiter.			*/
      481 	/*  3) If comments are being output, create a token for the comment.	*/
      482 	/*  4) Increment line counter for any new-line chars in comment.	*/
      483 	/*  5) Skip over the comment closing delimiter.			*/
      484 	/*  6) If the string being lexed ends with a comment, and no closing	*/
      485 	/*     delimiter is found for the comment, ignore this condition.	*/
      486 	/*							*/
      487 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      488 
      489 comment_:
      490 	proc;
      491 
      492 	if Lstr = length(comment_open) then do;
      493 		/* str exhausted in mid-comment. That's OK.		*/
      494 	     Lstr = 0;
      495 	     return;
      496 	     end;
      497 	else do;
      498 	     Pstr = addr(str_array(length(comment_open)+1));
      499 	     Lstr = Lstr - length(comment_open);
      500 	     if Snew_line.comm_open then
      501 		Nlines = Nlines + 1;
      502 	     end;
      503 
      504 	k = index (str, comment_close);
      505 
      506 	if k = 0 then do;
      507 		/* remainder of str is the comment.  No comment close delim.*/
      508 	     if S.output_comments then
      509 		call comment_token_(Pstr, Lstr);
      510 	     Lstr = 0;
      511 	     return;
      512 	     end;
      513 
      514 	if S.output_comments then
      515 	     call comment_token_(Pstr, k-1);
      516 
      517 	k = k-1;
      518 	do while (k > 0);
      519 	     Pstr_search = Pstr;
      520 	     Lstr_search = k;
      521 	     j = index(str_search,NL);
      522 	     if j = 0 then
      523 		j = k;
      524 	     else
      525 		Nlines = Nlines + 1;
      526 	     Pstr = addr(str_array(j+1));
      527 	     Lstr = Lstr - j;
      528 	     k = k - j;
      529 	     end;
      530 	if S.equate_comment_close_stmt_delim then;
      531 	else if Lstr = length(comment_close) then
      532 		/* lexing comment close delim exhausts str.		*/
      533 	     Lstr = 0;
      534 	else do;
      535 	     Pstr = addr(str_array(length(comment_close)+1));
      536 	     Lstr = Lstr - length(comment_close);
      537 	     if Snew_line.comm_close then
      538 		Nlines = Nlines + 1;
      539 	     end;
      540 	if S.output_stmts then
      541 	     if stmt.Ntokens = 0 then do;
      542 		stmt.Pvalue = Pstr;
      543 		stmt.Lvalue = Lstr;
      544 		stmt.line_no = Nlines;
      545 		stmt.Istmt_in_line = 1;
      546 		end;
      547 
      548 	end comment_;
      549 
      550 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      551 
      552 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      553 
      554 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      555 	/*							*/
      556 	/* COMMENT DESCRIPTORS:					*/
      557 	/*							*/
      558 	/*  1) Allocate a new token descriptor; chain it onto stmt descr.	*/
      559 	/*  2) Set flags indicating position of comment relative to beginning	*/
      560 	/*     of stmt and relative to the previous comment in this stmt.	*/
      561 	/*							*/
      562 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      563 
      564 comment_token_:
      565 	proc     (P, L);
      566 
      567      dcl
      568 	P			ptr,		/* ptr to comment.	*/
      569 	L			fixed bin(21);	/* length of comment*/
      570 
      571 	if stmt.Pcomments = null then do;
      572 	     Pcomment = allocate (Parea, size(comment));
      573 	     stmt.Pcomments = Pcomment;
      574 	     comment.Plast = null;
      575 	     string(comment.S) = "0"b;
      576 	     Ntokens_in_stmt = stmt.Ntokens;
      577 	     end;
      578 	else do;
      579 	     comment.Pnext = allocate (Parea, size(comment));
      580 	     comment.Pnext -> comment.Plast = comment.Pnext;
      581 	     Pcomment = comment.Pnext;
      582 	     string(comment.S) = "0"b;
      583 	     if Ntokens_in_stmt = stmt.Ntokens then
      584 		comment.S.contiguous = "1"b;
      585 	     Ntokens_in_stmt = stmt.Ntokens;
      586 	     end;
      587 	comment.version = 1;
      588 	comment.size = size(comment);
      589 	comment.Pnext = null;
      590 	comment.Pvalue = P;
      591 	comment.Lvalue = min(max_Lvalue,L);
      592 	comment.line_no = Nlines;
      593 	if stmt.Ntokens = 0 then
      594 	     comment.S.before_stmt = "1"b;
      595 
      596 	end comment_token_;
      597 
      598 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      599 
      600 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      601 
      602 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      603 	/*							*/
      604 	/* QUOTED STRINGS:						*/
      605 	/*							*/
      606 	/*  1) Process quoted strings in three parts:  open quoting delim;	*/
      607 	/*     quoted string;  close quoting delimiter.			*/
      608 	/*  2) If quoting delimiters are not being ignored, create a token	*/
      609 	/*     for the begin quoting delim.				*/
      610 	/*  3) Search for the end of the quoted string, taking into account	*/
      611 	/*     doubled quoting delimiters appearing in the string which	*/
      612 	/*     represent occurrences of the quoting delimiter in the string.	*/
      613 	/*     If the end quoting delim is not found, return an error code and*/
      614 	/*     assume that the remainder of str is the quoted string.	*/
      615 	/*  4) If doubled quoting delimiters appear within the quoted string	*/
      616 	/*     and doubled quotes are _n_o_t being retained, copy the quoted	*/
      617 	/*     string, translating doubled quotes into the single quote	*/
      618 	/*     representation they should have in an unquoted string.	*/
      619 	/*  5) Create a token representing the quoted string (or its copy).	*/
      620 	/*  6) Increment the line counter for any new-line chars which appear	*/
      621 	/*     in the quoted string.					*/
      622 	/*  6) If quoting delimiters are not being ignored, create a token	*/
      623 	/*     for the end quoting delim.				*/
      624 	/*							*/
      625 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      626 
      627 quote_:
      628 	proc;
      629 
      630 	if delim.quote_open.Signore then;
      631 	else
      632 	     call token_(Pstr, length(quote_open));
      633 	if Lstr = length(quote_open) then do;
      634 	     /* begin quote delim appears at end of str.			*/
      635 	     Lstr = 0;
      636 	     code = error_table_$unbalanced_quotes;
      637 	     return;
      638 	     end;
      639 	else do;
      640 	     Pstr = addr(str_array(length(quote_open)+1));
      641 	     Lstr = Lstr - length(quote_open);
      642 	     if Snew_line.quote_open then
      643 		Nlines = Nlines + 1;
      644 	     end;
      645 
      646 	k = index(str,quote_close);
      647 	if k = 0 then do;
      648 	     call token_(Pstr, Lstr);
      649 	     token.S.quoted_string = "1"b;
      650 	     Lstr = 0;
      651 	     code = error_table_$unbalanced_quotes;
      652 	     return;
      653 	     end;
      654 
      655 	l = index(str,doubled_quote);
      656 
      657 	if l ^= k then do;
      658 		/* No doubled quoting delims appear in the quoted string.	*/
      659 	     k = k-1;
      660 	     call token_(Pstr, k);
      661 	     token.S.quoted_string = "1"b;
      662 	     do while (k > 0);
      663 		Pstr_search = Pstr;
      664 		Lstr_search = k;
      665 		j = index(str_search,NL);
      666 		if j = 0 then
      667 		     j = k;
      668 		else
      669 		     Nlines = Nlines + 1;
      670 		Pstr = addr(str_array(j+1));
      671 		Lstr = Lstr - j;
      672 		k = k - j;
      673 		end;
      674 	     end;
      675 	else do;
      676 		/* Doubled quotes were found within the quoted string.	*/
      677 		/*  1) Compute length of quoted string, including doubled	*/
      678 		/*     quotes.					*/
      679 		/*  2) Count number of doubled quotes as length is computed.*/
      680 		/*  3) Unless doubled quotes are to be retained, copy the	*/
      681 		/*     quoted string, translating double to single quotes.	*/
      682 		/*  4) Create a token for the quoted string (or its copy).	*/
      683 	     Pquote_str = Pstr;
      684 	     Lquote_str = 0;
      685 	     Ndoubled_quotes = 0;
      686 
      687 	     do while (l = k);
      688 		/* Do until end of quoted string is found.		*/
      689 		Lquote_incr = (l-1) + length(doubled_quote);
      690 		Lquote_str = Lquote_str + Lquote_incr;
      691 		Ndoubled_quotes = Ndoubled_quotes + 1;
      692 		if Lstr = Lquote_incr then do;
      693 		     Lstr = 0;
      694 		     code = error_table_$unbalanced_quotes;
      695 		     go to DONE_QUOTING;
      696 		     end;
      697 		Pstr = addr(str_array(Lquote_incr+1));
      698 		Lstr = Lstr - Lquote_incr;
      699 
      700 		k = index(str, quote_close);
      701 		if k = 0 then do;
      702 		     Lquote_str = Lquote_str + Lstr;
      703 		     Lstr = 0;
      704 		     code = error_table_$unbalanced_quotes;
      705 		     go to DONE_QUOTING;
      706 		     end;
      707 
      708 		l = index(str,doubled_quote);
      709 		end;
      710 
      711 	     Lquote_str = Lquote_str + (k-1);
      712 	     Pstr = addr(str_array(k));
      713 	     Lstr = Lstr - (k-1);
      714 
      715 DONE_QUOTING:
      716 	     if S.retain_doubled_quotes then do;
      717 		Pquote_copy = Pquote_str;
      718 		Lquote_copy = Lquote_str;
      719 		end;
      720 	     else do;
      721 	          Lquote_copy = Lquote_str - (Ndoubled_quotes * length(quote_close));
      722 		Pquote_copy = allocate (Parea, size(quote_copy));
      723 	          Lquote_copy = 0;
      724 	     
      725 	          do while (Lquote_str > 0);
      726 	               k = index(quote_str, quote_close);
      727 	               if k = 0 then do;
      728 	                    Lquote_copy = Lquote_copy + Lquote_str;
      729 	                    substr(quote_copy, Lquote_copy-Lquote_str+1) = quote_str;
      730 	                    Lquote_str = 0;
      731 	                    end;
      732 	               else do;
      733 	                    Lquote_copy = Lquote_copy + k;
      734 	                    substr(quote_copy, Lquote_copy-(k-1)) = quote_str;
      735 	                    Pquote_str = addr(quote_str_array(k+2));
      736 	                    Lquote_str = Lquote_str - (k+1);
      737 	                    end;
      738 	               end;
      739 		end;
      740 	     
      741 	     call token_(Pquote_copy,Lquote_copy);
      742 	     token.S.quoted_string = "1"b;
      743 	     token.S.quotes_in_string = "1"b;
      744 	     token.S.quotes_doubled = S.retain_doubled_quotes;
      745 	     do while (Lquote_copy > 0);
      746 		j = index(quote_copy,NL);
      747 		if j = 0 then
      748 		     j = Lquote_copy;
      749 		else
      750 		     Nlines = Nlines + 1;
      751 		if Lquote_copy > j then
      752 		     Pquote_copy = addr(quote_copy_array(j+1));
      753 		Lquote_copy = Lquote_copy - j;
      754 		end;
      755 	     if Lstr = 0 then
      756 		return;
      757 	     end;
      758 
      759 	if delim.quote_open.Signore then;
      760 	else
      761 	     call token_(Pstr,length(quote_close));
      762 	if Lstr = length(quote_close) then
      763 	     Lstr = 0;
      764 	else do;
      765 	     Pstr = addr(str_array(length(quote_close)+1));
      766 	     Lstr = Lstr - length(quote_close);
      767 	     if Snew_line.quote_close then
      768 		Nlines = Nlines + 1;
      769 	     end;
      770 
      771 	end quote_;
      772 
      773 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      774 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      775 	/*							*/
      776 	/* STATEMENT DESCRIPTORS:					*/
      777 	/*							*/
      778 	/*  1) If stmt delims are not being ignored, create a stmt delim token*/
      779 	/*  2) If stmt descriptors are being output, fill in remaining values	*/
      780 	/*     for current stmt, and create next stmt descriptor.  Otherwise,	*/
      781 	/*     reset count of tokens in stmt so tokens will have good count.	*/
      782 	/*							*/
      783 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      784 
      785 stmt_:
      786 	proc;
      787 
      788 	if delim.stmt.Signore then;
      789 	else
      790 	     call token_(Pstr,length(stmt_delim));
      791 	if APtoken ^= null then
      792 	     token.S.end_of_stmt = "1"b;
      793 
      794 	if Lstr = length(stmt_delim) then
      795 	     Lstr = 0;
      796 	else do;
      797 	     Pstr = addr(str_array(length(stmt_delim)+1));
      798 	     Lstr = Lstr - length(stmt_delim);
      799 	     if Snew_line.stmt_delim then
      800 		Nlines = Nlines + 1;
      801 	     end;
      802 
      803 	if S.output_stmts then do;
      804 	     stmt.Lvalue = min(max_Lvalue, stmt.Lvalue - Lstr);
      805 	     if stmt.line_no = Nlines then
      806 		Nstmt = stmt.Istmt_in_line + 1;
      807 	     else
      808 		Nstmt = 1;
      809 	     stmt.Pnext = allocate (Parea, size(stmt));
      810 	     stmt.Pnext -> stmt.Plast = Pstmt;
      811 	     Pstmt = stmt.Pnext;
      812 	     stmt.version = 1;
      813 	     stmt.size = size(stmt);
      814 	     stmt.Pnext = null;
      815 	     stmt.Pvalue = Pstr;
      816 	     stmt.Lvalue = Lstr;
      817 	     stmt.Pfirst_token = null;
      818 	     stmt.Plast_token = null;
      819 	     stmt.Puser = null;
      820 	     stmt.Pcomments = null;
      821 	     stmt.Ntokens = 0;
      822 	     stmt.semant_type = 0;
      823 	     stmt.line_no = Nlines;
      824 	     stmt.Istmt_in_line = Nstmt;
      825 	     string(stmt.group2.S) = "0"b;
      826 	     end;
      827 
      828 	else
      829 	     Ntokens_in_stmt = 0;
      830 
      831 	end stmt_;
      832 
      833 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      834 
      835 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      836 
      837 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      838 	/*							*/
      839 	/* TOKEN DESCRIPTORS:					*/
      840 	/*							*/
      841 	/*  1) Allocate a new token descriptor, chained onto previous one.	*/
      842 	/*     If a used token already exists, reuse it.			*/
      843 	/*  2) Fill in the token descriptor from input arguments.		*/
      844 	/*  3) If stmt descriptors are being output, fill in token's stmt	*/
      845 	/*     position information and stmt descriptor's token information.	*/
      846 	/*  4) If this is the first token, fill in argument ptr to token chain*/
      847 	/*							*/
      848 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      849 
      850 token_:
      851 	proc     (P, L);
      852 
      853      dcl
      854 	P			ptr,		/* ptr to token.	*/
      855 	L			fixed bin(21);	/* length of token.	*/
      856 
      857 	if Sreuse_token then Sreuse_token = "0"b;
      858 	else
      859 	     if APtoken = null then do;
      860 	          Ptoken = allocate (Parea, size(token));
      861 	          token.Plast = null;
      862 	          APtoken = Ptoken;
      863 	          end;
      864 	     else do;
      865 	          token.Pnext = allocate (Parea, size(token));
      866 	          token.Pnext -> token.Plast = Ptoken;
      867 	          Ptoken = token.Pnext;
      868 	          end;
      869 	token.version = 1;
      870 	token.size = size(token);
      871 	token.Pnext = null;
      872 	token.Pvalue = P;
      873 	token.Lvalue = min(max_Lvalue,L);
      874 	token.Nvalue = 0;
      875 	string(token.S) = "0"b;
      876 
      877 	if S.output_stmts then do;
      878 	     token.Pstmt = Pstmt;
      879 	     stmt.Ntokens = stmt.Ntokens + 1;
      880 	     token.Itoken_in_stmt = stmt.Ntokens;
      881 	     stmt.Plast_token = Ptoken;
      882 	     if stmt.Pfirst_token = null then
      883 		stmt.Pfirst_token = Ptoken;
      884 	     end;
      885 	else do;
      886 	     token.Pstmt = null;
      887 	     Ntokens_in_stmt = Ntokens_in_stmt + 1;
      888 	     token.Itoken_in_stmt = Ntokens_in_stmt;
      889 	     end;
      890 
      891 	token.Psemant = null;
      892 	token.line_no = Nlines;
      893 
      894 	end token_;
      895 
      896 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      897 
      898 
      899 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      900 	/*							*/
      901 	/* DELETING THE LAST TOKEN WHICH WAS CREATED:			*/
      902 	/*							*/
      903 	/* 1) Set a flag indicating that the last token descriptor is to be	*/
      904 	/*    reused in the next call to token_.			*/
      905 	/* 2) Adjust the bounds of the string to include the last token.	*/
      906 	/* 3) Adjust token counts in statement descriptor or temp. counter.	*/
      907 	/*							*/
      908 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      909 
      910 unmake_token_:	procedure;
      911 
      912 	Sreuse_token = "1"b;
      913 	Pstr = token.Pvalue;
      914 	Lstr = Lstr + token.Lvalue;
      915 	if S.output_stmts then do;
      916 	     stmt.Ntokens = stmt.Ntokens - 1;
      917 	     if stmt.Plast_token = stmt.Pfirst_token then do;
      918 		stmt.Pfirst_token = null;
      919 		stmt.Plast_token  = null;
      920 		end;
      921 	     else stmt.Plast_token  = token.Plast;
      922 	     end;
      923 	else Ntokens_in_stmt = Ntokens_in_stmt - 1;
      924 
      925 	end unmake_token_;
      926 
      927 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      928 
      929 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      930 	/*							*/
      931 	/* INITIALIZE LEX DELIMITERS:					*/
      932 	/*							*/
      933 	/*  1) Input includes the quote delimiters, comment-open delimiter,	*/
      934 	/*     comment-close delimiter, stmt delimiter, break characters,	*/
      935 	/*     ignored break characters, and switches indicating whether	*/
      936 	/*     quote delimiters and stmt delimiters are to be ignored.	*/
      937 	/*  2) Create a lex_delims character string consisting of the first	*/
      938 	/*     character of the quote delimiter, comment-open delimiter,	*/
      939 	/*     stmt delimiter, along with a new-line char and the other	*/
      940 	/*     white-space chars (all ASCII control chars except BS & HT),	*/
      941 	/*     and each of the user-specified break characters.		*/
      942 	/*  3) For each character in lex_delims, create a corresponding char	*/
      943 	/*     in lex_control_chars specifying what type of the lex_delim	*/
      944 	/*     character is.  (Each character of lex_control_chars can be	*/
      945 	/*     overlaid by the delim bit string structure.)		*/
      946 	/*							*/
      947 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      948 
      949 init_lex_delims:
      950 	entry    (Aquote_open, Aquote_close, Acomment_open, Acomment_close, Astmt_delim, AS,
      951 		breaks, ignored_breaks, lex_delims, lex_control_chars);
      952 
      953 	quote_open = Aquote_open;
      954 	comment_open = Acomment_open;
      955 	stmt_delim = Astmt_delim;
      956 	Sarg = AS;
      957 
      958 	lex_delims = "";
      959 	lex_control_chars = "";
      960 	spec_lex_delims = "";
      961 	spec_lex_control_chars = "";
      962 
      963 	if length(quote_open) > 0 then do;
      964 	     ch = substr(quote_open,1,1);
      965 	     spec_lex_delims = ch;
      966 	     string(delim) = "0"b;
      967 	     delim.quote_open.S = "1"b;
      968 	     delim.quote_open.Signore = Signore.quote;
      969 	     spec_lex_control_chars = delim_control_char;
      970 	     end;
      971 
      972 	if length(comment_open) > 0 then do;
      973 	     ch = substr(comment_open,1,1);
      974 	     if length(spec_lex_delims) > 0 then
      975 		i = index(spec_lex_delims,ch);
      976 	     else
      977 		i = 0;
      978 	     if i > 0 then
      979 		delim_control_char = substr(spec_lex_control_chars,i,1);
      980 	     else do;
      981 		spec_lex_delims = spec_lex_delims || ch;
      982 		string(delim) = "0"b;
      983 		end;
      984 	     delim.comment_open.S = "1"b;
      985 	     if i > 0 then
      986 		substr(spec_lex_control_chars,i,1) = delim_control_char;
      987 	     else
      988 		spec_lex_control_chars = spec_lex_control_chars || delim_control_char;
      989 	     end;
      990 
      991 	if length(stmt_delim) > 0 then do;
      992 	     ch = substr(stmt_delim,1,1);
      993 	     if length(spec_lex_delims) > 0 then
      994 		i = index(spec_lex_delims,ch);
      995 	     else
      996 		i = 0;
      997 	     if i > 0 then
      998 		delim_control_char = substr(spec_lex_control_chars,i,1);
      999 	     else do;
     1000 		spec_lex_delims = spec_lex_delims || ch;
     1001 		string(delim) = "0"b;
     1002 		end;
     1003 	     delim.stmt.S = "1"b;
     1004 	     delim.stmt.Signore = Signore.stmt;
     1005 	     if i > 0 then
     1006 		substr(spec_lex_control_chars,i,1) = delim_control_char;
     1007 	     else
     1008 		spec_lex_control_chars = spec_lex_control_chars || delim_control_char;
     1009 	     end;
     1010 
     1011 	do k = 1 to length(breaks);
     1012 	     ch = substr(breaks,k,1);
     1013 	     if length(spec_lex_delims) > 0 then
     1014 		i = index(spec_lex_delims,ch);
     1015 	     else
     1016 		i = 0;
     1017 	     if i > 0 then
     1018 		delim_control_char = substr(spec_lex_control_chars,i,1);
     1019 	     else do;
     1020 		lex_delims = lex_delims || ch;
     1021 		string(delim) = "0"b;
     1022 		end;
     1023 	     delim.break.S = "1"b;
     1024 	     l = index(ignored_breaks,ch);
     1025 	     if l > 0 then
     1026 		delim.break.Signore = "1"b;
     1027 	     if i > 0 then
     1028 		substr(spec_lex_control_chars,i,1) = delim_control_char;
     1029 	     else
     1030 		lex_control_chars = lex_control_chars || delim_control_char;
     1031 	     end;
     1032 
     1033 	lex_delims = lex_delims || spec_lex_delims;
     1034 	lex_control_chars = lex_control_chars || spec_lex_control_chars;
     1035 
     1036 	i = index(lex_delims, NL);
     1037 	if i > 0 then do;
     1038 	     delim_control_char = substr(lex_control_chars,i,1);
     1039 	     if delim.break.Signore then do;
     1040 		delim.white_space.S = "1"b;
     1041 		delim.new_line.S = "1"b;
     1042 		substr(lex_control_chars,i,1) = delim_control_char;
     1043 		end;
     1044 	     end;
     1045 	i = index(lex_delims, NP);
     1046 	if i > 0 then do;
     1047 	     delim_control_char = substr(lex_control_chars,i,1);
     1048 	     if delim.break.Signore then do;
     1049 		delim.white_space.S = "1"b;
     1050 		substr(lex_control_chars,i,1) = delim_control_char;
     1051 		end;
     1052 	     end;
     1053 
     1054 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1055 
     1056 
  2     1 /* BEGINNING OF:	translator_temp_alloc.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  translator_temp_alloc.incl.pl1					*/
  2     6 	/*									*/
  2     7 	/*      This include segment allocates space in a translator's temporary segment.  It 	*/
  2     8 	/* contains a complete space allocation function 'allocate' which can be a quick PL/I	*/
  2     9 	/* internal procedure in the program which includes this include segment.  The temporary	*/
  2    10 	/* segment should be one obtained by using the translator_temp_ subroutine.		*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created by:  G. C. Dixon  in  January, 1975.				*/
  2    15 	/* 1) Modified by: G. C. Dixon  in  February, 1981 - use limit area structure.		*/
  2    16 	/*									*/
  2    17 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    18 
  2    19 
  2    20 
  2    21 allocate:	procedure (Parea, ANwords) returns (ptr);
  2    22 
  2    23      dcl	Parea			ptr,		/* ptr to the temporary segment. (In)		*/
  2    24 	ANwords			fixed bin;	/* number of words to be allocated. (In)	*/
  2    25 
  2    26      dcl	Nwords			fixed bin,	/* number of words to be allocated, rounded up	*/
  2    27 						/* to a 0 mod 2 quantity.			*/
  2    28 	P			ptr,		/* a temporary pointer.			*/
  2    29 	code			fixed bin(35),	/* a status code.				*/
  2    30          (mod, null, ptr)		builtin;
  2    31 
  2    32      dcl	1 area			based (Parea),
  2    33 	  2 Pfirst_temp_seg		ptr unal,		/*   ptr to first temp seg of a group.		*/
  2    34 	  2 Ofree			fixed bin(35),	/*   offset of next free word in temp seg.	*/
  2    35 	  2 Lfree			fixed bin(35);	/*   length of remaining free space in temp seg.	*/
  2    36 
  2    37      dcl	translator_temp_$get_next_segment
  2    38 				entry (ptr, ptr, fixed bin(35));
  2    39 
  2    40 	Nwords = ANwords + mod (ANwords, 2);		/* round up word count to 0 + mod 2 quantity.	*/
  2    41 	if Nwords > Lfree then do;			/* handle area overflow.			*/
  2    42 	     call translator_temp_$get_next_segment (Parea, P, code);
  2    43 	     if P = null then return (null);
  2    44 	     Parea = P;
  2    45 	     if Nwords > area.Lfree then return (null);
  2    46 	     end;
  2    47 	P = ptr (Parea, area.Ofree);			/* get pointer to next free word of area.	*/
  2    48 	area.Ofree = area.Ofree + Nwords;		/* increase offset of remaining free space.	*/
  2    49 	area.Lfree = area.Lfree - Nwords;		/* decrease length of remaining free space.	*/
  2    50 	return (P);
  2    51 
  2    52 	end allocate;
  2    53 
  2    54 /* END OF:	translator_temp_alloc.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1057 
     1058 
     1059 	end lex_string_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/01/84  0857.7  lex_string_.pl1                   >spec>on>6967.recompile>lex_string_.pl1
164          1    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
1057         2    07/22/81  2045.0  translator_temp_alloc.incl.pl1    >ldd>include>translator_temp_alloc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALstr                                  parameter       fixed bin(21,0)          dcl 31 ref 26 183 187 215
ALstr_ignore                           parameter       fixed bin(21,0)          dcl 31 ref 187 202
ANwords                                parameter       fixed bin(17,0)          dcl 2-23 ref 2-21 2-40 2-40
APstmt                                 parameter       pointer                  dcl 31 set ref 26 187 263* 266* 454*
APstr                                  parameter       pointer                  dcl 31 ref 26 182 187 201
APtoken                                parameter       pointer                  dcl 31 set ref 26 187 270* 451 465 791 858 862*
AS                                     parameter       bit                      unaligned dcl 31 ref 26 187 230 949 956
Acomment_close                         parameter       char                     unaligned dcl 31 ref 26 187 237 949
Acomment_open                          parameter       char                     unaligned dcl 31 ref 26 187 236 949 954
Aquote_close                           parameter       char                     unaligned dcl 31 ref 26 187 233 949
Aquote_open                            parameter       char                     unaligned dcl 31 ref 26 187 232 949 953
Astmt_delim                            parameter       char                     unaligned dcl 31 ref 26 187 238 949 955
Istmt_in_line            12            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-40 set ref 261* 395*
                                                                                  545* 805 824*
Itoken_in_stmt            7            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-68 set ref 880* 888*
L                                      parameter       fixed bin(21,0)          dcl 567 in procedure "comment_token_" ref 564 591
L                                      parameter       fixed bin(21,0)          dcl 853 in procedure "token_" ref 850 873
Lfree                     2            based           fixed bin(35,0)          level 2 dcl 2-32 set ref 2-41 2-45 2-49* 2-49
Lquote_copy                     000100 automatic       fixed bin(21,0)          dcl 56 set ref 718* 721* 722 722 722 722 723* 728*
                                                                                  728 729 729 733* 733 734 734 741* 745 746 747 751
                                                                                  753* 753
Lquote_incr                     000101 automatic       fixed bin(21,0)          dcl 56 set ref 689* 690 692 697 698
Lquote_str                      000102 automatic       fixed bin(21,0)          dcl 56 set ref 684* 690* 690 702* 702 711* 711 718
                                                                                  721 725 726 728 729 729 730* 734 736* 736
Lstr                            000103 automatic       fixed bin(21,0)          dcl 56 set ref 183* 202* 203 204 206 207* 212* 212
                                                                                  215* 248 337 339 342* 343* 351* 351 362 362 373
                                                                                  373 384 384 410 410* 415* 415 426 492 494* 499*
                                                                                  499 504 508* 510* 527* 527 531 531* 536* 536 543
                                                                                  633 635* 641* 641 646 648* 650* 655 671* 671 692
                                                                                  693* 698* 698 700 702 703* 708 713* 713 755 762
                                                                                  762* 766* 766 794 794* 798* 798 804 816 914* 914
Lstr_search                     000104 automatic       fixed bin(21,0)          dcl 56 set ref 426* 427 520* 521 664* 665
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "comment" dcl 1-20 in procedure
                                                                                  "lex_string_" set ref 591*
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "stmt" dcl 1-40 in procedure
                                                                                  "lex_string_" set ref 248* 403* 403 543* 804* 804
                                                                                  816*
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 1-68 in procedure
                                                                                  "lex_string_" set ref 873* 914
NL                                     constant        char(1)                  initial dcl 170 ref 204 274 277 280 283 286 521 665
                                                                                  746 1036
NP                                     constant        char(1)                  initial dcl 170 ref 1045
Ndoubled_quotes                 000105 automatic       fixed bin(17,0)          dcl 56 set ref 685* 691* 691 721
Nlines                          000106 automatic       fixed bin(21,0)          dcl 56 set ref 181* 200* 210* 210 260 391* 391 500*
                                                                                  500 524* 524 537* 537 544 592 642* 642 668* 668
                                                                                  749* 749 767* 767 799* 799 805 823 892
Nstmt                           000107 automatic       fixed bin(17,0)          dcl 56 set ref 805* 807* 824
Ntokens                  11            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-40 set ref 255* 540
                                                                                  576 583 585 593 821* 879* 879 880 916* 916
Ntokens_in_stmt                 000110 automatic       fixed bin(17,0)          dcl 56 set ref 267* 576* 583 585* 828* 887* 887 888
                                                                                  923* 923
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 1-68 set ref 874*
Nwords                          000342 automatic       fixed bin(17,0)          dcl 2-26 set ref 2-40* 2-41 2-45 2-48 2-49
Ofree                     1            based           fixed bin(35,0)          level 2 dcl 2-32 set ref 2-47 2-48* 2-48
P                                      parameter       pointer                  dcl 567 in procedure "comment_token_" ref 564 590
P                                      parameter       pointer                  dcl 853 in procedure "token_" ref 850 872
P                               000344 automatic       pointer                  dcl 2-26 in procedure "allocate" set ref 2-42* 2-43
                                                                                  2-44 2-47* 2-50
Parea                                  parameter       pointer                  dcl 2-23 in procedure "allocate" set ref 2-21 2-41
                                                                                  2-42* 2-44* 2-45 2-47 2-47 2-48 2-48 2-49 2-49
Parea                                  parameter       pointer                  dcl 31 in procedure "lex_string_" set ref 26 187
                                                                                  242* 572* 579* 722* 809* 860* 865*
Pcomment                        000200 automatic       pointer                  dcl 1-20 set ref 572* 572 572 573 574 575 579 579
                                                                                  579 580 580 581* 581 582 583 587 588 588 589 590
                                                                                  591 592 593
Pcomments                 7            based           pointer                  level 2 packed unaligned dcl 1-40 set ref 259* 571
                                                                                  573* 820*
Pfirst_token              5            based           pointer                  level 2 packed unaligned dcl 1-40 set ref 253* 817*
                                                                                  882 882* 917 918*
Plast                     2            based           pointer                  level 2 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 574*
                                                                                  580*
Plast                     2            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 861*
                                                                                  866* 921
Plast                     2            based           pointer                  level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 246*
                                                                                  459 810*
Plast_token               6            based           pointer                  level 2 packed unaligned dcl 1-40 set ref 254* 818*
                                                                                  881* 917 919* 921*
Pnext                     1            based           pointer                  level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 245*
                                                                                  460* 809* 810 811 814*
Pnext                     1            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 865*
                                                                                  866 867 871*
Pnext                     1            based           pointer                  level 2 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 579*
                                                                                  580 580 581 589*
Pquote_copy                     000112 automatic       pointer                  dcl 56 set ref 717* 722* 722 722 729 734 741* 746
                                                                                  751* 751
Pquote_str                      000114 automatic       pointer                  dcl 56 set ref 683* 717 726 729 734 735* 735
Psemant                   6            based           pointer                  level 2 packed unaligned dcl 1-68 set ref 891*
Pstmt                           000202 automatic       pointer                  dcl 1-40 in procedure "lex_string_" set ref 242* 242
                                                                                  242 243 244 244 245 246 247 248 253 254 255 257
                                                                                  258 259 260 261 262 263 392 394 394 395 399 402
                                                                                  403 403 459* 459 460 540 542 543 544 545 571 573
                                                                                  576 583 585 593 804 804 805 805 809 809 809 810
                                                                                  810 811* 811 812 813 813 814 815 816 817 818 819
                                                                                  820 821 822 823 824 825 878 879 879 880 881 882
                                                                                  882 916 916 917 917 918 919 921
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 878*
                                                                                  886*
Pstr                            000116 automatic       pointer                  dcl 56 set ref 182* 201* 204 206* 206 211* 211 247
                                                                                  339 342* 349* 350* 350 355 362 373 384 392 399 402
                                                                                  408* 414* 414 425 498* 498 504 508* 514* 519 526*
                                                                                  526 535* 535 542 631* 640* 640 646 648* 655 660*
                                                                                  663 670* 670 683 697* 697 700 708 712* 712 760*
                                                                                  765* 765 789* 797* 797 815 913*
Pstr_search                     000120 automatic       pointer                  dcl 56 set ref 425* 427 519* 521 663* 665
Ptoken                          000204 automatic       pointer                  dcl 1-68 set ref 457 649 661 742 743 744 791 860*
                                                                                  860 860 861 862 865 865 865 866 866 867* 867 869
                                                                                  870 870 871 872 873 874 875 878 880 881 882 886
                                                                                  888 891 892 913 914 921
Puser                    10            based           pointer                  level 2 packed unaligned dcl 1-40 set ref 257* 819*
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 872*
                                                                                  913
Pvalue                    3            based           pointer                  level 2 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 590*
Pvalue                    3            based           pointer                  level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 247*
                                                                                  392 399 402* 542* 815*
S                        11            based           structure                level 3 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 875*
S                                      based           structure                level 1 packed unaligned dcl 108 in procedure
                                                                                  "lex_string_"
S                         5(18)        based           structure                level 3 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 575*
                                                                                  582*
S                                      based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 399
                                                                                  1040* 1049*
S                         0(07)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 406
                                                                                  1023*
S                         0(05)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 379
                                                                                  1003*
S                         0(03)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 357
                                                                                  967*
S                         0(01)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 390
                                                                                  1041*
S                         0(02)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 368
                                                                                  984*
S                        13            based           structure                level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 262*
                                                                                  825*
Sarg                            000122 automatic       bit(36)                  dcl 56 set ref 230* 231 231 231 240 289 292 293 392
                                                                                  399 454 457 508 514 530 540 715 744 803 877 915
                                                                                  956* 968 1004
Signore                   0(08)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 407
                                                                                  1025* 1039 1048
Signore                   0(04)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 630 759
                                                                                  968*
Signore                   0(06)        based           bit(1)                   level 3 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" set ref 788
                                                                                  1004*
Signore                                based           structure                level 1 packed unaligned dcl 108 in procedure
                                                                                  "lex_string_"
Snew_line                       000123 automatic       structure                level 1 dcl 56 set ref 273*
Sreuse_token                    000130 automatic       bit(1)                   initial dcl 56 set ref 56* 857 857* 912*
addr                                                   builtin function         dcl 166 ref 206 211 231 231 231 240 289 292 293 350
                                                                                  357 368 379 390 392 399 399 402 406 407 414 425
                                                                                  454 457 498 508 514 526 530 535 540 630 640 670
                                                                                  697 712 715 735 744 751 759 765 788 797 803 877
                                                                                  915 966 967 968 968 982 984 1001 1003 1004 1004
                                                                                  1021 1023 1025 1039 1040 1041 1048 1049
area                                   based           structure                level 1 unaligned dcl 2-32
before_stmt               5(18)        based           bit(1)                   level 4 packed unaligned dcl 1-20 set ref 593*
break                     0(07)        based           structure                level 2 packed unaligned dcl 108
breaks                                 parameter       varying char             dcl 31 ref 26 187 949 1011 1012
ch                              000131 automatic       char(1)                  dcl 56 set ref 964* 965 973* 974 981 992* 993 1000
                                                                                  1012* 1013 1020 1024
code                                   parameter       fixed bin(35,0)          dcl 31 in procedure "lex_string_" set ref 26 187
                                                                                  271* 453* 463* 465* 636* 651* 694* 704*
code                            000346 automatic       fixed bin(35,0)          dcl 2-26 in procedure "allocate" set ref 2-42*
comm_close                3     000123 automatic       bit(1)                   level 2 dcl 56 set ref 283* 537
comm_open                 2     000123 automatic       bit(1)                   level 2 dcl 56 set ref 280* 500
comment                                based           structure                level 1 dcl 1-20 set ref 572 572 579 579 588
comment_close                   000132 automatic       varying char(4)          dcl 56 set ref 237* 283 283 289 504 531 535 536
comment_open              0(02)        based           structure                level 2 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_"
comment_open                    000134 automatic       varying char(4)          dcl 56 in procedure "lex_string_" set ref 236* 280
                                                                                  280 368 373 373 373 492 498 499 954* 972 973
contiguous                5(19)        based           bit(1)                   level 4 packed unaligned dcl 1-20 set ref 583*
delim                                  based           structure                level 1 packed unaligned dcl 108 set ref 966* 982*
                                                                                  1001* 1021*
delim_control_char              000136 automatic       char(1)                  dcl 56 set ref 355* 357 368 379 390 399 406 407 630
                                                                                  759 788 966 967 968 969 978* 982 984 985 987 997*
                                                                                  1001 1003 1004 1005 1007 1017* 1021 1023 1025 1027
                                                                                  1029 1038* 1039 1040 1041 1042 1047* 1048 1049
                                                                                  1050
doubled_quote                   000137 automatic       varying char(8)          dcl 56 set ref 234* 235* 235 655 689 708
end_of_stmt              11            based           bit(1)                   level 4 packed unaligned dcl 1-68 set ref 457 791*
equate_comment_close_stmt_delim
                          0(03)        based           bit(1)                   level 2 packed unaligned dcl 108 set ref 289 292*
                                                                                  293* 530
error_table_$no_stmt_delim      000010 external static fixed bin(35,0)          dcl 170 ref 463
error_table_$unbalanced_quotes  000012 external static fixed bin(35,0)          dcl 170 ref 636 651 694 704
error_table_$zero_length_seg    000014 external static fixed bin(35,0)          dcl 170 ref 453 465
first_str_char                         based           char(1)                  unaligned dcl 108 ref 355
group1                                 based           structure                level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_"
group1                                 based           structure                level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_"
group1                                 based           structure                level 2 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_"
group2                    5            based           structure                level 2 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_"
group2                    7            based           structure                level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_"
group2                   11            based           structure                level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_"
i                               000142 automatic       fixed bin(21,0)          dcl 56 set ref 204* 205 211 212 339* 340 347 349 350
                                                                                  351 423 425 426 427 428 428* 430* 974* 976* 978
                                                                                  978 985 985 993* 995* 997 997 1005 1005 1013*
                                                                                  1015* 1017 1017 1027 1027 1036* 1037 1038 1042
                                                                                  1045* 1046 1047 1050
ignored_breaks                         parameter       varying char             dcl 31 ref 26 187 949 1024
index                                                  builtin function         dcl 166 ref 204 274 277 280 283 286 355 504 521 646
                                                                                  655 665 700 708 726 746 974 993 1013 1024 1036
                                                                                  1045
j                               000143 automatic       fixed bin(17,0)          dcl 56 set ref 521* 522 522* 526 527 528 665* 666
                                                                                  666* 670 671 672 746* 747 747* 751 751 753
k                               000144 automatic       fixed bin(21,0)          dcl 56 set ref 427* 428 430 504* 506 514 517* 517
                                                                                  518 520 522 528* 528 646* 647 657 659* 659 660*
                                                                                  662 664 666 672* 672 687 700* 701 711 712 713 726*
                                                                                  727 733 734 735 736 1011* 1012*
l                               000145 automatic       fixed bin(21,0)          dcl 56 set ref 655* 657 687 689 708* 1024* 1025
length                                                 builtin function         dcl 166 ref 240 274 277 280 283 286 289 357 362 362
                                                                                  368 373 373 379 384 384 451 492 498 499 531 535
                                                                                  536 631 631 633 640 641 689 721 760 760 762 765
                                                                                  766 789 789 794 797 798 963 972 974 991 993 1011
                                                                                  1013
lex_control_chars                      parameter       varying char             dcl 31 set ref 26 187 355 949 959* 1029* 1029 1034*
                                                                                  1034 1038 1042* 1047 1050*
lex_delims                             parameter       varying char             dcl 31 set ref 26 187 339 355 427 949 958* 1020*
                                                                                  1020 1033* 1033 1036 1045
line_no                  11(18)        based           fixed bin(17,0)          level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 260*
                                                                                  394* 394 544* 805 823*
line_no                   5            based           fixed bin(17,0)          level 3 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 592*
line_no                   7(18)        based           fixed bin(17,0)          level 3 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 892*
max_Lvalue                             constant        fixed bin(18,0)          initial dcl 170 ref 591 804 873
min                                                    builtin function         dcl 166 ref 591 804 873
mod                                                    builtin function         dcl 2-26 ref 2-40
new_line                  0(01)        based           structure                level 2 packed unaligned dcl 108
null                                                   builtin function         dcl 166 in procedure "lex_string_" ref 245 246 253
                                                                                  254 257 259 266 270 451 454 460 465 571 574 589
                                                                                  791 814 817 818 819 820 858 861 871 882 886 891
                                                                                  918 919
null                                                   builtin function         dcl 2-26 in procedure "allocate" ref 2-43 2-43 2-45
output_comments           0(01)        based           bit(1)                   level 2 packed unaligned dcl 108 set ref 231* 231
                                                                                  508 514
output_stmts                           based           bit(1)                   level 2 packed unaligned dcl 108 ref 231 240 392 399
                                                                                  454 457 540 803 877 915
ptr                                                    builtin function         dcl 2-26 ref 2-47
quote                                  based           bit(1)                   level 2 packed unaligned dcl 108 ref 968
quote_close               1     000123 automatic       bit(1)                   level 2 in structure "Snew_line" dcl 56 in procedure
                                                                                  "lex_string_" set ref 277* 767
quote_close                     000146 automatic       varying char(4)          dcl 56 in procedure "lex_string_" set ref 233* 234
                                                                                  235 277 277 646 700 721 726 760 760 762 765 766
quote_copy                             based           char                     unaligned dcl 108 set ref 722 722 729* 734* 746
quote_copy_array                       based           char(1)                  array unaligned dcl 108 set ref 751
quote_open                      000123 automatic       bit(1)                   level 2 in structure "Snew_line" dcl 56 in procedure
                                                                                  "lex_string_" set ref 274* 642
quote_open                0(03)        based           structure                level 2 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_"
quote_open                      000150 automatic       varying char(4)          dcl 56 in procedure "lex_string_" set ref 232* 274
                                                                                  274 357 362 362 362 631 631 633 640 641 953* 963
                                                                                  964
quote_str                              based           char                     unaligned dcl 108 ref 726 729 734
quote_str_array                        based           char(1)                  array unaligned dcl 108 set ref 735
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 1-68 set ref 649* 661*
                                                                                  742*
quotes_doubled           11(03)        based           bit(1)                   level 4 packed unaligned dcl 1-68 set ref 744*
quotes_in_string         11(02)        based           bit(1)                   level 4 packed unaligned dcl 1-68 set ref 743*
retain_doubled_quotes
                          0(02)        based           bit(1)                   level 2 packed unaligned dcl 108 ref 715 744
search                                                 builtin function         dcl 166 ref 339 427
semant_type              12(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-40 set ref 258* 822*
size                      0(18)        based           fixed bin(17,0)          level 3 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 588*
size                      0(18)        based           fixed bin(17,0)          level 3 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 870*
size                      0(18)        based           fixed bin(17,0)          level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 244*
                                                                                  813*
size                                                   builtin function         dcl 166 in procedure "lex_string_" ref 242 242 244
                                                                                  572 572 579 579 588 722 722 809 809 813 860 860
                                                                                  865 865 870
spec_lex_control_chars          000152 automatic       varying char(36)         dcl 56 set ref 961* 969* 978 985* 987* 987 997 1005*
                                                                                  1007* 1007 1017 1027* 1034
spec_lex_delims                 000164 automatic       varying char(36)         dcl 56 set ref 960* 965* 974 974 981* 981 993 993
                                                                                  1000* 1000 1013 1013 1033
stmt                      0(01)        based           bit(1)                   level 2 in structure "Signore" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_" ref 1004
stmt                      0(05)        based           structure                level 2 in structure "delim" packed unaligned
                                                                                  dcl 108 in procedure "lex_string_"
stmt                                   based           structure                level 1 dcl 1-40 in procedure "lex_string_" set ref
                                                                                  242 242 244 809 809 813
stmt_delim                4     000123 automatic       bit(1)                   level 2 in structure "Snew_line" dcl 56 in procedure
                                                                                  "lex_string_" set ref 286* 799
stmt_delim                      000176 automatic       varying char(4)          dcl 56 in procedure "lex_string_" set ref 238* 240
                                                                                  286 286 289 289 379 384 384 384 451 789 789 794
                                                                                  797 798 955* 991 992
str                                    based           char                     unaligned dcl 108 ref 204 339 362 373 384 504 646
                                                                                  655 700 708
str_array                              based           char(1)                  array unaligned dcl 108 set ref 206 211 350 402 414
                                                                                  425 498 526 535 640 670 697 712 765 797
str_search                             based           char                     unaligned dcl 108 ref 427 521 665
string                                                 builtin function         dcl 166 set ref 262* 273* 575* 582* 825* 875* 966*
                                                                                  982* 1001* 1021*
substr                                                 builtin function         dcl 166 set ref 355 362 373 384 729* 734* 964 973
                                                                                  978 985* 992 997 1005* 1012 1017 1027* 1038 1042*
                                                                                  1047 1050*
token                                  based           structure                level 1 dcl 1-68 set ref 860 860 865 865 870
translator_temp_$get_next_segment
                                000016 constant        entry                    external dcl 2-37 ref 2-42
version                                based           fixed bin(17,0)          level 3 in structure "comment" packed unaligned
                                                                                  dcl 1-20 in procedure "lex_string_" set ref 587*
version                                based           fixed bin(17,0)          level 3 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_string_" set ref 869*
version                                based           fixed bin(17,0)          level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_string_" set ref 243*
                                                                                  812*
white_space                            based           structure                level 2 packed unaligned dcl 108

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
collate                                                builtin function         dcl 166
comment_value                          based           char                     unaligned dcl 1-20
copy                                                   builtin function         dcl 166
stmt_value                             based           char                     unaligned dcl 1-40
token_value                            based           char                     unaligned dcl 1-68

NAMES DECLARED BY EXPLICIT CONTEXT.
DONE_QUOTING                    002574 constant        label                    dcl 715 ref 695 705
END_LEX                         001151 constant        label                    dcl 434 ref 344 360 365 371 376 382 387 417
LEX                             000664 constant        label                    dcl 337
RE_LEX                          000673 constant        label                    dcl 340 ref 432
allocate                        003365 constant        entry                    internal dcl 2-21 ref 242 572 579 722 809 860 865
comment_                        002054 constant        entry                    internal dcl 489 ref 370 375
comment_token_                  002222 constant        entry                    internal dcl 564 ref 508 514
init                            000305 constant        label                    dcl 230 ref 184
init_lex_delims                 001231 constant        entry                    external dcl 949
lex                             000146 constant        entry                    external dcl 187
lex_string_                     000031 constant        entry                    external dcl 26
quote_                          002351 constant        entry                    internal dcl 627 ref 359 364
stmt_                           003023 constant        entry                    internal dcl 785 ref 381 386
token_                          003166 constant        entry                    internal dcl 850 ref 342 349 408 631 648 660 741 760
                                                                                  789
unmake_token_                   003326 constant        entry                    internal dcl 910 ref 423

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3650        3670    3541        3660
Length      4110    3541        20         203     106           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lex_string_                         314 external procedure  is an external procedure.  
comment_                                internal procedure  shares stack frame of external procedure lex_string_.  
comment_token_                          internal procedure  shares stack frame of external procedure lex_string_.  
quote_                                  internal procedure  shares stack frame of external procedure lex_string_.  
stmt_                                   internal procedure  shares stack frame of external procedure lex_string_.  
token_                                  internal procedure  shares stack frame of external procedure lex_string_.  
unmake_token_                           internal procedure  shares stack frame of external procedure lex_string_.  
allocate                                internal procedure  shares stack frame of external procedure lex_string_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lex_string_              000100 Lquote_copy                 lex_string_
                         000101 Lquote_incr                 lex_string_
                         000102 Lquote_str                  lex_string_
                         000103 Lstr                        lex_string_
                         000104 Lstr_search                 lex_string_
                         000105 Ndoubled_quotes             lex_string_
                         000106 Nlines                      lex_string_
                         000107 Nstmt                       lex_string_
                         000110 Ntokens_in_stmt             lex_string_
                         000112 Pquote_copy                 lex_string_
                         000114 Pquote_str                  lex_string_
                         000116 Pstr                        lex_string_
                         000120 Pstr_search                 lex_string_
                         000122 Sarg                        lex_string_
                         000123 Snew_line                   lex_string_
                         000130 Sreuse_token                lex_string_
                         000131 ch                          lex_string_
                         000132 comment_close               lex_string_
                         000134 comment_open                lex_string_
                         000136 delim_control_char          lex_string_
                         000137 doubled_quote               lex_string_
                         000142 i                           lex_string_
                         000143 j                           lex_string_
                         000144 k                           lex_string_
                         000145 l                           lex_string_
                         000146 quote_close                 lex_string_
                         000150 quote_open                  lex_string_
                         000152 spec_lex_control_chars      lex_string_
                         000164 spec_lex_delims             lex_string_
                         000176 stmt_delim                  lex_string_
                         000200 Pcomment                    lex_string_
                         000202 Pstmt                       lex_string_
                         000204 Ptoken                      lex_string_
                         000342 Nwords                      allocate
                         000344 P                           allocate
                         000346 code                        allocate

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
unpk_to_pk          call_ext_out        return              mod_fx1             ext_entry_desc      set_cs_eis
index_cs_eis        search_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
translator_temp_$get_next_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_stmt_delim    error_table_$unbalanced_quotes                              error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     56 000013        26 000016       181 000122       182 000124       183 000130       184 000132       187 000133
    200 000237       201 000241       202 000245       203 000247       204 000252       205 000264       206 000265
    207 000271       208 000272       210 000273       211 000274       212 000277       214 000301       215 000302
    230 000305       231 000315       232 000330       233 000344       234 000360       235 000365       236 000377
    237 000413       238 000427       240 000443       242 000450       243 000464       244 000467       245 000472
    246 000475       247 000476       248 000500       253 000502       254 000504       255 000505       257 000507
    258 000510       259 000512       260 000513       261 000515       262 000517       263 000520       264 000521
    266 000522       267 000524       270 000525       271 000527       273 000530       274 000533       277 000551
    280 000567       283 000605       286 000623       289 000641       292 000657       293 000662       337 000664
    339 000666       340 000673       342 000675       343 000677       344 000700       347 000701       349 000703
    350 000707       351 000715       355 000722       357 000742       359 000752       360 000753       362 000754
    364 000763       365 000764       368 000765       370 000773       371 000774       373 000775       375 001004
    376 001005       379 001006       381 001014       382 001015       384 001016       386 001025       387 001026
    390 001027       391 001032       392 001033       394 001043       395 001050       399 001052       402 001065
    403 001071       404 001073       406 001074       407 001077       408 001103       410 001107       414 001114
    415 001120       417 001122       423 001123       425 001127       426 001133       427 001136       428 001143
    430 001147       432 001150       451 001151       453 001157       454 001162       456 001167       457 001170
    459 001177       460 001202       462 001204       463 001205       465 001211       468 001220       949 001221
    953 001312       954 001326       955 001342       956 001356       958 001366       959 001374       960 001402
    961 001403       963 001404       964 001406       965 001411       966 001414       967 001416       968 001420
    969 001425       972 001430       973 001432       974 001435       976 001452       978 001453       981 001462
    982 001471       984 001473       985 001475       987 001503       991 001512       992 001514       993 001517
    995 001534       997 001535      1000 001544      1001 001553      1003 001555      1004 001557      1005 001564
   1007 001572      1011 001601      1012 001611      1013 001616      1015 001633      1017 001634      1020 001643
   1021 001660      1023 001662      1024 001664      1025 001677      1027 001702      1029 001710      1031 001725
   1033 001727      1034 001747      1036 001767      1037 002001      1038 002002      1039 002006      1040 002013
   1041 002015      1042 002017      1045 002022      1046 002034      1047 002035      1048 002041      1049 002046
   1050 002050      1059 002053       489 002054       492 002055       494 002060       495 002061       498 002062
    499 002066       500 002070       504 002073       506 002101       508 002102       510 002107       511 002110
    514 002111       517 002120       518 002122       519 002124       520 002126       521 002127       522 002141
    524 002145       526 002146       527 002151       528 002153       529 002155       530 002156       531 002164
    535 002171       536 002175       537 002177       540 002202       542 002211       543 002213       544 002215
    545 002217       548 002221       564 002222       571 002224       572 002230       573 002244       574 002247
    575 002251       576 002253       577 002256       579 002257       580 002276       581 002301       582 002303
    583 002305       585 002315       587 002316       588 002321       589 002324       590 002327       591 002333
    592 002340       593 002343       596 002350       627 002351       630 002352       631 002356       633 002362
    635 002365       636 002366       637 002371       640 002372       641 002376       642 002400       646 002403
    647 002411       648 002412       649 002414       650 002417       651 002420       652 002423       655 002424
    657 002433       659 002435       660 002437       661 002441       662 002444       663 002446       664 002450
    665 002451       666 002463       668 002467       670 002470       671 002473       672 002475       673 002477
    674 002500       683 002501       684 002503       685 002504       687 002505       689 002511       690 002514
    691 002515       692 002516       693 002520       694 002521       695 002524       697 002525       698 002530
    700 002532       701 002540       702 002541       703 002543       704 002544       705 002547       708 002550
    709 002557       711 002560       712 002563       713 002571       715 002574       717 002577       718 002601
    719 002603       721 002604       722 002611       723 002626       725 002627       726 002632       727 002640
    728 002641       729 002643       730 002661       731 002662       733 002663       734 002664       735 002710
    736 002715       738 002722       741 002723       742 002725       743 002730       744 002732       745 002737
    746 002742       747 002754       749 002760       751 002761       753 002766       754 002770       755 002771
    759 002774       760 003000       762 003004       765 003011       766 003015       767 003017       771 003022
    785 003023       788 003024       789 003030       791 003034       794 003043       797 003050       798 003054
    799 003056       803 003061       804 003064       805 003073       807 003105       809 003107       810 003126
    811 003130       812 003132       813 003134       814 003136       815 003140       816 003142       817 003144
    818 003146       819 003147       820 003150       821 003151       822 003153       823 003155       824 003157
    825 003162       826 003163       828 003164       831 003165       850 003166       857 003170       858 003174
    860 003200       861 003214       862 003217       863 003220       865 003221       866 003240       867 003242
    869 003244       870 003247       871 003252       872 003255       873 003261       874 003266       875 003270
    877 003271       878 003274       879 003276       880 003303       881 003305       882 003306       884 003312
    886 003313       887 003315       888 003316       891 003321       892 003323       894 003325       910 003326
    912 003327       913 003331       914 003334       915 003337       916 003342       917 003350       918 003353
    919 003355       920 003356       921 003357       922 003361       923 003362       925 003364    2   21 003365
 2   40 003367    2   41 003375    2   42 003401    2   43 003414    2   44 003424    2   45 003427    2   47 003437
 2   48 003446    2   49 003452    2   50 003460


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
