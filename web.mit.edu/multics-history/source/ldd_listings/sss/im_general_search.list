	COMPILATION LISTING OF SEGMENT im_general_search
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1309.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*          This subroutine searches an index and returns all of the keys (as
       10*     typed_vectors in a typed_vector_array) which satisfy the specification
       11*     provided by the caller.
       12*
       13**/
       14 
       15 /* HISTORY:
       16*
       17*Written by Lindsey Spratt, 06/16/82.
       18*Modified:
       19*07/13/82 by Lindsey Spratt:  Added support of ranges.
       20*08/06/82 by Lindsey Spratt:  Renamed from im_get_key to im_general_search.
       21*	  The get_key operation is now supported by the "get" entry.  Added
       22*	  support for deleting keys, via the "delete" entry.
       23*08/09/82 by Matthew Pierret:  Removed offset and length arguments from calls to
       24*            collection_manager_$get_element which requested the entire element,
       25*            and changed calls to get portions of an element into
       26*            collection_manager_$get_element_portion.
       27*08/17/82 by Matthew Pierret:  Changed calls to im_build_sequential_spec to
       28*            calls to data_mgmt_util_$build_sequential_spec.
       29*08/19/82 by Matthew Pierret:  Changed field_ids argument to data_mgmt_util_
       30*            $cv_table_to_typed_array to be null, meaning convert all fields.
       31*            Removed begin block and code which built field_ids array.
       32*08/19/82 by Lindsey Spratt:  Changed to take p_id_list_ptr in the "get"
       33*	  calling sequence.  Changed to pass this on the cv_table_to_array
       34*	  and im_process_keys$get.
       35*08/24/82 by Lindsey Spratt:  Changed the calling sequence of
       36*	  im_process_keys$(delete get) to pass the subset_specification_ptr.
       37*08/26/82 by Lindsey Spratt:  Added the "position" entry.  Added the "delete"
       38*	  switch, which, with the "get" switch, allows the common code to
       39*	  determine whether a get, delete, or position operation is being
       40*	  done.  Added capability to do "relative" searching.
       41*10/07/82 by Lindsey Spratt:  Changed to use the new search_specification
       42*	  (version 2).  Added the "count" entry.
       43*10/14/82 by Matthew Pierret:  Added number_of_slots argument to
       44*            dmu_$cv_table_to_typed_array.
       45*10/21/82 by Lindsey Spratt:  Added code for the numeric_specification.
       46*	  Changed to use version 3 of the specification structures.
       47*10/26/82 by Lindsey Spratt:  Fixed to catch "no_key" situations.  If the low
       48*	  and high id_strings in an interval_bead are both "0"b, then there
       49*	  is no key which satisfies that interval.
       50*10/27/82 by Lindsey Spratt:  Fixed to set the first (or last) key ids to just
       51*	  outside the index when doing an absolute numeric search.  This
       52*	  causes an abs pos of 1 to get the first key, for instance.
       53*10/28/82 by Lindsey Spratt:  Changed to use the opening_info, and to keep
       54*	  track of the various key counts.
       55*11/09/82 by Lindsey Spratt:  Added the interval_list_ptr to the calling
       56*	  sequence for the get entry.  This is to support the
       57*	  relation_manager_ in satisfying search_specifications which
       58*	  specify more than the fields in the index.  The interval_list
       59*	  identifies what intervals of the returned typed_vectors were
       60*	  selected to satisfy which and_groups of the supplied
       61*	  search_specification.
       62*
       63*	  Changed to remove index_header_ptr from im_process_keys entry
       64*	  points.  Also, changed to use dm_key_count_array include file.
       65*11/23/82 by Lindsey Spratt:  Fixed to set the p_interval_list_ptr before
       66*	  returning.
       67*12/06/82 by Lindsey Spratt:  Fixed to handle the  0 and_groups in a
       68*	  search_specification case, and the null specification case.
       69*12/08/82 by Lindsey Spratt:  Fixed to return dm_error_$key_not_found if the
       70*	  index_header.root_id is 0.
       71*12/09/82 by Lindsey Spratt:  Changed to use the
       72*	  im_update_opening_info$key_count_array entry instead of the
       73*	  (non-existent) key_counts entry.
       74*12/17/82 by Lindsey Spratt:  Fixed get_ci_header to work for branch and leaf
       75*	  headers.
       76*01/20/83 by Matthew Pierret: Changed to use p_typed_vector_array_ptr with
       77*            every reference to typed_vector_array so that one needn't worry
       78*            about failing to set it before returning.
       79*            Changed to finish and return when get_keys returns a non-zero
       80*            p_code.
       81*02/28/83 by Lindsey Spratt:  Changed to use version 3 index_cursor.  Also
       82*	  fixed to call im_validate_cursor when doing a relative position,
       83*	  which will "automatically" re-position a cursor when the key the
       84*	  cursor identifies has moved.
       85*	       Changed to make the finish procedure convert
       86*	  dm_error_$key_not_found to 0 when returning a count.
       87*03/07/83 by Lindsey Spratt:  Fixed relative "find_key_id" to be sensitive to
       88*	  the case where index_cursor.flags.is_at_end_of_index is true and
       89*	  (separately) the case where index_cursor.flags.current_key_exists
       90*	  is false.
       91*03/16/83 by Matthew Pierret: Fixed to check interval_specification_ptr for
       92*            "null-ness" after returning from im_build_interval_spec. 
       93*            Changed $get to always return a non-null interval_list_ptr.
       94*            Changed all subroutine names to be upper-case. Changed
       95*            "do;call FINISH;return;end;" cliche to "call ERROR_RETURN;"
       96*03/23/83 by Lindsey Spratt:  Changed to use version 2 of field_table.
       97*05/23/83 by Matthew Pierret: Changed to use version 4 of specification_head.
       98*            Split dm_specification.incl.pl1 into dm_specification_head,
       99*            dm_specification and dm_range_types.incl.pl1.
      100*            Changed to free key_count_array and interval_list in the
      101*            finish subroutine.
      102*            Changed to detect the situation where the caller has supplied
      103*            an absolute numeric specification and a position_number of 0 -
      104*            this combination is not meaningful. Changed FIND_KEY_ID to set
      105*            p_element_id_string to index_cursor.key_id for relative numeric
      106*            specifications, instead of moving it up or back one slot as it
      107*            does for search specifications.
      108*01/20/84 by Matthew Pierret:  Changed to initialize
      109*            interval_list.and_group_id_list_ptr to null.
      110*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3.  Changed
      111*            references to data_mgmt_util_ to data_format_util_.  Removed
      112*            declarations un-used error codes.
      113*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get,
      114*            cm_$get_element_portion to cm_$get_portion.
      115*10/28/84 by Lindsey L. Spratt:  Changed ERROR_RETURN to take a code arg.
      116*            Changed internal procs to call ERROR_RETURN, and to not have code
      117*            args.  Changed to use version 2 index_opening_info, version 2
      118*            interval_list, version 2 interval_specification, version 4
      119*            index_header.
      120*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
      121**/
      122 /* format: style2,ind3 */
      123 
      124 /* format: style2,ind3 */
      125 im_general_search$get:
      126    proc (p_specification_ptr, p_id_list_ptr, p_work_area_ptr, p_index_cursor_ptr, p_typed_vector_array_ptr,
      127         p_interval_list_ptr, p_code);
      128 
      129 
      130 /* START OF DECLARATIONS */
      131 /* Parameter */
      132 
      133       dcl	    p_specification_ptr    ptr;
      134       dcl	    p_id_list_ptr	       ptr parameter;
      135       dcl	    p_work_area_ptr	       ptr;
      136       dcl	    p_index_cursor_ptr     ptr;
      137       dcl	    p_typed_vector_array_ptr
      138 			       ptr;
      139       dcl	    p_interval_list_ptr    ptr parameter;
      140       dcl	    p_number_of_keys_deleted
      141 			       fixed bin (35);
      142       dcl	    p_key_count	       fixed bin (35);
      143       dcl	    p_code	       fixed bin (35);
      144 
      145 /* Automatic */
      146 
      147       dcl	    work_area_ptr	       ptr init (null);
      148       dcl	    (get, delete, count, position, is_relative_specification, is_search_specification)
      149 			       bit (1) aligned init ("0"b);
      150       dcl	    number_of_keys_accepted
      151 			       fixed bin (35) init (0);
      152       dcl	    number_of_structural_fields
      153 			       fixed bin init (0);
      154       dcl	    (high_element_id_string, low_element_id_string)
      155 			       bit (36) init ("0"b) aligned;
      156       dcl	    (new_buffer_was_allocated, no_match)
      157 			       bit (1) aligned init ("0"b);
      158       dcl	    interval_idx	       fixed bin (17);
      159 
      160 
      161 /* Based */
      162 
      163       dcl	    work_area	       area based (work_area_ptr);
      164 
      165 /* Builtin */
      166 
      167       dcl	    (addr, length, max, null)
      168 			       builtin;
      169 
      170 /* Condition */
      171 
      172       dcl	    cleanup	       condition;
      173 
      174 /* Constant */
      175 
      176       dcl	    DEFAULT_AND_GROUP_ID_LIST_PTR
      177 			       ptr init (null) internal static options (constant);
      178       dcl	    (
      179 	    DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
      180 			       init (0),
      181 	    DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID
      182 			       init (0)
      183 	    )		       fixed bin (17) internal static options (constant);
      184 
      185       dcl	    BEGINNING_OF_ELEMENT   init (1) fixed bin (35) internal static options (constant);
      186 
      187       dcl	    HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36) aligned internal static options (constant);
      188 
      189       dcl	    myname	       init ("im_general_search") char (17) internal static options (constant);
      190 
      191       dcl	    (
      192 	    FIRST_KEY	       init ("0"b),
      193 	    LAST_KEY	       init ("1"b)
      194 	    )		       bit (1) aligned internal static options (constant);
      195 
      196 /* Entry */
      197 
      198       dcl	    get_dm_free_area_      entry () returns (ptr);
      199       dcl	    im_get_opening_info    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      200       dcl	    im_update_opening_info$key_count_array
      201 			       entry (ptr, ptr, fixed bin (35));
      202 
      203       dcl	    im_build_interval_spec entry (ptr, ptr, ptr, fixed bin (35));
      204 
      205       dcl	    im_structural_search   entry (ptr, ptr, bit (1) aligned, ptr, bit (1) aligned, fixed bin (35));
      206       dcl	    im_validate_cursor     entry (ptr, ptr, fixed bin (35));
      207 
      208       dcl	    im_process_keys$get    entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin, fixed bin, bit (36) aligned,
      209 			       bit (36) aligned, ptr, fixed bin (35));
      210       dcl	    im_process_keys$delete entry (ptr, ptr, ptr, ptr, ptr, fixed bin, fixed bin, bit (36) aligned,
      211 			       bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
      212       dcl	    im_process_keys$position
      213 			       entry (ptr, ptr, ptr, ptr, ptr, fixed bin, fixed bin, bit (36) aligned,
      214 			       bit (36) aligned, fixed bin (35), fixed bin (35));
      215       dcl	    im_process_keys$count  entry (ptr, ptr, ptr, ptr, ptr, fixed bin, fixed bin, bit (36) aligned,
      216 			       bit (36) aligned, fixed bin (35), fixed bin (35));
      217 
      218       dcl	    data_format_util_$cv_table_to_typed_array
      219 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, fixed bin (35));
      220       dcl	    sub_err_	       entry options (variable);
      221 
      222 /* External */
      223 
      224       dcl	    (
      225 	    dm_error_$key_not_found,
      226 	    dm_error_$bad_first_key_idx,
      227 	    dm_error_$programming_error,
      228 	    dm_error_$bad_last_key_idx,
      229 	    dm_error_$bad_specification_type,
      230 	    dm_error_$invalid_cursor_position,
      231 	    error_table_$unimplemented_version
      232 	    )		       fixed bin (35) ext;
      233 
      234 /* END OF DECLARATIONS */
      235 
      236 /*
      237*get:
      238*   entry (p_specification_ptr, p_id_list_ptr, p_work_area_ptr, p_index_cursor_ptr, p_typed_vector_array_ptr,
      239*      p_interval_list_ptr, p_code);
      240**/
      241       work_area_ptr = p_work_area_ptr;
      242       get = "1"b;
      243       goto JOIN;
      244 
      245 position:
      246    entry (p_specification_ptr, p_work_area_ptr, p_index_cursor_ptr, p_code);
      247       work_area_ptr = p_work_area_ptr;
      248       position = "1"b;
      249       goto JOIN;
      250 
      251 delete:
      252    entry (p_specification_ptr, p_work_area_ptr, p_index_cursor_ptr, p_number_of_keys_deleted, p_code);
      253       work_area_ptr = p_work_area_ptr;
      254       p_number_of_keys_deleted = 0;
      255       delete = "1"b;
      256       goto JOIN;
      257 
      258 count:
      259    entry (p_specification_ptr, p_index_cursor_ptr, p_key_count, p_code);
      260       work_area_ptr = get_dm_free_area_ ();
      261       p_key_count = 0;
      262       count = "1"b;
      263 
      264 JOIN:
      265       numeric_specification_ptr, search_specification_ptr, specification_head_ptr, interval_list_ptr,
      266 	 key_count_array_ptr = null;
      267       p_code = 0;
      268       index_cursor_ptr = p_index_cursor_ptr;
      269 
      270       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      271 
      272       specification_head_ptr = p_specification_ptr;
      273       if specification_head_ptr ^= null
      274       then
      275          do;
      276 	  call CHECK_VERSION ((specification_head.version), (SPECIFICATION_VERSION_4), "specification");
      277 
      278 	  if specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      279 	  then
      280 	     do;
      281 	        search_specification_ptr = specification_head_ptr;
      282 	        is_relative_specification = "1"b;
      283 	        is_search_specification = "1"b;
      284 	     end;
      285 	  else if specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
      286 	  then
      287 	     do;
      288 	        search_specification_ptr = specification_head_ptr;
      289 	        is_relative_specification = "0"b;
      290 	        is_search_specification = "1"b;
      291 	     end;
      292 	  else if specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      293 	  then
      294 	     do;
      295 	        numeric_specification_ptr = specification_head_ptr;
      296 	        is_relative_specification = "1"b;
      297 	        is_search_specification = "0"b;
      298 	     end;
      299 	  else if specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
      300 	  then
      301 	     do;
      302 	        numeric_specification_ptr = specification_head_ptr;
      303 	        if numeric_specification.position_number = 0
      304 	        then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      305 		        "^/The given position_number, ^d, is not supported by the given specification^/type, type ^d - absolute numeric.",
      306 		        numeric_specification.position_number, ABSOLUTE_NUMERIC_SPECIFICATION_TYPE);
      307 	        is_relative_specification = "0"b;
      308 	        is_search_specification = "0"b;
      309 	     end;
      310 	  else call sub_err_ (dm_error_$bad_specification_type, myname, ACTION_CANT_RESTART, null, 0,
      311 		  "^/The  specification structure does not have a recognizable type.
      312 The recognizable types are: ^d, ^d, ^d or ^d. Received a type ^d structure.", ABSOLUTE_SEARCH_SPECIFICATION_TYPE,
      313 		  RELATIVE_SEARCH_SPECIFICATION_TYPE, ABSOLUTE_NUMERIC_SPECIFICATION_TYPE,
      314 		  RELATIVE_NUMERIC_SPECIFICATION_TYPE, search_specification.head.type);
      315          end;
      316 
      317       on cleanup call FINISH;
      318 
      319       call im_get_opening_info (index_cursor.file_opening_id, index_cursor.collection_id, index_opening_info_ptr, p_code);
      320       if p_code ^= 0
      321       then call ERROR_RETURN (p_code);
      322 
      323       call CHECK_VERSION_CHAR (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      324 
      325       index_header_ptr = index_opening_info.index_header_ptr;
      326       call CHECK_VERSION_CHAR (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
      327 
      328       if index_header.root_id = 0			/* There are no keys. */
      329       then call ERROR_RETURN (dm_error_$key_not_found);
      330 
      331       field_table_ptr = index_opening_info.field_table_ptr;
      332       call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      333 
      334       if is_search_specification
      335       then
      336          do;
      337 
      338 	  call im_build_interval_spec (work_area_ptr, search_specification_ptr, interval_specification_ptr, p_code);
      339 	  if p_code ^= 0
      340 	  then call ERROR_RETURN (p_code);
      341 
      342 	  if interval_specification_ptr ^= null
      343 	  then
      344 	     do;
      345 	        call CHECK_VERSION_CHAR (interval_specification.version, INTERVAL_SPECIFICATION_VERSION_2,
      346 		   "interval_specification");
      347 
      348 	        if search_specification.number_of_and_groups <= 0
      349 	        then call FIND_KEY_ID (FIRST_KEY,
      350 		        interval_specification.first_interval_bead_ptr -> interval_bead.low.id_string);
      351 	     end;
      352          end;
      353 
      354 
      355       if interval_specification_ptr ^= null
      356       then if search_specification.number_of_and_groups > 0
      357 	 then
      358 	    do;
      359 
      360 
      361 	       call im_structural_search (index_opening_info_ptr, index_cursor_ptr, is_relative_specification,
      362 		  interval_specification_ptr, no_match, p_code);
      363 	       if p_code ^= 0
      364 	       then call ERROR_RETURN (p_code);
      365 
      366 	       if no_match
      367 	       then call ERROR_RETURN (dm_error_$key_not_found);
      368 
      369 	       if get
      370 	       then
      371 		do;
      372 		   intl_number_of_intervals = interval_specification.number_of_intervals;
      373 		   alloc interval_list in (work_area);
      374 		   interval_list.version = INTERVAL_LIST_VERSION_2;
      375 		   interval_list.and_group_id_list_ptr = null;
      376 		end;
      377 	    end;
      378 
      379       if get
      380       then
      381          do;
      382 
      383 	  call data_format_util_$cv_table_to_typed_array (field_table_ptr, p_id_list_ptr, work_area_ptr, 0,
      384 	       p_typed_vector_array_ptr, p_code);
      385 	  if p_code ^= 0
      386 	  then call ERROR_RETURN (p_code);
      387          end;
      388 
      389       if delete
      390       then
      391          do;
      392 	  call CHECK_VERSION_CHAR (index_opening_info.key_count_array_ptr -> key_count_array.version,
      393 	       KEY_COUNT_ARRAY_VERSION_2, "key_count_array");
      394 	  kca_number_of_counts = index_opening_info.key_count_array_ptr -> key_count_array.number_of_counts;
      395 
      396 	  alloc key_count_array in (work_area);
      397 
      398 	  key_count_array = index_opening_info.key_count_array_ptr -> key_count_array;
      399          end;
      400 
      401       if interval_specification_ptr = null
      402       then
      403 PROCESS_ALL_KEYS:
      404          do;
      405 	  if ^is_search_specification & numeric_specification_ptr ^= null
      406 	  then
      407 	     do;
      408 	        if numeric_specification.position_number >= 0
      409 	        then
      410 		 do;
      411 		    call FIND_KEY_ID (FIRST_KEY, low_element_id_string);
      412 		    high_element_id_string = "0"b;
      413 		 end;
      414 	        else
      415 		 do;
      416 		    low_element_id_string = "0"b;
      417 		    call FIND_KEY_ID (LAST_KEY, high_element_id_string);
      418 		 end;
      419 	     end;
      420 	  else
      421 	     do;
      422 	        high_element_id_string = "0"b;
      423 	        call FIND_KEY_ID (FIRST_KEY, low_element_id_string);
      424 	     end;
      425 
      426 	  if get
      427 	  then call im_process_keys$get (index_cursor_ptr, work_area_ptr, field_table_ptr, p_id_list_ptr,
      428 		  p_specification_ptr, DEFAULT_AND_GROUP_ID_LIST_PTR, DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      429 		  DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID, low_element_id_string, high_element_id_string,
      430 		  p_typed_vector_array_ptr, p_code);
      431 	  else if delete
      432 	  then call im_process_keys$delete (index_cursor_ptr, work_area_ptr, field_table_ptr, p_specification_ptr,
      433 		  DEFAULT_AND_GROUP_ID_LIST_PTR, DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      434 		  DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID, low_element_id_string, high_element_id_string,
      435 		  key_count_array_ptr, number_of_keys_accepted, p_code);
      436 	  else if position
      437 	  then call im_process_keys$position (index_cursor_ptr, work_area_ptr, field_table_ptr, p_specification_ptr,
      438 		  DEFAULT_AND_GROUP_ID_LIST_PTR, DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      439 		  DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID, low_element_id_string, high_element_id_string,
      440 		  number_of_keys_accepted, p_code);
      441 	  else call im_process_keys$count (index_cursor_ptr, work_area_ptr, field_table_ptr, p_specification_ptr,
      442 		  DEFAULT_AND_GROUP_ID_LIST_PTR, DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      443 		  DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID, low_element_id_string, high_element_id_string,
      444 		  number_of_keys_accepted, p_code);
      445 
      446 	  if p_code ^= 0
      447 	  then call ERROR_RETURN (p_code);
      448 
      449 	  if get
      450 	  then
      451 	     do;
      452 	        intl_number_of_intervals = 1;
      453 	        alloc interval_list in (work_area);
      454 	        interval_list.version = INTERVAL_LIST_VERSION_2;
      455 	        interval_list.interval (1).low_vector_idx = 1;
      456 	        interval_list.interval (1).high_vector_idx =
      457 		   p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
      458 	        interval_list.interval (1).and_group_id_list_ptr = null;
      459 	     end;
      460 
      461          end PROCESS_ALL_KEYS;
      462       else if search_specification.range.type = HIGH_RANGE_TYPE
      463       then
      464          do;
      465 	  interval_bead_ptr = interval_specification.last_interval_bead_ptr;
      466 	  if interval_bead.high.id_string = "0"b & USES_GREATER_OPERATOR (interval_bead.low.operator_code)
      467 	       & interval_bead.low.id_string ^= "0"b
      468 	  then call FIND_KEY_ID (LAST_KEY, interval_bead.high.id_string);
      469 
      470 	  interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      471 	  do interval_idx = interval_specification.number_of_intervals to 1 by -1
      472 	       while (search_specification.range.size > number_of_keys_accepted);
      473 	     call GET_KEYS;
      474 
      475 	     interval_bead_ptr = interval_bead.next;
      476 	  end;
      477          end;
      478       else if search_specification.range.type = LOW_RANGE_TYPE
      479       then
      480          do;
      481 	  interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      482 	  if interval_bead.low.id_string = "0"b
      483 	  then call FIND_KEY_ID (FIRST_KEY, interval_bead.low.id_string);
      484 
      485 	  interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      486 	  do interval_idx = 1 to interval_specification.number_of_intervals
      487 	       while ((search_specification.range.size > number_of_keys_accepted & (get | delete | count))
      488 	       | (position & number_of_keys_accepted = 0));
      489 	     call GET_KEYS;
      490 
      491 	     interval_bead_ptr = interval_bead.next;
      492 	  end;
      493          end;
      494       else
      495          do;
      496 	  interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      497 FORWARD_INTERVAL_LOOP:
      498 	  do interval_idx = 1 to interval_specification.number_of_intervals
      499 	       while (get | delete | (position & number_of_keys_accepted = 0) | count);
      500 	     call GET_KEYS;
      501 
      502 	     interval_bead_ptr = interval_bead.next;
      503 	  end FORWARD_INTERVAL_LOOP;
      504          end;
      505       if get
      506       then p_interval_list_ptr = interval_list_ptr;
      507       else if delete
      508       then
      509          do;
      510 	  call im_update_opening_info$key_count_array (index_opening_info_ptr, key_count_array_ptr, p_code);
      511 	  if p_code ^= 0
      512 	  then call ERROR_RETURN (p_code);
      513 
      514 	  p_number_of_keys_deleted = number_of_keys_accepted;
      515          end;
      516       else if count
      517       then p_key_count = number_of_keys_accepted;
      518 
      519       call FINISH;
      520 
      521 MAIN_RETURN:
      522       return;
      523 
      524 FINISH:
      525    proc;
      526       dcl	    next_ptr	       ptr;
      527 
      528       if count & p_code = dm_error_$key_not_found
      529       then p_code = 0;
      530 
      531       if interval_specification_ptr ^= null
      532       then
      533          do;
      534 	  interval_bead_ptr = interval_specification.first_interval_bead_ptr;
      535 	  do while (interval_bead_ptr ^= null);
      536 	     next_ptr = interval_bead.next;
      537 	     if interval_bead.simple_typed_vector_ptr ^= null
      538 	     then free interval_bead.simple_typed_vector_ptr -> simple_typed_vector in (work_area);
      539 	     if interval_bead.id_list_ptr ^= null
      540 	     then free interval_bead.id_list_ptr -> id_list in (work_area);
      541 	     free interval_bead in (work_area);
      542 	     interval_bead_ptr = next_ptr;
      543 	  end;
      544 	  free interval_specification in (work_area);
      545          end;
      546 
      547       if interval_list_ptr ^= null
      548       then if p_interval_list_ptr ^= interval_list_ptr
      549 	 then free interval_list in (work_area);
      550 
      551       if key_count_array_ptr ^= null
      552       then free key_count_array in (work_area);
      553 
      554    end FINISH;
      555 
      556 
      557 ERROR_RETURN:
      558    proc (er_p_code);
      559       dcl	    er_p_code	       fixed bin (35) parameter;
      560 
      561       p_code = er_p_code;				/* p_code must be set before calling FINISH. */
      562       call FINISH ();
      563       goto MAIN_RETURN;
      564 
      565    end ERROR_RETURN;
      566 
      567 CHECK_VERSION:
      568    proc (p_received_version, p_expected_version, p_structure_name);
      569       dcl	    p_received_version     fixed bin (35);
      570       dcl	    p_expected_version     fixed bin (35);
      571       dcl	    p_structure_name       char (*);
      572 
      573       if p_received_version ^= p_expected_version
      574       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      575 	      "^/Expected version ^d of the ^a structure.
      576 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      577 
      578    end CHECK_VERSION;
      579 
      580 CHECK_VERSION_CHAR:
      581    proc (p_expected_version, p_received_version, p_structure_name);
      582 
      583       dcl	    (p_expected_version, p_received_version)
      584 			       char (8) aligned parameter;
      585       dcl	    p_structure_name       char (*) parameter;
      586 
      587       if p_expected_version ^= p_received_version
      588       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      589 	      "^/Expected version ^a of the ^a structure.  
      590 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      591    end CHECK_VERSION_CHAR;
      592 
      593 GET_CI_HEADER:
      594    proc (gch_p_control_interval_id, gch_p_ci_header_ptr);
      595       dcl	    gch_p_control_interval_id
      596 			       fixed bin (24) unsigned;
      597       dcl	    gch_p_ci_header_ptr    ptr;
      598 
      599       dcl	    gch_code	       fixed bin (35);
      600       dcl	    1 gch_element_id       aligned like element_id;
      601 
      602 
      603       gch_element_id.control_interval_id = gch_p_control_interval_id;
      604       gch_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      605       gch_code = 0;
      606 
      607       call collection_manager_$get (index_cursor.file_opening_id, index_cursor.collection_id, unspec (gch_element_id), 0,
      608 	 gch_p_ci_header_ptr, max (BRANCH_CI_HEADER_LENGTH_IN_BITS, LEAF_CI_HEADER_LENGTH_IN_BITS), null, "0"b,
      609 	 gch_p_ci_header_ptr, (0), gch_code);
      610       if gch_code ^= 0
      611       then call ERROR_RETURN (gch_code);
      612 
      613       if gch_p_ci_header_ptr -> common_ci_header.key_range.first < 0
      614       then call ERROR_RETURN (dm_error_$bad_first_key_idx);
      615       else if gch_p_ci_header_ptr -> common_ci_header.key_range.last
      616 	 < gch_p_ci_header_ptr -> common_ci_header.key_range.first
      617       then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      618       return;
      619    end GET_CI_HEADER;
      620 
      621 FIND_KEY_ID:
      622    proc (fki_p_find_last_key, fki_p_element_id_string);
      623       dcl	    fki_p_find_last_key    bit (1) aligned;
      624       dcl	    fki_p_element_id_string
      625 			       bit (*) aligned;
      626 
      627       dcl	    fki_branch_key_head_buffer
      628 			       bit (BRANCH_KEY_HEADER_LENGTH_IN_BITS) aligned;
      629       dcl	    fki_code	       fixed bin (35);
      630       dcl	    1 fki_element_id       aligned like element_id;
      631       dcl	    fki_element_id_string  based (addr (fki_element_id)) bit (36) aligned;
      632       dcl	    fki_local_header_buffer
      633 			       bit (max (BRANCH_CI_HEADER_LENGTH_IN_BITS, LEAF_CI_HEADER_LENGTH_IN_BITS)) aligned;
      634 
      635       fki_code = 0;
      636       branch_ci_header_ptr, common_ci_header_ptr, leaf_ci_header_ptr = addr (fki_local_header_buffer);
      637       if is_relative_specification & ((^fki_p_find_last_key & is_search_specification) | ^is_search_specification)
      638       then
      639 GET_CURSOR_POSITION:
      640          do;
      641 	  if ^index_cursor.flags.is_valid
      642 	  then call ERROR_RETURN (dm_error_$invalid_cursor_position);
      643 	  else
      644 	     do;
      645 	        call im_validate_cursor (index_opening_info_ptr, index_cursor_ptr, fki_code);
      646 	        if fki_code ^= 0
      647 	        then call ERROR_RETURN (fki_code);
      648 	     end;
      649 	  fki_element_id_string = index_cursor.key_id_string;
      650 	  call GET_CI_HEADER ((fki_element_id.control_interval_id), common_ci_header_ptr);
      651 
      652 	  if index_cursor.flags.is_at_end_of_index
      653 	  then call ERROR_RETURN (dm_error_$key_not_found);
      654 	  else if index_cursor.flags.current_key_exists
      655 	  then if ^is_search_specification
      656 	       then fki_element_id_string = index_cursor.key_id_string;
      657 	       else
      658 POSITION_TO_SLOT_AFTER_CURRENT:
      659 		do;
      660 		   if fki_element_id.index + 1 > common_ci_header.key_range.last
      661 		   then
      662 GOTO_NEXT_CONTROL_INTERVAL:
      663 		      do;
      664 		         fki_element_id.control_interval_id = common_ci_header.next_id;
      665 		         if fki_element_id.control_interval_id = 0
      666 						/* There is no next control interval. */
      667 		         then call ERROR_RETURN (dm_error_$key_not_found);
      668 		         call GET_CI_HEADER ((fki_element_id.control_interval_id), common_ci_header_ptr);
      669 		         fki_element_id.index = common_ci_header.key_range.first;
      670 		      end GOTO_NEXT_CONTROL_INTERVAL;
      671 		   else fki_element_id.index = fki_element_id.index + 1;
      672 		end POSITION_TO_SLOT_AFTER_CURRENT;
      673 	  fki_p_element_id_string = fki_element_id_string;
      674 	  return;
      675          end GET_CURSOR_POSITION;
      676       fki_element_id.control_interval_id = index_header.root_id;
      677       call GET_CI_HEADER ((fki_element_id.control_interval_id), common_ci_header_ptr);
      678 
      679       bk_string_length = 0;
      680       do while (^common_ci_header.is_leaf);
      681 
      682          if fki_p_find_last_key
      683          then
      684 	  do;
      685 	     fki_element_id.index = branch_ci_header.common.key_range.last;
      686 	     call collection_manager_$get_portion (index_cursor.file_opening_id, index_cursor.collection_id,
      687 		fki_element_id_string, 0, addr (fki_branch_key_head_buffer), length (fki_branch_key_head_buffer),
      688 		null, 1, length (fki_branch_key_head_buffer), "0"b, branch_key_ptr, 0, fki_code);
      689 	     if fki_code ^= 0
      690 	     then call ERROR_RETURN (fki_code);
      691 
      692 	     fki_element_id.control_interval_id = branch_key.branch_id;
      693 	  end;
      694          else fki_element_id.control_interval_id = branch_ci_header.low_branch_id;
      695          call GET_CI_HEADER ((fki_element_id.control_interval_id), common_ci_header_ptr);
      696       end;
      697 
      698       if is_search_specification | is_relative_specification
      699       then if fki_p_find_last_key
      700 	 then fki_element_id.index = leaf_ci_header.common.key_range.last;
      701 	 else fki_element_id.index = leaf_ci_header.common.key_range.first;
      702       else if fki_p_find_last_key
      703       then fki_element_id.index = leaf_ci_header.common.key_range.last + 1;
      704       else fki_element_id.index = leaf_ci_header.common.key_range.first - 1;
      705 
      706       fki_p_element_id_string = fki_element_id_string;
      707       return;
  1     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          There are two formats for keys, the leaf_key structure and the
  1     6*     branch_key structure. The branch_key has two more pieces of information
  1     7*     than the leaf_key. One is the control interval id of the
  1     8*     node for all keys greater than the value of the branch key.  The other is
  1     9*     the number of fields for which there are values in the "string" portion
  1    10*     of the key.  This allows for the storing of only as much data as is needed
  1    11*     to discriminate between the children being split by the branch key.
  1    12**/
  1    13 
  1    14 /* HISTORY:
  1    15*
  1    16*Written by Lindsey Spratt, 03/29/82.
  1    17*Modified:
  1    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  1    19**/
  1    20 
  1    21 /* format: style2,ind3 */
  1    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  1    23      dcl	   key_string_length      fixed bin (35);
  1    24      dcl	   key_string_ptr	      ptr;
  1    25 
  1    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  1    27 	     2 string	      bit (lk_string_length) unal;
  1    28 
  1    29      dcl	   lk_string_length	      fixed bin (35);
  1    30      dcl	   leaf_key_ptr	      ptr;
  1    31 
  1    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  1    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  1    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  1    35 	     2 string	      bit (bk_string_length) unal;
  1    36 
  1    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  1    38 			      init (36) fixed bin (35) internal static options (constant);
  1    39      dcl	   bk_string_length	      fixed bin (35);
  1    40      dcl	   branch_key_ptr	      ptr;
  1    41 
  1    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      708 
      709    end FIND_KEY_ID;
      710 
      711 GET_KEYS:
      712    proc;
      713       dcl	    gk_code	       fixed bin (35);
      714       dcl	    partial_structural_field_id
      715 			       fixed bin;
      716       if interval_bead.low.id_string = "0"b & interval_bead.high.id_string = "0"b
      717       then return;
      718       simple_typed_vector_ptr = interval_bead.simple_typed_vector_ptr;
      719       if simple_typed_vector_ptr = null
      720       then partial_structural_field_id = DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID;
      721       else if interval_bead.number_of_fully_structural_fields = simple_typed_vector.number_of_dimensions
      722       then partial_structural_field_id = DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID;
      723       else partial_structural_field_id = simple_typed_vector.number_of_dimensions;
      724       if interval_bead.low.id_string = "0"b & is_relative_specification
      725       then call FIND_KEY_ID (FIRST_KEY, interval_bead.low.id_string);
      726 
      727       if get
      728       then call im_process_keys$get (index_cursor_ptr, work_area_ptr, field_table_ptr, p_id_list_ptr,
      729 	      search_specification_ptr, interval_bead.id_list_ptr, (interval_bead.number_of_fully_structural_fields),
      730 	      partial_structural_field_id, interval_bead.low.id_string, interval_bead.high.id_string,
      731 	      p_typed_vector_array_ptr, gk_code);
      732       else if delete
      733       then call im_process_keys$delete (index_cursor_ptr, work_area_ptr, field_table_ptr, search_specification_ptr,
      734 	      interval_bead.id_list_ptr, (interval_bead.number_of_fully_structural_fields), partial_structural_field_id,
      735 	      interval_bead.low.id_string, interval_bead.high.id_string, key_count_array_ptr, number_of_keys_accepted,
      736 	      gk_code);
      737       else if position
      738       then call im_process_keys$position (index_cursor_ptr, work_area_ptr, field_table_ptr, search_specification_ptr,
      739 	      interval_bead.id_list_ptr, (interval_bead.number_of_fully_structural_fields), partial_structural_field_id,
      740 	      interval_bead.low.id_string, interval_bead.high.id_string, number_of_keys_accepted, gk_code);
      741       else call im_process_keys$count (index_cursor_ptr, work_area_ptr, field_table_ptr, search_specification_ptr,
      742 	      interval_bead.id_list_ptr, (interval_bead.number_of_fully_structural_fields), partial_structural_field_id,
      743 	      interval_bead.low.id_string, interval_bead.high.id_string, number_of_keys_accepted, gk_code);
      744 
      745       if gk_code ^= 0
      746       then call ERROR_RETURN (gk_code);
      747 
      748       if get
      749       then
      750          do;
      751 	  if number_of_keys_accepted < p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors
      752 	       & interval_list_ptr ^= null
      753 	  then
      754 	     do;
      755 	        interval_list.interval (interval_idx).low_vector_idx = number_of_keys_accepted + 1;
      756 	        interval_list.interval (interval_idx).high_vector_idx =
      757 		   p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
      758 	        interval_list.interval (interval_idx).and_group_id_list_ptr = interval_bead.id_list_ptr;
      759 	        interval_bead.id_list_ptr = null;
      760 	     end;
      761 
      762 	  number_of_keys_accepted = p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
      763          end;
      764    end GET_KEYS;
      765 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 04/02/82.
  2     9*Modified:
  2    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  2    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  2    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  2    13*	  type.
  2    14**/
  2    15 
  2    16 /* format: style2,ind3 */
  2    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  2    18 	     2 type	      fixed bin (17) unal,
  2    19 	     2 number_of_dimensions
  2    20 			      fixed bin (17) unal,
  2    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  2    22 	       3 value_ptr	      ptr unaligned;
  2    23 
  2    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  2    25 	     2 type	      fixed bin (17) unal,
  2    26 	     2 number_of_dimensions
  2    27 			      fixed bin (17) unal,
  2    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  2    29 	       3 identifier	      fixed bin (17) unal,
  2    30 	       3 pad	      bit (18) unal,
  2    31 	       3 value_ptr	      ptr unal;
  2    32 
  2    33      dcl	   simple_typed_vector_ptr
  2    34 			      ptr;
  2    35      dcl	   stv_number_of_dimensions
  2    36 			      fixed bin (17);
  2    37 
  2    38      dcl	   general_typed_vector_ptr
  2    39 			      ptr;
  2    40      dcl	   gtv_number_of_dimensions
  2    41 			      fixed bin (17);
  2    42 
  2    43      dcl	   (
  2    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  2    45 			      init (1),		/* value_ptr was aligned. */
  2    46 	   GENERAL_TYPED_VECTOR_TYPE
  2    47 			      init (2),
  2    48 	   SIMPLE_TYPED_VECTOR_TYPE
  2    49 			      init (3)
  2    50 	   )		      fixed bin (17) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      766 
      767 
  3     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          The index_header structure is stored in the header element of an
  3     6*     index collection and describes basic information about the index.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*
  3    11*Written by Lindsey Spratt, 04/02/82.
  3    12*Modified:
  3    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  3    14*	  count(0) is the number of keys in the index.  count(N) is the
  3    15*	  number of keys in the index which have at least fields 1 through N
  3    16*	  having the same value as another key in the index, i.e. count(N)
  3    17*	  is the number of partial duplicates with number of partial
  3    18*	  duplication fields equal to N.
  3    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  3    20*	  Replaced the key_count_array with a key_count_array_element_id.
  3    21*	  Changed the version field to char(8).  Aligned the structure.
  3    22**/
  3    23 
  3    24 /* format: style2,ind3 */
  3    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  3    26 	     2 version	      char (8) aligned,
  3    27 	     2 field_table_element_id
  3    28 			      like element_id,
  3    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  3    30 	     2 pad1	      bit (12) unaligned,
  3    31 	     2 number_of_duplication_fields
  3    32 			      fixed bin (17) unal,
  3    33 	     2 pad2	      bit (18) unal,
  3    34 	     2 key_count_array_element_id
  3    35 			      like element_id;
  3    36 
  3    37      dcl	   index_header_ptr	      ptr;
  3    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  3    39 
  3    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      768 
      769 
  4     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          Each node (control interval) in the index has a header which
  4     6*     describes the contents of that node.  Although there are two different
  4     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  4     8*     common_ci_header.  The common_ci_header states which slots are used by
  4     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  4    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  4    11*     There are pointers to the previous and next nodes (previous_id and
  4    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  4    13*     searching.  There is also a count of how much space is in use by the keys.
  4    14*
  4    15**/
  4    16 
  4    17 /* HISTORY:
  4    18*
  4    19*Written by Lindsey Spratt, 03/29/82.
  4    20*Modified:
  4    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  4    22*            section format.
  4    23**/
  4    24 
  4    25 /* format: style2,ind3 */
  4    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  4    27 	     2 flags	      unaligned,
  4    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  4    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  4    30 	     2 key_tail_space_used_since_last_prefix_compaction
  4    31 			      fixed bin (18) unsigned unal,
  4    32 	     2 key_range	      unaligned,
  4    33 	       3 first	      fixed bin (18) unsigned,
  4    34 	       3 last	      fixed bin (18) unsigned,
  4    35 	     2 parent_id_string   bit (36) aligned,
  4    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  4    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  4    38 	     2 pad	      bit (24) unaligned;
  4    39 
  4    40 
  4    41      dcl	   common_ci_header_ptr   ptr;
  4    42 
  4    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  4    44 	     2 common	      like common_ci_header;
  4    45 
  4    46      dcl	   leaf_ci_header_ptr     ptr;
  4    47 
  4    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  4    49 	     2 common	      like common_ci_header,
  4    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  4    51 	     2 pad	      bit (12) unaligned;
  4    52 
  4    53      dcl	   branch_ci_header_ptr   ptr;
  4    54 
  4    55 
  4    56      dcl	   (
  4    57 	   DEFAULT_INITIAL_KEY_SLOT
  4    58 			      init (2),
  4    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  4    60 			      init (1),
  4    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  4    62 			      init (180),
  4    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  4    64 			      init (216)
  4    65 	   )		      internal static options (constant) fixed bin;
  4    66 
  4    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      770 
      771 
  5     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          This structure specifies a DM file, an index collection in that DM
  5     6*file, and a position (key) in that index collection.
  5     7*
  5     8**/
  5     9 
  5    10 /* HISTORY:
  5    11*
  5    12*Written by Lindsey Spratt, 03/29/82
  5    13*Modified:
  5    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  5    15*            "bit (35) aligned".
  5    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  5    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  5    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  5    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  5    20*	  which is a unique number used by hash_index_ to develop the
  5    21*	  key_check_value.
  5    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  5    23*	  cursor.  Also, implemented the ability to have the cursor
  5    24*	  positioned before or after the index.  
  5    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3 */
  5    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  5    30 	     2 type	      fixed bin (17) unaligned,
  5    31 	     2 version	      fixed bin (17) unaligned,
  5    32 	     2 file_opening_id    bit (36) aligned,
  5    33 	     2 collection_id      bit (36) aligned,
  5    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  5    35 						/* if flags.current_key_exists is on. Is the location */
  5    36 						/* of the end of the index if flags.is_at_end_of_index */
  5    37 						/* is on, which is only available via an operation */
  5    38 						/* requiring the "previous" key.  Is the location of */
  5    39 						/* the "next" key, otherwise. */
  5    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  5    41 						/* Must be a freeing area. */
  5    42 	     2 current_key_string_ptr
  5    43 			      ptr,		/* Points to the value of the current key. */
  5    44 	     2 current_key_string_length
  5    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  5    46 	     2 pad	      bit (12) unal,
  5    47 	     2 flags	      aligned,
  5    48 	       3 is_at_beginning_of_index
  5    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  5    50 	       3 is_at_end_of_index
  5    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  5    52 	       3 current_key_exists
  5    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  5    54 						/* by the key_id_string.  If off, the "current" position */
  5    55 						/* is undefined, and the key_id_string identifies the */
  5    56 						/* previous or next key, depending on whether */
  5    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  5    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  5    59 						/* setting the cursor position and the cursor is not */
  5    60 						/* to be trusted for relative position operations. */
  5    61 	       3 pad	      bit (32) unal;
  5    62 
  5    63 
  5    64      dcl	   index_cursor_ptr	      ptr;
  5    65 
  5    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  5    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  5    68 
  5    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      772 
      773 
  6     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        Contains the declaration of an element identifier.  Element
  6     6*   identifiers consist of two parts, the id (number) of the control interval
  6     7*   in which the element resides, and the index into the slot table of
  6     8*   the element in the control interval.  The declaration of the element_id 
  6     9*   structure reflects this division of the element identifier.  The structure 
  6    10*   is based on the automatic bit string element_id_string because programs
  6    11*   generally pass bit strings (element_id_string) to each other, then 
  6    12*   interpret the bit string by overlaying the element_id structure ony if
  6    13*   it is necessary to access the parts of the id.  Basing element_id on
  6    14*   addr(element_id_string) instead of on a pointer removes the necessity
  6    15*   for always setting that pointer explicitly and guarantees that changes
  6    16*   made to the string or structure do not get inconsistent.
  6    17*
  6    18*   Changes made to element_id must also be made to datum_id, declared in 
  6    19*   dm_cm_datum.incl.pl1.
  6    20**/
  6    21 
  6    22 /* HISTORY:
  6    23*Written by Matthew Pierret, 04/01/82.
  6    24*Modified:
  6    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  6    26**/
  6    27 
  6    28 /* format: style2,ind3,ll79 */
  6    29 
  6    30      dcl	   element_id_string      bit (36) aligned;
  6    31 
  6    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  6    33 	     2 control_interval_id
  6    34 			      fixed bin (24) unal unsigned,
  6    35 	     2 index	      fixed bin (12) unal unsigned;
  6    36 
  6    37 
  6    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      774 
      775 
  7     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*     This include file contains declarations of all collection_manager_ 
  7     5*     entrypoints.
  7     6**/
  7     7 
  7     8 /* HISTORY:
  7     9*Written by Matthew Pierret 
  7    10*Modified:
  7    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  7    12*	  allocate_control_interval operation to be unaligned, as well as
  7    13*	  unsigned.
  7    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  7    15*            removed the beginning_location parameter from the put_element
  7    16*            operation. Added the create_page_file_operation.
  7    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  7    18*            wherever collection_id was required.
  7    19*            Also changed the control_interval_id parameter of the 
  7    20*            allocate_control_interval operation back to be aligned. So there.
  7    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  7    22*            added the argument file_create_info_ptr to $create_file.
  7    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  7    24*	  include the zero_on_free bit.
  7    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  7    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  7    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  7    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  7    29*            cm_$put_unprotected_header.
  7    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  7    31*             $simple_get_buffered_element.
  7    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  7    33*            parameter for specifying absolute/relative nature of search.
  7    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  7    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  7    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  7    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  7    38*            delete_from_ci_buffer.
  7    39*            Re-named *_buffered_ci to =_ci_buffer.
  7    40*            get entries.
  7    41*            modify entries.
  7    42*            Changed calling sequence of modify entries to have a ptr/length
  7    43*            instead of length/ptr parameter pair.
  7    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  7    45**/
  7    46 
  7    47 /* This include file contains declarations of collection_manager_ entrypoints */
  7    48 
  7    49 /* format: style2,ind3 */
  7    50      dcl	   collection_manager_$allocate_control_interval
  7    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    52      dcl	   collection_manager_$compact_control_interval
  7    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  7    54      dcl	   collection_manager_$create_collection
  7    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7    56      dcl	   collection_manager_$create_file
  7    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  7    58      dcl	   collection_manager_$destroy_collection
  7    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7    60      dcl	   collection_manager_$free_control_interval
  7    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  7    62 			      fixed bin (35));
  7    63 
  7    64      dcl	   collection_manager_$delete
  7    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    66 			      fixed bin (35));
  7    67      dcl	   collection_manager_$delete_from_ci_buffer
  7    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    69 			      fixed bin (35));
  7    70 
  7    71      dcl	   collection_manager_$get
  7    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    74      dcl	   collection_manager_$get_control_interval_ptr
  7    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  7    76 			      fixed bin (35));
  7    77      dcl	   collection_manager_$get_from_ci_buffer
  7    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    80      dcl	   collection_manager_$get_by_ci_ptr
  7    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  7    83      dcl	   collection_manager_$get_header
  7    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  7    85 			      ptr, fixed bin (35), fixed bin (35));
  7    86      dcl	   collection_manager_$get_id
  7    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  7    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    89      dcl	   collection_manager_$get_portion
  7    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7    92 			      fixed bin (35), fixed bin (35));
  7    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  7    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7    96 			      fixed bin (35));
  7    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  7    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   collection_manager_$modify
  7   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   103 			      fixed bin (35), fixed bin (35));
  7   104      dcl	   collection_manager_$modify_unprotected
  7   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   106 			      fixed bin (35), fixed bin (35));
  7   107      dcl	   collection_manager_$modify_in_ci_buffer
  7   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   109 			      fixed bin (35), fixed bin (35));
  7   110      dcl	   collection_manager_$modify_portion
  7   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  7   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   113      dcl	   collection_manager_$postcommit_increments
  7   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   115      dcl	   collection_manager_$put
  7   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   117 			      fixed bin (35), fixed bin (35));
  7   118      dcl	   collection_manager_$put_in_ci_buffer
  7   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   120 			      fixed bin (35), fixed bin (35));
  7   121      dcl	   collection_manager_$put_header
  7   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   123      dcl	   collection_manager_$put_unprotected_header
  7   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   125 
  7   126      dcl	   collection_manager_$replace_ci_buffer
  7   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   128 			      fixed bin (35));
  7   129      dcl	   collection_manager_$setup_ci_buffer
  7   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   131 			      fixed bin (35));
  7   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  7   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   134 			      fixed bin (35));
  7   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  7   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   137 			      fixed bin (35));
  7   138 
  7   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      776 
      777 
  8     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  8     2 
  8     3 /* HISTORY:
  8     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  8     5*Modified:
  8     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  8     7**/
  8     8 
  8     9 /* format: style2,ind3 */
  8    10      dcl	   1 specification_head   based (specification_head_ptr),
  8    11 	     2 version	      fixed bin (35),
  8    12 	     2 type	      fixed bin (17) unal,
  8    13 	     2 pad	      bit (18) unal,
  8    14 	     2 subset_specification_ptr
  8    15 			      ptr;
  8    16 
  8    17 
  8    18      dcl	   specification_head_ptr ptr;
  8    19      dcl	   SPECIFICATION_VERSION_4
  8    20 			      init (4) fixed bin (35) internal static options (constant);
  8    21 
  8    22      dcl	   (
  8    23 	   SEARCH_SPECIFICATION_TYPE
  8    24 			      init (1),
  8    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  8    26 			      init (1),
  8    27 	   NUMERIC_SPECIFICATION_TYPE
  8    28 			      init (2),
  8    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  8    30 			      init (2),
  8    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  8    32 			      init (3),
  8    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  8    34 			      init (4),
  8    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  8    36 			      init (5),
  8    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  8    38 			      init (6),
  8    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  8    40 			      init (7),
  8    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  8    42 			      init (8)
  8    43 	   )		      fixed bin (17) internal static options (constant);
  8    44 
  8    45 
  8    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      778 
      779 
  9     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*          The specification structure is used to identify sets items based on
  9     6*     the value of some of the contents of the items (the
  9     7*     search_specification), or based on the ordinal position (the
  9     8*     numeric_specification) of the first or last item in the desired set of
  9     9*     items in the set of all possible items.  It is used with the relation,
  9    10*     index and record managers.  The items for these three managers are
  9    11*     tuples, keys and records, respectively.  The sets of "all possible
  9    12*     items", for determination of ordinal position for these three managers
  9    13*     are: a relation, an index, and a record collection, respectively.
  9    14*     
  9    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  9    16*     must be included in any program which uses this (the
  9    17*     dm_specification.incl.pl1) include file.
  9    18**/
  9    19 
  9    20 /* HISTORY:
  9    21*
  9    22*Written by Lindsey Spratt, 05/19/82.
  9    23*Modified:
  9    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  9    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  9    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  9    27*	  Changed the version to 3.
  9    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  9    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  9    30*            Moved range type constants into dm_range_constants.incl.pl1.
  9    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  9    32*            intra-key/record compares.
  9    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  9    34*            Added a DESCRIPTION comment.
  9    35**/
  9    36 
  9    37 /* format: style2,ind3 */
  9    38      dcl	   1 search_specification based (search_specification_ptr),
  9    39 	     2 head	      like specification_head,
  9    40 	     2 maximum_number_of_constraints
  9    41 			      fixed bin (17) unal,
  9    42 	     2 number_of_and_groups
  9    43 			      fixed bin (17) unal,
  9    44 	     2 range	      unal,
  9    45 	       3 type	      fixed bin (17),
  9    46 	       3 size	      fixed bin (17),
  9    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  9    48 	       3 number_of_constraints
  9    49 			      fixed bin (17) unal,
  9    50 	       3 constraint	      (ss_maximum_number_of_constraints
  9    51 			      refer (search_specification.maximum_number_of_constraints)),
  9    52 	         4 field_id	      fixed bin (17) unal,
  9    53 	         4 operator_code  fixed bin (17) unal,
  9    54 	         4 value_field_id fixed bin (17) unal,
  9    55 	         4 pad	      bit (18) unal,
  9    56 	         4 value_ptr      ptr unal;
  9    57 
  9    58      dcl	   search_specification_ptr
  9    59 			      ptr;
  9    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  9    61 			      fixed bin (17);
  9    62 
  9    63      dcl	   1 numeric_specification
  9    64 			      based (numeric_specification_ptr),
  9    65 	     2 head	      like specification_head,
  9    66 	     2 range_size	      fixed bin (35) aligned,
  9    67 	     2 position_number    fixed bin (17) unal,
  9    68 	     2 pad	      bit (18) unal;
  9    69 
  9    70      dcl	   numeric_specification_ptr
  9    71 			      ptr;
  9    72 
  9    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      780 
      781 
 10     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
 10     2 
 10     3 /* Written by Lindsey Spratt, 07/07/82
 10     4*Modified:
 10     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
 10     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
 10     7*	  bit(1) arrays for determining if a given operator code "uses" a
 10     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
 10     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
 10    10**/
 10    11 
 10    12 /* format: style2,ind3 */
 10    13      dcl	   (
 10    14 	   EQUAL_OPERATOR_CODE    init (1),
 10    15 	   GREATER_OPERATOR_CODE  init (2),
 10    16 	   LESS_OPERATOR_CODE     init (7),
 10    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
 10    18 			      init (8),
 10    19 	   NOT_EQUAL_OPERATOR_CODE
 10    20 			      init (5),
 10    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
 10    22 			      init (3),
 10    23 	   LESS_OR_EQUAL_OPERATOR_CODE
 10    24 			      init (6),
 10    25 	   EQUAL_IDX	      init (18),
 10    26 	   GREATER_IDX	      init (17),
 10    27 	   NOT_IDX	      init (16),
 10    28 	   REGULAR_EXPRESSION_IDX init (15)
 10    29 	   )		      fixed bin internal static options (constant);
 10    30 
 10    31      dcl	   (
 10    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
 10    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
 10    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
 10    35 			      (25) (1)"0"b),
 10    36 	   USES_REGULAR_EXPRESSION_OPERATOR
 10    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
 10    38 			      (19) (1)"0"b)
 10    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
 10    40 
 10    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      782 
      783 
 11     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
 11     2 
 11     3 /* HISTORY:
 11     4*Written by Matthew Pierret, 05/27/83.
 11     5*Modified:
 11     6**/
 11     7 
 11     8      dcl	   (
 11     9 	   ALL_RANGE_TYPE	      init (1),
 11    10 	   LOW_RANGE_TYPE	      init (2),
 11    11 	   HIGH_RANGE_TYPE	      init (3)
 11    12 	   )		      fixed bin internal static options (constant);
 11    13 
 11    14 
 11    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
      784 
      785 
 12     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*
 12     5*          The field_table describes the layout of a set of fields in a
 12     6*     formatted data string.  Such a string is the stored representation of a
 12     7*     record or a key.  Fields are placed side-by-side in the string in the
 12     8*     order they appear in the field_table.field array.  The string is divided
 12     9*     into the fixed portion and the varying portion.  In the fixed portion
 12    10*     appear fixed-length fields and fixed-size length-fields for
 12    11*     varying-length fields.  In the varying portion appear varying length
 12    12*     fields.  The length-field for a varying-length field contains the length
 12    13*     of the field values either in bits or in characters, depending on the
 12    14*     data type of the field.
 12    15**/
 12    16 
 12    17 /* HISTORY:
 12    18*Written by Matthew Pierret, 04/01/82.
 12    19*Modified:
 12    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
 12    21*	  that if the field is varying, its length is expressed in
 12    22*	  bytes/characters.
 12    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
 12    24*	  of 17, changed version to 2, changed version field to char(8) from
 12    25*	  fixed bin (17).
 12    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
 12    27*            put field names in one string (field_names) at the end of the 
 12    28*            structure. Added field.location_of_name and field.length_of_name
 12    29*            for locating the field name in field_names. Aligned all "fixed bin"
 12    30*            structure elements.  Changed maximum_field_name_length to 
 12    31*            length_of_field_names.
 12    32**/
 12    33 
 12    34 /* format: style2 */
 12    35 
 12    36      dcl	   1 field_table	      aligned based (field_table_ptr),
 12    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
 12    38 	     2 number_of_fields   fixed bin (17),
 12    39 	     2 length_of_field_names
 12    40 			      fixed bin (17),	/* length of field_names in characters */
 12    41 	     2 location_of_first_varying_field
 12    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
 12    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
 12    44 	       3 flags	      aligned,
 12    45 	         4 descriptor_is_varying
 12    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
 12    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
 12    48 						/* containing the id of the element in which the descriptor is stored. */
 12    49 	         4 length_is_in_characters
 12    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
 12    51 						/* in characters instead of in bits */
 12    52 	         4 must_be_zero   bit (34) unal,
 12    53 	       3 descriptor	      bit (36) aligned,
 12    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
 12    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
 12    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
 12    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
 12    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
 12    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
 12    60 	       3 varying_field_index
 12    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
 12    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
 12    63 
 12    64 
 12    65      dcl	   field_table_ptr	      ptr;
 12    66      dcl	   ft_length_of_field_names
 12    67 			      fixed bin;
 12    68      dcl	   ft_number_of_fields    fixed bin;
 12    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
 12    70 
 12    71 dcl field_name char (field_name_length) based (field_name_ptr);
 12    72 
 12    73 dcl field_name_length fixed bin;
 12    74 dcl field_name_ptr ptr;
 12    75 
 12    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      786 
      787 
 13     1 /* ***********************************************************
 13     2*   *                                                         *
 13     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 13     4*   *                                                         *
 13     5*   *********************************************************** */
 13     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
 13     7 
 13     8 /* Written by Lindsey Spratt, 03/04/82.
 13     9*Modified:
 13    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
 13    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
 13    12*	  the print_vector value (char varying), ptr to the typed_vector
 13    13*	  value location, and a code. cv_to_print now takes ptr to the
 13    14*	  descriptor, ptr to the typed_vector value, the print_vector value
 13    15*	  (char(*) varying), the maximum allowed length for the print_vector
 13    16*	  value, a temp_seg to put the value in if its to big to fit into
 13    17*	  the print_vector, and a code.
 13    18**/
 13    19 
 13    20 /* format: style2,ind3 */
 13    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
 13    22 	     2 version	      fixed bin (35),
 13    23 	     2 number_of_dimensions
 13    24 			      fixed bin (17),
 13    25 	     2 number_of_vectors  fixed bin (17),
 13    26 	     2 number_of_vector_slots
 13    27 			      fixed bin (17),
 13    28 	     2 maximum_dimension_name_length
 13    29 			      fixed bin (17),
 13    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
 13    31 	       3 name	      char (tva_maximum_dimension_name_length
 13    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
 13    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
 13    34 						/* temp_seg_ptr, max_length_for_print_value, */
 13    35 						/* print_value, code) */
 13    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
 13    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
 13    38 						/* print_value_ptr, typed_value_ptr, code) */
 13    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 13    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
 13    41 			      pointer;
 13    42 
 13    43      dcl	   typed_vector_array_ptr ptr;
 13    44      dcl	   tva_number_of_vector_slots
 13    45 			      fixed bin;
 13    46      dcl	   tva_number_of_dimensions
 13    47 			      fixed bin;
 13    48      dcl	   tva_maximum_dimension_name_length
 13    49 			      fixed bin;
 13    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
 13    51 			      fixed bin (35) int static options (constant) init (2);
 13    52 
 13    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      788 
      789 
 14     1 /* BEGIN INCLUDE FILE - dm_interval_spec.incl.pl1 */
 14     2 
 14     3 
 14     4 
 14     5 
 14     6 /****^  HISTORY COMMENTS:
 14     7*  1) change(86-09-19,Dupuis), approve(86-09-19,MCR7401), audit(86-09-24,Blair),
 14     8*     install(86-10-02,MR12.0-1173):
 14     9*     Changed the declaration of interval_bead to also initialize id_string and
 14    10*     id_list_ptr. The declare had initialized all of the structure but forgot
 14    11*     these elements.
 14    12*                                                   END HISTORY COMMENTS */
 14    13 
 14    14 
 14    15 
 14    16 /* DESCRIPTION:
 14    17*
 14    18*          The interval_specification is used in the index manager searching as
 14    19*     an internal (normalized) representation of the search specification.
 14    20*     Each interval_bead is a separate search problem, a separate interval.
 14    21*     The im_build_interval_spec module builds the interval_specification by
 14    22*     analyzing the search_specification.  The im_structural_search module
 14    23*     applies the interval_specification to the index.
 14    24**/
 14    25 
 14    26 /* HISTORY:
 14    27*
 14    28*Written by Lindsey Spratt, 10/06/82.
 14    29*Modified:
 14    30*10/26/84 by Lindsey L. Spratt:  Added documentation.  Changed to have a
 14    31*            char(8) version in interval_specification.
 14    32**/
 14    33 
 14    34 /* format: style2,ind3 */
 14    35      dcl	   1 interval_specification
 14    36 			      based (interval_specification_ptr) aligned,
 14    37 	     2 version	      char (8) aligned,
 14    38 	     2 number_of_intervals
 14    39 			      fixed bin (17) unaligned init (0),
 14    40 	     2 pad	      bit (18) unaligned init ("0"b),
 14    41 	     2 first_interval_bead_ptr
 14    42 			      ptr init (null),
 14    43 	     2 last_interval_bead_ptr
 14    44 			      ptr init (null);
 14    45 
 14    46      dcl	   1 interval_bead	      based (interval_bead_ptr) aligned,
 14    47 	     2 simple_typed_vector_ptr
 14    48 			      ptr init (null),
 14    49 	     2 next	      ptr init (null),
 14    50 	     2 number_of_fully_structural_fields
 14    51 			      fixed bin (17) init (0) unal,
 14    52 	     2 low,
 14    53 	       3 id_string	      bit (36) aligned init ("0"b),
 14    54 	       3 value_ptr	      ptr unaligned init (null),
 14    55 	       3 operator_code    fixed bin (18) uns unal init (0),
 14    56 	       3 pad	      bit (18) init ("0"b) unal,
 14    57 	     2 high	      like interval_bead.low,
 14    58 	     2 id_list_ptr	      ptr init (null);	/* This points at an id_list as declared in dm_id_list.incl.pl1 */
 14    59 						/* The ids in this list are of and_groups in */
 14    60 						/* the original search_specification. */
 14    61 
 14    62      dcl	   interval_specification_ptr
 14    63 			      ptr init (null);
 14    64      dcl	   interval_bead_ptr      ptr init (null);
 14    65      dcl	   INTERVAL_SPECIFICATION_VERSION_2
 14    66 			      init ("IntSpc 2") aligned char (8) internal static options (constant);
 14    67 
 14    68 
 14    69 /* END INCLUDE FILE - dm_interval_spec.incl.pl1 */
      790 
      791 
 15     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
 15     2 
 15     3 /* DESRIPTION:
 15     4*
 15     5*          The index_opening_info is per-process information, stored in a
 15     6*     hash_table managed by the opening_manager_, which allows the
 15     7*     index_manager_ to quickly reference certain unchanging pieces of
 15     8*     information rapidly.
 15     9**/
 15    10 
 15    11 /* HISTORY:
 15    12*
 15    13*Written by Lindsey Spratt, 10/28/82.
 15    14*Modified:
 15    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
 15    16*            description.  Added the current_rollback_count.  Added the
 15    17*	  key_count_array_ptr.
 15    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
 15    19*	  key_counts_postcommit_written.  Changed to version 3.
 15    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
 15    21*	  flag is used by im_update_opening_info to help it maintain the
 15    22*	  key count array info.
 15    23**/
 15    24 
 15    25 /* format: style2,ind3 */
 15    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
 15    27 	     2 version	      char (8) aligned,
 15    28 	     2 file_opening_id    bit (36) aligned,
 15    29 	     2 collection_id      bit (36) aligned,
 15    30 	     2 index_header_ptr   ptr init (null),
 15    31 	     2 field_table_ptr    ptr init (null),
 15    32 	     2 key_count_array_ptr
 15    33 			      ptr init (null),
 15    34 	     2 key_count_increments_ptr
 15    35 			      ptr init (null),
 15    36 	     2 flags,
 15    37 	       3 key_count_postcommit_written
 15    38 			      bit (1) unal init ("0"b),
 15    39 	       3 key_count_unprotected_file
 15    40 			      bit (1) unal init ("0"b),
 15    41 	       3 pad	      bit (34) unal init (""b),
 15    42 	     2 current_txn_id     fixed bin (35) init (0),
 15    43 	     2 current_rollback_count
 15    44 			      fixed bin (35) init (0);
 15    45 
 15    46      dcl	   index_opening_info_ptr ptr init (null);
 15    47      dcl	   INDEX_OPENING_INFO_VERSION_3
 15    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
 15    49 
 15    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      792 
      793 
 16     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
 16     2 
 16     3 /* DESCRIPTION
 16     4*        The id_list structure is used to identify attributes, fields and
 16     5*   dimensions by various modules of the Data Management System.
 16     6**/
 16     7 
 16     8 /* HISTORY:
 16     9*Written by Matthew Pierret, '82.
 16    10*Modified:
 16    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
 16    12*            (constant)' and to initialize automatic variables.
 16    13**/
 16    14 
 16    15 /* format: style2,ind3 */
 16    16      dcl	   1 id_list	      aligned based (id_list_ptr),
 16    17 	     2 version	      fixed bin (35),
 16    18 	     2 number_of_ids      fixed bin (17),
 16    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
 16    20 
 16    21      dcl	   id_list_ptr	      ptr init (null);
 16    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
 16    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
 16    24 
 16    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      794 
      795 
 17     1 /* BEGIN INCLUDE FILE - dm_interval_list.incl.pl1 */
 17     2 
 17     3 /* DESCRIPTION:
 17     4*
 17     5*          The interval_list structure is used to describe a number of
 17     6*     intervals of keys in an associated typed_vector_array.  With each
 17     7*     interval is a list of the and_groups from the search_specification used
 17     8*     to find those keys.  All of the constraints on fields which are specified
 17     9*     in the and_groups associated with an interval and are in the keys are
 17    10*     completely satisfied by the keys in the interval.
 17    11**/
 17    12 
 17    13 /* HISTORY:
 17    14*
 17    15*Written by Lindsey Spratt, 11/09/82.
 17    16*Modified:
 17    17**/
 17    18 
 17    19 /* format: style2,ind3 */
 17    20      dcl	   1 interval_list	      based (interval_list_ptr) aligned,
 17    21 	     2 version	      char (8),		/* Must be set to INTERVAL_LIST_VERSION_2. */
 17    22 	     2 number_of_intervals
 17    23 			      fixed bin (17) unal,
 17    24 	     2 pad	      bit (18) unal,
 17    25 	     2 interval	      (intl_number_of_intervals refer (interval_list.number_of_intervals)),
 17    26 	       3 low_vector_idx   fixed bin (35),	/* The first vector in the associated typed_vector_array for this interval. */
 17    27 	       3 high_vector_idx  fixed bin (35),	/* The last vector for this interval. */
 17    28 	       3 and_group_id_list_ptr
 17    29 			      ptr;		/* points to an id_list which identifies the */
 17    30 						/* and_groups in the associated search_specification */
 17    31 						/* which apply to the vectors in this interval. */
 17    32 
 17    33      dcl	   interval_list_ptr      ptr init (null);
 17    34      dcl	   INTERVAL_LIST_VERSION_2
 17    35 			      init ("IntLst 2") char (8) aligned internal static options (constant);
 17    36      dcl	   intl_number_of_intervals
 17    37 			      fixed bin init (0);
 17    38 
 17    39 /* END INCLUDE FILE dm_interval_list.incl.pl1 */
      796 
      797 
 18     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
 18     2 
 18     3 
 18     4 
 18     5 /****^  HISTORY COMMENTS:
 18     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
 18     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
 18     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
 18     9*     beginning of the structure to the element key_count_array.count in
 18    10*     characters. Using this it is possible to calculate the key_count_array_ptr
 18    11*     given the "addr (key_count_array.count (0))".
 18    12*                                                   END HISTORY COMMENTS */
 18    13 
 18    14 
 18    15 /* DESCRIPTION:
 18    16*
 18    17*          The key_count_array holds counts of the number of unique key values
 18    18*     in an index.  These values are used by the search optimization done by
 18    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
 18    20*     number of keys in the index which have at least fields 1 through N
 18    21*     having the same value as another key in the index, i.e. count(N)
 18    22*     is the number of partial duplicates with number of partial
 18    23*     duplication fields equal to N.
 18    24*
 18    25**/
 18    26 
 18    27 /* HISTORY:
 18    28*
 18    29*Written by Lindsey Spratt, 11/09/82.
 18    30*Modified:
 18    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
 18    32*	  Added a description, fixed the history section.
 18    33**/
 18    34 
 18    35 /* format: style2,ind3 */
 18    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
 18    37 	     2 version	      char (8) aligned,
 18    38 	     2 number_of_counts   fixed bin (17) unal,
 18    39 	     2 pad	      bit (18) unal,
 18    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
 18    41 			      bin (35) aligned;
 18    42 
 18    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
 18    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
 18    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
 18    46 			      init (12) fixed bin internal static options (constant);
 18    47 
 18    48      dcl	   key_count_array_ptr    ptr init (null);
 18    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
 18    50 
 18    51 
 18    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      798 
      799 
 19     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 19     2 /* format: style3 */
 19     3 
 19     4 /* These constants are to be used for the flags argument of sub_err_ */
 19     5 /* They are just "string (condition_info_header.action_flags)" */
 19     6 
 19     7 declare	(
 19     8 	ACTION_CAN_RESTART	init (""b),
 19     9 	ACTION_CANT_RESTART init ("1"b),
 19    10 	ACTION_DEFAULT_RESTART
 19    11 			init ("01"b),
 19    12 	ACTION_QUIET_RESTART
 19    13 			init ("001"b),
 19    14 	ACTION_SUPPORT_SIGNAL
 19    15 			init ("0001"b)
 19    16 	)		bit (36) aligned internal static options (constant);
 19    17 
 19    18 /* End include file */
      800 
      801    end im_general_search$get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1300.0  im_general_search.pl1             >spec>install>MR12.1-1020>im_general_search.pl1
708          1    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
766          2    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
768          3    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
770          4    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
772          5    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
774          6    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
776          7    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
778          8    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
780          9    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
782         10    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
784         11    10/14/83  1609.1  dm_range_constants.incl.pl1       >ldd>include>dm_range_constants.incl.pl1
786         12    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
788         13    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
790         14    10/02/86  1226.6  dm_interval_spec.incl.pl1         >ldd>include>dm_interval_spec.incl.pl1
792         15    04/05/85  0924.4  dm_im_opening_info.incl.pl1       >ldd>include>dm_im_opening_info.incl.pl1
794         16    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
796         17    01/07/85  0859.0  dm_interval_list.incl.pl1         >ldd>include>dm_interval_list.incl.pl1
798         18    04/02/87  1300.6  dm_key_count_array.incl.pl1       >spec>install>MR12.1-1020>dm_key_count_array.incl.pl1
800         19    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
                                000057 constant        fixed bin(17,0)          initial dcl 8-22 set ref 299 303* 310*
ABSOLUTE_SEARCH_SPECIFICATION_TYPE
                                000060 constant        fixed bin(17,0)          initial dcl 8-22 set ref 285 310*
ACTION_CANT_RESTART             000053 constant        bit(36)                  initial dcl 19-7 set ref 303* 310* 573* 587*
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 4-56 ref 607 607 632
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 1-37 ref 627
DEFAULT_AND_GROUP_ID_LIST_PTR   000024 constant        pointer                  initial dcl 176 set ref 426* 431* 436* 441*
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 4-56 ref 604
DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
                                000052 constant        fixed bin(17,0)          initial dcl 178 set ref 426* 431* 436* 441*
DEFAULT_PARTIAL_STRUCTURAL_FIELD_ID
                                000052 constant        fixed bin(17,0)          initial dcl 178 set ref 426* 431* 436* 441* 719 721
FIELD_TABLE_VERSION_3           000010 constant        char(8)                  initial dcl 12-69 set ref 332*
FIRST_KEY                       000052 constant        bit(1)                   initial dcl 191 set ref 348* 411* 423* 482* 724*
HIGH_RANGE_TYPE                        constant        fixed bin(17,0)          initial dcl 11-8 ref 462
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 5-66 ref 270
INDEX_HEADER_VERSION_4          000014 constant        char(8)                  initial dcl 3-38 set ref 326*
INDEX_OPENING_INFO_VERSION_3    000004 constant        char(8)                  initial dcl 15-47 set ref 323*
INTERVAL_LIST_VERSION_2         000002 constant        char(8)                  initial dcl 17-34 ref 374 454
INTERVAL_SPECIFICATION_VERSION_2
                                000006 constant        char(8)                  initial dcl 14-65 set ref 345*
KEY_COUNT_ARRAY_VERSION_2       000000 constant        char(8)                  initial dcl 18-43 set ref 392*
LAST_KEY                        000053 constant        bit(1)                   initial dcl 191 set ref 417* 466*
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 4-56 ref 607 607 632
LOW_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 11-8 ref 478
RELATIVE_NUMERIC_SPECIFICATION_TYPE
                                000055 constant        fixed bin(17,0)          initial dcl 8-22 set ref 292 310*
RELATIVE_SEARCH_SPECIFICATION_TYPE
                                000054 constant        fixed bin(17,0)          initial dcl 8-22 set ref 278 310*
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 8-19 ref 276
USES_GREATER_OPERATOR           000012 constant        bit(1)                   initial array unaligned dcl 10-31 ref 466
addr                                                   builtin function         dcl 167 ref 636 649 654 673 686 686 686 706
and_group_id_list_ptr
                          6            based           pointer                  array level 3 dcl 17-20 set ref 375* 458* 758*
bk_string_length                000112 automatic       fixed bin(35,0)          dcl 1-39 set ref 679*
branch_ci_header                       based           structure                level 1 unaligned dcl 4-48
branch_ci_header_ptr            000136 automatic       pointer                  dcl 4-53 set ref 636* 685 694
branch_id                              based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 1-32 ref 692
branch_key                             based           structure                level 1 packed unaligned dcl 1-32
branch_key_ptr                  000114 automatic       pointer                  dcl 1-40 set ref 686* 692
cleanup                         000120 stack reference condition                dcl 172 ref 317
collection_id             2            based           bit(36)                  level 2 dcl 5-29 set ref 319* 607* 686*
collection_manager_$get         000056 constant        entry                    external dcl 7-71 ref 607
collection_manager_$get_portion 000060 constant        entry                    external dcl 7-89 ref 686
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 4-43 in procedure "im_general_search$get"
common                                 based           structure                level 2 in structure "branch_ci_header" unaligned
                                                                                  dcl 4-48 in procedure "im_general_search$get"
common_ci_header                       based           structure                level 1 unaligned dcl 4-26
common_ci_header_ptr            000132 automatic       pointer                  dcl 4-41 set ref 636* 650* 660 664 668* 669 677* 680
                                                                                  695*
control_interval_id             000111 automatic       fixed bin(24,0)          level 2 in structure "fki_element_id" packed
                                                                                  unsigned unaligned dcl 630 in procedure
                                                                                  "FIND_KEY_ID" set ref 650 664* 665 668 676* 677
                                                                                  692* 694* 695
control_interval_id             000107 automatic       fixed bin(24,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 600 in procedure
                                                                                  "GET_CI_HEADER" set ref 603*
count                           000104 automatic       bit(1)                   initial dcl 148 set ref 148* 262* 486 497 516 528
current_key_exists       12(02)        based           bit(1)                   level 3 packed unaligned dcl 5-29 ref 654
data_format_util_$cv_table_to_typed_array
                                000034 constant        entry                    external dcl 218 ref 383
delete                          000103 automatic       bit(1)                   initial dcl 148 set ref 148* 255* 389 431 486 497
                                                                                  507 732
dm_error_$bad_first_key_idx     000042 external static fixed bin(35,0)          dcl 224 set ref 613*
dm_error_$bad_last_key_idx      000046 external static fixed bin(35,0)          dcl 224 set ref 615*
dm_error_$bad_specification_type
                                000050 external static fixed bin(35,0)          dcl 224 set ref 310*
dm_error_$invalid_cursor_position
                                000052 external static fixed bin(35,0)          dcl 224 set ref 641*
dm_error_$key_not_found         000040 external static fixed bin(35,0)          dcl 224 set ref 328* 366* 528 652* 665*
dm_error_$programming_error     000044 external static fixed bin(35,0)          dcl 224 set ref 303*
element_id                             based           structure                level 1 dcl 6-32
er_p_code                              parameter       fixed bin(35,0)          dcl 559 ref 557 561
error_table_$unimplemented_version
                                000054 external static fixed bin(35,0)          dcl 224 set ref 573* 587*
field_table                            based           structure                level 1 dcl 12-36
field_table_ptr                 000150 automatic       pointer                  dcl 12-65 in procedure "im_general_search$get" set
                                                                                  ref 331* 332 383* 426* 431* 436* 441* 727* 732*
                                                                                  737* 741*
field_table_ptr           6            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 15-26 in procedure "im_general_search$get" ref
                                                                                  331
file_opening_id           1            based           bit(36)                  level 2 dcl 5-29 set ref 319* 607* 686*
first                     1            based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_general_search$get" ref 613 615 669
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 4-43 in procedure
                                                                                  "im_general_search$get" ref 701 704
first_interval_bead_ptr
                          4            based           pointer                  initial level 2 dcl 14-35 ref 348 470 481 485 496
                                                                                  534
fki_branch_key_head_buffer      000110 automatic       bit                      dcl 627 set ref 686 686 686 686 686 686
fki_code                        000110 automatic       fixed bin(35,0)          dcl 629 set ref 635* 645* 646 646* 686* 689 689*
fki_element_id                  000111 automatic       structure                level 1 dcl 630 set ref 649 654 673 686 706
fki_element_id_string                  based           bit(36)                  dcl 631 set ref 649* 654* 673 686* 706
fki_local_header_buffer         000112 automatic       bit                      dcl 632 set ref 636
fki_p_element_id_string                parameter       bit                      dcl 624 set ref 621 673* 706*
fki_p_find_last_key                    parameter       bit(1)                   dcl 623 ref 621 637 682 698 702
flags                                  based           structure                level 2 in structure "common_ci_header" packed
                                                                                  unaligned dcl 4-26 in procedure
                                                                                  "im_general_search$get"
flags                    12            based           structure                level 2 in structure "index_cursor" dcl 5-29
                                                                                  in procedure "im_general_search$get"
gch_code                        000106 automatic       fixed bin(35,0)          dcl 599 set ref 605* 607* 610 610*
gch_element_id                  000107 automatic       structure                level 1 dcl 600 set ref 607 607
gch_p_ci_header_ptr                    parameter       pointer                  dcl 597 set ref 593 607* 607* 613 615 615
gch_p_control_interval_id              parameter       fixed bin(24,0)          unsigned dcl 595 ref 593 603
get                             000102 automatic       bit(1)                   initial dcl 148 set ref 148* 242* 369 379 426 449
                                                                                  486 497 505 727 748
get_dm_free_area_               000010 constant        entry                    external dcl 198 ref 260
gk_code                         000272 automatic       fixed bin(35,0)          dcl 713 set ref 727* 732* 737* 741* 745 745*
head                                   based           structure                level 2 unaligned dcl 9-38
high                     10            based           structure                level 2 dcl 14-46
high_element_id_string          000112 automatic       bit(36)                  initial dcl 154 set ref 154* 412* 417* 422* 426*
                                                                                  431* 436* 441*
high_vector_idx           5            based           fixed bin(35,0)          array level 3 dcl 17-20 set ref 456* 756*
id_list                                based           structure                level 1 dcl 16-16 ref 539
id_list_ptr                     000160 automatic       pointer                  initial dcl 16-21 in procedure
                                                                                  "im_general_search$get" set ref 16-21*
id_list_ptr              14            based           pointer                  initial level 2 in structure "interval_bead"
                                                                                  dcl 14-46 in procedure "im_general_search$get" set
                                                                                  ref 539 539 727* 732* 737* 741* 758 759*
id_string                 5            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 14-46 in procedure "im_general_search$get" set
                                                                                  ref 348* 466 482 482* 716 724 724* 727* 732* 737*
                                                                                  741*
id_string                10            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 14-46 in procedure "im_general_search$get" set
                                                                                  ref 466 466* 716 727* 732* 737* 741*
il_number_of_ids                000162 automatic       fixed bin(17,0)          initial dcl 16-22 set ref 16-22*
im_build_interval_spec          000016 constant        entry                    external dcl 203 ref 338
im_get_opening_info             000012 constant        entry                    external dcl 199 ref 319
im_process_keys$count           000032 constant        entry                    external dcl 215 ref 441 741
im_process_keys$delete          000026 constant        entry                    external dcl 210 ref 431 732
im_process_keys$get             000024 constant        entry                    external dcl 208 ref 426 727
im_process_keys$position        000030 constant        entry                    external dcl 212 ref 436 737
im_structural_search            000020 constant        entry                    external dcl 205 ref 361
im_update_opening_info$key_count_array
                                000014 constant        entry                    external dcl 200 ref 510
im_validate_cursor              000022 constant        entry                    external dcl 206 ref 645
index                     0(24) 000107 automatic       fixed bin(12,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 600 in procedure
                                                                                  "GET_CI_HEADER" set ref 604*
index                     0(24) 000111 automatic       fixed bin(12,0)          level 2 in structure "fki_element_id" packed
                                                                                  unsigned unaligned dcl 630 in procedure
                                                                                  "FIND_KEY_ID" set ref 660 669* 671* 671 685* 698*
                                                                                  701* 702* 704*
index_cursor                           based           structure                level 1 unaligned dcl 5-29
index_cursor_ptr                000140 automatic       pointer                  dcl 5-64 set ref 268* 270 319 319 361* 426* 431*
                                                                                  436* 441* 607 607 641 645* 649 652 654 654 686 686
                                                                                  727* 732* 737* 741*
index_header                           based           structure                level 1 dcl 3-25
index_header_ptr                000130 automatic       pointer                  dcl 3-37 in procedure "im_general_search$get" set
                                                                                  ref 325* 326 328 676
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 15-26 in procedure "im_general_search$get" ref
                                                                                  325
index_opening_info                     based           structure                level 1 dcl 15-26
index_opening_info_ptr          000156 automatic       pointer                  initial dcl 15-46 set ref 319* 323 325 331 361* 392
                                                                                  394 398 510* 15-46* 645*
interval                  4            based           structure                array level 2 dcl 17-20
interval_bead                          based           structure                level 1 dcl 14-46 set ref 541
interval_bead_ptr               000154 automatic       pointer                  initial dcl 14-64 set ref 465* 466 466 466 466 470*
                                                                                  475* 475 481* 482 482 485* 491* 491 496* 502* 502
                                                                                  14-64* 534* 535 536 537 537 539 539 541 542* 716
                                                                                  716 718 721 724 724 727 727 727 727 732 732 732
                                                                                  732 737 737 737 737 741 741 741 741 758 759
interval_idx                    000116 automatic       fixed bin(17,0)          dcl 158 set ref 471* 486* 497* 755 756 758
interval_list                          based           structure                level 1 dcl 17-20 set ref 373 453 547
interval_list_ptr               000164 automatic       pointer                  initial dcl 17-33 set ref 264* 373* 374 375 453* 454
                                                                                  455 456 458 505 17-33* 547 547 547 751 755 756 758
interval_specification                 based           structure                level 1 dcl 14-35 set ref 544
interval_specification_ptr      000152 automatic       pointer                  initial dcl 14-62 set ref 338* 342 345 348 355 361*
                                                                                  372 401 465 470 471 481 485 486 496 497 14-62* 531
                                                                                  534 544
intl_number_of_intervals        000166 automatic       fixed bin(17,0)          initial dcl 17-36 set ref 372* 373 373 452* 453 453
                                                                                  17-36*
is_at_end_of_index       12(01)        based           bit(1)                   level 3 packed unaligned dcl 5-29 ref 652
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 4-26 ref 680
is_relative_specification       000106 automatic       bit(1)                   initial dcl 148 set ref 148* 282* 289* 296* 307*
                                                                                  361* 637 698 724
is_search_specification         000107 automatic       bit(1)                   initial dcl 148 set ref 148* 283* 290* 297* 308* 334
                                                                                  405 637 637 654 698
is_valid                 12(03)        based           bit(1)                   level 3 packed unaligned dcl 5-29 ref 641
kca_number_of_counts            000172 automatic       fixed bin(17,0)          initial dcl 18-49 set ref 394* 396 396 18-49*
key_count_array                        based           structure                level 1 dcl 18-36 set ref 396 398* 398 551
key_count_array_ptr             000170 automatic       pointer                  initial dcl 18-48 in procedure
                                                                                  "im_general_search$get" set ref 264* 396* 398 431*
                                                                                  510* 18-48* 551 551 732*
key_count_array_ptr      10            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 15-26 in procedure "im_general_search$get" ref
                                                                                  392 394 398
key_id_string             3            based           bit(36)                  level 2 dcl 5-29 ref 649 654
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed
                                                                                  unaligned dcl 4-43 in procedure
                                                                                  "im_general_search$get"
key_range                 1            based           structure                level 2 in structure "common_ci_header" packed
                                                                                  unaligned dcl 4-26 in procedure
                                                                                  "im_general_search$get"
key_range                 1            based           structure                level 3 in structure "branch_ci_header" packed
                                                                                  unaligned dcl 4-48 in procedure
                                                                                  "im_general_search$get"
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 4-43 in procedure
                                                                                  "im_general_search$get" ref 698 702
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "branch_ci_header" packed
                                                                                  unsigned unaligned dcl 4-48 in procedure
                                                                                  "im_general_search$get" ref 685
last                      1(18)        based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_general_search$get" ref 615 660
last_interval_bead_ptr
                          6            based           pointer                  initial level 2 dcl 14-35 ref 465
leaf_ci_header                         based           structure                level 1 unaligned dcl 4-43
leaf_ci_header_ptr              000134 automatic       pointer                  dcl 4-46 set ref 636* 698 701 702 704
length                                                 builtin function         dcl 167 ref 686 686 686 686
low                       5            based           structure                level 2 dcl 14-46
low_branch_id             5            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-48 ref 694
low_element_id_string           000113 automatic       bit(36)                  initial dcl 154 set ref 154* 411* 416* 423* 426*
                                                                                  431* 436* 441*
low_vector_idx            4            based           fixed bin(35,0)          array level 3 dcl 17-20 set ref 455* 755*
max                                                    builtin function         dcl 167 ref 607 607 632
myname                          000016 constant        char(17)                 initial unaligned dcl 189 set ref 303* 310* 573*
                                                                                  587*
new_buffer_was_allocated        000114 automatic       bit(1)                   initial dcl 156 set ref 156*
next                      2            based           pointer                  initial level 2 dcl 14-46 ref 475 491 502 536
next_id                   3(24)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-26 ref 664
next_ptr                        000100 automatic       pointer                  dcl 526 set ref 536* 542
no_match                        000115 automatic       bit(1)                   initial dcl 156 set ref 156* 361* 366
null                                                   builtin function         dcl 167 ref 147 264 273 303 303 310 310 342 355 375
                                                                                  401 405 458 14-62 14-64 15-46 16-21 17-33 18-48
                                                                                  531 535 537 539 547 551 573 573 587 587 607 607
                                                                                  686 686 719 751 759
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 9-38 ref 348 355
number_of_counts          2            based           fixed bin(17,0)          level 2 packed unaligned dcl 18-36 set ref 394 396*
                                                                                  398 551
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-17 ref 537 721 723
number_of_fully_structural_fields
                          4            based           fixed bin(17,0)          initial level 2 packed unaligned dcl 14-46 ref 721
                                                                                  727 732 737 741
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 16-16 ref 539
number_of_intervals       2            based           fixed bin(17,0)          level 2 in structure "interval_list" packed
                                                                                  unaligned dcl 17-20 in procedure
                                                                                  "im_general_search$get" set ref 373* 375 453* 547
number_of_intervals       2            based           fixed bin(17,0)          initial level 2 in structure
                                                                                  "interval_specification" packed unaligned
                                                                                  dcl 14-35 in procedure "im_general_search$get" ref
                                                                                  372 471 486 497
number_of_keys_accepted         000110 automatic       fixed bin(35,0)          initial dcl 150 set ref 150* 431* 436* 441* 471 486
                                                                                  486 497 514 516 732* 737* 741* 751 755 762*
number_of_structural_fields     000111 automatic       fixed bin(17,0)          initial dcl 152 set ref 152*
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 13-21 ref 456 751 756 762
numeric_specification                  based           structure                level 1 unaligned dcl 9-63
numeric_specification_ptr       000146 automatic       pointer                  dcl 9-70 set ref 264* 295* 302* 303 303 405 408
operator_code             7            based           fixed bin(18,0)          initial level 3 packed unsigned unaligned dcl 14-46
                                                                                  ref 466
p_code                                 parameter       fixed bin(35,0)          dcl 143 set ref 125 245 251 258 267* 319* 320 320*
                                                                                  338* 339 339* 361* 363 363* 383* 385 385* 426*
                                                                                  431* 436* 441* 446 446* 510* 511 511* 528 528*
                                                                                  561*
p_expected_version                     parameter       char(8)                  dcl 583 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  580 587 587*
p_expected_version                     parameter       fixed bin(35,0)          dcl 570 in procedure "CHECK_VERSION" set ref 567 573
                                                                                  573*
p_id_list_ptr                          parameter       pointer                  dcl 134 set ref 125 383* 426* 727*
p_index_cursor_ptr                     parameter       pointer                  dcl 136 ref 125 245 251 258 268
p_interval_list_ptr                    parameter       pointer                  dcl 139 set ref 125 505* 547
p_key_count                            parameter       fixed bin(35,0)          dcl 142 set ref 258 261* 516*
p_number_of_keys_deleted               parameter       fixed bin(35,0)          dcl 140 set ref 251 254* 514*
p_received_version                     parameter       char(8)                  dcl 583 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  580 587 587*
p_received_version                     parameter       fixed bin(35,0)          dcl 569 in procedure "CHECK_VERSION" set ref 567 573
                                                                                  573*
p_specification_ptr                    parameter       pointer                  dcl 133 set ref 125 245 251 258 272 426* 431* 436*
                                                                                  441*
p_structure_name                       parameter       char                     unaligned dcl 571 in procedure "CHECK_VERSION" set
                                                                                  ref 567 573*
p_structure_name                       parameter       char                     unaligned dcl 585 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 580 587*
p_typed_vector_array_ptr               parameter       pointer                  dcl 137 set ref 125 383* 426* 456 727* 751 756 762
p_work_area_ptr                        parameter       pointer                  dcl 135 ref 125 241 245 247 251 253
partial_structural_field_id     000273 automatic       fixed bin(17,0)          dcl 714 set ref 719* 721* 723* 727* 732* 737* 741*
position                        000105 automatic       bit(1)                   initial dcl 148 set ref 148* 248* 436 486 497 737
position_number           5            based           fixed bin(17,0)          level 2 packed unaligned dcl 9-63 set ref 303 303*
                                                                                  408
range                     5            based           structure                level 2 packed unaligned dcl 9-38
root_id                   3            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-25 ref 328
                                                                                  676
search_specification                   based           structure                level 1 unaligned dcl 9-38
search_specification_ptr        000144 automatic       pointer                  dcl 9-58 set ref 264* 281* 288* 310 338* 348 355 462
                                                                                  471 478 486 727* 732* 737* 741*
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 2-17 ref 537
simple_typed_vector_ptr         000126 automatic       pointer                  dcl 2-33 in procedure "im_general_search$get" set
                                                                                  ref 718* 719 721 723
simple_typed_vector_ptr                based           pointer                  initial level 2 in structure "interval_bead"
                                                                                  dcl 14-46 in procedure "im_general_search$get" ref
                                                                                  537 537 718
size                      5(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 9-38 ref 471 486
specification_head                     based           structure                level 1 unaligned dcl 8-10
specification_head_ptr          000142 automatic       pointer                  dcl 8-18 set ref 264* 272* 273 276 278 281 285 288
                                                                                  292 295 299 302
sub_err_                        000036 constant        entry                    external dcl 220 ref 303 310 573 587
type                      1            based           fixed bin(17,0)          level 2 in structure "specification_head" packed
                                                                                  unaligned dcl 8-10 in procedure
                                                                                  "im_general_search$get" ref 278 285 292 299
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 9-38 in procedure
                                                                                  "im_general_search$get" set ref 310*
type                      5            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 9-38 in procedure
                                                                                  "im_general_search$get" ref 462 478
typed_vector_array                     based           structure                level 1 dcl 13-21
version                                based           char(8)                  level 2 in structure "index_header" dcl 3-25
                                                                                  in procedure "im_general_search$get" set ref 326*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 12-36
                                                                                  in procedure "im_general_search$get" set ref 332*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 15-26
                                                                                  in procedure "im_general_search$get" set ref 323*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 5-29 in procedure "im_general_search$get" ref
                                                                                  270
version                                based           fixed bin(35,0)          level 2 in structure "specification_head" dcl 8-10
                                                                                  in procedure "im_general_search$get" ref 276
version                                based           char(8)                  level 2 in structure "interval_specification"
                                                                                  dcl 14-35 in procedure "im_general_search$get" set
                                                                                  ref 345*
version                                based           char(8)                  level 2 in structure "interval_list" dcl 17-20
                                                                                  in procedure "im_general_search$get" set ref 374*
                                                                                  454*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 18-36
                                                                                  in procedure "im_general_search$get" set ref 392*
work_area                              based           area(1024)               dcl 163 ref 373 396 453 537 539 541 544 547 551
work_area_ptr                   000100 automatic       pointer                  initial dcl 147 set ref 147* 241* 247* 253* 260*
                                                                                  338* 373 383* 396 426* 431* 436* 441* 453 537 539
                                                                                  541 544 547 551 727* 732* 737* 741*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 8-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 8-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 19-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 19-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 19-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 19-7
ALL_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 11-8
BEGINNING_OF_ELEMENT                   internal static fixed bin(35,0)          initial dcl 185
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 4-56
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 10-13
EQUAL_OPERATOR_CODE                    internal static fixed bin(17,0)          initial dcl 10-13
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 2-43
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 10-13
GREATER_OPERATOR_CODE                  internal static fixed bin(17,0)          initial dcl 10-13
GREATER_OR_EQUAL_OPERATOR_CODE         internal static fixed bin(17,0)          initial dcl 10-13
HEADER_COLLECTION_ID                   internal static bit(36)                  initial dcl 187
ID_LIST_VERSION_1                      internal static fixed bin(17,0)          initial dcl 16-23
INDEX_CURSOR_TYPE                      internal static fixed bin(17,0)          initial dcl 5-67
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 18-45
LESS_OPERATOR_CODE                     internal static fixed bin(17,0)          initial dcl 10-13
LESS_OR_EQUAL_OPERATOR_CODE            internal static fixed bin(17,0)          initial dcl 10-13
NOT_EQUAL_OPERATOR_CODE                internal static fixed bin(17,0)          initial dcl 10-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 10-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 8-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 2-43
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 10-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 10-13
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 8-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 8-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 8-22
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 2-43
TYPED_VECTOR_ARRAY_VERSION_2           internal static fixed bin(35,0)          initial dcl 13-50
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array unaligned dcl 10-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array unaligned dcl 10-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array unaligned dcl 10-31
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 7-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 7-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 7-54
collection_manager_$create_file 000000 constant        entry                    external dcl 7-56
collection_manager_$delete      000000 constant        entry                    external dcl 7-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 7-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 7-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 7-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 7-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-77
collection_manager_$get_header  000000 constant        entry                    external dcl 7-83
collection_manager_$get_id      000000 constant        entry                    external dcl 7-86
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 7-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 7-93
collection_manager_$modify      000000 constant        entry                    external dcl 7-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 7-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 7-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 7-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 7-113
collection_manager_$put         000000 constant        entry                    external dcl 7-115
collection_manager_$put_header  000000 constant        entry                    external dcl 7-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 7-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 7-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 7-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 7-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-135
element_id_string                      automatic       bit(36)                  dcl 6-30
field_name                             based           char                     unaligned dcl 12-71
field_name_length                      automatic       fixed bin(17,0)          dcl 12-73
field_name_ptr                         automatic       pointer                  dcl 12-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 12-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 12-68
general_typed_vector                   based           structure                level 1 packed unaligned dcl 2-24
general_typed_vector_ptr               automatic       pointer                  dcl 2-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-40
key_string                             based           bit                      unaligned dcl 1-22
key_string_length                      automatic       fixed bin(35,0)          dcl 1-23
key_string_ptr                         automatic       pointer                  dcl 1-24
leaf_key                               based           structure                level 1 packed unaligned dcl 1-26
leaf_key_ptr                           automatic       pointer                  dcl 1-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 1-29
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 9-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 9-60
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 13-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 13-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 13-44
typed_vector_array_ptr                 automatic       pointer                  dcl 13-43

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   002457 constant        entry                    internal dcl 567 ref 270 276
CHECK_VERSION_CHAR              002553 constant        entry                    internal dcl 580 ref 323 326 332 345 392
ERROR_RETURN                    002436 constant        entry                    internal dcl 557 ref 320 328 339 363 366 385 446 511
                                                                                  610 613 615 641 646 652 665 689 745
FIND_KEY_ID                     003007 constant        entry                    internal dcl 621 ref 348 411 417 423 466 482 724
FINISH                          002303 constant        entry                    internal dcl 524 ref 317 519 562
FORWARD_INTERVAL_LOOP           002177 constant        label                    dcl 497
GET_CI_HEADER                   002655 constant        entry                    internal dcl 593 ref 650 668 677 695
GET_CURSOR_POSITION             003065 constant        label                    dcl 637
GET_KEYS                        003474 constant        entry                    internal dcl 711 ref 473 489 500
GOTO_NEXT_CONTROL_INTERVAL      003204 constant        label                    dcl 660
JOIN                            000471 constant        label                    dcl 264 ref 243 249 256
MAIN_RETURN                     002301 constant        label                    dcl 521 ref 563
POSITION_TO_SLOT_AFTER_CURRENT  003171 constant        label                    dcl 657
PROCESS_ALL_KEYS                001474 constant        label                    dcl 401
count                           000443 constant        entry                    external dcl 258
delete                          000411 constant        entry                    external dcl 251
im_general_search$get           000331 constant        entry                    external dcl 125
position                        000361 constant        entry                    external dcl 245

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         ref 607 607

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4460        4542    4076        4470
Length      5410    4076        62         632     362           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_general_search$get               504 external procedure  is an external procedure.  
on unit on line 317                  64 on unit               
FINISH                               66 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_general_search$get.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_general_search$get.  
GET_CI_HEADER                           internal procedure  shares stack frame of internal procedure FIND_KEY_ID.  
FIND_KEY_ID                         172 internal procedure  uses auto adjustable storage.  
GET_KEYS                                internal procedure  shares stack frame of external procedure im_general_search$get.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
FIND_KEY_ID              000106 gch_code                    GET_CI_HEADER
                         000107 gch_element_id              GET_CI_HEADER
                         000110 fki_branch_key_head_buffer  FIND_KEY_ID
                         000110 fki_code                    FIND_KEY_ID
                         000111 fki_element_id              FIND_KEY_ID
                         000112 fki_local_header_buffer     FIND_KEY_ID
                         000112 bk_string_length            FIND_KEY_ID
                         000114 branch_key_ptr              FIND_KEY_ID
FINISH                   000100 next_ptr                    FINISH
im_general_search$get    000100 work_area_ptr               im_general_search$get
                         000102 get                         im_general_search$get
                         000103 delete                      im_general_search$get
                         000104 count                       im_general_search$get
                         000105 position                    im_general_search$get
                         000106 is_relative_specification   im_general_search$get
                         000107 is_search_specification     im_general_search$get
                         000110 number_of_keys_accepted     im_general_search$get
                         000111 number_of_structural_fields im_general_search$get
                         000112 high_element_id_string      im_general_search$get
                         000113 low_element_id_string       im_general_search$get
                         000114 new_buffer_was_allocated    im_general_search$get
                         000115 no_match                    im_general_search$get
                         000116 interval_idx                im_general_search$get
                         000126 simple_typed_vector_ptr     im_general_search$get
                         000130 index_header_ptr            im_general_search$get
                         000132 common_ci_header_ptr        im_general_search$get
                         000134 leaf_ci_header_ptr          im_general_search$get
                         000136 branch_ci_header_ptr        im_general_search$get
                         000140 index_cursor_ptr            im_general_search$get
                         000142 specification_head_ptr      im_general_search$get
                         000144 search_specification_ptr    im_general_search$get
                         000146 numeric_specification_ptr   im_general_search$get
                         000150 field_table_ptr             im_general_search$get
                         000152 interval_specification_ptr  im_general_search$get
                         000154 interval_bead_ptr           im_general_search$get
                         000156 index_opening_info_ptr      im_general_search$get
                         000160 id_list_ptr                 im_general_search$get
                         000162 il_number_of_ids            im_general_search$get
                         000164 interval_list_ptr           im_general_search$get
                         000166 intl_number_of_intervals    im_general_search$get
                         000170 key_count_array_ptr         im_general_search$get
                         000172 kca_number_of_counts        im_general_search$get
                         000272 gk_code                     GET_KEYS
                         000273 partial_structural_field_id GET_KEYS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other
return_mac          tra_ext_1           alloc_auto_adj      enable_op           ext_entry           int_entry
int_entry_desc      op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       collection_manager_$get_portion
data_format_util_$cv_table_to_typed_array                   get_dm_free_area_             im_build_interval_spec
im_get_opening_info           im_process_keys$count         im_process_keys$delete        im_process_keys$get
im_process_keys$position      im_structural_search          im_update_opening_info$key_count_array
im_validate_cursor            sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_first_key_idx   dm_error_$bad_last_key_idx    dm_error_$bad_specification_type
dm_error_$invalid_cursor_position                           dm_error_$key_not_found       dm_error_$programming_error
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    147 000270       148 000272       150 000300       152 000301       154 000302       156 000304   14   62 000306
14   64 000307   15   46 000310   16   21 000311   16   22 000312   17   33 000314   17   36 000316   18   48 000317
18   49 000320       125 000323       241 000346       242 000351       243 000353       245 000354       247 000376
    248 000401       249 000403       251 000404       253 000426       254 000431       255 000433       256 000435
    258 000436       260 000456       261 000465       262 000467       264 000471       267 000477       268 000500
    270 000503       272 000520       273 000524       276 000530       278 000545       281 000553       282 000554
    283 000556       284 000557       285 000560       288 000562       289 000563       290 000564       291 000566
    292 000567       295 000571       296 000572       297 000574       298 000575       299 000576       302 000600
    303 000601       307 000660       308 000661       309 000662       310 000663       317 000750       319 000772
    320 001010       323 001020       325 001042       326 001045       328 001071       331 001104       332 001107
    334 001132       338 001134       339 001151       342 001161       345 001165       348 001212       355 001235
    361 001246       363 001267       366 001277       369 001311       372 001313       373 001317       374 001331
    375 001334       379 001354       383 001356       385 001401       389 001411       392 001413       394 001441
    396 001446       398 001457       401 001470       405 001474       408 001502       411 001506       412 001522
    413 001523       416 001524       417 001525       419 001541       422 001542       423 001543       426 001557
    431 001620       436 001661       441 001720       446 001754       449 001764       452 001766       453 001770
    454 002002       455 002005       456 002007       458 002014       461 002016       462 002017       465 002025
    466 002030       470 002055       471 002060       473 002075       475 002076       476 002101       477 002104
    478 002105       481 002107       482 002112       485 002130       486 002133       489 002165       491 002166
    492 002171       493 002173       496 002174       497 002177       500 002223       502 002224       503 002227
    505 002231       507 002237       510 002241       511 002254       514 002264       515 002267       516 002270
    519 002275       521 002301       524 002302       528 002310       531 002317       534 002323       535 002326
    536 002333       537 002336       539 002354       541 002367       542 002372       543 002375       544 002376
    547 002400       551 002421       554 002434       557 002435       561 002443       562 002447       563 002454
    567 002457       573 002470       578 002552       580 002553       587 002564       591 002654       593 002655
    603 002657       604 002662       605 002664       607 002665       610 002740       613 002751       615 002771
    618 003005       621 003006       627 003022       632 003031       635 003043       636 003044       637 003052
    641 003065       645 003101       646 003113       649 003124       650 003130       652 003143       654 003161
    660 003171       664 003204       665 003210       668 003223       669 003237       670 003244       671 003245
    673 003250       674 003256       676 003257       677 003262       679 003275       680 003276       682 003302
    685 003306       686 003311       689 003367       692 003400       693 003404       694 003405       695 003410
    696 003424       698 003425       701 003442       702 003447       704 003461       706 003466       707 003473
    711 003474       716 003475       718 003505       719 003507       721 003516       723 003533       724 003535
    727 003556       732 003623       737 003667       741 003731       745 003770       748 004000       751 004002
    755 004014       756 004023       758 004026       759 004031       762 004034       764 004040


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
