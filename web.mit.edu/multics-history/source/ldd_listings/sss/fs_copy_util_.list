	COMPILATION LISTING OF SEGMENT fs_copy_util_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/29/86  1353.4 mst Wed
	    Options: optimize map single_symbol_list

        1 /****^  **************************************************************
        2*        *                                                            *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983    *
        4*        *                                                            *
        5*        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        6*        *                                                            *
        7*        ************************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-10-29,MSharpe), approve(86-01-24,MCR7296),
       13*     audit(86-01-24,CLJones), install(86-01-29,MR12.0-1009):
       14*     History comments before hcom:
       15*      fs_util_$copy for segments and MSF's
       16*     - BIM 831022
       17*     - MAP 840206 to properly close SSF when copying SSF -> MSF -update
       18*     - MSharpe 850212 to force_access in case of "-fc (-update -extend)";
       19*      to return et_$inconsistent_msf instead of et_$noentry if msf>0 is
       20*      not found; to delete the forced acl entry if none existed before and
       21*      replace the forced acl with the original mode otherwise; to compare
       22*      the max length of target with bit_count/36 instead of bit_count/4.
       23*     - MSharpe 850307 to check the contents of target past the bitcount
       24*      up to the last bit of current length whenever there is a discrepency.
       25*      If there are only zeroes, we copy; otherwise, give "bit count is
       26*      inconsistent with current length" error message.
       27*     
       28*     and the reason for the first use of history_comment is...
       29*     
       30*     Fixed bug that caused components of msfs to be terminated twice.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 /* format: style2,indcomtxt,idind30 */
       35 
       36 fs_copy_util_:
       37      procedure;
       38 
       39 	declare P_copy_options_ptr	        ptr parameter;
       40 	declare P_status		        fixed bin (35) parameter;
       41 
       42 	declare attach_desc		        char (200);
       43 	declare (bit_count, bc2)	        fixed bin (24);
       44 	declare char_count		        fixed bin (21);
       45 	declare code		        fixed bin (35);
       46 	declare component_ptr	        ptr;
       47 	declare curlen		        fixed bin;
       48 	declare dir		        char (168);
       49 	declare ename		        char (32);
       50 	declare (forced_access, delete_forced_acle)
       51 				        bit (1) aligned;
       52 	declare (fcb_ptr, new_fcb_ptr)        ptr;
       53 	declare increment		        fixed bin;
       54 	declare iocb_name		        char (32);
       55 	declare iocb_ptr		        ptr;
       56 	declare max_length		        fixed bin (19);
       57 	declare modes		        bit (36) aligned;
       58 	declare (msf, target_msf)	        bit (1) aligned;
       59 	declare (new_seg_ptr, old_seg_ptr)    ptr;
       60 	declare saved_mode		        bit (36) aligned;
       61 	declare source_dir		        char (168);
       62 	declare source_name		        char (32);
       63 	declare source_type		        char (32);
       64 	declare target_dir		        char (168);
       65 	declare target_name		        char (32);
       66 	declare type		        fixed bin;
       67 	declare word_count		        fixed bin (19);
       68 
       69 	declare 1 sb		        aligned like status_branch;
       70 	declare 1 sb2		        aligned like status_branch;
       71 	declare 1 cei		        aligned like copy_error_info;
       72 	declare 1 oi		        aligned like object_info;
       73 	declare 1 one_acl		        aligned,
       74 		2 version		        char (8) aligned,
       75 		2 count		        fixed bin,
       76 		2 entries		        (1) aligned like general_acl_entry;
       77 	declare 1 one_del_acl	        aligned,
       78 		2 version		        char (8) aligned,
       79 		2 count		        fixed bin,
       80 		2 entries		        (1) aligned like general_acl_entry;
       81 	declare 1 info		        aligned like indx_info;
       82 
       83 
       84 
       85 	declare (addbitno, addr, clock, divide, fixed, index, min, null, rtrim)
       86 				        builtin,
       87 	        (cleanup, no_write_permission)
       88 				        condition;
       89 
       90 	declare (
       91 	        error_table_$inconsistent_msf,
       92 	        error_table_$lower_ring,
       93 	        error_table_$moderr,
       94 	        error_table_$namedup,
       95 	        error_table_$noentry,
       96 	        error_table_$no_e_permission,
       97 	        error_table_$no_s_permission,
       98 	        error_table_$unimplemented_version,
       99 	        error_table_$user_not_found
      100 	        )			        fixed bin (35) external;
      101 
      102 	declare add_acl_entries_entry	        entry (char (*), char (*), pointer, fixed bin (35)) variable;
      103 	declare delete_acl_entries_entry      entry (char (*), char (*), pointer, fixed bin (35)) variable;
      104 	declare get_group_id_	        entry returns (char (32));
      105 	declare get_ring_		        entry returns (fixed bin (3));
      106 	declare fs_util_$make_entry_for_type  entry (char (*), char (*), entry, fixed bin (35));
      107 	declare hcs_$fs_get_path_name	        entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      108 	declare hcs_$status_long	        entry (char (*), char (*), fixed bin, ptr, ptr, fixed bin (35));
      109 	declare hcs_$status_minf	        entry (char (*), char (*), fixed bin, fixed bin, fixed bin (24),
      110 				        fixed bin (35));
      111 	declare hcs_$get_max_length_seg       entry (ptr, fixed bin (19), fixed bin (35));
      112 	declare hcs_$get_max_length	        entry (char (*), char (*), fixed bin (19), fixed bin (35));
      113 	declare hcs_$set_bc		        entry (char (*), char (*), fixed bin (24), fixed bin (35));
      114 	declare hcs_$set_bc_seg	        entry (ptr, fixed bin (24), fixed bin (35));
      115 	declare initiate_file_	        entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      116 	declare initiate_file_$create	        entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24),
      117 				        fixed bin (35));
      118 	declare hcs_$terminate_noname	        entry (ptr, fixed bin (35));
      119 	declare hcs_$truncate_seg	        entry (ptr, fixed bin (19), fixed bin (35));
      120 	declare msf_manager_$adjust	        entry (ptr, fixed bin, fixed bin (24), bit (3), fixed bin (35));
      121 	declare msf_manager_$close	        entry (ptr);
      122 	declare msf_manager_$msf_get_ptr      entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      123 	declare msf_manager_$get_ptr	        entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      124 	declare msf_manager_$open	        entry (char (*), char (*), ptr, fixed bin (35));
      125 	declare object_info_$brief	        entry (ptr, fixed bin (24), ptr, fixed bin (35));
      126 	declare pathname_		        entry (char (*), char (*)) returns (char (168));
      127 	declare request_id_		        entry (fixed bin (71)) returns (char (19));
      128 	declare requote_string_	        entry (char (*)) returns (char (*));
      129 	declare sub_err_		        entry options (variable);
      130 	declare vfile_status_	        entry (char (*), char (*), ptr, fixed bin (35));
      131 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      132 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
      133 
  3     1 /* Begin include file file_system_operations.incl.pl1 BIM 8309 */
  3     2 /* format: style3,indcomtxt,idind30 */
  3     3 
  3     4 /**** Operation names to be passed to fs_util_$make_entry */
  3     5 
  3     6 declare   (
  3     7           FS_ADD_ACL_ENTRIES            init ("add_acl_entries"),
  3     8           FS_ADD_EXTENDED_ACL_ENTRIES   init ("add_extended_acl_entries"),
  3     9           FS_CHNAME_FILE                init ("chname_file"),
  3    10           FS_COPY                       init ("copy"),
  3    11           FS_DELENTRY_FILE              init ("delentry_file"),
  3    12           FS_DELETE_ACL_ENTRIES         init ("delete_acl_entries"),
  3    13           FS_GET_BIT_COUNT              init ("get_bit_count"),
  3    14           FS_GET_MAX_LENGTH             init ("get_max_length"),
  3    15           FS_GET_RING_BRACKETS          init ("get_ring_brackets"),
  3    16           FS_GET_SWITCH                 init ("get_switch"),
  3    17           FS_GET_USER_ACCESS_MODES      init ("get_user_access_modes"),
  3    18           FS_LIST_ACL                   init ("list_acl"),
  3    19           FS_LIST_EXTENDED_ACL          init ("list_extended_acl"),
  3    20           FS_LIST_SWITCHES              init ("list_switches"),
  3    21           FS_REPLACE_ACL                init ("replace_acl"),
  3    22           FS_REPLACE_EXTENDED_ACL       init ("replace_extended_acl"),
  3    23           FS_SET_BIT_COUNT              init ("set_bit_count"),
  3    24           FS_SET_MAX_LENGTH             init ("set_max_length"),
  3    25           FS_SET_RING_BRACKETS          init ("set_ring_brackets"),
  3    26           FS_SET_SWITCH                 init ("set_switch"),
  3    27           FS_SUFFIX_INFO                init ("suffix_info"),
  3    28           FS_VALIDATE                   init ("validate")
  3    29           )                             char (64) int static options (constant);
  3    30 
  3    31 /* End include file file_system_operations.incl.pl1 */
      134 
  4     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  4     2 /* format: style3,indcomtxt,idind30 */
  4     3 /**** Jay Pattin 2/13/83
  4     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  4     5*
  4     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  4     7*
  4     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  4     9 
  4    10 declare   suffix_info_ptr               ptr;
  4    11 
  4    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  4    13             2 version                   char (8),
  4    14             2 type                      char (32) unaligned,
  4    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  4    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  4    17             2 flags                     unaligned,
  4    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  4    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  4    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  4    21               3 mbz1                    bit (33) unaligned,
  4    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  4    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  4    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  4    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  4    26             2 info_pathname             char (168) unaligned;
  4    27                                                             /* pathname of info segment containing more info */
  4    28 
  4    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  4    30 
  4    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  4    32 
  4    33 declare   switch_list_ptr               ptr,
  4    34           alloc_switch_count            fixed bin,
  4    35           alloc_switch_name_count       fixed bin;
  4    36 
  4    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  4    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  4    39             2 switch_count              fixed bin,          /* total number of switches */
  4    40             2 switch_name_count         fixed bin,          /* total number of names */
  4    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  4    42               3 name_index              fixed bin,          /* index of first name for this switch */
  4    43               3 name_count              fixed bin,          /* number of names for this switch */
  4    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  4    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  4    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  4    47 
  4    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  4    49 
  4    50 declare   (
  4    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  4    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  4    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  4    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  4    55           FS_OBJECT_TYPE_LINK           init ("-link")
  4    56           )                             char (32) unaligned int static options (constant);
  4    57 
  4    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      135 
      136 
      137 
      138 /* format: off */
      139 
      140  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  5     2 
  5     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  5     4 
  5     5 /* This include file contains branch and link structures returned by
  5     6*   hcs_$status_ and hcs_$status_long. */
  5     7 
  5     8 dcl 1 status_branch aligned based (status_ptr),
  5     9     2 short aligned,
  5    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  5    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  5    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  5    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  5    14       3 dtu bit (36) unaligned,			/* date/time last used */
  5    15       3 mode bit (5) unaligned,			/* caller's effective access */
  5    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  5    17       3 pad1 bit (8) unaligned,
  5    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  5    19 
  5    20 /* Limit of information returned by hcs_$status_ */
  5    21 
  5    22     2 long aligned,
  5    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  5    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  5    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  5    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  5    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  5    28       3 pad2 bit (8) unaligned,
  5    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  5    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  5    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  5    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  5    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  5    34       3 pad3 bit (5) unaligned,
  5    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  5    36       3 uid bit (36) unaligned;			/* unique ID */
  5    37 
  5    38 dcl 1 status_link aligned based (status_ptr),
  5    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  5    40     2 nnames fixed bin (16) unaligned unsigned,
  5    41     2 names_relp bit (18) unaligned,
  5    42     2 dtem bit (36) unaligned,
  5    43     2 dtd bit (36) unaligned,
  5    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  5    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  5    46 
  5    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  5    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  5    49 						/* array of names returned */
  5    50      status_pathname character (status_link.pathname_length) aligned
  5    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  5    52 						/* link target path */
  5    53      status_area_ptr pointer,
  5    54      status_ptr pointer;
  5    55 
  5    56 dcl (Link initial (0),
  5    57      Segment initial (1),
  5    58      Directory initial (2)) fixed bin internal static options (constant);
  5    59 						/* values for type fields declared above */
  5    60 
  5    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      140 
      141  /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  6     2 
  6     3 /* This structure declares the input structure used by the copy_ subroutine.
  6     4*
  6     5*   NOTE: This include file depends on declarations in the include file
  6     6*   copy_flags.incl.pl1.
  6     7*
  6     8*   Jay Pattin 6/1/83 */
  6     9 
  6    10 declare   copy_options_ptr              ptr;
  6    11 
  6    12 declare   1 copy_options                aligned based (copy_options_ptr),
  6    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  6    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  6    15           2 source_dir                  char (168) unal,
  6    16           2 source_name                 char (32) unal,
  6    17           2 target_dir                  char (168) unal,
  6    18           2 target_name                 char (32) unal,
  6    19           2 flags,
  6    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  6    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  6    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  6    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  6    24             3 target_err_switch         bit (1) unaligned,
  6    25             3 mbz                       bit (31) unaligned,
  6    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  6    27 
  6    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  6    29 
  6    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      141 
      142  /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  7     2 
  7     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  7     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  7     5*
  7     6*   Jay Pattin 6/23/83 */
  7     7 
  7     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  7     9           2 names                       bit (1) unaligned,
  7    10           2 acl                         bit (1) unaligned,
  7    11           2 ring_brackets               bit (1) unaligned,
  7    12           2 max_length                  bit (1) unaligned,
  7    13           2 copy_switch                 bit (1) unaligned,
  7    14           2 safety_switch               bit (1) unaligned,
  7    15           2 dumper_switches             bit (1) unaligned,
  7    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  7    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  7    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  7    19           2 mbz                         bit (26) unaligned;
  7    20 
  7    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      142 
      143  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  8     2*
  8     3*   Values for the "access mode" argument so often used in hardcore
  8     4*   James R. Davis 26 Jan 81  MCR 4844
  8     5*   Added constants for SM access 4/28/82 Jay Pattin
  8     6*   Added text strings 03/19/85 Chris Jones
  8     7**/
  8     8 
  8     9 
  8    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8    11 dcl	(
  8    12 	N_ACCESS		   init ("000"b),
  8    13 	R_ACCESS		   init ("100"b),
  8    14 	E_ACCESS		   init ("010"b),
  8    15 	W_ACCESS		   init ("001"b),
  8    16 	RE_ACCESS		   init ("110"b),
  8    17 	REW_ACCESS	   init ("111"b),
  8    18 	RW_ACCESS		   init ("101"b),
  8    19 	S_ACCESS		   init ("100"b),
  8    20 	M_ACCESS		   init ("010"b),
  8    21 	A_ACCESS		   init ("001"b),
  8    22 	SA_ACCESS		   init ("101"b),
  8    23 	SM_ACCESS		   init ("110"b),
  8    24 	SMA_ACCESS	   init ("111"b)
  8    25 	)		   bit (3) internal static options (constant);
  8    26 
  8    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  8    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  8    29 
  8    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  8    31 			   static options (constant);
  8    32 
  8    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  8    34 			   static options (constant);
  8    35 
  8    36 dcl	(
  8    37 	N_ACCESS_BIN	   init (00000b),
  8    38 	R_ACCESS_BIN	   init (01000b),
  8    39 	E_ACCESS_BIN	   init (00100b),
  8    40 	W_ACCESS_BIN	   init (00010b),
  8    41 	RW_ACCESS_BIN	   init (01010b),
  8    42 	RE_ACCESS_BIN	   init (01100b),
  8    43 	REW_ACCESS_BIN	   init (01110b),
  8    44 	S_ACCESS_BIN	   init (01000b),
  8    45 	M_ACCESS_BIN	   init (00010b),
  8    46 	A_ACCESS_BIN	   init (00001b),
  8    47 	SA_ACCESS_BIN	   init (01001b),
  8    48 	SM_ACCESS_BIN	   init (01010b),
  8    49 	SMA_ACCESS_BIN	   init (01011b)
  8    50 	)		   fixed bin (5) internal static options (constant);
  8    51 
  8    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      143 
      144  /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
  9     2 /* format: style2 */
  9     3 
  9     4 /* The include file condition_info_header must be used with this file */
  9     5 
  9     6      declare sub_error_info_ptr     pointer;
  9     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
  9     8 	     2 header	      aligned like condition_info_header,
  9     9 	     2 retval	      fixed bin (35),	/* return value */
  9    10 	     2 name	      char (32),		/* module name */
  9    11 	     2 info_ptr	      ptr;
  9    12 
  9    13      declare sub_error_info_version_1
  9    14 			      internal static options (constant) fixed bin init (1);
  9    15 
  9    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
      144 
 10     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 10     2 /* format: style3 */
 10     3 
 10     4 /* These constants are to be used for the flags argument of sub_err_ */
 10     5 /* They are just "string (condition_info_header.action_flags)" */
 10     6 
 10     7 declare	(
 10     8 	ACTION_CAN_RESTART	init (""b),
 10     9 	ACTION_CANT_RESTART init ("1"b),
 10    10 	ACTION_DEFAULT_RESTART
 10    11 			init ("01"b),
 10    12 	ACTION_QUIET_RESTART
 10    13 			init ("001"b),
 10    14 	ACTION_SUPPORT_SIGNAL
 10    15 			init ("0001"b)
 10    16 	)		bit (36) aligned internal static options (constant);
 10    17 
 10    18 /* End include file */
      145 
      146  /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
 11     2 /* format: style2 */
 11     3 
 11     4      declare condition_info_header_ptr
 11     5 			      pointer;
 11     6      declare 1 condition_info_header
 11     7 			      aligned based (condition_info_header_ptr),
 11     8 	     2 length	      fixed bin,		/* length in words of this structure */
 11     9 	     2 version	      fixed bin,		/* version number of this structure */
 11    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
 11    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
 11    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
 11    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
 11    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
 11    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
 11    16 	       3 pad	      bit (32) unaligned,
 11    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
 11    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
 11    19 
 11    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      146 
 12     1 /* BEGIN INCLUDE FILE:  copy_error_info.incl.pl1
 12     2*
 12     3*   This is the structure pointed to by sub_error_info.info_ptr when copy_
 12     4*   signals the sub_err_ condition.
 12     5*
 12     6*   Jay Pattin 6/13/83 */
 12     7 
 12     8 declare   1 copy_error_info             aligned based (sub_error_info.info_ptr),
 12     9           2 copy_options_ptr            ptr,                /* Pointer to input argument of copy_ */
 12    10           2 operation                   char (32),          /* Name of operation that failed. */
 12    11           2 target_err_switch           bit (1) aligned;    /* ON = error was on the target */
 12    12 
 12    13 /* END INCLUDE FILE:  copy_error_info.incl.pl1 */
      147 
      148  /* BEGIN INCLUDE FILE ... object_info.incl.pl1
 13     2*coded February 8, 1972 by Michael J. Spier	*/
 13     3 /* modified May 26, 1972 by M. Weaver */
 13     4 /* modified 15 April, 1975 by M. Weaver */
 13     5 
 13     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
 13     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
 13     8 	2 textp pointer,			/* pointer to beginning of text section */
 13     9 	2 defp pointer,			/* pointer to beginning of definition section */
 13    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
 13    11 	2 statp pointer,			/* pointer to beginning of static section */
 13    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
 13    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
 13    14 	2 tlng fixed bin,			/* length in words of text section */
 13    15 	2 dlng fixed bin,			/* length in words of definition section */
 13    16 	2 llng fixed bin,			/* length in words of linkage section */
 13    17 	2 ilng fixed bin,			/* length in words of static section */
 13    18 	2 slng fixed bin,			/* length in words of symbol section */
 13    19 	2 blng fixed bin,			/* length in words of break map */
 13    20 	2 format,				/* word containing bit flags about object type */
 13    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
 13    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
 13    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
 13    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
 13    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
 13    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
 13    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
 13    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
 13    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
 13    30 	  3 pad bit(27) unaligned,
 13    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
 13    32 	2 textlinkp pointer,		/* ptr to first link in text */
 13    33 
 13    34 	/* LIMIT OF BRIEF STRUCTURE */
 13    35 
 13    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
 13    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
 13    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
 13    39 	2 cvers aligned,			/* generator version name in printable char string form */
 13    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
 13    41 	  3 length bit(18) unaligned,		/* length of name in characters */
 13    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
 13    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
 13    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
 13    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
 13    46 
 13    47 	/* LIMIT OF DISPLAY STRUCTURE */
 13    48 
 13    49 	2 rel_text pointer,			/* pointer to text section relocation info */
 13    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
 13    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
 13    52 	2 rel_static pointer,		/* pointer to static section relocation info */
 13    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
 13    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
 13    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
 13    56 					/* currently not used by system */
 13    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
 13    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
 13    59 
 13    60 declare	object_info_version_2 fixed bin int static init(2);
 13    61 
 13    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      148 
      149       dcl	   1 uns_info	      based (addr (info)),	/* info structure for unstructured files */
 14     2 	     2 info_version	      fixed,		/* (Input) must =1--only one version
 14     3*						   currently supported */
 14     4 	     2 type	      fixed,		/* =1 */
 14     5 	     2 end_pos	      fixed (34),		/* length (bytes) not including header */
 14     6 	     2 flags	      aligned,
 14     7 	       3 pad1	      bit (2) unal,		/* used for lock_status in other files */
 14     8 	       3 header_present   bit (1) unal,		/* on if file code is set */
 14     9 	       3 pad2	      bit (33) unal,
 14    10 	     2 header_id	      fixed (35);		/* meaning is user defined */
 14    11      dcl	   1 seq_info	      based (addr (info)),	/* info structure for sequential files */
 14    12 	     2 info_version	      fixed,
 14    13 	     2 type	      fixed,		/* =2 */
 14    14 	     2 end_pos	      fixed (34),		/* record count */
 14    15 	     2 flags	      aligned,
 14    16 	       3 lock_status      bit (2) unal,		/* 0,1,2, or 3 to indicate not locked,
 14    17*						   locked by (other,this,dead) process */
 14    18 	       3 pad	      bit (34) unal,
 14    19 	     2 version	      fixed,		/* end_pos valid only in latest version */
 14    20 	     2 action	      fixed;		/* indicates if adjustment or rollback is needed */
 14    21      dcl	   1 blk_info	      based (addr (info)),	/* info structure for blocked files */
 14    22 	     2 info_version	      fixed,
 14    23 	     2 type	      fixed,		/* =3 */
 14    24 	     2 end_pos	      fixed (34),		/* record count */
 14    25 	     2 flags	      aligned,
 14    26 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
 14    27 	       3 pad	      bit (34) unal,
 14    28 	     2 version	      fixed,		/* only one currently supported */
 14    29 	     2 action	      fixed,		/* non-zero if truncation in progress, else =0 */
 14    30 	     2 max_rec_len	      fixed (21),		/* bytes--determines characteristiWc block size */
 14    31 	     2 pad	      fixed,		/* not used at this time */
 14    32 	     2 time_last_modified fixed (71);		/* time stamp for synchronization */
 14    33      dcl	   1 indx_info	      based (addr (info)),	/* info structure for indexed files */
 14    34 	     2 info_version	      fixed,
 14    35 	     2 type	      fixed,		/* =4 */
 14    36 	     2 records	      fixed (34),		/* record count */
 14    37 	     2 flags	      aligned,
 14    38 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
 14    39 	       3 pad	      bit (34) unal,
 14    40 	     2 version_info	      aligned,
 14    41 	       3 file_version     fixed (17) unal,	/* headers differ */
 14    42 	       3 program_version  fixed (17) unal,	/* may indicate bugs */
 14    43 	     2 action	      fixed,		/* non-zero code indicates update in progress */
 14    44 	     2 non_null_recs      fixed (34),		/* count of allocated recs */
 14    45 	     2 record_bytes	      fixed (34),		/* total record length */
 14    46 	     2 free_blocks	      fixed,		/* available record blocks */
 14    47 	     2 index_height	      fixed,		/* height of index tree (0 if empty) */
 14    48 	     2 nodes	      fixed,		/* nodes being used in the index */
 14    49 	     2 key_bytes	      fixed (34),		/* total length of keys */
 14    50 	     2 change_count	      fixed (35),		/* bumped on each file modification */
 14    51 	     2 num_keys	      fixed (34),		/* number of index entries */
 14    52 	     2 dup_keys	      fixed (34),		/* 0 if all keys are distinct, else 1 for each dup */
 14    53 	     2 dup_key_bytes      fixed (34),		/* total bytes of duplicate keys */
 14    54 	     2 word	      (1) fixed;		/* reserved for future use */
 14    55      dcl	   1 vbl_info	      based (addr (info)),	/* info structure for variable files */
 14    56 	     2 info_version	      fixed,
 14    57 	     2 type	      fixed,		/* =5 */
 14    58 	     2 end_pos	      fixed (34),		/* logical end of file--not necessarily allocation count */
 14    59 	     2 flags	      aligned,
 14    60 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
 14    61 	       3 pad	      bit (34) unal,
 14    62 	     2 version	      fixed,		/* only one currently supported */
 14    63 	     2 action	      fixed,		/* same as in indexed files */
 14    64 	     2 first_nz	      fixed (34),		/* position (numeric key) for first allocated record */
 14    65 	     2 last_nz	      fixed (34),		/* last allocated record position */
 14    66 	     2 change_count	      fixed (35);		/* used for synchronization */
 14    67      dcl	   vfs_version_1	      static internal fixed init (1);
 14    68 						/* should be used in
 14    69*						   assignments to info_version */
      149 
      150  /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
 15     2 /* format: style3,indcomtxt,idind30 */
 15     3 
 15     4 declare   acl_ptr                       pointer;
 15     5 declare   acl_count                     fixed bin;
 15     6 
 15     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
 15     8           2 version                     char (8) aligned,
 15     9           2 count                       fixed bin,
 15    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
 15    11 
 15    12 declare 1 general_acl_entry             based,
 15    13           2 access_name                 character (32) unaligned,
 15    14           2 mode                        bit (36) aligned,
 15    15           2 status_code                 fixed bin (35);
 15    16 
 15    17 
 15    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
 15    19           2 version                     char (8) aligned,
 15    20           2 count                       fixed bin,
 15    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
 15    22 
 15    23 declare 1 general_extended_acl_entry    aligned based,
 15    24           2 access_name                 character (32) unaligned,
 15    25           2 mode                        bit (36) aligned,
 15    26           2 extended_mode               bit (36) aligned,
 15    27           2 status_code                 fixed bin (35);
 15    28 
 15    29 
 15    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
 15    31           2 version                     char (8) aligned,
 15    32           2 count                       fixed bin,
 15    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
 15    34 
 15    35 declare 1 general_delete_acl_entry      aligned based,
 15    36           2 access_name                 character (32) unaligned,
 15    37           2 status_code                 fixed bin (35);
 15    38 
 15    39 
 15    40 declare 1 segment_acl                   aligned based (acl_ptr),
 15    41           2 version                     fixed bin,
 15    42           2 count                       fixed bin,
 15    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
 15    44 
 15    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
 15    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
 15    47 
 15    48 
 15    49 declare 1 directory_acl                 aligned based (acl_ptr),
 15    50           2 version                     fixed bin,
 15    51           2 count                       fixed bin,
 15    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
 15    53 
 15    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
 15    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
 15    56 
 15    57 
 15    58 declare 1 delete_acl                    based (acl_ptr) aligned,
 15    59           2 version                     fixed bin,
 15    60           2 count                       fixed bin,
 15    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
 15    62 
 15    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
 15    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
 15    65 
 15    66 
 15    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
 15    68           DIR_ACL_VERSION_1             init ("dra1"),
 15    69           DELETE_ACL_VERSION_1          init ("dla1"))
 15    70                                         char (4) int static options (constant);
 15    71 
 15    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
 15    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
 15    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
 15    75                                         char (8) internal static options (constant);
 15    76 
 15    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
 15    78 
 15    79 /* End include file acl_structures.incl.pl1 */
      150 
      151 /* format: on */
      152 
      153 
      154 segment:
      155      entry (P_copy_options_ptr, P_status);
      156 
      157 	source_type = FS_OBJECT_TYPE_SEGMENT;
      158 	msf = "0"b;
      159 	go to Entry_Common;
      160 
      161 msf:
      162      entry (P_copy_options_ptr, P_status);
      163 	source_type = FS_OBJECT_TYPE_MSF;
      164 	msf = "1"b;
      165 
      166 Entry_Common:
      167 	copy_options_ptr = P_copy_options_ptr;
      168 	if copy_options.version ^= COPY_OPTIONS_VERSION_1
      169 	then call copy_error (error_table_$unimplemented_version, "0"b);
      170 
      171 	if copy_options.extend & copy_options.update
      172 	then call fatal (0, "contents", "0"b, "The extend and update switches may not both be specified.");
      173 
      174 	source_dir = copy_options.source_dir;
      175 	source_name = copy_options.source_name;
      176 	target_dir = copy_options.target_dir;
      177 	target_name = copy_options.target_name;
      178 
      179 
      180 	fcb_ptr, new_fcb_ptr, new_seg_ptr, old_seg_ptr = null ();
      181 	forced_access = "0"b;
      182 
      183 	on cleanup call cleanup_copy ();
      184 	on no_write_permission call copy_error (error_table_$moderr, "1"b);
      185 
      186 	call hcs_$status_long (source_dir, source_name, 1, addr (sb), null (), code);
      187 	if code ^= 0
      188 	then if code ^= error_table_$no_s_permission
      189 	     then call copy_error (code, "0"b);
      190 
      191 	if msf
      192 	then do;
      193 		increment = 0;
      194 		call msf_manager_$open (source_dir, source_name, fcb_ptr, code);
      195 		if code ^= 0
      196 		then call copy_error (code, "0"b);
      197 	     end;
      198 
      199 	if sb.ring_brackets (1) < get_ring_ ()
      200 	then call copy_error (error_table_$lower_ring, "0"b);
      201 	if sb.mode & R_ACCESS = ""b
      202 	then call copy_error (error_table_$moderr, "0"b);
      203 
      204 	if ^msf & ^copy_options.extend
      205 	then do;
      206 		if sb.bit_count = 0
      207 		then bc2 = 0;
      208 		else bc2 = divide (sb.bit_count - 1, (36 * 1024), 12, 0) + 1;
      209 		if bc2 ^= sb.current_length
      210 		then call warning (0, "contents", "0"b, "Bit count is inconsistent with current length for ^a.");
      211 	     end;
      212 
      213 /* caller is responsible for namedup */
      214 	call hcs_$status_minf (target_dir, target_name, 1, type, bit_count, code);
      215 	if copy_options.extend | copy_options.update
      216 	then if code ^= 0
      217 	     then call copy_error (code, "1"b);
      218 	     else target_msf = (type = Directory & bit_count > 0);
      219 	else if code ^= error_table_$noentry
      220 	then call copy_error (error_table_$namedup, "1"b);
      221 	else target_msf = "0"b;
      222 
      223 /* initiate old segment */
      224 	if msf
      225 	then do;
      226 		call msf_manager_$get_ptr (fcb_ptr, 0, "0"b, old_seg_ptr, bit_count, code);
      227 		if code ^= 0
      228 		then code = error_table_$inconsistent_msf;
      229 	     end;
      230 	else do;
      231 		call initiate_file_ (source_dir, source_name, R_ACCESS, old_seg_ptr, (0), code);
      232 		bit_count = sb.bit_count;
      233 	     end;
      234 	if code ^= 0
      235 	then call copy_error (code, "0"b);
      236 
      237 	if copy_options.extend
      238 	then call extend;
      239 	else if ^msf & ^target_msf
      240 	then do;
      241 		call initiate_file_$create (target_dir, target_name, REW_ACCESS, new_seg_ptr, ("0"b), (0), code);
      242 						/* The only problem would be access */
      243 		if copy_options.update
      244 		then do;				/* truncate old contents */
      245 			if copy_options.force & code ^= 0
      246 			then call ensure_access ();	/* force access */
      247 						/* does not affect code */
      248 
      249 			if code ^= 0		/* the last call to initiate_file_ was not successful */
      250 			then call initiate_file_ (target_dir, target_name, RW_ACCESS, new_seg_ptr, (0), code);
      251 
      252 			if code = 0
      253 			then call hcs_$truncate_seg (new_seg_ptr, 0, code);
      254 			if code ^= 0
      255 			then call copy_error (code, "1"b);
      256 		     end;
      257 
      258 		else if code = error_table_$no_e_permission
      259 		then do;
      260 			call initiate_file_ (target_dir, target_name, RW_ACCESS, new_seg_ptr, (0), code);
      261 			if code ^= 0
      262 			then call copy_error (code, "1"b);
      263 		     end;
      264 
      265 		if new_seg_ptr = null
      266 		then call copy_error (code, "1"b);
      267 
      268 		curlen = sb.current_length;
      269 		word_count = curlen * 1024;
      270 
      271 		call copy_a_segment ();
      272 
      273 		call hcs_$terminate_noname (old_seg_ptr, (0));
      274 		call hcs_$terminate_noname (new_seg_ptr, (0));
      275 	     end;
      276 
      277 	else do;					/* Create target */
      278 		call msf_manager_$open (target_dir, target_name, new_fcb_ptr, code);
      279 		if new_fcb_ptr = null ()
      280 		then call copy_error (code, "1"b);
      281 
      282 		if copy_options.update
      283 		then do;				/* truncate the target */
      284 			if copy_options.force
      285 			then call ensure_access ();
      286 			call msf_manager_$adjust (new_fcb_ptr, 0, 0, "010"b, code);
      287 			if code ^= 0
      288 			then call copy_error (code, "1"b);
      289 		     end;
      290 
      291 		call msf_manager_$msf_get_ptr (new_fcb_ptr, 0, "1"b, new_seg_ptr, 0, code);
      292 
      293 		if code ^= 0
      294 		then call copy_error (code, "1"b);
      295 
      296 		do while ("1"b);
      297 		     call hcs_$fs_get_path_name (old_seg_ptr, dir, 0, ename, (0));
      298 		     call hcs_$status_long (dir, ename, 1, addr (sb), null (), code);
      299 		     if code ^= 0
      300 		     then call copy_error (code, "0"b);
      301 
      302 		     curlen = fixed (sb.current_length, 12);
      303 		     call hcs_$get_max_length (dir, ename, max_length, code);
      304 		     if code ^= 0
      305 		     then call copy_error (code, "0"b);
      306 
      307 		     word_count = min (curlen * 1024, max_length);
      308 		     call copy_a_segment ();
      309 
      310 		     if ^msf
      311 		     then goto SSF_UD_FINISH;		/* -update from ssf to msf */
      312 		     increment = increment + 1;
      313 
      314 		     call msf_manager_$get_ptr (fcb_ptr, increment, "0"b, old_seg_ptr, bit_count, code);
      315 		     if code ^= 0
      316 		     then goto MSF_FINISH;
      317 
      318 		     call msf_manager_$get_ptr (new_fcb_ptr, increment, "1"b, new_seg_ptr, (0), code);
      319 		     if code ^= 0
      320 		     then call copy_error (code, "1"b);
      321 		end;
      322 
      323 MSF_FINISH:
      324 		call hcs_$set_bc (target_dir, target_name, (increment), code);
      325 		if code ^= 0
      326 		then call copy_error (code, "1"b);
      327 
      328 SSF_UD_FINISH:
      329 		if msf
      330 		then call msf_manager_$close (fcb_ptr);
      331 		else call hcs_$terminate_noname (old_seg_ptr, (0));
      332 
      333 		call msf_manager_$close (new_fcb_ptr);
      334 	     end;
      335 
      336 	P_status = 0;				/* we exit via subr on errors */
      337 	if forced_access
      338 	then call delete_access ();			/* in case we forcd it earlier */
      339 	return;
      340 
      341 
      342 copy_a_segment:
      343      procedure;
      344 
      345 	declare segment		        (word_count) fixed bin (35) based;
      346 
      347 	new_seg_ptr -> segment = old_seg_ptr -> segment;
      348 
      349 	call hcs_$set_bc_seg (new_seg_ptr, bit_count, code);
      350 	if code ^= 0
      351 	then call copy_error (code, "1"b);
      352 
      353 	return;
      354      end copy_a_segment;
      355 
      356 
      357 extend:
      358      procedure;
      359 
      360 declare  rest_of_seg	bit (extra_bits) based;
      361 declare  extra_bits		fixed bin (24);
      362 
      363 	if ^msf
      364 	then do;
      365 		call object_info_$brief (old_seg_ptr, (sb.bit_count), addr (oi), code);
      366 		if code = 0
      367 		then call unstruct ("0"b);
      368 
      369 		if sb.bit_count = 0
      370 		then bc2 = 0;
      371 		else bc2 = divide (sb.bit_count - 1, (36 * 1024), 12, 0) + 1;
      372 		if bc2 ^= sb.current_length
      373 		then call fatal (0, "contents", "0"b,
      374 			"Bit count is inconsistent with current length for ^a. Cannot copy it.");
      375 	     end;
      376 
      377 	info.info_version = vfs_version_1;
      378 	call vfile_status_ (source_dir, source_name, addr (info), code);
      379 	if code ^= 0
      380 	then call copy_error (code, "0"b);
      381 	if info.type ^= 1 | (info.type = 1 & uns_info.flags.header_present)
      382 	then call unstruct ("0"b);
      383 
      384 	if copy_options.force
      385 	then call ensure_access ();
      386 
      387 	call vfile_status_ (target_dir, target_name, addr (info), code);
      388 	if code ^= 0
      389 	then call copy_error (code, "1"b);
      390 	if info.type ^= 1 | (info.type = 1 & uns_info.flags.header_present)
      391 	then call unstruct ("1"b);
      392 
      393 	if ^target_msf
      394 	then do;
      395 		call initiate_file_ (target_dir, target_name, RW_ACCESS, new_seg_ptr, (0), code);
      396 		if code ^= 0
      397 		then call copy_error (code, "1"b);
      398 
      399 		call hcs_$status_long (target_dir, target_name, 1, addr (sb2), null (), code);
      400 		if code ^= 0
      401 		then call copy_error (code, "1"b);
      402 
      403 		if sb2.bit_count = 0
      404 		then bc2 = 0;
      405 		else bc2 = divide (sb2.bit_count - 1, (36 * 1024), 12, 0) + 1;
      406 		if bc2 ^= sb2.current_length
      407 		then do;
      408 		     extra_bits = sb2.current_length * 1024 * 36 - sb2.bit_count;
      409 						/* bits past bit_count */
      410 		     if index (addbitno (new_seg_ptr, sb2.bit_count) -> rest_of_seg, "1"b) > 0
      411 		     then call fatal (0, "contents", "1"b,
      412 			"Bit count is inconsistent with current length for ^s^a. Cannot append to it.");
      413 		end;
      414 
      415 		call object_info_$brief (new_seg_ptr, (sb2.bit_count), addr (oi), code);
      416 		if code = 0
      417 		then call unstruct ("1"b);
      418 
      419 		if ^msf
      420 		then do;				/* check for easy case */
      421 			call hcs_$get_max_length_seg (new_seg_ptr, max_length, code);
      422 			if code ^= 0
      423 			then call copy_error (code, "1"b);
      424 
      425 			if divide ((sb.bit_count + sb2.bit_count), 36, 19, 0) > max_length
      426 			then goto USE_IOX;
      427 
      428 			bit_count = sb.bit_count + sb2.bit_count;
      429 			new_seg_ptr = addbitno (new_seg_ptr, sb2.bit_count);
      430 						/* point to end of target */
      431 			word_count = divide (sb.bit_count - 1, 36, 19, 0) + 1;
      432 
      433 			call copy_a_segment ();
      434 
      435 			call hcs_$terminate_noname (old_seg_ptr, (0));
      436 			call hcs_$terminate_noname (new_seg_ptr, (0));
      437 
      438 			return;
      439 		     end;
      440 	     end;
      441 
      442 USE_IOX:
      443 	iocb_ptr = null ();
      444 	on cleanup call close_and_destroy_iocb ();
      445 
      446 	if ^target_msf
      447 	then call hcs_$terminate_noname (new_seg_ptr, (0));
      448 
      449 	iocb_name = "copy_." || request_id_ (clock ());
      450 	attach_desc = "vfile_ " || requote_string_ (rtrim (pathname_ (target_dir, target_name))) || " -extend";
      451 
      452 	call iox_$attach_name (iocb_name, iocb_ptr, attach_desc, null (), code);
      453 	if code ^= 0
      454 	then call copy_error (code, "1"b);
      455 
      456 	call iox_$open (iocb_ptr, Stream_output, "0"b, code);
      457 	if code ^= 0
      458 	then call copy_error (code, "1"b);
      459 
      460 	if ^msf
      461 	then do;
      462 		char_count = divide (bit_count - 1, 9, 21, 0) + 1;
      463 		call iox_$put_chars (iocb_ptr, old_seg_ptr, char_count, code);
      464 		if code ^= 0
      465 		then call copy_error (code, "1"b);
      466 	     end;
      467 	else do increment = 0 repeat increment + 1;
      468 		call msf_manager_$get_ptr (fcb_ptr, increment, "0"b, component_ptr, bit_count, code);
      469 		if component_ptr = null ()
      470 		then goto DONE;
      471 
      472 		char_count = divide (bit_count - 1, 9, 21, 0) + 1;
      473 		call iox_$put_chars (iocb_ptr, component_ptr, char_count, code);
      474 		if code ^= 0
      475 		then call copy_error (code, "1"b);
      476 	     end;
      477 
      478 DONE:
      479 	call close_and_destroy_iocb ();
      480 
      481 	if msf
      482 	then call msf_manager_$close (fcb_ptr);
      483 	else call hcs_$terminate_noname (old_seg_ptr, (0));
      484 
      485 	return;
      486 
      487 unstruct:
      488      proc (errsw);
      489 
      490 	declare errsw		        bit (1) aligned;
      491 
      492 	call fatal (0, "contents", errsw, "Only unstructured files without headers may be used with -extend.");
      493 
      494      end unstruct;
      495 
      496 
      497 close_and_destroy_iocb:
      498      proc ();
      499 
      500 	if iocb_ptr = null ()
      501 	then return;
      502 
      503 	call iox_$close (iocb_ptr, (0));
      504 	call iox_$detach_iocb (iocb_ptr, (0));
      505 	call iox_$destroy_iocb (iocb_ptr, (0));
      506 
      507 	return;
      508      end close_and_destroy_iocb;
      509 
      510      end extend;
      511 
      512 
      513 copy_error:
      514      proc (status, switch);
      515 
      516 	declare status		        fixed bin (35),
      517 	        switch		        bit (1) aligned;
      518 
      519 	cei.copy_options_ptr = copy_options_ptr;
      520 	cei.operation = "contents";
      521 	cei.target_err_switch = switch;
      522 
      523 	do while ("1"b);
      524 	     call sub_err_ (status, "copy_", ACTION_CANT_RESTART, addr (cei), (0), "^[^a^;^s^a^]", switch,
      525 		pathname_ (target_dir, target_name), pathname_ (source_dir, source_name));
      526 
      527 	end;
      528 
      529      end copy_error;
      530 
      531 error:
      532      proc (status, op, switch, message);
      533 
      534 	declare flags		        bit (36) aligned,
      535 	        status		        fixed bin (35),
      536 	        op		        char (*),
      537 	        switch		        bit (1) aligned,
      538 	        message		        char (*);
      539 
      540 	flags = ACTION_CAN_RESTART;
      541 	goto COMMON;
      542 
      543 fatal:
      544      entry (status, op, switch, message);
      545 
      546 	flags = ACTION_CANT_RESTART;
      547 	goto COMMON;
      548 
      549 warning:
      550      entry (status, op, switch, message);
      551 
      552 	flags = ACTION_DEFAULT_RESTART;
      553 COMMON:
      554 	cei.copy_options_ptr = copy_options_ptr;
      555 	cei.operation = op;
      556 	cei.target_err_switch = switch;
      557 
      558 	call sub_err_ (status, "copy_", flags, addr (cei), (0), message, pathname_ (source_dir, source_name),
      559 	     pathname_ (target_dir, target_name));
      560 
      561 	return;
      562      end error;
      563 
      564 /**** This procedure may call an fs_util_ entry for an MSF with
      565*
      566*      a segment for an operand. This is okay, since a segment
      567*      will be corrcectly trreated as an SSF MSF. */
      568 
      569 ensure_access:
      570      procedure;
      571 
      572 	declare code		        fixed bin (35);
      573 	declare get_user_access_modes_entry   entry (char (*), char (*), char (*), fixed bin, bit (36) aligned,
      574 				        bit (36) aligned, fixed bin (35)) variable;
      575 	declare list_acl_entry	        entry (char (*), char (*), char (*), pointer, pointer, fixed bin (35))
      576 				        variable;
      577 
      578 	call fs_util_$make_entry_for_type (source_type, FS_GET_USER_ACCESS_MODES, get_user_access_modes_entry, (0));
      579 
      580 	call get_user_access_modes_entry (target_dir, target_name, "", -1, modes, ""b, code);
      581 	if code ^= 0
      582 	then call copy_error (code, "1"b);
      583 
      584 	if (modes & RW_ACCESS) = RW_ACCESS
      585 	then return;				/* Don't have to force access */
      586 
      587 	call fs_util_$make_entry_for_type (source_type, FS_LIST_ACL, list_acl_entry, (0));
      588 	call fs_util_$make_entry_for_type (source_type, FS_ADD_ACL_ENTRIES, add_acl_entries_entry, (0));
      589 	call fs_util_$make_entry_for_type (source_type, FS_DELETE_ACL_ENTRIES, delete_acl_entries_entry, (0));
      590 
      591 
      592 	one_acl.version = GENERAL_ACL_VERSION_1;
      593 	one_acl.count = 1;
      594 	one_acl.access_name = get_group_id_ ();
      595 	one_acl.mode = RW_ACCESS;
      596 
      597 	call list_acl_entry (target_dir, target_name, GENERAL_ACL_VERSION_1, null (), addr (one_acl), code);
      598 
      599 	if code ^= 0
      600 	then call copy_error (code, "1"b);
      601 	saved_mode = one_acl.mode (1);
      602 	delete_forced_acle = (one_acl.entries (1).status_code = error_table_$user_not_found);
      603 						/* If there were no entry for user, delete the forced one
      604*						   when we're done;else put the old one back */
      605 	forced_access = "1"b;
      606 
      607 	one_acl.mode (1) = one_acl.mode (1) | RW_ACCESS;
      608 
      609 	call add_acl_entries_entry (target_dir, target_name, addr (one_acl), code);
      610 	if code ^= 0
      611 	then call copy_error (code, "1"b);
      612 
      613 	return;
      614 
      615 delete_access:
      616      entry;
      617 
      618 	if ^forced_access				/* just in case the caller didn't check */
      619 	then return;
      620 
      621 	one_acl.mode (1) = saved_mode;
      622 	if delete_forced_acle
      623 	then do;
      624 		one_del_acl = one_acl, by name;
      625 		one_del_acl.version = GENERAL_DELETE_ACL_VERSION_1;
      626 		call delete_acl_entries_entry (target_dir, target_name, addr (one_del_acl), (0));
      627 	     end;
      628 	else call add_acl_entries_entry (target_dir, target_name, addr (one_acl), (0));
      629 	return;
      630      end ensure_access;
      631 
      632 cleanup_copy:
      633      procedure;
      634 
      635 	if forced_access
      636 	then call delete_access ();			/* in case we forced it earlier */
      637 
      638 	if ^msf					/* MSF pointers are terminated by msf_manager_$close */
      639 	then if old_seg_ptr ^= null ()
      640 	     then call hcs_$terminate_noname (old_seg_ptr, (0));
      641 
      642 	if ^target_msf
      643 	then if new_seg_ptr ^= null ()
      644 	     then call hcs_$terminate_noname (new_seg_ptr, (0));
      645 
      646 
      647 	if fcb_ptr ^= null ()
      648 	then call msf_manager_$close (fcb_ptr);
      649 	if new_fcb_ptr ^= null ()
      650 	then call msf_manager_$close (new_fcb_ptr);
      651 
      652 	return;
      653      end cleanup_copy;
      654 
      655      end fs_copy_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/29/86  1353.4  fs_copy_util_.pl1                 >spec>install>1009>fs_copy_util_.pl1
132          1    05/23/83  0916.6  iox_entries.incl.pl1              >ldd>include>iox_dcls.incl.pl1
133          2    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
134          3    10/14/83  1606.7  file_system_operations.incl.pl1   >ldd>include>file_system_operations.incl.pl1
135          4    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
140          5    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
141          6    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
142          7    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
143          8    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
144          9    07/18/81  1100.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
145         10    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
146         11    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
147         12    10/14/83  1606.7  copy_error_info.incl.pl1          >ldd>include>copy_error_info.incl.pl1
148         13    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
149         14    07/19/79  1547.0  vfs_info.incl.pl1                 >ldd>include>vfs_info.incl.pl1
150         15    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 15-77
ACTION_CANT_RESTART             000156 constant        bit(36)                  initial dcl 10-7 set ref 524* 546
ACTION_CAN_RESTART                     constant        bit(36)                  initial dcl 10-7 ref 540
ACTION_DEFAULT_RESTART                 constant        bit(36)                  initial dcl 10-7 ref 552
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 10-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 10-7
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
COMMON                          004377 constant        label                    dcl 553 ref 541 547
COPY_OPTIONS_VERSION_1          000006 constant        char(8)                  initial unaligned dcl 6-28 ref 168
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 15-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 15-67
DONE                            003766 constant        label                    dcl 478 ref 469
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
Directory                              constant        fixed bin(17,0)          initial dcl 5-56 ref 218
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
Entry_Common                    000400 constant        label                    dcl 166 ref 159
FS_ADD_ACL_ENTRIES              000110 constant        char(64)                 initial unaligned dcl 3-6 set ref 588*
FS_ADD_EXTENDED_ACL_ENTRIES            internal static char(64)                 initial unaligned dcl 3-6
FS_CHNAME_FILE                         internal static char(64)                 initial unaligned dcl 3-6
FS_COPY                                internal static char(64)                 initial unaligned dcl 3-6
FS_DELENTRY_FILE                       internal static char(64)                 initial unaligned dcl 3-6
FS_DELETE_ACL_ENTRIES           000070 constant        char(64)                 initial unaligned dcl 3-6 set ref 589*
FS_GET_BIT_COUNT                       internal static char(64)                 initial unaligned dcl 3-6
FS_GET_MAX_LENGTH                      internal static char(64)                 initial unaligned dcl 3-6
FS_GET_RING_BRACKETS                   internal static char(64)                 initial unaligned dcl 3-6
FS_GET_SWITCH                          internal static char(64)                 initial unaligned dcl 3-6
FS_GET_USER_ACCESS_MODES        000050 constant        char(64)                 initial unaligned dcl 3-6 set ref 578*
FS_LIST_ACL                     000030 constant        char(64)                 initial unaligned dcl 3-6 set ref 587*
FS_LIST_EXTENDED_ACL                   internal static char(64)                 initial unaligned dcl 3-6
FS_LIST_SWITCHES                       internal static char(64)                 initial unaligned dcl 3-6
FS_OBJECT_TYPE_DIRECTORY               internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_MSF              000010 constant        char(32)                 initial unaligned dcl 4-50 ref 163
FS_OBJECT_TYPE_SEGMENT          000020 constant        char(32)                 initial unaligned dcl 4-50 ref 157
FS_REPLACE_ACL                         internal static char(64)                 initial unaligned dcl 3-6
FS_REPLACE_EXTENDED_ACL                internal static char(64)                 initial unaligned dcl 3-6
FS_SET_BIT_COUNT                       internal static char(64)                 initial unaligned dcl 3-6
FS_SET_MAX_LENGTH                      internal static char(64)                 initial unaligned dcl 3-6
FS_SET_RING_BRACKETS                   internal static char(64)                 initial unaligned dcl 3-6
FS_SET_SWITCH                          internal static char(64)                 initial unaligned dcl 3-6
FS_SUFFIX_INFO                         internal static char(64)                 initial unaligned dcl 3-6
FS_VALIDATE                            internal static char(64)                 initial unaligned dcl 3-6
GENERAL_ACL_VERSION_1           000002 constant        char(8)                  initial unaligned dcl 15-72 set ref 592 597*
GENERAL_DELETE_ACL_VERSION_1    000000 constant        char(8)                  initial unaligned dcl 15-72 ref 625
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 15-72
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 2-15
Link                                   internal static fixed bin(17,0)          initial dcl 5-56
MSF_FINISH                      002234 constant        label                    dcl 323 ref 315
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
P_copy_options_ptr                     parameter       pointer                  dcl 39 ref 154 161 166
P_status                               parameter       fixed bin(35,0)          dcl 40 set ref 154 161 336*
REW_ACCESS                      000004 constant        bit(3)                   initial unaligned dcl 8-11 set ref 241*
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
RW_ACCESS                       000131 constant        bit(3)                   initial unaligned dcl 8-11 set ref 249* 260* 395*
                                                                                  584 584 595 607
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
R_ACCESS                        000156 constant        bit(3)                   initial unaligned dcl 8-11 set ref 201 231*
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 15-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 8-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SSF_UD_FINISH                   002277 constant        label                    dcl 328 ref 310
SUFFIX_INFO_VERSION_1                  internal static char(8)                  initial unaligned dcl 4-29
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial unaligned dcl 4-48
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
Segment                                internal static fixed bin(17,0)          initial dcl 5-56
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
Stream_output                   000163 constant        fixed bin(17,0)          initial dcl 2-15 set ref 456*
USE_IOX                         003314 constant        label                    dcl 442 ref 425
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
access_name               3     000614 automatic       char(32)                 array level 3 packed unaligned dcl 73 set ref 594*
acl_count                              automatic       fixed bin(17,0)          dcl 15-5
acl_ptr                                automatic       pointer                  dcl 15-4
add_acl_entries_entry           000704 automatic       entry variable           dcl 102 set ref 588* 609 628
addbitno                                               builtin function         dcl 85 ref 410 429
addr                                                   builtin function         dcl 85 ref 186 186 298 298 365 365 378 378 381 387
                                                                                  387 390 399 399 415 415 524 524 558 558 597 597
                                                                                  609 609 626 626 628 628
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 4-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 4-33
attach_desc                     000100 automatic       char(200)                unaligned dcl 42 set ref 450* 452*
bc2                             000163 automatic       fixed bin(24,0)          dcl 43 set ref 206* 208* 209 369* 371* 372 403* 405*
                                                                                  406
bit_count                 7(12) 000465 automatic       fixed bin(24,0)          level 3 in structure "sb" packed unsigned unaligned
                                                                                  dcl 69 in procedure "fs_copy_util_" set ref 206
                                                                                  208 232 365 369 371 425 428 431
bit_count                 7(12) 000477 automatic       fixed bin(24,0)          level 3 in structure "sb2" packed unsigned unaligned
                                                                                  dcl 70 in procedure "fs_copy_util_" set ref 403
                                                                                  405 408 410 415 425 428 429
bit_count                       000162 automatic       fixed bin(24,0)          dcl 43 in procedure "fs_copy_util_" set ref 214* 218
                                                                                  226* 232* 314* 349* 428* 462 468* 472
blk_info                               based           structure                level 1 unaligned dcl 14-21
cei                             000512 automatic       structure                level 1 dcl 71 set ref 524 524 558 558
char_count                      000164 automatic       fixed bin(21,0)          dcl 44 set ref 462* 463* 472* 473*
cleanup                         000670 stack reference condition                dcl 85 ref 183 444
cleanup_copy                    005314 constant        entry                    internal dcl 632 ref 183
clock                                                  builtin function         dcl 85 ref 449 449
close_and_destroy_iocb          004060 constant        entry                    internal dcl 497 ref 444 478
code                            000100 automatic       fixed bin(35,0)          dcl 572 in procedure "ensure_access" set ref 580*
                                                                                  581 581* 597* 599 599* 609* 610 610*
code                            000165 automatic       fixed bin(35,0)          dcl 45 in procedure "fs_copy_util_" set ref 186* 187
                                                                                  187 187* 194* 195 195* 214* 215 215* 219 226* 227
                                                                                  227* 231* 234 234* 241* 245 249 249* 252 252* 254
                                                                                  254* 258 260* 261 261* 265* 278* 279* 286* 287
                                                                                  287* 291* 293 293* 298* 299 299* 303* 304 304*
                                                                                  314* 315 318* 319 319* 323* 325 325* 349* 350 350*
                                                                                  365* 366 378* 379 379* 387* 388 388* 395* 396 396*
                                                                                  399* 400 400* 415* 416 421* 422 422* 452* 453 453*
                                                                                  456* 457 457* 463* 464 464* 468* 473* 474 474*
component_ptr                   000166 automatic       pointer                  dcl 46 set ref 468* 469 473*
condition_info_header                  based           structure                level 1 dcl 11-6
condition_info_header_ptr              automatic       pointer                  dcl 11-4
copy_a_segment                  002344 constant        entry                    internal dcl 342 ref 271 308 433
copy_error                      004136 constant        entry                    internal dcl 513 ref 168 184 187 195 199 201 215 219
                                                                                  234 254 261 265 279 287 293 299 304 319 325 350
                                                                                  379 388 396 400 422 453 457 464 474 581 599 610
copy_error_info                        based           structure                level 1 dcl 12-8
copy_flags                             based           structure                level 1 dcl 7-8
copy_items              157            based           structure                level 2 dcl 6-12
copy_options                           based           structure                level 1 dcl 6-12
copy_options_ptr                000512 automatic       pointer                  level 2 in structure "cei" dcl 71 in procedure
                                                                                  "fs_copy_util_" set ref 519* 553*
copy_options_ptr                000714 automatic       pointer                  dcl 6-10 in procedure "fs_copy_util_" set ref 166*
                                                                                  168 171 171 174 175 176 177 204 215 215 237 243
                                                                                  245 282 284 384 519 553
count                     2     000614 automatic       fixed bin(17,0)          level 2 dcl 73 set ref 593*
curlen                          000170 automatic       fixed bin(17,0)          dcl 47 set ref 268* 269 302* 307
current_length            7     000477 automatic       fixed bin(12,0)          level 3 in structure "sb2" packed unsigned unaligned
                                                                                  dcl 70 in procedure "fs_copy_util_" set ref 406
                                                                                  408
current_length            7     000465 automatic       fixed bin(12,0)          level 3 in structure "sb" packed unsigned unaligned
                                                                                  dcl 69 in procedure "fs_copy_util_" set ref 209
                                                                                  268 302 372
delete_access                   005162 constant        entry                    internal dcl 615 ref 337 635
delete_acl                             based           structure                level 1 dcl 15-58
delete_acl_array                       based           structure                array level 1 dcl 15-64
delete_acl_entries_entry        000710 automatic       entry variable           dcl 103 set ref 589* 626
delete_acl_entry                       based           structure                level 1 dcl 15-63
delete_forced_acle              000254 automatic       bit(1)                   dcl 50 set ref 602* 622
dir                             000171 automatic       char(168)                unaligned dcl 48 set ref 297* 298* 303*
directory_acl                          based           structure                level 1 dcl 15-49
directory_acl_array                    based           structure                array level 1 dcl 15-55
directory_acl_entry                    based           structure                level 1 dcl 15-54
divide                                                 builtin function         dcl 85 ref 208 371 405 425 431 462 472
ename                           000243 automatic       char(32)                 unaligned dcl 49 set ref 297* 298* 303*
ensure_access                   004532 constant        entry                    internal dcl 569 ref 245 284 384
entries                   3     000614 automatic       structure                array level 2 dcl 73
error                           004306 constant        entry                    internal dcl 531
error_table_$inconsistent_msf   000010 external static fixed bin(35,0)          dcl 90 ref 227
error_table_$lower_ring         000012 external static fixed bin(35,0)          dcl 90 set ref 199*
error_table_$moderr             000014 external static fixed bin(35,0)          dcl 90 set ref 184* 201*
error_table_$namedup            000016 external static fixed bin(35,0)          dcl 90 set ref 219*
error_table_$no_e_permission    000022 external static fixed bin(35,0)          dcl 90 ref 258
error_table_$no_s_permission    000024 external static fixed bin(35,0)          dcl 90 ref 187
error_table_$noentry            000020 external static fixed bin(35,0)          dcl 90 ref 219
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 90 set ref 168*
error_table_$user_not_found     000030 external static fixed bin(35,0)          dcl 90 ref 602
errsw                                  parameter       bit(1)                   dcl 490 set ref 487 492*
extend                  157(08)        based           bit(1)                   level 3 in structure "copy_options" packed unaligned
                                                                                  dcl 6-12 in procedure "fs_copy_util_" ref 171 204
                                                                                  215 237
extend                          002413 constant        entry                    internal dcl 357 in procedure "fs_copy_util_" ref
                                                                                  237
extra_bits                      000100 automatic       fixed bin(24,0)          dcl 361 set ref 408* 410
fatal                           004331 constant        entry                    internal dcl 543 ref 171 372 410 492
fcb_ptr                         000256 automatic       pointer                  dcl 52 set ref 180* 194* 226* 314* 328* 468* 481*
                                                                                  647 647*
fixed                                                  builtin function         dcl 85 ref 302
flags                   156            based           structure                level 2 in structure "copy_options" dcl 6-12
                                                                                  in procedure "fs_copy_util_"
flags                           000100 automatic       bit(36)                  dcl 534 in procedure "error" set ref 540* 546* 552*
                                                                                  558*
flags                     3            based           structure                level 2 in structure "uns_info" dcl 14-1
                                                                                  in procedure "fs_copy_util_"
force                   156(02)        based           bit(1)                   level 3 packed unaligned dcl 6-12 ref 245 284 384
forced_access                   000253 automatic       bit(1)                   dcl 50 set ref 181* 337 605* 618 635
fs_copy_util_                   000340 constant        entry                    external dcl 36
fs_util_$make_entry_for_type    000036 constant        entry                    external dcl 106 ref 578 587 588 589
general_acl                            based           structure                level 1 dcl 15-7
general_acl_entry                      based           structure                level 1 unaligned dcl 15-12
general_delete_acl                     based           structure                level 1 dcl 15-30
general_delete_acl_entry               based           structure                level 1 dcl 15-35
general_extended_acl                   based           structure                level 1 dcl 15-18
general_extended_acl_entry             based           structure                level 1 dcl 15-23
get_group_id_                   000032 constant        entry                    external dcl 104 ref 594
get_ring_                       000034 constant        entry                    external dcl 105 ref 199
get_user_access_modes_entry     000102 automatic       entry variable           dcl 573 set ref 578* 580
hcs_$fs_get_path_name           000040 constant        entry                    external dcl 107 ref 297
hcs_$get_max_length             000050 constant        entry                    external dcl 112 ref 303
hcs_$get_max_length_seg         000046 constant        entry                    external dcl 111 ref 421
hcs_$set_bc                     000052 constant        entry                    external dcl 113 ref 323
hcs_$set_bc_seg                 000054 constant        entry                    external dcl 114 ref 349
hcs_$status_long                000042 constant        entry                    external dcl 108 ref 186 298 399
hcs_$status_minf                000044 constant        entry                    external dcl 109 ref 214
hcs_$terminate_noname           000062 constant        entry                    external dcl 118 ref 273 274 331 435 436 446 483 638
                                                                                  642
hcs_$truncate_seg               000064 constant        entry                    external dcl 119 ref 252
header_present            3(02)        based           bit(1)                   level 3 packed unaligned dcl 14-1 ref 381 390
increment                       000262 automatic       fixed bin(17,0)          dcl 53 set ref 193* 312* 312 314* 318* 323 467* 468*
                                                                                  476*
index                                                  builtin function         dcl 85 ref 410
indx_info                              based           structure                level 1 unaligned dcl 14-33
info                            000646 automatic       structure                level 1 dcl 81 set ref 378 378 381 387 387 390
info_version                    000646 automatic       fixed bin(17,0)          level 2 dcl 81 set ref 377*
initiate_file_                  000056 constant        entry                    external dcl 115 ref 231 249 260 395
initiate_file_$create           000060 constant        entry                    external dcl 116 ref 241
iocb_name                       000263 automatic       char(32)                 unaligned dcl 54 set ref 449* 452*
iocb_ptr                        000274 automatic       pointer                  dcl 55 set ref 442* 452* 456* 463* 473* 500 503*
                                                                                  504* 505*
iox_$attach_loud                000000 constant        entry                    external dcl 1-8
iox_$attach_name                000114 constant        entry                    external dcl 1-8 ref 452
iox_$attach_ptr                 000000 constant        entry                    external dcl 1-8
iox_$close                      000116 constant        entry                    external dcl 1-8 ref 503
iox_$close_file                 000000 constant        entry                    external dcl 1-8
iox_$control                    000000 constant        entry                    external dcl 1-8
iox_$delete_record              000000 constant        entry                    external dcl 1-8
iox_$destroy_iocb               000120 constant        entry                    external dcl 1-8 ref 505
iox_$detach                     000000 constant        entry                    external dcl 1-8
iox_$detach_iocb                000122 constant        entry                    external dcl 1-8 ref 504
iox_$err_no_operation           000000 constant        entry                    external dcl 1-8
iox_$err_not_attached           000000 constant        entry                    external dcl 1-8
iox_$err_not_closed             000000 constant        entry                    external dcl 1-8
iox_$err_not_open               000000 constant        entry                    external dcl 1-8
iox_$error_output                      external static pointer                  dcl 1-41
iox_$find_iocb                  000000 constant        entry                    external dcl 1-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-8
iox_$get_chars                  000000 constant        entry                    external dcl 1-8
iox_$get_line                   000000 constant        entry                    external dcl 1-8
iox_$look_iocb                  000000 constant        entry                    external dcl 1-8
iox_$modes                      000000 constant        entry                    external dcl 1-8
iox_$move_attach                000000 constant        entry                    external dcl 1-8
iox_$open                       000124 constant        entry                    external dcl 1-8 ref 456
iox_$open_file                  000000 constant        entry                    external dcl 1-8
iox_$position                   000000 constant        entry                    external dcl 1-8
iox_$propagate                  000000 constant        entry                    external dcl 1-8
iox_$put_chars                  000126 constant        entry                    external dcl 1-8 ref 463 473
iox_$read_key                   000000 constant        entry                    external dcl 1-8
iox_$read_length                000000 constant        entry                    external dcl 1-8
iox_$read_record                000000 constant        entry                    external dcl 1-8
iox_$rewrite_record             000000 constant        entry                    external dcl 1-8
iox_$seek_key                   000000 constant        entry                    external dcl 1-8
iox_$user_input                        external static pointer                  dcl 1-41
iox_$user_io                           external static pointer                  dcl 1-41
iox_$user_output                       external static pointer                  dcl 1-41
iox_$write_record               000000 constant        entry                    external dcl 1-8
iox_modes                              internal static char(24)                 initial array dcl 2-6
list_acl_entry                  000106 automatic       entry variable           dcl 575 set ref 587* 597
long                      4     000477 automatic       structure                level 2 in structure "sb2" dcl 70 in procedure
                                                                                  "fs_copy_util_"
long                      4     000465 automatic       structure                level 2 in structure "sb" dcl 69 in procedure
                                                                                  "fs_copy_util_"
max_length                      000276 automatic       fixed bin(19,0)          dcl 56 set ref 303* 307 421* 425
message                                parameter       char                     unaligned dcl 534 set ref 531 543 549 558*
min                                                    builtin function         dcl 85 ref 307
mode                     13     000614 automatic       bit(36)                  array level 3 in structure "one_acl" dcl 73
                                                                                  in procedure "fs_copy_util_" set ref 595* 601 607*
                                                                                  607 621*
mode                      3     000465 automatic       bit(5)                   level 3 in structure "sb" packed unaligned dcl 69
                                                                                  in procedure "fs_copy_util_" set ref 201
modes                           000277 automatic       bit(36)                  dcl 57 set ref 580* 584
msf                             000300 automatic       bit(1)                   dcl 58 in procedure "fs_copy_util_" set ref 158*
                                                                                  164* 191 204 224 239 310 328 363 419 460 481 638
msf                             000366 constant        entry                    external dcl 161
msf_manager_$adjust             000066 constant        entry                    external dcl 120 ref 286
msf_manager_$close              000070 constant        entry                    external dcl 121 ref 328 333 481 647 649
msf_manager_$get_ptr            000074 constant        entry                    external dcl 123 ref 226 314 318 468
msf_manager_$msf_get_ptr        000072 constant        entry                    external dcl 122 ref 291
msf_manager_$open               000076 constant        entry                    external dcl 124 ref 194 278
new_fcb_ptr                     000260 automatic       pointer                  dcl 52 set ref 180* 278* 279 286* 291* 318* 333* 649
                                                                                  649*
new_seg_ptr                     000302 automatic       pointer                  dcl 59 set ref 180* 241* 249* 252* 260* 265 274*
                                                                                  291* 318* 347 349* 395* 410 415* 421* 429* 429
                                                                                  436* 446* 642 642*
no_write_permission             000676 stack reference condition                dcl 85 ref 184
null                                                   builtin function         dcl 85 ref 180 186 186 265 279 298 298 399 399 442
                                                                                  452 452 469 500 597 597 638 642 647 649
object_info                            based           structure                level 1 dcl 13-6
object_info_$brief              000100 constant        entry                    external dcl 125 ref 365 415
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 13-60
oi                              000526 automatic       structure                level 1 dcl 72 set ref 365 365 415 415
old_seg_ptr                     000304 automatic       pointer                  dcl 59 set ref 180* 226* 231* 273* 297* 314* 331*
                                                                                  347 365* 435* 463* 483* 638 638*
one_acl                         000614 automatic       structure                level 1 dcl 73 set ref 597 597 609 609 624 628 628
one_del_acl                     000631 automatic       structure                level 1 dcl 77 set ref 624* 626 626
op                                     parameter       char                     unaligned dcl 534 ref 531 543 549 555
operation                 2     000512 automatic       char(32)                 level 2 dcl 71 set ref 520* 555*
pathname_                       000102 constant        entry                    external dcl 126 ref 450 450 524 524 524 524 558 558
                                                                                  558 558
request_id_                     000104 constant        entry                    external dcl 127 ref 449
requote_string_                 000106 constant        entry                    external dcl 128 ref 450
rest_of_seg                            based           bit                      unaligned dcl 360 ref 410
ring_brackets            10(18) 000465 automatic       fixed bin(6,0)           array level 3 packed unsigned unaligned dcl 69 set
                                                                                  ref 199
rtrim                                                  builtin function         dcl 85 ref 450 450
saved_mode                      000306 automatic       bit(36)                  dcl 60 set ref 601* 621
sb                              000465 automatic       structure                level 1 dcl 69 set ref 186 186 298 298
sb2                             000477 automatic       structure                level 1 dcl 70 set ref 399 399
segment                                based           fixed bin(35,0)          array dcl 345 in procedure "copy_a_segment" set ref
                                                                                  347* 347
segment                         000352 constant        entry                    external dcl 154
segment_acl                            based           structure                level 1 dcl 15-40
segment_acl_array                      based           structure                array level 1 dcl 15-46
segment_acl_entry                      based           structure                level 1 dcl 15-45
seq_info                               based           structure                level 1 unaligned dcl 14-11
short                           000465 automatic       structure                level 2 dcl 69
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
source_dir               12            based           char(168)                level 2 in structure "copy_options" packed unaligned
                                                                                  dcl 6-12 in procedure "fs_copy_util_" ref 174
source_dir                      000307 automatic       char(168)                unaligned dcl 61 in procedure "fs_copy_util_" set
                                                                                  ref 174* 186* 194* 231* 378* 524* 524* 558* 558*
source_name                     000361 automatic       char(32)                 unaligned dcl 62 in procedure "fs_copy_util_" set
                                                                                  ref 175* 186* 194* 231* 378* 524* 524* 558* 558*
source_name              64            based           char(32)                 level 2 in structure "copy_options" packed unaligned
                                                                                  dcl 6-12 in procedure "fs_copy_util_" ref 175
source_type                     000371 automatic       char(32)                 unaligned dcl 63 set ref 157* 163* 578* 587* 588*
                                                                                  589*
status                                 parameter       fixed bin(35,0)          dcl 534 in procedure "error" set ref 531 543 549
                                                                                  558*
status                                 parameter       fixed bin(35,0)          dcl 516 in procedure "copy_error" set ref 513 524*
status_area_ptr                        automatic       pointer                  dcl 5-47
status_branch                          based           structure                level 1 dcl 5-8
status_code              14     000614 automatic       fixed bin(35,0)          array level 3 dcl 73 set ref 602
status_entry_names                     based           char(32)                 array dcl 5-47
status_link                            based           structure                level 1 dcl 5-38
status_pathname                        based           char                     dcl 5-47
status_ptr                             automatic       pointer                  dcl 5-47
sub_err_                        000110 constant        entry                    external dcl 129 ref 524 558
sub_error_info                         based           structure                level 1 dcl 9-7
sub_error_info_ptr                     automatic       pointer                  dcl 9-6
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 9-13
suffix_info                            based           structure                level 1 dcl 4-12
suffix_info_ptr                        automatic       pointer                  dcl 4-10
switch                                 parameter       bit(1)                   dcl 534 in procedure "error" ref 531 543 549 556
switch                                 parameter       bit(1)                   dcl 516 in procedure "copy_error" set ref 513 521
                                                                                  524*
switch_list                            based           structure                level 1 dcl 4-37
switch_list_ptr                        automatic       pointer                  dcl 4-33
target_dir                      000401 automatic       char(168)                unaligned dcl 64 in procedure "fs_copy_util_" set
                                                                                  ref 176* 214* 241* 249* 260* 278* 323* 387* 395*
                                                                                  399* 450* 450* 524* 524* 558* 558* 580* 597* 609*
                                                                                  626* 628*
target_dir               74            based           char(168)                level 2 in structure "copy_options" packed unaligned
                                                                                  dcl 6-12 in procedure "fs_copy_util_" ref 176
target_err_switch        12     000512 automatic       bit(1)                   level 2 dcl 71 set ref 521* 556*
target_msf                      000301 automatic       bit(1)                   dcl 58 set ref 218* 221* 239 393 446 642
target_name                     000453 automatic       char(32)                 unaligned dcl 65 in procedure "fs_copy_util_" set
                                                                                  ref 177* 214* 241* 249* 260* 278* 323* 387* 395*
                                                                                  399* 450* 450* 524* 524* 558* 558* 580* 597* 609*
                                                                                  626* 628*
target_name             146            based           char(32)                 level 2 in structure "copy_options" packed unaligned
                                                                                  dcl 6-12 in procedure "fs_copy_util_" ref 177
type                      1     000646 automatic       fixed bin(17,0)          level 2 in structure "info" dcl 81 in procedure
                                                                                  "fs_copy_util_" set ref 381 381 390 390
type                            000463 automatic       fixed bin(17,0)          dcl 66 in procedure "fs_copy_util_" set ref 214* 218
uns_info                               based           structure                level 1 unaligned dcl 14-1
unstruct                        004020 constant        entry                    internal dcl 487 ref 366 381 390 416
update                  157(09)        based           bit(1)                   level 3 packed unaligned dcl 6-12 ref 171 215 243
                                                                                  282
vbl_info                               based           structure                level 1 unaligned dcl 14-55
version                         000614 automatic       char(8)                  level 2 in structure "one_acl" dcl 73 in procedure
                                                                                  "fs_copy_util_" set ref 592*
version                         000631 automatic       char(8)                  level 2 in structure "one_del_acl" dcl 77
                                                                                  in procedure "fs_copy_util_" set ref 625*
version                                based           char(8)                  level 2 in structure "copy_options" dcl 6-12
                                                                                  in procedure "fs_copy_util_" ref 168
vfile_status_                   000112 constant        entry                    external dcl 130 ref 378 387
vfs_version_1                          constant        fixed bin(17,0)          initial dcl 14-67 ref 377
warning                         004355 constant        entry                    internal dcl 549 ref 209
word_count                      000464 automatic       fixed bin(19,0)          dcl 67 set ref 269* 307* 347 431*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6216        6346    5430        6226
Length      7170    5430       130         605     565           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fs_copy_util_                       568 external procedure  is an external procedure.  
on unit on line 183                  78 on unit               
on unit on line 184                  74 on unit               
copy_a_segment                       73 internal procedure  is called by several nonquick procedures.  
extend                              244 internal procedure  enables or reverts conditions.  
on unit on line 444                  64 on unit               
unstruct                                internal procedure  shares stack frame of internal procedure extend.  
close_and_destroy_iocb               72 internal procedure  is called by several nonquick procedures.  
copy_error                          210 internal procedure  is called by several nonquick procedures.  
error                               204 internal procedure  is called by several nonquick procedures.  
ensure_access                       132 internal procedure  is called by several nonquick procedures.  
cleanup_copy                            internal procedure  shares stack frame of on unit on line 183.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ensure_access            000100 code                        ensure_access
                         000102 get_user_access_modes_entry ensure_access
                         000106 list_acl_entry              ensure_access
error                    000100 flags                       error
extend                   000100 extra_bits                  extend
fs_copy_util_            000100 attach_desc                 fs_copy_util_
                         000162 bit_count                   fs_copy_util_
                         000163 bc2                         fs_copy_util_
                         000164 char_count                  fs_copy_util_
                         000165 code                        fs_copy_util_
                         000166 component_ptr               fs_copy_util_
                         000170 curlen                      fs_copy_util_
                         000171 dir                         fs_copy_util_
                         000243 ename                       fs_copy_util_
                         000253 forced_access               fs_copy_util_
                         000254 delete_forced_acle          fs_copy_util_
                         000256 fcb_ptr                     fs_copy_util_
                         000260 new_fcb_ptr                 fs_copy_util_
                         000262 increment                   fs_copy_util_
                         000263 iocb_name                   fs_copy_util_
                         000274 iocb_ptr                    fs_copy_util_
                         000276 max_length                  fs_copy_util_
                         000277 modes                       fs_copy_util_
                         000300 msf                         fs_copy_util_
                         000301 target_msf                  fs_copy_util_
                         000302 new_seg_ptr                 fs_copy_util_
                         000304 old_seg_ptr                 fs_copy_util_
                         000306 saved_mode                  fs_copy_util_
                         000307 source_dir                  fs_copy_util_
                         000361 source_name                 fs_copy_util_
                         000371 source_type                 fs_copy_util_
                         000401 target_dir                  fs_copy_util_
                         000453 target_name                 fs_copy_util_
                         000463 type                        fs_copy_util_
                         000464 word_count                  fs_copy_util_
                         000465 sb                          fs_copy_util_
                         000477 sb2                         fs_copy_util_
                         000512 cei                         fs_copy_util_
                         000526 oi                          fs_copy_util_
                         000614 one_acl                     fs_copy_util_
                         000631 one_del_acl                 fs_copy_util_
                         000646 info                        fs_copy_util_
                         000704 add_acl_entries_entry       fs_copy_util_
                         000710 delete_acl_entries_entry    fs_copy_util_
                         000714 copy_options_ptr            fs_copy_util_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_cs            cat_realloc_cs      call_var_desc       call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return
enable              shorten_stack       ext_entry           int_entry           int_entry_desc      index_bs_1_eis
clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
fs_util_$make_entry_for_type  get_group_id_                 get_ring_                     hcs_$fs_get_path_name
hcs_$get_max_length           hcs_$get_max_length_seg       hcs_$set_bc                   hcs_$set_bc_seg
hcs_$status_long              hcs_$status_minf              hcs_$terminate_noname         hcs_$truncate_seg
initiate_file_                initiate_file_$create         iox_$attach_name              iox_$close
iox_$destroy_iocb             iox_$detach_iocb              iox_$open                     iox_$put_chars
msf_manager_$adjust           msf_manager_$close            msf_manager_$get_ptr          msf_manager_$msf_get_ptr
msf_manager_$open             object_info_$brief            pathname_                     request_id_
requote_string_               sub_err_                      vfile_status_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$inconsistent_msf error_table_$lower_ring       error_table_$moderr           error_table_$namedup
error_table_$no_e_permission  error_table_$no_s_permission  error_table_$noentry
error_table_$unimplemented_version                          error_table_$user_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000337       154 000345       157 000357       158 000362       159 000363       161 000364       163 000373
    164 000376       166 000400       168 000404       171 000423       174 000464       175 000470       176 000473
    177 000476       180 000501       181 000506       183 000507       184 000525       186 000555       187 000617
    191 000636       193 000640       194 000641       195 000666       199 000702       201 000731       204 000753
    206 000761       208 000767       209 000773       214 001033       215 001071       218 001112       219 001123
    221 001142       224 001143       226 001145       227 001171       229 001176       231 001177       232 001235
    234 001240       237 001254       239 001265       241 001271       243 001335       245 001341       249 001352
    252 001412       254 001430       256 001444       258 001445       260 001451       261 001506       265 001522
    268 001540       269 001543       271 001545       273 001551       274 001563       275 001575       278 001576
    279 001623       282 001641       284 001645       286 001654       287 001677       291 001713       293 001740
    297 001754       298 002007       299 002051       302 002065       303 002070       304 002115       307 002131
    308 002137       310 002143       312 002145       314 002146       315 002171       318 002173       319 002217
    321 002233       323 002234       325 002263       328 002277       331 002311       333 002323       336 002332
    337 002334       339 002342       342 002343       347 002351       349 002361       350 002373       353 002411
    357 002412       363 002420       365 002423       366 002444       369 002453       371 002462       372 002466
    377 002527       378 002532       379 002561       381 002577       384 002613       387 002625       388 002656
    390 002674       393 002710       395 002713       396 002751       399 002767       400 003033       403 003051
    405 003060       406 003064       408 003070       410 003076       415 003143       416 003166       419 003175
    421 003200       422 003213       425 003231       428 003244       429 003247       431 003253       433 003260
    435 003265       436 003300       438 003313       442 003314       444 003316       446 003340       449 003355
    450 003404       452 003516       453 003551       456 003567       457 003607       460 003625       462 003630
    463 003635       464 003652       466 003670       467 003671       468 003672       469 003716       472 003723
    473 003730       474 003745       476 003763       478 003766       481 003772       483 004005       485 004017
    487 004020       492 004022       494 004056       497 004057       500 004065       503 004073       504 004104
    505 004120       507 004134       513 004135       519 004143       520 004147       521 004152       524 004156
    527 004303       529 004304       531 004305       540 004326       541 004327       543 004330       546 004351
    547 004353       549 004354       552 004375       553 004377       555 004403       556 004411       558 004414
    561 004530       569 004531       578 004537       580 004565       581 004631       584 004646       587 004653
    588 004701       589 004730       592 004757       593 004762       594 004764       595 005011       597 005025
    599 005064       601 005101       602 005104       605 005111       607 005113       609 005115       610 005143
    613 005160       615 005161       618 005167       621 005172       622 005174       624 005176       625 005231
    626 005234       627 005263       628 005264       629 005313       632 005314       635 005315       638 005325
    642 005346       647 005367       649 005403       652 005417


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
