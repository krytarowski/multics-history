	COMPILATION LISTING OF SEGMENT ms_table_mgr_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1123.38_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style2 */
       12 ms_table_mgr_:
       13      procedure;
       14 
       15 /* Multi-segment table manager for large system tables. */
       16 /* Written by C. Hornig, June 1979. */
       17 /* Modified by C. Hornig, January 1980, for salvager */
       18 /* Modified by B. Margolin, July 1983, for case-insensitive searching */
       19 /* Modified 1984-07-23 BIM for structure redesign. */
       20 /* Modified 1984-07-31 by Eric Swenson to fix various bugs. */
       21 
       22 	declare (
       23 	        (Dirname, Ename)	 character (*),	/* MSF pathname */
       24 	        Create_info_ptr	 pointer,		/* to ms_table_info */
       25 	        Status_ptr		 pointer,		/* to mstb_status */
       26 	        Type		 character (*) aligned,
       27 						/* type of table (for checking) */
       28 	        Tp		 pointer,		/* my data pointer */
       29 	        Hp		 pointer,		/* header pointer */
       30 	        Ne		 fixed bin (35),	/* number of used entries */
       31 	        Key		 character (*),
       32 	        Ep		 pointer,		/* pointer to entry */
       33 	        Record		 fixed bin (35),
       34 	        Code		 fixed (35),
       35 	        Write		 bit (1) aligned,
       36 	        Clock		 fixed bin (35),
       37 	        Locker		 bit (36) aligned,
       38 	        Locked_to_locker	 bit (1) aligned
       39 	        )			 parameter;
       40 
       41 
       42 /* External Static */
       43 
       44 	dcl     error_table_$bad_index fixed bin (35) external static;
       45 	dcl     error_table_$checksum_failure
       46 				 fixed bin (35) external static;
       47 	dcl     error_table_$id_already_exists
       48 				 fixed bin (35) external static;
       49 	dcl     error_table_$id_not_found
       50 				 fixed bin (35) external static;
       51 	dcl     error_table_$inconsistent
       52 				 fixed bin (35) external static;
       53 	dcl     error_table_$invalid_lock_reset
       54 				 fixed bin (35) external;
       55 	dcl     error_table_$locked_by_this_process
       56 				 fixed bin (35) external static;
       57 	dcl     error_table_$namedup	 fixed bin (35) external static;
       58 	dcl     error_table_$no_record fixed bin (35) external static;
       59 	dcl     error_table_$noalloc	 fixed bin (35) external static;
       60 	dcl     error_table_$noentry	 fixed bin (35) external static;
       61 	dcl     error_table_$request_id_ambiguous
       62 				 fixed bin (35) external static;
       63 	dcl     error_table_$unimplemented_version
       64 				 fixed bin (35) external static;
       65 
       66 /* External Entries */
       67 
       68 	declare delete_$path	 entry (character (*), character (*), bit (36) aligned, character (*),
       69 				 fixed binary (35));
       70 	declare hash_index_		 entry (pointer, fixed bin (21), fixed bin (35), fixed bin (35))
       71 				 returns (fixed bin (35));
       72 	declare hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
       73 	declare hcs_$set_max_length_seg
       74 				 entry (pointer, fixed bin (19), fixed bin (35));
       75 
       76 	declare mstb_checksum_$sum_entry
       77 				 entry (ptr, fixed bin (35)) returns (fixed bin (18) unsigned aligned);
       78 	declare mstb_checksum_$check_entry
       79 				 entry (ptr, fixed bin (35), fixed bin (18) unsigned aligned)
       80 				 returns (bit (1) aligned);
       81 
       82 	declare msf_manager_$open	 entry (character (*), character (*), pointer, fixed bin (35));
       83 	declare msf_manager_$get_ptr	 entry (pointer, unsigned fixed bin (18), bit aligned, pointer, fixed bin (24),
       84 				 fixed bin (35));
       85 	declare msf_manager_$msf_get_ptr
       86 				 entry (pointer, fixed binary, bit (1), pointer, fixed binary (24),
       87 				 fixed binary (35));
       88 	declare msf_manager_$close	 entry (pointer);
       89 
       90 	declare set_lock_$lock	 entry (bit (36) aligned, fixed binary, fixed binary (35));
       91 	declare set_lock_$unlock	 entry (bit (36) aligned, fixed binary (35));
       92 
       93 /* Automatic */
       94 
       95 	declare code		 fixed bin (35);
       96 	declare i			 unsigned fixed bin (18);
       97 	declare bc		 fixed bin (24);
       98 	declare component		 unsigned fixed bin (18);
       99 	declare (enum, record)	 fixed bin (35);
      100 	declare now		 fixed bin (71);
      101 	declare case_ins		 bit (1);
      102 	declare tp		 pointer;
      103 	dcl     ignore_mylock	 bit (1) aligned automatic;
      104 	dcl     unlock_when_done	 bit (1) aligned automatic;
      105 
      106 /* Constant */
      107 
      108 	dcl     DONT_IGNORE_MYLOCK	 bit (1) aligned internal static options (constant) initial ("0"b);
      109 
      110 	declare (addr, addrel, clock, divide, max, mod, null, pointer, size, currentize)
      111 				 builtin;
      112 
      113 	declare (cleanup, fixedoverflow)
      114 				 condition;
      115 
      116 
      117 /* * * * * * * * * * CREATE * * * * * * * * * */
      118 
      119 create:
      120      entry (Dirname, Ename, Create_info_ptr, Code);
      121 
      122 /* Create MSF "Path" with characteristics described in ms_table_info. */
      123 
      124 	Code = 0;
      125 
      126 /**** There is no compatability behind V3, since the reformat was pretty
      127*      drastic. */
      128 
      129 	if Create_info_ptr -> ms_table_info.version ^= MS_TABLE_INFO_VERSION_3
      130 	then do;
      131 		Code = error_table_$unimplemented_version;
      132 		return;
      133 	     end;
      134 
      135 	call msf_manager_$open (Dirname, Ename, tp, code);
      136 	if code ^= error_table_$noentry
      137 	then do;
      138 		if code = 0
      139 		then do;
      140 			Code = error_table_$namedup;
      141 			call msf_manager_$close (tp);
      142 		     end;
      143 		else Code = code;
      144 		return;
      145 	     end;
      146 
      147 	call msf_manager_$msf_get_ptr (tp, 0, "1"b, hdrp, bc, code);
      148 						/* create the header */
      149 	if hdrp = null ()
      150 	then do;
      151 		Code = code;
      152 		return;
      153 	     end;
      154 	mt_header.mti = Create_info_ptr -> ms_table_info;
      155 	if mod (mt_header.mti.entry_size, 2) ^= 0
      156 	then mt_header.mti.entry_size = mt_header.mti.entry_size + 1;
      157 	mt_header.used_entries, mt_header.deleted_entries = 0;
      158 	mt_header.entries_per_component = divide (mt_header.max_size - size (comp_header), currentsize (entry), 18);
      159 	mt_header.entry_offset = 1 + divide (size (mt_header) - size (comp_header) - 1, currentsize (entry), 18);
      160 	mt_header.number_components =
      161 	     max (1, divide (mt_header.max_entries + mt_header.entry_offset - 1, mt_header.entries_per_component, 18));
      162 	mt_header.total_entries =
      163 	     (1 + mt_header.number_components) * mt_header.entries_per_component - mt_header.entry_offset;
      164 
      165 	mt_header.lock = ""b;
      166 	mt_header.pclock = 0;
      167 	mt_header.meters = 0;
      168 	mt_header.header.pad = ""b;
      169 	now = clock ();
      170 	do i = 0 to mt_header.number_components;
      171 	     call msf_manager_$get_ptr (tp, i, "1"b, segp, bc, code);
      172 	     if code ^= 0
      173 	     then do;
      174 		     Code = code;
      175 		     return;
      176 		end;
      177 	     comp_header.type = mt_header.mti.type;
      178 	     comp_header.dt_created, comp_header.dt_updated = now;
      179 	     comp_header.component = i;
      180 	     call hcs_$set_max_length_seg (segp, (mt_header.max_size), code);
      181 	     call hcs_$set_bc_seg (segp, 36 * mt_header.max_size, code);
      182 	end;
      183 
      184 	call set_mt_header_check;
      185 	call msf_manager_$close (tp);
      186 RETURN:
      187 	return;
      188 
      189 /* * * * * * * * * DELETE * * * * * * * * * * */
      190 
      191 
      192 delete:
      193      entry (Dirname, Ename, Code);
      194 
      195 	Code = 0;
      196 	string (delete_options) = ""b;
      197 	delete_options.force, delete_options.directory, delete_options.segment, delete_options.raw = "1"b;
      198 
      199 /**** We have to have chased the links already to have validated the suffix */
      200 
      201 	call delete_$path (Dirname, Ename, string (delete_options), "ms_table_mgr_$delete", Code);
      202 	return;
      203 
      204 /* * * * * * * * * * OPEN * * * * * * * * * * */
      205 
      206 open:
      207      entry (Dirname, Ename, Type, Tp, Hp, Code);
      208 
      209 	Code = 0;
      210 	Tp, Hp = null ();
      211 
      212 	call msf_manager_$open (Dirname, Ename, tp, code);
      213 	if tp = null ()
      214 	then do;
      215 		Code = code;
      216 		return;
      217 	     end;
      218 	call get_header;
      219 	if mt_header.version ^= MS_TABLE_INFO_VERSION_3
      220 	then do;
      221 		Code = error_table_$unimplemented_version;
      222 		return;
      223 	     end;
      224 	if (mt_header.mti.type ^= Type) & (Type ^= "")
      225 	then do;
      226 		Code = error_table_$inconsistent;
      227 		return;
      228 	     end;
      229 	Hp = addr (mt_header.header_data);
      230 	Tp = tp;
      231 	return;
      232 
      233 /* * * * * * * * * * VERIFY * * * * * * * * * */
      234 
      235 
      236 /**** Verify, called per-bootload, revalidates all the checksums. 
      237*      It stops at the first problem. It is assumed that the salvager
      238*      is used to make a complete survey of the data. */
      239 
      240 
      241 verify:
      242      entry (Tp, Code);
      243 
      244 	Code = 0;
      245 	tp = Tp;
      246 
      247 	call get_header;				/* This will abort if the header info fails to check */
      248 	do i = 0 to mt_header.number_components;
      249 	     call get_component (i);
      250 	     if comp_header.type ^= mt_header.mti.type | comp_header.component ^= i
      251 		| comp_header.dt_updated ^= mt_header.comp_hdr.dt_updated
      252 	     then do;
      253 		     Code = error_table_$inconsistent;
      254 		     return;
      255 		end;
      256 	end;
      257 	return;
      258 
      259 /* * * * * * * * * * TABLE_INFO * * * * * * * * * * */
      260 
      261 table_data:
      262      entry (Tp, Create_info_ptr, Hp, Ne, Code);
      263 
      264 	Code, Ne = 0;
      265 	Hp = null ();
      266 	tp = Tp;
      267 
      268 	call get_header;
      269 	Create_info_ptr -> ms_table_info = mt_header.mti;
      270 	Hp = pointer (hdrp, size (mt_header));
      271 	Ne = mt_header.used_entries - mt_header.deleted_entries;
      272 	return;
      273 
      274 /* * * * * * * * * * STATUS * * * * * * * * */
      275 
      276 status:
      277      entry (Tp, Status_ptr, Code);
      278 	Code = 0;
      279 	tp = Tp;
      280 	call get_header;
      281 
      282 	if Status_ptr -> mstb_status.version ^= MSTB_STATUS_VERSION_1
      283 	then do;
      284 		Code = error_table_$unimplemented_version;
      285 		return;
      286 	     end;
      287 
      288 	Status_ptr -> mstb_status = mt_header.header, by name;
      289 	Status_ptr -> mstb_status.version = MSTB_STATUS_VERSION_1;
      290 						/* vapped by by-name */
      291 	return;
      292 
      293 /* * * * * * * * * * CLOSE * * * * * * * * * */
      294 
      295 close:
      296      entry (Tp, Code);
      297 
      298 	Code = 0;
      299 	tp = Tp;
      300 
      301 	call msf_manager_$close (tp);
      302 	return;
      303 
      304 /* * * * * * * * * * NEW_ENTRY_IGNORE_MYLOCK * * * * * * * * * */
      305 
      306 /**** Same as NEW__ENTRY below, but does not error return on mylock error.*/
      307 
      308 new_entry_ignore_mylock:
      309      entry (Tp, Key, Ep, Code);
      310 
      311 	ignore_mylock = "1"b;
      312 	goto NEW_ENTRY_JOIN;
      313 
      314 /* * * * * * * * * * NEW_ENTRY * * * * * * * * * */
      315 
      316 /**** A new-entry will be filled in and returned to us with a call to
      317*      update_entry. */
      318 
      319 new_entry:
      320      entry (Tp, Key, Ep, Code);
      321 
      322 	ignore_mylock = "0"b;
      323 
      324 NEW_ENTRY_JOIN:
      325 	Code = 0;
      326 	Ep = null ();
      327 	tp = Tp;
      328 
      329 	call get_header;				/* Must get header before calling lock */
      330 
      331 	on cleanup call unlock ();
      332 	call lock (ignore_mylock);
      333 	if code ^= 0
      334 	then do;
      335 		Code = code;
      336 		return;
      337 	     end;
      338 
      339 	if hash_search (Key, "0"b)
      340 	then do;
      341 		Code = error_table_$id_already_exists;
      342 		go to NEW_ENTRY_UNLOCK_RETURN;
      343 	     end;
      344 
      345 	if ep = null ()
      346 	then do;
      347 		Code = error_table_$noalloc;
      348 		go to NEW_ENTRY_UNLOCK_RETURN;
      349 	     end;
      350 
      351 /**** Past here we will not unlock the lock */
      352 
      353 	entry.key = Key;
      354 	entry.inconsistent,				/* checksum will fail, its not set */
      355 	     entry.used = "1"b;
      356 	mt_header.used_entries = mt_header.used_entries + 1;
      357 	call set_checkpoint;
      358 	Ep = addr (entry.entry_data);
      359 	return;
      360 
      361 NEW_ENTRY_UNLOCK_RETURN:
      362 	call unlock;
      363 	return;
      364 
      365 /* * * * * * * * * * FIND_ENTRY * * * * * * * * * */
      366 
      367 find_entry:
      368      entry (Tp, Key, Ep, Write, Clock, Code);
      369 
      370 	case_ins = "0"b;
      371 	go to FIND_ENTRY_COMMON;
      372 
      373 find_entry_case_ins:
      374      entry (Tp, Key, Ep, Write, Clock, Code);
      375 
      376 	case_ins = "1"b;
      377 
      378 FIND_ENTRY_COMMON:
      379 	Code = 0;
      380 	Ep = null ();
      381 	tp = Tp;
      382 
      383 	call get_header;
      384 	if Write
      385 	then do;
      386 		call lock (DONT_IGNORE_MYLOCK);
      387 		if code ^= 0
      388 		then do;
      389 			Code = code;
      390 			return;
      391 		     end;
      392 	     end;
      393 	else Clock = mt_header.pclock;
      394 
      395 	if ^hash_search (Key, case_ins)
      396 	then do;
      397 		Code = error_table_$id_not_found;
      398 		go to FIND_ERROR_RETURN;
      399 	     end;
      400 	if ep = null ()
      401 	then do;					/* Ambiguous */
      402 		Code = error_table_$request_id_ambiguous;
      403 		go to FIND_ERROR_RETURN;
      404 	     end;
      405 
      406 	begin;
      407 	     dcl	   1 copy_entry	      aligned like entry automatic;
      408 
      409 	     copy_entry = ep -> entry;
      410 	     copy_entry.checksum = 0;
      411 
      412 	     if ^mstb_checksum_$check_entry (addr (copy_entry), divide (currentsize (entry), 2, 35, 0),
      413 		(entry.checksum))
      414 	     then Code = error_table_$checksum_failure;
      415 	end;
      416 
      417 	if Write
      418 	then entry.inconsistent = "1"b;
      419 	Ep = addr (entry.entry_data);
      420 	return;
      421 
      422 FIND_ERROR_RETURN:
      423 	if Write
      424 	then call unlock;
      425 	return;
      426 
      427 /* * * * * * * * * * DELETE_ENTRY_IGNORE_MYLOCK * * * * * * * * * */
      428 
      429 delete_entry_ignore_mylock:
      430      entry (Tp, Key, Code);
      431 
      432 	ignore_mylock = "1"b;
      433 	goto DELETE_ENTRY_JOIN;
      434 
      435 /* * * * * * * * * * DELETE_ENTRY * * * * * * * * * */
      436 
      437 delete_entry:
      438      entry (Tp, Key, Code);
      439 
      440 	ignore_mylock = "0"b;
      441 
      442 DELETE_ENTRY_JOIN:
      443 	Code = 0;
      444 	tp = Tp;
      445 
      446 	call get_header;
      447 	on cleanup call unlock;
      448 	call lock (ignore_mylock);
      449 	if code ^= 0
      450 	then do;
      451 		Code = code;
      452 		return;
      453 	     end;
      454 	if ^hash_search (Key, "0"b)
      455 	then do;
      456 		Code = error_table_$id_not_found;
      457 		goto DELETE_ENTRY_UNLOCK_RETURN;
      458 	     end;
      459 
      460 	entry.deleted = "1"b;
      461 	entry.checksum = 0;
      462 	entry.checksum = mstb_checksum_$sum_entry (ep, divide (currentsize (entry), 2, 35, 0));
      463 	mt_header.deleted_entries = mt_header.deleted_entries + 1;
      464 
      465 	call set_checkpoint;
      466 
      467 DELETE_ENTRY_UNLOCK_RETURN:
      468 	call unlock ();
      469 	return;
      470 
      471 /* * * * * * * * * * ABS_ENTRY * * * * * * * ** * */
      472 
      473 abs_entry:
      474      entry (Tp, Record, Key, Write, Ep, Clock, Code);
      475 
      476 	Code = 0;
      477 	Ep = null ();
      478 	Key = "";
      479 	tp = Tp;
      480 
      481 	call get_header;
      482 	if Write
      483 	then do;
      484 		on cleanup call unlock;
      485 		call lock (DONT_IGNORE_MYLOCK);
      486 		if code ^= 0
      487 		then do;
      488 			Code = code;
      489 			return;
      490 		     end;
      491 	     end;
      492 	else Clock = mt_header.pclock;
      493 
      494 	record = Record - 1;
      495 	if record + mt_header.entry_offset >= mt_header.total_entries
      496 	then do;
      497 		Code = error_table_$bad_index;
      498 		go to FIND_ERROR_RETURN;
      499 	     end;
      500 	call get_entry (record);
      501 	if entry.deleted | ^entry.used
      502 	then do;
      503 		Code = error_table_$no_record;
      504 		go to FIND_ERROR_RETURN;
      505 	     end;
      506 	begin;
      507 
      508 	     dcl	   1 copy_entry	      aligned like entry automatic;
      509 
      510 	     copy_entry = ep -> entry;
      511 	     copy_entry.checksum = 0;
      512 
      513 	     if ^mstb_checksum_$check_entry (addr (copy_entry), divide (currentsize (entry), 2, 35, 0),
      514 		(entry.checksum))
      515 	     then Code = error_table_$checksum_failure;
      516 	end;
      517 
      518 	Ep = addr (entry.entry_data);
      519 	Key = entry.key;
      520 	if Write
      521 	then entry.inconsistent = "1"b;
      522 	return;
      523 
      524 /* * * * * * * * * * UPDATE_ENTRY_DONT_UNLOCK * * * * * * * * * */
      525 
      526 update_entry_dont_unlock:
      527      entry (Tp, Ep, Code);
      528 
      529 	unlock_when_done = "0"b;
      530 	goto UPDATE_ENTRY_JOIN;
      531 
      532 /* * * * * * * * * * UPDATE_ENTRY * * * * * * * * * * */
      533 
      534 update_entry:
      535      entry (Tp, Ep, Code);
      536 
      537 	unlock_when_done = "1"b;
      538 
      539 UPDATE_ENTRY_JOIN:
      540 	tp = Tp;
      541 	Code = 0;
      542 	call get_header;
      543 
      544 /* Uk. We have to turn one of their ep's into one of ours. */
      545 
      546 	begin;
      547 	     declare 1 dummy_entry	      aligned like entry;
      548 	     ep = addwordno (Ep, -(wordno (addr (dummy_entry.entry_data)) - wordno (addr (dummy_entry))));
      549 	end;
      550 
      551 /**** Null out the caller-supplied Ep so that caller will not unknowingly
      552*      update the entry after our checksum has been calculated. */
      553 
      554 	Ep = null ();
      555 
      556 	entry.inconsistent = "0"b;
      557 	entry.checksum = 0;
      558 	entry.checksum = mstb_checksum_$sum_entry (ep, divide (currentsize (entry), 2, 35, 0));
      559 	call set_checkpoint;
      560 	if unlock_when_done
      561 	then call unlock ();
      562 	return;
      563 
      564 
      565 lock:
      566      entry (Tp, Code);
      567 
      568 	tp = Tp;
      569 	Code = 0;
      570 	call get_header;
      571 	call lock (DONT_IGNORE_MYLOCK);
      572 	Code = code;
      573 	return;
      574 
      575 
      576 unlock:
      577      entry (Tp, Code);
      578 
      579 	tp = Tp;
      580 	Code = 0;
      581 	call get_header;
      582 	call unlock;
      583 	return;
      584 
      585 check_lock:
      586      entry (Dirname, Ename, Locker, Locked_to_locker);
      587 
      588 	/*** WARNING - if we make set_lock_ use the HC, this will need to be changed. */
      589 
      590 	Locked_to_locker = "0"b;
      591 	call open (Dirname, Ename, "", tp, hdrp, code);
      592 	if code ^= 0
      593 	then return;				/* broken table */
      594 	if Locker = mt_header.lock
      595 	then do;
      596 		Locked_to_locker = "1"b;
      597 		call unlock;
      598 	     end;
      599 	call close (tp, (0));			/* if there is a static opening it will be undisturbed. */
      600 	return;
      601 
      602 get_change_clock:
      603      entry (Tp, Clock, Code);
      604 
      605 	tp = Tp;
      606 	Code = 0;
      607 	call get_header;
      608 	Clock = mt_header.pclock;
      609 	return;
      610 
      611 
      612 /* * * * * * * * * * GET_HEADER * * * * * * * * * */
      613 
      614 get_header:
      615      procedure;
      616 
      617 	call msf_manager_$get_ptr (tp, 0, "0"b, hdrp, bc, code);
      618 	if hdrp = null ()
      619 	then do;
      620 		Code = code;
      621 		goto RETURN;
      622 	     end;
      623 	segp = hdrp;
      624 	component = 0;
      625 	call check_mt_header_check;			/* aborts us on error */
      626      end;
      627 
      628 /* * * * * * * * * * GET_COMPONENT * * * * * * * * * * */
      629 
      630 get_component:
      631      procedure (Component);
      632 
      633 	declare Component		 unsigned fixed bin (18) parameter;
      634 
      635 	component = Component;
      636 	call msf_manager_$get_ptr (tp, component, "0"b, segp, bc, code);
      637 	if segp = null ()
      638 	then do;
      639 		Code = code;
      640 		goto RETURN;
      641 	     end;
      642 	return;
      643      end;
      644 
      645 /* * * * * * * * * * SET_CHECKPOINT * * * * * * * * * */
      646 
      647 set_checkpoint:
      648      procedure;
      649 
      650 	declare now		 fixed bin (71);
      651 
      652 	now = clock ();
      653 	do i = 0 to mt_header.number_components;
      654 	     call get_component (i);
      655 	     comp_header.dt_updated = now;
      656 	end;
      657 	on fixedoverflow
      658 	     begin;
      659 		mt_header.pclock = 1;
      660 		go to SET_CLOCK;
      661 	     end;
      662 (fixedoverflow):
      663 	mt_header.pclock = mt_header.pclock + 1;
      664 SET_CLOCK:
      665 	return;
      666      end set_checkpoint;
      667 
      668 /* * * * * * * * * * HASH_SEARCH * * * * * * * * * */
      669 
      670 hash_search:
      671      procedure (Key, Case_ins) returns (bit aligned);
      672 
      673 	declare (
      674 	        Key		 character (*),
      675 	        Case_ins		 bit (1)
      676 	        )			 parameter;
      677 	declare (hash_key, match_key)	 character (32) aligned;
      678 	declare (found_one, case_ins)	 bit (1);
      679 	declare save_ep		 ptr;
      680 	declare hash		 fixed bin (35);
      681 	declare saved_clock		 fixed bin (35);
      682 
      683 	hash_key = lowercase (Key);
      684 	case_ins = Case_ins;
      685 	if case_ins
      686 	then match_key = hash_key;			/* Lowercase */
      687 	else match_key = Key;			/* Normal */
      688 
      689 	hash = hash_index_ (addr (hash_key), 32, 1, mt_header.total_entries);
      690 
      691 	if mt_header.keep_meters
      692 	then mt_header.meters.searches = mt_header.meters.searches + 1;
      693 
      694 RETRY:
      695 	saved_clock = mt_header.pclock;
      696 	found_one = "0"b;
      697 	save_ep = null ();
      698 	do enum = hash to mt_header.total_entries - mt_header.entry_offset - 1, 0 to hash - 1;
      699 	     call get_entry (enum);
      700 
      701 	     if mt_header.keep_meters
      702 	     then mt_header.meters.entries_examined = mt_header.meters.entries_examined + 1;
      703 	     if ^entry.used
      704 	     then do;				/* End of hash bucket */
      705 		     if case_ins & found_one
      706 		     then do;
      707 			     ep = save_ep;
      708 			     go to RETURN_1;
      709 			end;
      710 		     goto RETURN_0;
      711 		end;
      712 	     if ^entry.deleted
      713 	     then do;
      714 		     if case_ins
      715 		     then do;			/* Case-insensitive match */
      716 			     if lowercase (entry.key) = match_key
      717 			     then if found_one
      718 				then do;
      719 					ep = null ();
      720 						/* This nonsense combination */
      721 					go to RETURN_1;
      722 						/* indicates ambiguous match */
      723 				     end;
      724 				else do;
      725 					found_one = "1"b;
      726 					save_ep = ep;
      727 						/* Save for later */
      728 				     end;
      729 			end;			/* Case-sensitive match */
      730 		     else if entry.key = match_key
      731 		     then go to RETURN_1;
      732 		end;
      733 	end;
      734 	if found_one
      735 	then do;
      736 		ep = save_ep;
      737 		go to RETURN_1;
      738 	     end;
      739 	else do;
      740 		ep = null ();
      741 		go to RETURN_0;
      742 	     end;
      743 
      744 RETURN_0:
      745 	if saved_clock ^= mt_header.pclock
      746 	then go to RETRY;
      747 	return ("0"b);
      748 RETURN_1:
      749 	if saved_clock ^= mt_header.pclock
      750 	then go to RETRY;
      751 	return ("1"b);
      752 
      753 lowercase:
      754      proc (String) returns (char (32)) reducible;
      755 
      756 	dcl     String		 char (*) parameter;
      757 	dcl     (
      758 	        LOWER		 init ("abcdefghijklmnopqrstuvwxyz"),
      759 	        UPPER		 init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
      760 	        )			 char (26) int static options (constant);
      761 	dcl     translate		 builtin;
      762 
      763 	return (translate (String, LOWER, UPPER));
      764 
      765      end lowercase;
      766 
      767 
      768      end hash_search;
      769 
      770 /* * * * * * * * * * GET_ENTRY * * * * * * * * * */
      771 
      772 get_entry:
      773      procedure (Enum);
      774 
      775 	declare Enum		 fixed bin (35) parameter;
      776 	declare enum		 fixed bin (35);
      777 	declare ecomp		 unsigned fixed bin (18);
      778 
      779 	enum = Enum + mt_header.entry_offset;
      780 	ecomp = divide (enum, mt_header.entries_per_component, 18);
      781 	if ecomp ^= component
      782 	then call get_component (ecomp);
      783 	ep = pointer (segp, size (comp_header) + (currentsize (entry)) * mod (enum, mt_header.entries_per_component));
      784      end get_entry;
      785 
      786 lock:
      787      procedure (P_ignore_mylock);
      788 
      789 	dcl     P_ignore_mylock	 bit (1) aligned parameter;
      790 
      791 	call set_lock_$lock (mt_header.lock, 5, code);
      792 	if (code = error_table_$locked_by_this_process & P_ignore_mylock) | code = error_table_$invalid_lock_reset
      793 	then code = 0;
      794 	return;
      795      end lock;
      796 
      797 unlock:
      798      procedure;
      799 
      800 	call set_lock_$unlock (mt_header.lock, code);
      801 	return;
      802      end unlock;
      803 
      804 set_mt_header_check:
      805      procedure;
      806 
      807 	mt_header.perm_data_checksum = mt_header_check ();
      808 	return;
      809      end set_mt_header_check;
      810 
      811 mt_header_check:
      812      procedure returns (fixed bin (35));
      813 
      814 	return (mt_header.number_components + mt_header.entries_per_component + mt_header.entry_offset
      815 	     + mt_header.total_entries + mt_header.header_size + mt_header.entry_size);
      816      end mt_header_check;
      817 
      818 check_mt_header_check:
      819      procedure;
      820 
      821 	if mt_header.perm_data_checksum ^= mt_header_check ()
      822 	then do;
      823 		Code = error_table_$inconsistent;
      824 		go to RETURN;
      825 	     end;
      826      end check_mt_header_check;
      827 
      828 /* format: off */
  1     1 /* Begin include file ms_table_info.incl.pl1 */
  1     2 /* Written by C. Hornig, June 1979 */
  1     3 /* Modified by B. Margolin, July 1983, for version 2 */
  1     4 /* Modified 1984-07-24 BIM for V3, improved hash, checksums */
  1     5 
  1     6 /* This information is passed to ms_table_mgr_$create when a multi-segment
  1     7*   table is created. */
  1     8 
  1     9 /* format: style3 */
  1    10 
  1    11 declare	MS_TABLE_INFO_VERSION_3
  1    12 			fixed init (3) internal static options (constant);
  1    13 
  1    14 declare	1 ms_table_info	aligned based,
  1    15 	  2 version	fixed,			/* Should be 3 */
  1    16 	  2 type		character (32),		/* what table is this? */
  1    17 	  2 (
  1    18 	  header_size,				/* length of table header in words */
  1    19 	  entry_size
  1    20 	  )		unsigned fixed (18),	/* same for table entries */
  1    21 	  2 max_entries	unsigned fixed bin (18),	/* how many entries */
  1    22 	  2 max_size	fixed bin (19),		/* max segment length */
  1    23 	  2 keep_meters	bit (1) aligned;		/* table is writable to readers */
  1    24 
  1    25 /* End include file ms_table_info.incl.pl1 */
      829 
  2     1 
  2     2 /* format: style3 */
  2     3 
  2     4 /**** Statictics from an mstb that the manager thereof 
  2     5*      might need to know. */
  2     6 
  2     7 declare	mstb_status_ptr	pointer;
  2     8 declare	1 mstb_status	aligned based (mstb_status_ptr),
  2     9 	  2 version	fixed bin,
  2    10 	  2 (total_entries, deleted_entries, used_entries)
  2    11 			fixed bin (35),
  2    12 	  2 meters,
  2    13 	    3 searches	fixed bin (35),
  2    14 	    3 entries_examined
  2    15 			fixed bin (35);
  2    16 
  2    17 declare	MSTB_STATUS_VERSION_1
  2    18 			fixed bin init (1) int static options (constant);
  2    19 
  2    20 /* End include file ms_table_status.incl.pl1 */
      830 
  3     1 /* Begin include file mstb_format.incl.pl1 */
  3     2 
  3     3 /* Modified 1984-07-23 BIM for V3: new hash function, checksums. */
  3     4 /* Modified 1984-08-08 EJS to make comp_header an even number of
  3     5*   words long.  This is required so that MSTB entries end up on
  3     6*   an even word boundary. */
  3     7 
  3     8 /* format: style3 */
  3     9 
  3    10 /***** NOTE NOTE NOTE
  3    11*
  3    12*       These tables have locks. Otherwise, checksum calculation
  3    13*       would be an incredible complexity.
  3    14*
  3    15*       It could, however be done. If the AS is split into multiple
  3    16*       processes, the following can be done:
  3    17*
  3    18*       1)    use stacq to maintain counters. 
  3    19*       2)    use entry locks on the individual entries.
  3    20*       3)    use the pclocks on the components 
  3    21*             to validate checksum entries. 
  3    22*
  3    23*       With any luck, we will have FAMIS files at our disposal
  3    24*       by the time the AS splits, and all of this will be 
  3    25*       unnecessary.
  3    26*
  3    27*       --BIM 1984-07-23 */
  3    28 
  3    29 declare	(hdrp, segp, ep)	pointer;
  3    30 
  3    31 declare	1 mt_header	aligned based (hdrp),
  3    32 	  2 header	aligned,			/* data mstb_mgr_ owns */
  3    33 	    3 comp_hdr	aligned like comp_header,
  3    34 	    3 lock	bit (36) aligned,		/* file lock */
  3    35 	    3 pclock	fixed bin (35),		/* change count, used for passive locking */
  3    36 	    3 mti		aligned like ms_table_info,
  3    37 	    3 (number_components, entries_per_component, entry_offset)
  3    38 			unsigned fixed binary (18),
  3    39 	    3 (total_entries, deleted_entries, used_entries)
  3    40 			fixed binary (35),
  3    41 	    3 perm_data_checksum
  3    42 			fixed bin (35),		/* sum of n_components, entries_per_component, entry_offset, total_entries, header_size, entry_size */
  3    43 	    3 meters,				/* only maintained if mti.keep_meters is on */
  3    44 	      4 searches	fixed binary (35),
  3    45 	      4 entries_examined
  3    46 			fixed binary (35),
  3    47 	    3 pad		(12) bit (36) aligned,	/* 50 words to end of this */
  3    48 	  2 header_data	(0 refer (mt_header.mti.header_size)) bit (36) aligned;
  3    49 
  3    50 declare	1 comp_header	aligned based (segp),	/* 16 words */
  3    51 	  2 type		character (32),
  3    52 	  2 (dt_created, dt_updated)
  3    53 			fixed binary (71),
  3    54 	  2 component	unsigned fixed binary (18),
  3    55 	  2 pad (3) bit (36); /* Pad out to 16 words. */
  3    56 
  3    57 declare	1 entry		aligned based (ep),		/* 10 + entry size */
  3    58 	  2 header	aligned,
  3    59 	    3 flags	unaligned,
  3    60 	      4 (used, deleted, inconsistent)
  3    61 			bit (1),
  3    62 	      4 pad	bit (15),
  3    63 	    3 checksum	fixed bin (18) unsigned unaligned,
  3    64 						/* checksums ENTIRE entry, including header */
  3    65 	    3 lock	bit (36) aligned,		/* unused for now */
  3    66 	    3 key		character (32) unaligned,
  3    67 	  2 entry_data	(mt_header.mti.entry_size) bit (36) aligned;
  3    68 
  3    69 
  3    70 
  3    71 /* End include file mstb_format.incl.pl1 */
      831 
  4     1 /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  4     2 
  4     3 /* control flag bit string passed to delete_$path and delete_$ptr
  4     4*
  4     5*   Jay Pattin 6/6/83 */
  4     6 
  4     7 declare   1 delete_options,
  4     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  4     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  4    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  4    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  4    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  4    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  4    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  4    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  4    16           2 mbz                         bit (28) unaligned;
  4    17 
  4    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
      832 
      833 /* format: on */
      834 
      835      end ms_table_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1123.3  ms_table_mgr_.pl1                 >udd>sm>ds>w>ml>ms_table_mgr_.pl1
829          1    12/07/84  1202.1  ms_table_info.incl.pl1            >ldd>incl>ms_table_info.incl.pl1
830          2    12/07/84  1201.4  ms_table_status.incl.pl1          >ldd>incl>ms_table_status.incl.pl1
831          3    12/07/84  1202.2  mstb_format.incl.pl1              >ldd>incl>mstb_format.incl.pl1
832          4    10/14/83  1706.7  delete_options.incl.pl1           >ldd>incl>delete_options.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Case_ins                               parameter       bit(1)                   packed unaligned dcl 673 ref 670 684
Clock                                  parameter       fixed bin(35,0)          dcl 22 set ref 367 373 393* 473 492* 602 608*
Code                                   parameter       fixed bin(35,0)          dcl 22 set ref 119 124* 131* 140* 143* 151* 174* 192
                                                                                  195* 201* 206 209* 215* 221* 226* 241 244* 253*
                                                                                  261 264* 276 278* 284* 295 298* 308 319 324* 335*
                                                                                  341* 347* 367 373 378* 389* 397* 402* 412* 429 437
                                                                                  442* 451* 456* 473 476* 488* 497* 503* 513* 526
                                                                                  534 541* 565 569* 572* 576 580* 602 606* 620* 639*
                                                                                  823*
Component                              parameter       fixed bin(18,0)          unsigned dcl 633 ref 630 635
Create_info_ptr                        parameter       pointer                  dcl 22 ref 119 129 154 261 269
DONT_IGNORE_MYLOCK                     constant        bit(1)                   initial dcl 108 set ref 386* 485* 571*
Dirname                                parameter       char                     packed unaligned dcl 22 set ref 119 135* 192 201*
                                                                                  206 212* 585 591*
Ename                                  parameter       char                     packed unaligned dcl 22 set ref 119 135* 192 201*
                                                                                  206 212* 585 591*
Enum                                   parameter       fixed bin(35,0)          dcl 775 ref 772 779
Ep                                     parameter       pointer                  dcl 22 set ref 308 319 326* 358* 367 373 380* 419*
                                                                                  473 477* 518* 526 534 548 554*
Hp                                     parameter       pointer                  dcl 22 set ref 206 210* 229* 261 265* 270*
Key                                    parameter       char                     packed unaligned dcl 673 in procedure "hash_search"
                                                                                  set ref 670 683* 687
Key                                    parameter       char                     packed unaligned dcl 22 in procedure "ms_table_mgr_"
                                                                                  set ref 308 319 339* 353 367 373 395* 429 437 454*
                                                                                  473 478* 519*
LOWER                           000007 constant        char(26)                 initial packed unaligned dcl 757 ref 763
Locked_to_locker                       parameter       bit(1)                   dcl 22 set ref 585 590* 596*
Locker                                 parameter       bit(36)                  dcl 22 ref 585 594
MSTB_STATUS_VERSION_1                  constant        fixed bin(17,0)          initial dcl 2-17 ref 282 289
MS_TABLE_INFO_VERSION_3                constant        fixed bin(17,0)          initial dcl 1-11 ref 129 219
Ne                                     parameter       fixed bin(35,0)          dcl 22 set ref 261 264* 271*
P_ignore_mylock                        parameter       bit(1)                   dcl 789 ref 786 792
Record                                 parameter       fixed bin(35,0)          dcl 22 ref 473 494
Status_ptr                             parameter       pointer                  dcl 22 ref 276 282 288 289
String                                 parameter       char                     packed unaligned dcl 756 ref 753 763
Tp                                     parameter       pointer                  dcl 22 set ref 206 210* 230* 241 245 261 266 276 279
                                                                                  295 299 308 319 327 367 373 381 429 437 444 473
                                                                                  479 526 534 539 565 568 576 579 602 605
Type                                   parameter       char                     dcl 22 ref 206 224 224
UPPER                           000000 constant        char(26)                 initial packed unaligned dcl 757 ref 763
Write                                  parameter       bit(1)                   dcl 22 ref 367 373 384 417 422 473 482 520
addr                                                   builtin function         dcl 110 ref 229 358 412 412 419 513 513 518 548 548
                                                                                  689 689
bc                              000102 automatic       fixed bin(24,0)          dcl 97 set ref 147* 171* 617* 636*
case_ins                        000215 automatic       bit(1)                   packed unaligned dcl 678 in procedure "hash_search"
                                                                                  set ref 684* 685 705 714
case_ins                        000110 automatic       bit(1)                   packed unaligned dcl 101 in procedure
                                                                                  "ms_table_mgr_" set ref 370* 376* 395*
checksum                  0(18)        based           fixed bin(18,0)          level 3 in structure "entry" packed packed unsigned
                                                                                  unaligned dcl 3-57 in procedure "ms_table_mgr_"
                                                                                  set ref 412 461* 462* 513 557* 558*
checksum                  0(18) 000100 automatic       fixed bin(18,0)          level 3 in structure "copy_entry" packed packed
                                                                                  unsigned unaligned dcl 508
                                                                                  in begin block on line 506 set ref 511*
checksum                  0(18) 000100 automatic       fixed bin(18,0)          level 3 in structure "copy_entry" packed packed
                                                                                  unsigned unaligned dcl 407
                                                                                  in begin block on line 406 set ref 410*
cleanup                         000116 stack reference condition                dcl 113 ref 331 447 484
clock                                                  builtin function         dcl 110 ref 169 652
code                            000100 automatic       fixed bin(35,0)          dcl 95 set ref 135* 136 138 143 147* 151 171* 172
                                                                                  174 180* 181* 212* 215 333 335 387 389 449 451 486
                                                                                  488 572 591* 592 617* 620 636* 639 791* 792 792
                                                                                  792* 800*
comp_hdr                               based           structure                level 3 dcl 3-31
comp_header                            based           structure                level 1 dcl 3-50 set ref 158 159 783
component                14            based           fixed bin(18,0)          level 2 in structure "comp_header" unsigned dcl 3-50
                                                                                  in procedure "ms_table_mgr_" set ref 179* 250
component                       000103 automatic       fixed bin(18,0)          unsigned dcl 98 in procedure "ms_table_mgr_" set ref
                                                                                  624* 635* 636* 781
copy_entry                      000100 automatic       structure                level 1 dcl 508 in begin block on line 506 set ref
                                                                                  510* 513 513
copy_entry                      000100 automatic       structure                level 1 dcl 407 in begin block on line 406 set ref
                                                                                  409* 412 412
delete_$path                    000042 constant        entry                    external dcl 68 ref 201
delete_options                  000132 automatic       structure                level 1 packed packed unaligned dcl 4-7 set ref 196*
                                                                                  201 201
deleted                   0(01)        based           bit(1)                   level 4 packed packed unaligned dcl 3-57 set ref
                                                                                  460* 501 712
deleted_entries          44            based           fixed bin(35,0)          level 3 dcl 3-31 set ref 157* 271 463* 463
directory                 0(02) 000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 4-7 set ref 197*
divide                                                 builtin function         dcl 110 ref 158 159 160 412 412 462 462 513 513 558
                                                                                  558 780
dt_created               10            based           fixed bin(71,0)          level 2 dcl 3-50 set ref 178*
dt_updated               12            based           fixed bin(71,0)          level 4 in structure "mt_header" dcl 3-31
                                                                                  in procedure "ms_table_mgr_" ref 250
dt_updated               12            based           fixed bin(71,0)          level 2 in structure "comp_header" dcl 3-50
                                                                                  in procedure "ms_table_mgr_" set ref 178* 250 655*
dummy_entry                     000100 automatic       structure                level 1 dcl 547 set ref 548
ecomp                           000245 automatic       fixed bin(18,0)          unsigned dcl 777 set ref 780* 781 781*
entries_examined         50            based           fixed bin(35,0)          level 4 dcl 3-31 set ref 701* 701
entries_per_component
                         41            based           fixed bin(18,0)          level 3 unsigned dcl 3-31 set ref 158* 160 162 780
                                                                                  783 814
entry                                  based           structure                level 1 dcl 3-57 set ref 158 159 409 412 412 462 462
                                                                                  510 513 513 558 558 783
entry_data               12            based           bit(36)                  array level 2 dcl 3-57 set ref 358 419 518
entry_offset             42            based           fixed bin(18,0)          level 3 unsigned dcl 3-31 set ref 159* 160 162 495
                                                                                  698 779 814
entry_size               34            based           fixed bin(18,0)          level 4 unsigned dcl 3-31 set ref 155 155* 155 158
                                                                                  159 407 409 412 412 462 462 508 510 513 513 547
                                                                                  558 558 783 814
enum                            000104 automatic       fixed bin(35,0)          dcl 99 in procedure "ms_table_mgr_" set ref 698*
                                                                                  699*
enum                            000244 automatic       fixed bin(35,0)          dcl 776 in procedure "get_entry" set ref 779* 780
                                                                                  783
ep                              000130 automatic       pointer                  dcl 3-29 set ref 158 159 345 353 354 354 358 400 409
                                                                                  412 412 412 417 419 460 461 462 462* 462 462 501
                                                                                  501 510 513 513 513 518 519 520 548* 556 557 558
                                                                                  558* 558 558 703 707* 712 716 719* 726 730 736*
                                                                                  740* 783* 783
error_table_$bad_index          000010 external static fixed bin(35,0)          dcl 44 ref 497
error_table_$checksum_failure   000012 external static fixed bin(35,0)          dcl 45 ref 412 513
error_table_$id_already_exists  000014 external static fixed bin(35,0)          dcl 47 ref 341
error_table_$id_not_found       000016 external static fixed bin(35,0)          dcl 49 ref 397 456
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 51 ref 226 253 823
error_table_$invalid_lock_reset 000022 external static fixed bin(35,0)          dcl 53 ref 792
error_table_$locked_by_this_process
                                000024 external static fixed bin(35,0)          dcl 55 ref 792
error_table_$namedup            000026 external static fixed bin(35,0)          dcl 57 ref 140
error_table_$no_record          000030 external static fixed bin(35,0)          dcl 58 ref 503
error_table_$noalloc            000032 external static fixed bin(35,0)          dcl 59 ref 347
error_table_$noentry            000034 external static fixed bin(35,0)          dcl 60 ref 136
error_table_$request_id_ambiguous
                                000036 external static fixed bin(35,0)          dcl 61 ref 402
error_table_$unimplemented_version
                                000040 external static fixed bin(35,0)          dcl 63 ref 131 221 284
fixedoverflow                   000000 stack reference condition                dcl 113 ref 657
flags                                  based           structure                level 3 packed packed unaligned dcl 3-57
force                           000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 4-7 set ref 197*
found_one                       000214 automatic       bit(1)                   packed unaligned dcl 678 set ref 696* 705 716 725*
                                                                                  734
hash                            000220 automatic       fixed bin(35,0)          dcl 680 set ref 689* 698 698
hash_index_                     000044 constant        entry                    external dcl 70 ref 689
hash_key                        000174 automatic       char(32)                 dcl 677 set ref 683* 685 689 689
hcs_$set_bc_seg                 000046 constant        entry                    external dcl 72 ref 181
hcs_$set_max_length_seg         000050 constant        entry                    external dcl 73 ref 180
hdrp                            000124 automatic       pointer                  dcl 3-29 set ref 147* 149 154 155 155 155 157 157
                                                                                  158 158 158 159 159 159 160 160 160 160 162 162
                                                                                  162 162 165 166 167 168 170 177 180 181 219 224
                                                                                  229 248 250 250 269 270 270 271 271 288 356 356
                                                                                  393 407 409 412 412 462 462 463 463 492 495 495
                                                                                  508 510 513 513 547 558 558 591* 594 608 617* 618
                                                                                  623 653 659 662 662 689 691 691 691 694 698 698
                                                                                  701 701 701 744 748 779 780 783 783 791 800 807
                                                                                  814 814 814 814 814 814 821
header                          000100 automatic       structure                level 2 in structure "copy_entry" dcl 407
                                                                                  in begin block on line 406
header                                 based           structure                level 2 in structure "mt_header" dcl 3-31
                                                                                  in procedure "ms_table_mgr_" set ref 288
header                                 based           structure                level 2 in structure "entry" dcl 3-57 in procedure
                                                                                  "ms_table_mgr_"
header                          000100 automatic       structure                level 2 in structure "copy_entry" dcl 508
                                                                                  in begin block on line 506
header_data              65            based           bit(36)                  array level 2 dcl 3-31 set ref 229
header_size              33            based           fixed bin(18,0)          level 4 unsigned dcl 3-31 set ref 814
i                               000101 automatic       fixed bin(18,0)          unsigned dcl 96 set ref 170* 171* 179* 248* 249*
                                                                                  250* 653* 654*
ignore_mylock                   000114 automatic       bit(1)                   dcl 103 set ref 311* 322* 332* 432* 440* 448*
inconsistent              0(02)        based           bit(1)                   level 4 packed packed unaligned dcl 3-57 set ref
                                                                                  354* 417* 520* 556*
keep_meters              37            based           bit(1)                   level 4 dcl 3-31 set ref 691 701
key                       2            based           char(32)                 level 3 packed packed unaligned dcl 3-57 set ref
                                                                                  353* 519 716* 730
lock                     20            based           bit(36)                  level 3 dcl 3-31 set ref 165* 594 791* 800*
match_key                       000204 automatic       char(32)                 dcl 677 set ref 685* 687* 716 730
max                                                    builtin function         dcl 110 ref 160
max_entries              35            based           fixed bin(18,0)          level 4 unsigned dcl 3-31 set ref 160
max_size                 36            based           fixed bin(19,0)          level 4 dcl 3-31 set ref 158 180 181
meters                   47            based           structure                level 3 dcl 3-31 set ref 167*
mod                                                    builtin function         dcl 110 ref 155 783
ms_table_info                          based           structure                level 1 dcl 1-14 set ref 154 269*
msf_manager_$close              000064 constant        entry                    external dcl 88 ref 141 185 301
msf_manager_$get_ptr            000060 constant        entry                    external dcl 83 ref 171 617 636
msf_manager_$msf_get_ptr        000062 constant        entry                    external dcl 85 ref 147
msf_manager_$open               000056 constant        entry                    external dcl 82 ref 135 212
mstb_checksum_$check_entry      000054 constant        entry                    external dcl 78 ref 412 513
mstb_checksum_$sum_entry        000052 constant        entry                    external dcl 76 ref 462 558
mstb_status                            based           structure                level 1 dcl 2-8 set ref 288*
mt_header                              based           structure                level 1 dcl 3-31 set ref 159 270
mti                      22            based           structure                level 3 dcl 3-31 set ref 154* 269
now                             000106 automatic       fixed bin(71,0)          dcl 100 in procedure "ms_table_mgr_" set ref 169*
                                                                                  178
now                             000100 automatic       fixed bin(71,0)          dcl 650 in procedure "set_checkpoint" set ref 652*
                                                                                  655
null                                                   builtin function         dcl 110 ref 149 210 213 265 326 345 380 400 477 554
                                                                                  618 637 697 719 740
number_components        40            based           fixed bin(18,0)          level 3 unsigned dcl 3-31 set ref 160* 162 170 248
                                                                                  653 814
pad                      51            based           bit(36)                  array level 3 dcl 3-31 set ref 168*
pclock                   21            based           fixed bin(35,0)          level 3 dcl 3-31 set ref 166* 393 492 608 659* 662*
                                                                                  662 694 744 748
perm_data_checksum       46            based           fixed bin(35,0)          level 3 dcl 3-31 set ref 807* 821
pointer                                                builtin function         dcl 110 ref 270 783
raw                       0(07) 000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 4-7 set ref 197*
record                          000105 automatic       fixed bin(35,0)          dcl 99 set ref 494* 495 500*
save_ep                         000216 automatic       pointer                  dcl 679 set ref 697* 707 726* 736
saved_clock                     000221 automatic       fixed bin(35,0)          dcl 681 set ref 694* 744 748
searches                 47            based           fixed bin(35,0)          level 4 dcl 3-31 set ref 691* 691
segment                   0(03) 000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 4-7 set ref 197*
segp                            000126 automatic       pointer                  dcl 3-29 set ref 158 159 171* 177 178 178 179 180*
                                                                                  181* 250 250 250 623* 636* 637 655 783 783
set_lock_$lock                  000066 constant        entry                    external dcl 90 ref 791
set_lock_$unlock                000070 constant        entry                    external dcl 91 ref 800
size                                                   builtin function         dcl 110 ref 158 159 159 270 783
total_entries            43            based           fixed bin(35,0)          level 3 dcl 3-31 set ref 162* 495 689* 698 814
tp                              000112 automatic       pointer                  dcl 102 set ref 135* 141* 147* 171* 185* 212* 213
                                                                                  230 245* 266* 279* 299* 301* 327* 381* 444* 479*
                                                                                  539* 568* 579* 591* 599* 605* 617* 636*
translate                                              builtin function         dcl 761 ref 763
type                     23            based           char(32)                 level 4 in structure "mt_header" dcl 3-31
                                                                                  in procedure "ms_table_mgr_" set ref 177 224 250
type                                   based           char(32)                 level 2 in structure "comp_header" dcl 3-50
                                                                                  in procedure "ms_table_mgr_" set ref 177* 250
unlock_when_done                000115 automatic       bit(1)                   dcl 104 set ref 529* 537* 560
used                                   based           bit(1)                   level 4 packed packed unaligned dcl 3-57 set ref
                                                                                  354* 501 703
used_entries             45            based           fixed bin(35,0)          level 3 dcl 3-31 set ref 157* 271 356* 356
version                                based           fixed bin(17,0)          level 2 in structure "ms_table_info" dcl 1-14
                                                                                  in procedure "ms_table_mgr_" set ref 129
version                  22            based           fixed bin(17,0)          level 4 in structure "mt_header" dcl 3-31
                                                                                  in procedure "ms_table_mgr_" set ref 219
version                                based           fixed bin(17,0)          level 2 in structure "mstb_status" dcl 2-8
                                                                                  in procedure "ms_table_mgr_" set ref 282 289*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addrel                                                 builtin function         dcl 110
currentize                                             builtin function         dcl 110
mstb_status_ptr                        automatic       pointer                  dcl 2-7

NAMES DECLARED BY EXPLICIT CONTEXT.
DELETE_ENTRY_JOIN               001746 constant        label                    dcl 442 ref 433
DELETE_ENTRY_UNLOCK_RETURN      002074 constant        label                    dcl 467 ref 457
FIND_ENTRY_COMMON               001440 constant        label                    dcl 378 ref 371
FIND_ERROR_RETURN               001665 constant        label                    dcl 422 ref 398 403 498 504
NEW_ENTRY_JOIN                  001220 constant        label                    dcl 324 ref 312
NEW_ENTRY_UNLOCK_RETURN         001351 constant        label                    dcl 361 ref 342 348
RETRY                           003320 constant        label                    dcl 694 ref 744 748
RETURN                          000430 constant        label                    dcl 186 ref 621 640 824
RETURN_0                        003502 constant        label                    dcl 744 ref 710 741
RETURN_1                        003511 constant        label                    dcl 748 ref 708 721 730 737
SET_CLOCK                       003207 constant        label                    dcl 664 ref 660
UPDATE_ENTRY_JOIN               002464 constant        label                    dcl 539 ref 530
abs_entry                       002107 constant        entry                    external dcl 473
check_lock                      002651 constant        entry                    external dcl 585
check_mt_header_check           003710 constant        entry                    internal dcl 818 ref 625
close                           001115 constant        entry                    external dcl 295 ref 599
create                          000063 constant        entry                    external dcl 119
delete                          000435 constant        entry                    external dcl 192
delete_entry                    001726 constant        entry                    external dcl 437
delete_entry_ignore_mylock      001702 constant        entry                    external dcl 429
find_entry                      001364 constant        entry                    external dcl 367
find_entry_case_ins             001413 constant        entry                    external dcl 373
get_change_clock                002762 constant        entry                    external dcl 602
get_component                   003051 constant        entry                    internal dcl 630 ref 249 654 781
get_entry                       003547 constant        entry                    internal dcl 772 ref 500 699
get_header                      003007 constant        entry                    internal dcl 614 ref 218 247 268 280 329 383 446 481
                                                                                  542 570 581 607
hash_search                     003210 constant        entry                    internal dcl 670 ref 339 395 454
lock                            003605 constant        entry                    internal dcl 786 in procedure "ms_table_mgr_" ref
                                                                                  332 386 448 485 571
lock                            002572 constant        entry                    external dcl 565
lowercase                       003521 constant        entry                    internal dcl 753 ref 683 716
ms_table_mgr_                   000050 constant        entry                    external dcl 12
mt_header_check                 003673 constant        entry                    internal dcl 811 ref 807 821
new_entry                       001176 constant        entry                    external dcl 319
new_entry_ignore_mylock         001150 constant        entry                    external dcl 308
open                            000544 constant        entry                    external dcl 206 ref 591
set_checkpoint                  003120 constant        entry                    internal dcl 647 ref 357 465 559
set_mt_header_check             003662 constant        entry                    internal dcl 804 ref 184
status                          001044 constant        entry                    external dcl 276
table_data                      000767 constant        entry                    external dcl 261
unlock                          003642 constant        entry                    internal dcl 797 in procedure "ms_table_mgr_" ref
                                                                                  331 361 422 447 467 484 560 582 597
unlock                          002620 constant        entry                    external dcl 576
update_entry                    002446 constant        entry                    external dcl 534
update_entry_dont_unlock        002426 constant        entry                    external dcl 526
verify                          000703 constant        entry                    external dcl 241

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addwordno                                              builtin function         ref 548
currentsize                                            builtin function         ref 158 159 412 412 462 462 513 513 558 558 783
string                                                 builtin function         ref 196 201 201
wordno                                                 builtin function         ref 548 548

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4726        5020    4153        4736
Length      5402    4153        72         345     553           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ms_table_mgr_                       329 external procedure  is an external procedure.  
on unit on line 331                  64 on unit               
begin block on line 406              84 begin block         uses auto adjustable storage.  
on unit on line 447                  64 on unit               
on unit on line 484                  64 on unit               
begin block on line 506              84 begin block         uses auto adjustable storage.  
begin block on line 546              72 begin block         uses auto adjustable storage.  
get_header                              internal procedure  shares stack frame of external procedure ms_table_mgr_.  
get_component                        80 internal procedure  is called by several nonquick procedures.  
set_checkpoint                       80 internal procedure  enables or reverts conditions.  
on unit on line 657                  64 on unit               
hash_search                             internal procedure  shares stack frame of external procedure ms_table_mgr_.  
lowercase                               internal procedure  shares stack frame of external procedure ms_table_mgr_.  
get_entry                               internal procedure  shares stack frame of external procedure ms_table_mgr_.  
lock                                    internal procedure  shares stack frame of external procedure ms_table_mgr_.  
unlock                               70 internal procedure  is called by several nonquick procedures.  
set_mt_header_check                     internal procedure  shares stack frame of external procedure ms_table_mgr_.  
mt_header_check                         internal procedure  shares stack frame of external procedure ms_table_mgr_.  
check_mt_header_check                   internal procedure  shares stack frame of external procedure ms_table_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 406  000100 copy_entry                  begin block on line 406
begin block on line 506  000100 copy_entry                  begin block on line 506
begin block on line 546  000100 dummy_entry                 begin block on line 546
ms_table_mgr_            000100 code                        ms_table_mgr_
                         000101 i                           ms_table_mgr_
                         000102 bc                          ms_table_mgr_
                         000103 component                   ms_table_mgr_
                         000104 enum                        ms_table_mgr_
                         000105 record                      ms_table_mgr_
                         000106 now                         ms_table_mgr_
                         000110 case_ins                    ms_table_mgr_
                         000112 tp                          ms_table_mgr_
                         000114 ignore_mylock               ms_table_mgr_
                         000115 unlock_when_done            ms_table_mgr_
                         000124 hdrp                        ms_table_mgr_
                         000126 segp                        ms_table_mgr_
                         000130 ep                          ms_table_mgr_
                         000132 delete_options              ms_table_mgr_
                         000174 hash_key                    hash_search
                         000204 match_key                   hash_search
                         000214 found_one                   hash_search
                         000215 case_ins                    hash_search
                         000216 save_ep                     hash_search
                         000220 hash                        hash_search
                         000221 saved_clock                 hash_search
                         000244 enum                        get_entry
                         000245 ecomp                       get_entry
set_checkpoint           000100 now                         set_checkpoint

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     enter_begin_block   leave_begin_block   call_ext_in_desc    call_ext_in         call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1           alloc_auto_adj
bound_ck_signal     mdfx1               enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
delete_$path                  hash_index_                   hcs_$set_bc_seg               hcs_$set_max_length_seg
msf_manager_$close            msf_manager_$get_ptr          msf_manager_$msf_get_ptr      msf_manager_$open
mstb_checksum_$check_entry    mstb_checksum_$sum_entry      set_lock_$lock                set_lock_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_index        error_table_$checksum_failure error_table_$id_already_exists
error_table_$id_not_found     error_table_$inconsistent     error_table_$invalid_lock_reset
error_table_$locked_by_this_process                         error_table_$namedup          error_table_$no_record
error_table_$noalloc          error_table_$noentry          error_table_$request_id_ambiguous
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000047       119 000055       124 000110       129 000111       131 000115       132 000117       135 000120
    136 000146       138 000152       140 000154       141 000156       142 000164       143 000165       144 000166
    147 000167       149 000212       151 000216       152 000220       154 000221       155 000227       157 000234
    158 000236       159 000245       160 000254       162 000263       165 000271       166 000272       167 000273
    168 000275       169 000307       170 000311       171 000321       172 000344       174 000346       175 000347
    177 000350       178 000355       179 000360       180 000362       181 000377       182 000416       184 000420
    185 000421       186 000430       192 000431       195 000460       196 000461       197 000462       201 000472
    202 000535       206 000536       209 000600       210 000601       212 000604       213 000633       215 000637
    216 000641       218 000642       219 000643       221 000647       222 000652       224 000653       226 000666
    227 000671       229 000672       230 000674       231 000676       241 000677       244 000715       245 000716
    247 000721       248 000722       249 000731       250 000737       253 000753       254 000756       256 000757
    257 000761       261 000762       264 001005       265 001010       266 001012       268 001015       269 001016
    270 001024       271 001030       272 001037       276 001040       278 001056       279 001057       280 001062
    282 001063       284 001070       285 001073       288 001074       289 001110       291 001112       295 001113
    298 001127       299 001130       301 001133       302 001142       308 001143       311 001171       312 001173
    319 001174       322 001217       324 001220       326 001221       327 001223       329 001226       331 001227
    332 001251       333 001253       335 001255       336 001256       339 001257       341 001303       342 001306
    345 001307       347 001313       348 001316       353 001317       354 001330       356 001334       357 001341
    358 001345       359 001350       361 001351       363 001355       367 001356       370 001407       371 001410
    373 001411       376 001436       378 001440       380 001441       381 001443       383 001446       384 001447
    386 001453       387 001455       389 001457       390 001460       392 001461       393 001462       395 001465
    397 001510       398 001513       400 001514       402 001520       403 001523       406 001524       407 001527
    409 001536       410 001612       412 001614       415 001652       417 001653       419 001661       420 001664
    422 001665       425 001675       429 001676       432 001721       433 001723       437 001724       440 001745
    442 001746       444 001747       446 001752       447 001753       448 001775       449 001777       451 002001
    452 002002       454 002003       456 002027       457 002032       460 002033       461 002035       462 002040
    463 002063       465 002070       467 002074       469 002100       473 002101       476 002132       477 002133
    478 002135       479 002145       481 002150       482 002151       484 002155       485 002177       486 002201
    488 002203       489 002204       491 002205       492 002206       494 002211       495 002220       497 002231
    498 002234       500 002235       501 002237       503 002245       504 002250       506 002251       508 002254
    510 002263       511 002340       513 002342       516 002400       518 002401       519 002404       520 002415
    522 002423       526 002424       529 002442       530 002443       534 002444       537 002462       539 002464
    541 002467       542 002470       546 002471       547 002474       548 002502       549 002520       554 002523
    556 002525       557 002527       558 002532       559 002555       560 002561       562 002567       565 002570
    568 002604       569 002607       570 002610       571 002611       572 002613       573 002615       576 002616
    579 002632       580 002635       581 002636       582 002637       583 002643       585 002644       590 002671
    591 002673       592 002727       594 002731       596 002736       597 002740       599 002744       600 002755
    602 002756       605 002776       606 003001       607 003002       608 003003       609 003006       614 003007
    617 003010       618 003034       620 003040       621 003042       623 003043       624 003045       625 003046
    626 003047       630 003050       635 003056       636 003062       637 003104       639 003111       640 003113
    642 003116       647 003117       652 003125       653 003127       654 003140       655 003147       656 003153
    657 003155       659 003171       660 003176       662 003201       664 003207       670 003210       683 003221
    684 003242       685 003250       687 003256       689 003263       691 003311       694 003320       696 003323
    697 003324       698 003326       699 003350       701 003352       703 003361       705 003364       707 003370
    708 003372       710 003373       712 003374       714 003377       716 003401       719 003423       721 003425
    725 003426       726 003430       729 003432       730 003433       733 003440       734 003472       736 003474
    737 003476       740 003477       741 003501       744 003502       747 003506       748 003511       751 003515
    753 003521       763 003532       772 003547       779 003551       780 003556       781 003560       783 003570
    784 003604       786 003605       791 003607       792 003625       794 003640       797 003641       800 003647
    801 003661       804 003662       807 003663       808 003672       811 003673       814 003675       818 003710
    821 003711       823 003717       824 003722       826 003723


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
