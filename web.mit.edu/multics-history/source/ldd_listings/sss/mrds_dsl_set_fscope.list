	COMPILATION LISTING OF SEGMENT mrds_dsl_set_fscope
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1121.85_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-10-17 by Jim
       17*     Lippard (mrds #145, SCP-6258).
       18*  2) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
       19*     install(86-10-23,MR12.0-1199):
       20*     Changed references to DEFAULT_WAIT to be mrds_data_$lock_wait_time.
       21*  3) change(87-10-13,Dupuis), approve(87-10-13,MCR7777),
       22*     audit(87-11-18,Brunelle), install(87-11-30,MR12.2-1006):
       23*     Fixed a problem where the internal proc queue_scope was getting a null
       24*     pointer fault trying to reference thru ul_ptr.
       25*                                                   END HISTORY COMMENTS */
       26 
       27 
       28 mrds_dsl_set_fscope: set_fscope: procedure;
       29 
       30 /*   
       31*	BEGIN_DESCRIPTION
       32*   This procedure sets the user's scope of access to the database if it is open in the
       33*   shared mode.  Calling sequence is:
       34*
       35*   call dsl_$set_fscope (db_index,
       36*   rel_name, permit_requests, prevent_requests, ...,
       37*   rel_name, permit_requests, prevent_requests, wait_seconds[optional],  code);
       38*	END_DESCRIPTION
       39*   
       40*   HISTORY:
       41*
       42*   Written April 28, 1976 by R. G. Luebke
       43*
       44*   Modified by O D Friesen July, 1977, to queue scope  requests  for
       45*   the  user Changed to set_fscope by Oris D. Friesen - Sept. 1978 -
       46*   to set scopes at file level instead of rel. level
       47*
       48*   Modified by M.  Pierret  December  1979  for  the  following:  1.
       49*   Redesigned  the queueing/wakeup system so that user must re-check
       50*   her ability to set scope when awakened, and  be  responsible  for
       51*   wakeing  the  next  elibible user in the queue and detecting dead
       52*   processes in the  queue;  2.  Restructured  the  entire  program,
       53*   adding  commentation;  3.  Coordinate  with  dl_scope the dbc and
       54*   user_list entries that they share; 4. Made call to mu_empty_scope
       55*   compatible with new changes.
       56*
       57*   Modified by M. Pierret 13 April 1980 to remove priority queueing.
       58*
       59*   Modified by M. Pierret 27 June 1980, changing fil  and  file_name
       60*   to   rel   and  model_rel_name,  resolving  naming  discrepancies
       61*   concerning submodels, and fixing various logic  errors  involving
       62*   passive_sw, setting up fil_list and scope_info, and redecoratng.
       63*
       64*   Modified by Jim Gray -  -  80-11-14,  to  put  common  code  into
       65*   check_scope_and_access,      plus     adding     the     routines
       66*   check_mrds_access, check_system_access, check_file_open,  and  to
       67*   add mrds/system access checking at scope time, so that more scope
       68*   than current access can not be granted,  and  to  put  the  vfile
       69*   opening  for a relation at set_scope time, so that relations that
       70*   are not having scope set will  not  be  opened,  plus  the  vfile
       71*   opening  process  will  not  be  the  one  to  detect  any access
       72*   violation.  Also  added  check  to  prevent  null  permit   scope
       73*   requests,  so  null  access  on files can be detected. Also fixed
       74*   set_scope_all bug by putting file ready  mode  checks  in  common
       75*   check_mrds_access  routine,  so  that  now  can't get update when
       76*   opened retrieve.
       77*
       78*   80-12-11 Jim Gray : added use of include file mdbm_scope_requests
       79*   as  part  of  change  from  r-u  to  r-s-m-d  type  scope  modes.
       80*   mdbm_scope_info and mdbm_users include files also  changed  as  a
       81*   result.  Added local declarations of actual/user_permits/prevents
       82*   and   actual_conflict_detail.   The   later    was    added    to
       83*   check_scope/conflict  interface to be able to report exact detail
       84*   of why a set_scope failed. Changed the mrds_access conflcit check
       85*   to   be   more   detailed,   The  routines  get_permit_scope  and
       86*   get_rmds_access  were  added  for  error  detail.  The  calls  to
       87*   store_scope,  plus the setting of the check_scope flag were moved
       88*   to the common routine check_scope_and_access. Common code was put
       89*   in  activate_or_queue.  A  bug  in  awakened was fixed that would
       90*   cause a queued process to loop forever,  if  a  non-passive  dead
       91*   process  was  created  while  he was still in the queue. now that
       92*   update has been turned into 3 separate permissions.
       93*
       94*   80-12-11 Jim Gray : found that MSF's could look  like  they  have
       95*   "rw",  but have been set to just "w", and that is all that exists
       96*   on the components. For cases  where  "r"  appears,  an  aditional
       97*   check  on component 0 of the MSF was added to make sure it really
       98*   was "r".
       99*
      100*   80-12-12 Jim Gray : added initialization of fil_list  pad  areas,
      101*   and  also  set update bit on according to whether one of a+m+d is
      102*   on. Improved the system access conflict error message to give the
      103*   required access for the requested scope.
      104*
      105*   80-12-12 Jim Gray : Found that the wait_sec option was having  no
      106*   effect,  even in default mode. No waiting was ever occuring. This
      107*   was because the DEFAULT_WAIT was declared fixed  bin  (71),  then
      108*   being  overlayed  with  a  fixed bin(35) number, getting only the
      109*   upper (zeroed) half of the double word number.
      110*
      111*   80-12-12 Jim Gray : Found that the awakened procedure did not set
      112*   the  upper  bound  on  the  loop  through  the  scope_info  array
      113*   properly, thus causing it to access beyond the end  of  the  dbcb
      114*   segment  in the resultant model. Now it uses scope_info.nfiles as
      115*   it should. This only happend when a queued waiter was woke up  by
      116*   a scope deleter, and no further conflict existed.
      117*
      118*   80-12-12 Jim Gray : Added debug message of SCOPE REQUEST GRANTED,
      119*   that  is  issued  when a user that has been queued is awoken, and
      120*   finds no conflict in being able to set his scope.
      121*
      122*   80-12-15 Jim Gray : changed being  queued,  and  request  granted
      123*   from   queue   informative   messages   from  sub_err_,  to  ioa_
      124*   displayable via mrds_debug_tool with switch 1 being set for  this
      125*   module.
      126*
      127*   80-12-15 Jim Gray : Modified logic to  allow  null  permit  scope
      128*   requests.  For  file  readying nothing is done in this case, same
      129*   for system access checking. However, a true "null" scope tuple is
      130*   set in the fil_list string and in the scope_info
      131*
      132*   80-12-16 Jim Gray : added requirement that a null permit  request
      133*   has  system  acl  to  the  relation  data  of "r", so that a user
      134*   without sufficient access can not prevent  others  from  using  a
      135*   relation he has no access to.
      136*
      137*   81-1-11 Jim Gray : added handling of touched bit  in  scope_info,
      138*   so that null scope requests can be displayed.
      139*
      140*   81-01-27 Jim Gray : added call to  set_needed_access  for  system
      141*   acl   failures,  so  that  DBA  types  will  never  fail  due  to
      142*   insufficient access.
      143*
      144*   81-06-17  Jim  Gray  :  removed  file  opening  logic,  now  that
      145*   mu_open_iocb_manager handles it at first data reference time.
      146*
      147*   81-07-23 Jim Gray : added check for the scope mode encoding being
      148*   too large.
      149*
      150*   81-12-15 R. Lackey : Modified to seach rel_array for full 32 character name. TR11887
      151*
      152*   82-01-08 R. Lackey : Added check to detect relation names longer then 30 characters.
      153*
      154*   82-09-22 Davids: added call to dbcb.relmgr_entries.set_scope in the
      155*   activate_user_scope internal proc. This required changing the calling
      156*   sequence of the internal procs store_scope and add_fil_list_entry to
      157*   include the parameter rmri_ptr so that add_fil_list_entry can set the
      158*   value of the relation's opening_id.
      159*
      160*   82-10-04 Davids: added the internal proc scopes_by_this_process and
      161*   placed a call to it activite_user_scopes right before the call to
      162*   relmgr_entries.set_scope. scopes_by_this_process combines all the scopes
      163*   that a process may have on a relation. A process could have more than
      164*   once set of scopes if the database has been opened multiple times.
      165*
      166*   82-10-14 Davids: added code to open a relation before the call to the
      167*   relation manager set scope routine because that routine expects the
      168*   relation to already be opened. 
      169*
      170*   82-12-10 Davids: Modified the call to dbcb.relmgr_entries.open by
      171*   enclosing the db_path and model name in ()s. This was needed because
      172*   the declaration of the relation manager entries in the dbcb was changed
      173*   from options variable to reality. The db_path and model_name are
      174*   declared as character aligned in include files while the entry expects
      175*   character unaligned.
      176*
      177*   83-01-21 Kubicar: Added transaction code
      178*
      179*   83-01-25 Davids: Added check of mstxn_code after the mrds_start_transaction
      180*   include file to be sure that the transaction was started ok (if it had to
      181*   be started). Also created the new entry point set_relmgr_scopes out of
      182*   code that used to be in activate_user_scope. This new entry is called from
      183*   both activate_user_scope and the clean_up procedure. The call in clean_up
      184*   was needed to be sure that the relation manager scopes and mrds scopes
      185*   matched. Corrected scope calculation in the internal procedure
      186*   scopes_by_this_process.
      187*
      188*   83-02-07 Davids: Modified the set_relmgr_scopes internal procedure to 
      189*   create a copy of the rmri_ptr instead of using the copy in the fil_list
      190*   structure. This is needed because the ring brackets of the db.control
      191*   segment which is where the fil_list is kept may be 5,5,5 in which case the 
      192*   pointer cannot be used to reference the rm_rel_info structure which is in
      193*   the resultant and may have different ring brackets, i.e. 4,4,4.
      194*
      195*   83-02-15 Davids: explicitly declared variables that were
      196*   declared by context or implication and deleted declarations
      197*   to variables that were not referenced.
      198*
      199*   84-07-26 Thanh Nguyen: Modified the ioa_args of the call sub_err_ due to
      200*   TR #phx17395, problem number 113 in the mrds error list.
      201*
      202*   85-03-14 Thanh Nguyen: Modified the awakened procedure to handle the case
      203*   of the conflict_sw is on and the ul_ptr is null after the call to 
      204*   wakeup_next_waiter internal subroutine. (TR #phx19144).
      205*
      206*   85-03-22 Thanh Nguyen: Modified the awakened procedure again to handle the 
      207*   case of the timed-out.  It will try to lock the scope_lock no more than 3
      208*   times before it will dequeue the timed-out user or will set the
      209*   trouble_switch.(TR #19174).
      210*
      211*   85-04-14 Thanh Nguyen: Modified code not to get the out of subrange while
      212*   checking for the conflict of the scope.
      213*
      214*   85-10-17 Jim Lippard: Changed to not set trouble switch when the scope_lock
      215*   can't be set and to wait the user's specified wait time rather than
      216*   mrds_data_$lock_wait_time.
      217**/
      218 
      219 	entry_name = "set_fscope";			/* normal entry point */
      220 	args_exp = 5;				/* 5 input arguments */
      221 	num_filns = 0;
      222 	dbc_ptr = null ();				/* initialize */
      223 	call cu_$arg_count (nargs);			/* get number of args */
      224 	if nargs < args_exp
      225 	then signal arg_error;			/* must be at least args_exp args */
      226 						/* signal is used here because we can't determine */
      227 						/* where the error code argument is */
      228 
      229 	if mod (nargs - 3, 3) = 0
      230 	then do;
      231 		call cu_$arg_ptr (nargs - 1, ws_ptr, arg_len, icode);
      232 		if icode ^= 0
      233 		then signal arg_error;
      234 	     end;
      235 	else ws_ptr = addr (mrds_data_$lock_wait_time);
      236 
      237 common_label:
      238 	mstxn_txn_id = "0"b;
      239 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* get pointer to last arg (code) */
      240 	if icode ^= 0
      241 	then signal arg_error;
      242 	code = 0;
      243 
      244 /* Set up condition handlers. Note that they come before the label pntr2, where dl_fscope_all_ptr enters.
      245*   This entry is for now unused, and if used, it is assumed that handlers are provided by the caller */
      246 
      247 	on cleanup call clean_up;
      248 	on quit
      249 	     begin;
      250 		call clean_up;
      251 		call continue_to_signal_ (icode);
      252 	     end;
      253 
      254 
      255 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* get db_index */
      256 	if icode ^= 0
      257 	then call error (icode);
      258 	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      259 						/* look up db's pointer */
      260 	if dbcb_ptr = null ()			/* we don't know about this data base */
      261 	then call error (mrds_error_$invalid_db_index);
      262 
      263 pntr2:
      264 
      265 
      266 	dbc_ptr = dbcb.dbc_ptr;			/* get pointer to data base control segment */
      267 	if dbcb.scope_ptr = null
      268 	then call error (mrds_error_$non_scope_ready);
      269 
      270 	scope_ptr = dbcb.scope_ptr;
      271 	rdbi_ptr = dbcb.rdbi_ptr;
      272 	rmra_ptr = rm_db_info.ra_ptr;
      273 
      274 	if scope_info.active_scopes > 0		/* all scope must be set at one time, so there */
      275 	then call error (mrds_error_$scope_not_empty);	/* ..cannot be existing scope at this point */
      276 
      277 
      278 
      279 	call set_lock_$lock (dbc.scope_lock, (wait_seconds), icode);
      280 						/* lock scope portion of dbc */
      281 	if icode = error_table_$invalid_lock_reset |
      282 	     icode = error_table_$locked_by_this_process
      283 	then icode = 0;
      284 						/* ignore these error codes */
      285 	if icode ^= 0
      286 	then do;					/* somebody else has got it locked */
      287 		call error (icode);
      288 
      289 	     end;
      290 
      291 
      292 
      293 
      294 	QUE_FREE = fixed (unspec (CHAR_Q_F), 71);	/* Set wakeup message constant */
      295 	ALARM = fixed (unspec (CHAR_ALARM), 71);	/* Set time-out message constant */
      296 
      297 	empty_on_err = ON;				/* Must empty scope on error (for cleanup purposes) */
      298 
      299 /* Position to this user's user_list in dbc */
      300 
      301 	ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
      302 	this_ul_ptr = null;
      303 	do while (ul_ptr ^= null);
      304 	     if user_list.process_id = get_process_id_ ()
      305 	     then do;
      306 		     if user_list.rdbi_bits = addr (rdbi_ptr) -> ptr_bit_string
      307 		     then do;
      308 			     this_ul_ptr = ul_ptr;
      309 			     ul_ptr = null;
      310 			end;
      311 		     else ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      312 		end;
      313 	     else ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      314 	end;
      315 
      316 	if this_ul_ptr = null			/* User is not in open list - DBC was probably reset */
      317 	then call error (mrds_error_$invalid_db_index);
      318 
      319 	ul_ptr = this_ul_ptr;
      320 
      321 /* find out if the user is a DBA */
      322 
      323 	call mrds_dm_authorization$get_user_class (rtrim (rm_db_info.db_path), addr (local_area),
      324 	     mrds_authorization_structure_version, mrds_authorization_ptr, icode);
      325 	if icode ^= 0 then call error (icode);
      326 
      327 /* Initialize some variables. */
      328 
      329 	user_list.queue_activ = OFF;
      330 	user_list.bypass_count = 0;
      331 	check_scope = ON;				/* OFF-> don't bother checking for conflict */
      332 	conflict_sw = OFF;				/* ON -> a conflict was found */
      333 	re_check = OFF;				/* ON -> a conflict was resolved, so try again */
      334 	first_scope_triple = ON;			/* Processing firstrelation in scope request */
      335 
      336 /*  Set up transactions */
      337 
      338 	mstxn_transactions_needed = dbcb.transactions_needed;
      339 	on cleanup
      340 	     begin;
      341 		call mstxn_cleanup;
      342 		call clean_up;
      343 	     end;
      344 	on quit
      345 	     begin;
      346 		call clean_up;
      347 		call mstxn_any_other;
      348 	     end;
      349 	on any_other call mstxn_any_other;
      350 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      351 
      352 
      353 	if mstxn_code ^= 0
      354 	then call error (mstxn_code);
      355 
      356 	dbcb.user_started_transaction = user_started_transaction;
      357 
      358 /* Do one of the following blocks of code, as appropriate */
      359 
      360 /* ************* Entry point is set_fscope ************* */
      361 
      362 	if entry_name = "set_fscope"
      363 	then do;
      364 
      365 		num_tuples = divide (nargs - 2, 3, 17); /* calculate number of scope tuples */
      366 
      367 		do i = 1 to num_tuples;		/* iterate once for each scope tuple */
      368 		     arg_index = 3 * (i - 1) + 2;	/* position to ith scope tuple */
      369 		     call cu_$arg_ptr (arg_index, rel_ptr, rel_len, icode);
      370 						/* get rel_name */
      371 		     if icode ^= 0
      372 		     then call error (icode);
      373 
      374 
      375 
      376 /* BEGIN 82-01-08 Roger Lackey ********************************************* */
      377 
      378 		     if length (rtrim (rel_name)) > 30 then call error (mrds_error_$rel_name_too_long);
      379 
      380 /* END   82-01-08 Roger Lackey ********************************************* */
      381 
      382 /* BEGIN CHANGE 81-12-15 RDL ******************************************** */
      383 
      384 		     rel_name_32 = rel_name;		/* Used for searching */
      385 		     l = index (string (rm_rel_array.name), "!" || rel_name_32);
      386 
      387 /* END   CHANGE 81-12-15 RDL ******************************************** */
      388 
      389 /* find file (relation) and get it's model name and the permits-pervent */
      390 
      391 		     if l = 0 then do;
      392 			     call sub_err_ (mrds_error_$unknown_relation_name, caller_name, continue, info_ptr, return_value,
      393 				"^/^a^a^a", "The relation name """, rel_name,
      394 				""" was not found in the users view of the database.");
      395 			     call error (mrds_error_$unknown_relation_name);
      396 			end;
      397 		     else do;
      398 			     l = ((l - 1) / 33) + 1;	/* convert from char to array index */
      399 			     submodel_rel_name = rm_rel_array.name.submodel (l);
      400 			     model_rel_name = rm_rel_array.rel_data.model_name (l);
      401 			     rmri_ptr = rm_rel_array.rel_data.ri_ptr (l);
      402 			end;
      403 
      404 /* ptr to file info */
      405 
      406 		     call cu_$arg_ptr (arg_index + 1, permit_requests_ptr, arg_len, icode);
      407 						/* get permit ops */
      408 		     if icode ^= 0
      409 		     then call error (icode);
      410 
      411 		     call cu_$arg_ptr (arg_index + 2, prevent_requests_ptr, arg_len, icode);
      412 						/* get prevent ops */
      413 		     if icode ^= 0
      414 		     then call error (icode);
      415 
      416 
      417 /* assert whether we can successfully set scope without conflict by:
      418*   checking user's scope tuples (conceived at ready time) to make
      419*   sure scope hasn't been defined already by this user;
      420*   and then to actually check for a conflict */
      421 
      422 		     do pos_in_si = scope_info.nfiles to 1 by -1
      423 			while (submodel_rel_name ^= scope_info.scope.sm_name (pos_in_si));
      424 		     end;
      425 
      426 		     if string (scope_info.scope.flags (pos_in_si))
      427 						/* scope has already been defined for this file (relation) */
      428 		     then call error (mrds_error_$duplicate_scope);
      429 
      430 
      431 		     call check_scope_and_access (rmri_ptr);
      432 
      433 		end;
      434 
      435 		call activate_or_queue ();
      436 
      437 	     end;
      438 
      439 /* ************* Entry point is set_fscope_all or set_fscope_all_ptr ************* */
      440 
      441 	if entry_name = "set_fscope_all" | entry_name = "set_fscope_all_ptr"
      442 	then do;
      443 
      444 		if entry_name = "set_fscope_all"
      445 		then do;
      446 			call cu_$arg_ptr (2, permit_requests_ptr, arg_len, icode);
      447 						/* get permit ops */
      448 			if icode ^= 0
      449 			then call error (icode);
      450 
      451 			call cu_$arg_ptr (3, prevent_requests_ptr, arg_len, icode);
      452 						/* get prevent ops */
      453 			if icode ^= 0
      454 			then call error (icode);
      455 		     end;
      456 
      457 /* Iterate over each relation in scope_info */
      458 
      459 		do pos_in_si = 1 to scope_info.nfiles;
      460 		     model_rel_name = scope_info.scope.name (pos_in_si);
      461 		     submodel_rel_name = scope_info.scope.sm_name (pos_in_si);
      462 
      463 		     rmri_ptr = null ();
      464 		     call check_scope_and_access (rmri_ptr);
      465 
      466 		end;
      467 
      468 
      469 		call activate_or_queue ();
      470 	     end;
      471 
      472 
      473 	code = 0;
      474 
      475 	if dbc_ptr ^= null ()
      476 	then
      477 	     call set_lock_$unlock (dbc.scope_lock, code);/* unlock the scope table */
      478 exit:
      479 
      480 /* End the transaction */
      481 
      482 	mftxn_code = code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      483 
      484 	if mftxn_code ^= 0
      485 	then code = mftxn_code;
      486 
      487 	return;
      488 
      489 activate_or_queue: procedure ();
      490 
      491 /* common routine for queueing user if he found a conflict to his request,
      492*   or going ahead with giving him the permissions/prevents he asked for */
      493 
      494 /* If there was a conflict, then add user to waiting queue and wait.
      495*   If not, activate the user.  Use the scope already stored */
      496 
      497 	if conflict_sw then do;
      498 		call queue_scope (FIRST_QUEUE);	/* go to sleep  and when awakened, try it again */
      499 		call awakened;
      500 	     end;
      501 	else call activate_user_scope;		/* no conflict, so go ahead */
      502 
      503      end;
      504 
      505 mrds_dsl_set_fscope_all:
      506 set_fscope_all:
      507      entry;
      508 
      509 /*
      510*   *
      511*   *  call mrds_dsl_set_fscope_all (db_index, permit_requests, prevent_requests, wait_seconds[optional], code);
      512*   *
      513**/
      514 
      515 
      516 	entry_name = "set_fscope_all";
      517 	args_exp = 4;				/* at least 4 -- maybe 5 -- arguments are expected
      518*						   to be present */
      519 	dbc_ptr = null;
      520 	call cu_$arg_count (nargs);
      521 	if nargs < args_exp
      522 	then signal arg_error;
      523 	if nargs = args_exp + 1
      524 	then do;
      525 		call cu_$arg_ptr (nargs - 1, ws_ptr, arg_len, icode);
      526 		if icode ^= 0
      527 		then signal arg_error;
      528 	     end;
      529 	else ws_ptr = addr (mrds_data_$lock_wait_time);
      530 	goto common_label;
      531 
      532 pntr:
      533 set_fscope_all_pntr:
      534 mrds_dsl_set_fscope_all_pntr:
      535      entry (a_dbcb_ptr, a_permit_requests_ptr, a_prevent_requests_ptr, a_ws_ptr, a_cd_ptr);
      536 
      537 /*
      538*   *
      539*   *  entry point used to set scopes when data base has been opened in
      540*   *   EXCLUSIVE mode -- pointer is used in place of data base index
      541*   *
      542**/
      543 
      544 	dcl     (
      545 	        a_dbcb_ptr,				/* dbcb parameter */
      546 	        a_permit_requests_ptr,		/* permit options parameter */
      547 	        a_prevent_requests_ptr,		/* prevent options parameter */
      548 	        a_ws_ptr,				/* wait_seconds parameter */
      549 	        a_cd_ptr
      550 	        )			 ptr;		/* return code parameter */
      551 
      552 
      553 	entry_name = "set_fscope_all_ptr";
      554 	dbc_ptr = null;
      555 	args_exp = 5;				/* 5 arguments are expected to be present */
      556 	if a_ws_ptr = null
      557 	then ws_ptr = addr (mrds_data_$lock_wait_time);
      558 	else ws_ptr = a_ws_ptr;
      559 	dbcb_ptr = a_dbcb_ptr;
      560 	permit_requests_ptr = a_permit_requests_ptr;
      561 	prevent_requests_ptr = a_prevent_requests_ptr;
      562 	cd_ptr = a_cd_ptr;
      563 	goto pntr2;
      564 
      565 check_scope_and_access: procedure (dummy_ptr);
      566 
      567 /* routine to check for scope conflicts, and to   guarantee that scope granted does not exceed actual access
      568*   the user currently has via either mrds or the system
      569*   Also,  if this relation, has not yet had it's vfile opened, do so now */
      570 
      571 	call check_mrds_access (dummy_ptr);
      572 	call check_system_access (dummy_ptr);
      573 
      574 	if dbc.active_users = 0 & dbc.waiting_users = 0	/* If there are no active or waiting scope users, */
      575 	then check_scope = OFF;			/* no need to even check scope--you've got it */
      576 
      577 /* check scope now */
      578 
      579 	if check_scope & ^conflict_sw			/* if we have a conflict already, no need to check */
      580 	then do;
      581 		conflict_ul_ptr = null;
      582 		re_check = ON;
      583 	     end;
      584 
      585 /* Check for conflict for this relation */
      586 
      587 	do while (re_check);
      588 	     re_check = OFF;
      589 
      590 	     call mu_check_scope (dbc_ptr, addr (model_rel_name),
      591 		(this_ul_ptr), permit_requests_ptr, prevent_requests_ptr,
      592 		addr (actual_conflict_detail), conflict_sw, conflict_ul_ptr);
      593 
      594 	     if conflict_sw then do;			/* there was a conflict */
      595 		     call check_dead_proc (conflict_sw, status);
      596 		     if ^conflict_sw then /* conflict was worked out */
      597 			re_check = ON;
      598 		     else do;			/* still a conflict */
      599 			     conflict_user_id = conflict_ul_ptr -> user_list.ids.group_id;
      600 			     conflict_relation = submodel_rel_name;
      601 			     conflict_detail_known = ON;
      602 			     if status = DEAD then do;/* non-passive dead process conflcit */
      603 				     icode = mrds_error_$db_conflict_dead_process;
      604 				     call report_conflict_detail (DEAD_PROC_REPORT);
      605 				     call error (icode);
      606 				end;
      607 			end;
      608 		end;
      609 	end;
      610 
      611 /* Whether there was a conflict or not, store the relevant information about this scope request. */
      612 /* The information for each relation will be stored in a fil_list entry and an entry in the scope_info array. */
      613 
      614 	call store_scope (dummy_ptr);
      615 
      616 	declare dummy_ptr		 ptr;		/* communicates rmri_ptr between modules */
      617      end;
      618 
      619 check_mrds_access: procedure (rmri_ptr);
      620 
      621 /* routine to check that the access permission  bits in the resultant
      622*   model are >= the scope that is being requested */
      623 
      624 /* get the relation access permission bits */
      625 
      626 	if rmri_ptr = null () then do;
      627 		i = index (string (rm_rel_array.name), "!" || submodel_rel_name);
      628 		i = ((i - 1) / 33) + 1;		/* convert from char to array index */
      629 		rmri_ptr = rm_rel_array.rel_data.ri_ptr (i);
      630 		model_rel_name = rm_rel_array.rel_data (i).model_name;
      631 	     end;
      632 
      633 
      634 /* check that the file was readied for scope_retrieve(ready_mode = 5),
      635*   or scope_update(ready_mode = 6) and that if scope_retrieve, the requested
      636*   permit op does not exceed the allowable of retrieve. */
      637 
      638 	if rmri_ptr -> rm_rel_info.ready_mode < 5 then
      639 	     call error (mrds_error_$non_scope_ready);
      640 
      641 	if rmri_ptr -> rm_rel_info.ready_mode = 5 &
      642 	     (permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple) then
      643 	     call error (mrds_error_$update_not_allowed);
      644 
      645 	if ^rmri_ptr -> rm_rel_info.mdbm_secured then
      646 	     rel_append_perm, rel_delete_perm,
      647 		attr_modify_perm, attr_retr_perm = ON;	/* model openings or un-secured submodel openings
      648*						   always have correct mrds access */
      649 	else do;					/* secured submodel opening */
      650 
      651 /* always gather all mrds access permission, in case we have to display for error */
      652 
      653 		attr_modify_perm, attr_retr_perm = OFF; /* init */
      654 
      655 /* check for retrieve/modify permission on at least one attribute in the relation */
      656 
      657 		do i = 1 to rmri_ptr -> rm_rel_info.num_attr while (^attr_retr_perm | ^attr_modify_perm);
      658 		     rai_ptr = rmri_ptr -> rm_rel_info.attr_ptrs (i);
      659 		     if ^attr_retr_perm then
      660 			attr_retr_perm = rai_ptr -> rm_attr_info.read_perm; /* see if this attr has read permission */
      661 		     if ^attr_modify_perm then
      662 			attr_modify_perm = rai_ptr -> rm_attr_info.modify_perm; /* if attr has modify permission */
      663 		end;
      664 
      665 		attr_null_perm = (^(attr_retr_perm) & ^(attr_modify_perm));
      666 
      667 /* check for either append_tuple or delte_tuple on the relation */
      668 
      669 		rel_append_perm = rmri_ptr -> rm_rel_info.append_tuple_perm;
      670 		rel_delete_perm = rmri_ptr -> rm_rel_info.delete_tuple_perm;
      671 		rel_null_perm = (^(rel_append_perm) & (^rel_delete_perm));
      672 
      673 	     end;
      674 
      675 /* check for correct access from mrds to set this scope */
      676 
      677 	if (permit_requests.read_attr & ^(attr_retr_perm)) |
      678 	     (permit_requests.modify_attr & ^(attr_modify_perm)) |
      679 	     (permit_requests.append_tuple & ^(rel_append_perm)) |
      680 	     (permit_requests.delete_tuple & ^(rel_delete_perm)) then do;
      681 
      682 		call sub_err_ (mrds_error_$scope_mrds_access_conflict, caller_name, continue, info_ptr, return_value,
      683 		     "^/^a^a^a^a^a^a^a",
      684 		     "The scope permission request of """, get_permit_scope (),
      685 		     """ on relation """, rmri_ptr -> rm_rel_info.name,
      686 		     """ exceeds the access granted by MRDS of """,
      687 		     get_mrds_access (), """.");
      688 		call error (mrds_error_$scope_mrds_access_conflict);
      689 	     end;
      690 
      691 /* check that the user is not requesting null access scope permissions, which have no meaning,
      692*   and could cause an attemp to open a file for which the user has no access */
      693 
      694 	null_permit_request = ^(permit_requests.read_attr | permit_requests.modify_attr |
      695 	     permit_requests.append_tuple | permit_requests.delete_tuple);
      696 
      697 	null_prevent_request = ^(prevent_requests.read_attr | prevent_requests.modify_attr |
      698 	     prevent_requests.append_tuple | prevent_requests.delete_tuple);
      699 
      700 	null_request = (null_prevent_request & null_permit_request);
      701 
      702 /* BEGIN CHANGE 81-07-23 ************************************************* */
      703 
      704 	if permit_requests_ptr -> fb35_ovrly > 15 | prevent_requests_ptr -> fb35_ovrly > 15 then do;
      705 		call sub_err_ (error_table_$bad_arg, caller_name, continue, info_ptr, return_value,
      706 		     "^/^a^a^a^/^a^/^a",
      707 		     "The permit or prevent encodings summed to > 15 for relation """,
      708 		     rm_rel_info.name, """",
      709 		     "Allowed values are:",
      710 		     "0(null), 1(read_attr), 2(append_tuple), 4(delete_tuple), 8(modify_attr)");
      711 		call error (error_table_$bad_arg);
      712 	     end;
      713 
      714 /* END CHANGE 81-07-23 ****************************************** */
      715 
      716 
      717 	declare fb35_ovrly		 fixed bin (35) based; /* overlay for checking encoding sum */
      718 	declare error_table_$bad_arg	 fixed bin (35) ext;/* bad argument given */
      719 	declare mrds_error_$scope_mrds_access_conflict fixed bin (35) ext; /* access permission < scope requested */
      720 	declare (rmri_ptr, rai_ptr)	 ptr;		/* temporary ptrs for this routine */
      721 	declare i			 fixed bin;	/* loop index */
      722 
      723      end;
      724 
      725 check_system_access: procedure (rmri_ptr);
      726 
      727 /* this routine checks whether the actual system acl's that user
      728*   has for the relation's data vfile are sufficient to grant the requested
      729*   scope request. "r" for r or n, "rw" for a or m or d */
      730 
      731 	call mu_get_relation_acl (rtrim (rm_db_info.db_path), rtrim (model_rel_name),
      732 	     mrds_authorization.administrator, read_access, write_access, error_code);
      733 	if error_code ^= 0 then do;
      734 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      735 		     "^/^a^/^a^a",
      736 		     "Unable to get access information on the MSF component ",
      737 		     """" || rtrim (rm_db_info.db_path) || ">",
      738 		     rtrim (model_rel_name) || ">0"".");
      739 		call error (error_code);
      740 	     end;
      741 
      742 /* check for a system access violation by the requested scope */
      743 
      744 	if ((permit_requests.read_attr | null_permit_request) & ^read_access) |
      745 	     ((permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple) &
      746 	     ^(write_access & read_access)) then do;
      747 
      748 /* get a displayable form of system access */
      749 
      750 		system_access = "";
      751 
      752 		if read_access then
      753 		     system_access = system_access || "r";
      754 
      755 		if write_access then
      756 		     system_access = system_access || "w";
      757 
      758 		if system_access = "" then
      759 		     system_access = "null";
      760 
      761 /* get a displayable form of the required access
      762*   for this scope request permit codes */
      763 
      764 		if permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple then
      765 		     required_access = "rw";
      766 		else required_access = "r";
      767 
      768 		call sub_err_ (mrds_error_$scope_system_access_conflict, caller_name,
      769 		     continue, info_ptr, return_value,
      770 		     "^/^a^a^a^a^a^a^a^a^a",
      771 		     "The requested permit scope """, get_permit_scope (),
      772 		     """ for relation """, rmri_ptr -> rm_rel_info.name,
      773 		     """ requires """, required_access,
      774 		     """ access, but this exceeds the users system access to the relation data of """,
      775 		     system_access, """.");
      776 		call error (mrds_error_$scope_system_access_conflict);
      777 	     end;
      778 
      779 
      780 	declare error_code		 fixed bin (35);	/* local version of error code */
      781 	declare mu_get_relation_acl	 entry (char (*), char (*),
      782 				 bit (1), bit (1), bit (1), fixed bin (35)); /* finds multics acls */
      783 	declare required_access	 char (4) varying;	/* the access required by this scope request */
      784 	declare system_access	 char (4) varying;	/* r, rw, w or null */
      785 	declare mrds_error_$scope_system_access_conflict fixed bin (35) ext; /* acls not sufficient for scope */
      786 	declare read_access		 bit (1);		/* on => has read access to relation data */
      787 	declare write_access	 bit (1);		/* on => has write access to relation data */
      788 	declare rmri_ptr		 ptr;		/* local temp ptr */
      789 
      790      end;
      791 
      792 get_permit_scope: procedure () returns (char (80) varying);
      793 
      794 /* routine to get displayable form of the scope permit modes
      795*   that the user requested, for output in error messages */
      796 
      797 	permit_scope = "";
      798 
      799 	if permit_requests.read_attr then
      800 	     permit_scope = permit_scope || "read_attr ";
      801 
      802 	if permit_requests.modify_attr then
      803 	     permit_scope = permit_scope || "modify_attr ";
      804 
      805 	if permit_requests.append_tuple then
      806 	     permit_scope = permit_scope || "append_tuple ";
      807 
      808 	if permit_requests.delete_tuple then
      809 	     permit_scope = permit_scope || "delete_tuple ";
      810 
      811 	if permit_scope = "" then
      812 	     permit_scope = "null ";
      813 
      814 	return (permit_scope);
      815 
      816 	declare permit_scope	 char (80) varying; /* message display format of scope */
      817 
      818      end;
      819 
      820 get_mrds_access: procedure () returns (char (120) varying);
      821 
      822 /* routine to get displayable form of current mrds acl's
      823*   for reporting in error messages */
      824 
      825 	mrds_access = "";
      826 
      827 	if attr_null_perm then
      828 
      829 	     mrds_access = mrds_access || "null on all attributes in the relation ";
      830 
      831 	else do;
      832 
      833 		if attr_retr_perm then
      834 		     mrds_access = mrds_access || "read_attr ";
      835 
      836 		if attr_modify_perm then
      837 		     mrds_access = mrds_access || "modify_attr ";
      838 
      839 		mrds_access = mrds_access || "on some attribute(s) in the relation ";
      840 
      841 	     end;
      842 
      843 	mrds_access = mrds_access || "and ";
      844 
      845 	if rel_append_perm then
      846 	     mrds_access = mrds_access || "append_tuple ";
      847 
      848 	if rel_delete_perm then
      849 	     mrds_access = mrds_access || "delete_tuple ";
      850 
      851 	if rel_null_perm then
      852 	     mrds_access = mrds_access || "null ";
      853 
      854 	mrds_access = mrds_access || "on the relation";
      855 
      856 
      857 	return (mrds_access);
      858 
      859 
      860 
      861 	declare mrds_access		 char (120) varying;/* display form of mrds acl's  */
      862 
      863      end;
      864 
      865 error:
      866      procedure (cd);
      867 
      868 	dcl     cd		 fixed bin (35);
      869 
      870 	code = cd;
      871 	call clean_up;
      872 	go to exit;
      873 
      874      end error;
      875 
      876 
      877 store_scope: procedure (ss_rmri_ptr);
      878 
      879 /*
      880*
      881*   This routine stores the scope request information associated with
      882*   a given relation.  The information updated is in the scope_info of
      883*   the user's resultant model and the fil_list (list of relations)
      884*   associated with the  user's user_list in the DBC.
      885*
      886**/
      887 
      888 	dcl     ss_rmri_ptr		 ptr;		/* (input) needed to pass to add_fil_list_entry */
      889 
      890 	scope_info.scope (pos_in_si).flags.touched = ON;
      891 
      892 	if permit_requests.read_attr then
      893 	     scope_info.scope (pos_in_si).flags.permits.read_attr = ON;
      894 
      895 	if permit_requests.modify_attr then
      896 	     scope_info.scope (pos_in_si).flags.permits.modify_attr = ON;
      897 
      898 	if permit_requests.append_tuple then
      899 	     scope_info.scope (pos_in_si).flags.permits.append_tuple = ON;
      900 
      901 	if permit_requests.delete_tuple then
      902 	     scope_info.scope (pos_in_si).flags.permits.delete_tuple = ON;
      903 
      904 	if prevent_requests.read_attr then
      905 	     scope_info.scope (pos_in_si).flags.prevents.read_attr = ON;
      906 
      907 	if prevent_requests.modify_attr then
      908 	     scope_info.scope (pos_in_si).flags.prevents.modify_attr = ON;
      909 
      910 	if prevent_requests.append_tuple then
      911 	     scope_info.scope (pos_in_si).flags.prevents.append_tuple = ON;
      912 
      913 	if prevent_requests.delete_tuple then
      914 	     scope_info.scope (pos_in_si).flags.prevents.delete_tuple = ON;
      915 
      916 	scope_info.active_scopes = scope_info.active_scopes + 1;
      917 
      918 	if first_scope_triple
      919 	then do;
      920 		flo_ptr = addr (user_list.fil_list_ofs);/* ptr to file list offset */
      921 		first_scope_triple = OFF;
      922 	     end;
      923 
      924 	call add_fil_list_entry (flo_ptr, ss_rmri_ptr);
      925 
      926 	flo_ptr = addr (fil_list.next_ofs);
      927 
      928 
      929 	return;
      930 
      931      end store_scope;
      932 
      933 add_fil_list_entry: proc (prev_ofs_ptr, afle_rmri_ptr);
      934 
      935 /*  *  This routine adds an entry in a fil_list.  If the user is quiescing
      936*   *  then default scope settings are assigned.  The user is also determined
      937*   *  as a non-passive user here if the scope request is update. */
      938 
      939 	dcl     prev_ofs_ptr	 ptr;		/* a pointer to the offset location which
      940*						   currently points to nowhere -- indicating it is currently
      941*						   the last file in the list */
      942 	dcl     afle_rmri_ptr	 ptr;		/* (input) to relation's rm_rel_info structure */
      943 	dcl     ophset		 bit (18) unal based; /* a based offset */
      944 
      945 
      946 	allocate fil_list in (dbc.static_area);
      947 	unspec (fil_list) = "0"b;			/* zero pad areas */
      948 	fil_list.name = model_rel_name;
      949 	fil_list.rmri_ptr = afle_rmri_ptr;
      950 
      951 	if user_list.open_mode = mdbm_data_$quiesce_mode
      952 	then do;
      953 		fil_list.permits.read_attr = ON;
      954 		fil_list.permits.modify_attr = ON;
      955 		fil_list.permits.append_tuple = ON;
      956 		fil_list.permits.delete_tuple = ON;
      957 
      958 		fil_list.prevents.read_attr = ON;
      959 		fil_list.prevents.modify_attr = ON;
      960 		fil_list.prevents.append_tuple = ON;
      961 		fil_list.prevents.delete_tuple = ON;
      962 	     end;
      963 	else do;
      964 		fil_list.permits.read_attr = permit_requests.read_attr;
      965 		fil_list.permits.modify_attr = permit_requests.modify_attr;
      966 		fil_list.permits.append_tuple = permit_requests.append_tuple;
      967 		fil_list.permits.delete_tuple = permit_requests.delete_tuple;
      968 
      969 		fil_list.prevents.read_attr = prevent_requests.read_attr;
      970 		fil_list.prevents.modify_attr = prevent_requests.modify_attr;
      971 		fil_list.prevents.append_tuple = prevent_requests.append_tuple;
      972 		fil_list.prevents.delete_tuple = prevent_requests.delete_tuple;
      973 	     end;
      974 
      975 	user_list.passive_sw = ON;
      976 	if permit_requests.modify_attr | permit_requests.append_tuple | permit_requests.delete_tuple then do;
      977 		fil_list.permits.update = ON;
      978 		user_list.passive_sw = OFF;		/* user wants to be permitted to do a store, a modify */
      979 	     end;					/*          or a delete --- thus, is a non-passive user */
      980 	if fil_list.prevents.modify_attr | fil_list.prevents.append_tuple | fil_list.prevents.delete_tuple then
      981 	     fil_list.prevents.update = ON;
      982 
      983 	fil_list.next_ofs = NULL_OFS;			/* this is last file in the list */
      984 	prev_ofs_ptr -> ophset = rel (fl_ptr);		/* update previous last file */
      985      end add_fil_list_entry;
      986 
      987 activate_user_scope: proc;
      988 
      989 /*
      990*   This procedure links a user to the list of active users.
      991*   If this is a non-initial attempt to set scope (ie, user was queued), then
      992*   this procedure delinks the user from the waiting list before adding the
      993*   user to the active list. It also makes a call to set the relation manager
      994*   scopes.
      995**/
      996 
      997 
      998 	if info.msg = QUE_FREE			/* not the first time this request has been made */
      999 						/* unlink from waiting list -- and from priority list */
     1000 	then call mu_de_queue_user (NO_DQ_OPEN, SAVE_FIL_LIST, dbc_ptr, (this_ul_ptr), icode);
     1001 
     1002 /* Link user to active list */
     1003 
     1004 	ulo_ptr = addr (dbc.active_users_ofs);
     1005 	ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
     1006 	do while (ul_ptr ^= null);
     1007 	     ulo_ptr = addr (user_list.next_active_ofs);
     1008 	     ul_ptr = convert (dbc_ptr, user_list.next_active_ofs);
     1009 	end;
     1010 	ulo_ptr -> ophset = rel (this_ul_ptr);		/* link user to active list */
     1011 	dbc.active_users = dbc.active_users + 1;
     1012 	ul_ptr = this_ul_ptr;
     1013 	user_list.active_sw = ON;
     1014 	user_list.waiting_sw = OFF;
     1015 
     1016 	call set_relmgr_scopes;
     1017 
     1018      end activate_user_scope;
     1019 
     1020 scopes_by_this_process: proc (sbtp_rel_name, sbtp_faul_ptr, sbtp_pid, sbtp_relmgr_my_permits, sbtp_relmgr_others_permits);
     1021 
     1022 /*
     1023*   This procedure looks at each user with active scopes in the user_list
     1024*   and for each user with the same process id as the current it user it
     1025*   looks for a scope for the input relation. For each scope it finds it
     1026*   takes the union of the permit and prevent ops to come up with a "scope"
     1027*   that can be passed to the relation manager set_scope routine.
     1028**/
     1029 
     1030 /* PARAMETERS */
     1031 
     1032 	dcl     sbtp_rel_name	 char (30);	/* (input) relation under consideration */
     1033 	dcl     sbtp_faul_ptr	 ptr;		/* (input) pointer to the first active_user user_list structure */
     1034 	dcl     sbtp_pid		 bit (36);	/* (input) process id of the current process */
     1035 	dcl     sbtp_relmgr_my_permits bit (2) aligned;	/* (input) */
     1036 						/*         bit 1 true => process has set a scope permit */
     1037 						/*               of read on at least 1 opening */
     1038 						/*         bit 2 true => process has set a scope permit of modify */
     1039 						/*               or delete or append on at least 1 opening */
     1040 	dcl     sbtp_relmgr_others_permits bit (2) aligned; /* (input) */
     1041 						/*         bit 1 false => process has set a scope prevent */
     1042 						/*                        of read on at least 1 of its openings */
     1043 						/*         bit 2 false => process has set a scope prevent of */
     1044 						/*                         at least modify or delete or append in each opening */
     1045 						/*                          and all 3 prevents are set at least once. */
     1046 
     1047 /* AUTOMATIC */
     1048 
     1049 	dcl     sbtp_aul_ptr	 ptr;		/* pointer to a active_user user_list structure */
     1050 	dcl     sbtp_fl_ptr		 ptr;		/* pointer to a file_list structure */
     1051 	dcl     sbtp_rel_found	 bit (1);		/* "1"b => current user has active scopes on the */
     1052 						/*         relation under consideration */
     1053 	dcl     sbtp_r_prevents	 bit (1);		/* true if the process as set an r prevent in any of its openings */
     1054 	dcl     sbtp_a_prevents	 bit (1);		/* true if the process as set an a prevent in any of its openings */
     1055 	dcl     sbtp_d_prevents	 bit (1);		/* true if the process as set an d prevent in any of its openings */
     1056 	dcl     sbtp_m_prevents	 bit (1);		/* true if the process as set an m prevent in any of its openings */
     1057 
     1058 
     1059 	sbtp_aul_ptr = sbtp_faul_ptr;
     1060 	sbtp_relmgr_my_permits = "00"b;
     1061 	sbtp_r_prevents = "0"b;
     1062 	sbtp_a_prevents = "0"b;
     1063 	sbtp_d_prevents = "0"b;
     1064 	sbtp_m_prevents = "0"b;
     1065 	do while (sbtp_aul_ptr ^= null ());
     1066 	     if sbtp_aul_ptr -> user_list.ids.process_id = sbtp_pid
     1067 	     then do;
     1068 		     sbtp_fl_ptr = convert (dbc_ptr, sbtp_aul_ptr -> user_list.offsets.fil_list_ofs);
     1069 		     sbtp_rel_found = "0"b;
     1070 		     do while ((sbtp_fl_ptr ^= null ()) & ^(sbtp_rel_found));
     1071 			if sbtp_fl_ptr -> fil_list.name = sbtp_rel_name
     1072 			then do;
     1073 				sbtp_rel_found = "1"b;
     1074 				sbtp_relmgr_my_permits =
     1075 				     sbtp_relmgr_my_permits |
     1076 				     sbtp_fl_ptr -> fil_list.permits.read_attr ||
     1077 				     sbtp_fl_ptr -> fil_list.permits.update;
     1078 				sbtp_r_prevents = sbtp_r_prevents | sbtp_fl_ptr -> fil_list.prevents.read_attr;
     1079 				sbtp_a_prevents = sbtp_a_prevents | sbtp_fl_ptr -> fil_list.prevents.append_tuple;
     1080 				sbtp_d_prevents = sbtp_d_prevents | sbtp_fl_ptr -> fil_list.prevents.delete_tuple;
     1081 				sbtp_m_prevents = sbtp_m_prevents | sbtp_fl_ptr -> fil_list.prevents.modify_attr;
     1082 			     end;
     1083 			else sbtp_fl_ptr = convert (dbc_ptr, sbtp_fl_ptr -> fil_list.next_ofs);
     1084 		     end;
     1085 		end;
     1086 	     sbtp_aul_ptr = convert (dbc_ptr, sbtp_aul_ptr -> user_list.offsets.next_active_ofs);
     1087 	end;
     1088 
     1089 	sbtp_relmgr_others_permits = ^sbtp_r_prevents || ^(sbtp_a_prevents & sbtp_d_prevents & sbtp_m_prevents);
     1090 
     1091 	return;
     1092 
     1093      end scopes_by_this_process;
     1094 
     1095 set_relmgr_scopes: proc;
     1096 
     1097 /*
     1098*   This  procedure  loops though each relation with scope set, opens
     1099*   the  relation  if its not yet open and determines the total scope
     1100*   the  calling  process  has  on  the  relation (if the database is
     1101*   opened  multiple  times  there can be different scopes).  It then
     1102*   tells the relation manager what this total scope is.
     1103**/
     1104 
     1105 /* AUTOMATIC */
     1106 
     1107 	dcl     srs_relmgr_my_permits	 bit (2) aligned;	/* bit 1 true => process has set a scope permit */
     1108 						/*               of read on at least 1 opening*/
     1109 						/* bit 2 true => process has set a scope permit of modify */
     1110 						/*               or delete or append on at least 1 opening*/
     1111 	dcl     srs_relmgr_others_permits bit (2) aligned;/* bit 1 false => process has set a scope prevent */
     1112 						/*                of read on at least 1 of its openings */
     1113 						/* bit 2 false => process has set a scope prevent of */
     1114 						/*                at least modify or delete or append in each opening */
     1115 						/*                 and all 3 prevents are set at least once. */
     1116 	dcl     srs_first_ul_ptr	 ptr;		/* pointer to first user list element */
     1117 	dcl     srs_fl_ptr		 ptr;		/* points to a fil_list structure */
     1118 	dcl     srs_process_id	 bit (36);	/* process id of caller */
     1119 	dcl     srs_rmri_ptr	 ptr;		/* pointer to rm_rel_info structure */
     1120 
     1121 
     1122 	srs_first_ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
     1123 	srs_fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
     1124 	srs_process_id = get_process_id_ ();
     1125 	do while (srs_fl_ptr ^= null ());
     1126 	     srs_rmri_ptr = srs_fl_ptr -> fil_list.rmri_ptr;
     1127 	     srs_rmri_ptr = pointer (baseptr (baseno (srs_rmri_ptr)), rel (srs_rmri_ptr));
     1128 	     if srs_rmri_ptr -> rm_rel_info.opening_id = "0"b
     1129 	     then call open_relation (srs_rmri_ptr);
     1130 	     call scopes_by_this_process (srs_fl_ptr -> fil_list.name,
     1131 		srs_first_ul_ptr, srs_process_id,
     1132 		srs_relmgr_my_permits, srs_relmgr_others_permits);
     1133 	     call dbcb.relmgr_entries.set_scope (srs_rmri_ptr -> rm_rel_info.opening_id,
     1134 		srs_relmgr_my_permits, srs_relmgr_others_permits, icode);
     1135 	     if icode ^= 0
     1136 	     then call error (icode);
     1137 	     srs_fl_ptr = convert (dbc_ptr, srs_fl_ptr -> fil_list.next_ofs);
     1138 	end;
     1139 
     1140 	return;
     1141 
     1142      end set_relmgr_scopes;
     1143 
     1144 clean_up:
     1145      proc;
     1146 
     1147 	if dbc_ptr ^= null
     1148 	then do;
     1149 		if code ^= error_table_$lock_wait_time_exceeded
     1150 		then do;
     1151 						/* if a timeout then leave scope as is */
     1152 
     1153 /* if this user is on either the active or waiting list --- then delink */
     1154 /* also, reset all counts , tallies, etc */
     1155 
     1156 			if empty_on_err
     1157 			then do;
     1158 				call mu_empty_scope (dbcb.dbc_ptr, dbcb.scope_ptr, dbcb.rdbi_ptr, "1"b);
     1159 						/* delink */
     1160 				call set_relmgr_scopes;
     1161 			     end;
     1162 		     end;
     1163 		call set_lock_$unlock (dbc.scope_lock, icode);
     1164 	     end;
     1165      end clean_up;
     1166 
     1167 queue_scope:
     1168      proc (first_time_asleep);
     1169 
     1170 	dcl     first_time_asleep	 bit (1);
     1171 
     1172 	ul_ptr = this_ul_ptr;
     1173 	if first_time_asleep
     1174 	then do;
     1175 		call ipc_$create_ev_chn (user_list.ev_chn_id, state);
     1176 						/* create an event channel on which we can
     1177*						   receive a wakeup message
     1178*						   or a timer runout message */
     1179 		if state ^= 0
     1180 		then call error (mrds_error_$unable_to_create_channel);
     1181 		wait_list.chn_id = user_list.ev_chn_id;
     1182 		wait_list.nchn = 1;
     1183 		user_list.priority_high = OFF;
     1184 		user_list.waiting_sw = ON;
     1185 		user_list.active_sw = OFF;
     1186 		user_list.allowance_count = dbc.active_users + dbc.waiting_users + WAIT;
     1187 		ulo_ptr = addr (dbc.waiting_users_ofs);
     1188 		ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);
     1189 		do while (ul_ptr ^= null);
     1190 		     ulo_ptr = addr (user_list.next_waiting_ofs);
     1191 		     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
     1192 		end;
     1193 		ulo_ptr -> ophset = rel (this_ul_ptr);	/* link user to waiting list */
     1194 		dbc.waiting_users = dbc.waiting_users + 1;
     1195 		ul_ptr = this_ul_ptr;
     1196 
     1197 		call set_lock_$unlock (dbc.scope_lock, icode);
     1198 
     1199 		wait_sec_fb71 = wait_seconds;		/* move to fixed bin (71) variable */
     1200 		call timer_manager_$alarm_wakeup (wait_sec_fb71, REL_SEC, user_list.ev_chn_id);
     1201 						/* set max wait time */
     1202 		icode = 0;			/* not a real error, just reporting */
     1203 		call report_conflict_detail (BEING_QUEUED_REPORT);
     1204 	     end;
     1205 
     1206 	else do;
     1207 		user_list.event_signal_sw = OFF;
     1208 		user_list.queue_activ = OFF;
     1209 		call set_lock_$unlock (dbc.scope_lock, icode);
     1210 	     end;
     1211 
     1212 	call ipc_$block (addr (wait_list), addr (info), state);
     1213 						/* go blocked */
     1214 	if state ^= 0
     1215 	then call error (mrds_error_$unable_to_queue_user);
     1216 
     1217 
     1218      end queue_scope;
     1219 
     1220 awakened: proc;
     1221 
     1222 /* There are two possible ways we could have been awakened:
     1223*   if we ran out of time (message of ALARM), or by set/dl_fscope (msg of QUE_FREE)
     1224*   If we timed out, we must give up with an error message; if awakened by dl_fscope then scope has been freed so
     1225*   we're going to try again. Note that the scope lock must be re-locked in order for us to check for a conflict */
     1226 
     1227 	dcl     idx		 fixed bin;
     1228 
     1229 	if info.msg = ALARM				/* timed-out, so quit */
     1230 	then do;
     1231 		user_list.event_signal_sw = OFF;
     1232 		icode = error_table_$lock_wait_time_exceeded;
     1233 						/* Try 3 times before we give it up.  If we get the lock then we can dequeue */
     1234 		do idx = 1 to 3 while (icode ^= 0);
     1235 		     call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
     1236 		     if icode = error_table_$invalid_lock_reset |
     1237 			icode = error_table_$locked_by_this_process
     1238 		     then icode = 0;
     1239 		end;
     1240 		if icode ^= 0 then
     1241 		     /* Some one hung the scope queue, so DBA should check at it. */
     1242 		     dbc.trouble_switch = ON;
     1243 		icode = mrds_error_$db_busy;
     1244 		call report_conflict_detail (TIME_OUT_REPORT);
     1245 		call error (icode);
     1246 	     end;
     1247 
     1248 	call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
     1249 	if icode = error_table_$invalid_lock_reset |
     1250 	     icode = error_table_$locked_by_this_process
     1251 	then icode = 0;				/* these error codes are expected */
     1252 
     1253 	if icode ^= 0
     1254 	then do;
     1255 		dbc.trouble_switch = ON;
     1256 		call error (icode);
     1257 	     end;
     1258 
     1259 	if info.msg = QUE_FREE			/* awakened by dl_fscope */
     1260 	then do;
     1261 		ul_ptr = this_ul_ptr;
     1262 		user_list.queue_activ = ON;
     1263 
     1264 		if user_list.dead_proc_conflict
     1265 		then call error (mrds_error_$db_conflict_dead_process);
     1266 
     1267 
     1268 		conflict_sw = OFF;			/* re-check for conflict */
     1269 		do idx = 1 to scope_info.nfiles while (^conflict_sw);
     1270 		     re_check = ON;
     1271 		     do while (re_check);
     1272 			re_check = OFF;
     1273 			model_rel_name = scope_info.scope.name (idx);
     1274 			submodel_rel_name = scope_info.scope.sm_name (idx);
     1275 
     1276 			unspec (remembered_permits), unspec (remembered_prevents) = "0"b; /* init */
     1277 
     1278 			remembered_permits.read_attr =
     1279 			     scope_info.scope (idx).flags.permits.read_attr;
     1280 			remembered_permits.modify_attr =
     1281 			     scope_info.scope (idx).flags.permits.modify_attr;
     1282 			remembered_permits.append_tuple =
     1283 			     scope_info.scope (idx).flags.permits.append_tuple;
     1284 			remembered_permits.delete_tuple =
     1285 			     scope_info.scope (idx).flags.permits.delete_tuple;
     1286 
     1287 			remembered_prevents.read_attr =
     1288 			     scope_info.scope (idx).flags.prevents.read_attr;
     1289 			remembered_prevents.modify_attr =
     1290 			     scope_info.scope (idx).flags.prevents.modify_attr;
     1291 			remembered_prevents.append_tuple =
     1292 			     scope_info.scope (idx).flags.prevents.append_tuple;
     1293 			remembered_prevents.delete_tuple =
     1294 			     scope_info.scope (idx).flags.prevents.delete_tuple;
     1295 
     1296 			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (remembered_permits),
     1297 			     addr (remembered_prevents), addr (actual_conflict_detail),
     1298 			     conflict_sw, conflict_ul_ptr);
     1299 
     1300 			if conflict_sw then do;
     1301 				call check_dead_proc (conflict_sw, status);
     1302 				if ^conflict_sw then /* conflict was worked out */
     1303 				     re_check = ON;
     1304 				else do;
     1305 					conflict_user_id = conflict_ul_ptr -> user_list.ids.group_id;
     1306 					conflict_relation = submodel_rel_name;
     1307 					conflict_detail_known = ON;
     1308 					if status = DEAD then do; /* non-passive dead_proc remains */
     1309 						icode = mrds_error_$db_conflict_dead_process;
     1310 						call report_conflict_detail (DEAD_PROC_REPORT);
     1311 						call error (icode);
     1312 					     end;
     1313 				     end;
     1314 			     end;
     1315 		     end;
     1316 		end;
     1317 
     1318 		if conflict_sw then do;
     1319 			call wakeup_next_waiter;
     1320 			if ul_ptr ^= null then do;
     1321 				user_list.event_signal_sw = OFF;
     1322 				user_list.bypass_count = user_list.bypass_count + 1;
     1323 			     end;
     1324 			if dbc.wakeup_waiters > 0 then
     1325 			     dbc.wakeup_waiters = dbc.wakeup_waiters - 1;
     1326 			call queue_scope (QUEUE_AGAIN);
     1327 		     end;
     1328 		else do;
     1329 			if substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b then /* debug display on */
     1330 			     call ioa_ ("^/Scope request granted from queue.");
     1331 			call activate_user_scope;
     1332 			dbc.wakeup_waiters = dbc.wakeup_waiters - 1;
     1333 			user_list.event_signal_sw = OFF;
     1334 			if ^(prevent_requests.append_tuple &
     1335 			     prevent_requests.delete_tuple &
     1336 			     prevent_requests.modify_attr &
     1337 			     prevent_requests.read_attr)
     1338 						/* If user is preventing anyone from doing anything,
     1339*						   useless to wakeup someone */
     1340 			then call wakeup_next_waiter; /* Here such is not the case */
     1341 		     end;
     1342 	     end;
     1343 
     1344      end awakened;
     1345 
     1346 wakeup_next_waiter:
     1347      proc;
     1348 
     1349 /*
     1350*   This routine looks through the waiting queue for a user that can be awakened to set scope.
     1351*   It looks for only one such user; it is the responsible of the newly awakened user to wake up the next (as
     1352*   this processis doing now).
     1353**/
     1354 
     1355 	wakeup = OFF;
     1356 	ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);
     1357 
     1358 	do while (ul_ptr ^= null & ^wakeup);
     1359 	     if ^user_list.event_signal_sw
     1360 	     then do;
     1361 
     1362 /* Check each relation (file). */
     1363 
     1364 		     fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
     1365 		     wakeup = ON;
     1366 		     conflict_sw = OFF;
     1367 
     1368 		     do while (fl_ptr ^= null & ^conflict_sw);
     1369 
     1370 			model_rel_name = fil_list.name;
     1371 
     1372 			unspec (actual_permits), unspec (actual_prevents) = "0"b; /* init */
     1373 
     1374 			actual_permits.read_attr = fil_list.permits.read_attr;
     1375 			actual_permits.modify_attr = fil_list.permits.modify_attr;
     1376 			actual_permits.append_tuple = fil_list.permits.append_tuple;
     1377 			actual_permits.delete_tuple = fil_list.permits.delete_tuple;
     1378 
     1379 			actual_prevents.read_attr = fil_list.prevents.read_attr;
     1380 			actual_prevents.modify_attr = fil_list.prevents.modify_attr;
     1381 			actual_prevents.append_tuple = fil_list.prevents.append_tuple;
     1382 			actual_prevents.delete_tuple = fil_list.prevents.delete_tuple;
     1383 
     1384 			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (actual_permits),
     1385 			     addr (actual_prevents), addr (unused_conflict_detail),
     1386 			     conflict_sw, conflict_ul_ptr);
     1387 
     1388 /* If there was a conflict, see if it is because of a dead process.
     1389*   If there is a dead process that was passive, it will be de-queued and this process will continue checkin the files;
     1390*   Otherwise it will give up on this user. */
     1391 
     1392 			if conflict_sw then do;
     1393 				call check_dead_proc (conflict_sw, status);
     1394 				if conflict_sw then
     1395 				     wakeup = OFF;
     1396 			     end;
     1397 			else fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
     1398 		     end;
     1399 
     1400 		     if wakeup
     1401 		     then do;
     1402 			     call hcs_$wakeup (user_list.process_id, user_list.ev_chn_id, QUE_FREE, state);
     1403 			     if state ^= 0
     1404 			     then wakeup = OFF;
     1405 			     else do;
     1406 				     user_list.event_signal_sw = ON;
     1407 				     dbc.wakeup_waiters = dbc.wakeup_waiters + 1;
     1408 				end;
     1409 			end;
     1410 
     1411 		     if ^wakeup
     1412 		     then do;
     1413 			     user_list.bypass_count = user_list.bypass_count + 1;
     1414 			     if user_list.bypass_count > user_list.allowance_count
     1415 			     then user_list.priority_high = ON;
     1416 			end;
     1417 		end;
     1418 
     1419 	     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
     1420 	end;
     1421 
     1422      end wakeup_next_waiter;
     1423 
     1424 check_dead_proc:
     1425      proc (conflict_sw, status);
     1426 
     1427 /*
     1428*   This routine checks for a potential stiff (dead process pointed to by conflict_ul_ptr) and does what it can about it.
     1429*   If the process is dead and was a passive user, that process is de-queued.
     1430*   If dead and non_passive then it alerts the dbc to the fact that the db might be in an inconsistent state.
     1431**/
     1432 
     1433 	dcl     conflict_sw		 bit (1);
     1434 	dcl     status		 bit (1);
     1435 
     1436 /* Find out if conflicting proc is dead or alive. */
     1437 
     1438 	if conflict_ul_ptr -> user_list.dead_proc
     1439 	then status = DEAD;
     1440 	else do;
     1441 		call set_lock_$lock ((conflict_ul_ptr -> user_list.db_lock_id), 0, state);
     1442 		if state = 0
     1443 		then status = ALIVE;
     1444 		else if state = error_table_$invalid_lock_reset
     1445 		then status = DEAD;
     1446 		else if state = error_table_$locked_by_this_process
     1447 		     | state = error_table_$lock_wait_time_exceeded
     1448 		then status = ALIVE;
     1449 		else call error (state);
     1450 	     end;
     1451 
     1452 /* Now try and de-queue if dead/passive, quit if dead/non-passive, nothing if alive. */
     1453 
     1454 	if status = DEAD
     1455 	then if conflict_ul_ptr -> user_list.passive_sw
     1456 	     then do;
     1457 		     conflict_sw = OFF;
     1458 		     call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, conflict_ul_ptr, icode);
     1459 		     if icode ^= 0
     1460 		     then call error (icode);
     1461 		end;
     1462 	     else do;
     1463 		     dbc.dead_proc_flag = ON;
     1464 		     conflict_ul_ptr -> user_list.dead_proc = ON;
     1465 		     user_list.dead_proc_conflict = ON;
     1466 		end;
     1467 
     1468 	return;
     1469 
     1470      end check_dead_proc;
     1471 
     1472 convert:
     1473      proc (a_ptr, ofs) returns (ptr);
     1474 
     1475 	dcl     a_ptr		 ptr;
     1476 	dcl     ofs		 bit (18) unal;
     1477 
     1478 	if ofs = NULL_OFS
     1479 	then return (null);
     1480 	else return (ptr (a_ptr, ofs));
     1481 
     1482      end convert;
     1483 
     1484 open_relation: proc (or_rmri_ptr);
     1485 
     1486 /*
     1487*   This procedure opens a relation, it assumes that the relation is
     1488*   not yet opened, i.e. rm_rel_info.opening_id = "0"b
     1489**/
     1490 
     1491 /* PARAMETERS */
     1492 
     1493 	dcl     or_rmri_ptr		 ptr;		/* (input) pointer to the rm_rel_info of the relation to be opened */
     1494 
     1495 /* AUTOMATIC */
     1496 
     1497 	dcl     or_code		 fixed bin (35);	/* standard error code */
     1498 	dcl     or_rdbi_ptr		 ptr;		/* pointer to the database's rm_db_info structure */
     1499 
     1500 
     1501 
     1502 
     1503 	or_rdbi_ptr = pointer (or_rmri_ptr, 0);
     1504 
     1505 	call dbcb.relmgr_entries.open ((or_rdbi_ptr -> rm_db_info.db_path),
     1506 	     (or_rmri_ptr -> rm_rel_info.model_name),
     1507 	     or_rmri_ptr -> rm_rel_info.opening_id,
     1508 	     or_code);
     1509 	if or_code ^= 0
     1510 	then call error (or_code);
     1511 
     1512 	return;
     1513 
     1514      end open_relation;
     1515 
     1516 report_conflict_detail: procedure (report_type);
     1517 
     1518 /* report the detail of the conflict preventing this scope request
     1519*   from being granted. reports are at three times, upon being queued for the first
     1520*   time, upon time out after waiting in the queue, and upon detection
     1521*   of a non-passive dead process */
     1522 
     1523 	if substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b then do; /* if debug display on */
     1524 		if report_type = DEAD_PROC_REPORT then
     1525 		     report_reason = "A non passive dead process is blocking scope requests.";
     1526 		else if report_type = BEING_QUEUED_REPORT then
     1527 		     report_reason = "You are queued until a conflict is overcome, or wait time is exceeded.";
     1528 		else if report_type = TIME_OUT_REPORT then
     1529 		     report_reason = "Your wait time elapsed without being able to resolve the conflict.";
     1530 
     1531 		call ioa_ ("^/^a", report_reason);
     1532 
     1533 	     end;
     1534 
     1535 	if conflict_detail_known &
     1536 	     (report_type ^= BEING_QUEUED_REPORT | substr (db_mrds_dsl_set_fscope, 1, 1) = "1"b) then do;
     1537 
     1538 		permit_conflict = "";
     1539 
     1540 		if actual_conflict_detail.permits.read_attr then
     1541 		     permit_conflict = permit_conflict || "read_attr ";
     1542 
     1543 		if actual_conflict_detail.permits.modify_attr then
     1544 		     permit_conflict = permit_conflict || "modify_attr ";
     1545 
     1546 		if actual_conflict_detail.permits.append_tuple then
     1547 		     permit_conflict = permit_conflict || "append_tuple ";
     1548 
     1549 		if actual_conflict_detail.permits.delete_tuple then
     1550 		     permit_conflict = permit_conflict || "delete_tuple ";
     1551 
     1552 		if permit_conflict = "" then
     1553 		     permit_conflict = "null ";
     1554 
     1555 		prevent_conflict = "";
     1556 
     1557 		if actual_conflict_detail.prevents.read_attr then
     1558 		     prevent_conflict = prevent_conflict || "read_attr ";
     1559 
     1560 		if actual_conflict_detail.prevents.modify_attr then
     1561 		     prevent_conflict = prevent_conflict || "modify_attr ";
     1562 
     1563 		if actual_conflict_detail.prevents.append_tuple then
     1564 		     prevent_conflict = prevent_conflict || "append_tuple ";
     1565 
     1566 		if actual_conflict_detail.prevents.delete_tuple then
     1567 		     prevent_conflict = prevent_conflict || "delete_tuple ";
     1568 
     1569 		if prevent_conflict = "" then
     1570 		     prevent_conflict = "null ";
     1571 
     1572 		call sub_err_ (icode, caller_name, continue, info_ptr, return_value,
     1573 		     "^/^a^a^a^a^a^/^a^a^a^a^a",
     1574 		     "The user """, conflict_user_id, """ has prevents conflicting with requested permits of """,
     1575 		     permit_conflict, """", "and/or permits conflicting with requested prevents of """,
     1576 		     prevent_conflict, """ on relation """, conflict_relation, """.");
     1577 
     1578 		return;
     1579 
     1580 
     1581 		declare (permit_conflict, prevent_conflict) char (80) varying; /* extra scope that was not present */
     1582 		declare report_type		 fixed bin; /* encoding for caller */
     1583 		declare report_reason	 char (120) varying; /* detail about caller */
     1584 
     1585 	     end;
     1586 
     1587      end;
     1588 
     1589 /***********
     1590**
     1591**   These routines are used by the transaction processing include files.
     1592**   Restore_significant_data is called to reinitialize variables in case
     1593**   of a rollback.  Should_rollback determines whether a transaction should
     1594**   be rolled back or aborted on error.  Currently, it is always aborted.
     1595**
     1596***********/
     1597 
     1598 
     1599 restore_significant_data:
     1600      proc;
     1601 	user_list.queue_activ = OFF;
     1602 	user_list.bypass_count = 0;
     1603 	check_scope = ON;				/* OFF-> don't bother checking for conflict */
     1604 	conflict_sw = OFF;				/* ON -> a conflict was found */
     1605 	re_check = OFF;				/* ON -> a conflict was resolved, so try again */
     1606 	first_scope_triple = ON;			/* Processing firstrelation in scope request */
     1607      end restore_significant_data;
     1608 
     1609 
     1610 
     1611 should_rollback:
     1612      proc returns (bit (1));
     1613 	return ("0"b);
     1614 						/* No rollbacks requested or desired */
     1615      end should_rollback;
     1616 
     1617 
     1618 /* Based */
     1619 	dcl     db_index		 fixed bin (35) based (dbi_ptr),
     1620 						/* index of data base to perform set_fscope upon */
     1621 	        rel_name		 char (rel_len) based (rel_ptr);
     1622 						/* relation name part of scope tuple */
     1623 
     1624 	dcl     code		 fixed bin (35) based (cd_ptr);
     1625 						/* standard return code */
     1626 
     1627 /* Automatic structures */
     1628 
     1629 	dcl     1 wait_list,
     1630 		2 nchn		 fixed bin,	/* one event channel */
     1631 		2 chn_id		 (1) fixed bin (71);/* channel id */
     1632 
     1633 	dcl     1 info,				/* event information */
     1634 		2 chn_id		 fixed bin (71),
     1635 		2 msg		 fixed bin (71),	/* message from process doing the awakening */
     1636 		2 sender		 bit (36),	/* process id of the process doing the awakening */
     1637 		2 origin,
     1638 		  3 dev_sig	 bit (18) unal,	/* device signal */
     1639 		  3 ring		 bit (18) unal,	/* ring  id */
     1640 		2 chn_index	 fixed bin;	/* index of the channel id */
     1641 	dcl     ptr_bit_string	 bit (72) based;	/* bit string value of a pointer variable */
     1642 	dcl     state		 fixed bin (35);	/* return code from set_lock and ipc_  */
     1643 	dcl     empty_on_err	 bit (1) aligned init ("0"b);
     1644 						/* ON if we are to empty scope in case of error */
     1645 	dcl     check_scope		 bit (1);		/* OFF=>don't bother checking for conflict: either */
     1646 						/* ..there are no active users to contend with, or */
     1647 						/* ..there are active users and we are trying to set */
     1648 						/* ..an exclusive setting; thus cannot succeed */
     1649 	dcl     re_check		 bit (1);		/* ON if we are to re-check for conflict */
     1650 	dcl     first_scope_triple	 bit (1);		/* ON if we are still
     1651*						   processing the first rel of scope request */
     1652 	dcl     wakeup		 bit (1);		/* ON if we are to wake this waiting user up */
     1653 	dcl     conflict_sw		 bit (1) unal;	/* ON => conflict between
     1654*						   desired scope and scope in effect now */
     1655 	dcl     status		 bit (1) unal;	/* status code of DEAD or ALIVE */
     1656 	dcl     wait_seconds	 fixed bin (35) based (ws_ptr);
     1657 						/* seconds this user is willing to wait */
     1658 	dcl     wait_sec_fb71	 fixed bin (71);	/* fixed bin (71) format for wait_seconds param. */
     1659 	dcl     entry_name		 char (32);	/* name by which this procedure was called */
     1660 	dcl     model_rel_name	 char (30);	/* name of relation in model for which scope is to be set */
     1661 	declare submodel_rel_name	 char (32);	/* submodel version of rel name */
     1662 	dcl     (
     1663 	        nargs,				/* number of arguments passed */
     1664 	        arg_len,
     1665 	        num_tuples,				/* number of scope tuples to be defined */
     1666 	        i,
     1667 	        l,
     1668 	        pos_in_si,
     1669 	        args_exp,				/* number of args in the calling argument list */
     1670 	        arg_index,				/* index to 1st arg of current tuple in arg list */
     1671 	        rel_len
     1672 	        )			 fixed bin;	/* length of rel_name in chars */
     1673 
     1674 	dcl     icode		 fixed bin (35);	/* internal status code */
     1675 
     1676 
     1677 	dcl     rel_name_32		 char (32);	/* Used for searching rel_array */
     1678 	dcl     ophset		 bit (18) unal based;
     1679 						/* a based offset */
     1680 
     1681 	dcl     (
     1682 	        cd_ptr,				/* pointer to code */
     1683 	        dbi_ptr,				/* pointer to db_index */
     1684 	        ws_ptr,				/* ptr to wait time in seconds */
     1685 	        conflict_ul_ptr,			/* ptr to a user who conflicts with requested scope */
     1686 	        rel_ptr,				/* pointer to rel_name */
     1687 	        ulo_ptr,				/* ptr to the last 'next' offset in the user_list */
     1688 	        flo_ptr,				/* ptr to the last 'next' offset
     1689*						   in the fil_list(list of rels) */
     1690 	        this_ul_ptr				/* ptr to a given user list entry */
     1691 	        )			 ptr;		/* pointer to prevent ops */
     1692 
     1693 
     1694 	dcl     (any_other, cleanup, quit, arg_error)
     1695 				 condition;
     1696 
     1697 	dcl     (addr, divide, length, mod,
     1698 	        null, pointer, rel, baseno, baseptr)
     1699 				 builtin;
     1700 
     1701 
     1702 /*                    Multics subroutines                     */
     1703 
     1704 	dcl     cu_$arg_count	 entry (fixed bin),
     1705 	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35)),
     1706 	        get_process_id_	 entry returns (bit (36)),
     1707 	        ipc_$block		 entry (ptr, ptr, fixed bin (35)),
     1708 	        ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35)),
     1709 	        timer_manager_$alarm_wakeup
     1710 				 entry (fixed bin (71), bit (2), fixed bin (71)),
     1711 	        hcs_$wakeup		 entry (bit (*), fixed bin (71), fixed bin (71), fixed bin (35)),
     1712 	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
     1713 	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
     1714 
     1715 /*                    Other subroutines                    */
     1716 
     1717 	dcl     mu_empty_scope	 entry (ptr, ptr, ptr, bit (1) unal),
     1718 	        mu_database_index$get_resultant_model_pointer
     1719 				 entry (fixed bin (35), ptr),
     1720 	        mu_check_scope	 entry (ptr, ptr, ptr, ptr, ptr, ptr, bit (1), ptr),
     1721 	        mu_de_queue_user
     1722 				 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));
     1723 
     1724 /*                    External data                    */
     1725 	dcl     error_table_$lock_wait_time_exceeded
     1726 				 fixed bin (35) ext,
     1727 	        error_table_$locked_by_this_process
     1728 				 fixed bin (35) ext,
     1729 	        error_table_$invalid_lock_reset
     1730 				 fixed bin (35) ext,
     1731 	        mdbm_data_$quiesce_mode
     1732 				 fixed bin (35) ext,
     1733 	        mrds_data_$lock_wait_time
     1734 				 fixed bin (35) ext,
     1735 	        mrds_error_$unable_to_create_channel
     1736 				 fixed bin (35) ext,
     1737 	        mrds_error_$duplicate_scope
     1738 				 fixed bin (35) ext,
     1739 	        mrds_error_$invalid_db_index
     1740 				 fixed bin (35) ext,
     1741 	        mrds_error_$rel_name_too_long
     1742 				 fixed bin (35) ext,
     1743 	        mrds_error_$scope_not_empty
     1744 				 fixed bin (35) ext,
     1745 	        mrds_error_$unknown_relation_name
     1746 				 fixed bin (35) ext,
     1747 	        mrds_error_$non_scope_ready
     1748 				 fixed bin (35) ext,
     1749 	        mrds_error_$db_conflict_dead_process
     1750 				 fixed bin (35) ext,
     1751 	        mrds_error_$db_busy	 fixed bin (35) ext,
     1752 	        mrds_error_$unable_to_queue_user
     1753 				 fixed bin (35) ext,
     1754 	        mrds_error_$update_not_allowed
     1755 				 fixed bin (35) ext,
     1756 	        sys_info$max_seg_size	 fixed bin (35) ext;
     1757 
     1758 	dcl     NULL_CHAR		 char (8) init ("");
     1759 	dcl     OFF		 bit (1) init ("0"b) static internal options (constant);
     1760 	dcl     ON		 bit (1) init ("1"b) static internal options (constant);
     1761 
     1762 /* sub_err_ declarations */
     1763 
     1764 	declare sub_err_		 entry options (variable); /* reports error detail */
     1765 	declare continue		 char (1) init ("c"); /* dont stop after printing */
     1766 	declare caller_name		 char (32) init ("mrds_dsl_set_fscope"); /* name of calling routine */
     1767 	declare info_ptr		 ptr init (null ());/* unused */
     1768 	declare return_value	 fixed bin (35) init (0); /* unused */
     1769 	declare 1 (actual_permits, actual_prevents, remembered_permits, remembered_prevents) like common;
     1770 	declare attr_retr_perm	 bit (1);		/* on => retr access permission */
     1771 	declare attr_modify_perm	 bit (1);		/* on => modify on some attr */
     1772 	declare attr_null_perm	 bit (1);		/* on => null on some attr */
     1773 	declare rel_append_perm	 bit (1);		/* on => append-tuple access permission */
     1774 	declare rel_delete_perm	 bit (1);		/* on => delete tuple access permission */
     1775 	declare rel_null_perm	 bit (1);		/* on => null tuple access permission */
     1776 	declare 1 actual_conflict_detail,		/* detail of scope denial */
     1777 		2 permits		 like common,
     1778 		2 prevents	 like common;
     1779 	declare 1 unused_conflict_detail,		/* thorw away detail */
     1780 		2 permits		 like common,
     1781 		2 prevents	 like common;
     1782 	declare TIME_OUT_REPORT	 fixed bin init (1);/* report reason for last conflict before time out */
     1783 	declare BEING_QUEUED_REPORT	 fixed bin init (2);/* report for first conflict forcing queueing  */
     1784 	declare DEAD_PROC_REPORT	 fixed bin init (3);/* report detail on non-passive dead proc conflict */
     1785 	declare conflict_detail_known	 bit (1) init ("0"b); /* on => conflict_detail data set up */
     1786 	declare conflict_user_id	 char (32);	/* user id of user causing conflict */
     1787 	declare conflict_relation	 char (32);	/* name of relation conflict occured at */
     1788 	declare ioa_		 entry options (variable); /* reports debug display info */
     1789 	declare null_request	 bit (1);		/* on => no permits/prevents requested */
     1790 	declare null_permit_request	 bit (1);		/* on => no permits specified */
     1791 	declare null_prevent_request	 bit (1);		/* on => no prevents specified */
     1792 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* DBA detecter */
     1793 	declare local_area		 area (100);	/* space for DBA info */
     1794 	dcl     empty		 builtin;
     1795 	dcl     fixed		 builtin;
     1796 	dcl     index		 builtin;
     1797 	dcl     ptr		 builtin;
     1798 	dcl     rtrim		 builtin;
     1799 	dcl     string		 builtin;
     1800 	dcl     substr		 builtin;
     1801 	dcl     unspec		 builtin;
     1802 
  5     1 /* BEGIN INCLUDE FILE mdbm_scope_requests.incl.pl1 - - Jim Gray 80-12-10 */
  5     2 
  5     3 /* this include file contains overlays for the fixed bin (17)
  5     4*   permit/prevent scope mode encoding that set/dl_fscope and all lower
  5     5*   routines use in interface communications.
  5     6*   Note that is fixed bin(17) aligned, as recieved from
  5     7*   mrds_dsl_set_scope, thus the overlay is for a full 36 bit word.
  5     8*   The scope modes are encoded as a sum of the individual permissions,
  5     9*   with 1 => read_attr, 2 => append_tuple, 4 => delete_tuple, 8 => modify_attr,
  5    10*   thus individual bits in the fixed bin word can be used for each mode
  5    11*   These were known as r-s-m-d modes by old mrds users. */
  5    12 
  5    13 declare 1 common based,				/* common layout of bits for scope modes */
  5    14         2 mbz1 bit (32) unal,				/* unused upper part of word */
  5    15         2 modify_attr bit (1) unal,			/* mode sum has an 8 */
  5    16         2 delete_tuple bit (1) unal,			/* mode sum has a 4 */
  5    17         2 append_tuple bit (1) unal,			/* mode sum has a 2 */
  5    18         2 read_attr bit (1) unal ;			/* mode sum has a 1 */
  5    19 
  5    20 declare 1 permit_requests like common based (permit_requests_ptr) ; /* permit modes in scope call */
  5    21 
  5    22 declare 1 prevent_requests like common based (prevent_requests_ptr) ; /* prevent modes in scope call */
  5    23 
  5    24 declare (permit_requests_ptr, prevent_requests_ptr) ptr ;
  5    25 
  5    26 /* the following structure is used to describe in detail,
  5    27*   what scope conflict existed between a users requested
  5    28*   permit/prevent modes in a set/dl_scope call and the
  5    29*   actual usage of a file/relation currently with active scope in the database
  5    30*   Note that for delete_scope, the conflict check is that the requested deletion
  5    31*   be a subset of the users currently set scope.
  5    32*   For set_scope, the conflict check is that a permit does not conflict with
  5    33*   another users prevent, and that the requested prevent does not
  5    34*   conflict with an existing other users permit already granted. */
  5    35 
  5    36 declare 1 conflict_detail based (conflict_detail_ptr),
  5    37         2 permits like common,			/* conflicts in permit part of requests */
  5    38         2 prevents like common ;			/* conflicts in prevent part of requests */
  5    39 
  5    40 declare  conflict_detail_ptr ptr ;
  5    41 
  5    42 /* END INCLUDE FILE mdbm_scope_requests.incl.pl1 */
     1803 
     1804 
  6     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
  6     2 
  6     3 /* this include file associates module names with debug switches
  6     4*   that are stored in the data segment mrds_debug_
  6     5*   each module has it's own bit(9) debug switch, to define for various
  6     6*   debug actions, with new module names to be added to the end
  6     7*   of this list using the next in order array index in mrds_debug_
  6     8*   the convention for naming is db_{module's full name}
  6     9*   for the defined declaration over mrds_debug_$switch.
  6    10*   module.name array is then changed to reflect the new
  6    11*   number of modules, with the full module name added to the bottom
  6    12*   of the initialize list for the name array.
  6    13*   the module name array is used by the command level interface that sets/resets
  6    14*   the current status of the debug switches for each module.
  6    15*   the modules themselves use the db_{module name} declared variable for
  6    16*   that module to interagate the bits for proper debug action to take.
  6    17*   the definition of the meaning of the 9-bits is up to each individual module's
  6    18*   designer. */
  6    19 
  6    20 
  6    21 /*
  6    22*   HISTORY
  6    23*
  6    24*   80-11-12 Davids: added db_mus_mod_ubtup
  6    25*
  6    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
  6    27*
  6    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
  6    29*   error  info  about  being queued, and request being granted after
  6    30*   being queued.
  6    31*
  6    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
  6    33*   running  MR8  and  MR9 mrds against the same database at the same
  6    34*   time.
  6    35*
  6    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
  6    37*   displaying internal tuple format bit offset, rather than the user
  6    38*   view.
  6    39*
  6    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
  6    41*   dump  an  element  from  the  list, when display_open_names entry
  6    42*   called with switch set.
  6    43*
  6    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
  6    45*   of sub_err_ messages, when cross domain compare occurs.
  6    46*
  6    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
  6    48*   iocb slot and rel name.
  6    49*
  6    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
  6    51*
  6    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
  6    53*
  6    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
  6    55*   allows  key  searches, other than than specified by permute to be
  6    56*   done as comparisons instead.
  6    57*
  6    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
  6    59*   mrds_dsl_gen_srch_prog
  6    60**/
  6    61 
  6    62 declare (
  6    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
  6    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
  6    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
  6    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
  6    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
  6    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
  6    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
  6    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
  6    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
  6    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
  6    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
  6    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
  6    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
  6    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
  6    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
  6    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
  6    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
  6    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
  6    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
  6    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
  6    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
  6    84          ) ;
  6    85 
  6    86 /* list of known module names, with index into name array
  6    87*   the same as that into mrds_debug_$switch,
  6    88*   number is the current count of defined module names,
  6    89*   name is the modules full name. */
  6    90 
  6    91 declare 1 module options (constant) internal static,
  6    92         2 number fixed bin init (21),
  6    93         2 name char (32) dimension (21) init (
  6    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
  6    95          "mrds_dsl_get_token",			/* 1 => display the current token */
  6    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
  6    97*						   2 => reverse partial path
  6    98*						   3 => use range order for path
  6    99*						   4 => display access method costs
  6   100*						   5 => display details of final low cost path */
  6   101          "mrds_dsl_optimize",				/* 1 => pred tree,
  6   102*						   2 => paths to consider, 3 => calc_cost on */
  6   103          "mrds_dsl_search",				/* 1 => display each tuple located */
  6   104          "mrds_dsl_translate",			/* 1 => display the search program */
  6   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
  6   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
  6   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
  6   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
  6   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
  6   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
  6   111*						   and new tuple during modifies will be done */
  6   112          "mu_sec_get_tuple",				/* 1 => attribute values
  6   113*						   will be zeroed in the tuple structure
  6   114*						   is don't have read permission. */
  6   115          "mu_sec_get_tid",				/* 1 => read permission to the key
  6   116*						   is checked (if db is secured) */
  6   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
  6   118*						   and request granted from queue messages */
  6   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
  6   120*						   so can test both MR8 and MR9 mrds
  6   121*						   against the same database at the same time */
  6   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
  6   123*						   for attributes to be displayed, rather than user view */
  6   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
  6   125*						   when display_open_names entry called */
  6   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
  6   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
  6   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
  6   129*						   when the original access was a key,
  6   130*						   and the additional conditions can be done as key also
  6   131*						   2 => force key searches, regardless of strategy
  6   132*						   used to decide between compare or key search */
  6   133          ) ;
  6   134 
  6   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
  6   136 
  6   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
  6   138 
     1805 
     1806 
  7     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  7     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  7     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  7     9*     Nguyen. The scopes_changed flag was added to make checking for this
  7    10*     more efficient (mrds error list #137).
  7    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  7    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  7    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  7    14*     care if multiple txns use the same selection_expression. (mrds #156)
  7    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  7    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  7    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  7    18*                                                   END HISTORY COMMENTS */
  7    19 
  7    20 
  7    21 /* WARNING
  7    22*          If the dbcb structure is changed then the mrds_data_
  7    23*          item saved_res_version MUST be incremented to invalidate all
  7    24*          existing saved resultants
  7    25**/
  7    26 
  7    27 /* HISTORY :
  7    28*
  7    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  7    30*   tid_list management
  7    31*
  7    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  7    33*   phony resultant in mu_database_index, without having the area dcl
  7    34*   included.
  7    35*
  7    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  7    37*   mrds_dsl_store
  7    38*
  7    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  7    40*   switches
  7    41*
  7    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  7    43*   expression,  so  that relation statistics can be updated relative
  7    44*   to number of selection expressions seem. Also  removed  init  for
  7    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  7    46*   mrds_dsl_init_res.
  7    47*
  7    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  7    49*
  7    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  7    51*   for the conversion to the relation manager.
  7    52*
  7    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  7    54*   substructures so that the entries and costs can change
  7    55*   depending on the type of database that is opened.
  7    56*
  7    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  7    58*   since modify uses a different vector type (general) than does store.
  7    59*
  7    60*   82-09-20 Davids: changed names of (store modify)_vector to
  7    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  7    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  7    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  7    64*   during the first call.
  7    65*
  7    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  7    67*   since it deals with the pointers to the cursors and not the cursors
  7    68*   themelves and added the element cursor_storage_area_ptr which points
  7    69*   to the area where the cursors are kept.
  7    70*
  7    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  7    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  7    73*   anything.
  7    74*
  7    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  7    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  7    77*   by mrds_dsl_define_temp_rel.
  7    78*
  7    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  7    80*   is needed by mu_store.
  7    81*
  7    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  7    83*   bin to float bin since the values are not integers.
  7    84*
  7    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  7    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  7    87*   added to the end of the structure to allow modules that don't use
  7    88*   the element to continue to reference the dbcb structure without recompiling.
  7    89*
  7    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  7    91*   are needed so that temp rels can be created with the same file attributes
  7    92*   as the permanent relations.
  7    93*
  7    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  7    95*   added the resultant_in_pdir bit.
  7    96*
  7    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  7    98*   added the res_already_made element.
  7    99*
  7   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  7   101*
  7   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  7   103*   one of the unused pointers.
  7   104*
  7   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  7   106*
  7   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  7   108*   leaving unused_ptrs(1).
  7   109*
  7   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  7   111*   unused_ptrs (1).
  7   112*
  7   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  7   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  7   115*   spare ptrs, entries and reserved storages for future enhancement, since
  7   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  7   117*
  7   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  7   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  7   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  7   121**/
  7   122 
  7   123 
  7   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  7   125*   that constitutes the non-secure portion of the resultant model that is
  7   126*   created during the opening of a database. it contains variables that
  7   127*   are used during the runtime access of the database, and an area
  7   128*   for evaluation of requests. it points to four other
  7   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  7   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  7   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  7   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  7   133*   used in the elimination of duplicate tuples during a retrieve.
  7   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  7   135*   that is used when the database is using the file scope mechanism
  7   136*   for concurrency control over file readying. the segment overlayed via
  7   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  7   138*   across database openings. the pointer to this dbcb structure is kept in a table
  7   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  7   140*   opening instances of resultant models. (see mu_database_index routine) */
  7   141 
  7   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  7   143 	     2 data	      like dbcb_data,
  7   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  7   145 
  7   146      dcl	   dbcb_ptr	      ptr;
  7   147 
  7   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  7   149*						   like references can avoid getting the area declaration */
  7   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  7   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  7   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  7   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  7   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  7   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  7   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  7   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  7   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  7   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  7   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  7   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  7   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  7   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  7   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  7   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  7   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   167*						   for eliminating duplicate tuples. */
  7   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   169*						   for eliminating duplicate tuples. */
  7   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  7   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  7   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  7   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  7   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  7   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  7   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  7   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  7   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  7   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  7   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  7   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  7   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  7   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  7   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  7   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  7   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  7   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  7   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  7   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  7   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  7   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  7   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  7   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  7   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  7   195 	     2 val_del	      bit (1) unal,		/* for delete */
  7   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  7   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  7   198*                                                                     not imply that the database is of type page_file */
  7   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  7   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  7   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  7   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  7   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  7   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  7   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  7   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  7   207*						   inside a sequence of -another selection expression. */
  7   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  7   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  7   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  7   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  7   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  7   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  7   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  7   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  7   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  7   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  7   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  7   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  7   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  7   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  7   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  7   223 	     2 relmgr_entries,			/* relation manager entries */
  7   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  7   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  7   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  7   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  7   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  7   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  7   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  7   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  7   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  7   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  7   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  7   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  7   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  7   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  7   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  7   241 	       3 reserved_entries (5) entry (),
  7   242 	     2 access_costs,			/* access costs for permute */
  7   243 	       3 total_primary_key_cost float bin,
  7   244 	       3 access_cost      float bin,
  7   245 	       3 access_overhead  float bin,
  7   246 	       3 us_access_cost   float bin,
  7   247 	       3 os_access_cost   float bin,
  7   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  7   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  7   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  7   251 
  7   252 /* END mrds_dbcb.incl.pl1 */
  7   253 
  7   254 
     1807 
     1808 
  8     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*   Modified by odf for new version data bases in August 1978
  8     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  8     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  8     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  8     9*
  8    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  8    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  8    12**/
  8    13 
  8    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  8    15     2 proper,
  8    16       3 version fixed bin,				/* version number of this structure */
  8    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  8    18       3 flags,
  8    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  8    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  8    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  8    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  8    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  8    24         4 pad bit (31) unal,				/* reserved for future use */
  8    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  8    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  8    27*						   received it */
  8    28       3 user_counts,
  8    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  8    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  8    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  8    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  8    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  8    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  8    35       3 pad2 bit (144),
  8    36       3 offsets,
  8    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  8    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  8    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  8    40         4 obsolete bit (36) unal,			/* obsolete */
  8    41       3 pad3 bit (144),
  8    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  8    43 
  8    44 dcl  dbc_ptr ptr init (null ());
  8    45 
  8    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  8    47 
  8    48 
  8    49 /* END mdbm_dcb.incl.pl1  */
  8    50 
  8    51 
     1809 
     1810 
  9     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  9     7*     install(86-10-23,MR12.0-1199):
  9     8*     Deleted the DEFAULT_WAIT variable.
  9     9*                                                   END HISTORY COMMENTS */
  9    10 
  9    11 
  9    12 /* HISTORY:
  9    13*   Written by Oris Friesen August 10, 1978.
  9    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  9    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  9    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  9    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  9    18*   r-u-s-m-d scope codes, instead of just r-u.
  9    19*
  9    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  9    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  9    22*   and pad to mbz for consistency with MRDS access acl modes.
  9    23*
  9    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  9    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  9    26*   This is currently only used in mrds_dsl_set_fscope.
  9    27*
  9    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  9    29*   Put it at the end to make the new structure compatable with the old so
  9    30*   that testing could take place without having to recompile all the modules
  9    31*   that use the structure.
  9    32*
  9    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  9    34*   element. This was done because set_fscope must be able to open the
  9    35*   relation if its not yet opened.
  9    36*   ---------------------------------------------------------------------------
  9    37*   DESCRIPTION:
  9    38*
  9    39*   The dbc contains the following information in its static area.
  9    40*   One group of information is composed of structures (user_list)
  9    41*   threaded 3 ways to form 3 lists. They are the list of active
  9    42*   scope users, of open users, and of users waiting to set scope.
  9    43*   The beginning of each of these lists is pointed to by fields
  9    44*   in the dbc proper.  All of these lists share the user_list structures,
  9    45*   and are completely contained within these structures, i.e., there
  9    46*   is no extraneous information in some knook in Scottsdale.
  9    47*
  9    48*   Associated with each user_list structure is a linked list of
  9    49*   fil_list structures.  The list is of all of the files (relations)
  9    50*   included in the user's scope request.  Unlike the user_list
  9    51*   structures which were shared by several different lists, the structures
  9    52*   in a user's file list are exclusively hers.  The entries contain
  9    53*   information about the scope request and the file name, and have
  9    54*   no real connection with the actual files in the resultant model.
  9    55*   --------------------------------------------------------------------------- */
  9    56 
  9    57 dcl 1 user_list based (ul_ptr),
  9    58     2 ids,
  9    59       3 group_id char (32),				/* group identifier of this user */
  9    60       3 process_id bit (36),				/* process identifier of this user */
  9    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  9    62*						   used to identify dead processes */
  9    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  9    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  9    65*						   to allow concurrent openings by same process */
  9    66     2 flags,
  9    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  9    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  9    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  9    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  9    71       3 priority_high bit (1) unal,			/* obsolete */
  9    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  9    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  9    74       3 dead_proc_conflict
  9    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  9    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  9    77       3 pad bit (28),				/* reserved for future use */
  9    78     2 allowance_count fixed bin,			/* obsolete */
  9    79     2 bypass_count fixed bin,				/* obsolete */
  9    80     2 offsets,
  9    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  9    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  9    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  9    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  9    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  9    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  9    87 						/* names of files accessible by this user */
  9    88 
  9    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  9    90     2 name char (30),				/* data model name of the file specified in scope request */
  9    91     2 permits,					/* permit codes for scope setting or deleting */
  9    92       3 mbz1 bit (15) unal,
  9    93       3 modify_attr bit (1) unal,
  9    94       3 delete_tuple bit (1) unal,
  9    95       3 append_tuple bit (1) unal,
  9    96       3 update bit (1) unal,
  9    97       3 read_attr bit (1) unal,
  9    98     2 prevents,					/* prevent codes for scope setting or deleting */
  9    99       3 update bit (1) unal,
  9   100       3 read_attr bit (1) unal,
  9   101       3 append_tuple bit (1) unal,
  9   102       3 delete_tuple bit (1) unal,
  9   103       3 modify_attr bit (1) unal,
  9   104       3 mbz2 bit (29) unal,
  9   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  9   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  9   107                                                             /* needed so that the relation can be opened if need be */
  9   108 
  9   109 dcl  ul_ptr ptr init (null ());
  9   110 dcl  fl_ptr ptr init (null ());
  9   111 
  9   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  9   113 
  9   114 
  9   115 dcl  WAIT init (0) fixed bin int static options (constant);
  9   116 						/* the number of later user requests for which a user
  9   117*						   request will wait before it must be honored */
  9   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  9   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  9   120 						/* dequeue from open list */
  9   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  9   122 						/*  do not dequeue from open list */
  9   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  9   124 dcl  QUE_FREE fixed bin (71);
  9   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  9   126 						/* wakeup up signal for time-out */
  9   127 dcl  ALARM fixed bin (71);
  9   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  9   129 						/* this is the 1st time process will asleep */
  9   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  9   131 						/* being queued for the 2nd, 3rd ... time */
  9   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  9   133 						/* check to see which scopes can be set */
  9   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  9   135 						/* check to see which scopes can be deleted */
  9   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  9   137 						/* process is alive */
  9   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  9   139 						/* process is dead */
  9   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  9   141 						/* permit retrieve, update */
  9   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  9   143 						/* prevent retrieve, update */
  9   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  9   145 						/* permit retrieve, update */
  9   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  9   147 						/* prevent retrieve, update */
  9   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  9   149 						/* measure wait time in relative seconds */
  9   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  9   151 						/* free this user's file lists */
  9   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  9   153 						/* do not free this user's file lists */
  9   154 
  9   155 /* END mdbm_users.incl.pl1 */
  9   156 
     1811 
     1812 
 10     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
 10     2 
 10     3 /* WARNING
 10     4*          If the scope_info or scope_flags structure is changed then the
 10     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
 10     6*          all existing saved resultants
 10     7**/
 10     8 
 10     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
 10    10 
 10    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
 10    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
 10    13*   qualifiers for permit/prevent modes and to put pads in standard format */
 10    14 
 10    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
 10    16 
 10    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
 10    18*   could make use of it for compatibility. */
 10    19 
 10    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
 10    21*   the fact that null scope has been set can be displayed */
 10    22 
 10    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
 10    24*   prevent flags from any pointer which directly pointed to scope_flags itself
 10    25*   (i.e rm_rel_info.scope_flags_ptr). */
 10    26 
 10    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
 10    28*   and is used to maintain the scope mechanism for file access.
 10    29*   It contains the scope permit/prevent operations that this user
 10    30*   has set in his view for this opening instance. */
 10    31 
 10    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
 10    33     2 mbz1 bit (144),				/* Reserved for future use */
 10    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
 10    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
 10    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
 10    37       3 name char (30) aligned,			/* filename */
 10    38       3 sm_name char (32),				/* name of file(rel) in submodel */
 10    39       3 flags like scope_flags ;
 10    40 
 10    41 
 10    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
 10    43         2 permits,					/* modes to permit this user */
 10    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
 10    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
 10    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
 10    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
 10    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
 10    49         2 prevents,					/* modes to be denyed to other users */
 10    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
 10    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
 10    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
 10    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
 10    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
 10    55         2 touched bit (1) unal,			/* on => scope set for this relation */
 10    56         2 mbz4 bit (7) unal ;				/* for future flags */
 10    57 
 10    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
 10    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
 10    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
 10    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
 10    62 
 10    63 /* END mdbm_scope_info.incl.pl1 */
     1813 
     1814 
 11     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
 11     2 
 11     3 
 11     4 
 11     5 /****^  HISTORY COMMENTS:
 11     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
 11     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 11     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
 11     9*                                                   END HISTORY COMMENTS */
 11    10 
 11    11 
 11    12 /* WARNING
 11    13*          If the rm_db_info structure is changed then the mrds_data_
 11    14*          item saved_res_version MUST be incremented to invalidate all
 11    15*          existing saved resultants
 11    16**/
 11    17 
 11    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
 11    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
 11    20*   resultant model that is created partially at database open  time,
 11    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
 11    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
 11    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
 11    24*   to  provide  an  efficient  means  of  accessing  database  model
 11    25*   information, as seen from the possibly submodel view of the user,
 11    26*   and his current state of "files readied". it is the  secure  part
 11    27*   because  it  contains  the  model  information  which needs to be
 11    28*   protected  from  general  knowledge,  and   this   segment   will
 11    29*   eventually  be  capable  of  being in a lower ring. the structure
 11    30*   itself points to four arrays that are  allocated  in  it's  area,
 11    31*   that  in  turn point to the other structures mentions above, also
 11    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
 11    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
 11    34*   relations,  initially  empty,  and  a  pair  for   normal   model
 11    35*   files/relations.  the  normal  rm_file_array  is initialized to a
 11    36*   list of all known file names, the rm_rel_array only gets relation
 11    37*   names   as   files  are  readied.  the  rm_file_array  points  to
 11    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
 11    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
 11    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
 11    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
 11    42*   file infos point to contained rel infos, the rel infos  point  to
 11    43*   contained  attr  infos,  and  those in turn to domain infos. (see
 11    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
 11    45*   foreign     keys    are    represented    by    the    structures
 11    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
 11    47*   pathnames  of the model and submodel, if any, are also maintained
 11    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
 11    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
 11    50*   individual include files for  further  organization  information,
 11    51*   and particular data structures.
 11    52*
 11    53*   HISTORY:
 11    54*
 11    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
 11    56*   so that define_area_ could be used to make it an extensible area
 11    57*
 11    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
 11    59*   resultant in mu_database_index easier to keep, since no reference
 11    60*   to the area is needed.
 11    61*
 11    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
 11    63*   resultant.
 11    64*
 11    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
 11    66*   structure.
 11    67*
 11    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
 11    69*   are  now  combined  into  the rel_array. Removed the control file
 11    70*   info which was unused. Added pointer  to  head  of  domain  list,
 11    71*   which is to be used to insure only one copy of each domain info.
 11    72*
 11    73*   83-05-19 Davids: Added the  saved_res_version element.
 11    74*
 11    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
 11    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
 11    77*   check, encode, or decode proc.
 11    78*
 11    79*   CAUTION: The structure entries from db_version to sm_path  should
 11    80*   not  be moved or have their declarations changed because they are
 11    81*   used in the handling of old version database openings.
 11    82*
 11    83*
 11    84**/
 11    85 
 11    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
 11    87 	     2 data	      like rm_db_info_data,
 11    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
 11    89 
 11    90      dcl	   rdbi_ptr	      ptr;
 11    91 
 11    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
 11    93*						   like reference to it without getting the area as well */
 11    94 	     2 db_version	      fixed bin,		/* version no. of db */
 11    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
 11    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
 11    97 	     2 db_path	      char (168),		/* abs. path of db. */
 11    98 	     2 sm_path	      char (168),		/* path of submodel or model */
 11    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
 11   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
 11   101 	     2 pad	      bit (34) unal,	/* for future use */
 11   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
 11   103*                                                               dbcb and rdbi segments in the db dir */
 11   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
 11   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
 11   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
 11   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
 11   108 
 11   109 /* END mdbm_rm_db_info.incl.pl1 */
 11   110 
 11   111 
     1815 
     1816 
 12     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
 12     2 
 12     3 /* WARNING
 12     4*          If the rm_rel_array structure is changed then the mrds_data_
 12     5*          item saved_res_version MUST be incremented to invalidate all
 12     6*          existing saved resultants
 12     7**/
 12     8 
 12     9 /* HISTORY:
 12    10*
 12    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
 12    12*   combining   funtions   of   file_array  and  rel_array  into  one
 12    13*   structure. This will only allow 1 relation per file model now.
 12    14*   Also changed structure to allow more efficient searching
 12    15*   via and index builtin, rather than a programmed loop.
 12    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
 12    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
 12    18*
 12    19**/
 12    20 
 12    21 
 12    22 /* this structure is allocated in the static are of the structure
 12    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
 12    24*   resultant  model  upon  opening  the  database.  two  copies  are
 12    25*   allocated,  one for temporary relations, initially empty, and one
 12    26*   for relations known to the opener, which has a length  sufficient
 12    27*   for  all  relations known to the user, but whose names, etc. will
 12    28*   not be filled  in  until  the  file  containing  that  particular
 12    29*   relation  is readied. the rm_db_info structure contains a pointer
 12    30*   to the rel_arrays, and the array entries, when  "readied",  point
 12    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
 12    32*   information about the relation, it's attributes, etc. */
 12    33 
 12    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
 12    35     2 num_rels fixed bin,				/* no. rels in db. */
 12    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
 12    37       3 mark char (1) unal,				/* separator character = "!" */
 12    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
 12    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
 12    40       3 model_name char (30),				/* name of relation in model */
 12    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
 12    42 
 12    43 dcl  rmra_ptr ptr;
 12    44 dcl  rm_num_rels_init fixed bin;
 12    45 
 12    46 /* END mdbm_rm_rel_array.incl.pl1 */
 12    47 
 12    48 
     1817 
     1818 
 13     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
 13     2 
 13     3 /* WARNING
 13     4*          If the rm_rel_info structure is changed then the mrds_data_
 13     5*          item saved_res_version MUST be incremented to invalidate all
 13     6*          existing saved resultants
 13     7**/
 13     8 
 13     9 /* HISTORY:
 13    10*
 13    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
 13    12*   attributes,   and   varying  attributes,  so  that  partial  view
 13    13*   submodels will have the  info  needed  to  properly  set  up  the
 13    14*   varying length array headers in the tuple structure.
 13    15*
 13    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
 13    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
 13    18*   delete_tuple_perm, and make m_perm = unused_perm.
 13    19*
 13    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
 13    21*   view attribute was varying character or bit, since a partial view
 13    22*   submodel will not have this information in the resultant, and  it
 13    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
 13    24*   since with exact length storage  of  varying  length  attributes,
 13    25*   each  tuple  can  be  a  different  length,  which is can only be
 13    26*   determined by examining the tuple itself.
 13    27*
 13    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
 13    29*   interface  to  allow  temp  rel  population  to  be known, and to
 13    30*   provide a more efficient means of finding an approx. current perm
 13    31*   relation population.
 13    32*
 13    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 13    34*   blocked  files, foreign keys, and ids procedures. Also set number
 13    35*   of files per rel to a constant of 1.
 13    36*
 13    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
 13    38*   structure so that only one structure per relation is needed.
 13    39*
 13    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
 13    41*   counts.   Also  added  number  of  operations  count  since  last
 13    42*   statistics update, and a time  since  the  statistics  were  last
 13    43*   updated.
 13    44*
 13    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
 13    46*   identifier so that small relations could be updated on a per S.E.
 13    47*   basis
 13    48*
 13    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
 13    50*   to end of structure   TR 12205 (Suggestion).
 13    51*   
 13    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
 13    53*   the DMS conversion. 
 13    54*
 13    55*   82-08-30 Davids: added the opening_id element and removed the iocb
 13    56*   array and the niocb element for DMS conversion. Also removed the
 13    57*   number_selected array (and ri_niocbs_init) since subsets are not
 13    58*   going to be used.
 13    59*
 13    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
 13    61*   so that it can be used with relation manager.  Also added
 13    62*   rm_rel_info.primary_key_index_id for relation manager.
 13    63*
 13    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
 13    65*   nvar_atts, model_nvar_atts.
 13    66*
 13    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
 13    68*   since the duplicate key count for each secondary index is now being
 13    69*   kept in the attr_info structure and key_count was only needed to
 13    70*   help in calculating the average selectivity of each index which
 13    71*   can now be gotten directly from each index's dup key count. Also
 13    72*   removed the file_id element since it is no longer needed for
 13    73*   anything.
 13    74*
 13    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
 13    76*   was removed.
 13    77*
 13    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
 13    79*   used when retrieving tuples from this relation.
 13    80*
 13    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
 13    82*   for the relation. Note that this structure is part of the resultant NOT
 13    83*   part of the db.control structure. The scopes are duplicated in the resultant
 13    84*   to reduce contention for the db.control structure. Note also that the pointer
 13    85*   will always point to a scope_flags structure even if no scopes have been
 13    86*   set on the relation, the structure is allocated when the db is opened.
 13    87**/
 13    88 
 13    89 
 13    90 /* DESCRIPTION:
 13    91*
 13    92*   This structure is allocated in the area part of the structure  in
 13    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
 13    94*   at open  time  for  a  database.  There  will  be  one  of  these
 13    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
 13    96*   database view (there may be less than the total in  the  database
 13    97*   for  a  submodel  openings).  There  will  also  be  one for each
 13    98*   temporary relation currently defined for that opening.
 13    99*
 13   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
 13   101*   all  rm_rel_info  structures  allocated. It is used for searching
 13   102*   for the appropriate  structure.  This  array  is  pointed  to  by
 13   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
 13   104*   rels.
 13   105*
 13   106*   The      rm_rel_info      structure      points      to       the
 13   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
 13   108*   appearing in this view of the relation. Each  of  these  in  turn
 13   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
 13   110*   info for each attr.
 13   111*
 13   112*   Most of the other information here deals with  specifics  of  the
 13   113*   relation's  logical  definition,  such as key and secondary index
 13   114*   attribute inidicators, security permissions, and  tuple  physical
 13   115*   construction details.
 13   116*
 13   117**/
 13   118 
 13   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
 13   120 	     2 name	      char (32),		/* from submodel */
 13   121 	     2 model_name	      char (30),		/* from model */
 13   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
 13   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
 13   124 	     2 modify	      bit (1) unal,
 13   125 	     2 delete	      bit (1) unal,
 13   126 	     2 store	      bit (1) unal,
 13   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
 13   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
 13   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
 13   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
 13   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
 13   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
 13   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
 13   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
 13   135 	     2 reserved	      bit (24) unal,	/* for future use */
 13   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
 13   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
 13   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
 13   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
 13   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
 13   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
 13   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
 13   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
 13   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
 13   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
 13   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
 13   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
 13   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
 13   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
 13   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
 13   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
 13   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
 13   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
 13   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
 13   155 
 13   156      dcl	   rmri_ptr	      ptr;
 13   157      dcl	   (nkey_attr_init,
 13   158 	   natts_init,
 13   159 	   nvar_atts_init)	      fixed bin;
 13   160 
 13   161 /* END mdbm_rm_rel_info.incl.pl1 */
 13   162 
 13   163 
     1819 
     1820 
 14     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 14     2 
 14     3 /* WARNING
 14     4*          If the rm_attr_info structure is changed then the mrds_data_
 14     5*          item saved_res_version MUST be incremented to invalidate all
 14     6*          existing saved resultants
 14     7**/
 14     8 
 14     9 /*
 14    10*
 14    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 14    12*   that rm_rel_info does not have to be checked
 14    13*
 14    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 14    15*   foreign keys.
 14    16*
 14    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 14    18*   conversion.
 14    19*
 14    20*   82-09-15 Davids: added the number_of_dups field.
 14    21*
 14    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 14    23*   aligned.  This is to conform with the new definition in the database
 14    24*   model.  Also removed the now useless field varying.
 14    25*
 14    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 14    27*   comment for the field defn_order.
 14    28*
 14    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 14    30*   that's what relation manager returns.
 14    31*
 14    32**/
 14    33 
 14    34 
 14    35 /*
 14    36*   this   structure   is   allocated   in   the   static   area   of
 14    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 14    38*   a     readied     file.      it     in     turn     points     to
 14    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 14    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 14    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 14    42*   position  within  a  tuple as stored in the data file are kept in
 14    43*   this resultant model of the attribute.
 14    44* */
 14    45 
 14    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 14    47     2 name char (32),				/* from submodel */
 14    48     2 model_name char (32),				/* from model */
 14    49     2 key_attr bit (1) unal,				/* if key attribute */
 14    50     2 index_attr bit (1) unal,			/* if secondary index */
 14    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 14    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 14    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 14    54     2 reserved bit (30) unal,				/* for future use */
 14    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 14    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 14    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 14    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 14    59     2 domain_ptr ptr,				/* to domain info */
 14    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 14    61*                                                               be the number of duplicate values, exact
 14    62*                                                               for a page_file database, an estimate for a vfile type */
 14    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 14    64 
 14    65 dcl  rai_ptr ptr int automatic init (null ());
 14    66 
 14    67 /* END mdbm_rm_attr_info.incl.pl1 */
 14    68 
 14    69 
     1821 
     1822 
 15     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
 15     2 
 15     3 /* HISTORY:
 15     4*
 15     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
 15     6*
 15     7**/
 15     8 
 15     9 /* DESCRIPTION:
 15    10*
 15    11*   this structure returns the callers user_class
 15    12*   either database administrator or normal user.
 15    13*   Note that these separate classes were used to allow
 15    14*   future expansion to the user classes, rather than
 15    15*   make them logical "not"'s of one another.
 15    16*   NOTE: a DBA is always also a normal user, thus if the caller
 15    17*   is a DBA, his normal_user bit will be on also.
 15    18*
 15    19**/
 15    20 
 15    21 
 15    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
 15    23         2 version fixed bin,				/* version number of this structure */
 15    24         2 administrator bit (1) unal,			/* caller is a DBA */
 15    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
 15    26         2 mbz bit (34) unal ;
 15    27 
 15    28 
 15    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
 15    30 
 15    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
 15    32 
 15    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
     1823 
     1824 
     1825 
     1826 
     1827      end mrds_dsl_set_fscope;
     1828 
     1829 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1121.8  mrds_dsl_set_fscope.pl1           >udd>sm>ds>w>ml>mrds_dsl_set_fscope.pl1
351          1    02/05/86  1516.4  mrds_start_transaction.incl.pl1   >ldd>incl>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  1000.0  dm_tm_modes.incl.pl1              >ldd>incl>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1304.8  condition_info.incl.pl1           >ldd>incl>condition_info.incl.pl1
483          4    02/05/86  1516.4  mrds_finish_transaction.incl.pl1  >ldd>incl>mrds_finish_transaction.incl.pl1
1803         5    10/14/83  1708.7  mdbm_scope_requests.incl.pl1      >ldd>incl>mdbm_scope_requests.incl.pl1
1805         6    10/14/83  1709.0  mrds_debug_names.incl.pl1         >ldd>incl>mrds_debug_names.incl.pl1
1807         7    08/04/88  2143.3  mrds_dbcb.incl.pl1                >ldd>incl>mrds_dbcb.incl.pl1
1809         8    10/14/83  1709.0  mdbm_dbc.incl.pl1                 >ldd>incl>mdbm_dbc.incl.pl1
1811         9    10/23/86  1133.9  mdbm_users.incl.pl1               >ldd>incl>mdbm_users.incl.pl1
1813        10    04/18/85  1728.1  mdbm_scope_info.incl.pl1          >ldd>incl>mdbm_scope_info.incl.pl1
1815        11    08/04/88  2143.3  mdbm_rm_db_info.incl.pl1          >ldd>incl>mdbm_rm_db_info.incl.pl1
1817        12    10/14/83  1709.1  mdbm_rm_rel_array.incl.pl1        >ldd>incl>mdbm_rm_rel_array.incl.pl1
1819        13    10/14/83  1709.1  mdbm_rm_rel_info.incl.pl1         >ldd>incl>mdbm_rm_rel_info.incl.pl1
1821        14    10/14/83  1709.1  mdbm_rm_attr_info.incl.pl1        >ldd>incl>mdbm_rm_attr_info.incl.pl1
1823        15    10/14/83  1708.8  mrds_authorization.incl.pl1       >ldd>incl>mrds_authorization.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALARM                           000566 automatic       fixed bin(71,0)          dcl 9-127 set ref 295* 1229
ALIVE                                  constant        bit(1)                   initial packed unaligned dcl 9-136 ref 1442 1446
BEING_QUEUED_REPORT             000353 automatic       fixed bin(17,0)          initial dcl 1783 set ref 1203* 1526 1535 1783*
CHAR_ALARM                      000002 constant        char(8)                  initial packed unaligned dcl 9-125 ref 295
CHAR_Q_F                        000004 constant        char(8)                  initial packed unaligned dcl 9-123 ref 294
DEAD                                   constant        bit(1)                   initial packed unaligned dcl 9-138 ref 602 1308 1438
                                                                                  1444 1454
DEAD_PROC_REPORT                000354 automatic       fixed bin(17,0)          initial dcl 1784 set ref 604* 1310* 1524 1784*
DQ_OPEN                         000052 constant        bit(1)                   initial packed unaligned dcl 9-119 set ref 1458*
FIRST_QUEUE                            constant        bit(1)                   initial packed unaligned dcl 9-128 set ref 498*
FREE_FIL_LIST                   000052 constant        bit(1)                   initial packed unaligned dcl 9-150 set ref 1458*
NO_DQ_OPEN                      000056 constant        bit(1)                   initial packed unaligned dcl 9-121 set ref 998*
NULL_CHAR                       000314 automatic       char(8)                  initial packed unaligned dcl 1758 set ref 1758*
NULL_OFS                               constant        bit(18)                  initial packed unaligned dcl 9-118 ref 983 1478
OFF                                    constant        bit(1)                   initial packed unaligned dcl 1759 ref 329 332 333
                                                                                  574 588 653 921 978 1014 1183 1185 1207 1208 1231
                                                                                  1268 1272 1321 1333 1355 1366 1394 1403 1457 1601
                                                                                  1604 1605
ON                                     constant        bit(1)                   initial packed unaligned dcl 1760 ref 297 331 334
                                                                                  582 596 601 645 890 892 895 898 901 904 907 910
                                                                                  913 953 954 955 956 958 959 960 961 975 977 980
                                                                                  1013 1184 1240 1255 1262 1270 1302 1307 1365 1406
                                                                                  1414 1463 1464 1465 1603 1606
QUEUE_AGAIN                            constant        bit(1)                   initial packed unaligned dcl 9-130 set ref 1326*
QUE_FREE                        000564 automatic       fixed bin(71,0)          dcl 9-124 set ref 294* 998 1259 1402*
REL_SEC                         000000 constant        bit(2)                   initial packed unaligned dcl 9-148 set ref 1200*
SAVE_FIL_LIST                   000056 constant        bit(1)                   initial packed unaligned dcl 9-152 set ref 998*
TIME_OUT_REPORT                 000352 automatic       fixed bin(17,0)          initial dcl 1782 set ref 1244* 1528 1782*
TM_NORMAL_MODE                  000065 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
WAIT                                   constant        fixed bin(17,0)          initial dcl 9-115 ref 1186
a_cd_ptr                               parameter       pointer                  dcl 544 ref 532 532 532 562
a_dbcb_ptr                             parameter       pointer                  dcl 544 ref 532 532 532 559
a_permit_requests_ptr                  parameter       pointer                  dcl 544 ref 532 532 532 560
a_prevent_requests_ptr                 parameter       pointer                  dcl 544 ref 532 532 532 561
a_ptr                                  parameter       pointer                  dcl 1475 ref 1472 1480
a_ws_ptr                               parameter       pointer                  dcl 544 ref 532 532 532 556 558
active_scopes             5            based           fixed bin(17,0)          level 2 dcl 10-32 set ref 274 916* 916
active_sw                16(19)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1013* 1185*
active_users             10            based           fixed bin(17,0)          level 4 dcl 8-14 set ref 574 1011* 1011 1186
active_users_ofs         21(18)        based           bit(18)                  level 4 packed packed unaligned dcl 8-14 set ref
                                                                                  1004 1005* 1122*
actual_conflict_detail          000346 automatic       structure                level 1 packed packed unaligned dcl 1776 set ref 590
                                                                                  590 1296 1296
actual_permits                  000333 automatic       structure                level 1 packed packed unaligned dcl 1769 set ref
                                                                                  1372* 1384 1384
actual_prevents                 000334 automatic       structure                level 1 packed packed unaligned dcl 1769 set ref
                                                                                  1372* 1384 1384
addr                                                   builtin function         dcl 1697 ref 235 306 323 323 529 556 1-123 1-123 590
                                                                                  590 590 590 920 926 1004 1007 1187 1190 1212 1212
                                                                                  1212 1212 1296 1296 1296 1296 1296 1296 1296 1296
                                                                                  1384 1384 1384 1384 1384 1384 1384 1384
administrator             1            based           bit(1)                   level 2 packed packed unaligned dcl 15-22 set ref
                                                                                  731*
afle_rmri_ptr                          parameter       pointer                  dcl 942 ref 933 949
allowance_count          20            based           fixed bin(17,0)          level 2 dcl 9-57 set ref 1186* 1414
any_other                       000264 stack reference condition                dcl 1694 ref 349
append_tuple              0(34) 000334 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1381*
append_tuple             27(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 910* 1291
append_tuple              1(34) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1563
append_tuple              0(34)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 5-20 in procedure "set_fscope" ref
                                                                                  641 677 694 744 764 805 898 966 976
append_tuple              0(34) 000333 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1376*
append_tuple              7(35)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 955* 966* 1376
append_tuple             10(04)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 960* 971* 980 1079 1381
append_tuple              0(34)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 5-22 in procedure
                                                                                  "set_fscope" ref 697 910 971 1334
append_tuple              0(34) 000335 automatic       bit(1)                   level 2 in structure "remembered_permits" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1282*
append_tuple              0(34) 000336 automatic       bit(1)                   level 2 in structure "remembered_prevents" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1291*
append_tuple             26(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 898* 1282
append_tuple              0(34) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1546
append_tuple_perm        21(08)        based           bit(1)                   level 2 packed packed unaligned dcl 13-119 ref 669
arg_error                       000306 stack reference condition                dcl 1694 ref 224 232 240 521 526
arg_index                       000231 automatic       fixed bin(17,0)          dcl 1662 set ref 368* 369* 406 411
arg_len                         000223 automatic       fixed bin(17,0)          dcl 1662 set ref 231* 239* 255* 406* 411* 446* 451*
                                                                                  525*
args_exp                        000230 automatic       fixed bin(17,0)          dcl 1662 set ref 220* 224 517* 521 523 555*
attr_modify_perm                000340 automatic       bit(1)                   packed unaligned dcl 1771 set ref 645* 653* 657 661
                                                                                  661* 665 677 836
attr_null_perm                  000341 automatic       bit(1)                   packed unaligned dcl 1772 set ref 665* 827
attr_ptrs                              based           pointer                  array level 2 dcl 13-119 ref 658
attr_retr_perm                  000337 automatic       bit(1)                   packed unaligned dcl 1770 set ref 645* 653* 657 659
                                                                                  659* 665 677 833
baseno                                                 builtin function         dcl 1697 ref 1127
baseptr                                                builtin function         dcl 1697 ref 1127
bypass_count             21            based           fixed bin(17,0)          level 2 dcl 9-57 set ref 330* 1322* 1322 1413* 1413
                                                                                  1414 1602*
caller_name                     000317 automatic       char(32)                 initial packed unaligned dcl 1766 set ref 392* 682*
                                                                                  705* 734* 768* 1572* 1766*
cd                                     parameter       fixed bin(35,0)          dcl 868 ref 865 870
cd_ptr                          000244 automatic       pointer                  dcl 1681 set ref 239* 242 473 475 478 4-115 562* 870
                                                                                  1149
check_scope                     000161 automatic       bit(1)                   packed unaligned dcl 1645 set ref 331* 574* 579
                                                                                  1603*
chn_id                    2     000144 automatic       fixed bin(71,0)          array level 2 dcl 1629 set ref 1181*
cleanup                         000272 stack reference condition                dcl 1694 ref 247 339
code                                   based           fixed bin(35,0)          dcl 1624 set ref 242* 473* 475* 478 4-115* 870* 1149
common                                 based           structure                level 1 packed packed unaligned dcl 5-13
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
conflict_detail_known           000355 automatic       bit(1)                   initial packed unaligned dcl 1785 set ref 601* 1307*
                                                                                  1535 1785*
conflict_relation               000366 automatic       char(32)                 packed unaligned dcl 1787 set ref 600* 1306* 1572*
conflict_sw                     000165 automatic       bit(1)                   packed unaligned dcl 1653 in procedure "set_fscope"
                                                                                  set ref 332* 497 579 590* 594 595* 596 1268* 1269
                                                                                  1296* 1300 1301* 1302 1318 1366* 1368 1384* 1392
                                                                                  1393* 1394 1604*
conflict_sw                            parameter       bit(1)                   packed unaligned dcl 1433 in procedure
                                                                                  "check_dead_proc" set ref 1424 1457*
conflict_ul_ptr                 000252 automatic       pointer                  dcl 1681 set ref 581* 590* 599 1296* 1305 1384* 1438
                                                                                  1441 1454 1458* 1464
conflict_user_id                000356 automatic       char(32)                 packed unaligned dcl 1786 set ref 599* 1305* 1572*
continue                        000316 automatic       char(1)                  initial packed unaligned dcl 1765 set ref 392* 682*
                                                                                  705* 734* 768* 1572* 1765*
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 251 1-137
cu_$arg_count                   000040 constant        entry                    external dcl 1704 ref 223 520
cu_$arg_ptr                     000042 constant        entry                    external dcl 1704 ref 231 239 255 369 406 411 446
                                                                                  451 525
data                                   based           structure                level 2 in structure "rm_db_info" dcl 11-86
                                                                                  in procedure "set_fscope"
data                                   based           structure                level 2 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "set_fscope"
db_index                               based           fixed bin(35,0)          dcl 1619 set ref 258*
db_lock_id               11            based           bit(36)                  level 3 dcl 9-57 ref 1441
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 6-62 ref 1329 1523 1535
db_path                   2            based           char(168)                level 3 dcl 11-86 ref 323 323 731 731 734 1505
dbc                                    based           structure                level 1 unaligned dcl 8-14
dbc_ptr                  30            based           pointer                  level 3 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "set_fscope" set ref 263 1158*
dbc_ptr                         000554 automatic       pointer                  initial dcl 8-44 in procedure "set_fscope" set ref
                                                                                  222* 263* 279 301* 301 311* 313* 475 475 519* 554*
                                                                                  8-44* 574 574 590* 946 998* 1004 1005* 1005 1008*
                                                                                  1011 1011 1068* 1083* 1086* 1122* 1122 1123* 1137*
                                                                                  1147 1163 1186 1186 1187 1188* 1188 1191* 1194
                                                                                  1194 1197 1209 1235 1240 1248 1255 1296* 1324 1324
                                                                                  1324 1332 1332 1356* 1356 1364* 1384* 1397* 1407
                                                                                  1407 1419* 1458* 1463
dbcb                                   based           structure                level 1 dcl 7-142
dbcb_data                              based           structure                level 1 unaligned dcl 7-148
dbcb_ptr                        000552 automatic       pointer                  dcl 7-146 set ref 258* 260 263 267 270 271 338 356
                                                                                  559* 1133 1158 1158 1158 1505
dbi_ptr                         000246 automatic       pointer                  dcl 1681 set ref 255* 258
dead_proc                16(23)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1438 1464*
dead_proc_conflict       16(24)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1264 1465*
dead_proc_flag            4(01)        based           bit(1)                   level 4 packed packed unaligned dcl 8-14 set ref
                                                                                  1463*
delete_tuple              1(33) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1566
delete_tuple              0(33) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1549
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 5-22 in procedure
                                                                                  "set_fscope" ref 697 913 972 1334
delete_tuple             10(05)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 961* 972* 980 1080 1382
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 5-20 in procedure "set_fscope" ref
                                                                                  641 677 694 744 764 808 901 967 976
delete_tuple              0(33) 000334 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1382*
delete_tuple             27(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 913* 1293
delete_tuple             26(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 901* 1284
delete_tuple              7(34)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 956* 967* 1377
delete_tuple              0(33) 000335 automatic       bit(1)                   level 2 in structure "remembered_permits" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1284*
delete_tuple              0(33) 000336 automatic       bit(1)                   level 2 in structure "remembered_prevents" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1293*
delete_tuple              0(33) 000333 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1377*
delete_tuple_perm        21(09)        based           bit(1)                   level 2 packed packed unaligned dcl 13-119 ref 670
divide                                                 builtin function         dcl 1697 ref 365
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
dummy_ptr                              parameter       pointer                  dcl 616 set ref 565 571* 572* 614*
empty                                                  builtin function         dcl 1794 ref 1793
empty_on_err                    000160 automatic       bit(1)                   initial dcl 1643 set ref 297* 1156 1643*
entry_name                      000172 automatic       char(32)                 packed unaligned dcl 1659 set ref 219* 362 441 441
                                                                                  444 516* 553*
error_code                      000642 automatic       fixed bin(35,0)          dcl 780 set ref 731* 733 734* 739*
error_table_$bad_arg            000142 external static fixed bin(35,0)          dcl 718 set ref 705* 711*
error_table_$invalid_lock_reset 000076 external static fixed bin(35,0)          dcl 1725 ref 281 1236 1249 1444
error_table_$lock_wait_time_exceeded
                                000072 external static fixed bin(35,0)          dcl 1725 ref 1149 1232 1446
error_table_$locked_by_this_process
                                000074 external static fixed bin(35,0)          dcl 1725 ref 281 1236 1249 1446
ev_chn_id                12            based           fixed bin(71,0)          level 3 dcl 9-57 set ref 1175* 1181 1200* 1402*
event_signal_sw          16(22)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1207* 1231* 1321* 1333* 1359 1406*
fb35_ovrly                             based           fixed bin(35,0)          dcl 717 ref 704 704
fil_list                               based           structure                level 1 unaligned dcl 9-89 set ref 946 947*
fil_list_ofs             22            based           bit(18)                  level 3 packed packed unaligned dcl 9-57 set ref 920
                                                                                  1068* 1123* 1364*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_scope_triple              000163 automatic       bit(1)                   packed unaligned dcl 1650 set ref 334* 918 921*
                                                                                  1606*
first_time_asleep                      parameter       bit(1)                   packed unaligned dcl 1170 ref 1167 1173
fixed                                                  builtin function         dcl 1795 ref 294 295
fl_ptr                          000560 automatic       pointer                  initial dcl 9-110 set ref 9-110* 926 946* 947 948
                                                                                  949 953 954 955 956 958 959 960 961 964 965 966
                                                                                  967 969 970 971 972 977 980 980 980 980 983 984
                                                                                  1364* 1368 1370 1374 1375 1376 1377 1379 1380 1381
                                                                                  1382 1397* 1397
flags                     4            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 8-14 in procedure "set_fscope"
flags                    26            based           structure                array level 3 in structure "scope_info" dcl 10-32
                                                                                  in procedure "set_fscope" set ref 426
flags                    16            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 9-57 in procedure "set_fscope"
flo_ptr                         000260 automatic       pointer                  dcl 1681 set ref 920* 924* 926*
get_process_id_                 000044 constant        entry                    external dcl 1704 ref 304 1124
group_id                               based           char(32)                 level 3 packed packed unaligned dcl 9-57 ref 599
                                                                                  1305
hcs_$wakeup                     000054 constant        entry                    external dcl 1704 ref 1402
i                               000225 automatic       fixed bin(17,0)          dcl 1662 in procedure "set_fscope" set ref 367* 368*
i                               000632 automatic       fixed bin(17,0)          dcl 721 in procedure "check_mrds_access" set ref
                                                                                  627* 628* 628 629 630 657* 658*
icode                           000233 automatic       fixed bin(35,0)          dcl 1674 set ref 231* 232 239* 240 251* 255* 256
                                                                                  256* 279* 281 281 281* 285 287* 323* 325 325* 369*
                                                                                  371 371* 406* 408 408* 411* 413 413* 446* 448 448*
                                                                                  451* 453 453* 525* 526 603* 605* 998* 1133* 1135
                                                                                  1135* 1163* 1197* 1202* 1209* 1232* 1234 1235*
                                                                                  1236 1236 1236* 1240 1243* 1245* 1248* 1249 1249
                                                                                  1249* 1253 1256* 1309* 1311* 1458* 1459 1459*
                                                                                  1572*
ids                                    based           structure                level 2 unaligned dcl 9-57
idx                             001014 automatic       fixed bin(17,0)          dcl 1227 set ref 1234* 1269* 1273 1274 1278 1280
                                                                                  1282 1284 1287 1289 1291 1293*
index                                                  builtin function         dcl 1796 ref 385 627
info                            000150 automatic       structure                level 1 unaligned dcl 1633 set ref 1212 1212
info_ptr                        000330 automatic       pointer                  initial dcl 1767 set ref 392* 682* 705* 734* 768*
                                                                                  1572* 1767*
ioa_                            000134 constant        entry                    external dcl 1788 ref 1329 1531
ipc_$block                      000046 constant        entry                    external dcl 1704 ref 1212
ipc_$create_ev_chn              000050 constant        entry                    external dcl 1704 ref 1175
l                               000226 automatic       fixed bin(17,0)          dcl 1662 set ref 385* 391 398* 398 399 400 401
length                                                 builtin function         dcl 1697 ref 378
local_area                      000402 automatic       area(100)                dcl 1793 set ref 323 323 1793*
mdbm_data_$quiesce_mode         000100 external static fixed bin(35,0)          dcl 1725 ref 951
mdbm_secured             21(06)        based           bit(1)                   level 2 packed packed unaligned dcl 13-119 ref 645
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 478* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mod                                                    builtin function         dcl 1697 ref 229
model_name                             based           char(30)                 array level 3 in structure "rm_rel_array" dcl 12-34
                                                                                  in procedure "set_fscope" ref 400 630
model_name               10            based           char(30)                 level 2 in structure "rm_rel_info" dcl 13-119
                                                                                  in procedure "set_fscope" ref 1505
model_rel_name                  000202 automatic       char(30)                 packed unaligned dcl 1660 set ref 400* 460* 590 590
                                                                                  630* 731 731 734 948 1273* 1296 1296 1370* 1384
                                                                                  1384
modify_attr               0(32)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 5-20 in procedure "set_fscope" ref
                                                                                  641 677 694 744 764 802 895 965 976
modify_attr               0(32) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1543
modify_attr               1(32) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1560
modify_attr               0(32)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 5-22 in procedure
                                                                                  "set_fscope" ref 697 907 970 1334
modify_attr               0(32) 000336 automatic       bit(1)                   level 2 in structure "remembered_prevents" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1289*
modify_attr               0(32) 000334 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1380*
modify_attr              10(06)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 959* 970* 980 1081 1380
modify_attr               7(33)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 954* 965* 1375
modify_attr              27(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 907* 1289
modify_attr               0(32) 000335 automatic       bit(1)                   level 2 in structure "remembered_permits" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1280*
modify_attr              26(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 895* 1280
modify_attr               0(32) 000333 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1375*
modify_perm              20(03)        based           bit(1)                   level 2 packed packed unaligned dcl 14-46 ref 661
mrds_access                     000714 automatic       varying char(120)        dcl 861 set ref 825* 827* 827 833* 833 836* 836 839*
                                                                                  839 843* 843 845* 845 848* 848 851* 851 854* 854
                                                                                  857
mrds_authorization                     based           structure                level 1 dcl 15-22
mrds_authorization_ptr          000602 automatic       pointer                  dcl 15-29 set ref 323* 731
mrds_authorization_structure_version
                                000065 constant        fixed bin(17,0)          initial dcl 15-31 set ref 323*
mrds_data_$lock_wait_time       000102 external static fixed bin(35,0)          dcl 1725 set ref 235 529 556 1235 1248
mrds_debug_$switch              000140 external static bit(9)                   array packed unaligned dcl 6-135 ref 1329 1329 1523
                                                                                  1523 1535 1535
mrds_dm_authorization$get_user_class
                                000136 constant        entry                    external dcl 1792 ref 323
mrds_error_$db_busy             000124 external static fixed bin(35,0)          dcl 1725 ref 1243
mrds_error_$db_conflict_dead_process
                                000122 external static fixed bin(35,0)          dcl 1725 set ref 603 1264* 1309
mrds_error_$duplicate_scope     000106 external static fixed bin(35,0)          dcl 1725 set ref 426*
mrds_error_$invalid_db_index    000110 external static fixed bin(35,0)          dcl 1725 set ref 260* 316*
mrds_error_$non_scope_ready     000120 external static fixed bin(35,0)          dcl 1725 set ref 267* 638*
mrds_error_$rel_name_too_long   000112 external static fixed bin(35,0)          dcl 1725 set ref 378*
mrds_error_$scope_mrds_access_conflict
                                000144 external static fixed bin(35,0)          dcl 719 set ref 682* 688*
mrds_error_$scope_not_empty     000114 external static fixed bin(35,0)          dcl 1725 set ref 274*
mrds_error_$scope_system_access_conflict
                                000150 external static fixed bin(35,0)          dcl 785 set ref 768* 776*
mrds_error_$unable_to_create_channel
                                000104 external static fixed bin(35,0)          dcl 1725 set ref 1179*
mrds_error_$unable_to_queue_user
                                000126 external static fixed bin(35,0)          dcl 1725 set ref 1214*
mrds_error_$unknown_relation_name
                                000116 external static fixed bin(35,0)          dcl 1725 set ref 392* 395*
mrds_error_$update_not_allowed  000130 external static fixed bin(35,0)          dcl 1725 set ref 641*
msg                       2     000150 automatic       fixed bin(71,0)          level 2 dcl 1633 set ref 998 1229 1259
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 338* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 237* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_check_scope                  000066 constant        entry                    external dcl 1717 ref 590 1296 1384
mu_database_index$get_resultant_model_pointer
                                000064 constant        entry                    external dcl 1717 ref 258
mu_de_queue_user                000070 constant        entry                    external dcl 1717 ref 998 1458
mu_empty_scope                  000062 constant        entry                    external dcl 1717 ref 1158
mu_get_relation_acl             000146 constant        entry                    external dcl 781 ref 731
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 13-119
                                                                                  in procedure "set_fscope" set ref 682* 705* 768*
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 12-34 in procedure
                                                                                  "set_fscope" ref 385 627
name                      6            based           char(30)                 array level 3 in structure "scope_info" dcl 10-32
                                                                                  in procedure "set_fscope" ref 460 1273
name                                   based           char(30)                 level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 948* 1071 1130* 1370
nargs                           000222 automatic       fixed bin(17,0)          dcl 1662 set ref 223* 224 229 231 239* 365 520* 521
                                                                                  523 525
nchn                            000144 automatic       fixed bin(17,0)          level 2 dcl 1629 set ref 1182*
next_active_ofs          22(18)        based           bit(18)                  level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1007 1008* 1086*
next_ofs                 11            based           bit(18)                  level 2 packed packed unaligned dcl 9-89 set ref 926
                                                                                  983* 1083* 1137* 1397*
next_open_ofs            23(18)        based           bit(18)                  level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  311* 313*
next_waiting_ofs         23            based           bit(18)                  level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1190 1191* 1419*
nfiles                    4            based           fixed bin(17,0)          level 2 dcl 10-32 ref 422 459 1269
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 13-119 ref 658
null                                                   builtin function         dcl 1697 ref 222 260 267 302 303 309 316 463 475 519
                                                                                  554 556 1767 8-44 9-109 9-110 10-59 14-65 1-123
                                                                                  1-123 581 626 1006 1065 1070 1125 1147 1189 1320
                                                                                  1358 1368 1478
null_permit_request             000377 automatic       bit(1)                   packed unaligned dcl 1790 set ref 694* 700 744
null_prevent_request            000400 automatic       bit(1)                   packed unaligned dcl 1791 set ref 697* 700
null_request                    000376 automatic       bit(1)                   packed unaligned dcl 1789 set ref 700*
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 13-119 ref 657
num_filns                       000562 automatic       fixed bin(17,0)          dcl 9-112 set ref 221*
num_rels                               based           fixed bin(17,0)          level 2 dcl 12-34 ref 385 400 401 627 629 630
num_tuples                      000224 automatic       fixed bin(17,0)          dcl 1662 set ref 365* 367
offsets                  21            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 8-14 in procedure "set_fscope"
offsets                  22            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 9-57 in procedure "set_fscope"
ofs                                    parameter       bit(18)                  packed unaligned dcl 1476 ref 1472 1478 1480
open                    146            based           entry variable           level 4 dcl 7-142 ref 1505
open_mode                16            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 9-57 ref 951
open_users_ofs           21            based           bit(18)                  level 4 packed packed unaligned dcl 8-14 set ref
                                                                                  301*
opening_id               42            based           bit(36)                  level 2 dcl 13-119 set ref 1128 1133* 1505*
ophset                                 based           bit(18)                  packed unaligned dcl 1678 in procedure "set_fscope"
                                                                                  set ref 1010* 1193*
ophset                                 based           bit(18)                  packed unaligned dcl 943 in procedure
                                                                                  "add_fil_list_entry" set ref 984*
or_code                         000140 automatic       fixed bin(35,0)          dcl 1497 set ref 1505* 1509 1509*
or_rdbi_ptr                     000142 automatic       pointer                  dcl 1498 set ref 1503* 1505
or_rmri_ptr                            parameter       pointer                  dcl 1493 ref 1484 1503 1505 1505
passive_sw               16(18)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  975* 978* 1454
permit_conflict                 001040 automatic       varying char(80)         dcl 1581 set ref 1538* 1540* 1540 1543* 1543 1546*
                                                                                  1546 1549* 1549 1552 1552* 1572*
permit_requests                        based           structure                level 1 packed packed unaligned dcl 5-20
permit_requests_ptr             000546 automatic       pointer                  dcl 5-24 set ref 406* 446* 560* 590* 641 641 641 677
                                                                                  677 677 677 694 694 694 694 704 744 744 744 744
                                                                                  764 764 764 799 802 805 808 892 895 898 901 964
                                                                                  965 966 967 976 976 976
permit_scope                    000660 automatic       varying char(80)         dcl 816 set ref 797* 799* 799 802* 802 805* 805 808*
                                                                                  808 811 811* 814
permits                   7(18)        based           structure                level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope"
permits                  26            based           structure                array level 4 in structure "scope_info" dcl 10-32
                                                                                  in procedure "set_fscope"
permits                         000346 automatic       structure                level 2 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope"
pointer                                                builtin function         dcl 1697 ref 1127 1503
pos_in_si                       000227 automatic       fixed bin(17,0)          dcl 1662 set ref 422* 422* 426 459* 460 461* 890 892
                                                                                  895 898 901 904 907 910 913
prev_ofs_ptr                           parameter       pointer                  dcl 939 ref 933 984
prevent_conflict                001065 automatic       varying char(80)         dcl 1581 set ref 1555* 1557* 1557 1560* 1560 1563*
                                                                                  1563 1566* 1566 1569 1569* 1572*
prevent_requests                       based           structure                level 1 packed packed unaligned dcl 5-22
prevent_requests_ptr            000550 automatic       pointer                  dcl 5-24 set ref 411* 451* 561* 590* 697 697 697 697
                                                                                  704 904 907 910 913 969 970 971 972 1334 1334 1334
                                                                                  1334
prevents                 10(02)        based           structure                level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope"
prevents                 27            based           structure                array level 4 in structure "scope_info" dcl 10-32
                                                                                  in procedure "set_fscope"
prevents                  1     000346 automatic       structure                level 2 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope"
priority_high            16(21)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1183* 1414*
process_id               10            based           bit(36)                  level 3 packed packed unaligned dcl 9-57 set ref 304
                                                                                  1066 1402*
proper                                 based           structure                level 2 unaligned dcl 8-14
ptr                                                    builtin function         dcl 1797 ref 1480
ptr_bit_string                         based           bit(72)                  packed unaligned dcl 1641 ref 306
queue_activ              16(25)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  329* 1208* 1262* 1601*
quit                            000300 stack reference condition                dcl 1694 ref 248 344
ra_ptr                  134            based           pointer                  level 3 dcl 11-86 ref 272
rai_ptr                         000600 automatic       pointer                  initial dcl 14-65 in procedure "set_fscope" set ref
                                                                                  14-65*
rai_ptr                         000630 automatic       pointer                  dcl 720 in procedure "check_mrds_access" set ref
                                                                                  658* 659 661
rdbi_bits                14            based           bit(72)                  level 3 packed packed unaligned dcl 9-57 ref 306
rdbi_ptr                        000572 automatic       pointer                  dcl 11-90 in procedure "set_fscope" set ref 271* 272
                                                                                  306 323 323 731 731 734
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "set_fscope" set ref 271 1158*
re_check                        000162 automatic       bit(1)                   packed unaligned dcl 1649 set ref 333* 582* 587 588*
                                                                                  596* 1270* 1271 1272* 1302* 1605*
read_access                     000650 automatic       bit(1)                   packed unaligned dcl 786 set ref 731* 744 744 752
read_attr                10(03)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 958* 969* 1078 1379
read_attr                 0(35) 000335 automatic       bit(1)                   level 2 in structure "remembered_permits" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1278*
read_attr                 1(35) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1557
read_attr                26            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 892* 1278
read_attr                 0(35) 000333 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1374*
read_attr                10(01)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 953* 964* 1074 1374
read_attr                27            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 10-32 in procedure
                                                                                  "set_fscope" set ref 904* 1287
read_attr                 0(35) 000336 automatic       bit(1)                   level 2 in structure "remembered_prevents" packed
                                                                                  packed unaligned dcl 1769 in procedure
                                                                                  "set_fscope" set ref 1287*
read_attr                 0(35) 000346 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1776 in procedure
                                                                                  "set_fscope" set ref 1540
read_attr                 0(35) 000334 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1769 in procedure "set_fscope" set
                                                                                  ref 1379*
read_attr                 0(35)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 5-22 in procedure
                                                                                  "set_fscope" ref 697 904 969 1334
read_attr                 0(35)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 5-20 in procedure "set_fscope" ref
                                                                                  677 694 744 799 892 964
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 14-46 ref 659
ready_mode               37            based           fixed bin(17,0)          level 2 dcl 13-119 ref 638 641
rel                                                    builtin function         dcl 1697 ref 984 1010 1127 1193
rel_append_perm                 000342 automatic       bit(1)                   packed unaligned dcl 1773 set ref 645* 669* 671 677
                                                                                  845
rel_data                               based           structure                array level 2 dcl 12-34
rel_delete_perm                 000343 automatic       bit(1)                   packed unaligned dcl 1774 set ref 645* 670* 671 677
                                                                                  848
rel_len                         000232 automatic       fixed bin(17,0)          dcl 1662 set ref 369* 378 384 392 392
rel_name                               based           char                     packed unaligned dcl 1619 set ref 378 384 392*
rel_name_32                     000234 automatic       char(32)                 packed unaligned dcl 1677 set ref 384* 385
rel_null_perm                   000344 automatic       bit(1)                   packed unaligned dcl 1775 set ref 671* 851
rel_ptr                         000254 automatic       pointer                  dcl 1681 set ref 369* 378 384 392
relmgr_entries          146            based           structure                level 3 dcl 7-142
remembered_permits              000335 automatic       structure                level 1 packed packed unaligned dcl 1769 set ref
                                                                                  1276* 1296 1296
remembered_prevents             000336 automatic       structure                level 1 packed packed unaligned dcl 1769 set ref
                                                                                  1276* 1296 1296
report_reason                   001112 automatic       varying char(120)        dcl 1583 set ref 1524* 1526* 1528* 1531*
report_type                            parameter       fixed bin(17,0)          dcl 1582 ref 1516 1524 1526 1528 1535
required_access                 000644 automatic       varying char(4)          dcl 783 set ref 764* 766* 768*
return_value                    000332 automatic       fixed bin(35,0)          initial dcl 1768 set ref 392* 682* 705* 734* 768*
                                                                                  1572* 1768*
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 12-34 ref
                                                                                  401 629
rm_attr_info                           based           structure                level 1 dcl 14-46
rm_db_info                             based           structure                level 1 dcl 11-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 11-92
rm_rel_array                           based           structure                level 1 dcl 12-34
rm_rel_info                            based           structure                level 1 dcl 13-119
rmra_ptr                        000574 automatic       pointer                  dcl 12-43 set ref 272* 385 399 400 401 627 629 630
rmri_ptr                               parameter       pointer                  dcl 788 in procedure "check_system_access" ref 725
                                                                                  768
rmri_ptr                        000576 automatic       pointer                  dcl 13-156 in procedure "set_fscope" set ref 401*
                                                                                  431* 463* 464* 705
rmri_ptr                 12            based           pointer                  level 2 in structure "fil_list" dcl 9-89
                                                                                  in procedure "set_fscope" set ref 949* 1126
rmri_ptr                               parameter       pointer                  dcl 720 in procedure "check_mrds_access" set ref 619
                                                                                  626 629* 638 641 645 657 658 669 670 682
rtrim                                                  builtin function         dcl 1798 ref 323 323 378 731 731 731 731 734 734
sbtp_a_prevents                 000114 automatic       bit(1)                   packed unaligned dcl 1054 set ref 1062* 1079* 1079
                                                                                  1089
sbtp_aul_ptr                    000106 automatic       pointer                  dcl 1049 set ref 1059* 1065 1066 1068 1086* 1086
sbtp_d_prevents                 000115 automatic       bit(1)                   packed unaligned dcl 1055 set ref 1063* 1080* 1080
                                                                                  1089
sbtp_faul_ptr                          parameter       pointer                  dcl 1033 ref 1020 1059
sbtp_fl_ptr                     000110 automatic       pointer                  dcl 1050 set ref 1068* 1070 1071 1074 1074 1078 1079
                                                                                  1080 1081 1083* 1083
sbtp_m_prevents                 000116 automatic       bit(1)                   packed unaligned dcl 1056 set ref 1064* 1081* 1081
                                                                                  1089
sbtp_pid                               parameter       bit(36)                  packed unaligned dcl 1034 ref 1020 1066
sbtp_r_prevents                 000113 automatic       bit(1)                   packed unaligned dcl 1053 set ref 1061* 1078* 1078
                                                                                  1089
sbtp_rel_found                  000112 automatic       bit(1)                   packed unaligned dcl 1051 set ref 1069* 1070 1073*
sbtp_rel_name                          parameter       char(30)                 packed unaligned dcl 1032 ref 1020 1071
sbtp_relmgr_my_permits                 parameter       bit(2)                   dcl 1035 set ref 1020 1060* 1074* 1074
sbtp_relmgr_others_permits             parameter       bit(2)                   dcl 1040 set ref 1020 1089*
scope                     6            based           structure                array level 2 dcl 10-32
scope_flags                            based           structure                level 1 dcl 10-42
scope_info                             based           structure                level 1 dcl 10-32
scope_lock               13            based           bit(36)                  level 3 dcl 8-14 set ref 279* 475* 1163* 1197* 1209*
                                                                                  1235* 1248*
scope_ptr                34            based           pointer                  level 3 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "set_fscope" set ref 267 270 1158*
scope_ptr                       000570 automatic       pointer                  initial dcl 10-59 in procedure "set_fscope" set ref
                                                                                  270* 274 422 422 426 459 460 461 10-59* 890 892
                                                                                  895 898 901 904 907 910 913 916 916 1269 1273 1274
                                                                                  1278 1280 1282 1284 1287 1289 1291 1293
set_lock_$lock                  000056 constant        entry                    external dcl 1704 ref 279 1235 1248 1441
set_lock_$unlock                000060 constant        entry                    external dcl 1704 ref 475 1163 1197 1209
set_scope               166            based           entry variable           level 4 dcl 7-142 ref 1133
sm_name                  16            based           char(32)                 array level 3 dcl 10-32 ref 422 461 1274
srs_first_ul_ptr                000122 automatic       pointer                  dcl 1116 set ref 1122* 1130*
srs_fl_ptr                      000124 automatic       pointer                  dcl 1117 set ref 1123* 1125 1126 1130 1137* 1137
srs_process_id                  000126 automatic       bit(36)                  packed unaligned dcl 1118 set ref 1124* 1130*
srs_relmgr_my_permits           000117 automatic       bit(2)                   dcl 1107 set ref 1130* 1133*
srs_relmgr_others_permits       000120 automatic       bit(2)                   dcl 1111 set ref 1130* 1133*
srs_rmri_ptr                    000130 automatic       pointer                  dcl 1119 set ref 1126* 1127* 1127 1127 1128 1128*
                                                                                  1133
ss_rmri_ptr                            parameter       pointer                  dcl 888 set ref 877 924*
state                           000157 automatic       fixed bin(35,0)          dcl 1642 set ref 1175* 1179 1212* 1214 1402* 1403
                                                                                  1441* 1442 1444 1446 1446 1449*
static_area              30            based           area                     level 2 dcl 8-14 ref 946
status                                 parameter       bit(1)                   packed unaligned dcl 1434 in procedure
                                                                                  "check_dead_proc" set ref 1424 1438* 1442* 1444*
                                                                                  1446* 1454
status                          000166 automatic       bit(1)                   packed unaligned dcl 1655 in procedure "set_fscope"
                                                                                  set ref 595* 602 1301* 1308 1393*
string                                                 builtin function         dcl 1799 ref 385 426 627
sub_err_                        000132 constant        entry                    external dcl 1764 ref 392 682 705 734 768 1572
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 12-34 ref
                                                                                  399
submodel_rel_name               000212 automatic       char(32)                 packed unaligned dcl 1661 set ref 399* 422 461* 600
                                                                                  627 1274* 1306
substr                                                 builtin function         dcl 1800 ref 1329 1523 1535
system_access                   000646 automatic       varying char(4)          dcl 784 set ref 750* 752* 752 755* 755 758 758* 768*
this_ul_ptr                     000262 automatic       pointer                  dcl 1681 set ref 302* 308* 316 319 590 998 1010 1012
                                                                                  1172 1193 1195 1261
timer_manager_$alarm_wakeup     000052 constant        entry                    external dcl 1704 ref 1200
touched                  30            based           bit(1)                   array level 4 packed packed unaligned dcl 10-32 set
                                                                                  ref 890*
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 7-142 ref 338
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 8-14 set ref
                                                                                  1240* 1255*
ul_ptr                          000556 automatic       pointer                  initial dcl 9-109 set ref 301* 303 304 306 308 309*
                                                                                  311* 311 313* 313 319* 329 330 9-109* 920 951 975
                                                                                  978 1005* 1006 1007 1008* 1008 1012* 1013 1014
                                                                                  1123 1172* 1175 1181 1183 1184 1185 1186 1188*
                                                                                  1189 1190 1191* 1191 1195* 1200 1207 1208 1231
                                                                                  1261* 1262 1264 1296* 1320 1321 1322 1322 1333
                                                                                  1356* 1358 1359 1364 1384* 1402 1402 1406 1413
                                                                                  1413 1414 1414 1414 1419* 1419 1465 1601 1602
ulo_ptr                         000256 automatic       pointer                  dcl 1681 set ref 1004* 1007* 1010 1187* 1190* 1193
unspec                                                 builtin function         dcl 1801 set ref 294 295 947* 1276* 1276* 1372*
                                                                                  1372*
unused_conflict_detail          000350 automatic       structure                level 1 packed packed unaligned dcl 1779 set ref
                                                                                  1384 1384
update                   10(02)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 980*
update                   10            based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 9-89 in procedure "set_fscope" set
                                                                                  ref 977* 1074
user_counts               7            based           structure                level 3 unaligned dcl 8-14
user_list                              based           structure                level 1 unaligned dcl 9-57
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 7-142 in procedure "set_fscope" set ref 356*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "set_fscope" set ref 1-92*
                                                                                  1-98* 356 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
wait_list                       000144 automatic       structure                level 1 unaligned dcl 1629 set ref 1212 1212
wait_sec_fb71                   000170 automatic       fixed bin(71,0)          dcl 1658 set ref 1199* 1200*
wait_seconds                           based           fixed bin(35,0)          dcl 1656 ref 279 1199
waiting_sw               16(20)        based           bit(1)                   level 3 packed packed unaligned dcl 9-57 set ref
                                                                                  1014* 1184*
waiting_users            11            based           fixed bin(17,0)          level 4 dcl 8-14 set ref 574 1186 1194* 1194
waiting_users_ofs        22            based           bit(18)                  level 4 packed packed unaligned dcl 8-14 set ref
                                                                                  1187 1188* 1356*
wakeup                          000164 automatic       bit(1)                   packed unaligned dcl 1652 set ref 1355* 1358 1365*
                                                                                  1394* 1400 1403* 1411
wakeup_waiters            6            based           fixed bin(17,0)          level 3 dcl 8-14 set ref 1324 1324* 1324 1332* 1332
                                                                                  1407* 1407
write_access                    000651 automatic       bit(1)                   packed unaligned dcl 787 set ref 731* 744 755
ws_ptr                          000250 automatic       pointer                  dcl 1681 set ref 231* 235* 279 525* 529* 556* 558*
                                                                                  1199

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEL                                    internal static bit(1)                   initial packed unaligned dcl 9-134
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 9-140
Q_PRM_BITS                             internal static bit(2)                   initial packed unaligned dcl 9-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 9-142
Q_PRV_BITS                             internal static bit(2)                   initial packed unaligned dcl 9-146
SET                                    internal static bit(1)                   initial packed unaligned dcl 9-132
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 8-46
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
conflict_detail                        based           structure                level 1 packed packed unaligned dcl 5-36
conflict_detail_ptr                    automatic       pointer                  dcl 5-40
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 6-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 6-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 6-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 6-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 6-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 6-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 6-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 6-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 6-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 6-62
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
max_file_init                          automatic       fixed bin(17,0)          dcl 10-58
module                                 internal static structure                level 1 unaligned dcl 6-91
natts_init                             automatic       fixed bin(17,0)          dcl 13-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 13-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 13-157
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 12-44
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 10-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 10-61
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 1725

NAMES DECLARED BY EXPLICIT CONTEXT.
activate_or_queue               003153 constant        entry                    internal dcl 489 ref 435 469
activate_user_scope             005514 constant        entry                    internal dcl 987 ref 501 1331
add_fil_list_entry              005343 constant        entry                    internal dcl 933 ref 924
awakened                        006532 constant        entry                    internal dcl 1220 ref 499
check_dead_proc                 007524 constant        entry                    internal dcl 1424 ref 595 1301 1393
check_mrds_access               003335 constant        entry                    internal dcl 619 ref 571
check_scope_and_access          003165 constant        entry                    internal dcl 565 ref 431 464
check_system_access             004156 constant        entry                    internal dcl 725 ref 572
clean_up                        006205 constant        entry                    internal dcl 1144 ref 247 250 342 346 871
common_label                    000736 constant        label                    dcl 237 ref 530
convert                         007676 constant        entry                    internal dcl 1472 ref 301 311 313 1005 1008 1068
                                                                                  1083 1086 1122 1123 1137 1188 1191 1356 1364 1397
                                                                                  1419
error                           005204 constant        entry                    internal dcl 865 ref 256 260 267 274 287 316 325
                                                                                  1-140 371 378 395 408 413 426 448 453 605 638 641
                                                                                  688 711 739 776 1135 1179 1214 1245 1256 1264 1311
                                                                                  1449 1459 1509
exit                            002366 constant        label                    dcl 478 set ref 872
get_mrds_access                 005022 constant        entry                    internal dcl 820 ref 682
get_permit_scope                004705 constant        entry                    internal dcl 792 ref 682 768
mftxn_check_code                002377 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      002617 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_set_fscope             000645 constant        entry                    external dcl 28
mrds_dsl_set_fscope_all         002634 constant        entry                    external dcl 505
mrds_dsl_set_fscope_all_pntr    002731 constant        entry                    external dcl 532
mstxn_any_other                 003054 constant        entry                    internal dcl 1-116 ref 347 349
mstxn_cleanup                   003021 constant        entry                    internal dcl 1-102 ref 341
mstxn_exit                      001576 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
open_relation                   007723 constant        entry                    internal dcl 1484 ref 1128
pntr                            002753 constant        entry                    external dcl 532
pntr2                           001111 constant        label                    dcl 263 set ref 563
queue_scope                     006264 constant        entry                    internal dcl 1167 ref 498 1326
report_conflict_detail          010000 constant        entry                    internal dcl 1516 ref 604 1203 1244 1310
restore_significant_data        010424 constant        entry                    internal dcl 1599 ref 4-77
scopes_by_this_process          005633 constant        entry                    internal dcl 1020 ref 1130
set_fscope                      000635 constant        entry                    external dcl 28
set_fscope_all                  002624 constant        entry                    external dcl 505
set_fscope_all_pntr             002742 constant        entry                    external dcl 532
set_relmgr_scopes               006021 constant        entry                    internal dcl 1095 ref 1016 1160
should_rollback                 010441 constant        entry                    internal dcl 1611 ref 4-94
store_scope                     005225 constant        entry                    internal dcl 877 ref 614
wakeup_next_waiter              007220 constant        entry                    internal dcl 1346 ref 1319 1334

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11576       11750   10552       11606
Length     12624   10552       152         637    1023           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
set_fscope                         1324 external procedure  is an external procedure.  
on unit on line 247                  64 on unit               
on unit on line 248                  68 on unit               
on unit on line 339                  76 on unit               
on unit on line 344                  64 on unit               
on unit on line 349                  64 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 339.  
mstxn_any_other                      76 internal procedure  is called by several nonquick procedures.  
activate_or_queue                       internal procedure  shares stack frame of external procedure set_fscope.  
check_scope_and_access                  internal procedure  shares stack frame of external procedure set_fscope.  
check_mrds_access                       internal procedure  shares stack frame of external procedure set_fscope.  
check_system_access                     internal procedure  shares stack frame of external procedure set_fscope.  
get_permit_scope                        internal procedure  shares stack frame of external procedure set_fscope.  
get_mrds_access                         internal procedure  shares stack frame of external procedure set_fscope.  
error                                64 internal procedure  is called by several nonquick procedures.  
store_scope                             internal procedure  shares stack frame of external procedure set_fscope.  
add_fil_list_entry                      internal procedure  shares stack frame of external procedure set_fscope.  
activate_user_scope                     internal procedure  shares stack frame of external procedure set_fscope.  
scopes_by_this_process                  internal procedure  shares stack frame of internal procedure set_relmgr_scopes.  
set_relmgr_scopes                   208 internal procedure  is called by several nonquick procedures.  
clean_up                             76 internal procedure  is called by several nonquick procedures.  
queue_scope                             internal procedure  shares stack frame of external procedure set_fscope.  
awakened                                internal procedure  shares stack frame of external procedure set_fscope.  
wakeup_next_waiter                      internal procedure  shares stack frame of external procedure set_fscope.  
check_dead_proc                         internal procedure  shares stack frame of external procedure set_fscope.  
convert                              65 internal procedure  is called by several nonquick procedures.  
open_relation                           internal procedure  shares stack frame of internal procedure set_relmgr_scopes.  
report_conflict_detail                  internal procedure  shares stack frame of external procedure set_fscope.  
restore_significant_data                internal procedure  shares stack frame of external procedure set_fscope.  
should_rollback                         internal procedure  shares stack frame of external procedure set_fscope.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
set_fscope               000100 mstxn_code                  set_fscope
                         000101 mstxn_retries               set_fscope
                         000102 mstxn_temp_code             set_fscope
                         000103 mstxn_transactions_needed   set_fscope
                         000104 user_started_transaction    set_fscope
                         000105 mstxn_txn_id                set_fscope
                         000106 user_transaction_id         set_fscope
                         000110 mstxn_condition_info        set_fscope
                         000142 mftxn_code                  set_fscope
                         000143 mftxn_temp_code             set_fscope
                         000144 wait_list                   set_fscope
                         000150 info                        set_fscope
                         000157 state                       set_fscope
                         000160 empty_on_err                set_fscope
                         000161 check_scope                 set_fscope
                         000162 re_check                    set_fscope
                         000163 first_scope_triple          set_fscope
                         000164 wakeup                      set_fscope
                         000165 conflict_sw                 set_fscope
                         000166 status                      set_fscope
                         000170 wait_sec_fb71               set_fscope
                         000172 entry_name                  set_fscope
                         000202 model_rel_name              set_fscope
                         000212 submodel_rel_name           set_fscope
                         000222 nargs                       set_fscope
                         000223 arg_len                     set_fscope
                         000224 num_tuples                  set_fscope
                         000225 i                           set_fscope
                         000226 l                           set_fscope
                         000227 pos_in_si                   set_fscope
                         000230 args_exp                    set_fscope
                         000231 arg_index                   set_fscope
                         000232 rel_len                     set_fscope
                         000233 icode                       set_fscope
                         000234 rel_name_32                 set_fscope
                         000244 cd_ptr                      set_fscope
                         000246 dbi_ptr                     set_fscope
                         000250 ws_ptr                      set_fscope
                         000252 conflict_ul_ptr             set_fscope
                         000254 rel_ptr                     set_fscope
                         000256 ulo_ptr                     set_fscope
                         000260 flo_ptr                     set_fscope
                         000262 this_ul_ptr                 set_fscope
                         000314 NULL_CHAR                   set_fscope
                         000316 continue                    set_fscope
                         000317 caller_name                 set_fscope
                         000330 info_ptr                    set_fscope
                         000332 return_value                set_fscope
                         000333 actual_permits              set_fscope
                         000334 actual_prevents             set_fscope
                         000335 remembered_permits          set_fscope
                         000336 remembered_prevents         set_fscope
                         000337 attr_retr_perm              set_fscope
                         000340 attr_modify_perm            set_fscope
                         000341 attr_null_perm              set_fscope
                         000342 rel_append_perm             set_fscope
                         000343 rel_delete_perm             set_fscope
                         000344 rel_null_perm               set_fscope
                         000346 actual_conflict_detail      set_fscope
                         000350 unused_conflict_detail      set_fscope
                         000352 TIME_OUT_REPORT             set_fscope
                         000353 BEING_QUEUED_REPORT         set_fscope
                         000354 DEAD_PROC_REPORT            set_fscope
                         000355 conflict_detail_known       set_fscope
                         000356 conflict_user_id            set_fscope
                         000366 conflict_relation           set_fscope
                         000376 null_request                set_fscope
                         000377 null_permit_request         set_fscope
                         000400 null_prevent_request        set_fscope
                         000402 local_area                  set_fscope
                         000546 permit_requests_ptr         set_fscope
                         000550 prevent_requests_ptr        set_fscope
                         000552 dbcb_ptr                    set_fscope
                         000554 dbc_ptr                     set_fscope
                         000556 ul_ptr                      set_fscope
                         000560 fl_ptr                      set_fscope
                         000562 num_filns                   set_fscope
                         000564 QUE_FREE                    set_fscope
                         000566 ALARM                       set_fscope
                         000570 scope_ptr                   set_fscope
                         000572 rdbi_ptr                    set_fscope
                         000574 rmra_ptr                    set_fscope
                         000576 rmri_ptr                    set_fscope
                         000600 rai_ptr                     set_fscope
                         000602 mrds_authorization_ptr      set_fscope
                         000630 rai_ptr                     check_mrds_access
                         000632 i                           check_mrds_access
                         000642 error_code                  check_system_access
                         000644 required_access             check_system_access
                         000646 system_access               check_system_access
                         000650 read_access                 check_system_access
                         000651 write_access                check_system_access
                         000660 permit_scope                get_permit_scope
                         000714 mrds_access                 get_mrds_access
                         001014 idx                         awakened
                         001040 permit_conflict             report_conflict_detail
                         001065 prevent_conflict            report_conflict_detail
                         001112 report_reason               report_conflict_detail
set_relmgr_scopes        000106 sbtp_aul_ptr                scopes_by_this_process
                         000110 sbtp_fl_ptr                 scopes_by_this_process
                         000112 sbtp_rel_found              scopes_by_this_process
                         000113 sbtp_r_prevents             scopes_by_this_process
                         000114 sbtp_a_prevents             scopes_by_this_process
                         000115 sbtp_d_prevents             scopes_by_this_process
                         000116 sbtp_m_prevents             scopes_by_this_process
                         000117 srs_relmgr_my_permits       set_relmgr_scopes
                         000120 srs_relmgr_others_permits   set_relmgr_scopes
                         000122 srs_first_ul_ptr            set_relmgr_scopes
                         000124 srs_fl_ptr                  set_relmgr_scopes
                         000126 srs_process_id              set_relmgr_scopes
                         000130 srs_rmri_ptr                set_relmgr_scopes
                         000140 or_code                     open_relation
                         000142 or_rdbi_ptr                 open_relation

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           mdfx1               signal_op
enable_op           shorten_stack       ext_entry           int_entry           trunc_fx2           set_chars_eis
index_chars_eis     divide_fx1          op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_count                 cu_$arg_ptr                   find_condition_info_
get_process_id_               hcs_$wakeup                   ioa_                          ipc_$block
ipc_$create_ev_chn            mrds_dm_authorization$get_user_class                        mu_check_scope
mu_database_index$get_resultant_model_pointer               mu_de_queue_user              mu_empty_scope
mu_get_relation_acl           set_lock_$lock                set_lock_$unlock              sub_err_
timer_manager_$alarm_wakeup   transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$bad_arg          error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_this_process
mdbm_data_$quiesce_mode       mrds_data_$lock_wait_time     mrds_debug_$switch            mrds_error_$db_busy
mrds_error_$db_conflict_dead_process                        mrds_error_$duplicate_scope   mrds_error_$invalid_db_index
mrds_error_$non_scope_ready   mrds_error_$rel_name_too_long mrds_error_$scope_mrds_access_conflict
mrds_error_$scope_not_empty   mrds_error_$scope_system_access_conflict
mrds_error_$unable_to_create_channel                        mrds_error_$unable_to_queue_user
mrds_error_$unknown_relation_name                           mrds_error_$update_not_allowed




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   1643 000577      1758 000600      1765 000602      1766 000604      1767 000607      1768 000611      1782 000612
   1783 000614      1784 000616      1785 000620      1793 000621    8   44 000624    9  109 000626    9  110 000627
10   59 000630   14   65 000631        28 000634       219 000653       220 000656       221 000660       222 000661
    223 000663       224 000672       229 000700       231 000705       232 000725       234 000732       235 000733
    237 000736       239 000737       240 000754       242 000761       247 000762       248 001004       250 001020
    251 001025       252 001035       255 001036       256 001055       258 001065       260 001076       263 001111
    267 001114       270 001130       271 001133       272 001136       274 001140       279 001151       281 001167
    285 001176       287 001200       294 001206       295 001210       297 001212       301 001214       302 001227
    303 001231       304 001236       306 001251       308 001255       309 001256       310 001260       311 001261
    312 001275       313 001276       314 001312       316 001313       319 001326       323 001330       325 001403
    329 001414       330 001417       331 001420       332 001422       333 001423       334 001424       338 001425
    339 001432       341 001446       342 001447       343 001454       344 001455       346 001471       347 001476
    348 001503       349 001504    1   83 001526    1   84 001527    1   86 001530    1   88 001532    1   89 001533
 1   90 001544    1   92 001550    1   93 001552    1   94 001554    1   95 001555    1   98 001556    1   99 001557
 1  100 001574    1  140 001576       356 001606       362 001614       365 001620       367 001624       368 001633
    369 001637       371 001654       378 001664       384 001710       385 001715       391 001740       392 001741
    395 002024       396 002033       398 002034       399 002050       400 002054       401 002071       406 002076
    408 002116       411 002126       413 002146       422 002156       424 002174       426 002177       431 002216
    433 002220       435 002222       441 002223       444 002233       446 002237       448 002256       451 002266
    453 002305       459 002315       460 002325       461 002333       463 002340       464 002342       466 002344
    469 002346       473 002347       475 002350       478 002366    4   60 002370    4   62 002375    4   63 002376
 4   65 002377    4   68 002401    4   69 002412    4   71 002414    4   72 002425    4   75 002440    4   77 002441
 4   78 002442    4   81 002451    4   82 002452    4   83 002465    4   85 002467    4   86 002500    4   88 002513
 4   90 002514    4   91 002515    4   93 002516    4   94 002517    4   96 002524    4   97 002540    4   99 002542
 4  100 002553    4  102 002566    4  104 002567    4  105 002570    4  107 002571    4  109 002572    4  110 002603
 4  114 002616    4  115 002617       487 002622       505 002623       516 002642       517 002645       519 002647
    520 002651       521 002660       523 002666       525 002672       526 002712       528 002717       529 002720
    530 002723       532 002724       553 002761       554 002764       555 002766       556 002770       558 003001
    559 003004       560 003007       561 003012       562 003015       563 003020    1  102 003021    1  107 003022
 1  109 003025    1  110 003036    1  114 003052    1  116 003053    1  121 003061    1  123 003064    1  124 003102
 1  126 003110    1  127 003113    1  129 003116    1  132 003130    1  133 003133    1  135 003136    1  136 003143
 1  137 003144    1  138 003152       489 003153       497 003154       498 003157       499 003161       500 003162
    501 003163       503 003164       565 003165       571 003167       572 003175       574 003204       579 003212
    581 003217       582 003221       587 003223       588 003226       590 003227       594 003262       595 003265
    596 003267       599 003275       600 003301       601 003304       602 003306       603 003311       604 003314
    605 003316       609 003324       614 003325       617 003334       619 003335       626 003337       627 003343
    628 003366       629 003402       630 003416       638 003424       641 003441       645 003473       653 003507
    657 003512       658 003532       659 003545       661 003553       663 003561       665 003563       669 003572
    670 003601       671 003605       677 003613       682 003644       688 003762       694 003771       697 004014
    700 004037       704 004041       705 004047       711 004146       723 004155       725 004156       731 004160
    733 004255       734 004260       739 004424       744 004433       750 004472       752 004473       755 004505
    758 004517       764 004530       766 004537       768 004543       776 004675       790 004704       792 004705
    797 004707       799 004710       802 004727       805 004745       808 004763       811 005001       814 005013
    820 005022       825 005024       827 005025       833 005042       836 005056       839 005072       843 005104
    845 005116       848 005132       851 005146       854 005162       857 005174       865 005203       870 005211
    871 005215       872 005222       877 005225       890 005227       892 005234       895 005244       898 005252
    901 005260       904 005266       907 005275       910 005303       913 005311       916 005317       918 005320
    920 005322       921 005325       924 005326       926 005337       929 005342       933 005343       946 005345
    947 005353       948 005356       949 005362       951 005366       953 005374       954 005377       955 005401
    956 005403       958 005405       959 005407       960 005411       961 005413       962 005415       964 005416
    965 005423       966 005426       967 005431       969 005434       970 005440       971 005443       972 005446
    975 005451       976 005454       977 005471       978 005473       980 005475       983 005502       984 005504
    985 005513       987 005514       998 005515      1004 005541      1005 005546      1006 005561      1007 005566
   1008 005573      1009 005606      1010 005607      1011 005615      1012 005617      1013 005621      1014 005624
   1016 005626      1018 005632      1020 005633      1059 005635      1060 005640      1061 005641      1062 005642
   1063 005643      1064 005644      1065 005645      1066 005652      1068 005661      1069 005675      1070 005676
   1071 005704      1073 005713      1074 005715      1078 005726      1079 005732      1080 005736      1081 005742
   1082 005746      1083 005747      1084 005763      1086 005764      1087 006003      1089 006004      1091 006017
   1095 006020      1122 006026      1123 006045      1124 006062      1125 006071      1126 006076      1127 006101
   1128 006111      1130 006116      1133 006134      1135 006153      1137 006165      1138 006202      1140 006203
   1144 006204      1147 006212      1149 006217      1156 006222      1158 006224      1160 006243      1163 006250
   1165 006263      1167 006264      1172 006266      1173 006270      1175 006275      1179 006307      1181 006320
   1182 006337      1183 006341      1184 006344      1185 006346      1186 006350      1187 006354      1188 006356
   1189 006370      1190 006374      1191 006377      1192 006412      1193 006413      1194 006421      1195 006423
   1197 006425      1199 006437      1200 006442      1202 006456      1203 006457      1204 006461      1207 006462
   1208 006465      1209 006467      1212 006501      1214 006520      1218 006531      1220 006532      1229 006533
   1231 006536      1232 006541      1234 006544      1235 006553      1236 006571      1239 006600      1240 006602
   1243 006607      1244 006612      1245 006614      1248 006622      1249 006640      1253 006647      1255 006651
   1256 006654      1259 006662      1261 006665      1262 006667      1264 006672      1268 006704      1269 006706
   1270 006722      1271 006724      1272 006726      1273 006727      1274 006736      1276 006743      1278 006745
   1280 006753      1282 006760      1284 006765      1287 006772      1289 006777      1291 007004      1293 007011
   1296 007016      1300 007053      1301 007056      1302 007060      1305 007066      1306 007072      1307 007075
   1308 007077      1309 007102      1310 007105      1311 007107      1315 007115      1316 007116      1318 007120
   1319 007123      1320 007124      1321 007130      1322 007133      1324 007134      1326 007141      1327 007143
   1329 007144      1331 007166      1332 007167      1333 007172      1334 007175      1344 007217      1346 007220
   1355 007221      1356 007222      1358 007235      1359 007244      1364 007250      1365 007262      1366 007264
   1368 007266      1370 007275      1372 007301      1374 007303      1375 007310      1376 007315      1377 007322
   1379 007327      1380 007334      1381 007341      1382 007346      1384 007353      1392 007410      1393 007413
   1394 007415      1396 007421      1397 007422      1398 007435      1400 007436      1402 007440      1403 007465
   1406 007471      1407 007474      1411 007476      1413 007500      1414 007502      1419 007507      1420 007522
   1422 007523      1424 007524      1438 007526      1441 007537      1442 007555      1444 007565      1446 007576
   1449 007610      1454 007616      1457 007630      1458 007634      1459 007653      1461 007663      1463 007664
   1464 007667      1465 007671      1468 007674      1472 007675      1478 007703      1480 007716      1484 007723
   1503 007725      1505 007730      1509 007766      1512 007777      1516 010000      1523 010002      1524 010011
   1526 010022      1528 010032      1531 010041      1535 010057      1538 010074      1540 010075      1543 010112
   1546 010127      1549 010144      1552 010161      1555 010173      1557 010174      1560 010211      1563 010226
   1566 010243      1569 010260      1572 010271      1578 010422      1587 010423      1599 010424      1601 010425
   1602 010430      1603 010431      1604 010433      1605 010435      1606 010436      1607 010440      1611 010441
   1613 010443


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
