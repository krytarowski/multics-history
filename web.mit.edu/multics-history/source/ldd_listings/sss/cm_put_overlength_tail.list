	COMPILATION LISTING OF SEGMENT cm_put_overlength_tail
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0954.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This routine takes a pointer to an element (p_element_ptr) and
       11*   allocates maximum-sized datums in which to store the element.  Starting
       12*   from the end of the element, it takes a maximum-sized piece off the end,
       13*   allocates a control interval, and stores the piece as a datum in the first
       14*   slot of the new control interval.  It stops when the element has been
       15*   reduced to less than a maximum-sized datum.  This routine can be called
       16*   with an element that already has had part of the element allocated in this
       17*   fashion, providing that the allocated portion is at the end and is all
       18*   maximum-sized datums.  In this case, the caller passes the datum_id of the
       19*   leftmost datum (p_continuation_datum_id) which is stored as part of the
       20*   first datum allocated by this routine.
       21*   
       22*        The first datum stored (the rightmost datum) is handled as a special
       23*   case if it is the last datum of the element (p_continuation_datum_id =
       24*   "0"b).  First, since it is the last datum, it is not itself continued,
       25*   i.e. it is a continuation_datum rather than a continued_continuation_datum. 
       26*   Second, if the total length of the element is not an integral number of
       27*   bytes, the last byte of this datum is padded to make it an integral number
       28*   of bytes.
       29*   
       30*        On output, p_remainder_length_in_bits is set to the number of bits of
       31*   the element not stored by this routine.  This is the leftmost part of the
       32*   element and the remaining number of bits must be less than the maximum size
       33*   of a datum. It can be zero.  p_continuation_datum_id is set to be the
       34*   datum_id of the last (logically, leftmost) datum stored.  
       35**/
       36 
       37 /* HISTORY:
       38*
       39*Written by Matthew Pierret, 10/27/82.
       40*Modified:
       41*12/23/82 by Lindsey Spratt:  Fixed to set cm_info_ptr.
       42*01/03/83 by Lindsey Spratt:  Fixed to set p_continuation and to update
       43*	  remainder_length_in_bits and p_remainder_length_in_bits.   Changed
       44*	  to use the info_header entry in cm_allocate_ci to get a current
       45*	  and valid value for the bci_header.
       46*01/05/83 by Lindsey Spratt:  Fixed to set the continued_datum_is_present flag.
       47*01/05/83 by Matthew Pierret: Changed to make rightmost datum (the first datum
       48*            stored in this routine) pad the last byte to make all datums to the
       49*            left be an integral number of bytes.
       50*02/03/83 by Matthew Pierret: Upgraded to CM_INFO_VERSION_2. Added version check
       51*03/09/83 by Lindsey Spratt:  Fixed use of based_bit_array, was too low by 1.
       52*	  Moved setting of dclib to MDCLIB into case for datum_count ^=
       53*	  1 or p_continuation ^= "0"b.  Fixed to initialize datum_slot.flags
       54*	  to "0"b.
       55*04/04/83 by Lindsey L. Spratt:  Fixed to check p_code after calling
       56*            cm_put_datum_in_pool$*.  Fixed to initialize the datum_slot for
       57*            each datum.
       58*04/05/83 by Lindsey L. Spratt:  Changed to explicitly calculate the
       59*            datum_contents_ptr using the addbitno builtin instead of the addr
       60*            builtin and a based_bit_array.
       61*09/24/84 by Matthew Pierret: To add ERROR_RETURN and LIMIT, and remove call-
       62*            by-value to CHECK_VERSION.
       63**/
       64 
       65 /* format: style2,ind3 */
       66 
       67 cm_put_overlength_tail:
       68    proc (p_cm_info_ptr, p_element_ptr, p_remainder_length_in_bits, p_continuation_datum_id, p_code);
       69 
       70 
       71 /* START OF DECLARATIONS */
       72 /* Parameter */
       73 
       74       dcl	    p_cm_info_ptr	       ptr parameter;
       75       dcl	    p_element_ptr	       ptr parameter;
       76       dcl	    p_remainder_length_in_bits
       77 			       fixed bin (35) parameter;
       78       dcl	    p_continuation_datum_id
       79 			       bit (36) aligned parameter;
       80       dcl	    p_code	       fixed bin (35) parameter;
       81 
       82 /* Automatic */
       83 
       84       dcl	    1 my_bci_header	       aligned like bci_header;
       85       dcl	    1 my_datum_slot	       aligned like datum_slot;
       86       dcl	    code		       fixed bin (35);
       87       dcl	    control_interval_id    fixed bin (24) uns init (0);
       88       dcl	    datum_count	       fixed bin (17) init (0);
       89       dcl	    (remainder_length_in_bits, datum_contents_length_in_bits, number_of_bits_in_last_byte)
       90 			       fixed bin (35) init (0);
       91       dcl	    datum_contents_ptr     ptr init (null);
       92 
       93 /* Based */
       94 /* Builtin */
       95 
       96       dcl	    (addbitno, addr, mod, null, unspec)
       97 			       builtin;
       98 
       99 /*	 Constant */
      100 
      101       dcl	    myname	       init ("cm_put_overlength_tail") char (32) varying internal static options (constant);
      102       dcl	    BITS_PER_BYTE	       init (9) fixed bin internal static options (constant);
      103       dcl	    LIMIT		       init (131071) fixed bin (17) internal static options (constant);
      104 
      105 /* Entry */
      106 
      107       dcl	    sub_err_	       entry () options (variable);
      108 
      109 /* External */
      110 
      111       dcl	    dm_error_$programming_error
      112 			       ext fixed bin (35);
      113       dcl	    error_table_$unimplemented_version
      114 			       ext fixed bin (35);
      115 
      116 /* END OF DECLARATIONS */
      117 
      118       p_code, code = 0;
      119       cm_info_ptr = p_cm_info_ptr;
      120       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      121 
      122       bci_header_ptr = addr (my_bci_header);
      123       datum_slot_ptr = addr (my_datum_slot);
      124 
      125 
      126       remainder_length_in_bits = p_remainder_length_in_bits;
      127 
      128       do datum_count = 1 to LIMIT
      129 	 while (remainder_length_in_bits > MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS - BITS_PER_BYTE);
      130 
      131          call cm_allocate_ci$info_header (cm_info_ptr, control_interval_id, bci_header_ptr, code);
      132          if code ^= 0
      133          then call ERROR_RETURN (code);
      134 
      135          bci_header.number_of_datums = 1;
      136          bci_header.flags.continuation_datum_is_present = "1"b;
      137 
      138          element_id.control_interval_id = control_interval_id;
      139          element_id.index = 1;
      140 
      141          unspec (datum_slot) = ""b;
      142          datum_slot.is_continuation = "1"b;
      143 
      144          if datum_count = 1 & p_continuation_datum_id = "0"b
      145          then
      146 	  do;
      147 	     number_of_bits_in_last_byte = mod (remainder_length_in_bits, BITS_PER_BYTE);
      148 	     if number_of_bits_in_last_byte = 0
      149 	     then number_of_bits_in_last_byte = BITS_PER_BYTE;
      150 	     datum_contents_length_in_bits =
      151 		MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS - BITS_PER_BYTE + number_of_bits_in_last_byte;
      152 	     datum_contents_ptr = addbitno (p_element_ptr, remainder_length_in_bits - datum_contents_length_in_bits);
      153 	     call cm_put_datum_in_pool (cm_info.file_oid, element_id_string, datum_contents_ptr,
      154 		datum_contents_length_in_bits, datum_slot_ptr, bci_header_ptr, code);
      155 	     if code ^= 0
      156 	     then call ERROR_RETURN (code);
      157 	  end;
      158          else
      159 	  do;
      160 	     datum_contents_length_in_bits = MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS;
      161 	     datum_contents_ptr = addbitno (p_element_ptr, remainder_length_in_bits - datum_contents_length_in_bits);
      162 	     call cm_put_datum_in_pool$continued (cm_info.file_oid, element_id_string, datum_contents_ptr,
      163 		datum_contents_length_in_bits, datum_slot_ptr, bci_header_ptr, -1, p_continuation_datum_id, code);
      164 	     if code ^= 0
      165 	     then call ERROR_RETURN (code);
      166 	  end;
      167          p_continuation_datum_id = element_id_string;
      168          remainder_length_in_bits = remainder_length_in_bits - datum_contents_length_in_bits;
      169 
      170       end;
      171       if datum_count > LIMIT
      172       then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null (), 0,
      173 	      "^/The program was looping infinitely.");
      174 
      175       p_remainder_length_in_bits = remainder_length_in_bits;
      176 
      177 MAIN_RETURN:
      178       return;
      179 
      180 ERROR_RETURN:
      181    proc (er_p_code);
      182 
      183       dcl	    er_p_code	       fixed bin (35);
      184 
      185       p_code = er_p_code;
      186       go to MAIN_RETURN;
      187 
      188    end ERROR_RETURN;
      189 
      190 CHECK_VERSION:
      191    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      192 
      193       dcl	    cv_p_structure_name    char (*);
      194       dcl	    cv_p_given_version     char (8) aligned;
      195       dcl	    cv_p_correct_version   char (8) aligned;
      196 
      197       if cv_p_given_version ^= cv_p_correct_version
      198       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      199 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", cv_p_correct_version,
      200 	      cv_p_structure_name, cv_p_given_version);
      201       else return;
      202 
      203    end CHECK_VERSION;
      204 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      205 
      206 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        The collection_manager_ manages the structure of the addressable
  2     6*   portion of a control interval.  The addressable portion is that portion of
  2     7*   a control interval which the file_manager_ will allow the
  2     8*   collection_manager_ to address.  In this description control interval will
  2     9*   be used to mean the addressable portion of a control interval.
  2    10*   
  2    11*        A control interval is divided into four parts: the header, the datum
  2    12*   position table (also known as the slot table or slots), un-used space and
  2    13*   used space.  The beginning of the header is at offset 0, and the end of the
  2    14*   used space is at the end of the control interval (curently offset 4072).
  2    15*   Pictoriarly, a control interval is structured as follows:
  2    16*   
  2    17*   ----------------------------------------------------------------------
  2    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  2    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  2    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  2    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  2    22*   ----------------------------------------------------------------------
  2    23*                                           ^ ^    ^      ^    ^  ^   ^
  2    24*                                           | |    |      |    |  |   |
  2    25*                                           | |...........|.......|...|
  2    26*                        start of used space|      |           |      |
  2    27*                                                  |           |  each|
  2    28*                                          scattered free space|  is a used
  2    29*                                                                 datum
  2    30*   
  2    31*      The basic_control_interval structure describes the header
  2    32*   (basic_control_interval.header, bci_header) and the slots
  2    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  2    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  2    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  2    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  2    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  2    38**/
  2    39 
  2    40 /* HISTORY:
  2    41*Written by Matthew Pierret, 02/07/82.
  2    42*Modified:
  2    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  2    44*            and its sub-structures.
  2    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  2    46*            basic_ci_header to bci_header. Added previous_control_interval.
  2    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  2    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  2    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  2    50*            is not used.
  2    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  2    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  2    53**/
  2    54 
  2    55 /* format: style2 */
  2    56      dcl	   1 basic_control_interval
  2    57 			      aligned based (basic_control_interval_ptr),
  2    58 	     2 header	      like bci_header,
  2    59 	     2 datum_position_table
  2    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  2    61 
  2    62 
  2    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  2    64 	     2 layout_type	      char (4) aligned,
  2    65 	     2 collection_id      bit (36) aligned,
  2    66 	     2 next_control_interval
  2    67 			      fixed bin (24) uns unal,
  2    68 	     2 previous_control_interval
  2    69 			      fixed bin (24) uns unal,
  2    70 	     2 flags	      unal,
  2    71 	       3 continuation_datum_is_present
  2    72 			      bit (1) unal,
  2    73 	       3 free_slot_is_present
  2    74 			      bit (1) unal,
  2    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  2    76 	     2 scattered_free_space
  2    77 			      fixed bin (17) unal,
  2    78 	     2 start_of_used_space
  2    79 			      fixed bin (17) unal,
  2    80 	     2 number_of_datums   fixed bin (17) unal;
  2    81 
  2    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  2    83 	     2 flags	      unal,
  2    84 	       3 special_format_datum
  2    85 			      bit (1) unal,		/* reserved */
  2    86 	       3 is_continued     bit (1) unal,
  2    87 	       3 is_continuation  bit (1) unal,
  2    88 	       3 mbz	      bit (1) unal,		/* reserved */
  2    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  2    90 	     2 length_in_bits     fixed bin (17) uns unal;
  2    91 
  2    92      dcl	   basic_control_interval_ptr
  2    93 			      ptr;
  2    94      dcl	   bci_header_ptr	      ptr;
  2    95      dcl	   datum_slot_ptr	      ptr;
  2    96 
  2    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  2    98 
  2    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      207 
      208 
  3     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        Contains constants describing the extents of datums and datum
  3     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  3     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  3     7*   datum that can be stored in a control interval, allowing for the largest
  3     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  3     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    10*   is the smallest length in bits which requires 
  3    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  3    12**/
  3    13 
  3    14 /*
  3    15*HISTORY:
  3    16*Written by Matthew Pierret, 02/07/82.
  3    17*Modified:
  3    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  3    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  3    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  3    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  3    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  3    23*            DESCRIPTION section.
  3    24**/
  3    25 
  3    26 /* format: style2,ind3,ll79 */
  3    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  3    28 			      fixed bin init (8) internal static
  3    29 			      options (constant);
  3    30 
  3    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  3    32 			      fixed bin init (72) internal static
  3    33 			      options (constant);
  3    34 
  3    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  3    36 			      init (4) fixed bin int static
  3    37 			      options (constant);
  3    38 
  3    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  3    40 			      init (36) fixed bin int static
  3    41 			      options (constant);
  3    42 
  3    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    44 			      init (36360) fixed bin (35) internal
  3    45 			      static options (constant);
  3    46 
  3    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  3    48 			      init (4040) fixed bin (35) internal
  3    49 			      static options (constant);
  3    50 
  3    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  3    52 			      init (36352) fixed bin (35) internal
  3    53 			      static options (constant);
  3    54 
  3    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      209 
      210 
  4     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*   Contains entry declarations of internally available collection_manager_
  4     6*   entries.  Entries which are only available via the collection_manager_
  4     7*   transfer vector are not included here, but are declared instead in 
  4     8*   dm_collmgr_entry_dcls.incl.pl1.
  4     9**/
  4    10 
  4    11 /* HISTORY:
  4    12*Written by Mathew Pierret, 04/01/82.
  4    13*Modified:
  4    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  4    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  4    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  4    17*            Added cm_get_element$info*, $header*.  The former is used when
  4    18*            the caller has a cm_info structure already; the latter is used to
  4    19*            get collection headers.
  4    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  4    21*            Added cm_allocate_element$info.
  4    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  4    23*            calling sequence for returning free space.
  4    24*            Added cm_free_cn_datum("" $header).
  4    25*01/07/83 by Matthew Pierret:  Added:
  4    26*            cm_allocate_element$buffered("" _info);
  4    27*            cm_put_element$buffered("" _info);
  4    28*            cm_put_datum_in_place$buffered("" _continued);
  4    29*            cm_put_datum_in_pool$buffered("" _continued);
  4    30*            cm_compact$buffered.
  4    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  4    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  4    33*            Added cm_opening_info$get_storage_record.
  4    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  4    35*            id of the previous datum.
  4    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  4    37*            which is for the number of slots after allocation.
  4    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  4    39*            header header_return_slot).
  4    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  4    41*            Added cm_get_element$bypass_info.
  4    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  4    43*            cm_free_opening_info.
  4    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  4    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  4    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  4    47*            return flags indicating if a datum fits in the ci and the pool.
  4    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  4    49*            returned the new value of bci_header.free_slot_is_present.
  4    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  4    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  4    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  4    53*            calling sequence as other cm_get_element entries.
  4    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  4    55*            and cm_allocate_element to cm_put.
  4    56*            Switched the element_length/element_ptr parameter pair to be
  4    57*            element_ptr/element_length in cm_modify and cm_put.
  4    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  4    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  4    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  4    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  4    62*            Removed cm_find_free_space. Commented out un-used entries.
  4    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  4    64*            Re-named free element and free datum entries to use delete instead
  4    65*            of free, and cm_recursive_put to cm_recursive_modify.
  4    66*            Removed cm_get_element$bypass_info.
  4    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  4    68*            that cm_modify$buffered uses it.
  4    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  4    70**/
  4    71 
  4    72 /* format: style2,ind3 */
  4    73 
  4    74 
  4    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  4    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  4    77      dcl	   cm_allocate_ci$info_header
  4    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  4    79 
  4    80 
  4    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  4    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  4    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  4    84      dcl	   cm_compact$buffered_replacement
  4    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  4    86 
  4    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  4    88 
  4    89      dcl	   cm_delete_cn_datum$header
  4    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  4    91 
  4    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  4    93 			      fixed bin (35));
  4    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  4    95 
  4    96      dcl	   cm_determine_free_space$all
  4    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  4    98      dcl	   cm_determine_free_space$effective
  4    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  4   100 			      fixed bin (35));
  4   101      dcl	   cm_determine_free_space$does_new_datum_fit
  4   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  4   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  4   104 
  4   105 /**** Not yet used *********************************************************
  4   106*     dcl	   cm_determine_free_space$does_replacement_fit
  4   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  4   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  4   109*************************************************************************** */
  4   110 
  4   111      dcl	   cm_find_ci_to_alloc_datum
  4   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  4   113 			      fixed bin (24) uns, fixed bin (35));
  4   114 
  4   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  4   116 			      bit (1) aligned, fixed bin (35));
  4   117 
  4   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  4   119      dcl	   cm_free_ci$raw_return_prev_next
  4   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  4   121 			      fixed bin (24) uns, fixed bin (35));
  4   122      dcl	   cm_free_ci$trace_thread_modifications_on
  4   123 			      entry ();
  4   124      dcl	   cm_free_ci$trace_thread_modifications_off
  4   125 			      entry ();
  4   126 
  4   127 
  4   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  4   129 
  4   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  4   131      dcl	   cm_get_bci_header$exclusive
  4   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  4   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  4   134 
  4   135 /**** Not yet used ********************************************************
  4   136*     dcl	   cm_get_bci_header$slot_exclusive
  4   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  4   138*************************************************************************** */
  4   139 
  4   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  4   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  4   142      dcl	   cm_get_element$exclusive
  4   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  4   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  4   145 
  4   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  4   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  4   148 			      fixed bin (35), fixed bin (35));
  4   149 
  4   150 /**** Not yet used ********************************************************
  4   151*     dcl	   cm_get_element_portion$exclusive
  4   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  4   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  4   154*			      fixed bin (35), fixed bin (35));
  4   155*************************************************************************** */
  4   156 
  4   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  4   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  4   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  4   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  4   161 
  4   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   163 			      fixed bin (35), fixed bin (35));
  4   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   165 			      fixed bin (35), fixed bin (35));
  4   166 
  4   167 /******* Not yet used *****************************************************
  4   168*     dcl	   cm_modify$buffered_info
  4   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  4   170*			      fixed bin (35));
  4   171*****************************************************************************/
  4   172 
  4   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  4   174      dcl	   cm_modify$unprotected_info
  4   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  4   176 
  4   177 
  4   178 /******* Not yet used *****************************************************
  4   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  4   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  4   181*****************************************************************************/
  4   182 
  4   183 
  4   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  4   185      dcl	   cm_opening_info$get_storage_record
  4   186 			      entry (ptr, fixed bin (35));
  4   187      dcl	   cm_opening_info$full_get
  4   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  4   189      dcl	   cm_opening_info$opening_table_ptr
  4   190 			      entry () returns (ptr);
  4   191 
  4   192      dcl	   cm_postcommit_increment
  4   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  4   194 
  4   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   196 			      fixed bin (35), fixed bin (35));
  4   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   198 			      fixed bin (35), fixed bin (35));
  4   199 
  4   200 /******* Not yet used *****************************************************
  4   201*     dcl	   cm_put$buffered_info
  4   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  4   203*			      fixed bin (35));
  4   204*****************************************************************************/
  4   205 
  4   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  4   207 
  4   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  4   209 			      fixed bin (35));
  4   210 
  4   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  4   212 
  4   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  4   214 			      fixed bin (35));
  4   215      dcl	   cm_put_datum_in_place$buffered
  4   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  4   217      dcl	   cm_put_datum_in_place$buffered_continued
  4   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  4   219 			      fixed bin (35));
  4   220      dcl	   cm_put_datum_in_place$continued
  4   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  4   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  4   223 
  4   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  4   225 			      fixed bin (35));
  4   226      dcl	   cm_put_datum_in_pool$buffered
  4   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  4   228      dcl	   cm_put_datum_in_pool$buffered_continued
  4   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  4   230 			      fixed bin (35));
  4   231      dcl	   cm_put_datum_in_pool$continued
  4   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  4   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  4   234 
  4   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  4   236 			      fixed bin (35));
  4   237      dcl	   cm_put_ordered_element$buffered
  4   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  4   239 			      fixed bin (35));
  4   240 
  4   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  4   242 
  4   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  4   244 			      fixed bin (35));
  4   245 
  4   246 
  4   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  4   248 			      entry ();
  4   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  4   250 			      entry ();
  4   251 
  4   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      211 
      212 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      213 
      214 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      215 
      216 
      217    end cm_put_overlength_tail;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.8  cm_put_overlength_tail.pl1        >spec>on>7192.pbf-04/04/85>cm_put_overlength_tail.pl1
205          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
207          2    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
209          3    01/07/85  0858.2  dm_cm_datum_constants.incl.pl1    >ldd>include>dm_cm_datum_constants.incl.pl1
211          4    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
213          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
215          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000020 constant        bit(36)                  initial dcl 6-7 set ref 171* 197*
BITS_PER_BYTE                   000566 constant        fixed bin(17,0)          initial dcl 102 ref 128 147 148 150
CM_INFO_VERSION_2               000000 constant        char(8)                  initial dcl 1-48 set ref 120*
LIMIT                                  constant        fixed bin(17,0)          initial dcl 103 ref 128 171
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  constant        fixed bin(35,0)          initial dcl 3-43 ref 128 150 160
addbitno                                               builtin function         dcl 96 ref 152 161
addr                                                   builtin function         dcl 96 ref 122 123 138 139
bci_header                             based           structure                level 1 dcl 2-63
bci_header_ptr                  000120 automatic       pointer                  dcl 2-94 set ref 122* 131* 135 136 153* 162*
cm_allocate_ci$info_header      000016 constant        entry                    external dcl 4-77 ref 131
cm_info                                based           structure                level 1 dcl 1-37
cm_info_ptr                     000116 automatic       pointer                  initial dcl 1-47 set ref 119* 120 131* 153 162 1-47*
cm_put_datum_in_pool            000020 constant        entry                    external dcl 4-224 ref 153
cm_put_datum_in_pool$continued  000022 constant        entry                    external dcl 4-231 ref 162
code                            000106 automatic       fixed bin(35,0)          dcl 86 set ref 118* 131* 132 132* 153* 155 155* 162*
                                                                                  164 164*
continuation_datum_is_present
                          3(12)        based           bit(1)                   level 3 packed unaligned dcl 2-63 set ref 136*
control_interval_id             000107 automatic       fixed bin(24,0)          initial unsigned dcl 87 in procedure
                                                                                  "cm_put_overlength_tail" set ref 87* 131* 138
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 5-32 in procedure
                                                                                  "cm_put_overlength_tail" set ref 138*
cv_p_correct_version                   parameter       char(8)                  dcl 195 set ref 190 197 197*
cv_p_given_version                     parameter       char(8)                  dcl 194 set ref 190 197 197*
cv_p_structure_name                    parameter       char                     unaligned dcl 193 set ref 190 197*
datum_contents_length_in_bits   000112 automatic       fixed bin(35,0)          initial dcl 89 set ref 89* 150* 152 153* 160* 161
                                                                                  162* 168
datum_contents_ptr              000114 automatic       pointer                  initial dcl 91 set ref 91* 152* 153* 161* 162*
datum_count                     000110 automatic       fixed bin(17,0)          initial dcl 88 set ref 88* 128* 144* 171
datum_slot                             based           structure                level 1 dcl 2-82 set ref 141*
datum_slot_ptr                  000122 automatic       pointer                  dcl 2-95 set ref 123* 141 142 153* 162*
dm_error_$programming_error     000012 external static fixed bin(35,0)          dcl 111 set ref 171*
element_id                             based           structure                level 1 dcl 5-32
element_id_string               000124 automatic       bit(36)                  dcl 5-30 set ref 138 139 153* 162* 167
er_p_code                              parameter       fixed bin(35,0)          dcl 183 ref 180 185
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 113 set ref 197*
file_oid                  3            based           bit(36)                  initial level 2 dcl 1-37 set ref 153* 162*
flags                     3(12)        based           structure                level 2 in structure "bci_header" packed unaligned
                                                                                  dcl 2-63 in procedure "cm_put_overlength_tail"
flags                                  based           structure                level 2 in structure "datum_slot" packed unaligned
                                                                                  dcl 2-82 in procedure "cm_put_overlength_tail"
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 5-32 set ref
                                                                                  139*
is_continuation           0(02)        based           bit(1)                   level 3 packed unaligned dcl 2-82 set ref 142*
mod                                                    builtin function         dcl 96 ref 147
my_bci_header                   000100 automatic       structure                level 1 dcl 84 set ref 122
my_datum_slot                   000105 automatic       structure                level 1 dcl 85 set ref 123
myname                          000002 constant        varying char(32)         initial dcl 101 set ref 171* 197*
null                                                   builtin function         dcl 96 ref 91 171 171 1-47 197 197
number_of_bits_in_last_byte     000113 automatic       fixed bin(35,0)          initial dcl 89 set ref 89* 147* 148 148* 150
number_of_datums          4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-63 set ref 135*
p_cm_info_ptr                          parameter       pointer                  dcl 74 ref 67 119
p_code                                 parameter       fixed bin(35,0)          dcl 80 set ref 67 118* 185*
p_continuation_datum_id                parameter       bit(36)                  dcl 78 set ref 67 144 162* 167*
p_element_ptr                          parameter       pointer                  dcl 75 ref 67 152 161
p_remainder_length_in_bits             parameter       fixed bin(35,0)          dcl 76 set ref 67 126 175*
remainder_length_in_bits        000111 automatic       fixed bin(35,0)          initial dcl 89 set ref 89* 126* 128 147 152 161 168*
                                                                                  168 175
sub_err_                        000010 constant        entry                    external dcl 107 ref 171 197
unspec                                                 builtin function         dcl 96 set ref 141*
version                                based           char(8)                  level 2 dcl 1-37 set ref 120*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 2-97
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 3-39
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      internal static fixed bin(17,0)          initial dcl 3-35
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 3-31
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 3-27
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 3-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 3-51
basic_control_interval                 based           structure                level 1 dcl 2-56
basic_control_interval_ptr             automatic       pointer                  dcl 2-92
cm_allocate_ci                  000000 constant        entry                    external dcl 4-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 4-76
cm_compact                      000000 constant        entry                    external dcl 4-81
cm_compact$buffered             000000 constant        entry                    external dcl 4-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 4-84
cm_compact$replacement          000000 constant        entry                    external dcl 4-83
cm_delete                       000000 constant        entry                    external dcl 4-92
cm_delete$info                  000000 constant        entry                    external dcl 4-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 4-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 4-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 4-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 4-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 4-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 4-111
cm_find_free_slot               000000 constant        entry                    external dcl 4-115
cm_free_ci$info                 000000 constant        entry                    external dcl 4-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 4-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 4-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 4-122
cm_free_opening_info            000000 constant        entry                    external dcl 4-128
cm_get_bci_header               000000 constant        entry                    external dcl 4-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 4-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 4-133
cm_get_element                  000000 constant        entry                    external dcl 4-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 4-142
cm_get_element_portion          000000 constant        entry                    external dcl 4-146
cm_get_id$id                    000000 constant        entry                    external dcl 4-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 4-159
cm_modify                       000000 constant        entry                    external dcl 4-162
cm_modify$buffered              000000 constant        entry                    external dcl 4-164
cm_modify$info                  000000 constant        entry                    external dcl 4-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 4-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 4-187
cm_opening_info$get             000000 constant        entry                    external dcl 4-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 4-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 4-189
cm_postcommit_increment         000000 constant        entry                    external dcl 4-192
cm_put                          000000 constant        entry                    external dcl 4-195
cm_put$buffered                 000000 constant        entry                    external dcl 4-197
cm_put$info                     000000 constant        entry                    external dcl 4-206
cm_put_basic_element            000000 constant        entry                    external dcl 4-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 4-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 4-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 4-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 4-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 4-220
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 4-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 4-228
cm_put_ordered_element          000000 constant        entry                    external dcl 4-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 4-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 4-241
cm_recursive_modify             000000 constant        entry                    external dcl 4-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 4-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 4-247

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000456 constant        entry                    internal dcl 190 ref 120
ERROR_RETURN                    000450 constant        entry                    internal dcl 180 ref 132 155 164
MAIN_RETURN                     000447 constant        label                    dcl 177 ref 186
cm_put_overlength_tail          000070 constant        entry                    external dcl 67

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       706         732     567         716
Length      1240     567        24         271     116           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_put_overlength_tail              222 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_put_overlength_tail.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_put_overlength_tail.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_put_overlength_tail   000100 my_bci_header               cm_put_overlength_tail
                         000105 my_datum_slot               cm_put_overlength_tail
                         000106 code                        cm_put_overlength_tail
                         000107 control_interval_id         cm_put_overlength_tail
                         000110 datum_count                 cm_put_overlength_tail
                         000111 remainder_length_in_bits    cm_put_overlength_tail
                         000112 datum_contents_length_in_bits
                                                            cm_put_overlength_tail
                         000113 number_of_bits_in_last_byte cm_put_overlength_tail
                         000114 datum_contents_ptr          cm_put_overlength_tail
                         000116 cm_info_ptr                 cm_put_overlength_tail
                         000120 bci_header_ptr              cm_put_overlength_tail
                         000122 datum_slot_ptr              cm_put_overlength_tail
                         000124 element_id_string           cm_put_overlength_tail

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_allocate_ci$info_header    cm_put_datum_in_pool          cm_put_datum_in_pool$continued
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     67 000063        87 000075        88 000076        89 000077        91 000102    1   47 000104       118 000105
    119 000110       120 000113       122 000134       123 000136       126 000140       128 000143       131 000165
    132 000202       135 000206       136 000211       138 000213       139 000216       141 000220       142 000221
    144 000223       147 000231       148 000235       150 000240       152 000247       153 000260       155 000304
    157 000310       160 000311       161 000313       162 000325       164 000357       167 000363       168 000366
    170 000374       171 000376       175 000444       177 000447       180 000450       185 000452       186 000455
    190 000456       197 000467       201 000560       203 000561


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
