	COMPILATION LISTING OF SEGMENT mu_concurrency_control
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1124.05_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 mu_concurrency_control: procedure (); return;		/* not a valid entry */
       20 
       21 
       22 /* HISTORY
       23*
       24*   Originally written by Friesen in august 1977
       25*   Modified by oris friesen in Aug. 1978 for new version data bases
       26*   Modified by M. Pierret 17 April 1980 to remove priority_ofs and wakeup_ofs.
       27*   (now dbc.obsolete)
       28*
       29*   80-12-09 Jim Gray : completely rewritten to
       30*   1) propoerly init the dbc structure including pad areas.
       31*   2) change the interface into an abstract data type
       32*   with 4 entries for use by AMDB, CMDB, DMDBS, and QMDB/OPEN.
       33*   3) As part of the above change, implement r-u scope mode
       34*   to r-s-m-d scope mode conversion.
       35*   4) change the module name from mu_init_dbc to mu_concurrency_control
       36*   5) provide more detailed documentation of module and it's enviornment
       37*
       38*   80-12-24 Jim Gray : modified get_latest_dbc routine to return access violation
       39*   message instead of version problem message, when null access on db control segment.
       40*
       41*   80-12-24 Jim Gray : modified re_init_dbc to give detailed sub_err_ message
       42*   if user does not have "w" access to control segment.
       43*
       44*   81-01-15 Jim Gray : modified to fix loophole, where user could have two
       45*   segments, one named dbc, the other db.control, or one segment with both names,
       46*   and thus attempt to run both MR8 and MR9 mrds on the same database concurrenty,
       47*   but without any real concurrent access protection.
       48*
       49*   81-01-16 Jim Gray : moved access violation check to get_any_dbc so other
       50*   than open gets sub_err_ details. Also added no control segment found
       51*   sub_err_ to that routine, to compliment, 2 control segment sub_err_
       52*   already there done as part of the last change fixing the loophole.
       53*
       54*   81-01-16 Jim Gray : changed logic for handling bad bit count of control
       55*   segment upon open. Now a bad version or a bit count less than the minimum strucutre
       56*   size causes a message indicating that amdb -rs must be done on the db before using.
       57*
       58*   81-01-27 Jim Gray : added setting of needed access for DBA types, if get access violation.
       59*
       60*   83-06-13 Davids: Cleaned up declarations.
       61**/
       62 
       63 /* DESCRIPTION:
       64*
       65*   this routine handles initialization
       66*   of the database control segment for several different needs.
       67*   There are four entries:
       68*   reset_control_segment is called by adjust_mrds_db when -reset is specified,
       69*   in order to completely re-init the dbc structures,
       70*   and possibly update the version of these, plus change the segments name.
       71*   This is a DBA priviledged action.
       72*   create_control_segment is called by create_mrds_db to create the
       73*   control segment under the database at database creation time.
       74*   open_control_segment is called by quiesce_mrds_db and dsl_$open, to get
       75*   a pointer to the dbc, if it is the latest version dbc,
       76*   otherwise a remedial action message is issued.
       77*   get_control_segment is called by display_mrds_db_status to get any version
       78*   dbc segment pointer, looking for latest version first,
       79*   in order to be able to display it's info.
       80*
       81**/
       82 
       83 /* PARAMETERS:
       84*
       85*   db_path - - (input) char(168), the absolute pathname of the database.
       86*
       87*   dbc_ptr_param - - (input/output) ptr, this is an output parameter for all entries
       88*   except reset_control_segment, in which case it is an input parameter.
       89*   This is a pointer the database control segment.
       90*
       91*   bit_count - - (output) fixed bin(24), the bit count of the database control segment.
       92*
       93*   icode - - (output) fixed bin(35), the error status encoding,
       94*   0 unless an error occured.
       95*
       96**/
       97 
       98 create_control_segment: entry (db_path, dbc_ptr_param, bit_count, icode);
       99 
      100 /* entry to create the database control segment */
      101 
      102 	call make_control_seg ();
      103 	dbc_ptr_param = dbc_ptr;
      104 	return;
      105 
      106 
      107 get_control_segment: entry (db_path, dbc_ptr_param, bit_count, icode);
      108 
      109 /* entry to get a pointer to the database control segment,
      110*   using any of the known names of versions for that segment,
      111*   latest version names are tried first, only display or conversion routines should use this entry */
      112 
      113 	call get_any_dbc ();
      114 	dbc_ptr_param = dbc_ptr;
      115 	return;
      116 
      117 
      118 open_control_segment: entry (db_path, dbc_ptr_param, bit_count, icode);
      119 
      120 /* entry to look only for the  latest version segment
      121*   name for the datbase control segment. If not found, a message
      122*   is issued, indicating AMDB -rs must be done to update the dbc version.
      123*   This is the normal entry point to be used by any routine requiring the dbc ptr */
      124 
      125 	call get_latest_dbc ();
      126 	dbc_ptr_param = dbc_ptr;
      127 	return;
      128 
      129 
      130 reset_control_segment: entry (db_path, dbc_ptr_param, bit_count, icode);
      131 
      132 /* entry to re-initialize the dbc. This may involve changing versions
      133*   of the dbc structures and the control segment name. */
      134 
      135 	dbc_ptr = dbc_ptr_param;
      136 	call re_init_dbc ();
      137 	return;
      138 
      139 make_control_seg: procedure ();
      140 
      141 /* this routine initially creates the database control segment
      142*   in the  fashion determined by the latest version */
      143 
      144 	call hcs_$make_seg (db_path, rtrim (mrds_data_$control_segment_name), "", 10, dbc_ptr, icode);
      145 	if dbc_ptr = null () then ;
      146 	else do;
      147 		icode = 0;
      148 
      149 		call init_dbc ();			/* fill in the dbc structures */
      150 	     end;
      151 
      152      end;
      153 
      154 re_init_dbc: procedure ();
      155 
      156 /* this routine re-initializes the database control segment
      157*   structures to the latest versions initial  values. */
      158 
      159 
      160 /* zero out the control segment, then set it's bit count to 0 */
      161 
      162 	call hcs_$truncate_seg (dbc_ptr, 0, icode);
      163 	if icode = error_table_$moderr then do;
      164 		entryname = mrds_data_$control_segment_name; /* default, in case can't get real name being used */
      165 		call hcs_$fs_get_path_name (dbc_ptr, dir_name, ldn, entryname, discard);
      166 		call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^a^a^a^a",
      167 		     "Insufficient access to re-initialize the database control segment """, rtrim (db_path),
      168 		     ">", rtrim (entryname), """.");
      169 	     end;
      170 	else if icode = 0 then do;
      171 		call hcs_$set_bc_seg (dbc_ptr, 0, icode);
      172 
      173 		if icode = 0 then do;
      174 
      175 /* initialize dbc values */
      176 
      177 			call init_dbc ();
      178 
      179 			if icode = 0 then do;
      180 
      181 
      182 /* change the name of the database control segment, so that r-u scope mode
      183*   users will not concurrently be using a r-s-m-d scope mode version dbc. */
      184 
      185 				call hcs_$chname_seg (dbc_ptr, "dbc", rtrim (mrds_data_$control_segment_name), icode);
      186 				if icode = error_table_$segnamedup then
      187 				     icode = 0;	/* ignore error, if name already changed */
      188 			     end;
      189 
      190 		     end;
      191 
      192 	     end;
      193      end;
      194 
      195 init_dbc: procedure ();
      196 
      197 /* this routine sets the inital values in the dbc structure,
      198*   and then sets the control segments bit count */
      199 
      200 	dbc.version = VERSION_NBR;
      201 	dbc.dtd_mrds = 0;				/* has never been dumped -- is a new data base */
      202 	dbc.flags = OFF;
      203 	dbc.quiesce_lock = OFF;
      204 	dbc.wakeup_waiters = 0;
      205 	dbc.user_counts = 0;
      206 	dbc.open_lock = OFF;
      207 	dbc.scope_lock = OFF;
      208 	dbc.sa_size = sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1;
      209 	dbc.pad2 = OFF;
      210 	dbc.offsets = NULL_OFS;
      211 	dbc.offsets.obsolete = OFF;
      212 	dbc.pad3 = OFF;
      213 	dbc.static_area = empty ();
      214 
      215 	bit_count = 36 * fixed (rel (addr (dbc.static_area)));
      216 	call hcs_$set_bc_seg (dbc_ptr, bit_count, icode);
      217 
      218      end;
      219 
      220 get_latest_dbc: procedure ();
      221 
      222 /* this routine attempts to get a pointer to the
      223*   latest version database control segment.
      224*   If an unsupported version is detected, an error is issued.
      225*   If an older or bad version is detected, a message is issued
      226*   that indicates that AMDB -rs must be done to update the version. */
      227 
      228 	old_version, cant_get_version, bad_version = OFF;
      229 
      230 	call get_any_dbc ();
      231 
      232 	if icode = mrds_error_$version_not_supported | dbc_ptr = null () then ;
      233 	else do;
      234 
      235 		call hcs_$fs_get_path_name (dbc_ptr, dir_name, ldn, entryname, icode);
      236 
      237 		if icode ^= 0 then
      238 		     cant_get_version = ON;
      239 		else if entryname = "dbc" then
      240 		     old_version = ON;
      241 		else if dbc.version < 4 | dbc.version > 5 |
      242 			bit_count < 36 * fixed (rel (addr (dbc.static_area))) then /* minimum allowable bit count */
      243 		     bad_version = ON;
      244 		else if dbc.version = 4 then
      245 		     old_version = ON;
      246 
      247 		if cant_get_version then do;
      248 
      249 /* unable to get segment name, to determine if this is a proper
      250*   new version control segment for open to accept */
      251 
      252 			call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^p^a^a^a",
      253 			     "Unable to get the segment name for the pointer """, dbc_ptr,
      254 			     """ to the database control segment under the database """,
      255 			     db_path, """.");
      256 
      257 		     end;
      258 		else if bad_version then do;
      259 
      260 /* unknown dbc version, give up */
      261 
      262 			icode = mrds_error_$version_not_supported;
      263 			call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a ^d^a ^d^/^a ^a ^a",
      264 			     "The database control segment has an unknown version =", dbc.version,
      265 			     ", or a bad bit count =", bit_count,
      266 			     """adjust_mrds_db", db_path, "-reset"" must be run before it can be used.");
      267 		     end;
      268 		else if old_version then do;
      269 			debug_sw = OFF;
      270 			if ^debug_sw then do;
      271 
      272 /* old version dbc's must be updated to the latest version
      273*   before we can let the suer set any scopes or open */
      274 
      275 				icode = mrds_error_$version_not_supported;
      276 				call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^/^a^/^a ^a ^a",
      277 				     "The version of the control segment has changed,",
      278 				     "to support r-m-a(s)-d instead of r-u scope modes.",
      279 				     """adjust_mrds_db", db_path,
      280 				     "-reset"" must be run before it can be used.");
      281 			     end;
      282 			else do;			/* unused test code for auto conversion of dbc version */
      283 
      284 /* this code is for test purposes only and is not mormally executed.
      285*   it causes r-u dbc's to be converted to r-s-m-d dbc's.
      286*   concurrent r-u and r-s-m-d users can cause the dbc to become incosistent */
      287 
      288 				call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
      289 				if icode = error_table_$invalid_lock_reset | icode = error_table_$locked_by_this_process then
      290 				     icode = 0;	/* ignore these errors */
      291 
      292 				if icode = error_table_$no_w_permission then
      293 				     call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^a^a^a^a",
      294 					"No permission to set scope lock on """, rtrim (db_path),
      295 					">", rtrim (mrds_data_$control_segment_name), """.");
      296 				else if icode ^= 0 then do;
      297 					dbc.trouble_switch = ON; /* something messed up, lock against further opens */
      298 				     end;
      299 				else do;
      300 
      301 /* convert fil_list structures from ru to rusmd codes usage */
      302 
      303 					call process_user_list (pointer (dbc_ptr, dbc.active_users_ofs), "1"b);
      304 					call process_user_list (pointer (dbc_ptr, dbc.waiting_users_ofs), "0"b);
      305 					dbc.version = 5; /* now converted to version 5 dbc */
      306 				     end;
      307 
      308 				if icode = 0 then
      309 				     call set_lock_$unlock (dbc.scope_lock, icode);
      310 
      311 			     end;
      312 		     end;
      313 
      314 
      315 	     end;
      316 
      317      end;
      318 
      319 get_any_dbc: procedure ();
      320 
      321 /* routine to get a pointer to any version of the database control segment,
      322*   starting with latest versions first. */
      323 
      324 	call hcs_$initiate_count (db_path, rtrim (mrds_data_$control_segment_name), "",
      325 	     bit_count, 0, first_dbc_ptr, icode);
      326 
      327 	if icode = error_table_$moderr then do;
      328 
      329 /* set access for the user and retry, if he is a DBA */
      330 
      331 		call mrds_dm_authorization$set_needed_access (rtrim (db_path), icode); /* fails if user not DBA */
      332 		if icode ^= 0 then
      333 		     icode = error_table_$moderr;
      334 		else call hcs_$initiate_count (db_path, rtrim (mrds_data_$control_segment_name), "",
      335 			bit_count, 0, first_dbc_ptr, icode);
      336 
      337 	     end;
      338 
      339 	if icode = error_table_$moderr then
      340 
      341 /* null access on database control segment */
      342 
      343 	     call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^a^a^a^a",
      344 		"Unable to get pointer to the database control segment """, rtrim (db_path),
      345 		">", rtrim (mrds_data_$control_segment_name), """.");
      346 
      347 	else do;
      348 
      349 		call hcs_$initiate_count (db_path, "dbc", "", temp_bit_count, 0, second_dbc_ptr, temp_code);
      350 
      351 /* on an access violation, set access for the user and retry, if he is a DBA */
      352 
      353 		if temp_code = error_table_$moderr then do;
      354 			call mrds_dm_authorization$set_needed_access (rtrim (db_path), temp_code);
      355 			if temp_code ^= 0 then
      356 			     temp_code = error_table_$moderr;
      357 			else call hcs_$initiate_count (db_path, "dbc", "", temp_bit_count, 0, second_dbc_ptr, temp_code);
      358 		     end;
      359 
      360 
      361 /* check for foul deeds by the user, only debug tool users may pass */
      362 
      363 		if first_dbc_ptr ^= null () & second_dbc_ptr ^= null () & /* too many control segments */
      364 		     substr (db_mu_concurrency_control, 1, 1) ^= "1"b then do;
      365 			dbc_ptr = null ();
      366 			icode = mrds_error_$version_not_supported;
      367 			call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^/^a^a^a^/^a",
      368 			     "Unable to determine the database control segment version,",
      369 			     "because both a ""dbc"" and a ""db.control"" segment were found under the database """,
      370 			     db_path, """",
      371 			     "either the old or new version may be present, not both!");
      372 		     end;
      373 		else do;
      374 
      375 			if first_dbc_ptr = null () & second_dbc_ptr = null () then do; /* not enough control segments */
      376 				dbc_ptr = null ();
      377 				call sub_err_ (icode, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      378 				     "Neither a ""dbc"", nor a ""db.control"" control segment was found under the database """,
      379 				     db_path, """.");
      380 			     end;
      381 			else if first_dbc_ptr = null () then do; /* old control segment - dbc */
      382 				dbc_ptr = second_dbc_ptr;
      383 				bit_count = temp_bit_count;
      384 			     end;
      385 			else dbc_ptr = first_dbc_ptr; /* new control segment - db.control */
      386 
      387 		     end;
      388 
      389 		if dbc_ptr ^= null () then
      390 		     icode = 0;			/* ignore name_dup errors */
      391 
      392 	     end;
      393 
      394 
      395 	declare (first_dbc_ptr, second_dbc_ptr) ptr;	/* temporary copies of dbc pointer */
      396 
      397      end;
      398 
      399 process_user_list: procedure (in_ul_ptr, active_list);
      400 
      401 /* routine to trace through the linked user list */
      402 
      403 	ul_ptr = in_ul_ptr;
      404 	do while (rel (ul_ptr) ^= NULL_OFS);
      405 
      406 	     call process_file_list (pointer (dbc_ptr, user_list.fil_list_ofs));
      407 	     if active_list then
      408 		ul_ptr = pointer (dbc_ptr, user_list.next_active_ofs);
      409 	     else ul_ptr = pointer (dbc_ptr, user_list.next_waiting_ofs);
      410 
      411 	end;
      412 
      413 	declare in_ul_ptr		 ptr;		/* input to start of list */
      414 	declare active_list		 bit (1);		/* on => active, off => waiting list of users */
      415 
      416 
      417      end;
      418 
      419 process_file_list: procedure (in_fl_ptr);
      420 
      421 /* routine to trace a list of file list structures  */
      422 
      423 	fl_ptr = in_fl_ptr;
      424 	do while (rel (fl_ptr) ^= NULL_OFS);
      425 
      426 	     if fil_list.permits.update then do;
      427 		     fil_list.permits.append_tuple = ON;
      428 		     fil_list.permits.delete_tuple = ON;
      429 		     fil_list.permits.modify_attr = ON;
      430 		end;
      431 	     else do;
      432 		     fil_list.permits.append_tuple = OFF;
      433 		     fil_list.permits.delete_tuple = OFF;
      434 		     fil_list.permits.modify_attr = OFF;
      435 		end;
      436 
      437 
      438 	     if fil_list.prevents.update then do;
      439 		     fil_list.prevents.append_tuple = ON;
      440 		     fil_list.prevents.delete_tuple = ON;
      441 		     fil_list.prevents.modify_attr = ON;
      442 		end;
      443 	     else do;
      444 		     fil_list.prevents.append_tuple = OFF;
      445 		     fil_list.prevents.delete_tuple = OFF;
      446 		     fil_list.prevents.modify_attr = OFF;
      447 		end;
      448 
      449 	     fl_ptr = pointer (dbc_ptr, fil_list.next_ofs);
      450 
      451 	end;
      452 
      453 	declare in_fl_ptr		 ptr;		/* input to start of list */
      454 
      455      end;
      456 
      457 	declare sub_err_		 entry options (variable); /* reports errors */
      458 	declare hcs_$chname_seg	 entry (ptr, char (*), char (*), fixed bin (35)); /* changes seg name */
      459 	declare error_table_$segnamedup fixed bin (35) ext; /* entry not found */
      460 	dcl     hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
      461 	dcl     hcs_$truncate_seg	 entry (ptr, fixed bin (18), fixed bin (35));
      462 
      463 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;
      464 
      465 	dcl     (addr, empty, fixed, null, pointer, rel, rtrim, substr) builtin;
      466 	declare set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
      467 	declare set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      468 	declare error_table_$invalid_lock_reset fixed bin (35) ext;
      469 	declare error_table_$locked_by_this_process fixed bin (35) ext;
      470 	declare mrds_data_$lock_wait_time fixed bin (35) ext;
      471 	declare mrds_data_$control_segment_name char (32) ext; /* name of control segment */
      472 	declare debug_sw		 bit (1);		/* for testing purposes */
      473 	declare continue		 char (1) init ("c"); /* dont stop after printing error */
      474 	declare info_ptr		 ptr init (null ());/* unused */
      475 	declare return_value	 fixed bin (35) init (0); /* unsued */
      476 	declare caller_name		 char (32) init ("mu_concurrency_control"); /* name of calling routine */
      477 	declare mrds_error_$version_not_supported fixed bin (35) ext; /* bad dbc version */
      478 	declare db_path		 char (168);	/* input database path */
      479 	declare temp_code		 fixed bin (35);	/* unused */
      480 	declare ON		 bit (1) init ("1"b); /* true value */
      481 	declare OFF		 bit (1) init ("0"b); /* false value */
      482 	declare old_version		 bit (1);		/* on => need to convert */
      483 	declare bad_version		 bit (1);		/* on => unsupported version */
      484 	declare hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)); /* makes segmetn */
      485 	declare hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24),
      486 				 fixed bin (2), ptr, fixed bin (35)); /* gets seg ptr and bit count */
      487 	declare error_table_$moderr	 fixed bin (35) ext;/* incorrect access on entry */
      488 	declare error_table_$no_w_permission fixed bin (35) ext; /* no "w" acl */
      489 	declare dir_name		 char (168);	/* name of dbc dir */
      490 	declare discard		 fixed bin (35);	/* unused error code */
      491 	declare ldn		 fixed bin;	/* length of dbc dir name */
      492 	declare entryname		 char (32);	/* either dbc or db.control */
      493 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35)); /* gets name from ptr */
      494 	declare temp_bit_count	 fixed bin (24);	/* temporary for get dbc seg bit count */
      495 	declare cant_get_version	 bit (1);		/* on => couldnt get segment name from dbc_ptr */
      496 	declare mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35)); /* sets access for dba types */
      497 	dcl     dbc_ptr_param	 ptr parm;	/* ptr to the data base control segment (input) */
      498 
      499 	dcl     bit_count		 fixed bin (24);	/* bit count of dbc segment */
      500 
      501 	dcl     icode		 fixed bin (35);	/* returrn code */
      502 
  1     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Modified by odf for new version data bases in August 1978
  1     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  1     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  1     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  1     9*
  1    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  1    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  1    12**/
  1    13 
  1    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  1    15     2 proper,
  1    16       3 version fixed bin,				/* version number of this structure */
  1    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  1    18       3 flags,
  1    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  1    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  1    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  1    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  1    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  1    24         4 pad bit (31) unal,				/* reserved for future use */
  1    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  1    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  1    27*						   received it */
  1    28       3 user_counts,
  1    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  1    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  1    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  1    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  1    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  1    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  1    35       3 pad2 bit (144),
  1    36       3 offsets,
  1    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  1    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  1    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  1    40         4 obsolete bit (36) unal,			/* obsolete */
  1    41       3 pad3 bit (144),
  1    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  1    43 
  1    44 dcl  dbc_ptr ptr init (null ());
  1    45 
  1    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  1    47 
  1    48 
  1    49 /* END mdbm_dcb.incl.pl1  */
  1    50 
  1    51 
      503 
      504 
  2     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  2     7*     install(86-10-23,MR12.0-1199):
  2     8*     Deleted the DEFAULT_WAIT variable.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* HISTORY:
  2    13*   Written by Oris Friesen August 10, 1978.
  2    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  2    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  2    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  2    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  2    18*   r-u-s-m-d scope codes, instead of just r-u.
  2    19*
  2    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  2    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  2    22*   and pad to mbz for consistency with MRDS access acl modes.
  2    23*
  2    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  2    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  2    26*   This is currently only used in mrds_dsl_set_fscope.
  2    27*
  2    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  2    29*   Put it at the end to make the new structure compatable with the old so
  2    30*   that testing could take place without having to recompile all the modules
  2    31*   that use the structure.
  2    32*
  2    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  2    34*   element. This was done because set_fscope must be able to open the
  2    35*   relation if its not yet opened.
  2    36*   ---------------------------------------------------------------------------
  2    37*   DESCRIPTION:
  2    38*
  2    39*   The dbc contains the following information in its static area.
  2    40*   One group of information is composed of structures (user_list)
  2    41*   threaded 3 ways to form 3 lists. They are the list of active
  2    42*   scope users, of open users, and of users waiting to set scope.
  2    43*   The beginning of each of these lists is pointed to by fields
  2    44*   in the dbc proper.  All of these lists share the user_list structures,
  2    45*   and are completely contained within these structures, i.e., there
  2    46*   is no extraneous information in some knook in Scottsdale.
  2    47*
  2    48*   Associated with each user_list structure is a linked list of
  2    49*   fil_list structures.  The list is of all of the files (relations)
  2    50*   included in the user's scope request.  Unlike the user_list
  2    51*   structures which were shared by several different lists, the structures
  2    52*   in a user's file list are exclusively hers.  The entries contain
  2    53*   information about the scope request and the file name, and have
  2    54*   no real connection with the actual files in the resultant model.
  2    55*   --------------------------------------------------------------------------- */
  2    56 
  2    57 dcl 1 user_list based (ul_ptr),
  2    58     2 ids,
  2    59       3 group_id char (32),				/* group identifier of this user */
  2    60       3 process_id bit (36),				/* process identifier of this user */
  2    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  2    62*						   used to identify dead processes */
  2    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  2    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  2    65*						   to allow concurrent openings by same process */
  2    66     2 flags,
  2    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  2    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  2    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  2    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  2    71       3 priority_high bit (1) unal,			/* obsolete */
  2    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  2    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  2    74       3 dead_proc_conflict
  2    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  2    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  2    77       3 pad bit (28),				/* reserved for future use */
  2    78     2 allowance_count fixed bin,			/* obsolete */
  2    79     2 bypass_count fixed bin,				/* obsolete */
  2    80     2 offsets,
  2    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  2    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  2    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  2    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  2    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  2    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  2    87 						/* names of files accessible by this user */
  2    88 
  2    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  2    90     2 name char (30),				/* data model name of the file specified in scope request */
  2    91     2 permits,					/* permit codes for scope setting or deleting */
  2    92       3 mbz1 bit (15) unal,
  2    93       3 modify_attr bit (1) unal,
  2    94       3 delete_tuple bit (1) unal,
  2    95       3 append_tuple bit (1) unal,
  2    96       3 update bit (1) unal,
  2    97       3 read_attr bit (1) unal,
  2    98     2 prevents,					/* prevent codes for scope setting or deleting */
  2    99       3 update bit (1) unal,
  2   100       3 read_attr bit (1) unal,
  2   101       3 append_tuple bit (1) unal,
  2   102       3 delete_tuple bit (1) unal,
  2   103       3 modify_attr bit (1) unal,
  2   104       3 mbz2 bit (29) unal,
  2   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  2   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  2   107                                                             /* needed so that the relation can be opened if need be */
  2   108 
  2   109 dcl  ul_ptr ptr init (null ());
  2   110 dcl  fl_ptr ptr init (null ());
  2   111 
  2   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  2   113 
  2   114 
  2   115 dcl  WAIT init (0) fixed bin int static options (constant);
  2   116 						/* the number of later user requests for which a user
  2   117*						   request will wait before it must be honored */
  2   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  2   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  2   120 						/* dequeue from open list */
  2   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  2   122 						/*  do not dequeue from open list */
  2   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  2   124 dcl  QUE_FREE fixed bin (71);
  2   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  2   126 						/* wakeup up signal for time-out */
  2   127 dcl  ALARM fixed bin (71);
  2   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  2   129 						/* this is the 1st time process will asleep */
  2   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  2   131 						/* being queued for the 2nd, 3rd ... time */
  2   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  2   133 						/* check to see which scopes can be set */
  2   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  2   135 						/* check to see which scopes can be deleted */
  2   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  2   137 						/* process is alive */
  2   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  2   139 						/* process is dead */
  2   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  2   141 						/* permit retrieve, update */
  2   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  2   143 						/* prevent retrieve, update */
  2   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  2   145 						/* permit retrieve, update */
  2   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  2   147 						/* prevent retrieve, update */
  2   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  2   149 						/* measure wait time in relative seconds */
  2   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  2   151 						/* free this user's file lists */
  2   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  2   153 						/* do not free this user's file lists */
  2   154 
  2   155 /* END mdbm_users.incl.pl1 */
  2   156 
      505 
      506 
  3     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
  3     2 
  3     3 /* this include file associates module names with debug switches
  3     4*   that are stored in the data segment mrds_debug_
  3     5*   each module has it's own bit(9) debug switch, to define for various
  3     6*   debug actions, with new module names to be added to the end
  3     7*   of this list using the next in order array index in mrds_debug_
  3     8*   the convention for naming is db_{module's full name}
  3     9*   for the defined declaration over mrds_debug_$switch.
  3    10*   module.name array is then changed to reflect the new
  3    11*   number of modules, with the full module name added to the bottom
  3    12*   of the initialize list for the name array.
  3    13*   the module name array is used by the command level interface that sets/resets
  3    14*   the current status of the debug switches for each module.
  3    15*   the modules themselves use the db_{module name} declared variable for
  3    16*   that module to interagate the bits for proper debug action to take.
  3    17*   the definition of the meaning of the 9-bits is up to each individual module's
  3    18*   designer. */
  3    19 
  3    20 
  3    21 /*
  3    22*   HISTORY
  3    23*
  3    24*   80-11-12 Davids: added db_mus_mod_ubtup
  3    25*
  3    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
  3    27*
  3    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
  3    29*   error  info  about  being queued, and request being granted after
  3    30*   being queued.
  3    31*
  3    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
  3    33*   running  MR8  and  MR9 mrds against the same database at the same
  3    34*   time.
  3    35*
  3    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
  3    37*   displaying internal tuple format bit offset, rather than the user
  3    38*   view.
  3    39*
  3    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
  3    41*   dump  an  element  from  the  list, when display_open_names entry
  3    42*   called with switch set.
  3    43*
  3    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
  3    45*   of sub_err_ messages, when cross domain compare occurs.
  3    46*
  3    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
  3    48*   iocb slot and rel name.
  3    49*
  3    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
  3    51*
  3    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
  3    53*
  3    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
  3    55*   allows  key  searches, other than than specified by permute to be
  3    56*   done as comparisons instead.
  3    57*
  3    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
  3    59*   mrds_dsl_gen_srch_prog
  3    60**/
  3    61 
  3    62 declare (
  3    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
  3    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
  3    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
  3    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
  3    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
  3    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
  3    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
  3    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
  3    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
  3    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
  3    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
  3    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
  3    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
  3    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
  3    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
  3    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
  3    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
  3    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
  3    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
  3    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
  3    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
  3    84          ) ;
  3    85 
  3    86 /* list of known module names, with index into name array
  3    87*   the same as that into mrds_debug_$switch,
  3    88*   number is the current count of defined module names,
  3    89*   name is the modules full name. */
  3    90 
  3    91 declare 1 module options (constant) internal static,
  3    92         2 number fixed bin init (21),
  3    93         2 name char (32) dimension (21) init (
  3    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
  3    95          "mrds_dsl_get_token",			/* 1 => display the current token */
  3    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
  3    97*						   2 => reverse partial path
  3    98*						   3 => use range order for path
  3    99*						   4 => display access method costs
  3   100*						   5 => display details of final low cost path */
  3   101          "mrds_dsl_optimize",				/* 1 => pred tree,
  3   102*						   2 => paths to consider, 3 => calc_cost on */
  3   103          "mrds_dsl_search",				/* 1 => display each tuple located */
  3   104          "mrds_dsl_translate",			/* 1 => display the search program */
  3   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
  3   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
  3   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
  3   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
  3   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
  3   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
  3   111*						   and new tuple during modifies will be done */
  3   112          "mu_sec_get_tuple",				/* 1 => attribute values
  3   113*						   will be zeroed in the tuple structure
  3   114*						   is don't have read permission. */
  3   115          "mu_sec_get_tid",				/* 1 => read permission to the key
  3   116*						   is checked (if db is secured) */
  3   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
  3   118*						   and request granted from queue messages */
  3   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
  3   120*						   so can test both MR8 and MR9 mrds
  3   121*						   against the same database at the same time */
  3   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
  3   123*						   for attributes to be displayed, rather than user view */
  3   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
  3   125*						   when display_open_names entry called */
  3   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
  3   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
  3   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
  3   129*						   when the original access was a key,
  3   130*						   and the additional conditions can be done as key also
  3   131*						   2 => force key searches, regardless of strategy
  3   132*						   used to decide between compare or key search */
  3   133          ) ;
  3   134 
  3   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
  3   136 
  3   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
  3   138 
      507 
      508      end;
      509 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1124.0  mu_concurrency_control.pl1        >udd>sm>ds>w>ml>mu_concurrency_control.pl1
503          1    10/14/83  1709.0  mdbm_dbc.incl.pl1                 >ldd>incl>mdbm_dbc.incl.pl1
505          2    10/23/86  1133.9  mdbm_users.incl.pl1               >ldd>incl>mdbm_users.incl.pl1
507          3    10/14/83  1709.0  mrds_debug_names.incl.pl1         >ldd>incl>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFS                               constant        bit(18)                  initial packed unaligned dcl 2-118 ref 210 404 424
OFF                             000117 automatic       bit(1)                   initial packed unaligned dcl 481 set ref 202 203 206
                                                                                  207 209 211 212 228 269 432 433 434 444 445 446
                                                                                  481*
ON                              000116 automatic       bit(1)                   initial packed unaligned dcl 480 set ref 237 239 241
                                                                                  244 297 427 428 429 439 440 441 480*
VERSION_NBR                            constant        fixed bin(17,0)          initial dcl 1-46 ref 200
active_list                            parameter       bit(1)                   packed unaligned dcl 414 ref 399 407
active_users_ofs         21(18)        based           bit(18)                  level 4 packed packed unaligned dcl 1-14 set ref 303
                                                                                  303
addr                                                   builtin function         dcl 465 ref 208 213 215 241
append_tuple              7(35)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 427* 432*
append_tuple             10(04)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 439* 444*
bad_version                     000121 automatic       bit(1)                   packed unaligned dcl 483 set ref 228* 241* 258
bit_count                              parameter       fixed bin(24,0)          dcl 499 set ref 98 107 118 130 215* 216* 241 263*
                                                                                  324* 334* 383*
caller_name                     000105 automatic       char(32)                 initial packed unaligned dcl 476 set ref 166* 252*
                                                                                  263* 276* 292* 339* 367* 377* 476*
cant_get_version                000207 automatic       bit(1)                   packed unaligned dcl 495 set ref 228* 237* 247
continue                        000101 automatic       char(1)                  initial packed unaligned dcl 473 set ref 166* 252*
                                                                                  263* 276* 292* 339* 367* 377* 473*
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 3-62 ref 363
db_path                                parameter       char(168)                packed unaligned dcl 478 set ref 98 107 118 130 144*
                                                                                  166 166 252* 263* 276* 292 292 324* 331 331 334*
                                                                                  339 339 349* 354 354 357* 367* 377*
dbc                                    based           structure                level 1 unaligned dcl 1-14
dbc_ptr                         000210 automatic       pointer                  initial dcl 1-44 set ref 103 114 126 135* 1-44* 144*
                                                                                  145 162* 165* 171* 185* 200 201 202 203 204 205
                                                                                  206 207 208 208 209 210 211 212 213 213 215 216*
                                                                                  232 235* 241 241 241 244 252* 263 288 297 303 303
                                                                                  303 303 304 304 304 304 305 308 365* 376* 382*
                                                                                  385* 389 406 406 407 409 449
dbc_ptr_param                          parameter       pointer                  dcl 497 set ref 98 103* 107 114* 118 126* 130 135
debug_sw                        000100 automatic       bit(1)                   packed unaligned dcl 472 set ref 269* 270
delete_tuple             10(05)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 440* 445*
delete_tuple              7(34)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 428* 433*
dir_name                        000122 automatic       char(168)                packed unaligned dcl 489 set ref 165* 235*
discard                         000174 automatic       fixed bin(35,0)          dcl 490 set ref 165*
dtd_mrds                  2            based           fixed bin(71,0)          level 3 dcl 1-14 set ref 201*
empty                                                  builtin function         dcl 465 ref 213
entryname                       000176 automatic       char(32)                 packed unaligned dcl 492 set ref 164* 165* 166 166
                                                                                  235* 239
error_table_$invalid_lock_reset 000030 external static fixed bin(35,0)          dcl 468 ref 289
error_table_$locked_by_this_process
                                000032 external static fixed bin(35,0)          dcl 469 ref 289
error_table_$moderr             000046 external static fixed bin(35,0)          dcl 487 ref 163 327 332 339 353 355
error_table_$no_w_permission    000050 external static fixed bin(35,0)          dcl 488 ref 292
error_table_$segnamedup         000014 external static fixed bin(35,0)          dcl 459 ref 186
fil_list                               based           structure                level 1 unaligned dcl 2-89
fil_list_ofs             22            based           bit(18)                  level 3 packed packed unaligned dcl 2-57 ref 406 406
first_dbc_ptr                   000254 automatic       pointer                  dcl 395 set ref 324* 334* 363 375 381 385
fixed                                                  builtin function         dcl 465 ref 208 213 215 241
fl_ptr                          000214 automatic       pointer                  initial dcl 2-110 set ref 2-110* 423* 424 426 427
                                                                                  428 429 432 433 434 438 439 440 441 444 445 446
                                                                                  449* 449
flags                     4            based           structure                level 3 packed packed unaligned dcl 1-14 set ref
                                                                                  202*
hcs_$chname_seg                 000012 constant        entry                    external dcl 458 ref 185
hcs_$fs_get_path_name           000052 constant        entry                    external dcl 493 ref 165 235
hcs_$initiate_count             000044 constant        entry                    external dcl 485 ref 324 334 349 357
hcs_$make_seg                   000042 constant        entry                    external dcl 484 ref 144
hcs_$set_bc_seg                 000016 constant        entry                    external dcl 460 ref 171 216
hcs_$truncate_seg               000020 constant        entry                    external dcl 461 ref 162
icode                                  parameter       fixed bin(35,0)          dcl 501 set ref 98 107 118 130 144* 147* 162* 163
                                                                                  166* 170 171* 173 179 185* 186 186* 216* 232 235*
                                                                                  237 252* 262* 263* 275* 276* 288* 289 289 289* 292
                                                                                  292* 296 308 308* 324* 327 331* 332 332* 334* 339
                                                                                  339* 366* 367* 377* 389*
in_fl_ptr                              parameter       pointer                  dcl 453 ref 419 423
in_ul_ptr                              parameter       pointer                  dcl 413 ref 399 403
info_ptr                        000102 automatic       pointer                  initial dcl 474 set ref 166* 252* 263* 276* 292*
                                                                                  339* 367* 377* 474*
ldn                             000175 automatic       fixed bin(17,0)          dcl 491 set ref 165* 235*
modify_attr              10(06)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 441* 446*
modify_attr               7(33)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" set ref 429* 434*
mrds_data_$control_segment_name 000036 external static char(32)                 packed unaligned dcl 471 ref 144 144 164 185 185 292
                                                                                  292 324 324 334 334 339 339
mrds_data_$lock_wait_time       000034 external static fixed bin(35,0)          dcl 470 ref 288
mrds_debug_$switch              000056 external static bit(9)                   array packed unaligned dcl 3-135 ref 363 363
mrds_dm_authorization$set_needed_access
                                000054 constant        entry                    external dcl 496 ref 331 354
mrds_error_$version_not_supported
                                000040 external static fixed bin(35,0)          dcl 477 ref 232 262 275 366
next_active_ofs          22(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-57 ref 407
next_ofs                 11            based           bit(18)                  level 2 packed packed unaligned dcl 2-89 ref 449
next_waiting_ofs         23            based           bit(18)                  level 3 packed packed unaligned dcl 2-57 ref 409
null                                                   builtin function         dcl 465 ref 474 1-44 2-109 2-110 145 232 363 363 365
                                                                                  375 375 376 381 389
obsolete                 22(18)        based           bit(36)                  level 4 packed packed unaligned dcl 1-14 set ref
                                                                                  211*
offsets                  21            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 1-14 in procedure "mu_concurrency_control" set
                                                                                  ref 210*
offsets                  22            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 2-57 in procedure
                                                                                  "mu_concurrency_control"
old_version                     000120 automatic       bit(1)                   packed unaligned dcl 482 set ref 228* 239* 244* 268
open_lock                12            based           bit(36)                  level 3 dcl 1-14 set ref 206*
pad2                     15            based           bit(144)                 level 3 packed packed unaligned dcl 1-14 set ref
                                                                                  209*
pad3                     23(18)        based           bit(144)                 level 3 packed packed unaligned dcl 1-14 set ref
                                                                                  212*
permits                   7(18)        based           structure                level 2 packed packed unaligned dcl 2-89
pointer                                                builtin function         dcl 465 ref 303 303 304 304 406 406 407 409 449
prevents                 10(02)        based           structure                level 2 packed packed unaligned dcl 2-89
proper                                 based           structure                level 2 unaligned dcl 1-14
quiesce_lock              5            based           bit(36)                  level 3 dcl 1-14 set ref 203*
rel                                                    builtin function         dcl 465 ref 208 213 215 241 404 424
return_value                    000104 automatic       fixed bin(35,0)          initial dcl 475 set ref 166* 252* 263* 276* 292*
                                                                                  339* 367* 377* 475*
rtrim                                                  builtin function         dcl 465 ref 144 144 166 166 166 166 185 185 292 292
                                                                                  292 292 324 324 331 331 334 334 339 339 339 339
                                                                                  354 354
sa_size                  14            based           fixed bin(35,0)          level 3 dcl 1-14 set ref 208*
scope_lock               13            based           bit(36)                  level 3 dcl 1-14 set ref 207* 288* 308*
second_dbc_ptr                  000256 automatic       pointer                  dcl 395 set ref 349* 357* 363 375 382
set_lock_$lock                  000026 constant        entry                    external dcl 467 ref 288
set_lock_$unlock                000024 constant        entry                    external dcl 466 ref 308
static_area              30            based           area                     level 2 dcl 1-14 set ref 208 213* 213 215 241
sub_err_                        000010 constant        entry                    external dcl 457 ref 166 252 263 276 292 339 367 377
substr                                                 builtin function         dcl 465 ref 363
sys_info$max_seg_size           000022 external static fixed bin(35,0)          dcl 463 ref 208 213
temp_bit_count                  000206 automatic       fixed bin(24,0)          dcl 494 set ref 349* 357* 383
temp_code                       000115 automatic       fixed bin(35,0)          dcl 479 set ref 349* 353 354* 355 355* 357*
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 1-14 set ref
                                                                                  297*
ul_ptr                          000212 automatic       pointer                  initial dcl 2-109 set ref 2-109* 403* 404 406 406
                                                                                  407* 407 409* 409
update                   10            based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" ref 426
update                   10(02)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 2-89 in procedure
                                                                                  "mu_concurrency_control" ref 438
user_counts               7            based           structure                level 3 unaligned dcl 1-14 set ref 205*
user_list                              based           structure                level 1 unaligned dcl 2-57
version                                based           fixed bin(17,0)          level 3 dcl 1-14 set ref 200* 241 241 244 263* 305*
waiting_users_ofs        22            based           bit(18)                  level 4 packed packed unaligned dcl 1-14 set ref 304
                                                                                  304
wakeup_waiters            6            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 204*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 2-127
ALIVE                                  internal static bit(1)                   initial packed unaligned dcl 2-136
CHAR_ALARM                             internal static char(8)                  initial packed unaligned dcl 2-125
CHAR_Q_F                               internal static char(8)                  initial packed unaligned dcl 2-123
DEAD                                   internal static bit(1)                   initial packed unaligned dcl 2-138
DEL                                    internal static bit(1)                   initial packed unaligned dcl 2-134
DQ_OPEN                                internal static bit(1)                   initial packed unaligned dcl 2-119
FIRST_QUEUE                            internal static bit(1)                   initial packed unaligned dcl 2-128
FREE_FIL_LIST                          internal static bit(1)                   initial packed unaligned dcl 2-150
NO_DQ_OPEN                             internal static bit(1)                   initial packed unaligned dcl 2-121
QUEUE_AGAIN                            internal static bit(1)                   initial packed unaligned dcl 2-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 2-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 2-140
Q_PRM_BITS                             internal static bit(2)                   initial packed unaligned dcl 2-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 2-142
Q_PRV_BITS                             internal static bit(2)                   initial packed unaligned dcl 2-146
REL_SEC                                internal static bit(2)                   initial packed unaligned dcl 2-148
SAVE_FIL_LIST                          internal static bit(1)                   initial packed unaligned dcl 2-152
SET                                    internal static bit(1)                   initial packed unaligned dcl 2-132
WAIT                                   internal static fixed bin(17,0)          initial dcl 2-115
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 3-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 3-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 3-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 3-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 3-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 3-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 3-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 3-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 3-62
module                                 internal static structure                level 1 unaligned dcl 3-91
num_filns                              automatic       fixed bin(17,0)          dcl 2-112

NAMES DECLARED BY EXPLICIT CONTEXT.
create_control_segment          000444 constant        entry                    external dcl 98
get_any_dbc                     002226 constant        entry                    internal dcl 319 ref 113 230
get_control_segment             000461 constant        entry                    external dcl 107
get_latest_dbc                  001314 constant        entry                    internal dcl 220 ref 125
init_dbc                        001150 constant        entry                    internal dcl 195 ref 149 177
make_control_seg                000527 constant        entry                    internal dcl 139 ref 102
mu_concurrency_control          000430 constant        entry                    external dcl 19
open_control_segment            000476 constant        entry                    external dcl 118
process_file_list               003312 constant        entry                    internal dcl 419 ref 406
process_user_list               003244 constant        entry                    internal dcl 399 ref 303 304
re_init_dbc                     000624 constant        entry                    internal dcl 154 ref 136
reset_control_segment           000513 constant        entry                    external dcl 130

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4010        4070    3453        4020
Length      4372    3453        60         265     335           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_concurrency_control              654 external procedure  is an external procedure.  
make_control_seg                        internal procedure  shares stack frame of external procedure mu_concurrency_control.  
re_init_dbc                             internal procedure  shares stack frame of external procedure mu_concurrency_control.  
init_dbc                                internal procedure  shares stack frame of external procedure mu_concurrency_control.  
get_latest_dbc                          internal procedure  shares stack frame of external procedure mu_concurrency_control.  
get_any_dbc                             internal procedure  shares stack frame of external procedure mu_concurrency_control.  
process_user_list                       internal procedure  shares stack frame of external procedure mu_concurrency_control.  
process_file_list                       internal procedure  shares stack frame of external procedure mu_concurrency_control.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_concurrency_control   000100 debug_sw                    mu_concurrency_control
                         000101 continue                    mu_concurrency_control
                         000102 info_ptr                    mu_concurrency_control
                         000104 return_value                mu_concurrency_control
                         000105 caller_name                 mu_concurrency_control
                         000115 temp_code                   mu_concurrency_control
                         000116 ON                          mu_concurrency_control
                         000117 OFF                         mu_concurrency_control
                         000120 old_version                 mu_concurrency_control
                         000121 bad_version                 mu_concurrency_control
                         000122 dir_name                    mu_concurrency_control
                         000174 discard                     mu_concurrency_control
                         000175 ldn                         mu_concurrency_control
                         000176 entryname                   mu_concurrency_control
                         000206 temp_bit_count              mu_concurrency_control
                         000207 cant_get_version            mu_concurrency_control
                         000210 dbc_ptr                     mu_concurrency_control
                         000212 ul_ptr                      mu_concurrency_control
                         000214 fl_ptr                      mu_concurrency_control
                         000254 first_dbc_ptr               get_any_dbc
                         000256 second_dbc_ptr              get_any_dbc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mpfx2               shorten_stack
ext_entry           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$chname_seg               hcs_$fs_get_path_name         hcs_$initiate_count           hcs_$make_seg
hcs_$set_bc_seg               hcs_$truncate_seg             mrds_dm_authorization$set_needed_access
set_lock_$lock                set_lock_$unlock              sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_lock_reset                             error_table_$locked_by_this_process
error_table_$moderr           error_table_$no_w_permission  error_table_$segnamedup
mrds_data_$control_segment_name                             mrds_data_$lock_wait_time     mrds_debug_$switch
mrds_error_$version_not_supported                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    473 000406       474 000410       475 000412       476 000413       480 000416       481 000420    1   44 000421
 2  109 000423    2  110 000424        19 000427        19 000436        98 000437       102 000452       103 000453
    104 000456       107 000457       113 000467       114 000470       115 000473       118 000474       125 000504
    126 000505       127 000510       130 000511       135 000521       136 000525       137 000526       139 000527
    144 000530       145 000612       147 000620       149 000622       152 000623       154 000624       162 000625
    163 000642       164 000647       165 000653       166 000703       169 001041       170 001043       171 001045
    173 001060       177 001063       179 001064       185 001067       186 001140       193 001147       195 001150
    200 001151       201 001153       202 001156       203 001213       204 001215       205 001216       206 001221
    207 001222       208 001223       209 001234       210 001237       211 001250       212 001254       213 001257
    215 001265       216 001277       218 001313       220 001314       228 001315       230 001321       232 001322
    235 001334       237 001364       239 001372       241 001401       244 001427       247 001434       252 001436
    257 001531       258 001532       262 001534       263 001537       267 001645       268 001646       269 001650
    270 001652       275 001653       276 001656       281 001760       288 001761       289 001777       292 002007
    296 002151       297 002154       298 002161       303 002162       304 002174       305 002206       308 002210
    317 002225       319 002226       324 002227       327 002314       331 002322       332 002357       334 002367
    337 002453       339 002454       347 002620       349 002621       353 002664       354 002670       355 002726
    357 002735       363 003002       365 003021       366 003023       367 003026       372 003124       375 003125
    376 003135       377 003137       380 003220       381 003221       382 003225       383 003227       384 003232
    385 003233       389 003235       397 003243       399 003244       403 003246       404 003251       406 003255
    407 003265       409 003302       411 003310       417 003311       419 003312       423 003314       424 003317
    426 003323       427 003327       428 003334       429 003341       430 003346       432 003347       433 003354
    434 003361       438 003366       439 003371       440 003376       441 003403       442 003410       444 003411
    445 003416       446 003423       449 003430       451 003434       455 003435


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
