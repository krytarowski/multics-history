	COMPILATION LISTING OF SEGMENT ta_process_volume_set_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/25/85  1526.1 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* format: style1,^inddcls,ifthenstmt,ifthendo,ifthen,indcomtxt,dclind5 */
       19 ta_process_volume_set_: proc (perm_table_ptr, arg_array, table_name, code);
       20 
       21 /* This subroutine implements the "go" key of tape_archive.  It is responsible
       22*   for orchestrating the order in which files are extracted, appended, and so
       23*   on, and for the bookkeeping of the files on the tape.  Certain duties that
       24*   are left to subroutines include actual tape mount, dismount, and I/O, and
       25*   bookkeeping of tape records used and tape file names.
       26*
       27*   Written 05/12/77 by C. D. Tavares.
       28*   Modified 04/11/79 by CDT to fix some problems with error handling.
       29*   Modified 09/24/79 by CDT to add -long and to fix bug resulting in
       30*   run-time additions to the volume set failing.
       31*   Modified 09/03/80 by CDT to implement density selection.
       32*   Modified 10/24/80 by CDT to add tape_ibm_ capability.
       33*   Modified 12/9/81 by CDT for highest_mount_type stuff.
       34*   Last modified 83-03-16 by S. G. Harris (UNCA) for version 4.
       35*   Modified 6/83 by S. Krupp for conversion to mtape_.
       36*   Modified 12/83 by T. A. Casey for ssu usage monitoring
       37*   Modified 01/84 by J. A. Bush to enable referencing dir search rule to find
       38*   target I/O module
       39*   Modified: June 1984 by Greg Texada to fix a bug in max volume set size.
       40*   Modified: 85-2-18 by C Spitzer add test for not finding a file when compacting.
       41**/
       42 
       43 /* The following constant is the ssu_usage version ID. It should be changed
       44*   whenever a new version of tape_archive is installed. The version ID decode
       45*   is as follows:
       46*   "tbX_mtY_ZZZ"
       47*   where:
       48*   X = tape_archive table version number
       49*   Y = mtape_ I/O module version number
       50*   ZZZ = either EXL or sss, depending on where this version of tape_archive resides */
       51 
       52 dcl  SSU_USAGE_VERSION      char (11) int static options (constant) init
       53 		        ("tb4_mt1_SSS");		/* change this as defined above */
       54 
       55 dcl  perm_table_ptr	        pointer parameter,
       56      arg_array	        (*) char (168) parameter,
       57      table_name	        char (*) parameter,
       58      code		        fixed bin (35) parameter,
       59      a_retain_sw	        bit (1) aligned;
       60 
       61 /* AUTOMATIC */
       62 
       63 dcl  alternate_volume_set   fixed bin,
       64      compacting	        bit (1) aligned,
       65      cur_time	        bit (36) aligned,
       66      debug_sw	        bit (1) aligned,
       67      (dlp, sci_ptr)	        pointer,
       68      (i, j)	        fixed bin,
       69      lock_entry	        bit (1) aligned,
       70      max_chars_in_seg       fixed bin (21),
       71      prev_retain_sw	        bit (1) aligned,
       72      reel_no	        fixed bin,
       73      retain_sw	        bit (1) aligned,
       74      set_incomplete_bit     bit (1) aligned,
       75      system_free_ptr        pointer,
       76      tape_has_changed       bit (1) aligned,
       77      tape_in_volume_string  char (264),
       78      tape_out_volume_string char (264),
       79      this_mount_type        fixed bin,
       80      varying_reel_id        char (168) varying,
       81      volume_no	        fixed bin,
       82      volume_string	        char (64) varying;
       83 
       84 /* BUILTINS */
       85 
       86 dcl  (addr, bit, clock, codeptr, dim, hbound, index, max, null, substr) builtin;
       87 
       88 /* STATIC */
       89 
       90 dcl  my_lock_id	        bit (36) aligned static initial ((36)"1"b);
       91 
       92 /* EXTERNAL STATIC */
       93 
       94 dcl  (error_table_$action_not_performed,
       95      error_table_$bad_mount_request,
       96      error_table_$badopt,
       97      error_table_$file_aborted,
       98      error_table_$lock_wait_time_exceeded,
       99      error_table_$no_file,
      100      error_table_$no_next_volume,
      101      error_table_$not_attached,
      102      error_table_$not_detached,
      103      error_table_$not_done,
      104      error_table_$unexpired_file,
      105      error_table_$unexpired_volume,
      106      error_table_$unimplemented_version,
      107      error_table_$uninitialized_volume,
      108      error_table_$vol_in_use) external fixed bin (35) static;
      109 
      110 dcl  sys_info$max_seg_size  external fixed bin (35) static;
      111 
      112 /* ENTRIES */
      113 
      114 dcl  (com_err_, com_err_$suppress_name, command_query_, command_query_$yes_no) ext entry options (variable),
      115      continue_to_signal_    ext entry (fixed bin (35)),
      116      debug	        ext entry,
      117      delete_$path	        ext entry (char (*), char (*), bit (6), char (*), fixed bin (35)),
      118      find_condition_info_   ext entry (pointer, pointer, fixed bin (35)),
      119      get_lock_id_	        entry returns (bit (36) aligned),
      120      get_system_free_area_  ext entry returns (pointer),
      121      get_temp_segments_     ext entry (char (*), pointer dimension (*), fixed bin (35)),
      122      ioa_		        ext entry options (variable),
      123      ioa_$rsnnl	        ext entry options (variable),
      124      release_temp_segments_ ext entry (char (*), pointer dimension (*), fixed bin (35)),
      125      set_lock_$lock	        entry (bit (36) aligned, fixed bin, fixed bin (35)),
      126      set_lock_$unlock       entry (bit (36) aligned, fixed bin (35)),
      127      ssu_$record_usage      entry (ptr, ptr, fixed bin (35)),
      128      ssu_$standalone_invocation entry (ptr, char (*), char (*), ptr, ptr, fixed bin (35)),
      129      ssu_$destroy_invocation entry (ptr);
      130 
      131 dcl  ta_file_io_$append     ext entry (pointer, fixed bin, pointer, fixed bin (35)),
      132      ta_file_io_$append_table ext entry (pointer, pointer, fixed bin (35)),
      133      ta_file_io_$compact    ext entry (pointer, fixed bin, pointer, fixed bin (35)),
      134      ta_file_io_$dismount   ext entry (pointer, pointer, bit (1) aligned, fixed bin (35)),
      135      ta_file_io_$extract    ext entry (pointer, fixed bin, pointer, fixed bin (35)),
      136      ta_table_mgr_$cancel_request_no ext entry (pointer, fixed bin, fixed bin (35)),
      137      ta_table_mgr_$copy_to_perm ext entry (ptr, ptr, fixed bin (35)),
      138      ta_table_mgr_$copy_to_temp ext entry (ptr, ptr, fixed bin (35)),
      139      ta_table_mgr_$finish_requests ext entry (pointer, fixed bin (35)),
      140      ta_table_mgr_$lock     ext entry (ptr, char (*), fixed bin, fixed bin (35)),
      141      ta_table_mgr_$unlock   ext entry (pointer, fixed bin (35));
      142 
      143 /* CONDITIONS */
      144 
      145 dcl  (command_question, cleanup) condition;
      146 
      147 /* BASED VARIABLES */
      148 
      149 dcl  1 delete_list	        aligned based (dlp),
      150        2 n_entries	        fixed bin initial (0),
      151        2 entries	        (tape_archive_table.n_queued_requests) aligned,
      152          3 dirname	        char (168) unaligned,
      153          3 uid	        bit (36) aligned,
      154          3 ename	        char (32) unaligned,
      155          3 force	        bit (1) aligned;
      156 
      157 dcl  system_free_area       area based (system_free_ptr);
      158 
  1     1 /* ---------- BEGIN include file tape_archive_table_dcl.incl.pl1 ---------- */
  1     2 
  1     3 /* Version 2 lengthened volume names from 6 to 32 characters */
  1     4 /* Version 3 introduced density field, workspace strategy for updates, */
  1     5 /* and the mount lock, which is less of a lock than a retain indicator. */
  1     6 /* Version 4 expanded density field to an array for independent volume set */
  1     7 /* densities and added uid fields for table deletion checking. */
  1     8 /* Modified 09/21/80 by C. D. Tavares for version 3 */
  1     9 /* Modified 12/9/81 by CDT to add highest_mount_type field */
  1    10 /* Last modified 83-03-16 by S. G. Harris (UNCA) for version 4. */
  1    11 /* Modified 09/16/83 by S. Krupp to add the TAPE_ARCHIVE_IO_MODULE
  1    12*   declaration for conversion to the mtape_ I/O module. */
  1    13 
  1    14 dcl 1 tape_archive_table aligned based (table_ptr),	/* online segment for tape_archive command */
  1    15     2 nonvolatile_part aligned,			/* temp table moving doesn't touch these */
  1    16       3 version_number fixed bin,			/* of table */
  1    17       3 magic_constant char (8),			/* "ta table" */
  1    18       3 compaction_warning_threshold float bin,		/* when to suggest compaction to user */
  1    19       3 auto_compaction_threshold float bin,		/* when to compact when user doesn't take hint */
  1    20       3 table_is_consistent bit (1) unaligned,		/* update in progress indicator */
  1    21       3 lock bit (36),				/* allows shared tape archives */
  1    22       3 lock_reason fixed bin,			/* reason seg already locked, for failure msg */
  1    23       3 locker_id char (32),				/* userid of locking process, for failure msg */
  1    24       3 io_module_name char (32),			/* tape_ansi_ or tape_ibm_ */
  1    25       3 recovery_info_offset bit (18) aligned,		/* holds address of workspace for table updates */
  1    26       3 perm_table_uid bit (36),			/* used to prevent table deletion */
  1    27       3 future_expansion (6) bit (36),			/* ... */
  1    28     2 volatile_part aligned,				/* these can get altered due to temp table moves */
  1    29       3 n_components fixed bin,			/* number valid (undeleted) components in archive */
  1    30       3 n_component_slots fixed bin,			/* number of used component slots in table */
  1    31       3 n_queued_requests fixed bin,			/* number requests to be performed next mount */
  1    32       3 n_request_slots fixed bin,			/* number of used request slots in table */
  1    33       3 next_mount_type fixed bin,			/* read only, write, or compact */
  1    34       3 date_time_tape_modified bit (36),		/* last time tape written on */
  1    35       3 date_time_last_compacted bit (36),		/* last time tape compacted */
  1    36       3 total_records fixed bin (35),			/* data out on tape, in Multics records */
  1    37       3 dead_records fixed bin (35),			/* records wasted (deletions, replacements) */
  1    38       3 incomplete_write_op_last bit (1),		/* ON if determined that user or sys crashed while writing tape */
  1    39       3 last_tape_file_no fixed bin,			/* number of last file existing on volume set */
  1    40       3 last_table_no fixed bin,			/* number of copies of online table on this volume set */
  1    41       3 mount_lock bit (36) aligned,			/* set to lock_id while volume set mounted */
  1    42       3 highest_mount_type fixed bin,			/* max of next_mount_type since retained */
  1    43       3 future_expansion (6) bit (36),			/* ... */
  1    44       3 tape_info aligned,
  1    45         4 density (2) fixed bin (17) unal,		/* post version 3 volume set densities */
  1    46         4 active_set fixed bin,			/* which of the two is most current */
  1    47         4 n_volumes_in_set (2) fixed bin,		/* how many reels comprise volume set */
  1    48         4 volume_set (2) aligned,
  1    49 	5 volume_id (8) char (168),			/* physical reel and slot info */
  1    50       3 component_table (0 refer (tape_archive_table.n_component_slots)) aligned like component,
  1    51       3 request_queue (0 refer (tape_archive_table.n_request_slots)) aligned like request;
  1    52 
  1    53 dcl 1 component aligned based (component_ptr),		/* format of one component entry */
  1    54     2 entry_status_descriptor like entry_status_descriptor aligned,
  1    55     2 previous_instance_backchain fixed bin,		/* index of file it replaced, if any */
  1    56     2 associated_request_index fixed bin,		/* if extract pending, index of request with dirpath */
  1    57     2 date_time_deleted bit (36) aligned,		/* if logically deleted, when. */
  1    58     2 future_expansion (5) bit (36) aligned;		/* ... */
  1    59 
  1    60 dcl 1 request aligned based (request_ptr),		/* format of a queued request */
  1    61     2 entry_status_descriptor like entry_status_descriptor aligned,
  1    62     2 directory_name char (168) unaligned,		/* in Multics file system */
  1    63     2 requested_ops unaligned,
  1    64       3 append bit (1) unaligned,			/* add to tape */
  1    65       3 replace bit (1) unaligned,			/* replace to tape */
  1    66       3 extract bit (1) unaligned,			/* extract from tape */
  1    67       3 delete bit (1) unaligned,			/* delete from tape or file system */
  1    68       3 force bit (1) unaligned,			/* forcibly do any of the above */
  1    69       3 single_name bit (1) unaligned,			/* append/extract with only given name */
  1    70       3 future_expansion bit (30) unaligned,
  1    71     2 existing_reference fixed bin,			/* index of component block, if exists (e.g. read) */
  1    72     2 future_expansion (4) bit (36) aligned;
  1    73 
  1    74 dcl 1 entry_status_descriptor aligned based,
  1    75     2 valid bit (1) unaligned,			/* an undeleted component or request if on */
  1    76     2 no_final_newline bit (1) unaligned,		/* ON if last char in file was not newline */
  1    77     2 safety_switch bit (1) unaligned,			/* reflects safety switch of file while online */
  1    78     2 pad bit (33) unaligned,
  1    79     2 file_info aligned,				/* main tape file for this entry */
  1    80       3 tape_file_name char (17),
  1    81       3 entry_name char (32) unaligned,			/* for Multics file system */
  1    82       3 date_time_archived bit (36),			/* when it was put on tape */
  1    83       3 recording_mode char (8) aligned,		/* "ascii", "binary", "ebcdic", etc. */
  1    84       3 date_time_branch_modified bit (36),		/* last modified while in file system */
  1    85       3 date_time_dumped bit (36),			/* by backup facility */
  1    86       3 bitcount_author char (32),			/* last person who modified it while online */
  1    87       3 file_length fixed bin (35),			/* in Multics pages */
  1    88       3 attribute_file_no fixed bin,			/* file number of attribute file on tape */
  1    89       3 n_tape_records fixed bin (35),			/* number of logical records on tape for this file */
  1    90     2 uid bit (36) aligned,				/* used to prevent table deletion */
  1    91     2 future_expansion bit (36) aligned;
  1    92 
  1    93 dcl 1 workspace based (workspace_ptr) aligned,		/* to prevent update inconsistencies */
  1    94     2 workspace_id char (8),				/* "wrkspace" */
  1    95     2 component_no fixed bin,
  1    96     2 request_no fixed bin,
  1    97     2 n_queued_requests fixed bin,
  1    98     2 dead_records fixed bin,
  1    99     2 total_records fixed bin,
  1   100     2 n_components fixed bin,
  1   101     2 n_request_slots fixed bin,
  1   102     2 next_mount_type fixed bin,
  1   103     2 future_expansion (70) fixed bin (35),
  1   104     2 tape_info_copy aligned like tape_archive_table.tape_info,
  1   105     2 future_expansion2 (16) fixed bin (35),
  1   106     2 component_copy like component aligned,
  1   107     2 future_expansion3 (16) fixed bin (35),
  1   108     2 request_copy like request aligned;
  1   109 
  1   110 dcl 1 based_tape_info based (tape_info_ptr) like tape_archive_table.tape_info aligned;
  1   111 
  1   112 dcl (table_ptr, component_ptr, request_ptr, workspace_ptr, tape_info_ptr) pointer;
  1   113 
  1   114 dcl ((None initial (0),				/* next scheduled processing flags */
  1   115      Delete initial (1),
  1   116      Read initial (2),
  1   117      Write initial (3),
  1   118      Compact initial (4),
  1   119 
  1   120      Examine initial (1),				/* current lock reason flags */
  1   121      Modify initial (2),
  1   122      Process_tape initial (3),
  1   123 
  1   124      Deletion initial (1),				/* pending_operation flags */
  1   125      Extraction initial (2),
  1   126      Replacement initial (3),
  1   127      Cancellation initial (4),
  1   128      Deletion_cancellation initial (5),
  1   129      Volume_alteration initial (6),
  1   130      Table_creation initial (7),
  1   131      Table_copy initial (8),
  1   132 
  1   133      Default_density initial (1600),
  1   134 
  1   135      tape_archive_version_4 initial (4)) fixed bin,
  1   136 
  1   137      TAPE_ARCHIVE_IO_MODULE char(6) init("mtape_"),
  1   138 
  1   139      Lock_reasons (0:3) char (24) initial
  1   140     ("no discernable reason", "table examination", "table modification", "tape processing"),
  1   141 
  1   142      Magic_constant char (8) initial ("ta table"),
  1   143      Magic_workspace_constant char (8) initial ("wrkspace")) static options (constant);
  1   144 
  1   145 /* ---------------- END include file tape_archive_table_dcl.incl.pl1 ---------------- */
      159 
      160 
      161 dcl  1 tape_archive_io_info aligned automatic,
  2     1 /* --------------- BEGIN include file tape_archive_io_info.incl.pl1 --------------- */
  2     2 
  2     3 /*
  2     4*dcl 1 tape_archive_io_info aligned,			/* level-1 line with storage class must be in outer program */
  2     5     2 tape_input_switch pointer,			/* IOX input switch pointer */
  2     6     2 input_opd_template char (520),			/* attach description template */
  2     7     2 tape_output_switch pointer,			/* IOX output switch pointer */
  2     8     2 output_opd_template char (520),			/* attach description template */
  2     9     2 file_input_switch pointer,			/* IOX switch */
  2    10     2 file_output_switch pointer,			/* IOX switch */
  2    11     2 temp_seg_ptrs aligned,				/* various free space pointers */
  2    12       3 attribute_seg_ptr pointer,			/* pointer to seg to hold attribute file from tape */
  2    13       3 buffer_ptr pointer,				/* seg for I/O buffer */
  2    14       3 temp_table_ptr pointer,			/* pointer to temp copy of online table */
  2    15     2 long_sw bit (1) aligned;			/* if on, call ioa_ to report major operations */
  2    16 
  2    17 dcl  based_temp_seg_ptrs (3) pointer based (addr (tape_archive_io_info.temp_seg_ptrs));
  2    18 
  2    19 /* ---------------- END include file tape_archive_io_info.incl.pl1 ---------------- */
      162 
      163 	;
      164 
      165 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      166 
      167 dcl  1 cond_info	        aligned automatic like condition_info;
      168 
  4     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  4     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  4     3 /*	version number changed to 4, 08/10/78 WOS */
  4     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  4     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  4     6 
  4     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  4     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  4     9     2 switches aligned,                                     /* various bit switch values */
  4    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  4    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  4    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  4    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  4    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  4    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  4    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  4    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  4    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  4    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  4    20 
  4    21 /*  Limit of data defined for version 2 */
  4    22 
  4    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  4    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  4    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  4    26 						/* minimum of 30 seconds required for repeat */
  4    27 						/* otherwise, no repeat will occur */
  4    28 /* Limit of data defined for version 4 */
  4    29 
  4    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  4    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  4    32 
  4    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  4    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  4    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  4    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  4    37 
  4    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      169 
      170 
  5     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  5     2 
  5     3 /* Written 05/04/78 by C. D. Tavares */
  5     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  5     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  5     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  5     7 
  5     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  5     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  5    10      iox_$close entry (pointer, fixed bin (35)),
  5    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  5    12      iox_$delete_record entry (pointer, fixed bin (35)),
  5    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  5    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  5    15      iox_$err_not_attached entry options (variable),
  5    16      iox_$err_not_closed entry options (variable),
  5    17      iox_$err_no_operation entry options (variable),
  5    18      iox_$err_not_open entry options (variable),
  5    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  5    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  5    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  5    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  5    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  5    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  5    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  5    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  5    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  5    28      iox_$propagate entry (pointer),
  5    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  5    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  5    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  5    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  5    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  5    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  5    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  5    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  5    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  5    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  5    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  5    40 
  5    41 dcl (iox_$user_output,
  5    42      iox_$user_input,
  5    43      iox_$user_io,
  5    44      iox_$error_output) external static pointer;
  5    45 
  5    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      171 
      172 
  6     1 /* BEGIN INCLUDE FILE mtape_volume_status.incl.pl1. Created by J. A. Bush 02/02/83 */
  6     2 /* The include file mtape_err_stats.incl.pl1 is referenced by this include file */
  6     3 /* format: style4 */
  6     4 /* This include file defines the structures returned by the "volume_status" ("vst"),
  6     5*   and the "volume_set_status" ("vsst") control operations */
  6     6 
  6     7 dcl  vst_ptr ptr;					/* Pointer to the volume_status info structure */
  6     8 dcl  vsst_ptr ptr;					/* Pointer to the volume_set_status info structure */
  6     9 dcl  v_statp ptr;					/* Pointer to the volume status structure */
  6    10 
  6    11 dcl  vst_version_1 char (8) int static options (constant) init ("vstv0001");
  6    12 dcl  vsst_version_1 char (8) int static options (constant) init ("vsstv001");
  6    13 
  6    14 dcl  mtape_vsst_nvolumes fixed bin;			/* set this variable before allocating mtape_vsst structure */
  6    15 
  6    16 dcl  1 mtape_vst aligned based (vst_ptr),		/* "volume_status" info structure */
  6    17        2 version char (8),				/* Current version */
  6    18        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  6    19        2 v_stat like volume_status;			/* See volume_status structure below */
  6    20 
  6    21 dcl  1 mtape_vsst aligned based (vsst_ptr),		/* "volume_set_status" info structure */
  6    22        2 version char (8),				/* Current version */
  6    23        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  6    24        2 nvolumes fixed bin,				/* # of volumes in volume set */
  6    25        2 vs_stat (mtape_vsst_nvolumes refer (mtape_vsst.nvolumes)) like volume_status; /* See volume_status below */
  6    26 
  6    27 dcl  1 volume_status based (v_statp) aligned,		/* Volume status info template */
  6    28        2 volume_name char (32),			/* As specified in attach description */
  6    29        2 volume_id char (32),				/* Recorded volume name */
  6    30        2 mounted bit (1),				/* "1"b => volume currently mounted */
  6    31        2 device_name char (8),			/* Tape device on which mounted */
  6    32        2 volume_index fixed bin,			/* Order of volume within volume set */
  6    33        2 mounts fixed bin,				/* Number of times volume mounted during attachment */
  6    34        2 tot_error_stats like mtape_err_stats,		/* Summation of error statistics for all mounts */
  6    35        2 rel_error_stats like mtape_err_stats;		/* Summation of error statistics, this mount */
  6    36 
  6    37 /* END INCLUDE FILE mtape_volume_status.incl.pl1 */
      173 
      174 
  7     1 /* BEGIN INCLUDE FILE mtape_err_stats.incl.pl1. Created by J. A. Bush 07/22/83. */
  7     2 /* format: style4 */
  7     3 
  7     4 dcl  es_ptr ptr;
  7     5 
  7     6 dcl  1 mtape_err_stats aligned based (es_ptr),		/* Error statistics block */
  7     7        2 read like err_entry,				/* For read operations */
  7     8        2 write like err_entry,			/* For write operations */
  7     9        2 orders like err_entry,			/* For non-data xfer operations */
  7    10        2 successful_retry (7) fixed bin (35);		/* retrys that succeeded after 1-7 trys */
  7    11 
  7    12 dcl  1 err_entry aligned based,
  7    13        2 errors fixed bin (35),
  7    14        2 operations fixed bin (35);
  7    15 
  7    16 /* END INCLUDE FILE mtape_err_stats.incl.pl1 */
      175 
      176 
      177 
      178 /* ta_process_volume_set_ entry */
      179 
      180 	lock_entry = "1"b;
      181 
      182 	goto MAIN;
      183 
      184 /* ta_process_volume_set_$lock entry */
      185 
      186 no_lock: entry (perm_table_ptr, arg_array, table_name, code);
      187 
      188 	lock_entry = "0"b;
      189 
      190 /* Main procedure. */
      191 
      192 MAIN:
      193 
      194 /* Record usage in >site>ssudir>tape_archive.ssusage if it exists, if not this is nop */
      195 /* Each "go" request counts as one use, as it will cause tape I/O to happen */
      196 
      197 	call ssu_$standalone_invocation (sci_ptr, "tape_archive", SSU_USAGE_VERSION, null (), null (), (0));
      198 	call ssu_$record_usage (sci_ptr, codeptr (ta_process_volume_set_), (0));
      199 	call ssu_$destroy_invocation (sci_ptr);
      200 
      201 	table_ptr = perm_table_ptr;
      202 	debug_sw, tape_archive_io_info.long_sw = "0"b;
      203 	temp_seg_ptrs = null;
      204 	max_chars_in_seg = sys_info$max_seg_size * 4;
      205 	dlp = null;
      206 	query_info.version = query_info_version_5;
      207 
      208 	if my_lock_id = (36)"1"b then
      209 	     my_lock_id = get_lock_id_ ();
      210 
      211 	prev_retain_sw, retain_sw = (tape_archive_table.mount_lock = my_lock_id);
      212 
      213 	alternate_volume_set = 3 - tape_archive_table.active_set;
      214 
      215 	call iox_$find_iocb ("ta_file_output_", tape_archive_io_info.file_output_switch, code);
      216 	if code ^= 0 then call abort (code, "");
      217 
      218 	call iox_$find_iocb ("ta_file_input_", tape_archive_io_info.file_input_switch, code);
      219 	if code ^= 0 then call abort (code, "");
      220 
      221 	call iox_$find_iocb ("ta_tape_output_", tape_archive_io_info.tape_output_switch, code);
      222 	if code ^= 0 then call abort (code, "");
      223 
      224 	call iox_$find_iocb ("ta_tape_input_", tape_archive_io_info.tape_input_switch, code);
      225 	if code ^= 0 then call abort (code, "");
      226 
      227 /* Process arguments if any */
      228 
      229 	do i = 1 to dim (arg_array, 1);
      230 	     if (arg_array (i) = "-debug" | arg_array (i) = "-db") then
      231 		debug_sw, tape_archive_io_info.long_sw = "1"b; /* do things loudly on command_question and call db if failure */
      232 
      233 	     else if (arg_array (i) = "-long") | (arg_array (i) = "-lg") then
      234 		tape_archive_io_info.long_sw = "1"b;
      235 
      236 	     else if arg_array (i) = "-retain" then do;
      237 		     if i = dim (arg_array, 1) then retain_sw = "1"b;
      238 		     else do;
      239 			     i = i + 1;
      240 			     if arg_array (i) = "all" then retain_sw = "1"b;
      241 			     else if arg_array (i) = "none" then retain_sw = ""b;
      242 			     else do;
      243 				     call com_err_ (error_table_$badopt, "tape_archive", "Use -retain all or -retain none.");
      244 				     return;
      245 				end;
      246 			end;
      247 		end;
      248 
      249 	     else do;
      250 		     call com_err_ (error_table_$badopt, "tape_archive", arg_array (i));
      251 		     return;
      252 		end;
      253 	end;
      254 
      255 
      256 	this_mount_type = tape_archive_table.next_mount_type;
      257 
      258 	if this_mount_type = None then do;
      259 		if (^retain_sw &
      260 		     (tape_archive_table.mount_lock = my_lock_id)) then do; /* wants to dismount tapes */
      261 
      262 			call cleanerup;
      263 
      264 			tape_archive_table.highest_mount_type = None;
      265 			call set_lock_$unlock
      266 			     (tape_archive_table.mount_lock, 0);
      267 		     end;
      268 		else do;
      269 			code = error_table_$not_done;
      270 			call com_err_ (code, "tape_archive", "No processing is scheduled for ^a.", table_name);
      271 		     end;
      272 		return;
      273 	     end;
      274 
      275 	on cleanup call cleanerup;
      276 
      277 	call get_temp_segments_ ("tape_archive", based_temp_seg_ptrs (*), code);
      278 	if code ^= 0 then call abort (code, "");
      279 
      280 	if lock_entry
      281 	then do;
      282 		call ta_table_mgr_$lock (perm_table_ptr, table_name, Process_tape, code);
      283 		if code ^= 0 then call abort (code, "Unable to lock the table.");
      284 	     end;
      285 
      286 	call ta_table_mgr_$copy_to_temp (perm_table_ptr, tape_archive_io_info.temp_table_ptr, code);
      287 	if code ^= 0 then call abort (code, "Unable to copy the table to a temporary work area.");
      288 
      289 	table_ptr = tape_archive_io_info.temp_table_ptr;
      290 
      291 	call set_lock_$lock (tape_archive_table.mount_lock, 0, code);
      292 	if code = error_table_$lock_wait_time_exceeded then do;
      293 		call com_err_ (error_table_$vol_in_use, "tape_archive",
      294 		     "^a", table_name);
      295 		call cleanerup;
      296 		return;
      297 	     end;
      298 	if code = 0 then tape_archive_table.highest_mount_type = None;
      299 
      300 	perm_table_ptr -> tape_archive_table.mount_lock = my_lock_id;
      301 
      302 	tape_archive_table.highest_mount_type =
      303 	     max (tape_archive_table.highest_mount_type, this_mount_type);
      304 
      305 	compacting = (this_mount_type = Compact);
      306 	if compacting then i = alternate_volume_set;
      307 	else i = tape_archive_table.active_set;
      308 
      309 	if tape_info.n_volumes_in_set (i) = 0 then do;
      310 		query_info.suppress_name_sw = "1"b;
      311 		call command_query_ (addr (query_info),
      312 		     volume_string,
      313 		     "tape_archive", "Enter volume name of new first volume: ");
      314 
      315 		tape_info.volume_set (i).volume_id (1) = volume_string;
      316 
      317 		tape_info.n_volumes_in_set (i) = 1;
      318 	     end;
      319 
      320 
      321 	on command_question begin;



      322 
  8     1 /* BEGIN INCLUDE FILE:  command_question_info.incl.pl1 */
  8     2 
  8     3 /*	Last modified: 11/02/78 W. Olin Sibert to change to version 5 and make compatible with query_info */
  8     4 /* Added explanation_ptr & explanation_len (Version 6) 05/13/81 S. Herbst */
  8     5 /* switched to condition_info_header June 1981 B. Margulies */
  8     6 
  8     7 /* This include file depends on condition_info_header.incl.pl1 */
  8     8 /* It must be included as well */
  8     9 /* Added interpret_cp_escape, literal_sw, prompt_after_explanation 12/16/82 S. Herbst */
  8    10 /* Changed ("" max_)(question answer)_lth declarations to fixed bin (21) 02/08/84 S. Herbst */
  8    11 
  8    12 
  8    13 dcl 1 command_question_info based (cq_info_ptr) aligned,
  8    14     2 header aligned like condition_info_header,
  8    15     2 query_code fixed bin (35),			/* extra information supplied by caller */
  8    16     2 switches aligned,                                     /* various bit switches */
  8    17       3 question_sw bit (1) unaligned,			/* should command_query_ print the question? */
  8    18       3 yes_or_no_sw bit (1) unaligned,			/* must question be answered yes or no? */
  8    19       3 preset_sw bit (1) unaligned,			/* is handler supplying a canned answer? */
  8    20       3 answer_sw bit (1) unaligned,			/* should canned answer be printed? */
  8    21       3 allow_cp_escape bit (1) unaligned,                  /* whether to allow answers to begin with ".." */
  8    22       3 suppress_spacing bit (1) unaligned,                 /* whether to print extra newline and spaces */
  8    23       3 interpret_cp_escape bit (1) unaligned,		/* whether to treat ".." as a cp escape */
  8    24       3 literal_sw bit (1) unaligned,			/* ON => don't strip whitespace or handle ".." */
  8    25       3 prompt_after_explanation bit (1) unaligned,	/* ON => repeat question after explanation */
  8    26       3 mbz bit (27) unaligned,
  8    27     2 name_ptr pointer,				/* ptr to caller's name */
  8    28     2 name_lth fixed bin,				/* length of caller's name */
  8    29     2 question_ptr pointer,				/* ptr to quetion being asked */
  8    30     2 question_lth fixed bin (21),			/* lentgh of question */
  8    31     2 max_question_lth fixed bin (21),			/* max question lth in case handler alters question */
  8    32     2 answer_ptr pointer,				/* pointer to space to return answer in */
  8    33     2 answer_lth fixed bin (21),			/* length of returned answer */
  8    34     2 max_answer_lth fixed bin (21),			/* max space in answer space */
  8    35     2 question_iocbp ptr,				/* IO switch to ask (write) question on */
  8    36     2 answer_iocbp ptr,				/* IO switch to read the answer from */
  8    37     2 repeat_time fixed bin (71),			/* repeat question every N seconds if no answer */
  8    38     2 explanation_ptr ptr,				/* ptr to string to print if user answers "?" */
  8    39     2 explanation_len fixed bin (21);			/* length of explanation string */
  8    40 						/* if N < 30 no repeat will occur */
  8    41 
  8    42 dcl  cq_info_ptr pointer;
  8    43 
  8    44 dcl  cq_info_version_7 fixed bin internal static options (constant) init (7);
  8    45 
  8    46 /* END INCLUDE FILE:  command_question_info.incl.pl1 */
      323 
  9     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  9     2 /* format: style2 */
  9     3 
  9     4      declare condition_info_header_ptr
  9     5 			      pointer;
  9     6      declare 1 condition_info_header
  9     7 			      aligned based (condition_info_header_ptr),
  9     8 	     2 length	      fixed bin,		/* length in words of this structure */
  9     9 	     2 version	      fixed bin,		/* version number of this structure */
  9    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  9    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  9    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  9    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  9    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  9    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  9    16 	       3 pad	      bit (32) unaligned,
  9    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  9    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  9    19 
  9    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      324 
      325 
      326 dcl  cq_answer	        char (command_question_info.max_answer_lth) based (command_question_info.answer_ptr),
      327      cq_callername	        char (command_question_info.name_lth) based (command_question_info.name_ptr);
      328 dcl  yes_sw	        bit (1) aligned;



      329 
      330 
      331 		call find_condition_info_ (null, addr (cond_info), code);
      332 		if code ^= 0 then goto resignal;
      333 
      334 		cq_info_ptr = cond_info.info_ptr;
      335 
      336 		if cq_callername ^= TAPE_ARCHIVE_IO_MODULE then goto resignal;
      337 
      338 		else if command_question_info.status_code = error_table_$file_aborted then goto resignal;
      339 
      340 		else if command_question_info.status_code = error_table_$unexpired_volume then cq_answer = "yes";
      341 
      342 		else if command_question_info.status_code = error_table_$uninitialized_volume then
      343 		     if command_question_info.query_code = 3 then goto resignal; /* Valid volume but different label */
      344 		     else cq_answer = "yes";
      345 
      346 		else if command_question_info.status_code = error_table_$no_next_volume then do;
      347 			call command_query_$yes_no (yes_sw, 0, "tape_archive",
      348 			     "Volume set is now full. Another tape volume will be required to complete the current operation.",
      349 			     "End of volume reached. Do you wish to extend the volume set?");
      350 			if yes_sw then cq_answer = "no";
      351 			else cq_answer = "yes";
      352 		     end;
      353 
      354 		else if command_question_info.status_code = error_table_$unexpired_file then
      355 		     if perm_table_ptr -> tape_archive_table.incomplete_write_op_last then cq_answer = "yes";
      356 		     else if compacting then cq_answer = "yes"; /* destroy any old contents of alternate volume set */
      357 		     else do;
      358 			     call com_err_ (command_question_info.status_code, "tape_archive",
      359 				"^/There may be more recent data on the volume set than is reflected in the table.");
      360 			     call com_err_$suppress_name (0, "tape_archive",
      361 				"^5xUnless you are sure this is not the case, answer ""no"" to the following
      362 ^5xquestion and perform a ""load_table"" operation on this volume set to regain^/^5xthe most recent table.");
      363 			     goto resignal;
      364 			end;
      365 
      366 		else if command_question_info.status_code = 0 then do; /* wants name of next tape to mount */
      367 
      368 			if compacting then volume_no = 3 - tape_archive_table.active_set;
      369 			else volume_no = tape_archive_table.active_set;
      370 
      371 			reel_no = tape_archive_table.tape_info.n_volumes_in_set (volume_no) + 1;
      372 			if reel_no > dim (tape_archive_table.volume_set (1).volume_id (*), 2) then do;
      373 				code = error_table_$no_next_volume;
      374 				call com_err_ (code, "tape_archive", "Maximum volume set size exceeded.");
      375 				call abort (code, "");
      376 			     end;
      377 
      378 			call command_query_ (addr (query_info), varying_reel_id,
      379 			     "tape_archive", "Enter name of new volume to be appended to the volume set: ");
      380 
      381 			tape_info.n_volumes_in_set (volume_no) = reel_no;
      382 			cq_answer, tape_info.volume_set (volume_no).volume_id (reel_no) = varying_reel_id;
      383 		     end;
      384 
      385 		command_question_info.question_sw,
      386 		     command_question_info.answer_sw = debug_sw;
      387 						/* blab only if user wants to know */
      388 		command_question_info.answer_lth = index (cq_answer, " ") - 1;
      389 		command_question_info.preset_sw = "1"b;
      390 
      391 		goto endblock;
      392 
      393 resignal:		call continue_to_signal_ (0);
      394 
      395 endblock:	     end;					/* of begin block, command_question handler */
      396 
      397 
      398 /* Make lists of input and output volume sets. */
      399 
      400 	do i = tape_archive_table.active_set, alternate_volume_set;
      401 	     call ioa_$rsnnl ("^v(^a ^)", tape_out_volume_string, 0,
      402 		tape_archive_table.n_volumes_in_set (i), tape_archive_table.volume_set (i).volume_id (*));
      403 	     if i = tape_archive_table.active_set then tape_in_volume_string = tape_out_volume_string;
      404 	end;
      405 
      406 /* Mount necessary volume sets. */
      407 
      408 /* Always try to attach the input switch (mount the active volume set)
      409*   because the table might indicate that the user has retained when he
      410*   really hasn't. */
      411 
      412 	call attach_switch (tape_archive_io_info.tape_input_switch,
      413 	     tape_in_volume_string, tape_archive_table.active_set,
      414 	     (this_mount_type = Write | retain_sw), code);
      415 	if code = error_table_$not_detached & prev_retain_sw
      416 	then ;
      417 	else if code = error_table_$bad_mount_request
      418 	then call abort (code, "Drive unavailable.");
      419 	else if code ^= 0
      420 	then call abort (code, "Unable to mount active volume set.");
      421 
      422 /* Now attach the output switch, if necessary. */
      423 
      424 	if this_mount_type >= Write
      425 	then do;
      426 		if compacting
      427 		then do;
      428 			call attach_switch (tape_archive_io_info.tape_output_switch,
      429 			     tape_out_volume_string, alternate_volume_set,
      430 			     compacting, code);
      431 			if code = error_table_$not_detached
      432 			then ;
      433 			else if code = error_table_$bad_mount_request
      434 			then call abort (code, "Drive unavailable.");
      435 			else if code ^= 0
      436 			then call abort (code, "Unable to mount alternate volume set.");
      437 		     end;
      438 		else tape_archive_io_info.tape_output_switch = tape_archive_io_info.tape_input_switch;
      439 	     end;
      440 
      441 /* Find the correct open description templates for the tape input and
      442*   output switches.  In conversion to mtape_ -create and -clear have
      443*   been left out of the open descriptions because their jobs are implicitly
      444*   done by mtape_. */
      445 
      446 	call ioa_$rsnnl ("-format ^[sb^;vbs^] -block 8192 -mode ^^a -name ^^a -number ^^d",
      447 	     tape_archive_io_info.input_opd_template, 0, (tape_archive_table.io_module_name = "tape_ansi_"));
      448 
      449 	if this_mount_type >= Write
      450 	then call ioa_$rsnnl ("-expires 12/31/99 -format ^[sb^;vbs^] -block 8192 -mode ^^a -record ^d -name ^^a -number ^^d",
      451 		tape_archive_io_info.output_opd_template, 0, (tape_archive_table.io_module_name = "tape_ansi_"), sys_info$max_seg_size * 4);
      452 	else tape_archive_io_info.output_opd_template = "";
      453 
      454 /* Perform deletions */
      455 
      456 	cur_time = substr (bit (clock ()), 20, 36);
      457 
      458 	do i = 1 to tape_archive_table.n_component_slots;
      459 
      460 	     component_ptr = addr (component_table (i));
      461 
      462 	     if component.valid then
      463 		if component.date_time_deleted then do;
      464 			component.valid = ""b;
      465 			component.date_time_deleted = cur_time;
      466 			tape_archive_table.n_components = tape_archive_table.n_components - 1;
      467 			if tape_archive_io_info.long_sw then
      468 			     call ioa_ ("Deleting component ^a", component.entry_name);
      469 		     end;
      470 
      471 	end;
      472 
      473 /* All deletions are done, now do the extractions */
      474 
      475 	if this_mount_type >= Read then do;
      476 		if compacting then
      477 		     tape_archive_table.last_tape_file_no,
      478 			tape_archive_table.last_table_no,
      479 			tape_archive_table.total_records,
      480 			tape_archive_table.dead_records = 0;
      481 
      482 		if retain_sw then do;		/* mark the table so we remember */
      483 			perm_table_ptr -> tape_archive_table.mount_lock
      484 			     = tape_archive_table.mount_lock;
      485 						/* the tapes stay up regardless of invocation-specific errors */
      486 			perm_table_ptr -> tape_archive_table.highest_mount_type
      487 			     = tape_archive_table.highest_mount_type;
      488 		     end;
      489 
      490 		do i = 1 to tape_archive_table.n_component_slots;
      491 
      492 		     component_ptr = addr (component_table (i));
      493 
      494 		     if component.valid then
      495 			if component.associated_request_index > 0 then
      496 			     if request_queue (component.associated_request_index).extract then do;
      497 				     j = component.associated_request_index;
      498 				     call ta_file_io_$extract (table_ptr, i, addr (tape_archive_io_info), code);
      499 				     if code = 1
      500 				     then ;	/* special case: cancel deletion, msg already issued */
      501 				     else if code ^= 0
      502 				     then call com_err_ (code, "tape_archive", "^a could not be extracted ^[and was not deleted^].",
      503 					     component.entry_name, request_queue (j).delete);
      504 				     else do;	/* extraction ok, check if deletion requested */
      505 					     if request_queue (j).delete then do;
      506 						     component.valid = ""b;
      507 						     component.date_time_deleted = cur_time;
      508 						     tape_archive_table.n_components = tape_archive_table.n_components - 1;
      509 						     if tape_archive_io_info.long_sw then
      510 							call ioa_ ("Deleting component ^a", component.entry_name);
      511 						     request_queue (j).delete = ""b; /* tell cancel_request_no extract/delete ok */
      512 						end;
      513 					end;
      514 				     call ta_table_mgr_$cancel_request_no (table_ptr, j, code);
      515 				     call ta_table_mgr_$cancel_request_no (perm_table_ptr, j, code);
      516 						/* file successfully extracted, might as well note it in perm table */
      517 				end;
      518 			     else ;		/* must be a replace pending, don't copy it */
      519 			else if compacting then do;
      520 				call ta_file_io_$compact (table_ptr, i, addr (tape_archive_io_info), code);
      521 				if code ^= 0
      522 				then if code = error_table_$no_file
      523 				     then do;
      524 					call com_err_ (code, "tape_archive",
      525 					     "Unable to read ^a from the original tape, it will not appear on the compacted tape.",
      526 					     component.entry_status_descriptor.file_info.entry_name);
      527 					component.entry_status_descriptor.valid = "0"b;
      528 					component.date_time_deleted = cur_time;
      529 					tape_archive_table.n_components = tape_archive_table.n_components - 1;
      530 					end;
      531 				     else call abort (code, "");
      532 			     end;
      533 		end;
      534 	     end;
      535 
      536 /* All the extractions are done, now do the replacements and appendings. */
      537 
      538 	if this_mount_type >= Write then do;
      539 
      540 
      541 		set_incomplete_bit = "1"b;
      542 
      543 /* The incomplete_write_op_last will be set the first time we successfully
      544*   append something.  This is a hedge in case the user or system crashes
      545*   before table is consistent again.  What this means is that the tape may
      546*   very well have files on the end which are not reflected in the table.  When
      547*   we re-run this table, the tape I/O module will ask whether we want to
      548*   destroy these unexpired files.  If the bit is on, we say yes.  On the other
      549*   hand, if someone's online table gets backed-up (an earlier version
      550*   retrieved), the same situation will occur, and this bit being off will tell
      551*   us that the tape is probably MORE recent than the table, and that the user
      552*   must take remedial action (a load_table or a reconstruct op) to recover
      553*   without losing data.  */
      554 
      555 
      556 		system_free_ptr = get_system_free_area_ ();
      557 		allocate delete_list set (dlp) in (system_free_area);
      558 
      559 		do i = 1 to tape_archive_table.n_request_slots;
      560 
      561 		     request_ptr = addr (request_queue (i));
      562 
      563 		     if request.valid then do;
      564 			     call ta_file_io_$append (table_ptr, i, addr (tape_archive_io_info), code);
      565 			     if code = error_table_$unexpired_file
      566 			     then do;
      567 				     call com_err_ (code, "tape_archive", "Terminating processing of this volume.");
      568 				     call cleanerup;
      569 				     return;
      570 				end;
      571 			     else if code ^= 0
      572 			     then do;
      573 				     call com_err_ (code, "tape_archive", "^a>^a could not be appended to volume set; removing request.",
      574 					request.directory_name, request.entry_name);
      575 				     call ta_table_mgr_$cancel_request_no (table_ptr, i, code);
      576 						/* remove request; if "rdf" specified, we don't want to delete it! */
      577 				end;
      578 			     else do;		/* successful append */
      579 				     if request.delete then do;
      580 					     delete_list.n_entries, j = delete_list.n_entries + 1;
      581 					     delete_list.dirname (j) = request.directory_name;
      582 					     delete_list.ename (j) = request.entry_name;
      583 					     delete_list.uid (j) = request.uid;
      584 					     delete_list.force (j) = request.force;
      585 					end;
      586 				     if set_incomplete_bit then do;
      587 					     tape_archive_table.incomplete_write_op_last = "1"b;
      588 					     perm_table_ptr -> tape_archive_table.incomplete_write_op_last = "1"b;
      589 					     set_incomplete_bit = ""b;
      590 					end;
      591 				end;
      592 			end;
      593 		end;
      594 	     end;
      595 
      596 
      597 	tape_has_changed = compacting | tape_archive_table.incomplete_write_op_last; /* next call resets incomplete_write_op_last */
      598 	call ta_table_mgr_$finish_requests (table_ptr, code);
      599 	if tape_archive_table.n_components = 0 then
      600 	     call ioa_ ("tape_archive: All components of ^a have been deleted.", table_name);
      601 
      602 	if tape_has_changed then do;			/* here, output the table to tape */
      603 		tape_archive_table.mount_lock = ""b;	/* wouldn't do to have locked table on tape */
      604 		call ta_file_io_$append_table (table_ptr, addr (tape_archive_io_info), code);
      605 		if code ^= 0 then call abort (code, "");
      606 	     end;
      607 
      608 /* Copy the new table into permanent storage */
      609 
      610 	if (tape_archive_table.highest_mount_type >= Read &
      611 	     retain_sw) then
      612 	     tape_archive_table.mount_lock = my_lock_id;	/* don't bother with set_lock_, it's in the [pd] */
      613 	else tape_archive_table.mount_lock = ""b;	/*  note we no longer have volumes retained */
      614 
      615 	call ta_table_mgr_$copy_to_perm (tape_archive_io_info.temp_table_ptr, perm_table_ptr, code);
      616 	if code ^= 0 then call abort (code, "");
      617 
      618 	if dlp ^= null then
      619 	     do i = 1 to delete_list.n_entries;
      620 		if delete_list.uid (i) = tape_archive_table.perm_table_uid then /* avoid disaster */
      621 		     call ioa_ ("tape_archive: Deletion of active table ^a has been suppressed.", table_name);
      622 		else do;
      623 			if tape_archive_io_info.long_sw then
      624 			     call ioa_ ("Deleting ^a>^a.", delete_list.dirname (i), delete_list.ename (i));
      625 			call delete_$path (delete_list.dirname (i), delete_list.ename (i), delete_list.force (i) || "11111"b,
      626 			     "tape_archive", code);	/* force if asked, otherwise delete anything that moves,
      627*						   and chase links. */
      628 			if code ^= 0 then
      629 			     call com_err_ (code, "tape_archive", "Unable to delete ^a>^a.",
      630 				delete_list.dirname (i), delete_list.ename (i));
      631 		     end;
      632 	     end;
      633 
      634 	table_ptr = perm_table_ptr;
      635 
      636 	call cleanerup;
      637 	return;
      638 
      639 cleanerup: proc;
      640 
      641 	call dismount_tapes (perm_table_ptr, retain_sw, code);
      642 
      643 	if (^retain_sw | (retain_sw & code ^= 0)) & perm_table_ptr -> tape_archive_table.lock = get_lock_id_ ()
      644 	then do;
      645 		perm_table_ptr -> tape_archive_table.highest_mount_type = None;
      646 		call set_lock_$unlock (perm_table_ptr -> tape_archive_table.mount_lock, code);
      647 	     end;
      648 
      649 	if lock_entry
      650 	then call ta_table_mgr_$unlock (perm_table_ptr, code);
      651 
      652 	call release_temp_segments_ ("tape_archive", based_temp_seg_ptrs (*), code);
      653 
      654 	if dlp ^= null then free delete_list in (system_free_area);
      655 
      656 	return;
      657      end cleanerup;





      658 
      659 abort: proc (code, msg) options (non_quick);
      660 
      661 /* Parameter */
      662 
      663 dcl  code		        fixed bin (35);
      664 dcl  msg		        char (*);
      665 
      666 	call com_err_ (code, "tape_archive", msg);
      667 	if debug_sw then do;
      668 		call ioa_ ("Calling debug...");
      669 		call debug;
      670 	     end;
      671 	call cleanerup;
      672 	goto returner;
      673      end abort;
      674 
      675 returner: return;
      676 
      677 
      678 
      679 dismount: entry (perm_table_ptr, a_retain_sw, code);
      680 
      681 	retain_sw = a_retain_sw;
      682 
      683 	call iox_$find_iocb ("ta_tape_output_", tape_archive_io_info.tape_output_switch, code);
      684 	if code ^= 0 then call abort (code, "");
      685 
      686 	call iox_$find_iocb ("ta_tape_input_", tape_archive_io_info.tape_input_switch, code);
      687 	if code ^= 0 then call abort (code, "");
      688 
      689 	call dismount_tapes (perm_table_ptr, retain_sw, code);
      690 
      691 	if ^(retain_sw | (retain_sw & code ^= 0)) & perm_table_ptr -> tape_archive_table.lock = get_lock_id_ ()
      692 	then do;
      693 		perm_table_ptr -> tape_archive_table.highest_mount_type
      694 		     = None;
      695 		call set_lock_$unlock
      696 		     (perm_table_ptr -> tape_archive_table.mount_lock, 0);
      697 	     end;
      698 
      699 	code = 0;
      700 	return;
      701 
      702 
      703 
      704 
      705 /* This procedure dismounts the volume sets by detaching the
      706*   tape input and output switches.
      707*
      708*   If -retain was specified somewhere along the way,
      709*   dismount_tapes tries to do the right thing.  It first
      710*   checks to see if the tape input and output switches need adjustment.
      711*   Tape_archive likes the tape input switch to talk about the active
      712*   volume set.  If for example, we have just done a compaction, this will
      713*   not be the case and we will have to adjust the switches.  If the switches
      714*   cannot be properly adjusted, nothing will be retained.  Otherwise,
      715*   the active set and possibly the alternate set (if used) are
      716*   retained (i.e., the tape input and output switches are left attached).
      717*
      718*   Also, we want to take our best shot at dismounting the tapes so we don't
      719*   just return when we get a nonzero error code, we try to keep going.
      720*   We do, however, save the first interesting error code we get and return
      721*   it when we are done. */
      722 
      723 dismount_tapes: proc (perm_table_ptr, retain_sw, code);
      724 
      725 /* Automatic */
      726 
      727 dcl  temp_code	        fixed bin (35);
      728 
      729 /* Parameter */
      730 
      731 dcl  code		        fixed bin (35);
      732 dcl  retain_sw	        bit (1) aligned;
      733 dcl  perm_table_ptr	        ptr;
      734 
      735 	if retain_sw
      736 	then do;
      737 		call adjust_switches (perm_table_ptr, retain_sw, code);
      738 		if code = 0
      739 		then return;
      740 	     end;
      741 
      742 	call iox_$detach_iocb (tape_archive_io_info.tape_input_switch, temp_code);
      743 	call save_code (temp_code, code);
      744 
      745 	call iox_$detach_iocb (tape_archive_io_info.tape_output_switch, temp_code);
      746 	if temp_code = error_table_$not_attached
      747 	then ;
      748 	else call save_code (temp_code, code);
      749 
      750      end dismount_tapes;
      751 
      752 
      753 save_code: proc (code1, code2);
      754 
      755 /* Parameter */
      756 
      757 dcl  code1	        fixed bin (35);
      758 dcl  code2	        fixed bin (35);
      759 
      760 	if code2 = 0
      761 	then code2 = code1;
      762 
      763      end save_code;
      764 
      765 
      766 /* This procedure makes sure that the tape input switch is talking
      767*   about the active volume set.  If this is not the case (an example
      768*   is, just after a compaction), it will adjust the switches. */
      769 
      770 adjust_switches: proc (perm_table_ptr, retain_sw, code);
      771 
      772 /* Automatic */
      773 
      774 dcl  active_vol_set_ptr     ptr;
      775 dcl  input_sw	        ptr;
      776 dcl  n_active_vols	        fixed bin;
      777 dcl  output_sw	        ptr;
      778 dcl  temp_iocb_ptr	        ptr;
      779 dcl  vol_name_len	        fixed bin (21);
      780 dcl  which_set	        fixed bin;
      781 
      782 /* Parameter */
      783 
      784 dcl  code		        fixed bin (35);
      785 dcl  retain_sw	        bit (1) aligned;
      786 dcl  perm_table_ptr	        ptr;
      787 
      788 /* Based */
      789 
      790 dcl  active_vol_set	        (n_active_vols) char (vol_name_len) aligned based (active_vol_set_ptr);
      791 
      792 	code = 0;
      793 
      794 	input_sw = tape_archive_io_info.tape_input_switch;
      795 	output_sw = tape_archive_io_info.tape_output_switch;
      796 
      797 /* Check to see if we need to adjust at all.  If we aren't retaining or
      798*   if we haven't compacted it is not necessary to adjust the switches.
      799*   Just return. */
      800 
      801 	if ^retain_sw
      802 	then do;
      803 		code = error_table_$action_not_performed;
      804 		return;
      805 	     end;
      806 
      807 	if perm_table_ptr -> tape_archive_table.highest_mount_type < Compact
      808 	then return;
      809 
      810 	if input_sw = output_sw
      811 	then return;				/* Compaction occurred, but not this time around. */
      812 
      813 /* Looks like we need to adjust the switches.  Get information
      814*   on the volume set assocated with the tape output switch and the
      815*   volume set that we consider to be the active volume set. */
      816 
      817 	vsst_ptr = null;
      818 
      819 	call iox_$control (output_sw, "volume_set_status", vsst_ptr, code);
      820 	if code = error_table_$not_attached /* Compaction occurred, but not this time around. */
      821 	then do;
      822 		code = 0;
      823 		return;
      824 	     end;
      825 	else if code ^= 0
      826 	then return;
      827 
      828 	if mtape_vsst.version ^= vsst_version_1
      829 	then do;
      830 		code = error_table_$unimplemented_version;
      831 		return;
      832 	     end;
      833 
      834 	which_set = perm_table_ptr -> tape_archive_table.active_set;
      835 	n_active_vols = perm_table_ptr -> tape_archive_table.n_volumes_in_set (which_set);
      836 	vol_name_len = length (perm_table_ptr -> tape_archive_table.volume_set (which_set).volume_id (1));
      837 	active_vol_set_ptr = addr (perm_table_ptr -> tape_archive_table.volume_set (which_set));
      838 
      839 /* If the active set is associated with the tape output switch,
      840*   move it to the tape input switch and the alternate to the
      841*   tape output switch. */
      842 
      843 	if same_volume_set (mtape_vsst.vs_stat.volume_name (*), active_vol_set (*))
      844 	then do;					/* Need adjustment */
      845 		call iox_$find_iocb ("ta_temp_iocb_", temp_iocb_ptr, code);
      846 		if code ^= 0
      847 		then return;
      848 		call iox_$move_attach (output_sw, temp_iocb_ptr, code);
      849 		if code ^= 0
      850 		then return;
      851 		call iox_$move_attach (input_sw, output_sw, code);
      852 		if code ^= 0
      853 		then return;
      854 		call iox_$move_attach (temp_iocb_ptr, input_sw, code);
      855 		if code ^= 0
      856 		then return;
      857 	     end;
      858 
      859 	free mtape_vsst;
      860 
      861      end adjust_switches;
      862 
      863 
      864 same_volume_set: proc (set_1, set_2) returns (bit (1) aligned);
      865 
      866 /* Parameter */
      867 
      868 dcl  set_1	        (*) char (*) aligned;
      869 dcl  set_2	        (*) char (*) aligned;
      870 
      871 /* Automatic */
      872 
      873 dcl  n_set_1	        fixed bin;
      874 dcl  n_set_2	        fixed bin;
      875 
      876 	n_set_1 = hbound (set_1, 1);
      877 	n_set_2 = hbound (set_2, 1);
      878 
      879 	do i = 1 by 1 while (i <= n_set_1 & i <= n_set_2 & set_1 (i) = set_2 (i));
      880 	end;
      881 
      882 	return (i > n_set_1 & i > n_set_2);
      883 
      884      end same_volume_set;
      885 
      886 
      887 
      888 /* This procedure determines the necessary attach description with the given
      889*   information.  It then tries to attach the specified I/O switch with
      890*   the attach description. */
      891 
      892 attach_switch: proc (iocb_ptr, vol_list_str, vol_set_num, write_sw, code);
      893 
      894 /* Parameter */
      895 
      896 dcl  code		        fixed bin (35);
      897 dcl  iocb_ptr	        ptr;
      898 dcl  vol_list_str	        char (*);
      899 dcl  vol_set_num	        fixed bin;
      900 dcl  write_sw	        bit (1) aligned;
      901 
      902 /* Automatic */
      903 
      904 dcl  atd		        char (520);
      905 
      906 	atd = "";
      907 
      908 	call ioa_$rsnnl ("^a ^a -volume_type ^[ansi^;ibm^] -density ^d ^[-ring^;^]", atd, 0,
      909 	     TAPE_ARCHIVE_IO_MODULE, vol_list_str,
      910 	     (tape_archive_table.io_module_name = "tape_ansi_"), tape_archive_table.density (vol_set_num),
      911 	     write_sw);
      912 
      913 	call iox_$attach_ptr (iocb_ptr, atd, codeptr (ta_process_volume_set_), code);
      914 
      915      end attach_switch;
      916 
      917 
      918      end ta_process_volume_set_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/25/85  1508.3  ta_process_volume_set_.pl1        >special_ldd>online>41-12>ta_process_volume_set_.pl1
159          1    02/16/84  1452.4  tape_archive_table_dcl.incl.pl1   >ldd>include>tape_archive_table_dcl.incl.pl1
162          2    02/16/84  1452.4  tape_archive_io_info.incl.pl1     >ldd>include>tape_archive_io_info.incl.pl1
166          3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
169          4    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
171          5    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
173          6    02/16/84  1452.4  mtape_volume_status.incl.pl1      >ldd>include>mtape_volume_status.incl.pl1
175          7    02/16/84  1452.3  mtape_err_stats.incl.pl1          >ldd>include>mtape_err_stats.incl.pl1
323          8    02/27/84  1141.9  command_question_info.incl.pl1    >ldd>include>command_question_info.incl.pl1
324          9    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Compact                                constant        fixed bin(17,0)          initial dcl 1-114 ref 305 807
None                                   constant        fixed bin(17,0)          initial dcl 1-114 ref 258 264 298 645 693
Process_tape                    000100 constant        fixed bin(17,0)          initial dcl 1-114 set ref 282*
Read                                   constant        fixed bin(17,0)          initial dcl 1-114 ref 475 610
SSU_USAGE_VERSION               000004 constant        char(11)                 initial unaligned dcl 52 set ref 192*
TAPE_ARCHIVE_IO_MODULE          000002 constant        char(6)                  initial unaligned dcl 1-114 set ref 336 908*
Write                                  constant        fixed bin(17,0)          initial dcl 1-114 ref 412 424 449 538
a_retain_sw                            parameter       bit(1)                   dcl 55 ref 679 681
active_set               65            based           fixed bin(17,0)          level 4 dcl 1-14 set ref 213 307 368 369 400 403
                                                                                  412* 834
active_vol_set                         based           char                     array dcl 790 set ref 843*
active_vol_set_ptr              000116 automatic       pointer                  dcl 774 set ref 837* 843
addr                                                   builtin function         dcl 86 ref 277 311 311 331 331 378 378 460 492 498
                                                                                  498 520 520 561 564 564 604 604 652 837
alternate_volume_set            000100 automatic       fixed bin(17,0)          dcl 63 set ref 213* 306 400 428*
answer_iocbp              6     001126 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
answer_lth              122            based           fixed bin(21,0)          level 2 dcl 8-13 set ref 388*
answer_ptr              120            based           pointer                  level 2 dcl 8-13 ref 340 344 350 351 354 356 382 388
answer_sw               106(03)        based           bit(1)                   level 3 packed unaligned dcl 8-13 set ref 385*
arg_array                              parameter       char(168)                array unaligned dcl 55 set ref 19 186 229 230 230
                                                                                  233 233 236 237 240 241 250*
associated_request_index
                         41            based           fixed bin(17,0)          level 2 dcl 1-53 ref 494 494 497
atd                             001166 automatic       char(520)                unaligned dcl 904 set ref 906* 908* 913*
based_temp_seg_ptrs                    based           pointer                  array dcl 2-17 set ref 277* 652*
bit                                                    builtin function         dcl 86 ref 456
cleanup                         000434 stack reference condition                dcl 145 ref 275
clock                                                  builtin function         dcl 86 ref 456
code                                   parameter       fixed bin(35,0)          dcl 731 in procedure "dismount_tapes" set ref 723
                                                                                  737* 738 743* 748*
code                                   parameter       fixed bin(35,0)          dcl 55 in procedure "ta_process_volume_set_" set ref
                                                                                  19 186 215* 216 216* 218* 219 219* 221* 222 222*
                                                                                  224* 225 225* 269* 270* 277* 278 278* 282* 283
                                                                                  283* 286* 287 287* 291* 292 298 331* 332 373* 374*
                                                                                  375* 412* 415 417 417* 419 419* 428* 431 433 433*
                                                                                  435 435* 498* 499 501 501* 514* 515* 520* 521 521
                                                                                  524* 531* 564* 565 567* 571 573* 575* 598* 604*
                                                                                  605 605* 615* 616 616* 625* 628 628* 641* 643 646*
                                                                                  649* 652* 679 683* 684 684* 686* 687 687* 689* 691
                                                                                  699*
code                                   parameter       fixed bin(35,0)          dcl 663 in procedure "abort" set ref 659 666*
code                                   parameter       fixed bin(35,0)          dcl 896 in procedure "attach_switch" set ref 892
                                                                                  913*
code                                   parameter       fixed bin(35,0)          dcl 784 in procedure "adjust_switches" set ref 770
                                                                                  792* 803* 819* 820 822* 825 830* 845* 846 848* 849
                                                                                  851* 852 854* 855
code1                                  parameter       fixed bin(35,0)          dcl 757 ref 753 760
code2                                  parameter       fixed bin(35,0)          dcl 758 set ref 753 760 760*
codeptr                                                builtin function         dcl 86 ref 198 198 913 913
com_err_                        000052 constant        entry                    external dcl 114 ref 243 250 270 293 358 374 501 524
                                                                                  567 573 628 666
com_err_$suppress_name          000054 constant        entry                    external dcl 114 ref 360
command_query_                  000056 constant        entry                    external dcl 114 ref 311 378
command_query_$yes_no           000060 constant        entry                    external dcl 114 ref 347
command_question                000426 stack reference condition                dcl 145 ref 321
command_question_info                  based           structure                level 1 dcl 8-13
compacting                      000101 automatic       bit(1)                   dcl 63 set ref 305* 306 356 368 426 428* 476 519 597
component                              based           structure                level 1 dcl 1-53
component_ptr                   000444 automatic       pointer                  dcl 1-112 set ref 460* 462 462 464 465 467 492* 494
                                                                                  494 494 497 501 506 507 509 524 527 528
component_table        1330            based           structure                array level 3 dcl 1-14 set ref 460 492
cond_info                       001074 automatic       structure                level 1 dcl 167 set ref 331 331
condition_info                         based           structure                level 1 dcl 3-14
condition_info_header                  based           structure                level 1 dcl 9-6
continue_to_signal_             000062 constant        entry                    external dcl 114 ref 393
cp_escape_control         1(02) 001126 automatic       bit(2)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
cq_answer                              based           char                     unaligned dcl 326 set ref 340* 344* 350* 351* 354*
                                                                                  356* 382* 388
cq_callername                          based           char                     unaligned dcl 326 ref 336
cq_info_ptr                     000100 automatic       pointer                  dcl 8-42 set ref 334* 336 336 338 340 340 340 342
                                                                                  342 344 344 346 350 350 351 351 354 354 354 356
                                                                                  356 358 366 382 382 385 385 388 388 388 389
cur_time                        000102 automatic       bit(36)                  dcl 63 set ref 456* 465 507 528
date_time_deleted        42            based           bit(36)                  level 2 dcl 1-53 set ref 462 465* 507* 528*
dead_records             50            based           fixed bin(35,0)          level 3 dcl 1-14 set ref 476*
debug                           000064 constant        entry                    external dcl 114 ref 669
debug_sw                        000103 automatic       bit(1)                   dcl 63 set ref 202* 230* 385 667
delete                                 based           bit(1)                   array level 5 in structure "tape_archive_table"
                                                                                  packed unaligned dcl 1-14 in procedure
                                                                                  "ta_process_volume_set_" set ref 501* 505 511*
delete                  112(03)        based           bit(1)                   level 3 in structure "request" packed unaligned
                                                                                  dcl 1-60 in procedure "ta_process_volume_set_" ref
                                                                                  579
delete_$path                    000066 constant        entry                    external dcl 114 ref 625
delete_list                            based           structure                level 1 dcl 149 set ref 557 654
density                  64            based           fixed bin(17,0)          array level 4 packed unaligned dcl 1-14 set ref 908*
dim                                                    builtin function         dcl 86 ref 229 237 372
directory_name           40            based           char(168)                level 2 packed unaligned dcl 1-60 set ref 573* 581
dirname                   1            based           char(168)                array level 3 packed unaligned dcl 149 set ref 581*
                                                                                  623* 625* 628*
dlp                             000104 automatic       pointer                  dcl 63 set ref 205* 557* 580 580 581 582 583 584 618
                                                                                  618 620 623 623 625 625 625 628 628 654 654
ename                    54            based           char(32)                 array level 3 packed unaligned dcl 149 set ref 582*
                                                                                  623* 625* 628*
entries                   1            based           structure                array level 2 dcl 149
entry_name                6            based           char(32)                 level 4 in structure "component" packed unaligned
                                                                                  dcl 1-53 in procedure "ta_process_volume_set_" set
                                                                                  ref 467* 501* 509* 524*
entry_name                6            based           char(32)                 level 4 in structure "request" packed unaligned
                                                                                  dcl 1-60 in procedure "ta_process_volume_set_" set
                                                                                  ref 573* 582
entry_status_descriptor                based           structure                level 2 in structure "request" dcl 1-60 in procedure
                                                                                  "ta_process_volume_set_"
entry_status_descriptor                based           structure                level 1 dcl 1-74 in procedure
                                                                                  "ta_process_volume_set_"
entry_status_descriptor                based           structure                level 2 in structure "component" dcl 1-53
                                                                                  in procedure "ta_process_volume_set_"
err_entry                              based           structure                level 1 dcl 7-12
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 94 ref 803
error_table_$bad_mount_request  000014 external static fixed bin(35,0)          dcl 94 ref 417 433
error_table_$badopt             000016 external static fixed bin(35,0)          dcl 94 set ref 243* 250*
error_table_$file_aborted       000020 external static fixed bin(35,0)          dcl 94 ref 338
error_table_$lock_wait_time_exceeded
                                000022 external static fixed bin(35,0)          dcl 94 ref 292
error_table_$no_file            000024 external static fixed bin(35,0)          dcl 94 ref 521
error_table_$no_next_volume     000026 external static fixed bin(35,0)          dcl 94 ref 346 373
error_table_$not_attached       000030 external static fixed bin(35,0)          dcl 94 ref 746 820
error_table_$not_detached       000032 external static fixed bin(35,0)          dcl 94 ref 415 431
error_table_$not_done           000034 external static fixed bin(35,0)          dcl 94 ref 269
error_table_$unexpired_file     000036 external static fixed bin(35,0)          dcl 94 ref 354 565
error_table_$unexpired_volume   000040 external static fixed bin(35,0)          dcl 94 ref 340
error_table_$unimplemented_version
                                000042 external static fixed bin(35,0)          dcl 94 ref 830
error_table_$uninitialized_volume
                                000044 external static fixed bin(35,0)          dcl 94 ref 342
error_table_$vol_in_use         000046 external static fixed bin(35,0)          dcl 94 set ref 293*
explanation_len          14     001126 automatic       fixed bin(21,0)          initial level 2 dcl 4-7 set ref 4-7*
explanation_ptr          12     001126 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
extract                                based           bit(1)                   array level 5 packed unaligned dcl 1-14 set ref 494
file_info                 1            based           structure                level 3 in structure "component" dcl 1-53
                                                                                  in procedure "ta_process_volume_set_"
file_info                 1            based           structure                level 3 in structure "request" dcl 1-60 in procedure
                                                                                  "ta_process_volume_set_"
file_input_switch       410     000450 automatic       pointer                  level 2 dcl 161 set ref 218*
file_output_switch      412     000450 automatic       pointer                  level 2 dcl 161 set ref 215*
find_condition_info_            000070 constant        entry                    external dcl 114 ref 331
force                   112(04)        based           bit(1)                   level 3 in structure "request" packed unaligned
                                                                                  dcl 1-60 in procedure "ta_process_volume_set_" ref
                                                                                  584
force                    64            based           bit(1)                   array level 3 in structure "delete_list" dcl 149
                                                                                  in procedure "ta_process_volume_set_" set ref 584*
                                                                                  625
get_lock_id_                    000072 constant        entry                    external dcl 114 ref 208 643 691
get_system_free_area_           000074 constant        entry                    external dcl 114 ref 556
get_temp_segments_              000076 constant        entry                    external dcl 114 ref 277
hbound                                                 builtin function         dcl 86 ref 876 877
header                                 based           structure                level 2 dcl 8-13
highest_mount_type       55            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 264* 298* 302* 302 486* 486
                                                                                  610 645* 693* 807
i                               000110 automatic       fixed bin(17,0)          dcl 63 set ref 229* 230 230 233 233 236 237 239* 239
                                                                                  240 241 250* 306* 307* 309 315 317 400* 401 401
                                                                                  403* 458* 460* 490* 492 498* 520* 559* 561 564*
                                                                                  575* 618* 620 623 623 625 625 625 628 628* 879*
                                                                                  879 879 879 879* 882 882
incomplete_write_op_last
                         51            based           bit(1)                   level 3 dcl 1-14 set ref 354 587* 588* 597
index                                                  builtin function         dcl 86 ref 388
info_ptr                 14     001074 automatic       pointer                  level 2 dcl 167 set ref 334
input_opd_template        2     000450 automatic       char(520)                level 2 dcl 161 set ref 446*
input_sw                        000120 automatic       pointer                  dcl 775 set ref 794* 810 851* 854*
io_module_name           20            based           char(32)                 level 3 dcl 1-14 ref 446 449 908
ioa_                            000100 constant        entry                    external dcl 114 ref 467 509 599 620 623 668
ioa_$rsnnl                      000102 constant        entry                    external dcl 114 ref 401 446 449 908
iocb_ptr                               parameter       pointer                  dcl 897 set ref 892 913*
iox_$attach_ptr                 000144 constant        entry                    external dcl 5-8 ref 913
iox_$control                    000146 constant        entry                    external dcl 5-8 ref 819
iox_$detach_iocb                000150 constant        entry                    external dcl 5-8 ref 742 745
iox_$find_iocb                  000152 constant        entry                    external dcl 5-8 ref 215 218 221 224 683 686 845
iox_$move_attach                000154 constant        entry                    external dcl 5-8 ref 848 851 854
j                               000111 automatic       fixed bin(17,0)          dcl 63 set ref 497* 501 505 511 514* 515* 580* 581
                                                                                  582 583 584
last_table_no            53            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 476*
last_tape_file_no        52            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 476*
literal_sw                1(05) 001126 automatic       bit(1)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
lock                      6            based           bit(36)                  level 3 dcl 1-14 ref 643 691
lock_entry                      000112 automatic       bit(1)                   dcl 63 set ref 180* 188* 280 649
long_sw                 422     000450 automatic       bit(1)                   level 2 dcl 161 set ref 202* 230* 233* 467 509 623
max                                                    builtin function         dcl 86 ref 302
max_answer_lth          123            based           fixed bin(21,0)          level 2 dcl 8-13 ref 340 344 350 351 354 356 382 388
max_chars_in_seg                000113 automatic       fixed bin(21,0)          dcl 63 set ref 204*
mount_lock               54            based           bit(36)                  level 3 dcl 1-14 set ref 211 259 265* 291* 300* 483*
                                                                                  483 603* 610* 613* 646* 695*
msg                                    parameter       char                     unaligned dcl 664 set ref 659 666*
mtape_err_stats                        based           structure                level 1 dcl 7-6
mtape_vsst                             based           structure                level 1 dcl 6-21 set ref 859
my_lock_id                      000010 internal static bit(36)                  initial dcl 90 set ref 208 208* 211 259 300 610
n_active_vols                   000122 automatic       fixed bin(17,0)          dcl 776 set ref 835* 843
n_component_slots        41            based           fixed bin(17,0)          level 3 dcl 1-14 ref 458 490 494 501 505 511 561
n_components             40            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 466* 466 508* 508 529* 529
                                                                                  599
n_entries                              based           fixed bin(17,0)          initial level 2 dcl 149 set ref 557* 580 580* 618
n_queued_requests        42            based           fixed bin(17,0)          level 3 dcl 1-14 ref 557 654
n_request_slots          43            based           fixed bin(17,0)          level 3 dcl 1-14 ref 559
n_set_1                         000140 automatic       fixed bin(17,0)          dcl 873 set ref 876* 879 882
n_set_2                         000141 automatic       fixed bin(17,0)          dcl 874 set ref 877* 879 882
n_volumes_in_set         66            based           fixed bin(17,0)          array level 4 dcl 1-14 set ref 309 317* 371 381*
                                                                                  401* 835
name_lth                112            based           fixed bin(17,0)          level 2 dcl 8-13 ref 336
name_ptr                110            based           pointer                  level 2 dcl 8-13 ref 336
next_mount_type          44            based           fixed bin(17,0)          level 3 dcl 1-14 ref 256
nonvolatile_part                       based           structure                level 2 dcl 1-14
null                                                   builtin function         dcl 86 ref 192 192 192 192 203 205 618 4-7 4-7 4-7
                                                                                  331 331 654 817
nvolumes                  3            based           fixed bin(17,0)          level 2 dcl 6-21 ref 843 859
output_opd_template     206     000450 automatic       char(520)                level 2 dcl 161 set ref 449* 452*
output_sw                       000124 automatic       pointer                  dcl 777 set ref 795* 810 819* 848* 851*
padding                   1(07) 001126 automatic       bit(29)                  initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
perm_table_ptr                         parameter       pointer                  dcl 55 in procedure "ta_process_volume_set_" set ref
                                                                                  19 186 201 282* 286* 300 354 483 486 515* 588 615*
                                                                                  634 641* 643 645 646 649* 679 689* 691 693 695
perm_table_ptr                         parameter       pointer                  dcl 786 in procedure "adjust_switches" ref 770 807
                                                                                  834 835 836 837
perm_table_ptr                         parameter       pointer                  dcl 733 in procedure "dismount_tapes" set ref 723
                                                                                  737*
perm_table_uid           31            based           bit(36)                  level 3 dcl 1-14 ref 620
preset_sw               106(02)        based           bit(1)                   level 3 packed unaligned dcl 8-13 set ref 389*
prev_retain_sw                  000114 automatic       bit(1)                   dcl 63 set ref 211* 415
prompt_after_explanation
                          1(06) 001126 automatic       bit(1)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
query_code              105            based           fixed bin(35,0)          level 2 in structure "command_question_info"
                                                                                  dcl 8-13 in on unit on line 321 ref 342
query_code                3     001126 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "ta_process_volume_set_" set ref 4-7*
query_info                      001126 automatic       structure                level 1 dcl 4-7 set ref 311 311 378 378
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 4-35 ref 206
question_iocbp            4     001126 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
question_sw             106            based           bit(1)                   level 3 packed unaligned dcl 8-13 set ref 385*
reel_no                         000115 automatic       fixed bin(17,0)          dcl 63 set ref 371* 372 381 382
release_temp_segments_          000104 constant        entry                    external dcl 114 ref 652
repeat_time              10     001126 automatic       fixed bin(71,0)          initial level 2 dcl 4-7 set ref 4-7*
request                                based           structure                level 1 dcl 1-60
request_ptr                     000446 automatic       pointer                  dcl 1-112 set ref 561* 563 573 573 579 581 582 583
                                                                                  584
request_queue                          based           structure                array level 3 dcl 1-14 set ref 561
requested_ops                          based           structure                array level 4 in structure "tape_archive_table"
                                                                                  packed unaligned dcl 1-14 in procedure
                                                                                  "ta_process_volume_set_"
requested_ops           112            based           structure                level 2 in structure "request" packed unaligned
                                                                                  dcl 1-60 in procedure "ta_process_volume_set_"
retain_sw                              parameter       bit(1)                   dcl 732 in procedure "dismount_tapes" set ref 723
                                                                                  735 737*
retain_sw                              parameter       bit(1)                   dcl 785 in procedure "adjust_switches" ref 770 801
retain_sw                       000116 automatic       bit(1)                   dcl 63 in procedure "ta_process_volume_set_" set ref
                                                                                  211* 237* 240* 241* 259 412 482 610 641* 643 643
                                                                                  681* 689* 691 691
sci_ptr                         000106 automatic       pointer                  dcl 63 set ref 192* 198* 199*
set_1                                  parameter       char                     array dcl 868 ref 864 876 879
set_2                                  parameter       char                     array dcl 869 ref 864 877 879
set_incomplete_bit              000117 automatic       bit(1)                   dcl 63 set ref 541* 586 589*
set_lock_$lock                  000106 constant        entry                    external dcl 114 ref 291
set_lock_$unlock                000110 constant        entry                    external dcl 114 ref 265 646 695
ssu_$destroy_invocation         000116 constant        entry                    external dcl 114 ref 199
ssu_$record_usage               000112 constant        entry                    external dcl 114 ref 198
ssu_$standalone_invocation      000114 constant        entry                    external dcl 114 ref 192
status_code             104            based           fixed bin(35,0)          level 3 in structure "command_question_info"
                                                                                  dcl 8-13 in on unit on line 321 set ref 338 340
                                                                                  342 346 354 358* 366
status_code               2     001126 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "ta_process_volume_set_" set ref 4-7*
substr                                                 builtin function         dcl 86 ref 456
suppress_name_sw          1(01) 001126 automatic       bit(1)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  310* 4-7*
suppress_spacing          1(04) 001126 automatic       bit(1)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
switches                106            based           structure                level 2 in structure "command_question_info"
                                                                                  dcl 8-13 in on unit on line 321
switches                  1     001126 automatic       structure                level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "ta_process_volume_set_"
sys_info$max_seg_size           000050 external static fixed bin(35,0)          dcl 110 ref 204 449
system_free_area                       based           area(1024)               dcl 157 ref 557 654
system_free_ptr                 000120 automatic       pointer                  dcl 63 set ref 556* 557 654
ta_file_io_$append              000120 constant        entry                    external dcl 131 ref 564
ta_file_io_$append_table        000122 constant        entry                    external dcl 131 ref 604
ta_file_io_$compact             000124 constant        entry                    external dcl 131 ref 520
ta_file_io_$extract             000126 constant        entry                    external dcl 131 ref 498
ta_table_mgr_$cancel_request_no 000130 constant        entry                    external dcl 131 ref 514 515 575
ta_table_mgr_$copy_to_perm      000132 constant        entry                    external dcl 131 ref 615
ta_table_mgr_$copy_to_temp      000134 constant        entry                    external dcl 131 ref 286
ta_table_mgr_$finish_requests   000136 constant        entry                    external dcl 131 ref 598
ta_table_mgr_$lock              000140 constant        entry                    external dcl 131 ref 282
ta_table_mgr_$unlock            000142 constant        entry                    external dcl 131 ref 649
table_name                             parameter       char                     unaligned dcl 55 set ref 19 186 270* 282* 293* 599*
                                                                                  620*
table_ptr                       000442 automatic       pointer                  dcl 1-112 set ref 201* 211 213 256 259 264 265 289*
                                                                                  291 298 302 302 307 309 315 317 368 369 371 372
                                                                                  381 382 400 401 401 403 412 446 449 458 460 466
                                                                                  466 476 476 476 476 483 486 490 492 494 498* 501
                                                                                  505 508 508 511 514* 520* 529 529 557 559 561 564*
                                                                                  575* 587 597 598* 599 603 604* 610 610 613 620
                                                                                  634* 654 908 908
tape_archive_io_info            000450 automatic       structure                level 1 dcl 161 set ref 498 498 520 520 564 564 604
                                                                                  604
tape_archive_table                     based           structure                level 1 dcl 1-14
tape_has_changed                000122 automatic       bit(1)                   dcl 63 set ref 597* 602
tape_in_volume_string           000123 automatic       char(264)                unaligned dcl 63 set ref 403* 412*
tape_info                64            based           structure                level 3 dcl 1-14
tape_input_switch               000450 automatic       pointer                  level 2 dcl 161 set ref 224* 412* 438 686* 742* 794
tape_out_volume_string          000225 automatic       char(264)                unaligned dcl 63 set ref 401* 403 428*
tape_output_switch      204     000450 automatic       pointer                  level 2 dcl 161 set ref 221* 428* 438* 683* 745* 795
temp_code                       000100 automatic       fixed bin(35,0)          dcl 727 set ref 742* 743* 745* 746 748*
temp_iocb_ptr                   000126 automatic       pointer                  dcl 778 set ref 845* 848* 854*
temp_seg_ptrs           414     000450 automatic       structure                level 2 dcl 161 set ref 203* 277 652
temp_table_ptr          420     000450 automatic       pointer                  level 3 dcl 161 set ref 286* 289 615*
this_mount_type                 000327 automatic       fixed bin(17,0)          dcl 63 set ref 256* 258 302 305 412 424 449 475 538
total_records            47            based           fixed bin(35,0)          level 3 dcl 1-14 set ref 476*
uid                      53            based           bit(36)                  array level 3 in structure "delete_list" dcl 149
                                                                                  in procedure "ta_process_volume_set_" set ref 583*
                                                                                  620
uid                      36            based           bit(36)                  level 3 in structure "request" dcl 1-60 in procedure
                                                                                  "ta_process_volume_set_" ref 583
valid                                  based           bit(1)                   level 3 in structure "request" packed unaligned
                                                                                  dcl 1-60 in procedure "ta_process_volume_set_" ref
                                                                                  563
valid                                  based           bit(1)                   level 3 in structure "component" packed unaligned
                                                                                  dcl 1-53 in procedure "ta_process_volume_set_" set
                                                                                  ref 462 464* 494 506* 527*
varying_reel_id                 000330 automatic       varying char(168)        dcl 63 set ref 378* 382
version                         001126 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "ta_process_volume_set_" set ref 206*
version                                based           char(8)                  level 2 in structure "mtape_vsst" dcl 6-21
                                                                                  in procedure "ta_process_volume_set_" ref 828
vol_list_str                           parameter       char                     unaligned dcl 898 set ref 892 908*
vol_name_len                    000130 automatic       fixed bin(21,0)          dcl 779 set ref 836* 843 843 843
vol_set_num                            parameter       fixed bin(17,0)          dcl 899 ref 892 908
volatile_part            40            based           structure                level 2 dcl 1-14
volume_id                70            based           char(168)                array level 5 dcl 1-14 set ref 315* 372 382* 401*
                                                                                  836
volume_name               4            based           char(32)                 array level 3 dcl 6-21 set ref 843*
volume_no                       000403 automatic       fixed bin(17,0)          dcl 63 set ref 368* 369* 371 381 382
volume_set               70            based           structure                array level 4 dcl 1-14 set ref 837
volume_status                          based           structure                level 1 dcl 6-27
volume_string                   000404 automatic       varying char(64)         dcl 63 set ref 311* 315
vs_stat                   4            based           structure                array level 2 dcl 6-21
vsst_ptr                        001144 automatic       pointer                  dcl 6-8 set ref 817* 819* 828 843 859
vsst_version_1                  000000 constant        char(8)                  initial unaligned dcl 6-12 ref 828
which_set                       000131 automatic       fixed bin(17,0)          dcl 780 set ref 834* 835 836 837
write_sw                               parameter       bit(1)                   dcl 900 set ref 892 908*
yes_or_no_sw              1     001126 automatic       bit(1)                   initial level 3 packed unaligned dcl 4-7 set ref
                                                                                  4-7*
yes_sw                          000102 automatic       bit(1)                   dcl 328 set ref 347* 350

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Cancellation                           internal static fixed bin(17,0)          initial dcl 1-114
Default_density                        internal static fixed bin(17,0)          initial dcl 1-114
Delete                                 internal static fixed bin(17,0)          initial dcl 1-114
Deletion                               internal static fixed bin(17,0)          initial dcl 1-114
Deletion_cancellation                  internal static fixed bin(17,0)          initial dcl 1-114
Examine                                internal static fixed bin(17,0)          initial dcl 1-114
Extraction                             internal static fixed bin(17,0)          initial dcl 1-114
Lock_reasons                           internal static char(24)                 initial array unaligned dcl 1-114
Magic_constant                         internal static char(8)                  initial unaligned dcl 1-114
Magic_workspace_constant               internal static char(8)                  initial unaligned dcl 1-114
Modify                                 internal static fixed bin(17,0)          initial dcl 1-114
Replacement                            internal static fixed bin(17,0)          initial dcl 1-114
Table_copy                             internal static fixed bin(17,0)          initial dcl 1-114
Table_creation                         internal static fixed bin(17,0)          initial dcl 1-114
Volume_alteration                      internal static fixed bin(17,0)          initial dcl 1-114
based_tape_info                        based           structure                level 1 dcl 1-110
condition_info_header_ptr              automatic       pointer                  dcl 9-4
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
cq_info_version_7                      internal static fixed bin(17,0)          initial dcl 8-44
es_ptr                                 automatic       pointer                  dcl 7-4
iox_$attach_loud                000000 constant        entry                    external dcl 5-8
iox_$attach_name                000000 constant        entry                    external dcl 5-8
iox_$close                      000000 constant        entry                    external dcl 5-8
iox_$close_file                 000000 constant        entry                    external dcl 5-8
iox_$delete_record              000000 constant        entry                    external dcl 5-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 5-8
iox_$detach                     000000 constant        entry                    external dcl 5-8
iox_$err_no_operation           000000 constant        entry                    external dcl 5-8
iox_$err_not_attached           000000 constant        entry                    external dcl 5-8
iox_$err_not_closed             000000 constant        entry                    external dcl 5-8
iox_$err_not_open               000000 constant        entry                    external dcl 5-8
iox_$error_output                      external static pointer                  dcl 5-41
iox_$find_iocb_n                000000 constant        entry                    external dcl 5-8
iox_$get_chars                  000000 constant        entry                    external dcl 5-8
iox_$get_line                   000000 constant        entry                    external dcl 5-8
iox_$look_iocb                  000000 constant        entry                    external dcl 5-8
iox_$modes                      000000 constant        entry                    external dcl 5-8
iox_$open                       000000 constant        entry                    external dcl 5-8
iox_$open_file                  000000 constant        entry                    external dcl 5-8
iox_$position                   000000 constant        entry                    external dcl 5-8
iox_$propagate                  000000 constant        entry                    external dcl 5-8
iox_$put_chars                  000000 constant        entry                    external dcl 5-8
iox_$read_key                   000000 constant        entry                    external dcl 5-8
iox_$read_length                000000 constant        entry                    external dcl 5-8
iox_$read_record                000000 constant        entry                    external dcl 5-8
iox_$rewrite_record             000000 constant        entry                    external dcl 5-8
iox_$seek_key                   000000 constant        entry                    external dcl 5-8
iox_$user_input                        external static pointer                  dcl 5-41
iox_$user_io                           external static pointer                  dcl 5-41
iox_$user_output                       external static pointer                  dcl 5-41
iox_$write_record               000000 constant        entry                    external dcl 5-8
mtape_vsst_nvolumes                    automatic       fixed bin(17,0)          dcl 6-14
mtape_vst                              based           structure                level 1 dcl 6-16
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 4-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 4-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 4-36
ta_file_io_$dismount            000000 constant        entry                    external dcl 131
tape_archive_version_4                 internal static fixed bin(17,0)          initial dcl 1-114
tape_info_ptr                          automatic       pointer                  dcl 1-112
v_statp                                automatic       pointer                  dcl 6-9
vst_ptr                                automatic       pointer                  dcl 6-7
vst_version_1                          internal static char(8)                  initial unaligned dcl 6-11
workspace                              based           structure                level 1 dcl 1-93
workspace_ptr                          automatic       pointer                  dcl 1-112

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN                            001061 constant        label                    dcl 192 ref 182
abort                           005521 constant        entry                    internal dcl 659 ref 216 219 222 225 278 283 287 375
                                                                                  417 419 433 435 531 605 616 684 687
adjust_switches                 005731 constant        entry                    internal dcl 770 ref 737
attach_switch                   006351 constant        entry                    internal dcl 892 ref 412 428
cleanerup                       005345 constant        entry                    internal dcl 639 ref 262 275 295 568 636 671
dismount                        005133 constant        entry                    external dcl 679
dismount_tapes                  005620 constant        entry                    internal dcl 723 ref 641 689
endblock                        003065 constant        label                    dcl 395 ref 391
no_lock                         001041 constant        entry                    external dcl 186
resignal                        003055 constant        label                    dcl 393 ref 332 336 338 342 363
returner                        005126 constant        label                    dcl 675 ref 672
same_volume_set                 006247 constant        entry                    internal dcl 864 ref 843
save_code                       005722 constant        entry                    internal dcl 753 ref 743 748
ta_process_volume_set_          001015 constant        entry                    external dcl 19 ref 198 198 913 913

NAME DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 836

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7356        7534    6511        7366
Length     10266    6511       156         515     644           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ta_process_volume_set_              906 external procedure  is an external procedure.  
on unit on line 275                  64 on unit               
on unit on line 321                 187 on unit               
cleanerup                            90 internal procedure  is called by several nonquick procedures.  
abort                                90 internal procedure  is declared options(non_quick).  
dismount_tapes                      152 internal procedure  is called by several nonquick procedures.  
save_code                               internal procedure  shares stack frame of internal procedure dismount_tapes.  
adjust_switches                         internal procedure  shares stack frame of internal procedure dismount_tapes.  
same_volume_set                         internal procedure  shares stack frame of internal procedure dismount_tapes.  
attach_switch                           internal procedure  shares stack frame of external procedure ta_process_volume_set_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 my_lock_id                  ta_process_volume_set_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dismount_tapes           000100 temp_code                   dismount_tapes
                         000116 active_vol_set_ptr          adjust_switches
                         000120 input_sw                    adjust_switches
                         000122 n_active_vols               adjust_switches
                         000124 output_sw                   adjust_switches
                         000126 temp_iocb_ptr               adjust_switches
                         000130 vol_name_len                adjust_switches
                         000131 which_set                   adjust_switches
                         000140 n_set_1                     same_volume_set
                         000141 n_set_2                     same_volume_set
on unit on line 321      000100 cq_info_ptr                 on unit on line 321
                         000102 yes_sw                      on unit on line 321
ta_process_volume_set_   000100 alternate_volume_set        ta_process_volume_set_
                         000101 compacting                  ta_process_volume_set_
                         000102 cur_time                    ta_process_volume_set_
                         000103 debug_sw                    ta_process_volume_set_
                         000104 dlp                         ta_process_volume_set_
                         000106 sci_ptr                     ta_process_volume_set_
                         000110 i                           ta_process_volume_set_
                         000111 j                           ta_process_volume_set_
                         000112 lock_entry                  ta_process_volume_set_
                         000113 max_chars_in_seg            ta_process_volume_set_
                         000114 prev_retain_sw              ta_process_volume_set_
                         000115 reel_no                     ta_process_volume_set_
                         000116 retain_sw                   ta_process_volume_set_
                         000117 set_incomplete_bit          ta_process_volume_set_
                         000120 system_free_ptr             ta_process_volume_set_
                         000122 tape_has_changed            ta_process_volume_set_
                         000123 tape_in_volume_string       ta_process_volume_set_
                         000225 tape_out_volume_string      ta_process_volume_set_
                         000327 this_mount_type             ta_process_volume_set_
                         000330 varying_reel_id             ta_process_volume_set_
                         000403 volume_no                   ta_process_volume_set_
                         000404 volume_string               ta_process_volume_set_
                         000442 table_ptr                   ta_process_volume_set_
                         000444 component_ptr               ta_process_volume_set_
                         000446 request_ptr                 ta_process_volume_set_
                         000450 tape_archive_io_info        ta_process_volume_set_
                         001074 cond_info                   ta_process_volume_set_
                         001126 query_info                  ta_process_volume_set_
                         001144 vsst_ptr                    ta_process_volume_set_
                         001166 atd                         attach_switch

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return              tra_ext
enable              shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
alloc_based         free_based          clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        command_query_                command_query_$yes_no
continue_to_signal_           debug                         delete_$path                  find_condition_info_
get_lock_id_                  get_system_free_area_         get_temp_segments_            ioa_
ioa_$rsnnl                    iox_$attach_ptr               iox_$control                  iox_$detach_iocb
iox_$find_iocb                iox_$move_attach              release_temp_segments_        set_lock_$lock
set_lock_$unlock              ssu_$destroy_invocation       ssu_$record_usage             ssu_$standalone_invocation
ta_file_io_$append            ta_file_io_$append_table      ta_file_io_$compact           ta_file_io_$extract
ta_table_mgr_$cancel_request_no                             ta_table_mgr_$copy_to_perm    ta_table_mgr_$copy_to_temp
ta_table_mgr_$finish_requests ta_table_mgr_$lock            ta_table_mgr_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_mount_request
error_table_$badopt           error_table_$file_aborted     error_table_$lock_wait_time_exceeded
error_table_$no_file          error_table_$no_next_volume   error_table_$not_attached     error_table_$not_detached
error_table_$not_done         error_table_$unexpired_file   error_table_$unexpired_volume
error_table_$unimplemented_version                          error_table_$uninitialized_volume
error_table_$vol_in_use       sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 4    7 000756        19 001010       180 001034       182 001036       186 001037       188 001060       192 001061
    198 001125       199 001143       201 001152       202 001156       203 001160       204 001164       205 001170
    206 001172       208 001174       211 001205       213 001214       215 001217       216 001243       218 001261
    219 001306       221 001324       222 001351       224 001367       225 001414       229 001432       230 001447
    233 001477       236 001512       237 001516       239 001530       240 001531       241 001545       243 001553
    244 001604       247 001605       250 001606       251 001640       253 001641       256 001643       258 001646
    259 001647       262 001656       264 001662       265 001665       267 001677       269 001700       270 001703
    272 001741       275 001742       277 001764       278 002012       280 002030       282 002032       283 002061
    286 002102       287 002116       289 002137       291 002141       292 002156       293 002162       295 002217
    296 002223       298 002224       300 002231       302 002236       305 002244       306 002250       307 002254
    309 002256       310 002260       311 002262       315 002320       317 002330       321 002334       331 002350
    332 002370       334 002373       336 002375       338 002404       340 002410       342 002420       344 002425
    346 002433       347 002435       350 002501       351 002513       352 002521       354 002522       356 002537
    358 002550       360 002600       363 002632       364 002633       366 002634       368 002636       369 002646
    371 002651       372 002654       373 002656       374 002660       375 002710       378 002726       381 002767
    382 002774       383 003023       385 003024       388 003040       389 003052       391 003054       393 003055
    395 003065       400 003066       401 003073       403 003136       404 003145       412 003153       415 003214
    417 003223       419 003245       424 003266       426 003271       428 003274       431 003324       433 003331
    435 003353       437 003374       438 003375       446 003377       449 003436       452 003510       456 003513
    458 003522       460 003533       462 003537       464 003544       465 003546       466 003550       467 003553
    471 003600       475 003602       476 003605       482 003615       483 003620       486 003626       490 003630
    492 003641       494 003645       497 003670       498 003672       499 003711       501 003715       505 004000
    506 004017       507 004021       508 004024       509 004026       511 004053       514 004071       515 004104
    518 004120       519 004121       520 004124       521 004143       524 004150       527 004205       528 004207
    529 004212       530 004215       531 004216       533 004232       538 004234       541 004237       556 004241
    557 004250       559 004261       561 004271       563 004302       564 004305       565 004324       567 004330
    568 004360       569 004364       571 004365       573 004367       575 004430       577 004443       579 004444
    580 004450       581 004454       582 004462       583 004467       584 004472       586 004477       587 004501
    588 004504       589 004510       593 004511       597 004513       598 004520       599 004531       602 004556
    603 004560       604 004562       605 004577       610 004615       613 004630       615 004631       616 004645
    618 004663       620 004677       623 004731       625 004765       628 005036       632 005113       634 005115
    636 005121       637 005125       675 005126       679 005127       681 005144       683 005150       684 005175
    686 005213       687 005240       689 005256       691 005271       693 005324       695 005330       699 005342
    700 005343       639 005344       641 005352       643 005367       645 005423       646 005427       649 005440
    652 005455       654 005504       656 005517       659 005520       666 005534       667 005562       668 005565
    669 005602       671 005607       672 005614       723 005617       735 005625       737 005631       738 005643
    742 005646       743 005660       745 005671       746 005703       748 005710       750 005721       753 005722
    760 005724       763 005730       770 005731       792 005733       794 005734       795 005737       801 005742
    803 005745       804 005750       807 005751       810 005757       817 005764       819 005767       820 006022
    822 006027       823 006030       825 006031       828 006034       830 006042       831 006044       834 006045
    835 006051       836 006053       837 006055       843 006061       845 006130       846 006156       848 006162
    849 006175       851 006201       852 006214       854 006220       855 006233       859 006237       861 006246
    864 006247       876 006265       877 006270       879 006273       880 006335       882 006337       892 006351
    906 006362       908 006365       913 006451       915 006500


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
