	COMPILATION LISTING OF SEGMENT rlm_get_approximate_count
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1139.64_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         Returns an approximate count depending on the entry.  The two
       11*     entries are:
       12*     
       13*     $get_population:
       14*         Returns  an  approximate  count of the tuples in the given relation.
       15*     The count returned is the number of keys in the primary index as kept  in
       16*     the key_count_array.
       17*
       18*     $get_duplicate_key_count:
       19*          Returns  an  approximate  count of the duplicate keys in the given 
       20*     index. The count returned depends on the number of fields in a key that
       21*     must be duplicated in order for the key to be considered a duplicate
       22*     (p_number_of_dulication_fields). This information is kept in the index's
       23*     key_count_array.
       24**/
       25 
       26 /* HISTORY:
       27*
       28*Written by Matthew Pierret, 08/10/83.
       29*Modified:
       30*09/13/83 by Matthew Pierret:  Changed calling sequence to take a pointer to a
       31*            relation_cursor instead of an opening_id.
       32*            Changed name to rlm_get_approximate_count and added the
       33*            $get_population and $get_duplicate_key_count entries.  The latter
       34*            formerly existed in rlm_general_search.
       35*06/22/84 by Matthew Pierret: Added a cleanup handler to call FINISH, a sub_err_
       36*            call to report an improper entry into the routine, and subroutine
       37*            prefix on each CHECK_VERSION variable.
       38*10/29/84 by Lindsey L. Spratt:  Changed to use version 2 of the
       39*            key_count_array.
       40*11/12/84 by Stanford S. Cox:  Chg to return a minimum tuple count of 1.
       41*03/05/85 by Lindsey L. Spratt:  Fixed to guarantee that the key count returend
       42*            (p_tuple_count) is always non-negative, and is no greater than one
       43*            less than the total (approx.)  tuple count (key_count_idx = 0).
       44**/
       45 /* format: style2,ind3 */
       46 
       47 /* format: style2,ind3 */
       48 
       49 rlm_get_approximate_count$get_population:
       50    proc (p_relation_cursor_ptr, p_tuple_count, p_code);
       51 
       52 
       53 /* START OF DECLARATIONS */
       54 /* Parameter */
       55 
       56       dcl	    p_relation_cursor_ptr  ptr parameter;	/* points to relation_cursor */
       57       dcl	    p_index_collection_id  bit (36) aligned parameter;
       58 						/* is the collection id of an index from which to get counts */
       59       dcl	    p_number_of_duplication_fields
       60 			       fixed bin (17) parameter;
       61       dcl	    p_tuple_count	       fixed bin (35) parameter;
       62 						/* approximate number of tuples in relation */
       63       dcl	    p_code	       fixed bin (35) parameter;
       64 						/* standard error code*/
       65 
       66 /* Automatic */
       67 
       68       dcl	    code		       fixed bin (35);
       69       dcl	    index_idx	       fixed bin;
       70       dcl	    key_count_idx	       fixed bin;
       71       dcl	    (get_population, get_duplicate_key_count)
       72 			       bit (1) aligned;
       73       dcl	    index_collection_id    bit (36) aligned;
       74       dcl	    index_cursor_ptr       ptr init (null);
       75 
       76 /* Based */
       77 /* Builtin */
       78 
       79       dcl	    null		       builtin;
       80 
       81 /* Condition */
       82 
       83       dcl	    cleanup	       condition;
       84 
       85 /* Constant */
       86 
       87       dcl	    myname	       init ("rlm_get_approximate_count") char (32) varying internal static
       88 			       options (constant);
       89       dcl	    TOTAL_KEY_COUNT_INDICATOR
       90 			       init (-1) fixed bin (17) internal static options (constant);
       91 
       92 /* Entry */
       93 
       94       dcl	    get_dm_free_area_      entry () returns (ptr);
       95       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
       96       dcl	    sub_err_	       entry () options (variable);
       97 
       98 /* External */
       99 
      100       dcl	    dm_error_$programming_error
      101 			       fixed bin (35) ext;
      102       dcl	    error_table_$unimplemented_version
      103 			       fixed bin (35) ext;
      104 
      105 /* Static */
      106 
      107       dcl	    work_area_ptr	       ptr internal static init (null);
      108 
      109 /* END OF DECLARATIONS */
      110 
      111 /* get_population:
      112*   entry (p_relation_cursor_ptr, p_tuple_count, p_code);
      113**/
      114       get_population = "1"b;
      115       get_duplicate_key_count = "0"b;
      116       key_count_idx = 0;
      117       goto JOIN;
      118 
      119 get_duplicate_key_count:
      120    entry (p_relation_cursor_ptr, p_index_collection_id, p_number_of_duplication_fields, p_tuple_count, p_code);
      121 
      122       get_population = "0"b;
      123       get_duplicate_key_count = "1"b;
      124       if p_number_of_duplication_fields = TOTAL_KEY_COUNT_INDICATOR
      125       then key_count_idx = 0;
      126       else key_count_idx = p_number_of_duplication_fields;
      127       goto JOIN;
      128 
      129 JOIN:
      130       p_tuple_count, p_code = 0;
      131 
      132       relation_cursor_ptr = p_relation_cursor_ptr;
      133       call CHECK_VERSION (relation_cursor.version, RELATION_CURSOR_VERSION_2, "relation_cursor");
      134 
      135       key_count_array_ptr, index_cursor_ptr = null;
      136 
      137       if get_duplicate_key_count
      138       then index_collection_id = p_index_collection_id;
      139       else
      140          do;
      141 
      142 	  /*** Set up opening info. Only the index_attribute_map is needed. */
      143 
      144 	  call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, code);
      145 	  if code ^= 0
      146 	  then call ERROR_RETURN (code);
      147 	  call CHECK_VERSION (relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2, "relation_opening_info");
      148 	  index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      149 	  call CHECK_VERSION (index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2, "index_attribute_map");
      150 
      151 /**** Get collection id of first index.  */
      152 
      153 	  do index_idx = 1 to hbound (index_attribute_map.index, 1)
      154 	       while (index_attribute_map.index (index_idx).collection_id = "0"b
      155 	       | index_attribute_map.index (index_idx).number_of_attributes <= 0);
      156 	  end;
      157 	  if index_idx > hbound (index_attribute_map.index, 1)
      158 	  then call ERROR_RETURN (0);
      159 
      160 	  index_collection_id = index_attribute_map.index (index_idx).collection_id;
      161          end;
      162 
      163       if work_area_ptr = null
      164       then work_area_ptr = get_dm_free_area_ ();
      165 
      166       on cleanup call FINISH ();
      167 
      168 /**** Get a pointer to an index_cursor to use in calling index_manager_ */
      169 
      170       if relation_cursor.flags.current_state_is_consistent & relation_cursor.current.cursor_ptr ^= null
      171 	 & relation_cursor.current.collection_id = index_collection_id
      172       then index_cursor_ptr = relation_cursor.current.cursor_ptr;
      173 						/* already have index_cursor */
      174       else
      175          do;
      176 
      177 	  /*** Create an index_cursor to use in calling index_manager_. */
      178 
      179 	  call index_manager_$create_cursor (relation_cursor.file_opening_id, index_collection_id, work_area_ptr,
      180 	       index_cursor_ptr, code);
      181 	  if code ^= 0
      182 	  then call ERROR_RETURN (code);
      183          end;
      184 
      185 /**** Get the count */
      186 
      187       call index_manager_$get_key_count_array (index_cursor_ptr, work_area_ptr, key_count_array_ptr, code);
      188       if code ^= 0
      189       then call ERROR_RETURN (code);
      190 
      191       call CHECK_VERSION (key_count_array.version, KEY_COUNT_ARRAY_VERSION_2, "key_count_array");
      192 
      193 /* The following is done as a kluge to get around a problem with the key counts
      194*where the key counts can be negative, or equal to the tuple 
      195*count (key_count_idx = 0), due to the unprotected nature of the key counts.
      196*(Neither of these cases would happen if the key counts were maintained in a
      197*protected fashion.)
      198*
      199*This code guarantees that the count returned is always at least zero, and if
      200*greater than zero, no more than one less than the full tuple count.
      201**/
      202 
      203       if key_count_idx = 0
      204       then p_tuple_count = key_count_array.count (0);
      205       else p_tuple_count = min (key_count_array.count (key_count_idx), key_count_array.count (0) - 1);
      206       p_tuple_count = max (0, p_tuple_count);
      207 
      208       call FINISH ();
      209 MAIN_RETURN:
      210       return;
      211 
      212 ERROR_RETURN:
      213    proc (er_code);
      214 
      215       dcl	    er_code	       fixed bin (35);
      216 
      217       p_code = er_code;
      218       call FINISH ();
      219       goto MAIN_RETURN;
      220 
      221    end ERROR_RETURN;
      222 
      223 
      224 FINISH:
      225    proc ();
      226 
      227       if index_cursor_ptr ^= null & index_cursor_ptr ^= relation_cursor.current.cursor_ptr
      228       then call index_manager_$destroy_cursor (index_cursor_ptr, (0));
      229 
      230       if key_count_array_ptr ^= null
      231       then free key_count_array;
      232 
      233    end FINISH;
      234 
      235 CHECK_VERSION:
      236    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      237       dcl	    cv_p_received_version  char (8) aligned parameter;
      238       dcl	    cv_p_expected_version  char (8) aligned parameter;
      239       dcl	    cv_p_structure_name    char (*);
      240 
      241       if cv_p_received_version ^= cv_p_expected_version
      242       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      243 	      "^/Expected version ^a of the ^a structure.
      244 Received version ^d instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      245 
      246    end CHECK_VERSION;
      247 
  1     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*Written by Matthew Pierret, 05/19/83. 
  1     6*Modified:
  1     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  1     8*            structure, to add the search_index_and_record_collection flag.
  1     9*            This flag is only meaningful when doing a relative search.  It is
  1    10*            used by rlm_general_search to know what state the
  1    11*            internal_search_specification was left in (suitable for searching
  1    12*            the index or suitable for searching the records).
  1    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  1    15**/
  1    16 
  1    17 /* format: style2,ind3 */
  1    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  1    19 	     2 version	      char (8),		/* version of this structure */
  1    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  1    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  1    22 						/* opening id of file in which relation resides */
  1    23 	     2 flags	      aligned,
  1    24 	       3 current_state_is_consistent
  1    25 			      bit (1) unal init ("0"b),
  1    26 						/* On if all values in current are insynch */
  1    27 	       3 mbz	      bit (35) unal init ("0"b),
  1    28 						/* must be zero */
  1    29 	     2 current,				/* current position in search */
  1    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  1    31 						/* in relation_search_specification */
  1    32 	       3 flags	      aligned,
  1    33 	         4 search_index_and_record_collection
  1    34 			      bit (1) unal init ("0"b),
  1    35 	         4 mbz	      bit (35) unal init ("0"b),
  1    36 	       3 collection_id    bit (36) aligned init ("0"b),
  1    37 						/* that cursor is define over */
  1    38 	       3 specification_ptr
  1    39 			      ptr init (null),	/* points to index or record specification */
  1    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  1    41 
  1    42      dcl	   relation_cursor_ptr    ptr init (null);
  1    43      dcl	   RELATION_CURSOR_VERSION_2
  1    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  1    45 
  1    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
      248 
      249 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  2     2 
  2     3 /* Written by Matthew Pierret, 09/08/82. 
  2     4*Modified:
  2     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  2     6*            transaction_id.
  2     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  2     8*            relation_info).
  2     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    10**/
  2    11 
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_opening_info
  2    16 			      aligned based (relation_opening_info_ptr),
  2    17 	     2 version	      char (8),
  2    18 	     2 per_process,
  2    19 	       3 current_transaction_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	       3 current_rollback_count
  2    22 			      fixed bin (35) init (0),
  2    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  2    24 	       3 number_of_openings
  2    25 			      fixed bin (17) aligned init (0),
  2    26 	       3 lock_advice      aligned,
  2    27 	         4 this_process   bit (2) unaligned init ("0"b),
  2    28 	         4 other_processes
  2    29 			      bit (2) unaligned init ("0"b),
  2    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  2    31 	       3 record_cursor_ptr
  2    32 			      ptr init (null),
  2    33 	       3 index_cursor_array_ptr
  2    34 			      ptr init (null),
  2    35 	     2 relation_header_ptr
  2    36 			      ptr init (null),
  2    37 	     2 attribute_info_ptr ptr init (null),
  2    38 	     2 index_attribute_map_ptr
  2    39 			      ptr init (null);
  2    40 
  2    41      dcl	   relation_opening_info_ptr
  2    42 			      ptr;
  2    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  2    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  2    45 
  2    46 
  2    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      250 
      251 
  3     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION
  3     4*        
  3     5*   Relation index components.  This info is kept in the header
  3     6*   collection of existing files, therefore this incl should not be changed.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*Written by Matthew Pierret, 01/15/83.
  3    11*Modified:
  3    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  3    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  3    14*   which were incompatible with existing DM files.        
  3    15**/
  3    16 
  3    17 /* format: style2,ind3 */
  3    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  3    19 	     2 version	      char (8),
  3    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  3    21 	     2 maximum_number_of_indices
  3    22 			      fixed bin (17) unal,
  3    23 	     2 maximum_number_of_attributes_per_index
  3    24 			      fixed bin (17) unal,
  3    25 	     2 mbz	      fixed bin (17) unal,
  3    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  3    27 	       3 collection_id    bit (36) aligned,
  3    28 	       3 style	      fixed bin (17) unal,
  3    29 	       3 number_of_duplication_fields
  3    30 			      fixed bin (17) unal,
  3    31 	       3 number_of_attributes
  3    32 			      fixed bin (17) unal,
  3    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  3    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  3    35 			      bin (17) unal;
  3    36 
  3    37      dcl	   index_attribute_map_ptr
  3    38 			      ptr init (null);
  3    39      dcl	   iam_maximum_number_of_indices
  3    40 			      fixed bin (17);
  3    41      dcl	   iam_maximum_number_of_attributes_per_index
  3    42 			      fixed bin (17);
  3    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  3    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  3    45      dcl	   INITIAL_NUMBER_OF_INDICES
  3    46 			      init (5) fixed bin (17);
  3    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  3    48 			      init (0) fixed bin (17);
  3    49 
  3    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      252 
      253 
  4     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
  4     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
  4     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
  4     9*     beginning of the structure to the element key_count_array.count in
  4    10*     characters. Using this it is possible to calculate the key_count_array_ptr
  4    11*     given the "addr (key_count_array.count (0))".
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 /* DESCRIPTION:
  4    16*
  4    17*          The key_count_array holds counts of the number of unique key values
  4    18*     in an index.  These values are used by the search optimization done by
  4    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
  4    20*     number of keys in the index which have at least fields 1 through N
  4    21*     having the same value as another key in the index, i.e. count(N)
  4    22*     is the number of partial duplicates with number of partial
  4    23*     duplication fields equal to N.
  4    24*
  4    25**/
  4    26 
  4    27 /* HISTORY:
  4    28*
  4    29*Written by Lindsey Spratt, 11/09/82.
  4    30*Modified:
  4    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
  4    32*	  Added a description, fixed the history section.
  4    33**/
  4    34 
  4    35 /* format: style2,ind3 */
  4    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
  4    37 	     2 version	      char (8) aligned,
  4    38 	     2 number_of_counts   fixed bin (17) unal,
  4    39 	     2 pad	      bit (18) unal,
  4    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
  4    41 			      bin (35) aligned;
  4    42 
  4    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
  4    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
  4    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
  4    46 			      init (12) fixed bin internal static options (constant);
  4    47 
  4    48      dcl	   key_count_array_ptr    ptr init (null);
  4    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
  4    50 
  4    51 
  4    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      254 
      255 
  5     1 /* BEGIN INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          This include file has all of the declarations for the index_manager_
  5     6*     external interface.  It is useful for programs which are making extensive
  5     7*     use of the index_manager_ to include this include file rather than
  5     8*     individually declaring each of the entries.
  5     9*     
  5    10**/
  5    11 
  5    12 /* HISTORY:
  5    13*
  5    14*Written by Lindsey Spratt, 06/25/82.
  5    15*Modified:
  5    16*07/28/82 by Lindsey Spratt: Extended the create_collection entry calling
  5    17*	  sequence to include the number_of_duplication_fields.
  5    18*08/10/82 by Matthew Pierret: Changed the create_collection entry calling 
  5    19*            sequence to return a "bit (36) aligned" collection id instead of
  5    20*            "fixed bin (17)".  Changed create_cursor calling sequence likewise.
  5    21*08/19/82 by Lindsey Spratt:  Renamed create_collection to create_index. Added
  5    22*	  the put_key_array entry.  Added the id_list_ptr to the get_key
  5    23*	  entry.  Added the create_subset_index entry.
  5    24*08/23/82 by Lindsey Spratt:  Added the position_cursor entry.
  5    25*09/27/82 by Lindsey Spratt:  Added the get_count and get_duplicate_key_count
  5    26*	  entries.
  5    27*11/09/82 by Lindsey Spratt:  Added ptr to get_key for the interval_list.
  5    28*	  Changed get_duplicate_key_count to get_key_count_array.
  5    29*05/31/83 by Matthew Pierret: Added $destroy_index and $destroy_cursor.
  5    30*05/02/84 by Lee Baldwin:  Renamed $get_count to $get_key_count_by_spec.
  5    31*10/23/84 by Lindsey L. Spratt:  Addressed auditing comments - alphabetized
  5    32*            entries, fixed $create_index to use "fixed bin (17)" instead of
  5    33*            just "fixed bin", added a description section.
  5    34**/
  5    35 
  5    36 /* format: style2,ind3 */
  5    37 
  5    38      dcl	   index_manager_$create_cursor entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
  5    39      dcl	   index_manager_$create_index entry (bit (36) aligned, ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  5    40      dcl	   index_manager_$create_subset_index entry (ptr, bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    41      dcl	   index_manager_$delete_key entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  5    42      dcl	   index_manager_$destroy_cursor entry (ptr, fixed bin (35));
  5    43      dcl	   index_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    44      dcl	   index_manager_$get_key entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  5    45      dcl	   index_manager_$get_key_count_array entry (ptr, ptr, ptr, fixed bin (35));
  5    46      dcl	   index_manager_$get_key_count_by_spec entry (ptr, ptr, fixed bin (35), fixed bin (35));
  5    47      dcl	   index_manager_$position_cursor entry (ptr, ptr, ptr, fixed bin (35));
  5    48      dcl	   index_manager_$put_key entry (ptr, ptr, fixed bin (35));
  5    49      dcl	   index_manager_$put_key_array entry (ptr, ptr, fixed bin (35));
  5    50 
  5    51 /* END INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
      256 
      257 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      258 
      259    end rlm_get_approximate_count$get_population;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1139.6  rlm_get_approximate_count.pl1     >udd>sm>ds>w>ml>rlm_get_approximate_count.pl1
248          1    03/06/85  1131.5  dm_rlm_cursor.incl.pl1            >ldd>incl>dm_rlm_cursor.incl.pl1
250          2    01/07/85  0959.6  dm_rlm_opening_info.incl.pl1      >ldd>incl>dm_rlm_opening_info.incl.pl1
252          3    01/07/85  1001.7  dm_rlm_index_attr_map.incl.pl1    >ldd>incl>dm_rlm_index_attr_map.incl.pl1
254          4    04/09/87  0950.7  dm_key_count_array.incl.pl1       >ldd>incl>dm_key_count_array.incl.pl1
256          5    01/07/85  0958.8  dm_idxmgr_entry_dcls.incl.pl1     >ldd>incl>dm_idxmgr_entry_dcls.incl.pl1
258          6    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000031 constant        bit(36)                  initial dcl 6-7 set ref 241*
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 3-43 set ref 149*
INITIAL_NUMBER_OF_INDICES       000124 automatic       fixed bin(17,0)          initial dcl 3-45 set ref 3-45*
KEY_COUNT_ARRAY_VERSION_2       000000 constant        char(8)                  initial dcl 4-43 set ref 191*
RELATION_CURSOR_VERSION_2       000006 constant        char(8)                  initial dcl 1-43 set ref 133*
RELATION_OPENING_INFO_VERSION_2 000004 constant        char(8)                  initial dcl 2-43 set ref 147*
TOTAL_KEY_COUNT_INDICATOR       001012 constant        fixed bin(17,0)          initial dcl 89 ref 124
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000125 automatic       fixed bin(17,0)          initial dcl 3-47 set ref 3-47*
cleanup                         000110 stack reference condition                dcl 83 ref 166
code                            000100 automatic       fixed bin(35,0)          dcl 68 set ref 144* 145 145* 179* 181 181* 187* 188
                                                                                  188*
collection_id            10            based           bit(36)                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 1-18 in procedure
                                                                                  "rlm_get_approximate_count$get_population" ref 170
collection_id             4            based           bit(36)                  array level 3 in structure "index_attribute_map"
                                                                                  dcl 3-18 in procedure
                                                                                  "rlm_get_approximate_count$get_population" ref 153
                                                                                  160
count                     3            based           fixed bin(35,0)          array level 2 dcl 4-36 ref 203 205 205
current                   6            based           structure                level 2 dcl 1-18
current_state_is_consistent
                          5            based           bit(1)                   initial level 3 packed packed unaligned dcl 1-18 ref
                                                                                  170
cursor_ptr               14            based           pointer                  initial level 3 dcl 1-18 ref 170 170 227
cv_p_expected_version                  parameter       char(8)                  dcl 238 set ref 235 241 241*
cv_p_received_version                  parameter       char(8)                  dcl 237 set ref 235 241 241*
cv_p_structure_name                    parameter       char                     packed unaligned dcl 239 set ref 235 241*
er_code                                parameter       fixed bin(35,0)          dcl 215 ref 212 217
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 102 set ref 241*
file_opening_id           4            based           bit(36)                  initial level 2 dcl 1-18 set ref 144* 179*
flags                     5            based           structure                level 2 dcl 1-18
get_dm_free_area_               000012 constant        entry                    external dcl 94 ref 163
get_duplicate_key_count         000104 automatic       bit(1)                   dcl 71 set ref 115* 123* 137
get_population                  000103 automatic       bit(1)                   dcl 71 set ref 114* 122*
index                     4            based           structure                array level 2 dcl 3-18 ref 153 157
index_attribute_map                    based           structure                level 1 dcl 3-18
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure
                                                                                  "rlm_get_approximate_count$get_population" ref 148
index_attribute_map_ptr         000122 automatic       pointer                  initial dcl 3-37 in procedure
                                                                                  "rlm_get_approximate_count$get_population" set ref
                                                                                  148* 149 153 153 153 157 160 3-37*
index_collection_id             000105 automatic       bit(36)                  dcl 73 set ref 137* 160* 170 179*
index_cursor_ptr                000106 automatic       pointer                  initial dcl 74 set ref 74* 135* 170* 179* 187* 227
                                                                                  227 227*
index_idx                       000101 automatic       fixed bin(17,0)          dcl 69 set ref 153* 153 153* 157 160
index_manager_$create_cursor    000022 constant        entry                    external dcl 5-38 ref 179
index_manager_$destroy_cursor   000024 constant        entry                    external dcl 5-42 ref 227
index_manager_$get_key_count_array
                                000026 constant        entry                    external dcl 5-45 ref 187
kca_number_of_counts            000130 automatic       fixed bin(17,0)          initial dcl 4-49 set ref 4-49*
key_count_array                        based           structure                level 1 dcl 4-36 set ref 230
key_count_array_ptr             000126 automatic       pointer                  initial dcl 4-48 set ref 135* 187* 191 203 205 205
                                                                                  4-48* 230 230
key_count_idx                   000102 automatic       fixed bin(17,0)          dcl 70 set ref 116* 124* 126* 203 205
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-18 ref 153 153
                                                                                  153 153 160 160
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-18 ref 153 157
myname                          000010 constant        varying char(32)         initial dcl 87 set ref 241*
null                                                   builtin function         dcl 79 ref 74 135 163 170 1-42 3-37 4-48 227 230 241
                                                                                  241
number_of_attributes      6            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 3-18 ref
                                                                                  153
number_of_counts          2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-36 ref 230
p_code                                 parameter       fixed bin(35,0)          dcl 63 set ref 49 119 129* 217*
p_index_collection_id                  parameter       bit(36)                  dcl 57 ref 119 137
p_number_of_duplication_fields         parameter       fixed bin(17,0)          dcl 59 ref 119 124 126
p_relation_cursor_ptr                  parameter       pointer                  dcl 56 ref 49 119 132
p_tuple_count                          parameter       fixed bin(35,0)          dcl 61 set ref 49 119 129* 203* 205* 206* 206
relation_cursor                        based           structure                level 1 dcl 1-18
relation_cursor_ptr             000116 automatic       pointer                  initial dcl 1-42 set ref 132* 133 144 170 170 170
                                                                                  170 179 1-42* 227
relation_opening_info                  based           structure                level 1 dcl 2-15
relation_opening_info_ptr       000120 automatic       pointer                  dcl 2-41 set ref 144* 147 148
rlm_opening_info$get            000014 constant        entry                    external dcl 95 ref 144
sub_err_                        000016 constant        entry                    external dcl 96 ref 241
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 1-18
                                                                                  in procedure
                                                                                  "rlm_get_approximate_count$get_population" set ref
                                                                                  133*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 3-18
                                                                                  in procedure
                                                                                  "rlm_get_approximate_count$get_population" set ref
                                                                                  149*
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure
                                                                                  "rlm_get_approximate_count$get_population" set ref
                                                                                  147*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 4-36
                                                                                  in procedure
                                                                                  "rlm_get_approximate_count$get_population" set ref
                                                                                  191*
work_area_ptr                   000010 internal static pointer                  initial dcl 107 set ref 163 163* 179* 187*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 4-45
dm_error_$programming_error            external static fixed bin(35,0)          dcl 100
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 3-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 3-39
index_manager_$create_index     000000 constant        entry                    external dcl 5-39
index_manager_$create_subset_index
                                000000 constant        entry                    external dcl 5-40
index_manager_$delete_key       000000 constant        entry                    external dcl 5-41
index_manager_$destroy_index    000000 constant        entry                    external dcl 5-43
index_manager_$get_key          000000 constant        entry                    external dcl 5-44
index_manager_$get_key_count_by_spec
                                000000 constant        entry                    external dcl 5-46
index_manager_$position_cursor  000000 constant        entry                    external dcl 5-47
index_manager_$put_key          000000 constant        entry                    external dcl 5-48
index_manager_$put_key_array    000000 constant        entry                    external dcl 5-49

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000700 constant        entry                    internal dcl 235 ref 133 147 149 191
ERROR_RETURN                    000622 constant        entry                    internal dcl 212 ref 145 157 181 188
FINISH                          000634 constant        entry                    internal dcl 224 ref 166 208 218
JOIN                            000203 constant        label                    dcl 129 ref 117 127
MAIN_RETURN                     000621 constant        label                    dcl 209 ref 219
get_duplicate_key_count         000155 constant        entry                    external dcl 119
rlm_get_approximate_count$get_population
                                000130 constant        entry                    external dcl 49

NAMES DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 153 157
max                                                    builtin function         ref 206
min                                                    builtin function         ref 205

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1210        1240    1013        1220
Length      1552    1013        30         276     174           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_get_approximate_count$get_population
                                    208 external procedure  is an external procedure.  
on unit on line 166                  64 on unit               
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_get_approximate_count$get             
FINISH                               72 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_get_approximate_count$get             

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 work_area_ptr               rlm_get_approximate_count$get_population

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_get_approximate_count$get_population
                         000100 code                        rlm_get_approximate_count$get_population
                         000101 index_idx                   rlm_get_approximate_count$get_population
                         000102 key_count_idx               rlm_get_approximate_count$get_population
                         000103 get_population              rlm_get_approximate_count$get_population
                         000104 get_duplicate_key_count     rlm_get_approximate_count$get_population
                         000105 index_collection_id         rlm_get_approximate_count$get_population
                         000106 index_cursor_ptr            rlm_get_approximate_count$get_population
                         000116 relation_cursor_ptr         rlm_get_approximate_count$get_population
                         000120 relation_opening_info_ptr   rlm_get_approximate_count$get_population
                         000122 index_attribute_map_ptr     rlm_get_approximate_count$get_population
                         000124 INITIAL_NUMBER_OF_INDICES   rlm_get_approximate_count$get_population
                         000125 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_get_approximate_count$get_population
                         000126 key_count_array_ptr         rlm_get_approximate_count$get_population
                         000130 kca_number_of_counts        rlm_get_approximate_count$get_population

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_dm_free_area_             index_manager_$create_cursor  index_manager_$destroy_cursor
index_manager_$get_key_count_array                          rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000110    1   42 000112    3   37 000113    3   45 000114    3   47 000116    4   48 000117    4   49 000121
     49 000124       114 000143       115 000145       116 000146       117 000147       119 000150       122 000170
    123 000171       124 000173       126 000201       127 000202       129 000203       132 000205       133 000211
    135 000234       137 000237       144 000245       145 000261       147 000265       148 000307       149 000312
    153 000337       156 000372       157 000374       160 000405       163 000422       166 000435       170 000457
    179 000475       181 000514       187 000520       188 000535       191 000541       203 000564       205 000572
    206 000610       208 000615       209 000621       212 000622       217 000624       218 000626       219 000632
    224 000633       227 000641       230 000664       233 000677       235 000700       241 000711       246 001001


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
