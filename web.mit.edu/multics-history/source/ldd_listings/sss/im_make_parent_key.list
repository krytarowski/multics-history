	COMPILATION LISTING OF SEGMENT im_make_parent_key
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1535.6 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(86-12-17,Dupuis), approve(87-04-01,MCR7632), audit(87-01-13,Blair),
       10*     install(87-04-02,MR12.1-1020):
       11*     Fixed a bug (phx20420) where the parent key was being built incorrectly if
       12*     it was a char varying or bit varying field.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* format: style2,ind3 */
       17 im_make_parent_key:
       18    proc (p_field_table_ptr, p_low_key_string_ptr, p_last_field_in_low_key, p_high_key_string_ptr,
       19       p_last_field_in_high_key, p_parent_key_buffer_ptr, p_parent_key_buffer_length, p_work_area_ptr, p_branch_key_ptr,
       20       p_branch_key_string_length, p_new_buffer_was_allocated, p_code);
       21 
       22 /* DESCRIPTION:
       23*
       24*          This module takes two input key strings and produces a "parent" key
       25*     string which will compare greater than the "low" key and less than or
       26*     equal to the "high" key.  The "parent" key which is produced may not have
       27*     as many fields as the either or both of the "low" and "high" keys.
       28*     Similarly the "low" and "high" keys need not have all of the fields
       29*     defined in the field_table.  The subset of fields present in any of these
       30*     keys, however, must be a continuous set  from the first field (i.e., if
       31*     field N is absent, then all fields with identifiers greater than N must
       32*     be absent as well).
       33**/
       34 
       35 /* HISTORY:
       36*
       37*Written by Lindsey Spratt, 04/22/82.
       38*Modified:
       39*01/06/83 by Lindsey Spratt:  Fixed to correctly initialize the 
       40*	  (low high)_varying_data_idx when the input keys are full length and
       41*	  a varying field is present.
       42*03/23/83 by Lindsey Spratt:  Changed to use version 2 of field_table.  Also,
       43*	  converted to use data_mgmt_util_$compare_field_to_field instead of
       44*	  im_compare_values$field_to_field.
       45*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3.  Changed
       46*            references to data_mgmt_util_ to data_format_util_.
       47**/
       48 
       49 /* START OF DECLARATIONS */
       50 /* Parameter */
       51 
       52       dcl	    p_field_table_ptr      ptr;
       53       dcl	    p_low_key_string_ptr   ptr;
       54       dcl	    p_last_field_in_low_key
       55 			       fixed bin (17) unal;
       56       dcl	    p_high_key_string_ptr  ptr;
       57       dcl	    p_last_field_in_high_key
       58 			       fixed bin (17) unal;
       59       dcl	    p_parent_key_buffer_ptr
       60 			       ptr;
       61       dcl	    p_parent_key_buffer_length
       62 			       fixed bin (35);
       63       dcl	    p_work_area_ptr	       ptr;
       64       dcl	    p_branch_key_ptr       ptr;
       65       dcl	    p_branch_key_string_length
       66 			       fixed bin (35);
       67       dcl	    p_new_buffer_was_allocated
       68 			       bit (1) aligned;
       69       dcl	    p_code	       fixed bin (35);
       70 
       71 /* Automatic */
       72 
       73       dcl	    last_field_is_truncated
       74 			       bit (1) aligned init ("0"b);
       75       dcl	    bit_idx	       fixed bin (35) init (0);
       76       dcl	    number_of_bits_needed_to_adjust_for_byte_alignment
       77 			       fixed bin init (0);
       78       dcl	    char_idx	       fixed bin (35) init (0);
       79 
       80       dcl	    maximum_field_idx      fixed bin (17) init (0);
       81       dcl	    low_varying_data_idx   fixed bin (17) init (0);
       82       dcl	    high_varying_data_idx  fixed bin (17) init (0);
       83       dcl	    low_equal_to_high      bit (1) aligned init ("0"b);
       84       dcl	    low_less_than_high     bit (1) aligned init ("0"b);
       85       dcl	    field_idx	       fixed bin (17) init (0);
       86       dcl	    low_value_length       fixed bin (35) init (0);
       87       dcl	    high_value_length      fixed bin (35) init (0);
       88       dcl	    low_value_ptr	       ptr init (null);
       89       dcl	    high_value_ptr	       ptr init (null);
       90       dcl	    myname	       init ("im_make_parent_key") char (32) varying;
       91       dcl	    branch_key_varying_data_idx
       92 			       fixed bin (35) init (0);
       93 
       94 /* Based */
       95 
       96       dcl	    low_key_string	       bit (sys_info$max_seg_size * BITS_PER_WORD) based (p_low_key_string_ptr);
       97       dcl	    high_key_string	       bit (sys_info$max_seg_size * BITS_PER_WORD) based (p_high_key_string_ptr);
       98       dcl	    low_key_bit_array      (sys_info$max_seg_size * BITS_PER_WORD) bit (1) based (p_low_key_string_ptr);
       99       dcl	    high_key_bit_array     (sys_info$max_seg_size * BITS_PER_WORD) bit (1) based (p_high_key_string_ptr);
      100       dcl	    based_char_string      char (sys_info$max_seg_size * BYTES_PER_WORD) based;
      101 
      102 /* Builtin */
      103 
      104       dcl	    (addr, bin, copy, divide, hbound, length, min, mod, null, substr, unspec)
      105 			       builtin;
      106 
      107 /* Controlled */
      108 /* Constant */
      109 
      110       dcl	    ALL_FIELDS_PRESENT     init (-1) fixed bin (17) internal static options (constant);
      111 
      112       dcl	    (
      113 	    BITS_PER_WORD	       init (36),
      114 	    BYTES_PER_WORD	       init (4),
      115 	    BITS_PER_BYTE	       init (9)
      116 	    )		       fixed bin (17) internal static options (constant);
      117 
      118 /* Entry */
      119 
      120       dcl	    data_format_util_$compare_field_to_field
      121 			       entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (1) aligned,
      122 			       bit (1) aligned, fixed bin (35));
      123       dcl	    sub_err_	       entry options (variable);
      124 
      125 /* External */
      126 
      127       dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
      128       dcl	    (
      129 	    error_table_$unimplemented_version,
      130 	    dm_error_$programming_error,
      131 	    dm_error_$key_duplication,
      132 	    dm_error_$keys_out_of_order
      133 	    )		       fixed bin (35) ext static;
      134 
      135 /* END OF DECLARATIONS */
      136 
      137       p_code = 0;
      138 
      139       field_table_ptr = p_field_table_ptr;
      140       if field_table.version ^= FIELD_TABLE_VERSION_3
      141       then call
      142 	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      143 	    "^/Expected version ^a of the field_table structure.  Received version ^a.", FIELD_TABLE_VERSION_3,
      144 	    field_table.version);
      145 
      146       p_new_buffer_was_allocated = "0"b;
      147       p_branch_key_ptr = null;
      148       p_branch_key_string_length = 0;
      149       branch_key_ptr = p_parent_key_buffer_ptr;
      150       bk_string_length = 0;
      151       bk_string_length = p_parent_key_buffer_length - length (unspec (branch_key));
      152 
      153       if p_last_field_in_low_key = ALL_FIELDS_PRESENT | p_last_field_in_high_key = ALL_FIELDS_PRESENT
      154       then maximum_field_idx = hbound (field_table.field, 1);
      155       else maximum_field_idx = min (p_last_field_in_low_key, p_last_field_in_high_key);
      156       if p_last_field_in_low_key = ALL_FIELDS_PRESENT
      157       then low_varying_data_idx = field_table.location_of_first_varying_field;
      158       else low_varying_data_idx =
      159 	    field_table.field (p_last_field_in_low_key).location
      160 	    + field_table.field (p_last_field_in_low_key).length_in_bits;
      161       if p_last_field_in_high_key = ALL_FIELDS_PRESENT
      162       then high_varying_data_idx = field_table.location_of_first_varying_field;
      163       else high_varying_data_idx =
      164 	    field_table.field (p_last_field_in_high_key).location
      165 	    + field_table.field (p_last_field_in_high_key).length_in_bits;
      166 
      167       low_equal_to_high = "1"b;
      168 COMPARISON_LOOP:
      169       do field_idx = 1 to maximum_field_idx while (low_equal_to_high & p_code = 0);
      170          if field_table.varying_field_map (field_idx).varying_field_index > 0
      171          then
      172 	  do;
      173 	     unspec (low_value_length) =
      174 	        copy ("0"b, BITS_PER_WORD - field_table.field (field_idx).length_in_bits)
      175 	        ||
      176 	        substr (low_key_string, field_table.field (field_idx).location,
      177 	        field_table.field (field_idx).length_in_bits);
      178 	     unspec (high_value_length) =
      179 	        copy ("0"b, BITS_PER_WORD - field_table.field (field_idx).length_in_bits)
      180 	        ||
      181 	        substr (high_key_string, field_table.field (field_idx).location,
      182 	        field_table.field (field_idx).length_in_bits);
      183 	     low_value_ptr = addr (low_key_bit_array (low_varying_data_idx));
      184 	     high_value_ptr = addr (high_key_bit_array (high_varying_data_idx));
      185 	     if field_table.field (field_idx).length_is_in_characters
      186 	     then
      187 	        do;
      188 		 low_varying_data_idx = low_varying_data_idx + low_value_length * BITS_PER_BYTE;
      189 		 high_varying_data_idx = high_varying_data_idx + high_value_length * BITS_PER_BYTE;
      190 	        end;
      191 	     else
      192 	        do;
      193 		 low_varying_data_idx = low_varying_data_idx + low_value_length;
      194 		 high_varying_data_idx = high_varying_data_idx + high_value_length;
      195 	        end;
      196 	  end;
      197          else
      198 	  do;
      199 	     low_value_length, high_value_length = -1;
      200 	     low_value_ptr = addr (low_key_bit_array (field_table.field (field_idx).location));
      201 	     high_value_ptr = addr (high_key_bit_array (field_table.field (field_idx).location));
      202 
      203 	  end;
      204 
      205          call
      206 	  data_format_util_$compare_field_to_field (addr (field_table.field (field_idx).descriptor), low_value_ptr,
      207 	  low_value_length, high_value_ptr, high_value_length, low_equal_to_high, low_less_than_high, p_code);
      208 
      209       end COMPARISON_LOOP;
      210 
      211       if low_equal_to_high
      212       then
      213          do;
      214 	  p_code = dm_error_$key_duplication;
      215 	  return;
      216          end;
      217 
      218       if ^low_less_than_high
      219       then call sub_err_ (dm_error_$keys_out_of_order, myname, "h", null, 0);
      220 
      221       branch_key.last_field_idx = field_idx - 1;		/* The loop increments the field idx one too many times. */
      222 
      223 /* Copy the fields which compared "equal" and the first field which compared
      224*"inequal" into the new parent key. */
      225 
      226       arg_descriptor_ptr = addr (field_table.field (branch_key.last_field_idx).descriptor);
      227       last_field_is_truncated = "0"b;
      228       if field_table.varying_field_map (branch_key.last_field_idx).varying_field_index = 0
      229       then if arg_descriptor.type = bit_dtype
      230 	 then
      231 	    do;
      232 	       if arg_descriptor.size > BITS_PER_WORD + BITS_PER_BYTE
      233 	       then
      234 		do;
      235 		   do bit_idx = 1 to field_table.field (branch_key.last_field_idx).length_in_bits
      236 		      while (
      237 		      substr (high_key_string, field_table.field (branch_key.last_field_idx).location + bit_idx - 1,
      238 		      1)
      239 		      =
      240 		      substr (low_key_string, field_table.field (branch_key.last_field_idx).location + bit_idx - 1, 1)
      241 		      );
      242 		   end;
      243 		   if bit_idx > field_table.field (branch_key.last_field_idx).length_in_bits
      244 		   then call
      245 			 sub_err_ (dm_error_$programming_error, myname, "s", null, 0,
      246 			 "^/Two bit values compared equal which im_compare_values claims are not equal.");
      247 
      248 
      249 		   substr (branch_key.string, field_table.field (branch_key.last_field_idx).location + BITS_PER_WORD,
      250 		      bit_idx) =
      251 		      substr (high_key_string, field_table.field (branch_key.last_field_idx).location, bit_idx);
      252 
      253 		   number_of_bits_needed_to_adjust_for_byte_alignment =
      254 		      mod (bit_idx + field_table.field (branch_key.last_field_idx).location + BITS_PER_BYTE - 1,
      255 		      BITS_PER_BYTE);
      256 		   substr (branch_key.string,
      257 		      field_table.field (branch_key.last_field_idx).location + bit_idx + BITS_PER_WORD,
      258 		      number_of_bits_needed_to_adjust_for_byte_alignment) = "0"b;
      259 		   bit_idx = bit_idx + number_of_bits_needed_to_adjust_for_byte_alignment;
      260 		   substr (branch_key.string, field_table.field (branch_key.last_field_idx).location, BITS_PER_WORD) =
      261 		      unspec (bit_idx);
      262 		   branch_key_varying_data_idx =
      263 		      field_table.field (branch_key.last_field_idx).location + BITS_PER_WORD + bit_idx;
      264 		   last_field_is_truncated = "1"b;
      265 		end;
      266 	    end;
      267 	 else if arg_descriptor.type = char_dtype
      268 	 then
      269 	    do;
      270 	       if arg_descriptor.size > BYTES_PER_WORD + 1
      271 	       then
      272 		do;
      273 
      274 		   do char_idx = 1
      275 		      to divide (field_table.field (branch_key.last_field_idx).length_in_bits, BITS_PER_BYTE, 35, 0)
      276 		      while (
      277 		      substr (addr (high_key_bit_array (field_table.field (branch_key.last_field_idx).location))
      278 		      -> based_char_string, char_idx, 1)
      279 		      =
      280 		      substr (addr (low_key_bit_array (field_table.field (branch_key.last_field_idx).location))
      281 		      -> based_char_string, char_idx, 1));
      282 		   end;
      283 		   bit_idx = char_idx * BITS_PER_BYTE;
      284 		   if bit_idx > field_table.field (branch_key.last_field_idx).length_in_bits
      285 		   then call
      286 			 sub_err_ (dm_error_$programming_error, myname, "s", null, 0,
      287 			 "^/Two character values compared equal which im_compare_values claims are not 
      288 equal.");
      289 
      290 		   substr (branch_key.string, field_table.field (branch_key.last_field_idx).location + BITS_PER_WORD,
      291 		      bit_idx) =
      292 		      substr (high_key_string, field_table.field (branch_key.last_field_idx).location, bit_idx);
      293 		   substr (branch_key.string, field_table.field (branch_key.last_field_idx).location, BITS_PER_WORD) =
      294 		      unspec (char_idx);
      295 		   branch_key_varying_data_idx =
      296 		      field_table.field (branch_key.last_field_idx).location + BITS_PER_WORD + bit_idx;
      297 		   last_field_is_truncated = "1"b;
      298 		end;
      299 	    end;
      300 
      301       low_varying_data_idx = field_table.location_of_first_varying_field;
      302       high_varying_data_idx = field_table.location_of_first_varying_field;
      303       if ^last_field_is_truncated
      304       then branch_key_varying_data_idx = field_table.location_of_first_varying_field;
      305 
      306 COPY_LOOP:
      307       do field_idx = 1 to branch_key.last_field_idx - bin (last_field_is_truncated);
      308          if field_table.varying_field_map (field_idx).varying_field_index = 0
      309          then substr (branch_key.string, field_table.field (field_idx).location,
      310 	       field_table.field (field_idx).length_in_bits) =
      311 	       substr (high_key_string, field_table.field (field_idx).location,
      312 	       field_table.field (field_idx).length_in_bits);
      313          else
      314 	  do;
      315 	     unspec (low_value_length) =
      316 	        copy ("0"b, BITS_PER_WORD - field_table.field (field_idx).length_in_bits)
      317 	        ||
      318 	        substr (low_key_string, field_table.field (field_idx).location,
      319 	        field_table.field (field_idx).length_in_bits);
      320 	     unspec (high_value_length) =
      321 	        copy ("0"b, BITS_PER_WORD - field_table.field (field_idx).length_in_bits)
      322 	        ||
      323 	        substr (high_key_string, field_table.field (field_idx).location,
      324 	        field_table.field (field_idx).length_in_bits);
      325 
      326 	     if field_table.field (field_idx).length_is_in_characters
      327 	     then do;
      328 		low_value_length = low_value_length * BITS_PER_BYTE;
      329 		high_value_length = high_value_length * BITS_PER_BYTE;
      330 	     end;
      331 	     if field_idx = branch_key.last_field_idx
      332 	     then if addr (field_table.field (field_idx).descriptor) -> arg_descriptor.type = varying_char_dtype
      333 		then
      334 		   do;
      335 		      do char_idx = 1
      336 		         to divide (min (high_value_length, low_value_length), BITS_PER_BYTE, 35, 0)
      337 		         while (
      338 		         substr (addr (high_key_bit_array (high_varying_data_idx)) -> based_char_string, char_idx, 1)
      339 		         = substr (addr (low_key_bit_array (low_varying_data_idx)) -> based_char_string, char_idx, 1))
      340 		         ;
      341 		      end;
      342 		      high_value_length = char_idx * BITS_PER_BYTE;
      343 		   end;
      344 		else
      345 		   do;
      346 		      do bit_idx = 1 to min (high_value_length, low_value_length)
      347 		         while (substr (high_key_string, high_varying_data_idx + bit_idx - 1, 1)
      348 		         = substr (low_key_string, low_varying_data_idx + bit_idx - 1, 1));
      349 		      end;
      350 		      high_value_length =
      351 		         bit_idx + (BITS_PER_BYTE - 1) - mod (bit_idx + (BITS_PER_BYTE - 1), BITS_PER_BYTE);
      352 						/* This adjusts the bit idx to fall on a byte boundary. */
      353 		   end;
      354 
      355 	     substr (branch_key.string, branch_key_varying_data_idx, high_value_length) =
      356 	        substr (high_key_string, high_varying_data_idx, high_value_length);
      357 	     if ^field_table.field (field_idx).length_is_in_characters
      358 	     then substr (branch_key.string, field_table.field (field_idx).location,
      359 	        field_table.field (field_idx).length_in_bits) =
      360 	        "0"b
      361 	        ||
      362 	        substr (unspec (high_value_length), BITS_PER_WORD + 2 - field_table.field (field_idx).length_in_bits,
      363 	        field_table.field (field_idx).length_in_bits - 1);
      364 	     else substr (branch_key.string, field_table.field (field_idx).location,
      365 	        field_table.field (field_idx).length_in_bits) =
      366 	        substr (bit (divide (high_value_length, BITS_PER_BYTE, 35), 35),
      367 	        BITS_PER_WORD - field_table.field (field_idx).length_in_bits,
      368 	        field_table.field (field_idx).length_in_bits);
      369 	     high_varying_data_idx = high_varying_data_idx + high_value_length;
      370 	     branch_key_varying_data_idx = branch_key_varying_data_idx + high_value_length;
      371 	  end;
      372 
      373 
      374       end COPY_LOOP;
      375 
      376       p_branch_key_ptr = branch_key_ptr;
      377       p_branch_key_string_length = branch_key_varying_data_idx - 1;
      378 
      379       return;
      380 
  1     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          The field_table describes the layout of a set of fields in a
  1     6*     formatted data string.  Such a string is the stored representation of a
  1     7*     record or a key.  Fields are placed side-by-side in the string in the
  1     8*     order they appear in the field_table.field array.  The string is divided
  1     9*     into the fixed portion and the varying portion.  In the fixed portion
  1    10*     appear fixed-length fields and fixed-size length-fields for
  1    11*     varying-length fields.  In the varying portion appear varying length
  1    12*     fields.  The length-field for a varying-length field contains the length
  1    13*     of the field values either in bits or in characters, depending on the
  1    14*     data type of the field.
  1    15**/
  1    16 
  1    17 /* HISTORY:
  1    18*Written by Matthew Pierret, 04/01/82.
  1    19*Modified:
  1    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  1    21*	  that if the field is varying, its length is expressed in
  1    22*	  bytes/characters.
  1    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  1    24*	  of 17, changed version to 2, changed version field to char(8) from
  1    25*	  fixed bin (17).
  1    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  1    27*            put field names in one string (field_names) at the end of the 
  1    28*            structure. Added field.location_of_name and field.length_of_name
  1    29*            for locating the field name in field_names. Aligned all "fixed bin"
  1    30*            structure elements.  Changed maximum_field_name_length to 
  1    31*            length_of_field_names.
  1    32**/
  1    33 
  1    34 /* format: style2 */
  1    35 
  1    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  1    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  1    38 	     2 number_of_fields   fixed bin (17),
  1    39 	     2 length_of_field_names
  1    40 			      fixed bin (17),	/* length of field_names in characters */
  1    41 	     2 location_of_first_varying_field
  1    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  1    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  1    44 	       3 flags	      aligned,
  1    45 	         4 descriptor_is_varying
  1    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  1    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  1    48 						/* containing the id of the element in which the descriptor is stored. */
  1    49 	         4 length_is_in_characters
  1    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  1    51 						/* in characters instead of in bits */
  1    52 	         4 must_be_zero   bit (34) unal,
  1    53 	       3 descriptor	      bit (36) aligned,
  1    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  1    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  1    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  1    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  1    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  1    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  1    60 	       3 varying_field_index
  1    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  1    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  1    63 
  1    64 
  1    65      dcl	   field_table_ptr	      ptr;
  1    66      dcl	   ft_length_of_field_names
  1    67 			      fixed bin;
  1    68      dcl	   ft_number_of_fields    fixed bin;
  1    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  1    70 
  1    71 dcl field_name char (field_name_length) based (field_name_ptr);
  1    72 
  1    73 dcl field_name_length fixed bin;
  1    74 dcl field_name_ptr ptr;
  1    75 
  1    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      381 
      382 
  2     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          There are two formats for keys, the leaf_key structure and the
  2     6*     branch_key structure. The branch_key has two more pieces of information
  2     7*     than the leaf_key. One is the control interval id of the
  2     8*     node for all keys greater than the value of the branch key.  The other is
  2     9*     the number of fields for which there are values in the "string" portion
  2    10*     of the key.  This allows for the storing of only as much data as is needed
  2    11*     to discriminate between the children being split by the branch key.
  2    12**/
  2    13 
  2    14 /* HISTORY:
  2    15*
  2    16*Written by Lindsey Spratt, 03/29/82.
  2    17*Modified:
  2    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  2    23      dcl	   key_string_length      fixed bin (35);
  2    24      dcl	   key_string_ptr	      ptr;
  2    25 
  2    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  2    27 	     2 string	      bit (lk_string_length) unal;
  2    28 
  2    29      dcl	   lk_string_length	      fixed bin (35);
  2    30      dcl	   leaf_key_ptr	      ptr;
  2    31 
  2    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  2    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  2    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  2    35 	     2 string	      bit (bk_string_length) unal;
  2    36 
  2    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  2    38 			      init (36) fixed bin (35) internal static options (constant);
  2    39      dcl	   bk_string_length	      fixed bin (35);
  2    40      dcl	   branch_key_ptr	      ptr;
  2    41 
  2    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      383 
      384 
  3     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  3     2*
  3     3*   James R. Davis 1 Mar 79 */
  3     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  3     5 
  3     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  3     7 	     2 flag	      bit (1) unal,
  3     8 	     2 type	      fixed bin (6) unsigned unal,
  3     9 	     2 packed	      bit (1) unal,
  3    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  3    11 	     2 size	      fixed bin (24) unsigned unal;
  3    12 
  3    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  3    14 	     2 flag	      bit (1) unal,
  3    15 	     2 type	      fixed bin (6) unsigned unal,
  3    16 	     2 packed	      bit (1) unal,
  3    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  3    18 	     2 scale	      fixed bin (11) unal,
  3    19 	     2 precision	      fixed bin (12) unsigned unal;
  3    20 
  3    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  3    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  3    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  3    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  3    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  3    26 	     2 size	      bit (24) unal,
  3    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  3    28 	       3 low	      fixed bin (35),
  3    29 	       3 high	      fixed bin (35),
  3    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  3    31 	     2 real_type	      fixed bin (18) unsigned unal,
  3    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  3    33 
  3    34      dcl	   arg_descriptor_ptr     ptr;
  3    35 
  3    36      dcl	   extended_arg_type      fixed bin init (58);
  3    37 
  3    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      385 
      386 
  4     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  4     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  4     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  4     8*     Objects of this type are PASCAL string types.
  4     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4    11*     Added the new C types.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 /* This include file defines mnemonic names for the Multics
  4    15*   standard descriptor types, using both pl1 and cobol terminology.
  4    16*   PG 780613
  4    17*   JRD 790530
  4    18*   JRD 791016
  4    19*   MBW 810731
  4    20*   TGO 830614 Add hex types.
  4    21*   Modified June 83 JMAthane to add PASCAL data types
  4    22*   TGO 840120 Add float dec extended and generic, float binary generic
  4    23**/
  4    24 
  4    25      dcl	   (real_fix_bin_1_dtype  init (1),
  4    26 	   real_fix_bin_2_dtype   init (2),
  4    27 	   real_flt_bin_1_dtype   init (3),
  4    28 	   real_flt_bin_2_dtype   init (4),
  4    29 	   cplx_fix_bin_1_dtype   init (5),
  4    30 	   cplx_fix_bin_2_dtype   init (6),
  4    31 	   cplx_flt_bin_1_dtype   init (7),
  4    32 	   cplx_flt_bin_2_dtype   init (8),
  4    33 	   real_fix_dec_9bit_ls_dtype init (9),
  4    34 	   real_flt_dec_9bit_dtype init (10),
  4    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  4    36 	   cplx_flt_dec_9bit_dtype init (12),
  4    37 	   pointer_dtype	      init (13),
  4    38 	   offset_dtype	      init (14),
  4    39 	   label_dtype	      init (15),
  4    40 	   entry_dtype	      init (16),
  4    41 	   structure_dtype	      init (17),
  4    42 	   area_dtype	      init (18),
  4    43 	   bit_dtype	      init (19),
  4    44 	   varying_bit_dtype      init (20),
  4    45 	   char_dtype	      init (21),
  4    46 	   varying_char_dtype     init (22),
  4    47 	   file_dtype	      init (23),
  4    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  4    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  4    50 	   real_fix_bin_1_uns_dtype init (33),
  4    51 	   real_fix_bin_2_uns_dtype init (34),
  4    52 	   real_fix_dec_9bit_uns_dtype init (35),
  4    53 	   real_fix_dec_9bit_ts_dtype init (36),
  4    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  4    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  4    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  4    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  4    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  4    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  4    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  4    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  4    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  4    63 	   real_flt_hex_1_dtype   init (47),
  4    64 	   real_flt_hex_2_dtype   init (48),
  4    65 	   cplx_flt_hex_1_dtype   init (49),
  4    66 	   cplx_flt_hex_2_dtype   init (50),
  4    67 	   c_typeref_dtype        init (54),
  4    68 	   c_enum_dtype           init (55),
  4    69              c_enum_const_dtype     init (56),
  4    70 	   c_union_dtype          init (57),
  4    71 	   algol68_straight_dtype init (59),
  4    72 	   algol68_format_dtype   init (60),
  4    73 	   algol68_array_descriptor_dtype init (61),
  4    74 	   algol68_union_dtype    init (62),
  4    75 
  4    76 	   cobol_comp_6_dtype     init (1),
  4    77 	   cobol_comp_7_dtype     init (1),
  4    78 	   cobol_display_ls_dtype init (9),
  4    79 	   cobol_structure_dtype  init (17),
  4    80 	   cobol_char_string_dtype init (21),
  4    81 	   cobol_display_ls_overp_dtype init (29),
  4    82 	   cobol_display_ts_overp_dtype init (30),
  4    83 	   cobol_display_uns_dtype init (35),
  4    84 	   cobol_display_ts_dtype init (36),
  4    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  4    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  4    87 	   cobol_comp_5_uns_dtype init (40),
  4    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  4    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  4    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  4    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  4    92 	   cplx_flt_dec_generic_dtype init (84),
  4    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  4    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  4    95 
  4    96      dcl	   (ft_integer_dtype      init (1),
  4    97 	   ft_real_dtype	      init (3),
  4    98 	   ft_double_dtype	      init (4),
  4    99 	   ft_complex_dtype	      init (7),
  4   100 	   ft_complex_double_dtype init (8),
  4   101 	   ft_external_dtype      init (16),
  4   102 	   ft_logical_dtype	      init (19),
  4   103 	   ft_char_dtype	      init (21),
  4   104 	   ft_hex_real_dtype      init (47),
  4   105 	   ft_hex_double_dtype    init (48),
  4   106 	   ft_hex_complex_dtype   init (49),
  4   107 	   ft_hex_complex_double_dtype init (50)
  4   108 	   )		      fixed bin internal static options (constant);
  4   109 
  4   110      dcl	   (algol68_short_int_dtype init (1),
  4   111 	   algol68_int_dtype      init (1),
  4   112 	   algol68_long_int_dtype init (2),
  4   113 	   algol68_real_dtype     init (3),
  4   114 	   algol68_long_real_dtype init (4),
  4   115 	   algol68_compl_dtype    init (7),
  4   116 	   algol68_long_compl_dtype init (8),
  4   117 	   algol68_bits_dtype     init (19),
  4   118 	   algol68_bool_dtype     init (19),
  4   119 	   algol68_char_dtype     init (21),
  4   120 	   algol68_byte_dtype     init (21),
  4   121 	   algol68_struct_struct_char_dtype init (22),
  4   122 	   algol68_struct_struct_bool_dtype init (20)
  4   123 	   )		      fixed bin internal static options (constant);
  4   124 
  4   125      dcl	   (label_constant_runtime_dtype init (24),
  4   126 	   int_entry_runtime_dtype init (25),
  4   127 	   ext_entry_runtime_dtype init (26),
  4   128 	   ext_procedure_runtime_dtype init (27),
  4   129 	   picture_runtime_dtype  init (63)
  4   130 	   )		      fixed bin internal static options (constant);
  4   131 
  4   132      dcl	   (pascal_integer_dtype  init (1),
  4   133 	   pascal_real_dtype      init (4),
  4   134 	   pascal_label_dtype     init (24),
  4   135 	   pascal_internal_procedure_dtype init (25),
  4   136 	   pascal_exportable_procedure_dtype init (26),
  4   137 	   pascal_imported_procedure_dtype init (27),
  4   138 	   pascal_typed_pointer_type_dtype init (64),
  4   139 	   pascal_char_dtype      init (65),
  4   140 	   pascal_boolean_dtype   init (66),
  4   141 	   pascal_record_file_type_dtype init (67),
  4   142 	   pascal_record_type_dtype init (68),
  4   143 	   pascal_set_dtype	      init (69),
  4   144 	   pascal_enumerated_type_dtype init (70),
  4   145 	   pascal_enumerated_type_element_dtype init (71),
  4   146 	   pascal_enumerated_type_instance_dtype init (72),
  4   147 	   pascal_user_defined_type_dtype init (73),
  4   148 	   pascal_user_defined_type_instance_dtype init (74),
  4   149 	   pascal_text_file_dtype init (75),
  4   150 	   pascal_procedure_type_dtype init (76),
  4   151 	   pascal_variable_formal_parameter_dtype init (77),
  4   152 	   pascal_value_formal_parameter_dtype init (78),
  4   153 	   pascal_entry_formal_parameter_dtype init (79),
  4   154 	   pascal_parameter_procedure_dtype init (80),
  4   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  4   156 
  4   157 
  4   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      387 
      388 
  5     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
      389 
      390    end im_make_parent_key;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1359.9  im_make_parent_key.pl1            >special_ldd>install>MR12.2-1184>im_make_parent_key.pl1
381          1    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
383          2    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
385          3    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
387          4    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
389          5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000005 constant        bit(36)                  initial dcl 5-7 set ref 140*
ALL_FIELDS_PRESENT              002032 constant        fixed bin(17,0)          initial dcl 110 ref 153 153 156 161
BITS_PER_BYTE                   002031 constant        fixed bin(17,0)          initial dcl 112 ref 188 189 232 253 253 274 283 328
                                                                                  329 335 342 350 350 350 364
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 112 ref 173 173 178 178 232 235 235 249
                                                                                  249 256 260 262 290 290 293 295 308 315 315 320
                                                                                  320 346 346 355 357 364
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 112 ref 270 274 274 335 335
FIELD_TABLE_VERSION_3           000000 constant        char(8)                  initial dcl 1-69 set ref 140 140*
addr                                                   builtin function         dcl 104 ref 183 184 200 201 205 205 226 274 274 331
                                                                                  335 335
arg_descriptor                         based           structure                level 1 dcl 3-6
arg_descriptor_ptr              000140 automatic       pointer                  dcl 3-34 set ref 226* 228 232 267 270
based_char_string                      based           char                     packed unaligned dcl 100 ref 274 274 335 335
bin                                                    builtin function         dcl 104 ref 306
bit_dtype                              constant        fixed bin(17,0)          initial dcl 4-25 ref 228
bit_idx                         000101 automatic       fixed bin(35,0)          initial dcl 75 set ref 75* 235* 235 235* 243 249 249
                                                                                  253 256 259* 259 260 262 283* 284 290 290 295 346*
                                                                                  346 346* 350 350
bk_string_length                000134 automatic       fixed bin(35,0)          dcl 2-39 set ref 150* 151* 151 249 256 260 290 293
                                                                                  308 355 357 364
branch_key                             based           structure                level 1 packed packed unaligned dcl 2-32 set ref 151
branch_key_ptr                  000136 automatic       pointer                  dcl 2-40 set ref 149* 151 221 226 228 235 235 235
                                                                                  243 249 249 249 253 256 256 260 260 262 274 274
                                                                                  274 284 290 290 290 293 293 295 306 308 331 355
                                                                                  357 364 376
branch_key_varying_data_idx     000131 automatic       fixed bin(35,0)          initial dcl 91 set ref 91* 262* 295* 303* 355 370*
                                                                                  370 377
char_dtype                             constant        fixed bin(17,0)          initial dcl 4-25 ref 267
char_idx                        000103 automatic       fixed bin(35,0)          initial dcl 78 set ref 78* 274* 274 274* 283 293
                                                                                  335* 335 335* 342
copy                                                   builtin function         dcl 104 ref 173 178 315 320
data_format_util_$compare_field_to_field
                                000010 constant        entry                    external dcl 120 ref 205
descriptor                6            based           bit(36)                  array level 3 dcl 1-36 set ref 205 205 226 331
divide                                                 builtin function         dcl 104 ref 274 335 364
dm_error_$key_duplication       000022 external static fixed bin(35,0)          dcl 128 ref 214
dm_error_$keys_out_of_order     000024 external static fixed bin(35,0)          dcl 128 set ref 218*
dm_error_$programming_error     000020 external static fixed bin(35,0)          dcl 128 set ref 243* 284*
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 128 set ref 140*
extended_arg_type               000142 automatic       fixed bin(17,0)          initial dcl 3-36 set ref 3-36*
field                     5            based           structure                array level 2 dcl 1-36 set ref 153
field_idx                       000111 automatic       fixed bin(17,0)          initial dcl 85 set ref 85* 168* 170 173 173 173 178
                                                                                  178 178 185 200 201 205 205* 221 306* 308 308 308
                                                                                  308 308 315 315 315 320 320 320 326 331 331 357
                                                                                  357 357 357 357 364 364 364 364*
field_table                            based           structure                level 1 dcl 1-36
field_table_ptr                 000132 automatic       pointer                  dcl 1-65 set ref 139* 140 140 153 156 158 158 161
                                                                                  163 163 170 173 173 173 178 178 178 185 200 201
                                                                                  205 205 226 228 235 235 235 243 249 249 253 256
                                                                                  260 262 274 274 274 284 290 290 293 295 301 302
                                                                                  303 308 308 308 308 308 315 315 315 320 320 320
                                                                                  326 331 357 357 357 357 357 364 364 364 364
flags                     5            based           structure                array level 3 dcl 1-36
hbound                                                 builtin function         dcl 104 ref 153
high_key_bit_array                     based           bit(1)                   array packed unaligned dcl 99 set ref 184 201 274
                                                                                  335
high_key_string                        based           bit                      packed unaligned dcl 97 ref 178 235 249 290 308 320
                                                                                  346 355
high_value_length               000113 automatic       fixed bin(35,0)          initial dcl 87 set ref 87* 178* 189 194 199* 205*
                                                                                  320* 329* 329 335 342* 346 350* 355 355 357 364
                                                                                  369 370
high_value_ptr                  000116 automatic       pointer                  initial dcl 89 set ref 89* 184* 201* 205*
high_varying_data_idx           000106 automatic       fixed bin(17,0)          initial dcl 82 set ref 82* 161* 163* 184 189* 189
                                                                                  194* 194 302* 335 346 355 369* 369
last_field_idx            0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 2-32
                                                                                  set ref 221* 226 228 235 235 235 243 249 249 253
                                                                                  256 260 262 274 274 274 284 290 290 293 295 306
                                                                                  331
last_field_is_truncated         000100 automatic       bit(1)                   initial dcl 73 set ref 73* 227* 264* 297* 303 306
length                                                 builtin function         dcl 104 ref 151
length_in_bits           10            based           fixed bin(35,0)          array level 3 dcl 1-36 ref 158 163 173 173 178 178
                                                                                  235 243 274 284 308 308 315 315 320 320 357 357
                                                                                  357 364 364 364
length_is_in_characters
                          5(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 1-36 ref
                                                                                  185 326 357
location                  7            based           fixed bin(35,0)          array level 3 dcl 1-36 ref 158 163 173 178 200 201
                                                                                  235 235 249 249 253 256 260 262 274 274 290 290
                                                                                  293 295 308 308 315 320 357 364
location_of_first_varying_field
                          4            based           fixed bin(35,0)          level 2 dcl 1-36 ref 156 161 301 302 303
low_equal_to_high               000107 automatic       bit(1)                   initial dcl 83 set ref 83* 167* 168 205* 211
low_key_bit_array                      based           bit(1)                   array packed unaligned dcl 98 set ref 183 200 274
                                                                                  335
low_key_string                         based           bit                      packed unaligned dcl 96 ref 173 235 315 346
low_less_than_high              000110 automatic       bit(1)                   initial dcl 84 set ref 84* 205* 218
low_value_length                000112 automatic       fixed bin(35,0)          initial dcl 86 set ref 86* 173* 188 193 199* 205*
                                                                                  315* 328* 328 335 346
low_value_ptr                   000114 automatic       pointer                  initial dcl 88 set ref 88* 183* 200* 205*
low_varying_data_idx            000105 automatic       fixed bin(17,0)          initial dcl 81 set ref 81* 156* 158* 183 188* 188
                                                                                  193* 193 301* 335 346
maximum_field_idx               000104 automatic       fixed bin(17,0)          initial dcl 80 set ref 80* 153* 155* 168
min                                                    builtin function         dcl 104 ref 155 335 346
mod                                                    builtin function         dcl 104 ref 253 350
myname                          000120 automatic       varying char(32)         initial dcl 90 set ref 90* 140* 218* 243* 284*
null                                                   builtin function         dcl 104 ref 88 89 140 140 147 218 218 243 243 284
                                                                                  284
number_of_bits_needed_to_adjust_for_byte_alignment
                                000102 automatic       fixed bin(17,0)          initial dcl 76 set ref 76* 253* 256 259
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 1-36 ref 153 170 228 308
p_branch_key_ptr                       parameter       pointer                  dcl 64 set ref 17 147* 376*
p_branch_key_string_length             parameter       fixed bin(35,0)          dcl 65 set ref 17 148* 377*
p_code                                 parameter       fixed bin(35,0)          dcl 69 set ref 17 137* 168 205* 214*
p_field_table_ptr                      parameter       pointer                  dcl 52 ref 17 139
p_high_key_string_ptr                  parameter       pointer                  dcl 56 ref 17 178 184 201 235 249 274 290 308 320
                                                                                  335 346 355
p_last_field_in_high_key               parameter       fixed bin(17,0)          packed unaligned dcl 57 ref 17 153 155 161 163 163
p_last_field_in_low_key                parameter       fixed bin(17,0)          packed unaligned dcl 54 ref 17 153 155 156 158 158
p_low_key_string_ptr                   parameter       pointer                  dcl 53 ref 17 173 183 200 235 274 315 335 346
p_new_buffer_was_allocated             parameter       bit(1)                   dcl 67 set ref 17 146*
p_parent_key_buffer_length             parameter       fixed bin(35,0)          dcl 61 ref 17 151
p_parent_key_buffer_ptr                parameter       pointer                  dcl 59 ref 17 149
p_work_area_ptr                        parameter       pointer                  dcl 63 ref 17
size                      0(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 3-6 ref
                                                                                  232 270
string                    1            based           bit                      level 2 packed packed unaligned dcl 2-32 set ref
                                                                                  249* 256* 260* 290* 293* 308* 355* 357* 364*
sub_err_                        000012 constant        entry                    external dcl 123 ref 140 218 243 284
substr                                                 builtin function         dcl 104 set ref 173 178 235 235 249* 249 256* 260*
                                                                                  274 274 290* 290 293* 308* 308 315 320 335 335 346
                                                                                  346 355* 355 357* 357 364* 364
sys_info$max_seg_size           000014 external static fixed bin(35,0)          dcl 127 ref 173 178 235 235 249 274 274 290 308 315
                                                                                  320 335 335 346 346 355
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 3-6 ref
                                                                                  228 267 331
unspec                                                 builtin function         dcl 104 set ref 151 173* 178* 260 293 315* 320* 357
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 4-25 ref 331
varying_field_index                    based           fixed bin(17,0)          array level 3 dcl 1-36 ref 170 228 308
varying_field_map                      based           structure                array level 2 dcl 1-36
version                                based           char(8)                  initial level 2 dcl 1-36 set ref 140 140*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 5-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7
BRANCH_KEY_HEADER_LENGTH_IN_BITS       internal static fixed bin(35,0)          initial dcl 2-37
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 4-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 4-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 4-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 4-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 4-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 4-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 4-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 4-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 4-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 4-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 4-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 4-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 4-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 4-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 4-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 4-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 4-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 4-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 4-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 4-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 4-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 4-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 4-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 4-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 4-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 4-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 4-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 4-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 4-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 4-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
entry_dtype                            internal static fixed bin(17,0)          initial dcl 4-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 4-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 4-125
extended_arg_descriptor                based           structure                level 1 dcl 3-21
field_name                             based           char                     packed unaligned dcl 1-71
field_name_length                      automatic       fixed bin(17,0)          dcl 1-73
field_name_ptr                         automatic       pointer                  dcl 1-74
file_dtype                             internal static fixed bin(17,0)          initial dcl 4-25
fixed_arg_descriptor                   based           structure                level 1 dcl 3-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 4-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 4-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 4-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 4-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 4-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 4-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 4-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 4-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 4-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 4-96
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 1-66
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 4-96
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 1-68
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 4-96
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 4-125
key_string                             based           bit                      packed unaligned dcl 2-22
key_string_length                      automatic       fixed bin(35,0)          dcl 2-23
key_string_ptr                         automatic       pointer                  dcl 2-24
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 4-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 4-25
leaf_key                               based           structure                level 1 packed packed unaligned dcl 2-26
leaf_key_ptr                           automatic       pointer                  dcl 2-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 2-29
offset_dtype                           internal static fixed bin(17,0)          initial dcl 4-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 4-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 4-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 4-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 4-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 4-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 4-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 4-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 4-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 4-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 4-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 4-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 4-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 4-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 4-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 4-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 4-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 4-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 4-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 4-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 4-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 4-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 4-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 4-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 4-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 4-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 4-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 4-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 4-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 4-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 4-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 4-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25
structure_dtype                        internal static fixed bin(17,0)          initial dcl 4-25
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 4-25

NAMES DECLARED BY EXPLICIT CONTEXT.
COMPARISON_LOOP                 000364 constant        label                    dcl 168
COPY_LOOP                       001371 constant        label                    dcl 306
im_make_parent_key              000134 constant        entry                    external dcl 17

NAME DECLARED BY CONTEXT OR IMPLICATION.
bit                                                    builtin function         ref 364

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2170        2216    2034        2200
Length      2512    2034        26         260     133           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_make_parent_key                  192 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_make_parent_key       000100 last_field_is_truncated     im_make_parent_key
                         000101 bit_idx                     im_make_parent_key
                         000102 number_of_bits_needed_to_adjust_for_byte_alignment
                                                            im_make_parent_key
                         000103 char_idx                    im_make_parent_key
                         000104 maximum_field_idx           im_make_parent_key
                         000105 low_varying_data_idx        im_make_parent_key
                         000106 high_varying_data_idx       im_make_parent_key
                         000107 low_equal_to_high           im_make_parent_key
                         000110 low_less_than_high          im_make_parent_key
                         000111 field_idx                   im_make_parent_key
                         000112 low_value_length            im_make_parent_key
                         000113 high_value_length           im_make_parent_key
                         000114 low_value_ptr               im_make_parent_key
                         000116 high_value_ptr              im_make_parent_key
                         000120 myname                      im_make_parent_key
                         000131 branch_key_varying_data_idx im_make_parent_key
                         000132 field_table_ptr             im_make_parent_key
                         000134 bk_string_length            im_make_parent_key
                         000136 branch_key_ptr              im_make_parent_key
                         000140 arg_descriptor_ptr          im_make_parent_key
                         000142 extended_arg_type           im_make_parent_key

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_bit_temp      cat_realloc_bits    call_ext_out_desc   call_ext_out        return_mac          mdfx3
shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
data_format_util_$compare_field_to_field                    sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$key_duplication     dm_error_$keys_out_of_order   dm_error_$programming_error
error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000123        73 000141        75 000142        76 000143        78 000144        80 000145        81 000146
     82 000147        83 000150        84 000151        85 000152        86 000153        87 000154        88 000155
     89 000157        90 000160        91 000165    3   36 000166       137 000170       139 000172       140 000175
    146 000252       147 000254       148 000256       149 000257       150 000262       151 000263       153 000274
    155 000324       156 000330       158 000337       161 000346       163 000354       167 000362       168 000364
    170 000401       173 000413       178 000454       183 000505       184 000513       185 000523       188 000526
    189 000532       190 000536       193 000537       194 000543       196 000547       199 000550       200 000553
    201 000564       205 000571       209 000623       211 000625       214 000630       215 000634       218 000635
    221 000676       226 000706       227 000717       228 000720       232 000741       235 000747       242 001002
    243 001007       249 001070       253 001116       256 001131       259 001140       260 001144       262 001150
    264 001155       266 001157       267 001160       270 001162       274 001170       282 001227       283 001234
    284 001237       290 001320       293 001346       295 001353       297 001360       301 001362       302 001365
    303 001366       306 001371       308 001412       315 001441       320 001503       326 001533       328 001540
    329 001543       331 001546       335 001564       341 001622       342 001627       343 001632       346 001633
    349 001663       350 001670       355 001704       357 001716       364 001761       369 002005       370 002011
    374 002015       376 002017       377 002022       379 002030


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
