	COMPILATION LISTING OF SEGMENT le_msf_partition_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1256.3 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to determine the placement of each input component
       11*     into an output MSF component (if there is enough input to cause MSF
       12*     generation) and to calculate the relocation values for each input
       13*     component.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       17 
       18 le_msf_partition_:
       19   proc (lecp,			/** components pointer  (i/o)	*/
       20        component_size,		/** max size in pages   (in ) */
       21        n_components);		/** no of output comp.  (out) */
       22 
       23   /*** ****************************************************************/
       24   /***							*/
       25   /***	Name:	le_msf_partition_				*/
       26   /***	Input:	lecp, component_size			*/
       27   /***	Function:	Partitions the input components into output	*/
       28   /***		components.  This is where it is determined	*/
       29   /***		if the output will be an MSF.  If all of the	*/
       30   /***		components fit within the component size limit	*/
       31   /***		given, a normal object segment will be created.	*/
       32   /***		If more than one is required, an MSF is created.	*/
       33   /***	Output:	lecp, n_components				*/
       34   /***							*/
       35   /*** ****************************************************************/
       36 
       37   /* constants */
       38 
       39   dcl max_linkage_words	fixed bin (19) static options (constant)
       40 			init (16384);
       41   dcl max_static_words	fixed bin (19) static options (constant)
       42 			init (16384);
       43 
       44   /* parameters */
       45 
       46   dcl lecp		ptr parameter;
       47   dcl component_size	fixed bin parameter;
       48   dcl n_components		fixed bin parameter;
       49 
       50   /* procedures */
       51 
       52   dcl le_debug_		entry options (variable);
       53   dcl le_error_		entry options (variable);
       54   dcl le_util_$get_user_and_version
       55 			entry (char (*), char (*));
       56 
       57   /* external */
       58 
       59   dcl le_et_$component_too_big
       60 			external fixed bin (35);
       61 
       62   /* based */
       63 
       64   dcl 01 lec		aligned based (lecp),
       65        02 header		aligned like le_components.header,
       66        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       67 
       68   /* automatic */
       69 
       70   dcl bound		fixed bin automatic;
       71   dcl c			fixed bin automatic;
       72   dcl c_linkage_words	fixed bin (19) automatic;
       73   dcl c_static_words	fixed bin (19) automatic;
       74   dcl c_symbol_words	fixed bin (19) automatic;
       75   dcl c_text_words		fixed bin (19) automatic;
       76   dcl c_words		fixed bin (19) automatic;
       77   dcl max_words		fixed bin (19) automatic;
       78   dcl n_linkage_words	fixed bin (19) automatic;
       79   dcl n_static_words	fixed bin (19) automatic;
       80   dcl n_symbol_words	fixed bin (19) automatic;
       81   dcl n_text_words		fixed bin (19) automatic;
       82   dcl n_words		fixed bin (19) automatic;
       83   dcl pad			fixed bin (19) automatic;
       84   dcl pad_base		fixed bin (19) automatic;
       85   dcl symbol_base		fixed bin (19) automatic;
       86   dcl user		char (32) automatic;
       87   dcl version		char (128) automatic;
       88 
       89   /* builtin */
       90 
       91   dcl divide		builtin;
       92   dcl length		builtin;
       93   dcl mod			builtin;
       94   dcl rtrim		builtin;
       95   dcl size		builtin;
       96 
       97   call le_debug_ ("Beginning MSF partitioning.");
       98 
       99   /* set the starting point for symbol sections to take the size of	*/
      100   /* the symbol header, version string, and user string into account	*/
      101 
      102   call le_util_$get_user_and_version (user, version);
      103   symbol_base = size (std_symbol_header);
      104   symbol_base = divide (length (rtrim (user)) + 3, 4, 17, 0) +
      105        divide (length (rtrim (version)) + 3, 4, 17, 0) + symbol_base;
      106   pad_base = mod (symbol_base, 2);
      107 
      108   n_components = 1;
      109   max_words = component_size * 1024;
      110   n_words = 0;
      111   n_static_words = 0;
      112   n_linkage_words = 0;
      113   n_text_words = 0;
      114   n_symbol_words = 0;
      115 
      116   do c = 1 to lec.n_components;
      117 
      118     /* for each included component . . . */
      119 
      120     if lec.comp (c).flags.include
      121       then do;
      122 
      123         /* calculate the number of words in the input component */
      124 
      125         c_words = divide (lec.comp (c).bc, 36, 19, 0);
      126 
      127         /* calculate the section sizes */
      128 
      129         c_linkage_words = lec.comp (c).orig.linkl;
      130         c_static_words = lec.comp (c).orig.statl;
      131         c_text_words = lec.comp (c).orig.textl;
      132         c_symbol_words = lec.comp (c).orig.symbl_no_rel;
      133 
      134         /* adjust the linkage size for combined static */
      135 
      136         if lec.comp (c).flags.separate_static &
      137 	   ^lec.header.flags.separate_static
      138 	then c_linkage_words = c_linkage_words + c_static_words;
      139 
      140         /* adjust the symbol size for table removal */
      141 
      142         if lec.comp (c).flags.delete_table
      143 	then c_symbol_words = lec.comp (c).orig.symbl_no_table;
      144 
      145         lec.comp (c).orig.symbl = c_symbol_words;
      146 
      147         /* print a message if we are forcing an oversize output	*/
      148         /* component					*/
      149 
      150         if c_words > max_words
      151 	then call le_error_ (LE_WARNING, le_et_$component_too_big,
      152 		"^/Component ^a (^d pages) is larger than ^d pages.",
      153 		lec.comp (c).name, divide (c_words + 1023, 1024, 9, 0),
      154 		component_size);
      155 
      156         /* if the output component is empty, include the component	*/
      157         /* even if it is larger than the maximum size to prevent	*/
      158         /* looping into an infinite number of components because we	*/
      159         /* couldn't ever fit one input component into a single output	*/
      160         /* component.					*/
      161 
      162         if n_words = 0
      163 	then do;
      164 
      165 	  /* set the section and total size values */
      166 
      167 	  n_words = c_words;
      168 	  n_static_words = c_static_words;
      169 	  n_text_words = c_text_words;
      170 	  n_linkage_words = c_linkage_words;
      171 	  lec.comp (c).target = n_components;
      172 
      173 	  /* zero the relocation counters */
      174 
      175 	  lec.comp (c).new.rel_text = 0;
      176 	  lec.comp (c).new.rel_stat = 0;
      177 	  lec.comp (c).new.text_pad = 0;
      178 	  lec.comp (c).new.static_pad = 0;
      179 
      180 	  /* set the symbol relocation counter accounting for the	*/
      181 	  /* symbol header and strings			*/
      182 
      183 	  lec.comp (c).new.rel_symb = symbol_base + pad_base;
      184 	  lec.comp (c).new.symbol_pad = pad_base;
      185 	  n_symbol_words = symbol_base + pad_base + c_symbol_words;
      186 	end;
      187         else if n_words + c_words > max_words
      188 	then do;
      189 
      190 	  /* if adding this input component would overflow the	*/
      191 	  /* output component, skip to the next component		*/
      192 
      193 	  call le_debug_ ("Skipping to component ^d due to size overflow.",
      194 	       n_components + 1);
      195 
      196 	  n_components = n_components + 1;
      197 	  n_words = c_words;
      198 	  n_static_words = c_static_words;
      199 	  n_linkage_words = c_linkage_words;
      200 	  n_text_words = c_text_words;
      201 	  lec.comp (c).target = n_components;
      202 
      203 	  /* zero the relocation counters */
      204 
      205 	  lec.comp (c).new.rel_text = 0;
      206 	  lec.comp (c).new.rel_stat = 0;
      207 	  lec.comp (c).new.text_pad = 0;
      208 	  lec.comp (c).new.static_pad = 0;
      209 
      210 	  /* set the symbol relocation counter accounting for the	*/
      211 	  /* symbol header and strings			*/
      212 
      213 	  lec.comp (c).new.rel_symb = symbol_base + pad_base;
      214 	  lec.comp (c).new.symbol_pad = pad_base;
      215 	  n_symbol_words = symbol_base + pad_base + c_symbol_words;
      216 	end;
      217         else if n_static_words + c_static_words > max_static_words
      218 	then do;
      219 
      220 	  /* if adding to this component would overflow the maximum	*/
      221 	  /* addressible static section size, then skip to the next	*/
      222 	  /* component.					*/
      223 
      224 	  call le_debug_ (
      225 	       "Skipping to component ^d due to static section overflow.",
      226 	       n_components + 1);
      227 
      228 	  n_components = n_components + 1;
      229 	  n_words = c_words;
      230 	  n_static_words = c_static_words;
      231 	  n_linkage_words = c_linkage_words;
      232 	  n_text_words = c_text_words;
      233 	  lec.comp (c).target = n_components;
      234 
      235 	  /* zero the relocation counters */
      236 
      237 	  lec.comp (c).new.rel_text = 0;
      238 	  lec.comp (c).new.rel_stat = 0;
      239 	  lec.comp (c).new.text_pad = 0;
      240 	  lec.comp (c).new.static_pad = 0;
      241 
      242 	  /* set the symbol relocation counter accounting for the	*/
      243 	  /* symbol header and strings			*/
      244 
      245 	  lec.comp (c).new.rel_symb = symbol_base + pad_base;
      246 	  lec.comp (c).new.symbol_pad = pad_base;
      247 	  n_symbol_words = symbol_base + pad_base + c_symbol_words;
      248 	end;
      249         else if n_linkage_words + c_linkage_words > max_linkage_words
      250 	then do;
      251 
      252 	  /* if adding to this component would overflow the maximum	*/
      253 	  /* addressible linkage section size, then skip to the	*/
      254 	  /* next component.				*/
      255 
      256 	  call le_debug_ (
      257 	       "Skipping to component ^d due to linkage section overflow.",
      258 	       n_components + 1);
      259 
      260 	  n_components = n_components + 1;
      261 	  n_words = c_words;
      262 	  n_static_words = c_static_words;
      263 	  n_linkage_words = c_linkage_words;
      264 	  lec.comp (c).target = n_components;
      265 
      266 	  /* zero the relocation counters */
      267 
      268 	  lec.comp (c).new.rel_text = 0;
      269 	  lec.comp (c).new.rel_stat = 0;
      270 	  lec.comp (c).new.text_pad = 0;
      271 	  lec.comp (c).new.static_pad = 0;
      272 
      273 	  /* set the symbol relocation counter accounting for the	*/
      274 	  /* symbol header and strings			*/
      275 
      276 	  lec.comp (c).new.rel_symb = symbol_base + pad_base;
      277 	  lec.comp (c).new.symbol_pad = pad_base;
      278 	  n_symbol_words = symbol_base + pad_base + c_symbol_words;
      279 	end;
      280         else do;
      281 
      282 	/* otherwise just append this input component to the	*/
      283 	/* current output component.				*/
      284 
      285 	lec.comp (c).target = n_components;
      286 	n_words = n_words + c_words;
      287 
      288 	/* calculate the text relocation counter, padding if reqd	*/
      289 	/* to get the necessary text boundary.			*/
      290 
      291 	bound = lec.comp (c).orig.text_boundary;
      292 	pad = mod (n_text_words, bound);
      293 	lec.comp (c).new.rel_text = n_text_words + pad;
      294 	lec.comp (c).new.text_pad = pad;
      295 	n_text_words = n_text_words + pad + c_text_words;
      296 
      297 	/* calculate the static relocation counter, padding if reqd	*/
      298 	/* to get the necessary static boundary.		*/
      299 
      300 	bound = lec.comp (c).orig.static_boundary;
      301 	pad = mod (n_static_words, bound);
      302 	lec.comp (c).new.rel_stat = n_static_words + pad;
      303 	lec.comp (c).new.static_pad = pad;
      304 	n_static_words = n_static_words + pad + c_static_words;
      305 
      306 	/* calculate the symbol relocation counter */
      307 
      308 	pad = mod (n_symbol_words, 2);
      309 	lec.comp (c).new.rel_symb = n_symbol_words + pad;
      310 	lec.comp (c).new.symbol_pad = pad;
      311 	n_symbol_words = n_symbol_words + pad + c_symbol_words;
      312         end;
      313 
      314         call le_debug_ ("Placing input component ""^a"" in component ^d.",
      315 	   lec.comp (c).name, n_components);
      316       end;
      317   end;
      318 
      319   call le_debug_ ("Completed MSF partitioning.^2/");
      320 
      321   return;
      322 
      323 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      324 
      325 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      326 
      327 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03 mbz		bit (29) unaligned;
  1   190   
  1   191   /*** ****************************************************************/
  1   192   /***							*/
  1   193   /***	Name:	le_options				*/
  1   194   /***	Function:	the option table contains definition retention	*/
  1   195   /***		information.  The input retentions options are	*/
  1   196   /***		ordered such that a linear search of the option	*/
  1   197   /***		table for the first matching starname will give	*/
  1   198   /***		the correct retention state.			*/
  1   199   /***							*/
  1   200   /*** ****************************************************************/
  1   201   
  1   202   dcl 01 le_options		aligned based,
  1   203        02 header		aligned,
  1   204         03 n_opts		fixed bin,
  1   205        02 opt		(0 refer (le_options.n_opts)),
  1   206         03 type		fixed bin (8) unaligned,
  1   207         03 used		bit (1) unaligned,
  1   208         03 inhibit_error	bit (1) unaligned,
  1   209         03 class		fixed bin (6) unaligned,
  1   210         03 order		fixed bin (17) unaligned,
  1   211         03 segname		char (32) unaligned,
  1   212         03 ep_name		char (256) unaligned;
  1   213   
  1   214   /*** ****************************************************************/
  1   215   /***							*/
  1   216   /***	Name:	le_links					*/
  1   217   /***	Function:	the link table contains information on all of the	*/
  1   218   /***		links in the input components. It is used to	*/
  1   219   /***		determine link targets, which library components	*/
  1   220   /***		will be included, and what init_info will be	*/
  1   221   /***		used, and where it will be placed.		*/
  1   222   /***							*/
  1   223   /*** ****************************************************************/
  1   224   
  1   225   dcl 01 le_links		aligned based,
  1   226        02 header		aligned,
  1   227         03 offset_adjustment	fixed bin (18),
  1   228         03 n_links		fixed bin,
  1   229        02 link		(link_count refer (le_links.n_links))
  1   230 			like le_link;
  1   231   dcl link_count		fixed bin automatic;
  1   232 
  1   233   dcl 01 le_link		aligned based,
  1   234        02 flags		unaligned,
  1   235         03 used		bit (1),
  1   236         03 mbx		bit (35),
  1   237        02 type		fixed bin (6) unsigned unaligned,
  1   238        02 class		fixed bin (6) unsigned unaligned,
  1   239        02 mod		bit (6) unaligned,
  1   240        02 exp		fixed bin (17) unaligned,
  1   241        02 target		fixed bin (18) unsigned unaligned,
  1   242        02 defx		fixed bin (18) unsigned unaligned,
  1   243        02 relp		fixed bin (18) unsigned unaligned,
  1   244        02 target_comp	fixed bin (18) unsigned unaligned,
  1   245        02 target_link	fixed bin (18) unsigned unaligned,
  1   246        02 extension		fixed bin (18) unsigned unaligned,
  1   247        02 initp		ptr unaligned,
  1   248        02 segnamep		ptr unaligned,
  1   249        02 offsetp		ptr unaligned;
  1   250   
  1   251   /*** ****************************************************************/
  1   252   /***							*/
  1   253   /***	Name:	le_binaries				*/
  1   254   /***	Function:	This table contains information about the output	*/
  1   255   /***		binaries.  It is primarily used for creation and	*/
  1   256   /***		backpatching of MSF output.			*/
  1   257   /***							*/
  1   258   /*** ****************************************************************/
  1   259   
  1   260   dcl 01 le_binaries	aligned based,
  1   261        02 header		aligned,
  1   262         03 n_binaries	fixed bin,
  1   263         03 pad		bit (36),
  1   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  1   265         03 segp		ptr,
  1   266         03 bc		fixed bin (24),
  1   267         03 uid		bit (36),
  1   268         03 aclc		fixed bin,
  1   269         03 aclp		ptr,
  1   270         03 textp		ptr,
  1   271         03 defnp		ptr,
  1   272         03 linkp		ptr,
  1   273         03 symbp		ptr,
  1   274         03 statp		ptr,
  1   275         03 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      328 
  2     1 dcl	1 std_symbol_header	based aligned,
  2     2 	2 dcl_version	fixed bin,
  2     3 	2 identifier	char(8),
  2     4 	2 gen_number	fixed bin,
  2     5 	2 gen_created	fixed bin(71),
  2     6 	2 object_created	fixed bin(71),
  2     7 	2 generator	char(8),
  2     8 	2 gen_version	unaligned,
  2     9 	  3 offset	bit(18),
  2    10 	  3 size		bit(18),
  2    11 	2 userid		unaligned,
  2    12 	  3 offset	bit(18),
  2    13 	  3 size		bit(18),
  2    14 	2 comment		unaligned,
  2    15 	  3 offset	bit(18),
  2    16 	  3 size		bit(18),
  2    17 	2 text_boundary	bit(18) unaligned,
  2    18 	2 stat_boundary	bit(18) unaligned,
  2    19 	2 source_map	bit(18) unaligned,
  2    20 	2 area_pointer	bit(18) unaligned,
  2    21 	2 backpointer	bit(18) unaligned,
  2    22 	2 block_size	bit(18) unaligned,
  2    23 	2 next_block	bit(18) unaligned,
  2    24 	2 rel_text	bit(18) unaligned,
  2    25 	2 rel_def		bit(18) unaligned,
  2    26 	2 rel_link	bit(18) unaligned,
  2    27 	2 rel_symbol	bit(18) unaligned,
  2    28 	2 mini_truncate	bit(18) unaligned,
  2    29 	2 maxi_truncate	bit(18) unaligned;
      329 
      330 
      331   end le_msf_partition_;
      332 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1251.8  le_msf_partition_.pl1             >special_ldd>install>MR12.0-1241>le_msf_partition_.pl1
328          1    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
329          2    05/06/74  1751.6  std_symbol_header.incl.pl1        >ldd>include>std_symbol_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LE_WARNING                      000016 constant        fixed bin(17,0)          initial dcl 1-19 set ref 150*
bc                        4            based           fixed bin(24,0)          array level 3 dcl 64 ref 125
bound                           000100 automatic       fixed bin(17,0)          dcl 70 set ref 291* 292 300* 301
c                               000101 automatic       fixed bin(17,0)          dcl 71 set ref 116* 120 125 129 130 131 132 136 142
                                                                                  142 145 150 171 175 176 177 178 183 184 201 205
                                                                                  206 207 208 213 214 233 237 238 239 240 245 246
                                                                                  264 268 269 270 271 276 277 285 291 293 294 300
                                                                                  302 303 309 310 314*
c_linkage_words                 000102 automatic       fixed bin(19,0)          dcl 72 set ref 129* 136* 136 170 199 231 249 263
c_static_words                  000103 automatic       fixed bin(19,0)          dcl 73 set ref 130* 136 168 198 217 230 262 304
c_symbol_words                  000104 automatic       fixed bin(19,0)          dcl 74 set ref 132* 142* 145 185 215 247 278 311
c_text_words                    000105 automatic       fixed bin(19,0)          dcl 75 set ref 131* 169 200 232 295
c_words                         000106 automatic       fixed bin(19,0)          dcl 76 set ref 125* 150 150 150 167 187 197 229 261
                                                                                  286
comp                      2            based           structure                array level 2 dcl 64
component_size                         parameter       fixed bin(17,0)          dcl 47 set ref 18 109 150*
delete_table            106(02)        based           bit(1)                   array level 4 packed unaligned dcl 64 ref 142
divide                                                 builtin function         dcl 91 ref 104 104 125 150 150
flags                   106            based           structure                array level 3 in structure "lec" dcl 64 in procedure
                                                                                  "le_msf_partition_"
flags                                  based           structure                level 3 in structure "lec" dcl 64 in procedure
                                                                                  "le_msf_partition_"
header                                 based           structure                level 2 in structure "le_components" dcl 1-72
                                                                                  in procedure "le_msf_partition_"
header                                 based           structure                level 2 in structure "lec" dcl 64 in procedure
                                                                                  "le_msf_partition_"
include                 106(01)        based           bit(1)                   array level 4 packed unaligned dcl 64 ref 120
le_comp                                based           structure                level 1 dcl 1-89
le_components                          based           structure                level 1 dcl 1-72
le_debug_                       000010 constant        entry                    external dcl 52 ref 97 193 224 256 314 319
le_definition                          based           structure                level 1 dcl 1-175
le_error_                       000012 constant        entry                    external dcl 53 ref 150
le_et_$component_too_big        000016 external static fixed bin(35,0)          dcl 59 set ref 150*
le_link                                based           structure                level 1 dcl 1-233
le_patch                               based           structure                level 1 dcl 1-298
le_util_$get_user_and_version   000014 constant        entry                    external dcl 54 ref 102
lec                                    based           structure                level 1 dcl 64
lecp                                   parameter       pointer                  dcl 46 ref 18 116 120 125 129 130 131 132 136 136
                                                                                  142 142 145 150 171 175 176 177 178 183 184 201
                                                                                  205 206 207 208 213 214 233 237 238 239 240 245
                                                                                  246 264 268 269 270 271 276 277 285 291 293 294
                                                                                  300 302 303 309 310 314
length                                                 builtin function         dcl 92 ref 104 104
linkl                   137            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  129
max_linkage_words                      constant        fixed bin(19,0)          initial dcl 39 ref 249
max_static_words                       constant        fixed bin(19,0)          initial dcl 41 ref 217
max_words                       000107 automatic       fixed bin(19,0)          dcl 77 set ref 109* 150 187
mod                                                    builtin function         dcl 93 ref 106 292 301 308
n_components                           parameter       fixed bin(17,0)          dcl 48 in procedure "le_msf_partition_" set ref 18
                                                                                  108* 171 193 196* 196 201 224 228* 228 233 256
                                                                                  260* 260 264 285 314*
n_components              1            based           fixed bin(17,0)          level 3 in structure "lec" dcl 64 in procedure
                                                                                  "le_msf_partition_" ref 116
n_linkage_words                 000110 automatic       fixed bin(19,0)          dcl 78 set ref 112* 170* 199* 231* 249 263*
n_static_words                  000111 automatic       fixed bin(19,0)          dcl 79 set ref 111* 168* 198* 217 230* 262* 301 302
                                                                                  304* 304
n_symbol_words                  000112 automatic       fixed bin(19,0)          dcl 80 set ref 114* 185* 215* 247* 278* 308 309 311*
                                                                                  311
n_text_words                    000113 automatic       fixed bin(19,0)          dcl 81 set ref 113* 169* 200* 232* 292 293 295* 295
n_words                         000114 automatic       fixed bin(19,0)          dcl 82 set ref 110* 162 167* 187 197* 229* 261* 286*
                                                                                  286
name                     10            based           varying char(32)         array level 3 dcl 64 set ref 150* 314*
new                     143            based           structure                array level 3 dcl 64
orig                    116            based           structure                array level 3 dcl 64
pad                             000115 automatic       fixed bin(19,0)          dcl 83 set ref 292* 293 294 295 301* 302 303 304
                                                                                  308* 309 310 311
pad_base                        000116 automatic       fixed bin(19,0)          dcl 84 set ref 106* 183 184 185 213 214 215 245 246
                                                                                  247 276 277 278
rel_stat                144            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 176* 206* 238* 269* 302*
rel_symb                143(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 183* 213* 245* 276* 309*
rel_text                143            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 175* 205* 237* 268* 293*
rtrim                                                  builtin function         dcl 94 ref 104 104
separate_static                        based           bit(1)                   level 4 in structure "lec" packed unaligned dcl 64
                                                                                  in procedure "le_msf_partition_" ref 136
separate_static         106(03)        based           bit(1)                   array level 4 in structure "lec" packed unaligned
                                                                                  dcl 64 in procedure "le_msf_partition_" ref 136
size                                                   builtin function         dcl 95 ref 103
static_boundary         142(09)        based           fixed bin(9,0)           array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  300
static_pad              145            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 178* 208* 240* 271* 303*
statl                   137(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  130
std_symbol_header                      based           structure                level 1 dcl 2-1 ref 103
symbl                   140            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 145*
symbl_no_rel            140(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  132
symbl_no_table          141            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  142
symbol_base                     000117 automatic       fixed bin(19,0)          dcl 85 set ref 103* 104* 104 106 183 185 213 215 245
                                                                                  247 276 278
symbol_pad              145(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 184* 214* 246* 277* 310*
target                  105            based           fixed bin(17,0)          array level 3 dcl 64 set ref 171* 201* 233* 264*
                                                                                  285*
text_boundary           142            based           fixed bin(9,0)           array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  291
text_pad                144(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 set
                                                                                  ref 177* 207* 239* 270* 294*
textl                   136            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 64 ref
                                                                                  131
user                            000120 automatic       char(32)                 unaligned dcl 86 set ref 102* 104
version                         000130 automatic       char(128)                unaligned dcl 87 set ref 102* 104

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
LE_ABORT_ERROR                         internal static fixed bin(17,0)          initial dcl 1-22
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LE_FATAL_ERROR                         internal static fixed bin(17,0)          initial dcl 1-21
Linkage                                internal static fixed bin(3,0)           initial dcl 1-28
Patch_Init                             internal static fixed bin(17,0)          initial dcl 1-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 1-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 1-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 1-60
Refname_Base                           internal static fixed bin(3,0)           initial dcl 1-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 1-51
Self_Base                              internal static fixed bin(3,0)           initial dcl 1-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 1-53
Static                                 internal static fixed bin(3,0)           initial dcl 1-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 1-30
System                                 internal static fixed bin(3,0)           initial dcl 1-36
Text                                   internal static fixed bin(3,0)           initial dcl 1-26
def_count                              automatic       fixed bin(17,0)          dcl 1-173
le_binaries                            based           structure                level 1 dcl 1-260
le_definitions                         based           structure                level 1 

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
