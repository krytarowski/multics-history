	COMPILATION LISTING OF SEGMENT statement_type
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-06-29_1713.66_Thu_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        *********************************************************** */
       10 
       11 /* ******************************************************
       12*   *                                                    *
       13*   *                                                    *
       14*   * Copyright (c) 1972 by Massachusetts Institute of   *
       15*   * Technology and Honeywell Information Systems, Inc. *
       16*   *                                                    *
       17*   *                                                    *
       18*   ****************************************************** */
       19 
       20 
       21 
       22 /****^  HISTORY COMMENTS:
       23*  1) change(88-01-26,RWaters), approve(88-01-26,MCR7724), audit(88-02-05,Huen),
       24*     install(88-02-16,MR12.2-1024):
       25*     Expand the uses of options (constant) variables.
       26*  2) change(89-10-03,Vu), approve(89-10-03,MCR8139), audit(89-10-04,Blackmore),
       27*     install(89-10-09,MR12.3-1086):
       28*     PL1 confuses parameter variables with static constants.
       29*  3) change(91-01-18,Blackmore), approve(91-01-18,MCR8234),
       30*     audit(91-12-05,Huen), install(92-04-24,MR12.5-1011):
       31*     Change entry pt. and dcl of 'constant_token' entry to allow passing a ptr
       32*     to the current block, for the constant reference resolution fix.
       33*                                                   END HISTORY COMMENTS */
       34 
       35 
       36 statement_type:
       37 	proc(cblock,index,label_ptr,conditions) returns(fixed bin(15));
       38 
       39 /*	This function returns a bit string which identifies */
       40 /*	to the caller the kind of pl/1 statement currently contained */
       41 /*	in the token_list.						*/
       42 
       43 /*	statement_type is called with index set such that token_list(index)	*/
       44 /*	points to the first token of the statement to be identified.	*/
       45 /*	this may be a label, condition prefix, etc.  index may be other than */
       46 /*	one primarily when identifying the statement in an else clause.	*/
       47 /*	when statement_type returns the value of index will be such that	*/
       48 /*	token_list(index) points to the first token of the statement, i.e.	*/
       49 /*	labels and condition prefixes will have been scanned.	*/
       50 
       51 /*	"conditions" is a bit string set to record the settings */
       52 /*	of the condition prefixes of the statement.			*/
       53 
       54 /*	"label_ptr" is a pointer to the beginning of a node list containing the */
       55 /*	labels(entry names) of the statement.				*/
       56 
       57 /* Modified 770713 by PG to use pl1_stat_$level_0_colon flag */
       58 /* Modified 770715 by RAB to fix bug in recognizing null stmts caused by above change */
       59 /* Modified 15 Feb 1978 by PCK to implement the stop statement */
       60 /* Modified 28 Jan 1988 by RW to fix 1994 and 2186 */
       61 
       62 /* automatic */
       63 
       64 dcl	(index,j,k,ksaved,paren_count,n) fixed bin(15);
       65 dcl	(cblock,p,q,label_ptr,value_token) ptr;
       66 dcl	(assumed_s_type,next_type) bit(9) aligned;
       67 dcl	unknown_key_word char(12) aligned;
       68 dcl	condition_value bit(1) aligned;
       69 dcl	conditions bit(12) aligned;
       70 dcl	unknown_condition char(16) aligned;
       71 
       72 /* builtins */
       73 
       74 dcl	(fixed, hbound, lbound, mod, null, substr) builtin;
       75 
       76 /* external static */
       77 
       78 dcl	pl1_stat_$level_0_colon bit (1) aligned external static;
       79 
       80 /* internal static */
       81 
       82 dcl	key_word(0:33) char(12) aligned internal static
       83 	initial (	"if",
       84 		"go",
       85 		"call",
       86 		"do",
       87 		"else",
       88 		"dcl",
       89 		"allocate",
       90 		"proc",
       91 		"return",
       92 		"entry",
       93 		"procedure",
       94 		"free",
       95 		"declare",
       96 		"end",
       97 		"goto",
       98 		"get",
       99 		"put",
      100 		"begin",
      101 		"on",
      102 		"signal",
      103 		"revert",
      104 		"default",
      105 		"format",
      106 		"open",
      107 		"close",
      108 		"read",
      109 		"write",
      110 		"locate",
      111 		"delete",
      112 		"rewrite",
      113 		"system",
      114 		"dft",
      115 		"alloc",
      116 		"stop");
      117 
      118 dcl	s_type(0:33) bit(9) internal static
      119 	initial (	"000010011"b,	/* if */
      120 		"000010010"b,	/* go to */
      121 		"000000100"b,	/* call */
      122 		"000001010"b,	/* do */
      123 		"000001011"b,	/* else */
      124 		"000000110"b,	/* dcl */
      125 		"000000001"b,	/* allocate */
      126 		"000011000"b,	/* proc */
      127 		"000011011"b,	/* return */
      128 		"000001101"b,	/* entry */
      129 		"000011000"b,	/* procedure */
      130 		"000010000"b,	/* free */
      131 		"000000110"b,	/* declare */
      132 		"000001100"b,	/* end */
      133 		"000010010"b,	/* goto */
      134 		"000010001"b,	/* get */
      135 		"000011001"b,	/* put */
      136 		"000000011"b,	/* begin */
      137 		"000010110"b,	/* on */
      138 		"000011110"b,	/* signal */
      139 		"000011100"b,	/* revert */
      140 		"000100100"b,	/* default */
      141 		"000001111"b,	/* format */
      142 		"000010111"b,	/* open */
      143 		"000000101"b,	/* close */
      144 		"000011010"b,	/* read */
      145 		"000100011"b,	/* write */
      146 		"000010100"b,	/* locate */
      147 		"000001000"b,	/* delete */
      148 		"000011101"b,	/* rewrite */
      149 		"000100000"b,	/* system */
      150 		"000100100"b,	/* default dft*/
      151 		"000000001"b,	/* alloc */
      152 		"000011111"b);	/* stop */
      153 
      154 dcl	parn_not_allowed(0:33) bit(1) internal static aligned
      155 	initial(	"0"b,"1"b,"1"b,"1"b,"0"b,"0"b,"1"b,"0"b,"0"b,"0"b,"0"b,
      156 		"1"b,"0"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,
      157 		"0"b,"0"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,"1"b,
      158 		"0"b,"1"b,"1"b);
      159 
      160 /* include files */
      161 
  1     1 /* BEGIN INCLUDE FILE ... condition_name.incl.pl1 */
  1     2 /* The long names and short names of the conditions are stored in the same
  1     3*   array.  The indices of the long name and the short name differ by 10.  The
  1     4*   size condition has the same long name and short name. */
  1     5 /* format: style3,^delnl */
  1     6 
  1     7 declare	condition_name	(19) char (16) internal static options (constant) initial
  1     8 			("underflow", "overflow", "zerodivide", "fixedoverflow", "conversion",
  1     9 			"size", "subscriptrange", "stringrange", "stringsize", "size",
  1    10 			"ufl", "ofl", "zdiv", "fofl", "conv",
  1    11 			"size", "subrg", "strg", "strz");
  1    12 
  1    13 /* END INCLUDE FILE ... condition_name.incl.pl1 */
      162 
  2     1 /****^  *********************************************************
  2     2*        *                                                       *
  2     3*        * Copyright, (C) BULL HN Information Systems Inc., 1989 *
  2     4*        *                                                       *
  2     5*        ********************************************************* */
  2     6 
  2     7 /* BEGIN INCLUDE FILE ... language_utility.incl.pl1 */
  2     8 
  2     9 
  2    10 /****^  HISTORY COMMENTS:
  2    11*  1) change(89-07-10,RWaters), approve(89-07-10,MCR8118), audit(89-07-19,Vu),
  2    12*     install(89-07-31,MR12.3-1066):	
  2    13*     Removed the obsolete parameter source_line from the dcl of error_().
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 /* Modified: 6 Jun 1979 by PG to add rank and byte
  2    17* * Modified: 9 Jul 1989 by RW updated the declaration of error_ 
  2    18* */
  2    19 
  2    20 declare	adjust_count	entry(pointer);
  2    21 			/* parameter 1:	(input)	any node pointer		*/
  2    22 
  2    23 declare	bindec		entry(fixed bin(31)) reducible
  2    24 			returns(character(12) aligned);
  2    25 			/* parameter 1:	(input)	bin value			*/
  2    26 			/* return:	(output)	character value with blanks	*/
  2    27 
  2    28 declare	bindec$vs		entry(fixed bin(31)) reducible
  2    29 			returns(character(12) aligned varying);
  2    30 			/* parameter 1:	(input)	binary value		*/
  2    31 			/* return:	(output)	char value without blanks	*/
  2    32 
  2    33 declare	binoct		entry(fixed bin(31)) reducible
  2    34 			returns(char(12) aligned);
  2    35 			/* parameter 1:	(input)	binary value		*/
  2    36 			/* return:	(output)	char value with blanks	*/
  2    37 
  2    38 declare	binary_to_octal_string	entry(fixed bin(31)) reducible
  2    39 			returns(char(12) aligned);
  2    40 			/* parameter 1:	(input)	binary value		*/
  2    41 			/* return:	(output)	right-aligned char value	*/
  2    42 
  2    43 declare	binary_to_octal_var_string	entry(fixed bin(31)) reducible
  2    44 			returns(char(12) varying aligned);
  2    45 			/* parameter 1:	(input)	binary value		*/
  2    46 			/* returns:	(output)	char value without blanks	*/
  2    47 
  2    48 declare	compare_expression	entry(pointer,pointer) reducible
  2    49 			returns(bit(1) aligned);
  2    50 			/* parameter 1:	(input)	any node pointer		*/
  2    51 			/* parameter 2:	(input)	any node pointer		*/
  2    52 			/* return:	(output)	compare bit		*/
  2    53 
  2    54 declare	constant_length	entry (pointer, fixed bin (71))
  2    55 			returns (bit (1) aligned);
  2    56 			/* parameter 1:	(input)	reference node pointer	*/
  2    57 			/* parameter 2:	(input)	value of constant length	*/
  2    58 			/* return:	(output)	"1"b if constant length	*/
  2    59 
  2    60 declare	convert		entry(pointer,bit(36) aligned)
  2    61 			returns(pointer);
  2    62 			/* parameter 1:	(input)	any node pointer		*/
  2    63 			/* parameter 2:	(input)	target type		*/
  2    64 			/* return:	(output)	target value tree pointer	*/
  2    65 
  2    66 declare	convert$to_integer	entry(pointer,bit(36)aligned)
  2    67 			returns(pointer);
  2    68 			/* parameter 1:	(input)	any node pointer		*/
  2    69 			/* parameter 2:	(input)	target type		*/
  2    70 			/* return:	(output)	target value tree pointer	*/
  2    71 
  2    72 declare	convert$from_builtin entry(pointer,bit(36) aligned)
  2    73 			returns(pointer);
  2    74 			/* parameter 1:	(input)	any node pointer		*/
  2    75 			/* parameter 2:	(input)	target type		*/
  2    76 			/* return:	(output)	target value tree pointer	*/
  2    77 
  2    78 declare	convert$validate	entry(pointer,pointer);
  2    79 			/* parameter 1:	(input)	source value tree pointer	*/
  2    80 			/* parameter 2:	(input)	target reference node pointer	*/
  2    81 
  2    82 declare	convert$to_target_fb entry(pointer,pointer)
  2    83 			returns(pointer);
  2    84 			/* parameter 1:	(input)	source value tree pointer	*/
  2    85 			/* parameter 2:	(input)	target reference node pointer	*/
  2    86 			/* return:	(output)	target value tree pointer	*/
  2    87 
  2    88 declare	convert$to_target	entry(pointer,pointer)
  2    89 			returns(pointer);
  2    90 			/* parameter 1:	(input)	source value tree pointer	*/
  2    91 			/* parameter 2:	(input)	target reference node pointer	*/
  2    92 			/* return:	(output)	target value tree pointer	*/
  2    93 
  2    94 declare	copy_expression	entry(pointer unaligned)
  2    95 			returns(pointer);
  2    96 			/* parameter 1:	(input)	any node pointer		*/
  2    97 			/* return:	(output)	any node pointer		*/
  2    98 
  2    99 declare	copy_expression$copy_sons entry(pointer,pointer);
  2   100 			/* parameter 1:	(input)	father symbol node pointer	*/
  2   101 			/* parameter 2:	(input)	stepfather symbol node ptr	*/
  2   102 
  2   103 declare	copy_unique_expression entry(pointer)
  2   104 			returns(pointer);
  2   105 			/* parameter 1:	(input)	any node pointer		*/
  2   106 			/* return:	(output)	any node pointer		*/
  2   107 
  2   108 declare	create_array	entry()
  2   109 			returns(pointer);
  2   110 			/* return:	(output)	array node pointer		*/
  2   111 
  2   112 declare	create_block	entry(bit(9) aligned,pointer)
  2   113 			returns(pointer);
  2   114 			/* parameter 1:	(input)	block type		*/
  2   115 			/* parameter 2:	(input)	father block node pointer	*/
  2   116 			/* return:	(output)	block node pointer		*/
  2   117 
  2   118 declare	create_bound	entry()
  2   119 			returns(pointer);
  2   120 			/* return:	(output)	bound node pointer		*/
  2   121 
  2   122 declare	create_context	entry(pointer,pointer)
  2   123 			returns(pointer);
  2   124 			/* parameter 1:	(input)	block node pointer		*/
  2   125 			/* parameter 2:	(input)	token pointer		*/
  2   126 			/* return:	(output)	context node pointer	*/
  2   127 
  2   128 declare	create_cross_reference entry()
  2   129 			returns(pointer);
  2   130 			/* return:	(output)	cross reference node pointer	*/
  2   131 
  2   132 declare	create_default	entry
  2   133 			returns(pointer);
  2   134 			/* return:	(output)	default node pointer	*/
  2   135 
  2   136 declare	create_identifier	entry()
  2   137 			returns(pointer);
  2   138 			/* return:	(output)	token node pointer		*/
  2   139 
  2   140 declare	create_label	entry(pointer,pointer,bit(3) aligned)
  2   141 			returns(pointer);
  2   142 			/* parameter 1:	(input)	block node pointer		*/
  2   143 			/* parameter 2:	(input)	token node pointer		*/
  2   144 			/* parameter 3:	(input)	declare type		*/
  2   145 			/* return:	(output)	label node pointer		*/
  2   146 
  2   147 declare	create_list	entry(fixed bin(15))
  2   148 			returns(pointer);
  2   149 			/* parameter 1:	(input)	number of list elements	*/
  2   150 			/* return:	(output)	list node pointer		*/
  2   151 
  2   152 declare	create_operator	entry(bit(9) aligned,fixed bin(15))
  2   153 			returns(pointer);
  2   154 			/* parameter 1:	(input)	operator type		*/
  2   155 			/* parameter 2:	(input)	number of operands		*/
  2   156 			/* return:	(output)	operator node pointer	*/
  2   157 
  2   158 declare	create_reference	entry(pointer)
  2   159 			returns(pointer);
  2   160 			/* parameter 1:	(input)	symbol node pointer		*/
  2   161 			/* return:	(output)	reference node pointer	*/
  2   162 
  2   163 declare	create_statement	entry(bit(9) aligned,pointer,pointer,bit(12) aligned)
  2   164 			returns(pointer);
  2   165 			/* parameter 1:	(input)	statement type		*/
  2   166 			/* parameter 2:	(input)	block node pointer		*/
  2   167 			/* parameter 3:	(input)	label node pointer		*/
  2   168 			/* parameter 4:	(input)	conditions		*/
  2   169 			/* return:	(output)	statement node pointer	*/
  2   170 
  2   171 declare	create_statement$prologue entry(bit(9) aligned,pointer,pointer,bit(12) aligned)
  2   172 			returns(pointer);
  2   173 			/* parameter 1:	(input)	statement type		*/
  2   174 			/* parameter 2:	(input)	block node pointer		*/
  2   175 			/* parameter 3:	(input)	label node pointer		*/
  2   176 			/* parameter 4:	(input)	conditions		*/
  2   177 			/* return:	(output)	statement node pointer	*/
  2   178 
  2   179 declare	create_storage	entry(fixed bin(15))
  2   180 			returns(pointer);
  2   181 			/* parameter 1:	(input)	number of words		*/
  2   182 			/* return:	(output)	storage block pointer	*/
  2   183 
  2   184 declare	create_symbol	entry(pointer,pointer,bit(3) aligned)
  2   185 			returns(pointer);
  2   186 			/* parameter 1:	(input)	block node pointer		*/
  2   187 			/* parameter 2:	(input)	token node pointer		*/
  2   188 			/* parameter 3:	(input)	declare type		*/
  2   189 			/* return:	(output)	symbol node pointer		*/
  2   190 
  2   191 declare	create_token	entry (character (*), bit (9) aligned)
  2   192 			returns (ptr);
  2   193 			/* parameter 1:	(input)	token string		*/
  2   194 			/* parameter 2:	(input)	token type		*/
  2   195 			/* return:	(output)	token node ptr		*/
  2   196 
  2   197 declare	create_token$init_hash_table entry ();
  2   198 
  2   199 declare	create_token$protected entry (char (*), bit (9) aligned, bit (18) aligned)
  2   200 			returns (ptr);
  2   201 			/* parameter 1:	(input)	token string		*/
  2   202 			/* parameter 2:	(input)	token type		*/
  2   203 			/* parameter 3:	(input)	protected flag		*/
  2   204 			/* return:	(output)	token node ptr		*/
  2   205 
  2   206 declare	decbin		entry(character(*) aligned) reducible
  2   207 			returns(fixed bin(31));
  2   208 			/* parameter 1:	(input)	decimal character string	*/
  2   209 			/* return:	(output)	binary value		*/
  2   210 
  2   211 declare	declare_constant	entry(bit(*) aligned,bit(36) aligned,fixed bin(31),fixed bin(15))
  2   212 			returns(pointer);
  2   213 			/* parameter 1:	(input)	value			*/
  2   214 			/* parameter 2:	(input)	type			*/
  2   215 			/* parameter 3:	(input)	size			*/
  2   216 			/* parameter 4:	(input)	scale			*/
  2   217 			/* return:	(output)	reference node pointer	*/
  2   218 
  2   219 declare	declare_constant$bit entry(bit(*) aligned)
  2   220 			returns(pointer);
  2   221 			/* parameter 1:	(input)	bit			*/
  2   222 			/* return:	(output)	reference node pointer	*/
  2   223 
  2   224 declare	declare_constant$char entry(character(*) aligned)
  2   225 			returns(pointer);
  2   226 			/* parameter 1:	(input)	character			*/
  2   227 			/* return:	(output)	reference node pointer	*/
  2   228 
  2   229 declare	declare_constant$desc entry(bit(*) aligned)
  2   230 			returns(pointer);
  2   231 			/* parameter 1:	(input)	descriptor bit value	*/
  2   232 			/* return:	(output)	reference node pointer	*/
  2   233 
  2   234 declare	declare_constant$integer entry(fixed bin(31))	/* note...should really be fixed bin(24) */
  2   235 			returns(pointer);
  2   236 			/* parameter 1:	(input)	integer			*/
  2   237 			/* return:	(output)	reference node pointer	*/
  2   238 
  2   239 declare	declare_descriptor	entry(pointer,pointer,pointer,pointer,bit(2) aligned)
  2   240 			returns(pointer);
  2   241 			/* parameter 1:	(input)	block node pointer		*/
  2   242 			/* parameter 2:	(input)	statement node pointer	*/
  2   243 			/* parameter 3:	(input)	symbol node pointer		*/
  2   244 			/* parameter 4:	(input)	loc pointer		*/
  2   245 			/* parameter 5:	(input)	array descriptor bit
  2   246*						cross_section bit	*/
  2   247 			/* return:	(output)	reference node pointer	*/
  2   248 
  2   249 declare	declare_descriptor$ctl entry(pointer,pointer,pointer,pointer,bit(2) aligned)
  2   250 			returns(pointer);
  2   251 			/* parameter 1:	(input)	block node pointer	*/
  2   252 			/* parameter 2:	(input)	statement node pointer 	*/
  2   253 			/* parameter 3:	(input)	symbol node pointer	*/
  2   254 			/* parameter 4:	(input)	loc pointer	*/
  2   255 			/* parameter 5:	(input)	array descriptor bit
  2   256*						cross_section bit	*/
  2   257 			/* return:	(output)	reference node pointer	*/
  2   258 
  2   259 declare	declare_descriptor$param entry(pointer,pointer,pointer,pointer,bit(2) aligned)
  2   260 			returns(pointer);
  2   261 			/* parameter 1:	(input)	block node pointer		*/
  2   262 			/* parameter 2:	(input)	statement node pointer	*/
  2   263 			/* parameter 3:	(input)	symbol node pointer		*/
  2   264 			/* parameter 4:	(input)	loc pointer		*/
  2   265 			/* parameter 5:	(input)	array descriptor bit
  2   266*						cross_section bit	*/
  2   267 			/* return:	(output)	reference node pointer	*/
  2   268 
  2   269 declare	declare_integer	entry(pointer)
  2   270 			returns(pointer);
  2   271 			/* parameter 1:	(input)	block node pointer		*/
  2   272 			/* return:	(output)	reference node pointer 	*/
  2   273 
  2   274 declare	declare_picture	entry(char(*)aligned,pointer,fixed bin(15));
  2   275 			/* parameter 1:	(input)	picture string		*/
  2   276 			/* parameter 2:	(input)	symbol node pointer		*/
  2   277 			/* parameter 3:	(output)	error code, if any		*/
  2   278 
  2   279 declare	declare_picture_temp entry(char(*) aligned,fixed bin(31),bit(1) aligned,bit(1) aligned)
  2   280 			returns(pointer);
  2   281 			/* parameter 1:	(input)	picture string		*/
  2   282 			/* parameter 2:	(input)	scalefactor of picture	*/
  2   283 			/* parameter 3:	(input)	="1"b => complex picture	*/
  2   284 			/* parameter 4:	(input)	="1"b => unaligned temp	*/
  2   285 			/* return:	(output)	reference node pointer	*/
  2   286 
  2   287 declare	declare_pointer	entry(pointer)
  2   288 			returns(pointer);
  2   289 			/* parameter 1:	(input)	block node pointer		*/
  2   290 			/* return:	(output)	reference node pointer	*/
  2   291 
  2   292 declare	declare_temporary	entry(bit(36) aligned,fixed bin(31),fixed bin(15),pointer)
  2   293 			returns(pointer);
  2   294 			/* parameter 1:	(input)	type			*/
  2   295 			/* parameter 2:	(input)	precision			*/
  2   296 			/* parameter 3:	(input)	scale			*/
  2   297 			/* parameter 4:	(input)	length			*/
  2   298 			/* return:	(output)	reference node pointer	*/
  2   299 
  2   300 declare	decode_node_id	entry(pointer,bit(1) aligned)
  2   301 			returns(char(120) varying);
  2   302 			/* parameter 1:	(input)	node pointer		*/
  2   303 			/* parameter 2:	(input)	="1"b => capitals		*/
  2   304 			/* return:	(output)	source line id		*/
  2   305 
  2   306 declare	decode_source_id	entry(
  3     1 			1 structure unaligned,
  3     2 			  2 /* file_number */	bit(8),
  3     3 			  2 /* line_number */	bit(14),
  3     4 			  2 /* stmt_number */	bit(5),
  2   307 
  2   308 			bit(1) aligned)
  2   309 			returns(char(120) varying);
  2   310 			/* parameter 1:	(input)	source id			*/
  2   311 			/* parameter 2:	(input)	="1"b => capitals		*/
  2   312 			/* return:	(output)	source line id		*/
  2   313 
  2   314 declare	error		entry(fixed bin(15),pointer,pointer);
  2   315 			/* parameter 1:	(input)	error number		*/
  2   316 			/* parameter 2:	(input)	statement node pointer or null*/
  2   317 			/* parameter 3:	(input)	token node pointer 		*/
  2   318 
  2   319 declare	error$omit_text	entry(fixed bin(15),pointer,pointer);
  2   320 			/* parameter 1:	(input)	error number		*/
  2   321 			/* parameter 2:	(input)	statement node pointer or null*/
  2   322 			/* parameter 3:	(input)	token node pointer 		*/
  2   323 
  2   324 declare	error_		entry(fixed bin(15),
  4     1 			1 structure unaligned,
  4     2 			  2 /* file_number */	bit(8),
  4     3 			  2 /* line_number */	bit(14),
  4     4 			  2 /* stmt_number */	bit(5),
  2   325 
  2   326 			pointer,fixed bin(8),fixed bin(23),fixed bin(11));
  2   327 			/* parameter 1:	(input)	error number		*/
  2   328 			/* parameter 2:	(input)	statement id		*/
  2   329 			/* parameter 3:	(input)	any node pointer		*/
  2   330 			/* parameter 4:	(input)	source segment		*/
  2   331 			/* parameter 5:	(input)	source starting character	*/
  2   332 			/* parameter 6:	(input)	source length		*/
  2   333 
  2   334 declare	error_$no_text	entry(fixed bin(15),
  5     1 			1 structure unaligned,
  5     2 			  2 /* file_number */	bit(8),
  5     3 			  2 /* line_number */	bit(14),
  5     4 			  2 /* stmt_number */	bit(5),
  2   335 
  2   336 			pointer);
  2   337 			/* parameter 1:	(input)	error number		*/
  2   338 			/* parameter 2:	(input)	statement id		*/
  2   339 			/* parameter 3:	(input)	any node pointer		*/
  2   340 
  2   341 declare	error_$initialize_error entry();
  2   342 
  2   343 declare	error_$finish	entry();
  2   344 
  2   345 declare	free_node		entry(pointer);
  2   346 			/* parameter 1:	any node pointer			*/
  2   347 
  2   348 declare	get_array_size	entry(pointer,fixed bin(3));
  2   349 			/* parameter 1:	(input)	symbol node pointer		*/
  2   350 			/* parameter 2:	(input)	units			*/
  2   351 
  2   352 declare	get_size		entry(pointer);
  2   353 			/* parameter 1:	(input)	symbol node pointer		*/
  2   354 
  2   355 declare	merge_attributes	external entry(pointer,pointer)
  2   356 			returns(bit(1) aligned);
  2   357 			/* parameter 1:	(input)	target symbol node pointer */
  2   358 			/* parameter 2:	(input)	source symbol node pointer */
  2   359 			/* return:	(output)	"1"b if merge was unsuccessful */
  2   360 
  2   361 declare	optimizer		entry(pointer);
  2   362 			/* parameter 1:	(input)	root pointer		*/
  2   363 
  2   364 declare	parse_error	entry(fixed bin(15),pointer);
  2   365 			/* parameter 1:	(input)	error number		*/
  2   366 			/* parameter 2:	(input)	any node pointer		*/
  2   367 
  2   368 declare	parse_error$no_text	entry(fixed bin(15),pointer);
  2   369 			/* parameter 1:	(input)	error number		*/
  2   370 			/* parameter 2:	(input)	any node pointer		*/
  2   371 
  2   372 declare	pl1_error_print$write_out
  2   373 			entry(fixed bin(15),
  6     1 			1 structure unaligned,
  6     2 			  2 /* file_number */	bit(8),
  6     3 			  2 /* line_number */	bit(14),
  6     4 			  2 /* stmt_number */	bit(5),
  2   374 
  2   375 			pointer,fixed bin(11),fixed bin(31),fixed bin(31),fixed bin(15));
  2   376 			/* parameter 1:	(input)	error number		*/
  2   377 			/* parameter 2:	(input)	statement identification	*/
  2   378 			/* parameter 3:	(input)	any node pointer		*/
  2   379 			/* parameter 4:	(input)	source segment		*/
  2   380 			/* parameter 5:	(input)	source character index	*/
  2   381 			/* parameter 6:	(input)	source length		*/
  2   382 			/* parameter 7:	(input)	source line		*/
  2   383 
  2   384 declare	pl1_error_print$listing_segment
  2   385 			entry(fixed bin(15),
  7     1 			1 structure unaligned,
  7     2 			  2 /* file_number */	bit(8),
  7     3 			  2 /* line_number */	bit(14),
  7     4 			  2 /* stmt_number */	bit(5),
  2   386 
  2   387 			pointer);
  2   388 			/* parameter 1:	(input)	error number		*/
  2   389 			/* parameter 2:	(input)	statement identification	*/
  2   390 			/* parameter 3:	(input)	token node pointer		*/
  2   391 
  2   392 declare	pl1_print$varying		entry(character(*) aligned varying);
  2   393 			/* parameter 1:	(input)	string			*/
  2   394 
  2   395 declare	pl1_print$varying_nl	entry(character(*) aligned varying);
  2   396 			/* parameter 1:	(input)	string			*/
  2   397 
  2   398 declare	pl1_print$non_varying	entry(character(*) aligned,fixed bin(31));
  2   399 			/* parameter 1:	(input)	string			*/
  2   400 			/* parameter 2:	(input)	string length or 0		*/
  2   401 
  2   402 declare	pl1_print$non_varying_nl	entry(character(*) aligned,fixed bin(31));
  2   403 			/* parameter 1:	(input)	string			*/
  2   404 			/* parameter 2:	(input)	string length or 0		*/
  2   405 
  2   406 declare	pl1_print$string_pointer	entry(pointer,fixed bin(31));
  2   407 			/* parameter 1:	(input)	string pointer		*/
  2   408 			/* parameter 2:	(input)	string size		*/
  2   409 
  2   410 declare	pl1_print$string_pointer_nl	entry(pointer,fixed bin(31));
  2   411 			/* parameter 1:	(input)	string pointer		*/
  2   412 			/* parameter 2:	(input)	string length or 0		*/
  2   413 
  2   414 declare	pl1_print$unaligned_nl	entry(character(*) unaligned,fixed bin(31));
  2   415 			/* parameter 1:	(input)	string			*/
  2   416 			/* parameter 2:	(input)	length			*/
  2   417 
  2   418 declare	pl1_print$for_lex	entry (ptr, fixed bin (14), fixed bin (21), fixed bin (21), bit (1) aligned, bit (1) aligned);
  2   419 			/* parameter 1:	(input)	ptr to base of source segment	*/
  2   420 			/* parameter 2:	(input)	line number		*/
  2   421 			/* parameter 3:	(input)	starting offset in source seg	*/
  2   422 			/* parameter 4:	(input)	number of chars to copy	*/
  2   423 			/* parameter 5:	(input)	ON iff shd print line number	*/
  2   424 			/* parameter 6:	(input)	ON iff line begins in comment	*/
  2   425 
  2   426 declare	refer_extent	entry(pointer,pointer);
  2   427 			/* parameter 1:	(input/output)	null,ref node,op node pointer	*/
  2   428 			/* parameter 2:	(input)	null,ref node,op node pointer	*/
  2   429 
  2   430 declare	reserve$clear	entry()
  2   431 			returns(pointer);
  2   432 			/* return:	(output)	pointer			*/
  2   433 
  2   434 declare	reserve$declare_lib	entry(fixed bin(15))
  2   435 			returns(pointer);
  2   436 			/* parameter 1:	(input)	builtin function number	*/
  2   437 			/* return:	(output)	pointer			*/
  2   438 
  2   439 declare	reserve$read_lib	entry(fixed bin(15))
  2   440 			returns(pointer);
  2   441 			/* parameter 1:	(input)	builtin function number	*/
  2   442 			/* return:	(output)	pointer			*/
  2   443 
  2   444 declare	semantic_translator	entry();
  2   445 
  2   446 declare	semantic_translator$abort entry(fixed bin(15),pointer);
  2   447 			/* parameter 1:	(input)	error number		*/
  2   448 			/* parameter 2:	(input)	any node pointer		*/
  2   449 
  2   450 declare	semantic_translator$error entry(fixed bin(15),pointer);
  2   451 			/* parameter 1:	(input)	error number		*/
  2   452 			/* parameter 2:	(input)	any node pointer		*/
  2   453 
  2   454 declare	share_expression	entry(ptr)
  2   455 			returns(ptr);
  2   456 			/* parameter 1:	(input)	usually operator node pointer	*/
  2   457 			/* return:	(output)	tree pointer or null	*/
  2   458 
  2   459 declare	token_to_binary	entry(ptr) reducible
  2   460 			returns(fixed bin(31));
  2   461 			/* parameter 1:	(input)	token node pointer		*/
  2   462 			/* return:	(output)	converted binary value	*/
  2   463 
  2   464 /* END INCLUDE FILE ... language_utility.incl.pl1 */
      163 
  8     1 dcl	pl1_stat_$token_list_ptr ptr external static;		/* pointer to token list	*/
  8     2 dcl	token_list(token_list_length) ptr based(token_list_pointer);
  8     3 dcl	token_list_pointer ptr initial(pl1_stat_$token_list_ptr);	/* for efficiency only */
  8     4 dcl	token_list_length fixed(15) internal static initial(3000) options(constant);
  8     5 
  8     6 dcl	1 pl1_stat_$statement_id	external static,
  8     7 	2 file_number		bit(8),
  8     8 	2 line_number		bit(14),
  8     9 	2 statement_number		bit(5);
  8    10 
  8    11 dcl	1 t_table 		based(token_list(k)) aligned,
  8    12 	2 node_type		bit(9) unaligned,
  8    13 	2 type			bit(9) unaligned,
  8    14 	2 loc			bit(18) unaligned,
  8    15 	2 declaration		ptr unaligned,
  8    16 	2 next			ptr unaligned,
  8    17 	2 size			fixed(9),
  8    18 	2 string			char(n refer(t_table.size));
      164 
  9     1 /* BEGIN INCLUDE FILE ... list.incl.pl1 */
  9     2 
  9     3 /* Modified 26 June 81 by EBush to add max_list_elements */
  9     4 
  9     5 
  9     6 dcl	1 list		based aligned,
  9     7 	2 node_type	bit(9) unaligned,
  9     8 	2 reserved	bit(12) unaligned,
  9     9 	2 number		fixed(14) unaligned,
  9    10 	2 element		dimension(n refer(list.number)) ptr unaligned;
  9    11 
  9    12 dcl       max_list_elements   fixed bin(17) internal static options (constant)
  9    13 	                    init(16383);
  9    14 
  9    15 /* END INCLUDE FILE ... list.incl.pl1 */
      165 
 10     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
 10     2 
 10     3 dcl	1 reference		based aligned,
 10     4 	2 node_type		bit(9) unaligned,
 10     5 	2 array_ref		bit(1) unaligned,
 10     6 	2 varying_ref		bit(1) unaligned,
 10     7 	2 shared			bit(1) unaligned,
 10     8 	2 put_data_sw		bit(1) unaligned,
 10     9 	2 processed		bit(1) unaligned,
 10    10 	2 units			fixed(3) unaligned,
 10    11 	2 ref_count		fixed(17) unaligned,
 10    12 	2 c_offset		fixed(24),
 10    13 	2 c_length		fixed(24),
 10    14 	2 symbol			ptr unaligned,
 10    15 	2 qualifier		ptr unaligned,
 10    16 	2 offset			ptr unaligned,
 10    17 	2 length			ptr unaligned,
 10    18 	2 subscript_list		ptr unaligned,
 10    19 						/* these fields are used by the 645 code generator */
 10    20 	2 address			structure unaligned,
 10    21 	  3 base			bit(3),
 10    22 	  3 offset		bit(15),
 10    23 	  3 op			bit(9),
 10    24 	  3 no_address		bit(1),
 10    25 	  3 inhibit		bit(1),
 10    26 	  3 ext_base		bit(1),
 10    27 	  3 tag			bit(6),
 10    28 	2 info			structure unaligned,
 10    29 	  3 address_in		structure,
 10    30 	    4 b			dimension(0:7) bit(1),
 10    31 	    4 storage		bit(1),
 10    32 	  3 value_in		structure,
 10    33 	    4 a			bit(1),
 10    34 	    4 q			bit(1),
 10    35 	    4 aq			bit(1),
 10    36 	    4 string_aq		bit(1),
 10    37 	    4 complex_aq		bit(1),
 10    38 	    4 decimal_aq		bit(1),
 10    39 	    4 b			dimension(0:7) bit(1),
 10    40 	    4 storage		bit(1),
 10    41 	    4 indicators		bit(1),
 10    42 	    4 x			dimension(0:7) bit(1),
 10    43 	  3 other			structure,
 10    44 	    4 big_offset		bit(1),
 10    45 	    4 big_length		bit(1),
 10    46 	    4 modword_in_offset	bit(1),
 10    47 	2 data_type		fixed(5) unaligned,
 10    48 	2 bits			structure unaligned,
 10    49 	  3 padded_ref		bit(1),
 10    50 	  3 aligned_ref		bit(1),
 10    51 	  3 long_ref		bit(1),
 10    52 	  3 forward_ref		bit(1),
 10    53 	  3 ic_ref		bit(1),
 10    54 	  3 temp_ref		bit(1),
 10    55 	  3 defined_ref		bit(1),
 10    56 	  3 evaluated		bit(1),
 10    57 	  3 allocate		bit(1),
 10    58 	  3 allocated		bit(1),
 10    59 	  3 aliasable		bit(1),
 10    60 	  3 even			bit(1),
 10    61 	  3 perm_address		bit(1),
 10    62 	  3 aggregate		bit(1),
 10    63 	  3 hit_zero		bit(1),
 10    64 	  3 dont_save		bit(1),
 10    65 	  3 fo_in_qual		bit(1),
 10    66 	  3 hard_to_load		bit(1),
 10    67 	2 relocation		bit(12) unaligned,
 10    68 	2 more_bits		structure unaligned,
 10    69 	  3 substr		bit(1),
 10    70 	  3 padded_for_store_ref	bit(1),
 10    71 	  3 aligned_for_store_ref	bit(1),
 10    72 	  3 mbz			bit(15),
 10    73 	2 store_ins		bit(18) unaligned;
 10    74 
 10    75 /* END INCLUDE FILE ... reference.incl.pl1 */
      166 
 11     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
 11     2 
 11     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
 11     4 
 11     5 dcl (	block_node		initial("000000001"b),
 11     6 	statement_node		initial("000000010"b),
 11     7 	operator_node		initial("000000011"b),
 11     8 	reference_node		initial("000000100"b),
 11     9 	token_node		initial("000000101"b),
 11    10 	symbol_node		initial("000000110"b),
 11    11 	context_node		initial("000000111"b),
 11    12 	array_node		initial("000001000"b),
 11    13 	bound_node		initial("000001001"b),
 11    14 	format_value_node		initial("000001010"b),
 11    15 	list_node			initial("000001011"b),
 11    16 	default_node		initial("000001100"b),
 11    17 	machine_state_node		initial("000001101"b),
 11    18 	source_node		initial("000001110"b),
 11    19 	label_node		initial("000001111"b),
 11    20 	cross_reference_node	initial("000010000"b),
 11    21 	sf_par_node		initial("000010001"b),
 11    22 	temporary_node		initial("000010010"b),
 11    23 	label_array_element_node	initial("000010011"b),
 11    24 	by_name_agg_node		initial("000010100"b))
 11    25 				bit(9) internal static aligned options(constant);
 11    26 
 11    27 dcl	1 node			based aligned,
 11    28 	2 type			unal bit(9),
 11    29 	2 source_id		unal structure,
 11    30 	  3 file_number		bit(8),
 11    31 	  3 line_number		bit(14),
 11    32 	  3 statement_number	bit(5);
 11    33 
 11    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
      167 
 12     1 /* BEGIN INCLUDE FILE ... token_types.incl.pl1 */
 12     2 
 12     3 dcl (	no_token		initial("000000000"b),	/*	token types		*/
 12     4 	identifier	initial("100000000"b),
 12     5 	isub		initial("010000000"b),
 12     6 	plus		initial("001000001"b),
 12     7 	minus		initial("001000010"b),
 12     8 	asterisk		initial("001000011"b),
 12     9 	slash		initial("001000100"b),
 12    10 	expon		initial("001000101"b),
 12    11 	not		initial("001000110"b),
 12    12 	and		initial("001000111"b),
 12    13 	or		initial("001001000"b),
 12    14 	cat		initial("001001001"b),
 12    15 	eq		initial("001001010"b),
 12    16 	ne		initial("001001011"b),
 12    17 	lt		initial("001001100"b),
 12    18 	gt		initial("001001101"b),
 12    19 	le		initial("001001110"b),
 12    20 	ge		initial("001001111"b),
 12    21 	ngt		initial("001010000"b),
 12    22 	nlt		initial("001010001"b),
 12    23 	assignment	initial("001010010"b),
 12    24 	colon		initial("001010011"b),
 12    25 	semi_colon	initial("001010100"b),
 12    26 	comma		initial("001010101"b),
 12    27 	period		initial("001010110"b),
 12    28 	arrow		initial("001010111"b),
 12    29 	left_parn		initial("001011000"b),
 12    30 	right_parn	initial("001011001"b),
 12    31 	percent		initial("001011100"b),
 12    32 	bit_string	initial("000100001"b),
 12    33 	char_string	initial("000100010"b),
 12    34 	bin_integer	initial("000110001"b),
 12    35 	dec_integer	initial("000110011"b),
 12    36 	fixed_bin		initial("000110000"b),
 12    37 	fixed_dec		initial("000110010"b),
 12    38 	float_bin		initial("000110100"b),
 12    39 	float_dec		initial("000110110"b),
 12    40 	i_bin_integer	initial("000111001"b),
 12    41 	i_dec_integer	initial("000111011"b),
 12    42 	i_fixed_bin	initial("000111000"b),
 12    43 	i_fixed_dec	initial("000111010"b),
 12    44 	i_float_bin	initial("000111100"b),
 12    45 	i_float_dec	initial("000111110"b)) bit (9) aligned internal static options (constant);
 12    46 
 12    47 dcl (	is_identifier		initial ("100000000"b),	/*	token type masks		*/
 12    48 	is_isub			initial ("010000000"b),
 12    49 	is_delimiter		initial ("001000000"b),
 12    50 	is_constant		initial ("000100000"b),
 12    51 	is_arith_constant		initial ("000010000"b),	/* N.B. not really a mask...s/b "000110000"b */
 12    52 	is_arithmetic_constant	initial ("000110000"b),
 12    53 	is_imaginary_constant	initial ("000111000"b),
 12    54 	is_float_constant		initial ("000110100"b),
 12    55 	is_decimal_constant		initial ("000110010"b),
 12    56 	is_integral_constant 	initial ("000110001"b)
 12    57 	) bit(9) internal static aligned options(constant);
 12    58 
 12    59 /* END INCLUDE FILE ... token_types.incl.pl1 */
      168 
 13     1 	/* statement types */
 13     2 
 13     3 dcl (	unknown_statement		initial("000000000"b),
 13     4 	allocate_statement		initial("000000001"b),
 13     5 	assignment_statement	initial("000000010"b),
 13     6 	begin_statement		initial("000000011"b),
 13     7 	call_statement		initial("000000100"b),
 13     8 	close_statement		initial("000000101"b),
 13     9 	declare_statement		initial("000000110"b),
 13    10 	lock_statement		initial("000000111"b),
 13    11 	delete_statement		initial("000001000"b),
 13    12 	display_statement		initial("000001001"b),
 13    13 	do_statement		initial("000001010"b),
 13    14 	else_clause		initial("000001011"b),
 13    15 	end_statement		initial("000001100"b),
 13    16 	entry_statement		initial("000001101"b),
 13    17 	exit_statement		initial("000001110"b),
 13    18 	format_statement		initial("000001111"b),
 13    19 	free_statement		initial("000010000"b),
 13    20 	get_statement		initial("000010001"b),
 13    21 	goto_statement		initial("000010010"b),
 13    22 	if_statement		initial("000010011"b),
 13    23 	locate_statement		initial("000010100"b),
 13    24 	null_statement		initial("000010101"b),
 13    25 	on_statement		initial("000010110"b),
 13    26 	open_statement		initial("000010111"b),
 13    27 	procedure_statement 	initial("000011000"b),
 13    28 	put_statement		initial("000011001"b),
 13    29 	read_statement		initial("000011010"b),
 13    30 	return_statement		initial("000011011"b),
 13    31 	revert_statement		initial("000011100"b),
 13    32 	rewrite_statement		initial("000011101"b),
 13    33 	signal_statement		initial("000011110"b),
 13    34 	stop_statement		initial("000011111"b),
 13    35 	system_on_unit		initial("000100000"b),
 13    36 	unlock_statement		initial("000100001"b),
 13    37 	wait_statement		initial("000100010"b),
 13    38 	write_statement		initial("000100011"b),
 13    39 	default_statement		initial("000100100"b),
 13    40 	continue_statement		initial("000100101"b)) bit(9) internal static aligned options(constant);
      169 
      170 
      171 dcl constant_token entry (ptr, ptr, bit(9) aligned, bit(9) aligned) returns(bit(9));
      172 
      173 
      174 /* program */
      175 
      176 	label_ptr = null;
      177 	k, ksaved = index;
      178 
      179 /*	The first construction to check for is the condition prefix list,	*/
      180 
      181 	if ^pl1_stat_$level_0_colon			/* if statement has no colon, it can't have */
      182 	then do;					/* prefixes or labels */
      183 
      184 	     /* we still have to see that the stmt begins with an identifier or semi_colon */
      185 
      186 	     if t_table.type ^= identifier
      187 	     then if t_table.type = semi_colon
      188 		then do;
      189 		     index = k;
      190 		     return(fixed(null_statement,15));
      191 		     end;
      192 		else call print(96,token_list(k));
      193 
      194 	     go to not_label;
      195 	     end;
      196 
      197 	do while (t_table.type = left_parn);
      198 
      199 another:
      200 	     k = k + 1;
      201 	     if t_table.type ^= identifier then call print(95,token_list(k));
      202 	     if substr(t_table.string,1,2)="no"
      203 	     then do;
      204 		     condition_value="0"b;
      205 		     unknown_condition=substr(t_table.string,3);
      206 		end;
      207 	     else do;
      208 		     condition_value="1"b;
      209 		     unknown_condition=t_table.string;
      210 		end;
      211 
      212 	     do j = lbound (condition_name, 1) to hbound (condition_name, 1) while (condition_name (j) ^= unknown_condition);
      213 	     end;
      214 
      215 	     if j > hbound (condition_name, 1)
      216 	     then call print (45, token_list (k));
      217 
      218 	     substr (conditions, mod (j, 10), 1) = condition_value;	/* j never equals 10 due to clever array */
      219 	     k = k + 1;
      220 	     if t_table.type = comma then go to another;
      221 	     if t_table.type ^= right_parn then call print(43,token_list(k-1));
      222 	     k = k + 1;
      223 	     if t_table.type ^= colon then call print(44,null);
      224 	     k = k + 1;
      225 	end;
      226 
      227 /* 	The next construct to check for is the label prefix list.	*/
      228 
      229 check_label:
      230 	ksaved = k;
      231 	if t_table.type ^= identifier
      232 		then if t_table.type = semi_colon
      233 			then do;
      234 				index=k;
      235 				return(fixed(null_statement,15));
      236 			end;
      237 			else call print(96,token_list(k));
      238 	q = token_list(k);
      239 	k = k+1;
      240 	if t_table.type = colon then go to label;
      241 	if t_table.type ^= left_parn then go to not_label;
      242 	k = k+1;
      243 	n = 1;
      244 	if t_table.type = plus
      245 		then k = k+1;
      246 		else if t_table.type = minus
      247 			then do;
      248 				n = -1;
      249 				k = k+1;
      250 			     end;
      251 
      252 	/* get ptr to value token */
      253 	value_token = token_list (k);		/* constant_token fixes this if named constant */
      254 	if constant_token (cblock, value_token, "777"b3, dec_integer) ^= dec_integer then go to not_label;
      255 
      256 	p = token_list(k);
      257 	k = k+1;
      258 	if t_table.type ^= right_parn then go to not_label;
      259 	k = k+1;
      260 	if t_table.type ^= colon then go to not_label;
      261 
      262 	token_list (k-2) = value_token;	/* substitute constant value */
      263 	p = value_token;
      264 	q = create_reference(q);
      265 	q->reference.offset = create_list(1);
      266 	if n = -1 then q->reference.offset->list.element(1) = create_token("-"||p->t_table.string,dec_integer);
      267 		else q->reference.offset->list.element(1) = p;
      268 label:
      269 	k = k+1;
      270 	p = create_list(2);
      271 	p->list.element(2) = q;
      272 	p->list.element(1) = label_ptr;
      273 	label_ptr = p;
      274 	go to check_label;
      275 
      276 /*	ksaved points to the first token following the last recognized label.
      277*	It is known to point to an identifier.	*/
      278 
      279 not_label:
      280 	k,index = ksaved;
      281 	next_type=token_list(k+1)->t_table.type;
      282 	if next_type=assignment then go to return_assignment;
      283 	if next_type=arrow then go to return_assignment;
      284 	if next_type=period then go to return_assignment;
      285 	if next_type=comma then go to return_assignment;
      286 
      287 /*	probably a key-word type statement */
      288 
      289 	unknown_key_word=t_table.string;
      290 	do j = 0 to hbound(key_word,1);
      291 	if unknown_key_word=key_word(j)
      292 	then do;
      293 		assumed_s_type=s_type(j);
      294 		if next_type^=left_parn then go to type_return;
      295 		if parn_not_allowed(j) then go to return_assignment;
      296 		go to verify_s_type;
      297 	     end;
      298 	end;
      299 
      300 	go to return_assignment;
      301 
      302 /*	when control reaches here we know that the identifier beginning */
      303 /*	the statement is a key-word and that the token */
      304 /*	following the identifier is a left-paren.  the following code */
      305 /*	decides whether the statement is the assumed statement type */
      306 /*	or the statement is an assignment statement. */
      307 
      308 verify_s_type:
      309 	k = k + 1;
      310 	call skip_parens;
      311 
      312 /*	at this point we have scanned to the right paren in this context:  */
      313 
      314 /*		key-word(...)					*/
      315 
      316 /*	the token following the right paren will distinguish a key word */
      317 /*	statement from an assignment statement. 		*/
      318 
      319 	k = k+1;
      320 	if t_table.type=arrow then go to return_assignment;
      321 	if t_table.type=period then go to return_assignment;
      322 	if t_table.type = comma
      323 	then if assumed_s_type = declare_statement
      324 	     then if has_equal()
      325 		then go to return_assignment;
      326 		else go to type_return;
      327 	     else go to return_assignment;
      328 	if t_table.type=assignment
      329 		then if assumed_s_type=if_statement
      330 			then go to if_check;
      331 			else go to return_assignment;
      332 		else go to type_return;			/* it was key-word type after all */
      333 
      334 /*	at this point we have scanned to the equal sign in this context:   */
      335 
      336 /*		if( ... )=	*/
      337 
      338 /*	the following code resolves the ambiguity of whether this is an */
      339 /*	if statement or a subscripted assignment statement.    */
      340 
      341 if_check:
      342 	k = k+1;
      343 	if t_table.type=semi_colon then go to return_assignment;
      344 	if t_table.type=left_parn
      345 	then do;
      346 		paren_count=paren_count+1;
      347 		go to if_check;
      348 	     end;
      349 	if t_table.type=right_parn
      350 	then do;
      351 		paren_count=paren_count-1;
      352 		go to if_check;
      353 	     end;
      354 	if t_table.type=identifier
      355 	then do;
      356 		if paren_count ^= 0 then go to if_check;
      357 		if t_table.string="then" then go to then_check;
      358 	     end;
      359 
      360 	go to if_check;
      361 
      362 /*	having found a "then" at zero-reduction level we check the type */
      363 /*	of the preceding token to distinguish the use of "then" as a */
      364 /*	key-word to initiate a then-clause from the use of "then" as */
      365 /*	an ordinary identifier. */
      366 
      367 then_check:
      368 	next_type = token_list(k-1)->t_table.type;
      369 	if next_type=identifier then go to type_return;
      370 	if next_type=right_parn then go to type_return;
      371 	if next_type & is_constant then go to type_return;
      372 	go to if_check;
      373 
      374 return_assignment:
      375 	assumed_s_type = assignment_statement;
      376 type_return:
      377 	return(fixed(assumed_s_type,15,0));
      378 
      379 
      380 skip_parens:	proc;
      381 
      382 	paren_count = 1;
      383 	do while(paren_count ^= 0);
      384 	k = k + 1;
      385 	if t_table.type = semi_colon then call print(2,null);
      386 	if t_table.type = left_parn then paren_count = paren_count + 1;
      387 	if t_table.type = right_parn then paren_count = paren_count - 1;
      388 	end;
      389 
      390 	end;
      391 
      392 
      393 has_equal:	proc returns(bit(1) aligned);
      394 
      395 	do while("1"b);
      396 	k = k + 1;
      397 	if t_table.type = semi_colon then return("0"b);
      398 	if t_table.type = assignment then return("1"b);
      399 	if t_table.type = left_parn then call skip_parens;
      400 	end;
      401 
      402 	end;
      403 
      404 /* subroutine to print a diagnostic and return to the caller of statement_type
      405*   telling him that the statement is unknown.	*/
      406 
      407 print: proc(m,t);
      408 
      409 dcl	m fixed bin(15);
      410 dcl	t ptr;
      411 
      412 	call parse_error(m,t);
      413 	assumed_s_type = unknown_statement;
      414 	go to type_return;
      415 	end print;
      416 
      417 	end statement_type;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/00  1713.6  statement_type.pl1                >udd>sm>ds>w>ml>statement_type.pl1
162          1    08/13/81  2143.5  condition_name.incl.pl1           >ldd>incl>condition_name.incl.pl1
163          2    08/01/89  1339.9  language_utility.incl.pl1         >ldd>incl>language_utility.incl.pl1
2-307        3    05/06/74  1846.9  source_id_descriptor.incl.pl1     >ldd>incl>source_id_descriptor.incl.pl1
2-325        4    05/06/74  1846.9  source_id_descriptor.incl.pl1     >ldd>incl>source_id_descriptor.incl.pl1
2-335        5    05/06/74  1846.9  source_id_descriptor.incl.pl1     >ldd>incl>source_id_descriptor.incl.pl1
2-374        6    05/06/74  1846.9  source_id_descriptor.incl.pl1     >ldd>incl>source_id_descriptor.incl.pl1
2-386        7    05/06/74  1846.9  source_id_descriptor.incl.pl1     >ldd>incl>source_id_descriptor.incl.pl1
164          8    09/14/77  1805.7  token_list.incl.pl1               >ldd>incl>token_list.incl.pl1
165          9    08/13/81  2311.5  list.incl.pl1                     >ldd>incl>list.incl.pl1
166         10    07/21/80  1646.3  reference.incl.pl1                >ldd>incl>reference.incl.pl1
167         11    07/21/80  1646.3  nodes.incl.pl1                    >ldd>incl>nodes.incl.pl1
168         12    11/30/78  1327.4  token_types.incl.pl1              >ldd>incl>token_types.incl.pl1
169         13    05/03/76  1420.4  statement_types.incl.pl1          >ldd>incl>statement_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
arrow                                  constant        bit(9)                   initial dcl 12-3 ref 283 320
assignment                             constant        bit(9)                   initial dcl 12-3 ref 282 328 398
assignment_statement                   constant        bit(9)                   initial dcl 13-3 ref 374
assumed_s_type                  000114 automatic       bit(9)                   dcl 66 set ref 293* 322 328 374* 376 413*
cblock                                 parameter       pointer                  dcl 65 set ref 36 254*
colon                                  constant        bit(9)                   initial dcl 12-3 ref 223 240 260
comma                                  constant        bit(9)                   initial dcl 12-3 ref 220 285 322
condition_name                  000001 constant        char(16)                 initial array packed unaligned dcl 1-7 ref 212 212
                                                                                  212 215
condition_value                 000121 automatic       bit(1)                   dcl 68 set ref 204* 208* 218
conditions                             parameter       bit(12)                  dcl 69 set ref 36 218*
constant_token                  000024 constant        entry                    external dcl 171 ref 254
create_list                     000012 constant        entry                    external dcl 2-147 ref 265 270
create_reference                000014 constant        entry                    external dcl 2-158 ref 264
create_token                    000016 constant        entry                    external dcl 2-191 ref 266
dec_integer                     000000 constant        bit(9)                   initial dcl 12-3 set ref 254* 254 266*
declare_statement                      constant        bit(9)                   initial dcl 13-3 ref 322
element                   1            based           pointer                  array level 2 packed packed unaligned dcl 9-6 set
                                                                                  ref 266* 267* 271* 272*
fixed                                                  builtin function         dcl 74 ref 190 235 376
hbound                                                 builtin function         dcl 74 ref 212 215 290
identifier                             constant        bit(9)                   initial dcl 12-3 ref 186 201 231 354 369
if_statement                           constant        bit(9)                   initial dcl 13-3 ref 328
index                                  parameter       fixed bin(15,0)          dcl 64 set ref 36 177 189* 234* 279*
is_constant                            constant        bit(9)                   initial dcl 12-47 ref 371
j                               000100 automatic       fixed bin(15,0)          dcl 64 set ref 212* 212* 215 218 290* 291 293 295*
k                               000101 automatic       fixed bin(15,0)          dcl 64 set ref 177* 186 186 189 192 197 199* 199 201
                                                                                  201 202 205 209 215 219* 219 220 221 221 222* 222
                                                                                  223 224* 224 229 231 231 234 237 238 239* 239 240
                                                                                  241 242* 242 244 244* 244 246 249* 249 253 256
                                                                                  257* 257 258 259* 259 260 262 268* 268 279* 281
                                                                                  289 308* 308 319* 319 320 321 322 328 341* 341 343
                                                                                  344 349 354 357 367 384* 384 385 386 387 396* 396
                                                                                  397 398 399
key_word                        000170 constant        char(12)                 initial array dcl 82 ref 290 291
ksaved                          000102 automatic       fixed bin(15,0)          dcl 64 set ref 177* 229* 279
label_ptr                              parameter       pointer                  dcl 65 set ref 36 176* 272 273*
lbound                                                 builtin function         dcl 74 ref 212
left_parn                              constant        bit(9)                   initial dcl 12-3 ref 197 241 294 344 386 399
list                                   based           structure                level 1 dcl 9-6
m                                      parameter       fixed bin(15,0)          dcl 409 set ref 407 412*
minus                                  constant        bit(9)                   initial dcl 12-3 ref 246
mod                                                    builtin function         dcl 74 ref 218
n                               000104 automatic       fixed bin(15,0)          dcl 64 set ref 243* 248* 266
next_type                       000115 automatic       bit(9)                   dcl 66 set ref 281* 282 283 284 285 294 367* 369 370
                                                                                  371
null                                                   builtin function         dcl 74 ref 176 223 223 385 385
null_statement                         constant        bit(9)                   initial dcl 13-3 ref 190 235
offset                    5            based           pointer                  level 2 packed packed unaligned dcl 10-3 set ref
                                                                                  265* 266 267
p                               000106 automatic       pointer                  dcl 65 set ref 256* 263* 266 267 270* 271 272 273
paren_count                     000103 automatic       fixed bin(15,0)          dcl 64 set ref 346* 346 351* 351 356 382* 383 386*
                                                                                  386 387* 387
parn_not_allowed                000115 constant        bit(1)                   initial array dcl 154 ref 295
parse_error                     000020 constant        entry                    external dcl 2-364 ref 412
period                                 constant        bit(9)                   initial dcl 12-3 ref 284 321
pl1_stat_$level_0_colon         000010 external static bit(1)                   dcl 78 ref 181
pl1_stat_$token_list_ptr        000022 external static pointer                  dcl 8-1 ref 8-3
plus                                   constant        bit(9)                   initial dcl 12-3 ref 244
q                               000110 automatic       pointer                  dcl 65 set ref 238* 264* 264* 265 266 267 271
reference                              based           structure                level 1 dcl 10-3
right_parn                             constant        bit(9)                   initial dcl 12-3 ref 221 258 349 370 387
s_type                          000157 constant        bit(9)                   initial array packed unaligned dcl 118 ref 293
semi_colon                             constant        bit(9)                   initial dcl 12-3 ref 186 231 343 385 397
size                      3            based           fixed bin(9,0)           level 2 dcl 8-11 ref 202 205 209 266 289 357
string                    4            based           char                     level 2 dcl 8-11 ref 202 205 209 266 289 357
substr                                                 builtin function         dcl 74 set ref 202 205 218*
t                                      parameter       pointer                  dcl 410 set ref 407 412*
t_table                                based           structure                level 1 dcl 8-11
token_list                             based           pointer                  array dcl 8-2 set ref 186 186 192* 197 201 201* 202
                                                                                  205 209 215* 220 221 221* 223 231 231 237* 238 240
                                                                                  241 244 246 253 256 258 260 262* 281 289 320 321
                                                                                  322 328 343 344 349 354 357 367 385 386 387 397
                                                                                  398 399
token_list_pointer              000126 automatic       pointer                  initial dcl 8-3 set ref 186 186 192 197 201 201 202
                                                                                  205 209 215 220 221 221 223 231 231 237 238 240
                                                                                  241 244 246 253 256 258 260 262 281 289 320 321
                                                                                  322 328 343 344 349 354 357 367 8-3* 385 386 387
                                                                                  397 398 399
type                      0(09)        based           bit(9)                   level 2 packed packed unaligned dcl 8-11 ref 186 186
                                                                                  197 201 220 221 223 231 231 240 241 244 246 258
                                                                                  260 281 320 321 322 328 343 344 349 354 367 385
                                                                                  386 387 397 398 399
unknown_condition               000122 automatic       char(16)                 dcl 70 set ref 205* 209* 212
unknown_key_word                000116 automatic       char(12)                 dcl 67 set ref 289* 291
unknown_statement                      constant        bit(9)                   initial dcl 13-3 ref 413
value_token                     000112 automatic       pointer                  dcl 65 set ref 253* 254* 262 263

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
adjust_count                    000000 constant        entry                    external dcl 2-20
allocate_statement                     internal static bit(9)                   initial dcl 13-3
and                                    internal static bit(9)                   initial dcl 12-3
array_node                             internal static bit(9)                   initial dcl 11-5
asterisk                               internal static bit(9)                   initial dcl 12-3
begin_statement                        internal static bit(9)                   initial dcl 13-3
bin_integer                            internal static bit(9)                   initial dcl 12-3
binary_to_octal_string          000000 constant        entry                    external dcl 2-38
binary_to_octal_var_string      000000 constant        entry                    external dcl 2-43
bindec                          000000 constant        entry                    external dcl 2-23
bindec$vs                       000000 constant        entry                    external dcl 2-28
binoct                          000000 constant        entry                    external dcl 2-33
bit_string                             internal static bit(9)                   initial dcl 12-3
block_node                             internal static bit(9)                   initial dcl 11-5
bound_node                             internal static bit(9)                   initial dcl 11-5
by_name_agg_node                       internal static bit(9)                   initial dcl 11-5
call_statement                         internal static bit(9)                   initial dcl 13-3
cat                                    internal static bit(9)                   initial dcl 12-3
char_string                            internal static bit(9)                   initial dcl 12-3
close_statement                        internal static bit(9)                   initial dcl 13-3
compare_expression              000000 constant        entry                    external dcl 2-48
constant_length                 000000 constant        entry                    external dcl 2-54
context_node                           internal static bit(9)                   initial dcl 11-5
continue_statement                     internal static bit(9)                   initial dcl 13-3
convert                         000000 constant        entry                    external dcl 2-60
convert$from_builtin            000000 constant        entry                    external dcl 2-72
convert$to_integer              000000 constant        entry                    external dcl 2-66
convert$to_target               000000 constant        entry                    external dcl 2-88
convert$to_target_fb            000000 constant        entry                    external dcl 2-82
convert$validate                000000 constant        entry                    external dcl 2-78
copy_expression                 000000 constant        entry                    external dcl 2-94
copy_expression$copy_sons       000000 constant        entry                    external dcl 2-99
copy_unique_expression          000000 constant        entry                    external dcl 2-103
create_array                    000000 constant        entry                    external dcl 2-108
create_block                    000000 constant        entry                    external dcl 2-112
create_bound                    000000 constant        entry                    external dcl 2-118
create_context                  000000 constant        entry                    external dcl 2-122
create_cross_reference          000000 constant        entry                    external dcl 2-128
create_default                  000000 constant        entry                    external dcl 2-132
create_identifier               000000 constant        entry                    external dcl 2-136
create_label                    000000 constant        entry                    external dcl 2-140
create_operator                 000000 constant        entry                    external dcl 2-152
create_statement                000000 constant        entry                    external dcl 2-163
create_statement$prologue       000000 constant        entry                    external dcl 2-171
create_storage                  000000 constant        entry                    external dcl 2-179
create_symbol                   000000 constant        entry                    external dcl 2-184
create_token$init_hash_table    000000 constant        entry                    external dcl 2-197
create_token$protected          000000 constant        entry                    external dcl 2-199
cross_reference_node                   internal static bit(9)                   initial dcl 11-5
decbin                          000000 constant        entry                    external dcl 2-206
declare_constant                000000 constant        entry                    external dcl 2-211
declare_constant$bit            000000 constant        entry                    external dcl 2-219
declare_constant$char           000000 constant        entry                    external dcl 2-224
declare_constant$desc           000000 constant        entry                    external dcl 2-229
declare_constant$integer        000000 constant        entry                    external dcl 2-234
declare_descriptor              000000 constant        entry                    external dcl 2-239
declare_descriptor$ctl          000000 constant        entry                    external dcl 2-249
declare_descriptor$param        000000 constant        entry                    external dcl 2-259
declare_integer                 000000 constant        entry                    external dcl 2-269
declare_picture                 000000 constant        entry                    external dcl 2-274
declare_picture_temp            000000 constant        entry                    external dcl 2-279
declare_pointer                 000000 constant        entry                    external dcl 2-287
declare_temporary               000000 constant        entry                    external dcl 2-292
decode_node_id                  000000 constant        entry                    external dcl 2-300
decode_source_id                000000 constant        entry                    external dcl 2-306
default_node                           internal static bit(9)                   initial dcl 11-5
default_statement                      internal static bit(9)                   initial dcl 13-3
delete_statement                       internal static bit(9)                   initial dcl 13-3
display_statement                      internal static bit(9)                   initial dcl 13-3
do_statement                           internal static bit(9)                   initial dcl 13-3
else_clause                            internal static bit(9)                   initial dcl 13-3
end_statement                          internal static bit(9)                   initial dcl 13-3
entry_statement                        internal static bit(9)                   initial dcl 13-3
eq                                     internal static bit(9)                   initial dcl 12-3
error                           000000 constant        entry                    external dcl 2-314
error$omit_text                 000000 constant        entry                    external dcl 2-319
error_                          000000 constant        entry                    external dcl 2-324
error_$finish                   000000 constant        entry                    external dcl 2-343
error_$initialize_error         000000 constant        entry                    external dcl 2-341
error_$no_text                  000000 constant        entry                    external dcl 2-334
exit_statement                         internal static bit(9)                   initial dcl 13-3
expon                                  internal static bit(9)                   initial dcl 12-3
fixed_bin                              internal static bit(9)                   initial dcl 12-3
fixed_dec                              internal static bit(9)                   initial dcl 12-3
float_bin                              internal static bit(9)                   initial dcl 12-3
float_dec                              internal static bit(9)                   initial dcl 12-3
format_statement                       internal static bit(9)                   initial dcl 13-3
format_value_node                      internal static bit(9)                   initial dcl 11-5
free_node                       000000 constant        entry                    external dcl 2-345
free_statement                         internal static bit(9)                   initial dcl 13-3
ge                                     internal static bit(9)                   initial dcl 12-3
get_array_size                  000000 constant        entry                    external dcl 2-348
get_size                        000000 constant        entry                    external dcl 2-352
get_statement                          internal static bit(9)                   initial dcl 13-3
goto_statement                         internal static bit(9)                   initial dcl 13-3
gt                                     internal static bit(9)                   initial dcl 12-3
i_bin_integer                          internal static bit(9)                   initial dcl 12-3
i_dec_integer                          internal static bit(9)                   initial dcl 12-3
i_fixed_bin                            internal static bit(9)                   initial dcl 12-3
i_fixed_dec                            internal static bit(9)                   initial dcl 12-3
i_float_bin                            internal static bit(9)                   initial dcl 12-3
i_float_dec                            internal static bit(9)                   initial dcl 12-3
is_arith_constant                      internal static bit(9)                   initial dcl 12-47
is_arithmetic_constant                 internal static bit(9)                   initial dcl 12-47
is_decimal_constant                    internal static bit(9)                   initial dcl 12-47
is_delimiter                           internal static bit(9)                   initial dcl 12-47
is_float_constant                      internal static bit(9)                   initial dcl 12-47
is_identifier                          internal static bit(9)                   initial dcl 12-47
is_imaginary_constant                  internal static bit(9)                   initial dcl 12-47
is_integral_constant                   internal static bit(9)                   initial dcl 12-47
is_isub                                internal static bit(9)                   initial dcl 12-47
isub                                   internal static bit(9)                   initial dcl 12-3
label_array_element_node               internal static bit(9)                   initial dcl 11-5
label_node                             internal static bit(9)                   initial dcl 11-5
le                                     internal static bit(9)                   initial dcl 12-3
list_node                              internal static bit(9)                   initial dcl 11-5
locate_statement                       internal static bit(9)                   initial dcl 13-3
lock_statement                         internal static bit(9)                   initial dcl 13-3
lt                                     internal static bit(9)                   initial dcl 12-3
machine_state_node                     internal static bit(9)                   initial dcl 11-5
max_list_elements                      internal static fixed bin(17,0)          initial dcl 9-12
merge_attributes                000000 constant        entry                    external dcl 2-355
ne                                     internal static bit(9)                   initial dcl 12-3
ngt                                    internal static bit(9)                   initial dcl 12-3
nlt                                    internal static bit(9)                   initial dcl 12-3
no_token                               internal static bit(9)                   initial dcl 12-3
node                                   based           structure                level 1 dcl 11-27
not                                    internal static bit(9)                   initial dcl 12-3
on_statement                           internal static bit(9)                   initial dcl 13-3
open_statement                         internal static bit(9)                   initial dcl 13-3
operator_node                          internal static bit(9)                   initial dcl 11-5
optimizer                       000000 constant        entry                    external dcl 2-361
or                                     internal static bit(9)                   initial dcl 12-3
parse_error$no_text             000000 constant        entry                    external dcl 2-368
percent                                internal static bit(9)                   initial dcl 12-3
pl1_error_print$listing_segment 000000 constant        entry                    external dcl 2-384
pl1_error_print$write_out       000000 constant        entry                    external dcl 2-372
pl1_print$for_lex               000000 constant        entry                    external dcl 2-418
pl1_print$non_varying           000000 constant        entry                    external dcl 2-398
pl1_print$non_varying_nl        000000 constant        entry                    external dcl 2-402
pl1_print$string_pointer        000000 constant        entry                    external dcl 2-406
pl1_print$string_pointer_nl     000000 constant        entry                    external dcl 2-410
pl1_print$unaligned_nl          000000 constant        entry                    external dcl 2-414
pl1_print$varying               000000 constant        entry                    external dcl 2-392
pl1_print$varying_nl            000000 constant        entry                    external dcl 2-395
pl1_stat_$statement_id                 external static structure                level 1 packed packed unaligned dcl 8-6
procedure_statement                    internal static bit(9)                   initial dcl 13-3
put_statement                          internal static bit(9)                   initial dcl 13-3
read_statement                         internal static bit(9)                   initial dcl 13-3
refer_extent                    000000 constant        entry                    external dcl 2-426
reference_node                         internal static bit(9)                   initial dcl 11-5
reserve$clear                   000000 constant        entry                    external dcl 2-430
reserve$declare_lib             000000 constant        entry                    external dcl 2-434
reserve$read_lib                000000 constant        entry                    external dcl 2-439
return_statement                       internal static bit(9)                   initial dcl 13-3
revert_statement                       internal static bit(9)                   initial dcl 13-3
rewrite_statement                      internal static bit(9)                   initial dcl 13-3
semantic_translator             000000 constant        entry                    external dcl 2-444
semantic_translator$abort       000000 constant        entry                    external dcl 2-446
semantic_translator$error       000000 constant        entry                    external dcl 2-450
sf_par_node                            internal static bit(9)                   initial dcl 11-5
share_expression                000000 constant        entry                    external dcl 2-454
signal_statement                       internal static bit(9)                   initial dcl 13-3
slash                                  internal static bit(9)                   initial dcl 12-3
source_node                            internal static bit(9)                   initial dcl 11-5
statement_node                         internal static bit(9)                   initial dcl 11-5
stop_statement                         internal static bit(9)                   initial dcl 13-3
symbol_node                            internal static bit(9)                   initial dcl 11-5
system_on_unit                         internal static bit(9)                   initial dcl 13-3
temporary_node                         internal static bit(9)                   initial dcl 11-5
token_list_length                      internal static fixed bin(15,0)          initial dcl 8-4
token_node                             internal static bit(9)                   initial dcl 11-5
token_to_binary                 000000 constant        entry                    external dcl 2-459
unlock_statement                       internal static bit(9)                   initial dcl 13-3
wait_statement                         internal static bit(9)                   initial dcl 13-3
write_statement                        internal static bit(9)                   initial dcl 13-3

NAMES DECLARED BY EXPLICIT CONTEXT.
another                         000455 constant        label                    dcl 199 ref 220
check_label                     000645 constant        label                    dcl 229 ref 274
has_equal                       001442 constant        entry                    internal dcl 393 ref 322
if_check                        001312 constant        label                    dcl 341 ref 328 347 352 356 360 372
label                           001137 constant        label                    dcl 268 ref 240
not_label                       001164 constant        label                    dcl 279 ref 194 241 254 258 260
print                           001500 constant        entry                    internal dcl 407 ref 192 201 215 221 223 237 385
return_assignment               001365 constant        label                    dcl 374 ref 282 283 284 285 295 300 320 321 322 322
                                                                                  331 343
skip_parens                     001374 constant        entry                    internal dcl 380 ref 310 399
statement_type                  000367 constant        entry                    external dcl 36
then_check                      001352 constant        label                    dcl 367 ref 357
type_return                     001367 constant        label                    dcl 376 ref 294 326 328 369 370 371 414
verify_s_type                   001252 constant        label                    dcl 308 ref 296

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1652        1700    1541        1662
Length      2324    1541        26         407     110           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
statement_type                      164 external procedure  is an external procedure.  
skip_parens                             internal procedure  shares stack frame of external procedure statement_type.  
has_equal                               internal procedure  shares stack frame of external procedure statement_type.  
print                                   internal procedure  shares stack frame of external procedure statement_type.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
statement_type           000100 j                           statement_type
                         000101 k                           statement_type
                         000102 ksaved                      statement_type
                         000103 paren_count                 statement_type
                         000104 n                           statement_type
                         000106 p                           statement_type
                         000110 q                           statement_type
                         000112 value_token                 statement_type
                         000114 assumed_s_type              statement_type
                         000115 next_type                   statement_type
                         000116 unknown_key_word            statement_type
                         000121 condition_value             statement_type
                         000122 unknown_condition           statement_type
                         000126 token_list_pointer          statement_type

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mdfx1               signal_op
shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
constant_token                create_list                   create_reference              create_token
parse_error

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pl1_stat_$level_0_colon       pl1_stat_$token_list_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000362    8    3 000374       176 000377       177 000402       181 000405       186 000407       189 000422
    190 000424       192 000430       194 000443       197 000444       199 000455       201 000456       202 000502
    204 000513       205 000514       206 000521       208 000522       209 000524       212 000530       213 000543
    215 000545       218 000565       219 000575       220 000576       221 000607       222 000624       223 000625
    224 000643       225 000644       229 000645       231 000647       234 000662       235 000665       237 000671
    238 000704       239 000711       240 000712       241 000723       242 000725       243 000726       244 000730
    246 000743       248 000745       249 000747       253 000750       254 000754       256 001003       257 001007
    258 001010       259 001020       260 001021       262 001031       263 001034       264 001035       265 001045
    266 001063       267 001133       268 001137       270 001140       271 001153       272 001156       273 001162
    274 001163       279 001164       281 001170       282 001177       283 001201       284 001203       285 001205
    289 001207       290 001216       291 001223       293 001232       294 001240       295 001243       296 001246
    298 001247       300 001251       308 001252       310 001253       319 001254       320 001255       321 001266
    322 001270       326 001303       328 001304       331 001311       341 001312       343 001313       344 001324
    346 001327       347 001330       349 001331       351 001333       352 001335       354 001336       356 001340
    357 001342       360 001351       367 001352       369 001356       370 001360       371 001362       372 001364
    374 001365       376 001367       380 001374       382 001375       383 001377       384 001402       385 001403
    386 001421       387 001434       388 001440       390 001441       393 001442       396 001444       397 001445
    398 001462       399 001470       400 001473       402 001474       407 001500       412 001502       413 001514
    414 001515


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
