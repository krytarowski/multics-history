	COMPILATION LISTING OF SEGMENT abs_io_v1_get_line
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx, AZ, Sys-M  
	Compiled on: 09/10/87  1458.6 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-03-05,Parisek), approve(87-07-23,MCR7716),
       17*     audit(87-08-07,Fawcett), install(87-08-11,MR12.1-1080):
       18*     Continue execution with next exec_com line when abs_io_data.noabort
       19*     is ON.
       20*  2) change(87-09-02,Parisek), approve(87-09-02,PBF7716),
       21*     audit(87-09-03,Farley), install(87-09-10,MR12.1-1104):
       22*     Handle a nobort operation only if severity 1 errors occur.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* Original coding: 25 June 1979 by J. Spencer Love
       27*   Modified: 19 August 1981 by Steve Herbst not to loop if &detach gets an error.
       28*   Modified: 14 February 1982 by Gary Palter for new calling sequence of ec_data.eval_string and to convert from
       29*   command_processor_$af to cu_$evaluate_active_string.
       30*   Modified: 7 June 1982 by J. Spencer Love to improve error checking for &then and &else clauses.			*/
       31 /* Recompiled for changes to abs_data structure 04/12/83 S. Herbst */
       32 
       33 /* format: style3,ifthenstmt,indcomtxt,indproc,idind30 */
       34 
       35 abs_io_v1_get_line:
       36      procedure (P_iocb_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);
       37 
       38 declare	P_iocb_ptr		ptr,		/* ptr to IOCB of abs_io_ or syn_ attached to abs_io_	*/
       39 	P_buffer_ptr		ptr,		/* ptr to caller's input buffer			*/
       40 	P_buffer_len		fixed bin (21),	/* maximum length (in chars) of caller's buffer		*/
       41 	P_actual_len		fixed bin (21),	/* length of data actually returned			*/
       42 	P_status			fixed bin (35);	/* standard system error code				*/
       43 
       44 declare	(addr, binary, char, codeptr, copy, divide, index, length, ltrim, max, min, mod, null, rank, rtrim, search,
       45 	string, substr, unspec, verify)
       46 				builtin;
       47 
       48 declare	(area, cleanup)		condition;
       49 
       50 declare	IS			char (input_string.len) based (input_string.ptr),
       51 	old_IS_pos		fixed bin (21);
       52 
       53 declare	CL_len			fixed bin (21),
       54 	CL_pos			fixed bin (21),
       55 	CL_ptr			ptr,
       56 	CL			char (CL_len) based (CL_ptr),
       57 	not_in_CL			bit (1) aligned,
       58 	old_CL_pos		fixed bin (21);
       59 
       60 declare	RS_len			fixed bin (21),
       61 	RS_pos			fixed bin (21),
       62 	RS_ptr			ptr,
       63 	RS			char (RS_len) based (RS_ptr),
       64 	old_RS_len		fixed bin (21);
       65 
       66 declare	arg_idx			fixed bin,
       67 	break			fixed bin,
       68 	buffer_allocated		bit (1) aligned,
       69 	buffer_len		fixed bin (21),
       70 	buffer_ptr		ptr,
       71 	control			fixed bin,
       72 	copy_len			fixed bin (21),
       73 	from_sw			bit (1) aligned,
       74 	get_next_line		local label variable,
       75 	hash			fixed bin,
       76 	input_reset_sw		bit (1) aligned,
       77 	iocb_ptr			ptr,
       78 	len			fixed bin (21),
       79 	quote_modifier		fixed bin,
       80 	start			fixed bin (21),
       81 	state			fixed bin,
       82 	saved_hash		fixed bin,
       83 	saved_label_ptr		ptr,
       84 	saved_state		fixed bin,
       85 	scanning_clause		bit (1) aligned,
       86 	status			fixed bin (35),
       87 	test			bit (1) aligned,
       88 	twoL			fixed bin (21),
       89 	width			fixed bin;
       90 
       91 declare	1 ready_mode		aligned,
       92 	  2 flag			bit (1) unaligned,
       93 	  2 pad			bit (35) unaligned;
       94 
       95 declare	ec_name			char (arg_info.ec_name_len) based (arg_info.ec_name_ptr),
       96 	ec_path			char (arg_info.ec_path_len) based (arg_info.ec_path_ptr),
       97 	P_buffer			char (P_actual_len) based (P_buffer_ptr),
       98 	allocated_chars		char (abs_data.allocated_chars_len) based (abs_data.allocated_chars_ptr),
       99 	return_arg		char (ec_data.return_len) varying based (ec_data.return_ptr);
      100 
      101 declare	arg_string		char (arg_array (arg_idx).len) based (arg_array (arg_idx).ptr);
      102 
      103 declare	1 arg_array		(abs_data.arg_count) aligned based (abs_data.arg_ptr),
      104 	  2 ptr			ptr,
      105 	  2 len			fixed bin (21),
      106 	  2 quotes		fixed bin (21);
      107 
      108 declare	INIT			bit (1) aligned static options (constant) initial ("0"b),
      109 	UPDATE			bit (1) aligned static options (constant) initial ("1"b);
      110 
      111 declare	NL			char (1) static options (constant) initial ("
      112 ");
      113 
      114 declare	NL_THEN_AMP		char (2) static options (constant) initial ("
      115 &");
      116 
      117 declare	SPACE			char (1) static options (constant) initial (" "),
      118 	TRUE			char (4) static options (constant) initial ("true"),
      119 	FALSE			char (5) static options (constant) initial ("false"),
      120 	TRACE_THEN		char (6) static options (constant) initial ("&then "),
      121 	TRACE_ELSE		char (6) static options (constant) initial ("&else ");
      122 
      123 declare	RANK_ZERO			fixed bin static options (constant) initial (48),
      124 	RANK_AMP_ADJ		fixed bin static options (constant) initial (-10),
      125 	RANK_F_ADJ		fixed bin static options (constant) initial (54);
      126 
      127 declare	NONE			fixed bin static options (constant) initial (0),
      128 	QUOTE			fixed bin static options (constant) initial (1),
      129 	REQUOTE			fixed bin static options (constant) initial (2);
      130 
      131 declare	NORMAL			fixed bin static options (constant) initial (0),
      132 	SEARCHING_FOR_LABEL		fixed bin static options (constant) initial (1),
      133 	MUST_BE_LABEL		fixed bin static options (constant) initial (2),
      134 	MUST_BE_THEN		fixed bin static options (constant) initial (3),
      135 	SKIPPING_CLAUSE		fixed bin static options (constant) initial (4);
      136 
      137 declare	DATA			fixed bin static options (constant) initial (-1),
      138 	COMMENT			fixed bin static options (constant) initial (0),
      139 	ELSE			fixed bin static options (constant) initial (6),
      140 	GOTO			fixed bin static options (constant) initial (7),
      141 	LABEL			fixed bin static options (constant) initial (10),
      142 	THEN			fixed bin static options (constant) initial (16);
      143 
      144 declare	LOW			(12) fixed bin static options (constant)
      145 				initial (1, 2, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17);
      146 
      147 declare	HIGH			(12) fixed bin static options (constant)
      148 				initial (1, 4, 5, 6, 7, 9, 10, 11, 12, 15, 16, 17);
      149 
      150 declare	KEYWORD			(17) char (12) varying static options (constant)
      151 				initial ("attach", "command_line", "comment_line", "control_line", "detach",
      152 				"else", "goto", "if", "input_line", "label", "print", "quit", "ready",
      153 				"ready_proc", "return", "then", "version");
      154 
      155 declare	TRACE			(-1:17) bit (1) aligned static options (constant)
      156 				initial ("0"b, "0"b, (5) ("1"b), "0"b, "1"b, "0"b, (7) ("1"b), "0"b, "0"b);
      157 
      158 declare	SKIPABLE			(-1:17) bit (1) aligned static options (constant)
      159 				initial ("1"b, "0"b, (5) ("1"b), "0"b, "1"b, "0"b, "1"b, "0"b, (5) ("1"b), "0"b,
      160 				"1"b);
      161 
      162 declare	WHITE			char (5) static options (constant) initial ("
      163 	 ");					/* FF VT NL HT SP					*/
      164 
      165 declare	(
      166 	error_table_$noalloc,
      167 	error_table_$command_line_overflow,
      168 	error_table_$end_of_info,
      169 	error_table_$long_record
      170 	)			fixed bin (35) external,
      171 	iox_$user_output		ptr external,
      172 	iox_$user_input		ptr external;
      173 
      174 declare	abs_io_control$attach	entry (ptr, ptr, fixed bin (35)),
      175 	abs_io_control$detach	entry (ptr, ptr, fixed bin (35)),
      176 	abs_io_control$sleep	entry (ptr),
      177 	active_fnc_err_		entry () options (variable),
      178 	com_err_			entry () options (variable),
      179 	cu_$arg_list_ptr		entry () returns (ptr),
      180 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      181 	cu_$evaluate_active_string	entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
      182 	cu_$set_ready_mode		entry (1 aligned like ready_mode),
      183 	hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
      184 	ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1), bit (1)),
      185 	ioa_$nnl			entry options (variable),
      186 	iox_$find_iocb		entry (char (*), ptr, fixed bin (35)),
      187 	iox_$get_line		entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      188 	iox_$put_chars		entry (ptr, ptr, fixed bin (21), fixed bin (35)),
      189 	logout			entry options (variable),
      190 	signal_io_error_		entry (char (*), ptr, fixed bin (35));
      191 
      192 /* abs_io_v1_get_line: procedure (P_iocb_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);  */
      193 
      194 	call get_ptrs (INIT);			/* the usual housekeeping to interface to the I/O system	*/
      195 
      196 	input_reset_sw = "0"b;
      197 
      198 /* recursion check. used to protect against &if [io get_line &ec_switch] (e.g., &if [query ...] in absentee)		*/
      199 
      200 	do while (abs_data.active);			/* Loop until bit is cleared asynchronously, if set	*/
      201 	     if attachedp ()
      202 	     then do;				/* Not our problem; we can offload this request to attachee */
      203 		     call iox_$get_line (abs_data.attach.save_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status)
      204 			;
      205 		     return;
      206 		end;
      207 
      208 	     call signal_io_error_ ("Attempt to invoke parser recursively.  Check for invalid ""&if"" test.", iocb_ptr,
      209 		0);
      210 
      211 	     call get_ptrs (INIT);			/* world may have changed, so reinit our view of it	*/
      212 	end;
      213 
      214 	on cleanup abs_data.active = "0"b;		/* Protect against non-local goto			*/
      215 
      216 	abs_data.active = "1"b;			/* Prevent recursive invocation of this I/O switch	*/
      217 
      218 /* Handle abnormal situations:  no data left, or partial line remaining.  Initialize for exit paths as needed.	*/
      219 
      220 	if abs_data.eof then go to END_OF_FILE;		/* No data left, just exit without doing any work		*/
      221 
      222 	if abs_data.chars_len > 0 then go to CONTINUE_LONG_RECORD;
      223 
      224 /* Timed input mode:  used in absentee processes to simulate interactive usage patterns				*/
      225 
      226 	if abs_data.timed_input then call abs_io_control$sleep (abs_data_ptr);
      227 
      228 /* Now initialize variables for the scan...								*/
      229 
      230 	width = 0;				/* width of modifier field, e.g., f, q, r, qf, rf, f&n, etc */
      231 	quote_modifier = NONE;			/* quote processing to be done to current parameter	*/
      232 	from_sw = "0"b;				/* current parameter doesn't (yet) have f as in &f	*/
      233 	saved_hash = -1;				/* used by &goto... valid range 0:60			*/
      234 
      235 /* Hack nested &if statements where we returned something and have to skip the rest of a compound statement		*/
      236 
      237 	if abs_data.nest_level > abs_data.expected_nest_level
      238 	then state = SKIPPING_CLAUSE;			/* In the middle of an &if:  if we're here, skip the rest	*/
      239 	else state = NORMAL;
      240 
      241 	if abs_data.else_clause_len > 0 then go to CONTINUE_WITH_PENDING_ELSE_CLAUSE;
      242 						/* not finished with last line, can't expand another yet	*/
      243 
      244 	buffer_allocated = "0"b;			/* Initially expanding into P_buffer			*/
      245 	get_next_line = EXPAND_NEXT_LINE;		/* Normal setting.  Used by &if nesting get control back.	*/
      246 	CL_len = 0;				/* No statements scanned yet, so don't skip anything	*/
      247 
      248 EXPAND_NEXT_LINE:
      249 	input_string.position = input_string.position + CL_len;
      250 						/* Position to the beginning of the next statement	*/
      251 	if input_string.position >= input_string.len then go to END_OF_FILE;
      252 						/* If we've gone too far, punt now			*/
      253 
      254 	CL_ptr = addr (substr (IS, input_string.position + 1));
      255 	CL_len = index (substr (IS, input_string.position + 1), NL);
      256 	if CL_len = 0 then go to NO_NEW_LINE;		/* Must be at end of file, print warning and &quit	*/
      257 
      258 	not_in_CL = "0"b;				/* Use original line in input seg, no expansions so far	*/
      259 	scanning_clause = "0"b;			/* We are not currently within an &then or &else clause	*/
      260 
      261 	CL_pos = index (CL, "&") - 1;			/* Find the first ampersand in the current line		*/
      262 	if CL_pos < 0 then go to COPY_REST;		/* No ampersands in line.  Skip expansion loop.		*/
      263 
      264 	RS_len, old_CL_pos, old_RS_len = 0;		/* So far we've expanded nothing			*/
      265 	RS_ptr = buffer_ptr;			/* We will expand to here, if necessary			*/
      266 	twoL = 1;					/* This is 2**(quote depth), used for requoting		*/
      267 
      268 	if CL_pos = 0
      269 	then do;					/* First char is ampersand.  Special case for fast comments */
      270 		break = index ("0123456789efinqracdglptv", substr (CL, 2, 1)) - 1;
      271 		if break < 0 then go to COMMENT_LINE;	/* If it's a comment, we needn't expand it or return it	*/
      272 		if break < 10 then go to EXPAND_ARG_NUMBER;
      273 						/* A digit.  Get whole number and expand argument		*/
      274 		if break < 16 then go to EXPAND (break);/* Might be expandable, investigate further		*/
      275 		go to EXPAND_AGAIN;			/* This might be a keyword, but we can't handle it now.	*/
      276 	     end;
      277 
      278 /* This is the loop which expands lines from the input segment.  It is entered here if the first character on the line
      279*   is not an ampersand.  If the first character is an ampersand, it will have been handled on the previous page as a
      280*   performance hack to not expand comment lines.  If no expandable constructs are encountered, the line will still be
      281*   in the input segment.  If expansion is done, it is initially into the caller-provided buffer, but if that is too
      282*   small, a larger buffer will be allocated and expansion will use it until the next line is returned to the caller.	*/
      283 
      284 EXPAND_LOOP:
      285 	break = index ("0123456789efinqr", substr (CL, CL_pos + 2, 1)) - 1;
      286 	if break < 0 then go to EXPAND_AGAIN;		/* Not expandable. skip it				*/
      287 	if break < 10 then go to EXPAND_ARG_NUMBER;	/* A digit.  Get whole number and expand argument		*/
      288 	go to EXPAND (break);			/* Might be expandable... investigate further		*/
      289 
      290 EXPAND (10):					/* &e						*/
      291 	if substr (CL, CL_pos + 3, 1) ^= "c" then go to EXPAND_AGAIN;
      292 						/* performance hack for &else				*/
      293 
      294 	if substr (CL, CL_pos + 4, min (CL_len, 5)) = "_name" then call emit_ec_name ();
      295 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 4)) = "_dir" then call emit_ec_dir ();
      296 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 7)) = "_switch" then call emit_ec_switch ();
      297 
      298 	go to EXPAND_AGAIN;
      299 
      300 EXPAND (11):					/* &f						*/
      301 	from_sw = "1"b;
      302 
      303 	go to EXPAND_MODIFIER;
      304 
      305 EXPAND (12):					/* &i						*/
      306 	if substr (CL, CL_pos + 3, 1) ^= "s" then go to EXPAND_AGAIN;
      307 						/* Performance hack for &if				*/
      308 
      309 	if substr (CL, CL_pos + 4, min (CL_len - 3, 6)) = "_absin" then call predicate (abs_data.absentee, 8);
      310 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 16)) = "_active_function"
      311 	then call predicate (functionp (), 18);
      312 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 3)) = "_af" then call predicate (functionp (), 5);
      313 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 9)) = "_attached" then call predicate (attachedp (), 11);
      314 	else if substr (CL, CL_pos + 4, min (CL_len - 3, 11)) = "_input_line" then call predicate (input_linep (), 13);
      315 
      316 	go to EXPAND_AGAIN;
      317 
      318 EXPAND (13):					/* &n:  The number of arguments given for substitution	*/
      319 	call emit_arg_count ();
      320 
      321 	go to EXPAND_AGAIN;
      322 
      323 EXPAND (14):					/* &q						*/
      324 	quote_modifier = QUOTE;
      325 
      326 	go to EXPAND_MODIFIER;
      327 
      328 EXPAND (15):					/* &r						*/
      329 	quote_modifier = REQUOTE;
      330 
      331 EXPAND_MODIFIER:
      332 	width = width + 1;
      333 	break = rank (substr (CL, CL_pos + width + 2, 1)) - RANK_ZERO;
      334 	if break = RANK_F_ADJ & ^from_sw
      335 	then do;
      336 		from_sw = "1"b;
      337 		go to EXPAND_MODIFIER;
      338 	     end;
      339 	if break = RANK_AMP_ADJ
      340 	then if substr (CL, CL_pos + width + 3, 1) = "n"
      341 	     then do;				/* &..&n:  Appropriately modified last argument		*/
      342 		     arg_idx = abs_data.arg_count;
      343 		     width = width + 2;
      344 		     go to COPY_ARG;
      345 		end;
      346 	if break < 0 | break > 9
      347 	then do;					/* Construct isn't really a parameter, skip it		*/
      348 		width = 0;			/* Reset these to default values, save the work elsewhere	*/
      349 		quote_modifier = NONE;
      350 		from_sw = "0"b;
      351 		go to EXPAND_AGAIN;
      352 	     end;
      353 
      354 EXPAND_ARG_NUMBER:
      355 	arg_idx = 0;
      356 	do break = break repeat (rank (substr (CL, CL_pos + width + 2, 1)) - RANK_ZERO) while (break >= 0 & break <= 9);
      357 	     if arg_idx <= abs_data.arg_count then arg_idx = 10 * arg_idx + break;
      358 	     width = width + 1;
      359 	end;
      360 
      361 COPY_ARG:
      362 	call copy_up_to_ampersand (width);		/* Skip construct (width chars long)			*/
      363 	width = 0;
      364 	if from_sw
      365 	then do;					/* User specified range of arguments to expand		*/
      366 		from_sw = "0"b;
      367 		do arg_idx = max (1, arg_idx) to abs_data.arg_count;
      368 		     call copy_string (arg_string, quote_modifier);
      369 		     if arg_idx ^= abs_data.arg_count then call copy_string (SPACE, NONE);
      370 		end;
      371 	     end;
      372 	else if arg_idx = 0 then call copy_string (ec_path, quote_modifier);
      373 	else if arg_idx <= abs_data.arg_count then call copy_string (arg_string, quote_modifier);
      374 	quote_modifier = NONE;
      375 
      376 EXPAND_AGAIN:
      377 	CL_pos = CL_pos + 1;			/* Skip ampersand					*/
      378 	break = index (substr (CL, CL_pos + 1), "&") - 1;
      379 	if break >= 0
      380 	then do;					/* Any more ampersands in line?			*/
      381 		CL_pos = CL_pos + break;
      382 		go to EXPAND_LOOP;
      383 	     end;
      384 
      385 COPY_REST:
      386 	if not_in_CL
      387 	then do;					/* Copy rest of line if any expansions			*/
      388 		copy_len = CL_len - old_CL_pos;
      389 		call check_len (copy_len);
      390 		substr (RS, RS_len - copy_len + 1, copy_len) = substr (CL, old_CL_pos + 1, copy_len);
      391 	     end;
      392 	else do;					/* Use unexpanded string, we may not need to copy it	*/
      393 		RS_len = CL_len;
      394 		RS_ptr = CL_ptr;
      395 	     end;
      396 
      397 /* We come here to identify the current request line as a statement, command, or expansion to be returned.
      398*   We can get here by falling through from expansion, or to identify an &then or &else clause.			*/
      399 
      400 CHECK_CONTROL:
      401 
      402 	if substr (RS, 1, min (1, RS_len)) = "&"
      403 	then do;					/* If first char is ampersand, hash on second char	*/
      404 		break = index ("acdegilpqrtv", substr (RS, 2, 1));
      405 		if break = 0 then go to COMMENT_LINE;
      406 		len = search (substr (RS, 3), WHITE);	/* Get length of possible keyword			*/
      407 		do control = LOW (break) to HIGH (break);
      408 		     if KEYWORD (control) = substr (RS, 2, len)
      409 		     then do;			/* Got a match! so just space RS_pos over it		*/
      410 			     RS_pos = verify (substr (RS, len + 3), WHITE) + len + 1;
      411 			     if RS_pos = len + 1 then RS_pos = RS_len;
      412 			     go to STATE (state);	/* And we're off to an action routine (of some sort)	*/
      413 			end;
      414 		end;
      415 
      416 		if len > 4
      417 		then if break = 4
      418 		     then if substr (RS, 2, 4) = "else"
      419 			then call warning (0,
      420 				"Whitespace must follow the ""&else"" keyword or the line is a comment.");
      421 			else ;
      422 		     else if break = 11
      423 		     then if substr (RS, 2, 4) = "then"
      424 			then call warning (0,
      425 				"Whitespace must follow the ""&then"" keyword or the line is a comment.");
      426 
      427 COMMENT_LINE:
      428 		control = COMMENT;			/* We have a leading ampersand but no keyword. Ignore it	*/
      429 	     end;
      430 	else control = DATA;			/* No ampersand so this line can be returned to user	*/
      431 
      432 	go to STATE (state);			/* Off to the wars (someone will handle this line)	*/
      433 
      434 STATE (0):					/* NORMAL:  we come here if not in search or conditional	*/
      435 	if TRACE (control) then call trace_output (abs_data.control_line, RS);
      436 
      437 	go to CONTROL (control);			/* This is where we really head off to the action routine	*/
      438 
      439 CONTINUE_LONG_RECORD:
      440 	buffer_allocated = "1"b;			/* Tell exit routine to take data out of buffer		*/
      441 	CL_len = 0;				/* Don't skip over statement since we did no expansion	*/
      442 	scanning_clause = "0"b;			/* Init this for tastefulness sake			*/
      443 	not_in_CL = "1"b;				/* Not from input segment				*/
      444 	RS_len = abs_data.chars_len;			/* set RS to pending string				*/
      445 	RS_ptr = abs_data.chars_ptr;
      446 
      447 CONTROL (-1):					/* DATA = data to return to caller			*/
      448 	if not_in_CL & ^buffer_allocated & ^scanning_clause
      449 	then P_actual_len = RS_len;			/* All done since all data is already in caller's buffer	*/
      450 	else do;					/* Otherwise copy as much as will fit			*/
      451 		P_actual_len = min (P_buffer_len, RS_len);
      452 		P_buffer = RS_ptr -> P_buffer;	/* If it doesn't all fit, stash the rest for later calls	*/
      453 		if P_actual_len < RS_len
      454 		then if not_in_CL
      455 		     then do;			/* We have an allocated buffer, and characters in it	*/
      456 			     abs_data.chars_ptr = addr (substr (RS, P_actual_len + 1));
      457 			     abs_data.chars_len = RS_len - P_actual_len;
      458 			end;
      459 		     else do;			/* this means no pending &else clause or full buffer	*/
      460 			     RS_ptr = addr (substr (RS, P_actual_len + 1));
      461 			     abs_data.chars_len, RS_len = RS_len - P_actual_len;
      462 			     call allocate_buffer (RS_len);
      463 			     abs_data.chars_ptr = RS_ptr;
      464 			end;
      465 		else abs_data.chars_len = 0;
      466 	     end;
      467 
      468 	if abs_data.allocated_chars_ptr ^= null () & abs_data.chars_len <= 0 & abs_data.else_clause_len <= 0
      469 	then free allocated_chars;			/* We don't need the buffer anymore so we can dump it	*/
      470 
      471 	input_string.position = input_string.position + CL_len;
      472 						/* Step over statement so we will get next one later	*/
      473 
      474 	if input_linep ()
      475 	then call trace_output (abs_data.input_line, P_buffer);
      476 	else call trace_output (abs_data.command_line, P_buffer);
      477 
      478 	if abs_data.chars_len > 0
      479 	then P_status = error_table_$long_record;	/* Pending chars exist so tell caller			*/
      480 	else P_status = 0;
      481 
      482 EGRESS:
      483 	abs_data.active = "0"b;
      484 	return;
      485 
      486 NO_NEW_LINE:
      487 	if state = SEARCHING_FOR_LABEL then go to STATE (SEARCHING_FOR_LABEL);
      488 						/* &goto should field this				*/
      489 
      490 	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited his ec				*/
      491 
      492 	call warning (0, "The last line did not end in a newline and was ignored.");
      493 
      494 END_OF_FILE:
      495 	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited his ec.				*/
      496 
      497 	if state = MUST_BE_THEN
      498 	then call error (0, "The end of file was encountered when a ""&then"" statement was expected.");
      499 
      500 	abs_data.eof = "1"b;			/* Make sure that end of file is remembered		*/
      501 
      502 	if ^input_reset_sw
      503 	then do;					/* Mustn't leave &attach in effect			*/
      504 		input_reset_sw = "1"b;
      505 
      506 		call reset_input ();
      507 	     end;
      508 
      509 	if abs_data.absentee then call logout ();
      510 
      511 	P_actual_len = 0;				/* Tell user what happened and how much data he got	*/
      512 	P_status = error_table_$end_of_info;
      513 
      514 	go to EGRESS;				/* Only one exit allowed for cleanup purposes		*/
      515 
      516 /* The following small serving of spaghetti is used to implement &goto and &label.  Labels are kept in chained buckets
      517*   in a small hash table.  Buckets are allocated the first time a label is seen, whether it it in a &label or a &goto.
      518*   There is no limit on the length of labels and the characters in a label, except that leading and trailing whitespace
      519*   are removed from them.  The blank label is allowed.  Label search is defined to find the first instance of a label
      520*   starting from the top of the file, so duplicate instances of the same label are ignored.  The hashed label scheme is
      521*   a large performance improvement in big exec_coms.							*/
      522 
      523 CONTROL (7):					/* &goto						*/
      524 	abs_data.nest_level = 0;			/* reset nest state, so parser doesn't think we are	*/
      525 	abs_data.else_clause_len = 0;			/* still in if statement or have else clause pending.	*/
      526 	get_next_line = EXPAND_NEXT_LINE;		/* also set scanner back to normal			*/
      527 
      528 	input_string.limit = max (input_string.limit, input_string.position + CL_len);
      529 						/* save farthest point in case backward branch		*/
      530 	go to GET_CURRENT_LABEL;			/* now go parse statement				*/
      531 
      532 CONTROL (10):					/* &label						*/
      533 	if scanning_clause then call error (0, "A label may not follow ""&then"" or ""&else"".");
      534 
      535 	if input_string.limit > input_string.position then go to get_next_line;
      536 						/* Have we seen this label already?			*/
      537 
      538 GET_CURRENT_LABEL:
      539 	current_label_ptr = addr (substr (RS, RS_pos + 1));
      540 	current_label_len = length (rtrim (substr (RS, RS_pos + 1), WHITE));
      541 	hash =
      542 	     mod (binary (unspec (char (substr (current_label, 1, min (2, current_label_len)), 2)), 18)
      543 	     + current_label_len, 61);
      544 
      545 	if hash = saved_hash			/* cheap test -- saved_hash = -1 if not looking		*/
      546 	then if current_label = saved_label_ptr -> label.name
      547 	     then do;
      548 		     saved_hash = -1;		/* reset saved_hash to illegal value for test		*/
      549 		     if state = MUST_BE_LABEL
      550 		     then do;			/* Label found in hash table has been verified		*/
      551 			     state = NORMAL;
      552 			     go to get_next_line;
      553 			end;
      554 		     state = NORMAL;		/* reset from SEARCHING_FOR_LABEL			*/
      555 		     label_ptr = saved_label_ptr;	/* so saved block will be threaded properly		*/
      556 		     go to THREAD_IN_LABEL;
      557 		end;
      558 
      559 	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited the input file.			*/
      560 
      561 	if abs_data.labels_ptr = null () then call allocate_hash_table ();
      562 
      563 	do label_ptr = abs_data.labels_ptr -> hash_table (hash) repeat (label.next_ptr) while (label_ptr ^= null ());
      564 	     if current_label = label.name		/* if match then three possible actions			*/
      565 	     then if control = LABEL			/* for label we just go to next line, which in		*/
      566 		then if state = NORMAL		/* search mode calls for special action to		*/
      567 		     then go to get_next_line;	/* only scan control lines for efficiency		*/
      568 		     else go to GET_NEXT_LABEL_LINE;
      569 		else do;
      570 			saved_hash = hash;
      571 			saved_label_ptr = label_ptr;
      572 			old_IS_pos = input_string.position;
      573 			input_string.position = label.statement_pos;
      574 			if input_string.position > 0
      575 			then if substr (IS, input_string.position, 1) ^= NL then go to UNSTUCK_LABEL;
      576 			state = MUST_BE_LABEL;
      577 			CL_len = 0;
      578 			go to get_next_line;
      579 		     end;
      580 	end;
      581 
      582 	on area call error (error_table_$noalloc, "Allocating label ""^a"".", current_label);
      583 
      584 	allocate label in (abs_data.work_area);		/* we need a new label cell since we now know this label	*/
      585 						/* has never been seen before.  length is arbitrary	*/
      586 	revert area;
      587 
      588 	if control = GOTO
      589 	then do;
      590 		saved_hash = hash;			/* we do this for cheap compare above			*/
      591 		saved_label_ptr = label_ptr;		/* we will need this later for compare and threading in	*/
      592 		old_IS_pos = input_string.position;	/* this is for line number in error message		*/
      593 		state = SEARCHING_FOR_LABEL;		/* set state to ignore everything but labels		*/
      594 		input_string.position = input_string.limit - CL_len;
      595 		go to GET_NEXT_LABEL_LINE;		/* start search beyond what we've already seen		*/
      596 	     end;
      597 
      598 THREAD_IN_LABEL:
      599 	label.statement_pos = input_string.position;	/* set label to beginning of its line			*/
      600 	label.next_ptr = abs_data.labels_ptr -> hash_table (hash);
      601 	abs_data.labels_ptr -> hash_table (hash) = label_ptr;
      602 
      603 	if state = NORMAL then go to get_next_line;	/* We are done unless still skipping			*/
      604 
      605 GET_NEXT_LABEL_LINE:
      606 	input_string.position = input_string.position + CL_len;
      607 	CL_len = index (substr (IS, input_string.position), NL_THEN_AMP) - 1;
      608 						/* search for next control string			*/
      609 	if CL_len >= 0 then go to get_next_line;	/* Found something; check it out			*/
      610 
      611 	input_string.position = old_IS_pos;		/* Restore position for error message.			*/
      612 	call error (0, "Label ""^a"" not found.", saved_label_ptr -> label.name);
      613 
      614 STATE (1):					/* SEARCHING_FOR_LABEL				*/
      615 	if control = LABEL
      616 	then go to GET_CURRENT_LABEL;			/* in this state we ignore everything but &label lines	*/
      617 	else go to GET_NEXT_LABEL_LINE;		/* since efficient label search is critical		*/
      618 
      619 STATE (2):					/* MUST_BE_LABEL					*/
      620 	if control = LABEL then go to GET_CURRENT_LABEL;
      621 
      622 UNSTUCK_LABEL:
      623 	input_string.position = old_IS_pos;
      624 	state = NORMAL;
      625 	call error (0, "Label ""^a"" is unstuck.  Active programs may not be edited.", saved_label_ptr -> label.name);
      626 
      627 CONTROL (0):					/* COMMENT LINE					*/
      628 	if scanning_clause then call error (0, "A comment may not follow ""&then"" or ""&else"".");
      629 
      630 	call trace_output (abs_data.comment_line, CL);
      631 
      632 	go to get_next_line;
      633 
      634 CONTROL (11):					/* &print						*/
      635 	call ioa_$nnl (substr (RS, min (RS_pos + 1, RS_len)));
      636 	go to get_next_line;
      637 
      638 CONTROL (12):					/* &quit						*/
      639 	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&quit"".");
      640 
      641 	go to END_OF_FILE;
      642 
      643 CONTROL (15):					/* &return					*/
      644 	if RS_pos = RS_len then RS_pos = RS_pos - 1;	/* Newline at end of null return string is not white space	*/
      645 
      646 	RS_ptr = addr (substr (RS, RS_pos + 1));	/* Adjust RS to only be argument of statement		*/
      647 	RS_len = RS_len - RS_pos;
      648 
      649 	if functionp ()
      650 	then do;
      651 		RS_len = RS_len - 1;		/* Don't return newline at end for active function	*/
      652 		if RS_len > ec_data.return_len
      653 		then call warning (error_table_$command_line_overflow,
      654 			"Expanded value length of ^d characters exceeds return argument length of ^d characters.",
      655 			RS_len, ec_data.return_len);
      656 		return_arg = RS;
      657 	     end;
      658 	else call iox_$put_chars (iox_$user_output, RS_ptr, RS_len, status);
      659 
      660 	go to END_OF_FILE;
      661 
      662 CONTROL (17):
      663 	call error (0, "The ""&version"" statement may only be the first line of the program.");
      664 
      665 CONTROL (1):					/* &attach					*/
      666 	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&attach"".");
      667 
      668 	if ec_data_ptr ^= null () & ^attachedp ()
      669 	then do;
      670 		call abs_io_control$attach (abs_data_ptr, null (), status);
      671 		if status ^= 0 then call error (status, "Error while performing ""&attach"".");
      672 	     end;
      673 
      674 	go to get_next_line;
      675 
      676 CONTROL (5):					/* &detach					*/
      677 	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&detach"".");
      678 
      679 	input_string.position = input_string.position + CL_len;
      680 						/* Adjust position in case call to reset_input fails	*/
      681 	CL_len = 0;				/* Make sure that it isn't adjusted twice if it doesn't	*/
      682 
      683 	call reset_input ();			/* Do &detach, call get_line for saved switch if input line */
      684 
      685 	go to get_next_line;
      686 
      687 reset_input:
      688      procedure ();
      689 
      690 	if attachedp ()
      691 	then do;
      692 		call abs_io_control$detach (abs_data_ptr, null (), status);
      693 		if status ^= 0 then call error (status, "Error while performing ""&detach"".");
      694 		if input_linep ()
      695 		then do;
      696 			call iox_$get_line (iox_$user_input, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);
      697 			go to EGRESS;
      698 		     end;
      699 	     end;
      700 
      701 	return;
      702      end;
      703 
      704 CONTROL (13):					/* &ready						*/
      705 	string (ready_mode) = ""b;
      706 	ready_mode.flag = trace_mode ();
      707 
      708 	if ec_data_ptr ^= null ()
      709 	then if codeptr (ec_data.set_ready_mode) ^= null ()
      710 	     then call ec_data.set_ready_mode (ready_mode);
      711 	     else call cu_$set_ready_mode (ready_mode);
      712 	else call cu_$set_ready_mode (ready_mode);
      713 
      714 	go to get_next_line;
      715 
      716 CONTROL (14):					/* &ready_proc					*/
      717 	test = trace_mode ();
      718 	if ec_data_ptr ^= null () then ec_data.call_ready_proc = test;
      719 	go to get_next_line;
      720 
      721 trace_mode:
      722      procedure () returns (bit (1) aligned);
      723 
      724 	if RS_len = RS_pos
      725 	then do;
      726 		call warning (0, "Missing keyword in mode statement.  ""on"" assumed.");
      727 		return ("1"b);
      728 	     end;
      729 
      730 	RS_len = length (rtrim (RS, WHITE));
      731 
      732 	if substr (RS, RS_pos + 1) = "on" | substr (RS, RS_pos + 1) = "true" then return ("1"b);
      733 	if substr (RS, RS_pos + 1) = "off" | substr (RS, RS_pos + 1) = "false" then return ("0"b);
      734 	call warning (0, "Illegal keyword in mode statement.  ""on"" assumed.");
      735 
      736 	return ("1"b);
      737      end;
      738 
      739 CONTROL (2):					/* &command_line					*/
      740 	call trace_control (abs_data.command_line);
      741 	go to get_next_line;
      742 
      743 CONTROL (3):					/* &comment_line					*/
      744 	call trace_control (abs_data.comment_line);
      745 	go to get_next_line;
      746 
      747 CONTROL (4):					/* &control_line					*/
      748 	call trace_control (abs_data.control_line);
      749 	go to get_next_line;
      750 
      751 CONTROL (9):					/* &input_line					*/
      752 	call trace_control (abs_data.input_line);
      753 	go to get_next_line;
      754 
      755 trace_control:
      756      procedure (trace_structure);
      757 
      758 declare	1 trace_structure		aligned like abs_data.command_line;
      759 
      760 	if RS_len = RS_pos
      761 	then do;
      762 		call warning (0, "Missing keyword in tracing statement.  ""on"" assumed.");
      763 		trace_structure.on = "1"b;
      764 		return;
      765 	     end;
      766 
      767 	len = search (substr (RS, RS_pos + 2), WHITE);	/* Find end of keyword				*/
      768 	RS_len = length (rtrim (RS, WHITE));		/* Find end of tokens on line				*/
      769 
      770 	if substr (RS, RS_pos + 1) = "on" | substr (RS, RS_pos + 1) = "true" then trace_structure.on = "1"b;
      771 	else if substr (RS, RS_pos + 1) = "off" | substr (RS, RS_pos + 1) = "false" then trace_structure.on = "0"b;
      772 	else if substr (RS, RS_pos + 1, len) = "output_switch" | substr (RS, RS_pos + 1, len) = "osw"
      773 	then if RS_pos + len >= RS_len
      774 	     then trace_structure.iocb = null ();
      775 	     else do;
      776 		     RS_pos = RS_pos + len + verify (substr (RS, RS_pos + len + 2), WHITE);
      777 		     call iox_$find_iocb (substr (RS, RS_pos + 1), trace_structure.iocb, status);
      778 		     if status ^= 0 then call error (status, "Finding stream ""^a"".", substr (RS, RS_pos + 1));
      779 		end;
      780 	else do;
      781 		call warning (0, "Invalid keyword in tracing statement.  ""on"" assumed.");
      782 		trace_structure.on = "1"b;
      783 	     end;
      784 
      785 	return;
      786 
      787      end trace_control;
      788 
      789 trace_output:
      790      procedure (trace_structure, line);
      791 
      792 declare	1 trace_structure		aligned like abs_data.command_line,
      793 	line			char (*);
      794 
      795 declare	switch			ptr;
      796 
      797 	do while (trace_structure.on);		/* Do this only if tracing is enabled.			*/
      798 	     if trace_structure.iocb = null ()
      799 	     then switch = iox_$user_output;		/* Default					*/
      800 	     else switch = trace_structure.iocb;
      801 
      802 	     call iox_$put_chars (switch, addr (line), length (line), status);
      803 	     if status = 0 then return;		/* Exit if line successfully traced			*/
      804 
      805 	     call signal_io_error_ ("Unable to do trace output.  Correct I/O attachments and type ""start"".", switch,
      806 		status);
      807 
      808 	     call get_ptrs (UPDATE);			/* Make sure user didn't do too good a job of "correction"	*/
      809 	end;
      810 
      811 	return;
      812 
      813      end trace_output;
      814 
      815 /* This procedure copies parameters and gets pointers to our databases.  It is called when abs_io_v1_get_line is
      816*   entered and after calling signal_io_error_ to make sure that nothing has changed that we care about.		*/
      817 
      818 get_ptrs:
      819      procedure (update);
      820 
      821 declare	update			bit (1) aligned;
      822 
      823 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      824 
      825 	if update
      826 	then do;
      827 		do while (abs_data_ptr ^= iocb_ptr -> iocb.attach_data_ptr);
      828 		     call signal_io_error_ ("Attachment of " || abs_data.io_module_name || " has been moved.",
      829 			P_iocb_ptr, 0);
      830 		     iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      831 		end;
      832 		return;
      833 	     end;
      834 
      835 	abs_data_ptr = iocb_ptr -> iocb.attach_data_ptr;
      836 	ec_data_ptr = abs_data.ec_data_ptr;
      837 	buffer_ptr = P_buffer_ptr;
      838 	buffer_len = P_buffer_len;
      839 
      840 	return;
      841 
      842      end get_ptrs;
      843 
      844 CONTROL (8):					/* &if						*/
      845 	start = find_clause ("&then");
      846 
      847 	if RS_len = RS_pos | start = RS_pos then call error (0, "Missing conditional in ""&if"" statement.");
      848 
      849 	if start >= 0
      850 	then do;
      851 		old_RS_len = RS_len;		/* Save for locating &then clause			*/
      852 		RS_len = start;			/* Delay assignment for benefit of error message routine.	*/
      853 	     end;
      854 
      855 	RS_len = length (rtrim (RS, WHITE));
      856 
      857 	abs_data.nest_level = abs_data.nest_level + 1;
      858 
      859 	if state = NORMAL
      860 	then do;
      861 		call trace_output (abs_data.control_line, RS);
      862 		call trace_output (abs_data.control_line, NL);
      863 		abs_data.expected_nest_level = abs_data.nest_level;
      864 		if ^conditional () then state = SKIPPING_CLAUSE;
      865 	     end;
      866 
      867 	if start < 0
      868 	then do;
      869 		saved_state = state;
      870 		state = MUST_BE_THEN;
      871 		go to EXPAND_NEXT_LINE;		/* Go direct, don't mess around. This state is indivisible	*/
      872 	     end;
      873 
      874 	RS_ptr = addr (substr (RS, start + 1));
      875 	RS_len = old_RS_len - start;
      876 
      877 	RS_pos = verify (substr (RS, 6), WHITE) + 4;	/* Find beginning of clause beyond "&then"		*/
      878 	if RS_pos = 4 then RS_pos = RS_len;
      879 
      880 CONTINUE_THEN:
      881 	if abs_data.else_clause_len <= 0
      882 	then do;					/* maybe we even have the &else			*/
      883 		start = find_clause ("&else");
      884 		if start >= 0
      885 		then do;				/* We do. Copy the whole line into an allocated buffer	*/
      886 			if ^not_in_CL | ^buffer_allocated then call allocate_buffer (RS_len);
      887 			abs_data.else_clause_len = RS_len - start;
      888 			abs_data.else_clause_ptr = addr (substr (RS, start + 1));
      889 			RS_len = length (rtrim (substr (RS, 1, start), WHITE)) + 1;
      890 			substr (RS, RS_len, 1) = NL;	/* Break the line.  We'll get rest of the line next time	*/
      891 			get_next_line = GET_PENDING_ELSE_CLAUSE;
      892 		     end;
      893 	     end;
      894 
      895 	if RS_pos >= RS_len then RS_pos = RS_len - 1;	/* Newline at end of null line is not white space		*/
      896 
      897 	RS_ptr = addr (substr (RS, RS_pos + 1));	/* Step over &then or &else and following whitespace	*/
      898 	RS_len = RS_len - RS_pos;
      899 
      900 	if state = NORMAL
      901 	then do;					/* This clause will be executed.  First, we trace ourself.	*/
      902 		if control = THEN
      903 		then call trace_output (abs_data.control_line, TRACE_THEN);
      904 		else call trace_output (abs_data.control_line, TRACE_ELSE);
      905 
      906 		abs_data.expected_nest_level = 0;	/* After taking this clause we skip until back at top level */
      907 
      908 		if abs_data.else_clause_len = 0 & abs_data.nest_level > 0
      909 		then get_next_line = ENTER_SKIPPING_CLAUSE_STATE;
      910 	     end;					/* Arrange to set state to skipping after taking clause	*/
      911 
      912 	scanning_clause = "1"b;			/* Comments and labels are forbidden in clauses		*/
      913 
      914 	go to CHECK_CONTROL;			/* Prepare to execute clause				*/
      915 
      916 STATE (3):					/* MUST_BE_THEN					*/
      917 	if control = COMMENT then go to get_next_line;	/* comments are allowed between &if and &else statements	*/
      918 
      919 	if control ^= THEN then call error (0, "Missing ""&then"" keyword following ""&if"" statement.");
      920 
      921 	state = saved_state;			/* pop state saved in &if (NORMAL or SKIPPING_CLAUSE)	*/
      922 
      923 	go to CONTINUE_THEN;
      924 
      925 CONTROL (16):					/* &then:  this can't be reached by a legitimate clause	*/
      926 	call error (0, "Unexpected ""&then"" statement.");
      927 
      928 CONTINUE_WITH_PENDING_ELSE_CLAUSE:
      929 	buffer_allocated = "1"b;			/* We have just reentered, so initialize--this must be	*/
      930 	CL_len = 0;				/* We haven't done any expansion this time, so don't skip	*/
      931 	not_in_CL = "1"b;				/* in an allocated buffer, not in the input file		*/
      932 
      933 GET_PENDING_ELSE_CLAUSE:
      934 	RS_len = abs_data.else_clause_len;		/* Set RS to pending &else clause in allocated buffer	*/
      935 	RS_ptr = abs_data.else_clause_ptr;
      936 	abs_data.else_clause_len = 0;			/* Unmark pending &else clause storage			*/
      937 
      938 	RS_pos = verify (substr (RS, 6), WHITE) + 4;	/* Set RS_pos as if we came from CHECK_CONTROL		*/
      939 	if RS_pos = 4 then RS_pos = RS_len;		/* Locate it at first non-white char or at end of line	*/
      940 
      941 	get_next_line = EXPAND_NEXT_LINE;		/* Reset this since we don't want to come back here	*/
      942 
      943 	control = ELSE;				/* This is the only kind of statement that is ever pending	*/
      944 
      945 CONTROL (6):					/* &else						*/
      946 	if abs_data.nest_level <= 0 then call error (0, "Unexpected ""&else"" statement.");
      947 
      948 	abs_data.nest_level = abs_data.nest_level - 1;	/* Implement nesting here				*/
      949 	if abs_data.nest_level < abs_data.expected_nest_level
      950 	then state = NORMAL;
      951 	else state = SKIPPING_CLAUSE;
      952 
      953 	go to CONTINUE_THEN;
      954 
      955 STATE (4):					/* SKIPPING_CLAUSE					*/
      956 	if ^scanning_clause
      957 	then if control = ELSE | control = COMMENT
      958 	     then go to CONTROL (control);		/* &else or comments are part of nested compound statement	*/
      959 	     else do;				/* anything else ends compound statement		*/
      960 		     scanning_clause = "0"b;		/* comments and &labels are legal again			*/
      961 		     state = NORMAL;		/* nested statement must end here			*/
      962 		     abs_data.nest_level = 0;		/* so reset back to top level				*/
      963 		     go to STATE (NORMAL);
      964 		end;
      965 
      966 	if SKIPABLE (control)
      967 	then go to get_next_line;
      968 	else go to CONTROL (control);
      969 
      970 ENTER_SKIPPING_CLAUSE_STATE:
      971 	state = SKIPPING_CLAUSE;			/* We have taken a clause, so we skip rest of if statement	*/
      972 
      973 	get_next_line = EXPAND_NEXT_LINE;		/* Reset this, we don't need to come here again		*/
      974 
      975 	go to EXPAND_NEXT_LINE;
      976 
      977 /* This function is called from &if to find &then and from &then or &else to find an &else which follows on the same
      978*   line.  The contract of the function is to return the length of the string preceding the keyword, which must be
      979*   delimited on BOTH sides by whitespace.  If it is followed by a newline, that is considered whitespace.  If the
      980*   clause is not found, the -1 is returned.								*/
      981 
      982 find_clause:
      983      procedure (keyword) returns (fixed bin (21));
      984 
      985 declare	keyword			char (*),
      986 	keyword_pos		fixed bin (21),
      987 	start_keyword		fixed bin (21);
      988 
      989 	keyword_pos = RS_pos;			/* start with first unidentified character		*/
      990 
      991 	start_keyword = index (substr (RS, RS_pos + 1), keyword) - 1;
      992 
      993 	if start_keyword < 0 then return (-1);
      994 
      995 	keyword_pos = RS_pos + start_keyword;
      996 
      997 	if index (WHITE, substr (RS, keyword_pos + length (keyword) + 1, 1)) - 1 < 0
      998 	     | index (WHITE, substr (RS, keyword_pos, 1)) - 1 < 0
      999 	then call warning (0, "Whitespace must surround the ""^a"" keyword.", keyword);
     1000 
     1001 	return (keyword_pos);
     1002 
     1003      end find_clause;
     1004 
     1005 
     1006 /* This procedure implements knowledge of the syntax of &if conditionals (except for detection of missing conditionals,
     1007*   which is done in &if).  The forms accepted are "true", "false", "[...]", "|[...]", and "||[...]".  The forms
     1008*   containing brackets are evaluated by calling cu_$evaluate_active_string with the string contained between them.  A
     1009*   zero error code must be returned, and the returned value must be either "true" or "false".			*/
     1010 
     1011 conditional:
     1012      procedure () returns (bit (1) aligned);
     1013 
     1014 declare	AF_len			fixed bin (21),
     1015 	AF_ptr			ptr,
     1016 	AF			char (AF_len) based (AF_ptr),
     1017 	bars_len			fixed bin,
     1018 	value			char (8) varying;
     1019 
     1020 	if substr (RS, RS_pos + 1) = "true" then return ("1"b);
     1021 
     1022 	if substr (RS, RS_pos + 1) = "false" then return ("0"b);
     1023 
     1024 	if substr (RS, RS_pos + 1, 1) = "|"
     1025 	then if substr (RS, RS_pos + 2, 1) = "|"
     1026 	     then bars_len = 2;
     1027 	     else bars_len = 1;
     1028 	else bars_len = 0;
     1029 
     1030 	if substr (RS, RS_pos + bars_len + 1, 1) ^= "[" | substr (RS, RS_len) ^= "]"
     1031 	then call error (0, "Malformed conditional in ""&if"" statement.");
     1032 
     1033 	AF_ptr = addr (substr (RS, RS_pos + bars_len + 2));
     1034 	AF_len = RS_len - RS_pos - bars_len - 2;	/* do not pass brackets surrounding if expression		*/
     1035 
     1036 	if ec_data_ptr ^= null ()
     1037 	then if codeptr (ec_data.eval_string) ^= null ()
     1038 	     then call ec_data.eval_string (null (), AF, (bars_len + 1), value, status);
     1039 	     else call cu_$evaluate_active_string (null (), AF, (bars_len + 1), value, status);
     1040 	else call cu_$evaluate_active_string (null (), AF, (bars_len + 1), value, status);
     1041 
     1042 	if status ^= 0 then call error (status, "Evaluating ""&if"" clause.");
     1043 
     1044 	if value = "true" then return ("1"b);
     1045 
     1046 	if value = "false" then return ("0"b);
     1047 
     1048 	call error (0, "Illegal value ""^a"" returned by active function.", value);
     1049 
     1050      end conditional;
     1051 
     1052 /* This utility predicate knows how to determine if some switch is &attached.  It has been designed to be easily
     1053*   extended to other cases than the usual &attach in exec_com using the io_call command or iox_$control		*/
     1054 
     1055 attachedp:
     1056      procedure () returns (bit (1) aligned);
     1057 
     1058 	return (abs_data.attach.target_ptr ^= null ());
     1059 
     1060      end attachedp;
     1061 
     1062 /* This utility predicate knows how to determine if the current line is an input line				*/
     1063 
     1064 input_linep:
     1065      procedure () returns (bit (1) aligned);
     1066 
     1067 	if ec_data_ptr = null () then return ("0"b);	/* Can't be input unless someone tells us so		*/
     1068 
     1069 	return (ec_data.input_line);
     1070 
     1071      end input_linep;
     1072 
     1073 /* This utility predicate knows how to tell if we were invoked as an active function				*/
     1074 
     1075 functionp:
     1076      procedure () returns (bit (1) aligned);
     1077 
     1078 	if ec_data_ptr = null ()
     1079 	then return ("0"b);				/* Can't return a value if we don't have a place to put it	*/
     1080 	else return (ec_data.active_function);
     1081 
     1082      end functionp;
     1083 
     1084 emit_ec_name:
     1085      procedure ();					/* &ec_name:  The entryname of the input file, sans suffix	*/
     1086 
     1087 	call copy_up_to_ampersand (7);
     1088 	call copy_string (ec_name, QUOTE);
     1089 
     1090      end emit_ec_name;
     1091 
     1092 emit_ec_dir:
     1093      procedure ();					/* &ec_dir:  The dir containing the input file		*/
     1094 						/* This is used to simulate referencing_dir		*/
     1095 declare	ec_dir_buf		char (168),
     1096 	ec_dir_len		fixed bin,
     1097 	ec_dir			char (ec_dir_len) based (addr (ec_dir_buf));
     1098 
     1099 	call copy_up_to_ampersand (6);
     1100 	call hcs_$fs_get_path_name (input_string.ptr, ec_dir_buf, ec_dir_len, (""), (0));
     1101 	call copy_string (ec_dir, QUOTE);
     1102 
     1103      end emit_ec_dir;
     1104 
     1105 emit_ec_switch:
     1106      procedure ();					/* &ec_switch:  The I/O switch to read input lines from	*/
     1107 
     1108 declare	ec_switch			char (ec_switch_len) based,
     1109 	ec_switch_len		fixed bin;
     1110 
     1111 	call copy_up_to_ampersand (9);
     1112 	if ec_data_ptr = null ()
     1113 	then do;
     1114 		ec_switch_len = length (rtrim (iocb_ptr -> iocb.name));
     1115 		call copy_string (addr (iocb_ptr -> iocb.name) -> ec_switch, QUOTE);
     1116 	     end;
     1117 	else do;
     1118 		ec_switch_len = length (rtrim (ec_data.switch_ptr -> iocb.name));
     1119 		call copy_string (addr (ec_data.switch_ptr -> iocb.name) -> ec_switch, QUOTE);
     1120 	     end;
     1121 
     1122      end emit_ec_switch;
     1123 
     1124 emit_arg_count:
     1125      procedure ();
     1126 
     1127 declare	arg_count_pic		picture "zzzzzzzz9",
     1128 	arg_count_len		fixed bin,
     1129 	arg_count			char (arg_count_len) based (addr (substr (arg_count_pic, 10 - arg_count_len)));
     1130 
     1131 	call copy_up_to_ampersand (1);
     1132 	arg_count_pic = abs_data.arg_count;
     1133 	arg_count_len = length (ltrim (arg_count_pic));
     1134 	call copy_string (arg_count, NONE);
     1135 
     1136      end emit_arg_count;
     1137 
     1138 predicate:
     1139      procedure (test, width);
     1140 
     1141 declare	test			bit (1) aligned,
     1142 	width			fixed bin;
     1143 
     1144 	call copy_up_to_ampersand (width);
     1145 	if test
     1146 	then call copy_string (TRUE, NONE);
     1147 	else call copy_string (FALSE, NONE);
     1148 
     1149 	return;
     1150 
     1151      end predicate;
     1152 
     1153 copy_up_to_ampersand:
     1154      procedure (width);
     1155 
     1156 declare	width			fixed bin;
     1157 
     1158 	len = CL_pos - old_CL_pos;
     1159 	if len > 0
     1160 	then do;
     1161 		call check_len (len);
     1162 		substr (RS, RS_len - len + 1, len) = substr (CL, old_CL_pos + 1, len);
     1163 	     end;
     1164 
     1165 	CL_pos = CL_pos + width;
     1166 	old_CL_pos = CL_pos + 1;
     1167 
     1168 	not_in_CL = "1"b;				/* Make sure that we know some expansion was encountered	*/
     1169 
     1170 	return;
     1171 
     1172      end copy_up_to_ampersand;
     1173 
     1174 copy_string:
     1175      procedure (arg_string, quote_modifier);
     1176 
     1177 declare	arg_string		char (*),
     1178 	quote_modifier		fixed bin;
     1179 
     1180 declare	(arg_pos, quote_pos, quote_len)
     1181 				fixed bin (21);
     1182 
     1183 	if quote_modifier = NONE
     1184 	then do;
     1185 		call check_len (length (arg_string));
     1186 		substr (RS, RS_len - length (arg_string) + 1) = arg_string;
     1187 		return;
     1188 	     end;
     1189 
     1190 	arg_pos = 0;
     1191 
     1192 QLOOP:
     1193 	quote_len = index (substr (RS, old_RS_len + 1), """") - 1;
     1194 	if quote_len >= 0
     1195 	then do;
     1196 		old_RS_len = old_RS_len + quote_len;
     1197 		quote_len = verify (substr (RS, old_RS_len + 1), """") - 1;
     1198 		if quote_len < 0 then quote_len = RS_len - old_RS_len;
     1199 		old_RS_len = old_RS_len + quote_len;
     1200 		if mod (quote_len, twoL) = 0
     1201 		then do while (mod (quote_len, 2 * twoL) ^= 0);
     1202 			quote_len = quote_len - twoL;
     1203 			twoL = 2 * twoL;
     1204 		     end;
     1205 		else do while (quote_len ^= 0);
     1206 			twoL = divide (twoL, 2, 17, 0);
     1207 			quote_len = mod (quote_len, twoL);
     1208 		     end;
     1209 		go to QLOOP;
     1210 	     end;
     1211 	else old_RS_len = RS_len;
     1212 
     1213 	if quote_modifier = REQUOTE
     1214 	then do;					/* insert quotes if requoting				*/
     1215 		call check_len (twoL);
     1216 		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
     1217 		twoL = 2 * twoL;			/* increase quote depth by one			*/
     1218 	     end;
     1219 
     1220 DBL_LOOP:
     1221 	quote_pos = index (substr (arg_string, arg_pos + 1), """") - 1;
     1222 	if quote_pos >= 0
     1223 	then do;
     1224 		call check_len (quote_pos);
     1225 		substr (RS, RS_len - quote_pos + 1, quote_pos) = substr (arg_string, arg_pos + 1, quote_pos);
     1226 		arg_pos = arg_pos + quote_pos + 1;
     1227 		call check_len (twoL);
     1228 		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
     1229 		if arg_pos < length (arg_string)
     1230 		then go to DBL_LOOP;
     1231 		else go to APPEND;
     1232 	     end;
     1233 
     1234 	quote_pos = length (arg_string) - arg_pos;
     1235 	if quote_pos > 0
     1236 	then do;					/* something after last quote in arg			*/
     1237 		call check_len (quote_pos);
     1238 		substr (RS, RS_len - quote_pos + 1, quote_pos) = substr (arg_string, arg_pos + 1, quote_pos);
     1239 	     end;
     1240 
     1241 APPEND:
     1242 	if quote_modifier = REQUOTE
     1243 	then do;					/* append quotes if requoting				*/
     1244 		twoL = divide (twoL, 2, 17, 0);
     1245 		call check_len (twoL);
     1246 		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
     1247 	     end;
     1248 	old_RS_len = RS_len;
     1249 
     1250 	return;
     1251 
     1252      end copy_string;
     1253 
     1254 check_len:
     1255      proc (len);					/* routine to make sure we don't overflow input buffer	*/
     1256 
     1257 declare	len			fixed bin (21),
     1258 	new_RS_len		fixed bin (21);
     1259 
     1260 	new_RS_len = RS_len + len;
     1261 
     1262 	if new_RS_len > buffer_len then call allocate_buffer (new_RS_len);
     1263 
     1264 	RS_len = new_RS_len;
     1265 
     1266 	return;
     1267 
     1268      end check_len;
     1269 
     1270 allocate_buffer:
     1271      procedure (required_len);
     1272 
     1273 declare	required_len		fixed bin (21),
     1274 	new_RS_ptr		ptr,
     1275 	new_RS			char (buffer_len) based (new_RS_ptr);
     1276 
     1277 	not_in_CL = "1"b;				/* RS will not be eq to CL after this			*/
     1278 	buffer_allocated = "1"b;
     1279 
     1280 	if abs_data.allocated_chars_ptr ^= null ()
     1281 	then if required_len <= abs_data.allocated_chars_len
     1282 	     then do;				/* Reuse allocated buffer if possible			*/
     1283 		     abs_data.allocated_chars_ptr -> RS = RS;
     1284 		     buffer_ptr, RS_ptr = abs_data.allocated_chars_ptr;
     1285 		     return;
     1286 		end;
     1287 
     1288 	buffer_len = divide (16 * required_len + 15, 8, 21, 0);
     1289 	if buffer_len > 1044320
     1290 	then if required_len > 1044320
     1291 	     then call error (0, "Expanded line exceeds implementation restriction of 1044320 characters in length.");
     1292 	     else buffer_len = 1044320;		/* Biggest string that can fit in an extensible area	*/
     1293 
     1294 	on area call error (error_table_$noalloc, "Allocating buffer (^d words).", required_len);
     1295 
     1296 	allocate new_RS in (abs_data.work_area);
     1297 
     1298 	revert area;
     1299 
     1300 	new_RS_ptr -> RS = RS;
     1301 
     1302 	if abs_data.allocated_chars_ptr ^= null () then free allocated_chars;
     1303 
     1304 	abs_data.allocated_chars_ptr, buffer_ptr, RS_ptr = new_RS_ptr;
     1305 	abs_data.allocated_chars_len = buffer_len;
     1306 
     1307 	return;
     1308 
     1309      end allocate_buffer;
     1310 
     1311 allocate_hash_table:
     1312      procedure ();
     1313 
     1314 	on area call error (error_table_$noalloc, "Allocating label hash table.");
     1315 
     1316 	allocate hash_table set (abs_data.labels_ptr) in (abs_data.work_area);
     1317 
     1318 	revert area;
     1319 
     1320      end allocate_hash_table;
     1321 
     1322 error:
     1323      procedure () options (variable);
     1324 
     1325 declare	complain			entry () variable options (variable),
     1326 	line_len			fixed bin (21),
     1327 	line_number		fixed bin (21),
     1328 	line_ptr			ptr,
     1329 	line_start		fixed bin (21),
     1330 	line			char (line_len) based (line_ptr),
     1331 	message			char (256),
     1332 	severity			bit (1),
     1333 	status_ptr		ptr,
     1334 	status			fixed bin (25) based (status_ptr),
     1335 	who			char (72) varying;
     1336 
     1337 	severity = "1"b;
     1338 	go to ERROR_COMMON;
     1339 
     1340 warning:
     1341      entry options (variable);
     1342 
     1343 	severity = "0"b;
     1344 
     1345 ERROR_COMMON:
     1346 	call cu_$arg_ptr (1, status_ptr, (0), (0));
     1347 	call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, message, (0), "1"b, "0"b);
     1348 
     1349 	line_number = 0;
     1350 	do line_start = 0 repeat (line_start + line_len + 1)
     1351 	     while ((line_start <= input_string.position) & (line_start < input_string.len));
     1352 
     1353 	     line_len = index (substr (IS, line_start + 1), NL) - 1;
     1354 	     if line_len < 0 then line_len = input_string.len - line_start;
     1355 	     line_number = line_number + 1;
     1356 	     line_ptr = addr (substr (IS, line_start + 1));
     1357 	end;
     1358 
     1359 	if ec_data_ptr = null ()
     1360 	then do;
     1361 		complain = com_err_;
     1362 		who = rtrim (abs_data.io_module_name);
     1363 	     end;
     1364 	else do;
     1365 		if codeptr (ec_data.error) = null () then
     1366 		     if ec_data.active_function
     1367 		     then complain = active_fnc_err_;
     1368 		     else complain = com_err_;
     1369 		else complain = ec_data.error;
     1370 		who = ec_data.who_am_i;
     1371 	     end;
     1372 
     1373 	call complain (status, who, "^[^/^]^[Error^;Warning^] on line #^d of ^a:^/^a^/SOURCE:^-^a", status ^= 0,
     1374 	     severity, line_number, ec_path, message, line);
     1375 
     1376 	if ^severity then return;
     1377 
     1378 	if abs_data.noabort then do;
     1379 	     get_next_line = EXPAND_NEXT_LINE;
     1380 	     go to get_next_line;
     1381 	end;
     1382 
     1383 	state = NORMAL;				/* Prevent looping if state is a MUST_BE state.		*/
     1384 
     1385 	go to END_OF_FILE;
     1386 
     1387      end error;
     1388 
  1     1 /*  START OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-02-20,Parisek), approve(87-07-23,MCR7716),
  1     6*     audit(87-07-30,Fawcett), install(87-08-11,MR12.1-1080):
  1     7*     Added the noabort flag for determining whether or not to abort after
  1     8*     exec_com error occurs.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Initial coding: 25 June 79 by J. Spencer Love */
  1    13 /* login_channel option flag BIM 11/81 */
  1    14 /* Added this_action and next_action 04/20/82 S. Herbst */
  1    15 /* Added on_info, goto_statement_(pos len) 01/06/83 S. Herbst */
  1    16 /* Added output_file.turn_off_ssw 05/16/83 S. Herbst */
  1    17 /* Added attach.trim_whitespace_sw 06/02/83 S. Herbst */
  1    18 /* Added listener_pl1_label and get_line_pl1_label 11/17/83 S. Herbst */
  1    19 /* Added (command comment control input)_line.by_control_arg 03/20/84 S. Herbst */
  1    20 
  1    21 declare	abs_data_ptr		ptr;
  1    22 
  1    23 declare	1 abs_data		aligned based (abs_data_ptr),
  1    24 	  2 version		fixed bin,	/* Version = 1					*/
  1    25 	  2 io_module_name		char (32) varying,	/* either "abs_io_" or "ec_input_"			*/
  1    26 	  2 open_description	char (24) varying,	/* either "stream_input" or "stream_input_output"		*/
  1    27 	  2 unique_name		char (15) varying,	/* &! -- either blank or 15 char unique string		*/
  1    28 						/*						*/
  1    29 	  2 ec_data_ptr		ptr,		/* -> communication area for exec_com			*/
  1    30 	  2 expand_data_ptr		ptr,		/* -> structure for abs_io_expand_			*/
  1    31 						/*						*/
  1    32 	  2 instance_chain,				/* two way linked chain of abs_data blocks for debugging	*/
  1    33 	    3 prev_ptr		ptr,		/* -> next older abs_data instance			*/
  1    34 	    3 next_ptr		ptr,		/* -> next newer abs_data instance			*/
  1    35 	    3 level		fixed bin,	/* level of ec invocation in chain for debugging		*/
  1    36 	    3 pad			bit (36),		/*						*/
  1    37 						/*						*/
  1    38 	  2 arg_info,				/*						*/
  1    39 	    3 ec_path_ptr		ptr,		/* Ptr to allocated &ec_path string			*/
  1    40 	    3 ec_path_len		fixed bin (21),	/* Length of allocated &ec_path (&0) string		*/
  1    41 	    3 ec_path_quotes	fixed bin (21),	/* Number of quote chars in &ec_path, -1 if not yet counted */
  1    42 	    3 ec_name_ptr		ptr,		/* Ptr to allocated &ec_name string			*/
  1    43 	    3 ec_name_len		fixed bin (21),	/* Length of allocated &ec_name string			*/
  1    44 	    3 ec_name_quotes	fixed bin (21),	/* Number of quote chars in &ec_name, -1 if not yet counted */
  1    45 	    3 arg_ptr		ptr,		/* pointer to allocated structure containing args		*/
  1    46 	    3 arg_count		fixed bin,	/* number of arguments passed				*/
  1    47 	    3 args_copied		bit (1),		/* 1 indicates arguments were copied into work_area	*/
  1    48 	    3 default_arg_ptr	ptr,		/* pointer to allocated &default args			*/
  1    49 	    3 default_arg_count	fixed bin,	/* number of &default args				*/
  1    50 	    3 pad			bit (36),		/*						*/
  1    51 						/*						*/
  1    52 	  2 input_string,				/* data about input segment or archive component		*/
  1    53 	    3 ptr			ptr,		/* pointer to input file				*/
  1    54 	    3 len			fixed bin (21),	/* number of characters in input file			*/
  1    55 	    3 start		fixed bin (21),	/* initial value for input_pos, set beyond &version, if any */
  1    56 	    3 position		fixed bin (21),	/* current index into input file			*/
  1    57 	    3 limit		fixed bin (21),	/* farthest point yet reached...begin &label search here	*/
  1    58 						/*						*/
  1    59 	  2 open_data,				/* data saved at attach time for open time		*/
  1    60 	    3 output_dir		char (168) unal,	/* directory pathname of output file (if specified)	*/
  1    61 	    3 output_entry		char (32) unal,	/* entryname of output file (if specified)		*/
  1    62 	    3 parser_version	fixed bin,	/* indicates version of parser (get_line) for open	*/
  1    63 	    3 si			bit (1) unal,	/* 1 indicates opening for stream_input permitted		*/
  1    64 	    3 sio			bit (1) unal,	/* 1 indicates opening for stream_input_output permitted	*/
  1    65 	    3 ssf			bit (1) unal,	/* 1 indicates output file cannot be MSF		*/
  1    66 	    3 truncate		bit (1) unal,	/* 1 indicates output file truncated at open		*/
  1    67 	    3 no_set_bc		bit (1) unal,	/* 1 to set absout bitcount only at close		  */
  1    68 	    3 login_channel		bit (1) unal,       /* 1 to fish arguments from PIT */
  1    69 	    3 pad			bit (30) unal,	/* 						*/
  1    70 						/*						*/
  1    71 	  2 output_file,				/* data for abs_io_put_chars				*/
  1    72 	    3 fcb_ptr		ptr,		/* -> File Control Block for msf_manager_, null if SSF	*/
  1    73 	    3 seg_ptr		ptr,		/* -> base of current component of output file		*/
  1    74 	    3 current_len		fixed bin (21),	/* number of characters in current component		*/
  1    75 	    3 max_len		fixed bin (21),	/* max number of characters in a component		*/
  1    76 	    3 MSF_seg_idx		fixed bin,	/* index of current MSF component. Used to get new ones	*/
  1    77 	    3 switches		aligned,
  1    78 	     4 may_be_MSF		bit (1) unaligned,	/* 1 indicates absout can become an MSF		*/
  1    79 	     4 turn_off_ssw		bit (1) unaligned,	/* 1 means safety switch of absout was off originally	*/
  1    80 	     4 mbz		bit (34) unaligned,
  1    81 						/*						*/
  1    82 	  2 command_line,				/* substructure dealing with tracing command lines	*/
  1    83 	    3 by_control_arg	bit (1) unaligned,	/* 1 if trace modes specified by ec control arg		*/
  1    84 	    3 on			bit (1) unaligned,	/* 1 to print tracing information			*/
  1    85 	    3 expand		fixed bin (3) unal,	/* 1 to print unexpanded, 2 expanded, 3 all, 4 both	*/
  1    86 	    3 pad1		bit (66) unaligned,	/* pad to double word				*/
  1    87 	    3 iocb		ptr,		/* I/O switch to put trace out on			*/
  1    88 	    3 prefix		char (32) varying,	/* prefix for &trace tracing, eg. "COMMAND: "		*/
  1    89 	    3 pad2		bit (36),		/*						*/
  1    90 	  2 (comment_line,				/* for tracing comments..always unexpanded		*/
  1    91 	     control_line,				/* for tracing control lines				*/
  1    92 	     input_line)				/* for tracing input lines in &attach mode		*/
  1    93 				like abs_data.command_line,
  1    94 						/*						*/
  1    95 	  2 attach,				/*						*/
  1    96 	   3 victim_ptr		ptr,		/* -> IOCB affected by &attach (usually iox_$user_input	*/
  1    97 	   3 target_ptr		ptr,		/* -> IOCB &attached to (created by exec_com command)	*/
  1    98 	   3 save_ptr		ptr,		/* -> IOCB used to save previous victim_ptr -> IOCB	*/
  1    99 	   3 switches,
  1   100 	    4 trim_whitespace_sw	bit (1) unaligned,	/* OFF for &attach &trim off, ON by default		*/
  1   101               4 noabort                 bit (1) unaligned,	/* ON if continue after severity 1 error */
  1   102 	    4 pad			bit (34) unaligned,
  1   103 						/*						*/
  1   104 	  2 allocated_chars_ptr	ptr,		/* -> allocated buffer for freeing			*/
  1   105 	  2 chars_ptr		ptr,		/* -> characters in buffer waiting to be returned		*/
  1   106 	  2 else_clause_ptr		ptr,		/* -> characters in deferred else clause		*/
  1   107 	  2 allocated_chars_len	fixed bin (21),	/* total length of allocated buffer			*/
  1   108 	  2 chars_len		fixed bin (21),	/* characters left in buffer to be returned		*/
  1   109 	  2 else_clause_len		fixed bin (21),	/* length of deferred else clause			*/
  1   110 						/*						*/
  1   111 	  2 absentee		bit (1),		/* 1 indicates logout on &quit			*/
  1   112 	  2 quit			bit (1),		/* 1 indicates orderly exit, quit or return		*/
  1   113 						/*						*/
  1   114 	  2 active		bit (1),		/* 1 indicates get_line is busy, for recursion check	*/
  1   115 	  2 eof			bit (1),		/* 1 indicates &quit found or no more input		*/
  1   116 	  2 last_input_line_sw	bit (1),		/* previous line returned was an input line		*/
  1   117 	  2 label_search_sw		bit (1),		/* ON when searching for target of &goto		*/
  1   118 	  2 nest_level		fixed bin,	/* V1: depth of &if-&then-&else nesting			*/
  1   119 	  2 expected_nest_level	fixed bin,	/* V1: depth that must be reached to resume execution	*/
  1   120 						/*						*/
  1   121 	  2 goto_statement_pos	fixed bin (21),	/* position of last &goto stmt, for error msgs		*/
  1   122 	  2 goto_statement_len	fixed bin (21),	/* length of the &goto stmt				*/
  1   123 
  1   124 	  2 if_info aligned,			/* &if-&then-&else nesting info			*/
  1   125 	   3 if_sw		bit (1),		/* ON if inside an &if-&then-&else construct		*/
  1   126 	   3 true_sw		bit (1),		/* ON after "&if true"				*/
  1   127 	   3 got_then_sw		bit (1),		/* ON after the &then has been seen			*/
  1   128 	   3 got_else_sw		bit (1),		/* ON after the &else has been seen			*/
  1   129 	   3 clause_type		fixed bin,	/* previous &then or &else				*/
  1   130 	   3 skip_sw		bit (1),		/* ON if skipping a &then or &else clause		*/
  1   131 	   3 skip_block_level	fixed bin,	/* how many levels of &do we are inside while skipping	*/
  1   132 	   3 prev_if_ptr		ptr,		/* ptr to if_info (saved) of &if we are nested inside	*/
  1   133 	   3 this_action		fixed bin,	/* copy of expand_data.this_statement.action */
  1   134 	   3 next_action		fixed bin,	/* copy of expand_data.next_statement.action */
  1   135 
  1   136 	  2 on_info aligned,			/* info pertaining to &on units in the ec		*/
  1   137 	   3 cleanup_handler_ptr	ptr,		/* -> node for cleanup handler if any			*/
  1   138 	   3 first_handler_ptr	ptr,		/* -> top of chain of nodes for other handlers		*/
  1   139 	   3 switches		aligned,
  1   140 	    4 was_attached_sw	bit (1) unal,	/* 1 indicates parent ec was &attach'ed		*/
  1   141 	    4 in_handler_sw		bit (1) unal,	/* 1 indicates we are now executing some handler text	*/
  1   142 	    4 exit_sw		bit (1) unal,	/* 1 indicates ready to exit the handler via &exit or &goto	*/
  1   143 	    4 goto_sw		bit (1) unal,	/* 1 means this exit is accomplished by a nonlocal &goto	*/
  1   144 	    4 continue_to_signal_sw	bit (1) unal,	/* 1 means &continue_to_signal was executed		*/
  1   145 	    4 pad			bit (31) unal,
  1   146 	   3 handler_node_ptr	ptr,		/* -> parent's handler_node for this condition		*/
  1   147 	   3 parent_abs_data_ptr	ptr,		/* -> abs_data structure of parent ec				*/
  1   148 	   3 condition_info		aligned,		/* selected condition info if in_handler_sw is ON		*/
  1   149 	    4 condition_name	char (32),	/* name of condition signalled			*/
  1   150 	    4 mc_ptr		ptr,		/* machine conditions ptr for signal_			*/
  1   151 	    4 info_ptr		ptr,		/* ptr to specific condition info, for signal_		*/
  1   152 	    4 wc_ptr		ptr,		/* machine conditions for lower ring fault, for signal_	*/
  1   153 	   3 goto_label_ptr		ptr,		/* -> &goto label if goto_sw is on			*/
  1   154 	   3 goto_label_len		fixed bin (21),	/* length of the &goto label				*/
  1   155 	   3 listener_pl1_label	label variable,	/* for nonlocal goto to parent ec's listener's stack frame	*/
  1   156 	   3 get_line_pl1_label	label variable,	/* for nonlocal goto to parent ec's get_line's stack frame	*/
  1   157 						/*						*/
  1   158 	  2 saved_state_ptr		ptr,		/* -> top of parser stack				*/
  1   159 	  2 current_lex_block_ptr	ptr,		/* -> lex_block for current block position		*/
  1   160 	  2 current_proc_block_ptr	ptr,		/* -> proc block for current procedure			*/
  1   161 	  2 last_block_ptr		ptr,		/* -> last lex or proc block that has been allocated	*/
  1   162 	  2 current_loop_ptr	ptr,		/* -> loop_block for current active loop		*/
  1   163 	  2 last_loop_ptr		ptr,		/* -> last loop block that has been allocated 		*/
  1   164 						/*						*/
  1   165 	  2 labels_ptr		ptr,		/* hash table ptr for label hash table			*/
  1   166 	  2 first_xlabel_ptr	ptr,		/* first expandable label				*/
  1   167 	  2 last_xlabel_ptr		ptr,		/* last expandable label				*/
  1   168 	  2 variables_ptr		ptr,		/* hash table ptr for variable hash table		*/
  1   169 						/*						*/
  1   170 	  2 timed_input		bit (1),		/* 1 indicates input requests may be delayed		*/
  1   171 	  2 low_sleep_time		fixed bin (35),	/* low  sleep time for timed input			*/
  1   172 	  2 sleep_time_range	fixed bin (35),	/* high sleep time for timed input			*/
  1   173 	  2 seed			fixed bin (35),	/* seed for timed input random numbers			*/
  1   174 						/*						*/
  1   175 	  2 work_area		area (800);	/* extensible area for args, etc.			*/
  1   176 
  1   177 declare	abs_data_version_1		fixed bin static options (constant) initial (1),
  1   178 	Work_area_size		fixed bin static options (constant) initial (800);
  1   179 
  1   180 dcl (UNEXPANDED init (1), EXPANDED init (2), ALL init (3), BOTH init (4))
  1   181 	fixed bin int static options (constant);
  1   182 
  1   183 /*  END OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
     1389 
     1390 
  2     1 /*  START OF:	abs_io_hash.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  2     2 
  2     3 /* Written: 10 June 1980 by J. Spencer Love								*/
  2     4 
  2     5 declare	hash_table		(0:60) ptr unaligned based initial ((61) (null ()));
  2     6 
  2     7 declare	label_ptr			ptr,
  2     8 	current_label_len		fixed bin (21),
  2     9 	current_label_ptr		ptr,
  2    10 	current_label		char (current_label_len) based (current_label_ptr);
  2    11 
  2    12 declare	1 label			aligned based (label_ptr),
  2    13 	  2 next_ptr		ptr unaligned,
  2    14 	  2 statement_pos		fixed bin (21),
  2    15 	  2 statement_len		fixed bin (21),
  2    16 	  2 len			fixed bin (21),
  2    17 	  2 lex_block_ptr		ptr unaligned,
  2    18 	  2 name			char (current_label_len refer (label.len)) initial (current_label);
  2    19 
  2    20 /*  END OF:	abs_io_hash.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1391 
     1392 
  3     1 /*  START OF:	ec_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
  3     2 
  3     3 declare	ec_data_ptr		ptr;
  3     4 
  3     5 declare	1 ec_data			aligned based (ec_data_ptr),
  3     6 	  2 version_id		char (4),		/* " ec "						*/
  3     7 	  2 version		fixed bin,	/* 1						*/
  3     8 	  2 active_function		bit (1),		/* This affects &is_af and &return			*/
  3     9 	  2 return_len		fixed bin (21),	/* maximum length and pointer to varying character string	*/
  3    10 	  2 return_ptr		ptr,		/* for active function return value			*/
  3    11 	  2 execute_line		entry (ptr, fixed bin (21), fixed bin (35)),
  3    12 	  2 eval_string		entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
  3    13 	  2 set_ready_mode		entry (1 aligned, 2 bit (1) unal, 2 bit (35) unal),
  3    14 	  2 error			entry () options (variable),
  3    15 	  2 switch_ptr		ptr,		/* switch affected by &attach				*/
  3    16 	  2 id_string		char (19),	/* name string for &attach save switch should contain this	*/
  3    17 	  2 input_line		bit (1),		/* this makes the command_line/input_line distinction	*/
  3    18 	  2 call_ready_proc		bit (1),		/* this implements the &ready_proc keyword		*/
  3    19 	  2 who_am_i		char (72) varying;	/* for error messages. It's 72 chars for subsystem requests */
  3    20 
  3    21 declare	ec_data_version_id		char (4) aligned static options (constant) initial (" ec "),
  3    22 	ec_data_version_1		fixed bin static options (constant) initial (1);
  3    23 
  3    24 /*  END OF:	ec_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
     1393 
     1394 
  4     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  4     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  4     3*      version number to IOX2. */
  4     4 /* format: style2 */
  4     5 
  4     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  4     7 	     2 version	      character (4) aligned,	/* IOX2 */
  4     8 	     2 name	      char (32),		/* I/O name of this block. */
  4     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  4    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  4    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  4    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  4    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  4    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  4    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  4    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  4    17 						/* open(p,mode,not_used,s) */
  4    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  4    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  4    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  4    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  4    24 						/* put_chars(p,bufptr,buflen,s) */
  4    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  4    26 						/* modes(p,newmode,oldmode,s) */
  4    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  4    28 						/* position(p,u1,u2,s) */
  4    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  4    30 						/* control(p,order,infptr,s) */
  4    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  4    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  4    34 						/* write_record(p,bufptr,buflen,s) */
  4    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  4    36 						/* rewrite_record(p,bufptr,buflen,s) */
  4    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  4    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  4    39 						/* seek_key(p,key,len,s) */
  4    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  4    41 						/* read_key(p,key,len,s) */
  4    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  4    43 						/* read_length(p,len,s) */
  4    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  4    45 						/* open_file(p,mode,desc,not_used,s) */
  4    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  4    47 						/* close_file(p,desc,s) */
  4    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  4    49 						/* detach(p,desc,s) */
  4    50 
  4    51      declare iox_$iocb_version_sentinel
  4    52 			      character (4) aligned external static;
  4    53 
  4    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1395 
     1396 
     1397      end abs_io_v1_get_line;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/10/87  1445.1  abs_io_v1_get_line.pl1            >special_ldd>install>MR12.1-1104>abs_io_v1_get_line.pl1
1389         1    08/11/87  2007.9  abs_io_data.incl.pl1              >ldd>include>abs_io_data.incl.pl1
1391         2    06/24/81  1744.4  abs_io_hash.incl.pl1              >ldd>include>abs_io_hash.incl.pl1
1393         3    04/13/82  1620.2  ec_data.incl.pl1                  >ldd>include>ec_data.incl.pl1
1395         4    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AF                                     based           char                     unaligned dcl 1014 set ref 1036* 1039* 1040*
AF_len                          000270 automatic       fixed bin(21,0)          dcl 1014 set ref 1034* 1036 1036 1039 1039 1040 1040
AF_ptr                          000272 automatic       pointer                  dcl 1014 set ref 1033* 1036 1039 1040
CL                                     based           char                     unaligned dcl 53 set ref 261 270 284 290 294 295 296
                                                                                  305 309 310 312 313 314 333 339 359 378 390 630*
                                                                                  1162
CL_len                          000115 automatic       fixed bin(21,0)          dcl 53 set ref 246* 248 255* 256 261 270 284 290 294
                                                                                  294 295 295 296 296 305 309 309 310 310 312 312
                                                                                  313 313 314 314 333 339 359 378 388 390 393 441*
                                                                                  471 528 577* 594 605 607* 609 630 630 679 681*
                                                                                  930* 1162
CL_pos                          000116 automatic       fixed bin(21,0)          dcl 53 set ref 261* 262 268 284 290 294 295 296 305
                                                                                  309 310 312 313 314 333 339 359 376* 376 378 381*
                                                                                  381 1158 1165* 1165 1166
CL_ptr                          000120 automatic       pointer                  dcl 53 set ref 254* 261 270 284 290 294 295 296 305
                                                                                  309 310 312 313 314 333 339 359 378 390 394 630
                                                                                  1162
COMMENT                                constant        fixed bin(17,0)          initial dcl 137 ref 427 916 955
DATA                                   constant        fixed bin(17,0)          initial dcl 137 ref 430
ELSE                                   constant        fixed bin(17,0)          initial dcl 137 ref 943 955
FALSE                           000246 constant        char(5)                  initial unaligned dcl 117 set ref 1147*
GOTO                                   constant        fixed bin(17,0)          initial dcl 137 ref 588
HIGH                            000212 constant        fixed bin(17,0)          initial array dcl 147 ref 407
INIT                                   constant        bit(1)                   initial dcl 108 set ref 194* 211*
IS                                     based           char                     unaligned dcl 50 set ref 254 255 574 607 1353 1356
KEYWORD                         000106 constant        varying char(12)         initial array dcl 150 ref 408
LABEL                                  constant        fixed bin(17,0)          initial dcl 137 ref 564 614 619
LOW                             000226 constant        fixed bin(17,0)          initial array dcl 144 ref 407
MUST_BE_LABEL                          constant        fixed bin(17,0)          initial dcl 131 ref 490 494 549 559 576
MUST_BE_THEN                           constant        fixed bin(17,0)          initial dcl 131 ref 497 870
NL                              000250 constant        char(1)                  initial unaligned dcl 111 set ref 255 574 862* 890
                                                                                  1353
NL_THEN_AMP                            constant        char(2)                  initial unaligned dcl 114 ref 607
NONE                            000334 constant        fixed bin(17,0)          initial dcl 127 set ref 231 349 369* 374 1134* 1145*
                                                                                  1147* 1183
NORMAL                                 constant        fixed bin(17,0)          initial dcl 131 ref 239 551 554 564 603 624 859 900
                                                                                  949 961 963 1383
P_actual_len                           parameter       fixed bin(21,0)          dcl 38 set ref 35 203* 447* 451* 452 452 453 456 457
                                                                                  460 461 474 474 476 476 511* 696*
P_buffer                               based           char                     unaligned dcl 95 set ref 452* 452 474* 476*
P_buffer_len                           parameter       fixed bin(21,0)          dcl 38 set ref 35 203* 451 696* 838
P_buffer_ptr                           parameter       pointer                  dcl 38 set ref 35 203* 452 474 476 696* 837
P_iocb_ptr                             parameter       pointer                  dcl 38 set ref 35 823 828* 830
P_status                               parameter       fixed bin(35,0)          dcl 38 set ref 35 203* 478* 480* 512* 696*
QUOTE                           000341 constant        fixed bin(17,0)          initial dcl 127 set ref 323 1088* 1101* 1115* 1119*
RANK_AMP_ADJ                    011144 constant        fixed bin(17,0)          initial dcl 123 ref 339
RANK_F_ADJ                             constant        fixed bin(17,0)          initial dcl 123 ref 334
RANK_ZERO                              constant        fixed bin(17,0)          initial dcl 123 ref 333 359
REQUOTE                                constant        fixed bin(17,0)          initial dcl 127 ref 328 1213 1241
RS                                     based           char                     unaligned dcl 60 set ref 390* 400 404 406 408 410
                                                                                  416 422 434* 456 460 538 540 634 634 646 656 730
                                                                                  732 732 733 733 767 768 770 770 771 771 772 772
                                                                                  776 777 777 778 778 855 861* 874 877 888 889 890*
                                                                                  897 938 991 997 997 1020 1022 1024 1024 1030 1030
                                                                                  1033 1162* 1186* 1192 1197 1216* 1225* 1228* 1238*
                                                                                  1246* 1283* 1283 1300* 1300
RS_len                          000124 automatic       fixed bin(21,0)          dcl 60 set ref 264* 390 390 393* 400 400 404 406 408
                                                                                  410 411 416 422 434 434 444* 447 451 453 456 457
                                                                                  460 461 461* 462* 538 540 634 634 634 634 638 643
                                                                                  646 647* 647 651* 651 652 652* 656 658* 665 676
                                                                                  724 730* 730 732 732 733 733 760 767 768* 768 770
                                                                                  770 771 771 772 772 772 776 777 777 778 778 847
                                                                                  851 852* 855* 855 861 861 874 875* 877 878 886*
                                                                                  887 888 889* 889 890 890 895 895 897 898* 898 933*
                                                                                  938 939 991 997 997 1020 1022 1024 1024 1030 1030
                                                                                  1030 1033 1034 1162 1162 1186 1186 1192 1197 1198
                                                                                  1211 1216 1216 1225 1225 1228 1228 1238 1238 1246
                                                                                  1246 1248 1260 1264* 1283 1283 1300 1300
RS_pos                          000125 automatic       fixed bin(21,0)          dcl 60 set ref 410* 411 411* 538 540 634 634 638 643
                                                                                  643* 643 646 647 665 676 724 732 732 733 733 760
                                                                                  767 770 770 771 771 772 772 772 776* 776 776 777
                                                                                  777 778 778 847 847 877* 878 878* 895 895* 897 898
                                                                                  938* 939 939* 989 991 995 1020 1022 1024 1024 1030
                                                                                  1033 1034
RS_ptr                          000126 automatic       pointer                  dcl 60 set ref 265* 390 394* 400 404 406 408 410 416
                                                                                  422 434 445* 452 456 460* 460 463 538 540 634 634
                                                                                  646* 646 656 658* 730 732 732 733 733 767 768 770
                                                                                  770 771 771 772 772 776 777 777 778 778 855 861
                                                                                  874* 874 877 888 889 890 897* 897 935* 938 991 997
                                                                                  997 1020 1022 1024 1024 1030 1030 1033 1162 1186
                                                                                  1192 1197 1216 1225 1228 1238 1246 1283 1284* 1300
                                                                                  1304*
SEARCHING_FOR_LABEL                    constant        fixed bin(17,0)          initial dcl 131 ref 486 486 593
SKIPABLE                        000040 constant        bit(1)                   initial array dcl 158 ref 966
SKIPPING_CLAUSE                        constant        fixed bin(17,0)          initial dcl 131 ref 237 864 951 970
SPACE                                  constant        char(1)                  initial unaligned dcl 117 set ref 369*
THEN                                   constant        fixed bin(17,0)          initial dcl 137 ref 902 919
TRACE                           000063 constant        bit(1)                   initial array dcl 155 ref 434
TRACE_ELSE                      000242 constant        char(6)                  initial unaligned dcl 117 set ref 904*
TRACE_THEN                      000244 constant        char(6)                  initial unaligned dcl 117 set ref 902*
TRUE                                   constant        char(4)                  initial unaligned dcl 117 set ref 1145*
UPDATE                                 constant        bit(1)                   initial dcl 108 set ref 808*
WHITE                           000036 constant        char(5)                  initial unaligned dcl 162 ref 406 410 540 730 767
                                                                                  768 776 855 877 889 938 997 997
abs_data                               based           structure                level 1 dcl 1-23
abs_data_ptr                    000174 automatic       pointer                  dcl 1-21 set ref 200 203 214 216 220 222 226 226*
                                                                                  237 237 241 248 248 251 251 254 254 254 255 255
                                                                                  255 309 342 357 367 368 368 368 369 372 372 372
                                                                                  373 373 373 373 434 444 445 456 457 461 463 465
                                                                                  468 468 468 468 468 468 471 471 474 476 478 482
                                                                                  500 509 523 525 528 528 528 535 535 561 563 572
                                                                                  573 574 574 574 574 584 592 594 594 598 600 601
                                                                                  605 605 607 607 607 611 622 630 670* 679 679 692*
                                                                                  739 743 747 751 827 828 835* 836 857 857 861 862
                                                                                  863 863 880 887 888 902 904 906 908 908 933 935
                                                                                  936 945 948 948 949 949 962 1058 1088 1088 1088
                                                                                  1100 1132 1280 1280 1283 1284 1296 1302 1302 1302
                                                                                  1302 1304 1305 1316 1316 1350 1350 1353 1353 1354
                                                                                  1356 1356 1362 1373 1373 1373 1378
abs_io_control$attach           000024 constant        entry                    external dcl 174 ref 670
abs_io_control$detach           000026 constant        entry                    external dcl 174 ref 692
abs_io_control$sleep            000030 constant        entry                    external dcl 174 ref 226
absentee                273            based           bit(1)                   level 2 dcl 1-23 set ref 309* 509
active                  275            based           bit(1)                   level 2 dcl 1-23 set ref 200 214* 216* 482*
active_fnc_err_                 000032 constant        entry                    external dcl 174 ref 1365
active_function           2            based           bit(1)                   level 2 dcl 3-5 ref 1080 1365
actual_iocb_ptr          12            based           pointer                  level 2 dcl 4-6 ref 823 830
addr                                                   builtin function         dcl 44 ref 254 456 460 538 646 802 802 874 888 897
                                                                                  1033 1101 1115 1119 1134 1356
allocated_chars                        based           char                     unaligned dcl 95 ref 468 1302
allocated_chars_len     270            based           fixed bin(21,0)          level 2 dcl 1-23 set ref 468 468 1280 1302 1302
                                                                                  1305*
allocated_chars_ptr     262            based           pointer                  level 2 dcl 1-23 set ref 468 468 1280 1283 1284 1302
                                                                                  1302 1304*
area                            000100 stack reference condition                dcl 48 ref 582 586 1294 1298 1314 1318
arg_array                              based           structure                array level 1 dcl 103
arg_count                              based           char                     unaligned dcl 1127 in procedure "emit_arg_count" set
                                                                                  ref 1134*
arg_count                52            based           fixed bin(17,0)          level 3 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_v1_get_line" ref 342 357 367
                                                                                  369 373 1132
arg_count_len                   000433 automatic       fixed bin(17,0)          dcl 1127 set ref 1133* 1134 1134 1134
arg_count_pic                   000430 automatic       picture(9)               unaligned dcl 1127 set ref 1132* 1133 1134
arg_idx                         000131 automatic       fixed bin(17,0)          dcl 66 set ref 342* 354* 357 357* 357 367* 367* 368
                                                                                  368 368 369* 372 373 373 373 373
arg_info                 40            based           structure                level 2 dcl 1-23
arg_pos                         000456 automatic       fixed bin(21,0)          dcl 1180 set ref 1190* 1220 1225 1226* 1226 1229
                                                                                  1234 1238
arg_ptr                  50            based           pointer                  level 3 dcl 1-23 ref 368 368 368 373 373 373
arg_string                             parameter       char                     unaligned dcl 1177 in procedure "copy_string" ref
                                                                                  1174 1185 1185 1186 1186 1220 1225 1229 1234 1238
arg_string                             based           char                     unaligned dcl 101 in procedure "abs_io_v1_get_line"
                                                                                  set ref 368* 373*
attach                  252            based           structure                level 2 dcl 1-23
attach_data_ptr          16            based           pointer                  level 2 dcl 4-6 ref 827 835
bars_len                        000274 automatic       fixed bin(17,0)          dcl 1014 set ref 1024* 1027* 1028* 1030 1033 1034
                                                                                  1036 1039 1040
binary                                                 builtin function         dcl 44 ref 541
break                           000132 automatic       fixed bin(17,0)          dcl 66 set ref 270* 271 272 274 274 284* 286 287 288
                                                                                  333* 334 339 346 346 356* 356 356 356* 357* 378*
                                                                                  379 381 404* 405 407 407 416 422
buffer_allocated                000133 automatic       bit(1)                   dcl 66 set ref 244* 439* 447 886 928* 1278*
buffer_len                      000134 automatic       fixed bin(21,0)          dcl 66 set ref 838* 1262 1288* 1289 1292* 1296 1296
                                                                                  1305
buffer_ptr                      000136 automatic       pointer                  dcl 66 set ref 265 837* 1284* 1304*
call_ready_proc          36            based           bit(1)                   level 2 dcl 3-5 set ref 718*
char                                                   builtin function         dcl 44 ref 541
chars_len               271            based           fixed bin(21,0)          level 2 dcl 1-23 set ref 222 444 457* 461* 465* 468
                                                                                  478
chars_ptr               264            based           pointer                  level 2 dcl 1-23 set ref 445 456* 463*
cleanup                         000106 stack reference condition                dcl 48 ref 214
codeptr                                                builtin function         dcl 44 ref 708 1036 1365
com_err_                        000034 constant        entry                    external dcl 174 ref 1361 1368
command_line            162            based           structure                level 2 dcl 1-23 set ref 476* 739*
comment_line            200            based           structure                level 2 dcl 1-23 set ref 630* 743*
complain                        000100 automatic       entry variable           dcl 1325 set ref 1361* 1365* 1368* 1369* 1373
control                         000140 automatic       fixed bin(17,0)          dcl 66 set ref 407* 408* 427* 430* 434 437 564 588
                                                                                  614 619 902 916 919 943* 955 955 955 966 968
control_line            216            based           structure                level 2 dcl 1-23 set ref 434* 747* 861* 862* 902*
                                                                                  904*
copy                                                   builtin function         dcl 44 ref 1216 1228 1246
copy_len                        000141 automatic       fixed bin(21,0)          dcl 66 set ref 388* 389* 390 390 390
cu_$arg_list_ptr                000036 constant        entry                    external dcl 174 ref 1347 1347
cu_$arg_ptr                     000040 constant        entry                    external dcl 174 ref 1345
cu_$evaluate_active_string      000042 constant        entry                    external dcl 174 ref 1039 1040
cu_$set_ready_mode              000044 constant        entry                    external dcl 174 ref 711 712
current_label                          based           char                     unaligned dcl 2-7 set ref 541 545 564 582* 584
current_label_len               000200 automatic       fixed bin(21,0)          dcl 2-7 set ref 540* 541 541 541 545 564 582 582 584
                                                                                  584 584
current_label_ptr               000202 automatic       pointer                  dcl 2-7 set ref 538* 541 545 564 582 584
divide                                                 builtin function         dcl 44 ref 1206 1244 1288
ec_data                                based           structure                level 1 dcl 3-5
ec_data_ptr              26            based           pointer                  level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_v1_get_line" ref 836
ec_data_ptr                     000204 automatic       pointer                  dcl 3-3 in procedure "abs_io_v1_get_line" set ref
                                                                                  652 652 656 656 668 708 708 708 718 718 836* 1036
                                                                                  1036 1036 1067 1069 1078 1080 1112 1118 1119 1359
                                                                                  1365 1365 1369 1370
ec_dir                                 based           char                     unaligned dcl 1095 set ref 1101*
ec_dir_buf                      000336 automatic       char(168)                unaligned dcl 1095 set ref 1100* 1101
ec_dir_len                      000410 automatic       fixed bin(17,0)          dcl 1095 set ref 1100* 1101 1101
ec_name                                based           char                     unaligned dcl 95 set ref 1088*
ec_name_len              46            based           fixed bin(21,0)          level 3 dcl 1-23 ref 1088 1088
ec_name_ptr              44            based           pointer                  level 3 dcl 1-23 ref 1088
ec_path                                based           char                     unaligned dcl 95 set ref 372* 1373*
ec_path_len              42            based           fixed bin(21,0)          level 3 dcl 1-23 ref 372 372 1373 1373
ec_path_ptr              40            based           pointer                  level 3 dcl 1-23 ref 372 1373
ec_switch                              based           char                     unaligned dcl 1108 set ref 1115* 1119*
ec_switch_len                   000420 automatic       fixed bin(17,0)          dcl 1108 set ref 1114* 1115 1115 1118* 1119 1119
else_clause_len         272            based           fixed bin(21,0)          level 2 dcl 1-23 set ref 241 468 525* 880 887* 908
                                                                                  933 936*
else_clause_ptr         266            based           pointer                  level 2 dcl 1-23 set ref 888* 935
eof                     276            based           bit(1)                   level 2 dcl 1-23 set ref 220 500*
error                    22            based           entry variable           level 2 dcl 3-5 ref 1365 1369
error_table_$command_line_overflow
                                000012 external static fixed bin(35,0)          dcl 165 set ref 652*
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 165 ref 512
error_table_$long_record        000016 external static fixed bin(35,0)          dcl 165 ref 478
error_table_$noalloc            000010 external static fixed bin(35,0)          dcl 165 set ref 582* 1294* 1314*
eval_string              12            based           entry variable           level 2 dcl 3-5 ref 1036 1036
expected_nest_level     302            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 237 863* 906* 949
flag                            000172 automatic       bit(1)                   level 2 packed unaligned dcl 91 set ref 706*
from_sw                         000142 automatic       bit(1)                   dcl 66 set ref 232* 300* 334 336* 350* 364 366*
get_next_line                   000144 automatic       label variable           local dcl 66 set ref 245* 526* 535 552 564 578 603
                                                                                  609 632 636 674 685 714 719 741 745 749 753 891*
                                                                                  908* 916 941* 966 973* 1379* 1380
hash                            000150 automatic       fixed bin(17,0)          dcl 66 set ref 541* 545 563 570 590 600 601
hash_table                             based           pointer                  initial array unaligned dcl 2-5 set ref 563 600 601*
                                                                                  1316 1316*
hcs_$fs_get_path_name           000046 constant        entry                    external dcl 174 ref 1100
index                                                  builtin function         dcl 44 ref 255 261 270 284 378 404 607 991 997 997
                                                                                  1192 1220 1353
input_line              234            based           structure                level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_v1_get_line" set ref 474*
                                                                                  751*
input_line               35            based           bit(1)                   level 2 in structure "ec_data" dcl 3-5 in procedure
                                                                                  "abs_io_v1_get_line" ref 1069
input_reset_sw                  000151 automatic       bit(1)                   dcl 66 set ref 196* 502 504*
input_string             60            based           structure                level 2 dcl 1-23
io_module_name            1            based           varying char(32)         level 2 dcl 1-23 ref 828 1362
ioa_$general_rs                 000050 constant        entry                    external dcl 174 ref 1347
ioa_$nnl                        000052 constant        entry                    external dcl 174 ref 634
iocb                                   based           structure                level 1 dcl 4-6 in procedure "abs_io_v1_get_line"
iocb                      2            parameter       pointer                  level 2 in structure "trace_structure" dcl 792
                                                                                  in procedure "trace_output" ref 798 800
iocb                      2            parameter       pointer                  level 2 in structure "trace_structure" dcl 758
                                                                                  in procedure "trace_control" set ref 772* 777*
iocb_ptr                        000152 automatic       pointer                  dcl 66 set ref 208* 823* 827 830* 835 1114 1115
iox_$find_iocb                  000054 constant        entry                    external dcl 174 ref 777
iox_$get_line                   000056 constant        entry                    external dcl 174 ref 203 696
iox_$put_chars                  000060 constant        entry                    external dcl 174 ref 658 802
iox_$user_input                 000022 external static pointer                  dcl 165 set ref 696*
iox_$user_output                000020 external static pointer                  dcl 165 set ref 658* 798
keyword                                parameter       char                     unaligned dcl 985 set ref 982 991 997 997*
keyword_pos                     000260 automatic       fixed bin(21,0)          dcl 985 set ref 989* 995* 997 997 1001
label                                  based           structure                level 1 dcl 2-12 set ref 584
label_ptr                       000176 automatic       pointer                  dcl 2-7 set ref 555* 563* 563* 564 571 573* 580 584*
                                                                                  591 598 600 601
labels_ptr              402            based           pointer                  level 2 dcl 1-23 set ref 561 563 600 601 1316*
len                                    parameter       fixed bin(21,0)          dcl 1257 in procedure "check_len" ref 1254 1260
len                             000154 automatic       fixed bin(21,0)          dcl 66 in procedure "abs_io_v1_get_line" set ref
                                                                                  406* 408 410 410 411 416 767* 772 772 772 776 776
                                                                                  1158* 1159 1161* 1162 1162 1162
len                      62            based           fixed bin(21,0)          level 3 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_v1_get_line" ref 251 254 255
                                                                                  574 607 1350 1353 1354 1356
len                       2            based           fixed bin(21,0)          array level 2 in structure "arg_array" dcl 103
                                                                                  in procedure "abs_io_v1_get_line" ref 368 368 373
                                                                                  373
len                       3            based           fixed bin(21,0)          level 2 in structure "label" dcl 2-12 in procedure
                                                                                  "abs_io_v1_get_line" set ref 545 564 584* 584 612
                                                                                  612 625 625
length                                                 builtin function         dcl 44 ref 540 730 768 802 802 855 889 997 1114 1118
                                                                                  1133 1185 1185 1186 1229 1234
limit                    65            based           fixed bin(21,0)          level 3 dcl 1-23 set ref 528* 528 535 594
line                                   based           char                     unaligned dcl 1325 in procedure "error" set ref
                                                                                  1373*
line                                   parameter       char                     unaligned dcl 792 in procedure "trace_output" set
                                                                                  ref 789 802 802 802 802
line_len                        000104 automatic       fixed bin(21,0)          dcl 1325 set ref 1353* 1354 1354* 1357 1373 1373
line_number                     000105 automatic       fixed bin(21,0)          dcl 1325 set ref 1349* 1355* 1355 1373*
line_ptr                        000106 automatic       pointer                  dcl 1325 set ref 1356* 1373
line_start                      000110 automatic       fixed bin(21,0)          dcl 1325 set ref 1350* 1350 1350* 1353 1354 1356*
                                                                                  1357
logout                          000062 constant        entry                    external dcl 174 ref 509
ltrim                                                  builtin function         dcl 44 ref 1133
max                                                    builtin function         dcl 44 ref 367 528
message                         000111 automatic       char(256)                unaligned dcl 1325 set ref 1347* 1373*
min                                                    builtin function         dcl 44 ref 294 295 296 309 310 312 313 314 400 451
                                                                                  541 634 634
mod                                                    builtin function         dcl 44 ref 541 1200 1200 1207
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 4-6 in procedure
                                                                                  "abs_io_v1_get_line" set ref 1114 1115 1118 1119
name                      5            based           char                     initial level 2 in structure "label" dcl 2-12
                                                                                  in procedure "abs_io_v1_get_line" set ref 545 564
                                                                                  584* 612* 625*
nest_level              301            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 237 523* 857* 857 863 908
                                                                                  945 948* 948 949 962*
new_RS                                 based           char                     unaligned dcl 1273 ref 1296
new_RS_len                      000470 automatic       fixed bin(21,0)          dcl 1257 set ref 1260* 1262 1262* 1264
new_RS_ptr                      000100 automatic       pointer                  dcl 1273 set ref 1296* 1300 1304
next_ptr                               based           pointer                  level 2 packed unaligned dcl 2-12 set ref 580 600*
noabort                 260(01)        based           bit(1)                   level 4 packed unaligned dcl 1-23 ref 1378
not_in_CL                       000122 automatic       bit(1)                   dcl 53 set ref 258* 385 443* 447 453 886 931* 1168*
                                                                                  1277*
null                                                   builtin function         dcl 44 ref 468 561 563 668 670 670 692 692 708 708
                                                                                  718 772 798 1036 1036 1036 1036 1039 1039 1040
                                                                                  1040 1058 1067 1078 1112 1280 1302 1316 1359 1365
old_CL_pos                      000123 automatic       fixed bin(21,0)          dcl 53 set ref 264* 388 390 1158 1162 1166*
old_IS_pos                      000114 automatic       fixed bin(21,0)          dcl 50 set ref 572* 592* 611 622
old_RS_len                      000130 automatic       fixed bin(21,0)          dcl 60 set ref 264* 851* 875 1192 1196* 1196 1197
                                                                                  1198 1199* 1199 1211* 1248*
on                        0(01)        parameter       bit(1)                   level 2 in structure "trace_structure" packed
                                                                                  unaligned dcl 758 in procedure "trace_control" set
                                                                                  ref 763* 770* 771* 782*
on                        0(01)        parameter       bit(1)                   level 2 in structure "trace_structure" packed
                                                                                  unaligned dcl 792 in procedure "trace_output" ref
                                                                                  797
position                 64            based           fixed bin(21,0)          level 3 dcl 1-23 set ref 248* 248 251 254 255 471*
                                                                                  471 528 535 572 573* 574 574 592 594* 598 605* 605
                                                                                  607 611* 622* 679* 679 1350
ptr                      60            based           pointer                  level 3 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_v1_get_line" set ref 254 255
                                                                                  574 607 1100* 1353 1356
ptr                                    based           pointer                  array level 2 in structure "arg_array" dcl 103
                                                                                  in procedure "abs_io_v1_get_line" ref 368 373
quote_len                       000460 automatic       fixed bin(21,0)          dcl 1180 set ref 1192* 1194 1196 1197* 1198 1198*
                                                                                  1199 1200 1200 1202* 1202 1205 1207* 1207
quote_modifier                  000155 automatic       fixed bin(17,0)          dcl 66 in procedure "abs_io_v1_get_line" set ref
                                                                                  231* 323* 328* 349* 368* 372* 373* 374*
quote_modifier                         parameter       fixed bin(17,0)          dcl 1177 in procedure "copy_string" ref 1174 1183
                                                                                  1213 1241
quote_pos                       000457 automatic       fixed bin(21,0)          dcl 1180 set ref 1220* 1222 1224* 1225 1225 1225
                                                                                  1226 1234* 1235 1237* 1238 1238 1238
rank                                                   builtin function         dcl 44 ref 333 359
ready_mode                      000172 automatic       structure                level 1 dcl 91 set ref 704* 708* 711* 712*
required_len                           parameter       fixed bin(21,0)          dcl 1273 set ref 1270 1280 1288 1289 1294*
return_arg                             based           varying char             dcl 95 set ref 656*
return_len                3            based           fixed bin(21,0)          level 2 dcl 3-5 set ref 652 652* 656
return_ptr                4            based           pointer                  level 2 dcl 3-5 ref 656
rtrim                                                  builtin function         dcl 44 ref 540 730 768 855 889 1114 1118 1362
save_ptr                256            based           pointer                  level 3 dcl 1-23 set ref 203*
saved_hash                      000160 automatic       fixed bin(17,0)          dcl 66 set ref 233* 545 548* 570* 590*
saved_label_ptr                 000162 automatic       pointer                  dcl 66 set ref 545 555 571* 591* 612 625
saved_state                     000164 automatic       fixed bin(17,0)          dcl 66 set ref 869* 921
scanning_clause                 000165 automatic       bit(1)                   dcl 66 set ref 259* 442* 447 532 627 912* 955 960*
search                                                 builtin function         dcl 44 ref 406 767
set_ready_mode           16            based           entry variable           level 2 dcl 3-5 ref 708 708
severity                        000211 automatic       bit(1)                   unaligned dcl 1325 set ref 1337* 1343* 1373* 1376
signal_io_error_                000064 constant        entry                    external dcl 174 ref 208 805 828
start                           000156 automatic       fixed bin(21,0)          dcl 66 set ref 844* 847 849 852 867 874 875 883* 884
                                                                                  887 888 889
start_keyword                   000261 automatic       fixed bin(21,0)          dcl 985 set ref 991* 993 995
state                           000157 automatic       fixed bin(17,0)          dcl 66 set ref 237* 239* 412 432 486 490 494 497 549
                                                                                  551* 554* 559 564 576* 593* 603 624* 859 864* 869
                                                                                  870* 900 921* 949* 951* 961* 970* 1383*
statement_pos             1            based           fixed bin(21,0)          level 2 dcl 2-12 set ref 573 598*
status                                 based           fixed bin(25,0)          dcl 1325 in procedure "error" set ref 1373* 1373
status                          000166 automatic       fixed bin(35,0)          dcl 66 in procedure "abs_io_v1_get_line" set ref
                                                                                  658* 670* 671 671* 692* 693 693* 777* 778 778*
                                                                                  802* 803 805* 1036* 1039* 1040* 1042 1042*
status_ptr                      000212 automatic       pointer                  dcl 1325 set ref 1345* 1373 1373
string                                                 builtin function         dcl 44 set ref 704*
substr                                                 builtin function         dcl 44 set ref 254 255 270 284 290 294 295 296 305
                                                                                  309 310 312 313 314 333 339 359 378 390* 390 400
                                                                                  404 406 408 410 416 422 456 460 538 540 541 574
                                                                                  607 634 634 646 732 732 733 733 767 770 770 771
                                                                                  771 772 772 776 777 777 778 778 874 877 888 889
                                                                                  890* 897 938 991 997 997 1020 1022 1024 1024 1030
                                                                                  1030 1033 1134 1162* 1162 1186* 1192 1197 1216*
                                                                                  1220 1225* 1225 1228* 1238* 1238 1246* 1353 1356
switch                          000242 automatic       pointer                  dcl 795 set ref 798* 800* 802* 805*
switch_ptr               26            based           pointer                  level 2 dcl 3-5 ref 1118 1119
switches                260            based           structure                level 3 dcl 1-23
target_ptr              254            based           pointer                  level 3 dcl 1-23 ref 1058
test                                   parameter       bit(1)                   dcl 1141 in procedure "predicate" ref 1138 1145
test                            000167 automatic       bit(1)                   dcl 66 in procedure "abs_io_v1_get_line" set ref
                                                                                  716* 718
timed_input             412            based           bit(1)                   level 2 dcl 1-23 ref 226
trace_structure                        parameter       structure                level 1 dcl 792 in procedure "trace_output" ref 789
trace_structure                        parameter       structure                level 1 dcl 758 in procedure "trace_control" set ref
                                                                                  755
twoL                            000170 automatic       fixed bin(21,0)          dcl 66 set ref 266* 1200 1200 1202 1203* 1203 1206*
                                                                                  1206 1207 1215* 1216 1216 1216 1217* 1217 1227*
                                                                                  1228 1228 1228 1244* 1244 1245* 1246 1246 1246
unspec                                                 builtin function         dcl 44 ref 541
update                                 parameter       bit(1)                   dcl 821 ref 818 825
value                           000275 automatic       varying char(8)          dcl 1014 set ref 1036* 1039* 1040* 1044 1046 1048*
verify                                                 builtin function         dcl 44 ref 410 776 877 938 1197
who                             000214 automatic       varying char(72)         dcl 1325 set ref 1362* 1370* 1373*
who_am_i                 37            based           varying char(72)         level 2 dcl 3-5 ref 1370
width                                  parameter       fixed bin(17,0)          dcl 1156 in procedure "copy_up_to_ampersand" ref
                                                                                  1153 1165
width                                  parameter       fixed bin(17,0)          dcl 1141 in procedure "predicate" set ref 1138 1144*
width                           000171 automatic       fixed bin(17,0)          dcl 66 in procedure "abs_io_v1_get_line" set ref
                                                                                  230* 331* 331 333 339 343* 343 348* 358* 358 359
                                                                                  361* 363*
work_area               416            based           area(800)                level 2 dcl 1-23 ref 584 1296 1316

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL                                    internal static fixed bin(17,0)          initial dcl 1-180
BOTH                                   internal static fixed bin(17,0)          initial dcl 1-180
EXPANDED                               internal static fixed bin(17,0)          initial dcl 1-180
UNEXPANDED                             internal static fixed bin(17,0)          initial dcl 1-180
Work_area_size                         internal static fixed bin(17,0)          initial dcl 1-177
abs_data_version_1                     internal static fixed bin(17,0)          initial dcl 1-177
ec_data_version_1                      internal static fixed bin(17,0)          initial dcl 3-21
ec_data_version_id                     internal static char(4)                  initial dcl 3-21
iox_$iocb_version_sentinel             external static char(4)                  dcl 4-51

NAMES DECLARED BY EXPLICIT CONTEXT.
APPEND                          007374 constant        label                    dcl 1241 ref 1231
CHECK_CONTROL                   002315 constant        label                    dcl 400 ref 914
COMMENT_LINE                    002514 constant        label                    dcl 427 ref 271 405
CONTINUE_LONG_RECORD            002550 constant        label                    dcl 439 ref 222
CONTINUE_THEN                   004501 constant        label                    dcl 880 ref 923 953
CONTINUE_WITH_PENDING_ELSE_CLAUSE
                                004717 constant        label                    dcl 928 ref 241
CONTROL                         000013 constant        label                    array(-1:17) dcl 447 ref 437 955 968
COPY_ARG                        002116 constant        label                    dcl 361 ref 344
COPY_REST                       002266 constant        label                    dcl 385 ref 262
DBL_LOOP                        007275 constant        label                    dcl 1220 ref 1229
EGRESS                          002753 constant        label                    dcl 482 ref 514 697
END_OF_FILE                     003005 constant        label                    dcl 494 ref 220 251 641 660 1385
ENTER_SKIPPING_CLAUSE_STATE     005040 constant        label                    dcl 970 ref 908
ERROR_COMMON                    007763 constant        label                    dcl 1345 ref 1338
EXPAND                          000000 constant        label                    array(10:15) dcl 290 ref 274 288
EXPAND_AGAIN                    002246 constant        label                    dcl 376 ref 275 286 290 298 305 316 321 351
EXPAND_ARG_NUMBER               002066 constant        label                    dcl 354 ref 272 287
EXPAND_LOOP                     001570 constant        label                    dcl 284 ref 382
EXPAND_MODIFIER                 002016 constant        label                    dcl 331 ref 303 326 337
EXPAND_NEXT_LINE                001476 constant        label                    dcl 248 ref 245 526 871 941 973 975 1379
GET_CURRENT_LABEL               003125 constant        label                    dcl 538 set ref 530 614 619
GET_NEXT_LABEL_LINE             003441 constant        label                    dcl 605 ref 568 595 617
GET_PENDING_ELSE_CLAUSE         004723 constant        label                    dcl 933 ref 891
NO_NEW_LINE                     002756 constant        label                    dcl 486 ref 256
QLOOP                           007160 constant        label                    dcl 1192 ref 1209
STATE                           000006 constant        label                    array(0:4) dcl 434 ref 412 432 486 963
THREAD_IN_LABEL                 003415 constant        label                    dcl 598 ref 556
UNSTUCK_LABEL                   003532 constant        label                    dcl 622 set ref 490 494 559 574
abs_io_v1_get_line              001316 constant        entry                    external dcl 35
allocate_buffer                 007440 constant        entry                    internal dcl 1270 ref 462 886 1262
allocate_hash_table             007642 constant        entry                    internal dcl 1311 ref 561
attachedp                       006510 constant        entry                    internal dcl 1055 ref 201 313 313 668 690
check_len                       007417 constant        entry                    internal dcl 1254 ref 389 1161 1185 1215 1224 1227
                                                                                  1237 1245
conditional                     006115 constant        entry                    internal dcl 1011 ref 864
copy_string                     007117 constant        entry                    internal dcl 1174 ref 368 369 372 373 1088 1101 1115
                                                                                  1119 1134 1145 1147
copy_up_to_ampersand            007063 constant        entry                    internal dcl 1153 ref 361 1087 1099 1111 1131 1144
emit_arg_count                  006755 constant        entry                    internal dcl 1124 ref 318
emit_ec_dir                     006577 constant        entry                    internal dcl 1092 ref 295
emit_ec_name                    006551 constant        entry                    internal dcl 1084 ref 294
emit_ec_switch                  006657 constant        entry                    internal dcl 1105 ref 296
error                           007743 constant        entry                    internal dcl 1322 ref 497 532 582 612 625 627 662
                                                                                  671 693 778 847 919 925 945 1030 1042 1048 1289
                                                                                  1294 1314
find_clause                     006004 constant        entry                    internal dcl 982 ref 844 883
functionp                       006535 constant        entry                    internal dcl 1075 ref 310 310 312 312 649
get_ptrs                        005672 constant        entry                    internal dcl 818 ref 194 211 808
input_linep                     006521 constant        entry                    internal dcl 1064 ref 314 314 474 694
predicate                       007037 constant        entry                    internal dcl 1138 ref 309 310 312 313 314
reset_input                     005046 constant        entry                    internal dcl 687 ref 506 683
trace_control                   005261 constant        entry                    internal dcl 755 ref 739 743 747 751
trace_mode                      005141 constant        entry                    internal dcl 721 ref 706 716
trace_output                    005564 constant        entry                    internal dcl 789 ref 434 474 476 630 861 862 902 904
warning                         007754 constant        entry                    internal dcl 1340 ref 416 422 492 638 652 665 676
                                                                                  726 734 762 781 997

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11520       11606   11156       11530
Length     12140   11156        66         316     342           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
abs_io_v1_get_line                  782 external procedure  is an external procedure.  
on unit on line 214                  64 on unit               
on unit on line 582                  88 on unit               
reset_input                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
trace_mode                              internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
trace_control                           internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
trace_output                            internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
get_ptrs                                internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
find_clause                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
conditional                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
attachedp                               internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
input_linep                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
functionp                               internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
emit_ec_name                            internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
emit_ec_dir                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
emit_ec_switch                          internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
emit_arg_count                          internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
predicate                               internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
copy_up_to_ampersand                    internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
copy_string                             internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
check_len                               internal procedure  shares stack frame of external procedure abs_io_v1_get_line.  
allocate_buffer                     110 internal procedure  enables or reverts conditions.  
on unit on line 1294                 88 on unit               
allocate_hash_table                  70 internal procedure  enables or reverts conditions.  
on unit on line 1314                 84 on unit               
error                               246 internal procedure  is called during a stack extension, and is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abs_io_v1_get_line       000114 old_IS_pos                  abs_io_v1_get_line
                         000115 CL_len                      abs_io_v1_get_line
                         000116 CL_pos                      abs_io_v1_get_line
                         000120 CL_ptr                      abs_io_v1_get_line
                         000122 not_in_CL                   abs_io_v1_get_line
                         000123 old_CL_pos                  abs_io_v1_get_line
                         000124 RS_len                      abs_io_v1_get_line
                         000125 RS_pos                      abs_io_v1_get_line
                         000126 RS_ptr                      abs_io_v1_get_line
                         000130 old_RS_len                  abs_io_v1_get_line
                         000131 arg_idx                     abs_io_v1_get_line
                         000132 break                       abs_io_v1_get_line
                         000133 buffer_allocated            abs_io_v1_get_line
                         000134 buffer_len                  abs_io_v1_get_line
                         000136 buffer_ptr                  abs_io_v1_get_line
                         000140 control                     abs_io_v1_get_line
                         000141 copy_len                    abs_io_v1_get_line
                         000142 from_sw                     abs_io_v1_get_line
                         000144 get_next_line               abs_io_v1_get_line
                         000150 hash                        abs_io_v1_get_line
                         000151 input_reset_sw              abs_io_v1_get_line
                         000152 iocb_ptr                    abs_io_v1_get_line
                         000154 len                         abs_io_v1_get_line
                         000155 quote_modifier              abs_io_v1_get_line
                         000156 start                       abs_io_v1_get_line
                         000157 state                       abs_io_v1_get_line
                         000160 saved_hash                  abs_io_v1_get_line
                         000162 saved_label_ptr             abs_io_v1_get_line
                         000164 saved_state                 abs_io_v1_get_line
                         000165 scanning_clause             abs_io_v1_get_line
                         000166 status                      abs_io_v1_get_line
                         000167 test                        abs_io_v1_get_line
                         000170 twoL                        abs_io_v1_get_line
                         000171 width                       abs_io_v1_get_line
                         000172 ready_mode                  abs_io_v1_get_line
                         000174 abs_data_ptr                abs_io_v1_get_line
                         000176 label_ptr                   abs_io_v1_get_line
                         000200 current_label_len           abs_io_v1_get_line
                         000202 current_label_ptr           abs_io_v1_get_line
                         000204 ec_data_ptr                 abs_io_v1_get_line
                         000242 switch                      trace_output
                         000260 keyword_pos                 find_clause
                         000261 start_keyword               find_clause
                         000270 AF_len                      conditional
                         000272 AF_ptr                      conditional
                         000274 bars_len                    conditional
                         000275 value                       conditional
                         000336 ec_dir_buf                  emit_ec_dir
                         000410 ec_dir_len                  emit_ec_dir
                         000420 ec_switch_len               emit_ec_switch
                         000430 arg_count_pic               emit_arg_count
                         000433 arg_count_len               emit_arg_count
                         000456 arg_pos                     copy_string
                         000457 quote_pos                   copy_string
                         000460 quote_len                   copy_string
                         000470 new_RS_len                  check_len
allocate_buffer          000100 new_RS_ptr                  allocate_buffer
error                    000100 complain                    error
                         000104 line_len                    error
                         000105 line_number                 error
                         000106 line_ptr                    error
                         000110 line_start                  error
                         000111 message                     error
                         000211 severity                    error
                         000212 status_ptr                  error
                         000214 who                         error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc return_mac          move_label_var
make_label_var      tra_ext_1           tra_ext_2           mdfx1               signal_op           enable_op
shorten_stack       ext_entry           int_entry           set_chars_eis       index_chars_eis     op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
abs_io_control$attach         abs_io_control$detach         abs_io_control$sleep          active_fnc_err_
com_err_                      cu_$arg_list_ptr              cu_$arg_ptr                   cu_$evaluate_active_string
cu_$set_ready_mode            hcs_$fs_get_path_name         ioa_$general_rs               ioa_$nnl
iox_$find_iocb                iox_$get_line                 iox_$put_chars                logout
signal_io_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$command_line_overflow                          error_table_$end_of_info      error_table_$long_record
error_table_$noalloc          iox_$user_input               iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     35 001311       194 001323       196 001325       200 001326       201 001331       203 001336       205 001357
    208 001360       211 001405       212 001407       214 001410       216 001430       220 001433       222 001435
    226 001437       230 001450       231 001451       232 001453       233 001454       237 001456       239 001465
    241 001467       244 001471       245 001472       246 001475       248 001476       251 001501       254 001504
    255 001507       256 001524       258 001525       259 001526       261 001527       262 001537       264 001540
    265 001543       266 001545       268 001547       270 001551       271 001561       272 001562       274 001564
    275 001567       284 001570       286 001602       287 001603       288 001605       290 001606       294 001614
    295 001626       296 001642       298 001653       300 001654       303 001656       305 001657       309 001665
    310 001713       312 001732       313 001751       314 001770       316 002006       318 002007       321 002010
    323 002011       326 002013       328 002014       331 002016       333 002017       334 002031       336 002035
    337 002037       339 002040       342 002047       343 002052       344 002054       346 002055       348 002061
    349 002062       350 002064       351 002065       354 002066       356 002067       357 002074       358 002103
    359 002104       361 002116       363 002120       364 002121       366 002123       367 002124       368 002137
    369 002162       370 002171       371 002173       372 002174       373 002217       374 002244       376 002246
    378 002247       379 002263       381 002264       382 002265       385 002266       388 002270       389 002273
    390 002275       391 002310       393 002311       394 002313       400 002315       404 002326       405 002337
    406 002340       407 002354       408 002365       410 002376       411 002417       412 002425       414 002427
    416 002431       421 002464       422 002465       427 002514       429 002516       430 002517       432 002521
    434 002523       437 002546       439 002550       441 002552       442 002553       443 002554       444 002555
    445 002556       447 002560       451 002572       452 002600       453 002606       456 002612       457 002616
    458 002621       460 002622       461 002625       462 002632       463 002640       464 002643       465 002644
    468 002646       471 002664       474 002667       476 002717       478 002741       480 002751       482 002753
    484 002755       486 002756       490 002763       492 002765       494 003005       497 003010       500 003032
    502 003035       504 003037       506 003041       509 003042       511 003053       512 003055       514 003060
    523 003061       525 003063       526 003064       528 003067       530 003075       532 003076       535 003120
    538 003125       540 003131       541 003147       545 003164       548 003176       549 003200       551 003203
    552 003205       554 003206       555 003210       556 003211       559 003212       561 003215       563 003226
    564 003242       568 003260       570 003261       571 003263       572 003264       573 003267       574 003271
    576 003277       577 003301       578 003302       580 003303       582 003306       584 003356       586 003375
    588 003376       590 003401       591 003403       592 003404       593 003407       594 003411       595 003414
    598 003415       600 003421       601 003431       603 003436       605 003441       607 003444       609 003463
    611 003465       612 003470       614 003523       617 003526       619 003527       622 003532       624 003535
    625 003537       627 003567       630 003611       632 003631       634 003632       636 003666       638 003670
    641 003713       643 003714       646 003721       647 003725       649 003727       651 003734       652 003736
    656 003771       657 004004       658 004005       660 004022       662 004023       665 004043       668 004066
    670 004102       671 004117       674 004140       676 004141       679 004164       681 004167       683 004170
    685 004171       704 004172       706 004173       708 004202       711 004224       712 004234       714 004243
    716 004244       718 004246       719 004256       739 004257       741 004266       743 004267       745 004276
    747 004277       749 004306       751 004307       753 004316       844 004317       847 004324       849 004352
    851 004354       852 004356       855 004360       857 004373       859 004375       861 004377       862 004416
    863 004433       864 004436       867 004445       869 004447       870 004451       871 004453       874 004454
    875 004457       877 004462       878 004475       880 004501       883 004504       884 004511       886 004513
    887 004525       888 004531       889 004535       890 004551       891 004554       895 004557       897 004565
    898 004570       900 004572       902 004574       904 004615       906 004632       908 004634       912 004643
    914 004645       916 004646       919 004651       921 004674       923 004676       925 004677       928 004717
    930 004721       931 004722       933 004723       935 004726       936 004730       938 004731       939 004744
    941 004750       943 004753       945 004755       948 005000       949 005003       951 005011       953 005013
    955 005014       960 005024       961 005025       962 005027       963 005031       966 005032       968 005036
    970 005040       973 005042       975 005045       687 005046       690 005047       692 005054       693 005071
    694 005112       696 005117       697 005137       701 005140       721 005141       724 005143       726 005146
    727 005166       730 005172       732 005204       733 005223       734 005235       736 005255       755 005261
    760 005263       762 005266       763 005306       764 005311       767 005312       768 005333       770 005345
    771 005364       772 005377       776 005420       777 005440       778 005475       779 005536       781 005540
    782 005560       785 005563       789 005564       797 005575       798 005602       800 005614       802 005616
    803 005637       805 005642       808 005666       809 005670       811 005671       818 005672       823 005674
    825 005701       827 005704       828 005711       830 005762       831 005770       832 005771       835 005772
    836 005774       837 005776       838 006001       840 006003       982 006004       989 006015       991 006017
    993 006033       995 006037       997 006041      1001 006111      1011 006115      1020 006117      1022 006133
   1024 006141      1027 006154      1028 006157      1030 006160      1033 006220      1034 006227      1036 006234
   1039 006310      1040 006352      1042 006413      1044 006437      1046 006450      1048 006460      1050 006504
   1055 006510      1058 006512      1064 006521      1067 006523      1069 006531      1075 006535      1078 006537
   1080 006545      1084 006551      1087 006552      1088 006556      1090 006576      1092 006577      1099 006600
   1100 006604      1101 006637      1103 006656      1105 006657      1111 006660      1112 006664      1114 006670
   1115 006703      1116 006721      1118 006722      1119 006736      1122 006754      1124 006755      1131 006756
   1132 006762      1133 006772      1134 007004      1136 007036      1138 007037      1144 007041      1145 007047
   1147 007057      1149 007062      1153 007063      1158 007065      1159 007070      1161 007071      1162 007073
   1165 007106      1166 007111      1168 007114      1170 007116      1174 007117      1183 007130      1185 007133
   1186 007137      1187 007156      1190 007157      1192 007160      1194 007174      1196 007175      1197 007176
   1198 007212      1199 007216      1200 007217      1202 007231      1203 007233      1204 007235      1205 007237
   1206 007242      1207 007245      1208 007251      1209 007252      1211 007253      1213 007255      1215 007261
   1216 007263      1217 007272      1220 007275      1222 007312      1224 007313      1225 007315      1226 007331
   1227 007335      1228 007337      1229 007346      1231 007351      1234 007352      1235 007355      1237 007356
   1238 007360      1241 007374      1244 007400      1245 007403      1246 007405      1248 007414      1250 007416
   1254 007417      1260 007421      1262 007424      1264 007434      1266 007436      1270 007437      1277 007445
   1278 007450      1280 007451      1283 007462      1284 007470      1285 007472      1288 007473      1289 007501
   1292 007530      1294 007532      1296 007575      1298 007606      1300 007607      1302 007615      1304 007627
   1305 007635      1307 007640      1311 007641      1314 007647      1316 007704      1318 007740      1320 007741
   1322 007742      1337 007750      1338 007752      1340 007753      1343 007761      1345 007763      1347 010004
   1349 010062      1350 010063      1353 010073      1354 010110      1355 010114      1356 010115      1357 010120
   1359 010124      1361 010130      1362 010135      1363 010156      1365 010157      1368 010176      1369 010204
   1370 010210      1373 010215      1376 010301      1378 010304      1379 010311      1380 010316      1383 010320
   1385 010322


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
