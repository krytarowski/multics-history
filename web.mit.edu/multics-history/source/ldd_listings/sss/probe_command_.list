	COMPILATION LISTING OF SEGMENT probe_command_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1133.04_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       13 
       14 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(87-06-18,RWaters), approve(87-06-18,MCR7687), audit(87-06-24,Huen),
       18*     install(87-07-15,MR12.1-1040):
       19*     Probe error #107: correctly implement source path PATH.
       20*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       21*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       22*     Added format control comment to make the source more readable.
       23*  3) change(88-10-21,WAAnderson), approve(88-10-21,MCR7952),
       24*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
       25*     Modified code to implement a C feature. If the user specifes 'seg' instead
       26*     of 'seg$main', probe will now assume the user wants 'seg$main' if no
       27*     statement map is found for 'seg'.  This is not particularily elegant
       28*     because it will try using the 'seg$main' convention for any object,
       29*     regardless of the compiler used to generate the object.  Other modules
       30*     affected to implement this feature are 'probe_find_procedure_' and
       31*     'probe_seg_info_'. The include 'probe_info.incl.pl1' was modified to
       32*     include the new file 'retry_using_main'.
       33*                                                   END HISTORY COMMENTS */
       34 
       35 
       36 probe_command_:
       37   procedure options (variable);
       38 
       39   /* *	Command procedure for the "probe" debugger. It does hardly anything at all, just
       40*   *	creates the global data structure and calls the probe listener. The code for the
       41*   *	"halt" request also appears here, since it must invoke the listener, as does the
       42*   *	code for responding to breakpoints. */
       43 
       44   /* Improved error message if can't get ptr to break seg 08/31/81 S. Herbst */
       45   /* Changed to call probe_break_mgr_$reset_all_pause_breaks on cleanup 04/19/84 S. Herbst */
       46   /* Changed to omit epilogue when returning if previous error occurred during "quit" 01/15/85 Steve Herbst */
       47   /* Fixed to correctly implement source path PATH 05/21/87 RWaters */
       48 
       49 
       50   dcl code		fixed bin (35);
       51   dcl alp			pointer;
       52 
       53   dcl cu_$arg_count_rel	entry (fixed bin, ptr);
       54   dcl cu_$arg_list_ptr	entry (ptr);
       55   dcl cu_$arg_ptr_rel	entry (fixed bin, pointer, fixed bin,
       56 			fixed bin (35), ptr);
       57 
       58   dcl have_we_greeted	bit (1) aligned internal static init ("0"b);
       59   dcl ioa_		entry options (variable);
       60   dcl probe_data_$greeting_msg
       61 			char (256) varying external static;
       62   dcl probe_data_$version_string
       63 			char (32) aligned external static;
       64 
       65 
       66   dcl probe_announce_entry_	entry (pointer);
       67   dcl probe_break_mgr_$reset_all_pause_breaks
       68 			entry (ptr);
       69   dcl probe_error_		entry options (variable);
       70   dcl probe_error_$warning	entry options (variable);
       71   dcl probe_error_$malfunction
       72 			entry options (variable);
       73   dcl probe_find_procedure_	entry (ptr, char (*), bit (36) aligned, ptr,
       74 			fixed bin (35));
       75   dcl probe_listen_		entry (ptr, fixed bin (35));
       76   dcl probe_subsys_util_$create_invocation
       77 			entry (fixed bin, ptr, fixed bin (35));
       78   dcl probe_subsys_util_$destroy_invocation
       79 			entry (ptr);
       80   dcl probe_stack_trace_$where_source_info
       81 			entry (ptr, ptr, fixed bin, char (*));
       82   dcl probe_stack_trace_$condition_raised
       83 			entry (ptr, ptr, char (32));
       84   dcl probe_stack_trace_$find_condition_frame
       85 			entry (ptr, ptr, char (32));
       86   dcl probe_stack_trace_$find_frame
       87 			entry (ptr, ptr, ptr);
       88 
       89   dcl (
       90       error_table_$noarg,
       91       error_table_$action_not_performed,
       92       error_table_$badopt
       93       )			fixed bin (35) external static;
       94 
       95   dcl cleanup		condition;
       96 
       97   dcl (addr, null, stackframeptr, substr)
       98 			builtin;
       99 
      100   /*  */
      101 
      102   probe_info_ptr = null ();
      103 
      104   on cleanup
      105     begin;
      106     call probe_break_mgr_$reset_all_pause_breaks (probe_info_ptr);
      107     call clean_things_up ();
      108   end;
      109 
      110   call probe_subsys_util_$create_invocation
      111        (probe_info_version, probe_info_ptr, code);
      112   if code ^= 0 then do;
      113       if code ^= error_table_$action_not_performed
      114         then /* haven't already printed message about breakseg */
      115 	   call probe_error_$malfunction (probe_info_ptr, code,
      116 	        "Unable to initialize probe.");
      117       call clean_things_up ();
      118       return;
      119     end;
      120 
      121   probe_info.abort_probe_label = PROBE_COMMAND_RETURNS;
      122 				/* for handling initialization errors, mostly */
      123   probe_info.abort_line_label = PROBE_COMMAND_RETURNS;
      124   probe_info.current_stack_frame = stackframeptr ();
      125   probe_static_info.good_stack = "0"b;	/* stack is a new beast */
      126 
      127   call cu_$arg_list_ptr (alp);
      128 
      129 
      130   if ^have_we_greeted then do;
      131       have_we_greeted = "1"b;
      132       if probe_data_$greeting_msg ^= ""
      133         then call ioa_ ("^a - ^a", probe_data_$version_string,
      134 	        probe_data_$greeting_msg);
      135     end;
      136 
      137   call process_command_arguments (alp);
      138 
      139   call probe_listen_ (probe_info_ptr, (0));
      140 				/* do it */
      141 
      142 PROBE_COMMAND_RETURNS:
      143   if probe_info.executing_quit_request
      144     then
      145          return;			/* don't chance looping with another error */
      146 
      147   if probe_info.return_method = RETURN_TO_CONDITION then do;
      148       call probe_error_$warning (probe_info_ptr, 0,
      149 	 "Temporary restriction: unable to restart conditions. Use the start command instead."
      150 	 );
      151       probe_info.return_method = RETURN_TO_CALLER;
      152     end;
      153 
      154   call clean_things_up ();
      155   return;				/* end of code for probe command */
      156 
      157   /*  */
      158 
      159 clean_things_up:
      160   proc ();
      161 
      162   if probe_info_ptr ^= null () then do; /* invalidate the saved stack */
      163       if addr (probe_static_info) ^= null ()
      164         then
      165 	   probe_static_info.good_stack = "0"b;
      166     end;
      167 
      168   call probe_subsys_util_$destroy_invocation (probe_info_ptr);
      169   return;
      170   end;				/* internal procedure clean_things_up */
      171 
      172   /*  */
      173 
      174 process_command_arguments:
      175   proc (P_alp) options (non_quick);
      176 
      177   /* *	This procedure is used to process the command-line arguments. */
      178 
      179   dcl P_alp		pointer parameter;
      180 
      181   dcl al			fixed bin;
      182   dcl ap			pointer;
      183   dcl arg			character (al) based (ap);
      184 				/* argument as returned by cu_$arg_ptr */
      185   dcl procedure_arg		char (200);
      186   dcl (argno, nargs)	fixed bin;
      187   dcl cond_name		char (32);
      188 
      189 
      190 
      191   procedure_arg = "";		/* start out empty */
      192 
      193   call cu_$arg_count_rel (nargs, P_alp);/* get number of arguments that we were called with */
      194 
      195   do argno = 1 to nargs;		/* loop through our arguments */
      196     call cu_$arg_ptr_rel (argno, ap, al, (0), P_alp);
      197 
      198     if substr (arg, 1, 1) ^= "-" then do;
      199 				/* a procedure name */
      200 PROCESS_PROCEDURE_NAME:
      201         if procedure_arg ^= ""
      202 	then /* punt if we already have one */
      203 	     call probe_error_ (probe_info_ptr, 0,
      204 		"At most one procedure may be specified. ^a", arg);
      205 
      206         procedure_arg = arg;		/* remember it */
      207       end;
      208 
      209       else do;			/* otherwise, process a control argument */
      210         if arg = "-name" | arg = "-nm" then do;
      211 	  if argno = nargs
      212 	    then call probe_error_
      213 		    (probe_info_ptr, error_table_$noarg,
      214 		    "A procedure name must follow ""^a"".", arg);
      215 
      216 	  argno = argno + 1;	/* get the procedure name */
      217 	  call cu_$arg_ptr_rel (argno, ap, al, (0), P_alp);
      218 	  goto PROCESS_PROCEDURE_NAME;/* and process it */
      219 	end;
      220 
      221         else if arg = "-brief" | arg = "-bf"
      222 	then probe_static_info.brief_sw = "1"b;
      223         else if arg = "-long" | arg = "-lg"
      224 	then probe_static_info.brief_sw = "0"b;
      225 
      226         else if arg = "-no_handle_conditions"
      227 	then probe_static_info.no_handle_faults_sw = "1"b;
      228         else if arg = "-handle_conditions"
      229 	then probe_static_info.no_handle_faults_sw = "0"b;
      230 
      231         else if arg = "-recursive_breaks"
      232 	then probe_static_info.recursive_breaks_sw = "1"b;
      233         else if arg = "-no_recursive_breaks"
      234 	then probe_static_info.recursive_breaks_sw = "0"b;
      235 
      236         else call probe_error_ (probe_info_ptr, error_table_$badopt, """^a""",
      237 	        arg);
      238       end;			/* of control arg case */
      239   end;				/* of loop through arguments */
      240 
      241   if procedure_arg ^= "" then do;	/* user specified a procedure, use it */
      242 
      243       probe_info.retry_using_main = 0;  
      244 
      245       call probe_find_procedure_ (probe_info_ptr, procedure_arg, "111"b,
      246 	 probe_info.ptr_to_initial_source, code);
      247 
      248 /* A kludge. If no statement map and no explicit entry point given, try */
      249 /* the same operation using procedure_arg$main. This is implemented for */
      250 /* the convienience of C programmers.                                   */
      251 
      252       if (probe_info.retry_using_main = 1 & index(procedure_arg,"$") = 0) then do;
      253           procedure_arg = rtrim(procedure_arg) || "$main";
      254           code = 0;
      255           call probe_find_procedure_ (probe_info_ptr, procedure_arg, "111"b,
      256   	 probe_info.ptr_to_initial_source, code);
      257        end;
      258 
      259       if code ^= 0
      260         then call probe_error_ (probe_info_ptr, code);
      261 				/* procedure seems to be losing */
      262 
      263       if initial_source.stack_ptr = null ()
      264         then /* figure out what to do upon return */
      265 	   probe_info.return_method = RETURN_TO_CALLER;
      266 				/* no active frame */
      267 
      268         else do;
      269 	call probe_stack_trace_$condition_raised
      270 	     (probe_info_ptr, probe_info.ptr_to_initial_source, cond_name);
      271 
      272 	if cond_name = ""
      273 	  then probe_info.return_method = RETURN_TO_FRAME;
      274 				/* just has invocation on the stack */
      275 	  else probe_info.return_method = RETURN_TO_CONDITION;
      276 				/* faulted out */
      277         end;
      278     end;				/* processing procedure arg */
      279 
      280     else do;			/* no arg, look for a fault frame */
      281       call probe_stack_trace_$find_condition_frame (probe_info_ptr,
      282 	 probe_info.ptr_to_initial_source, cond_name);
      283       if initial_source.entry_ptr ^= null ()
      284         then /* found a condition frame, use it */
      285 	   probe_info.return_method = RETURN_TO_CONDITION;
      286         else do;			/* no fault on stack -use last frame */
      287 	call probe_stack_trace_$find_frame (probe_info_ptr,
      288 	     probe_info.ptr_to_initial_source,
      289 	     probe_info.current_stack_frame -> stack_frame.prev_sp);
      290 	probe_info.return_method = RETURN_TO_FRAME;
      291         end;
      292     end;				/* making implicit definition */
      293 
      294   current_source = initial_source;	/* they start out the same */
      295   current_source.seg_info_ptr -> seg_info.file_pointers (*) = null ();
      296 				/* start out null */
      297   probe_info.language_type =
      298        current_source.seg_info_ptr -> seg_info.language_type;
      299 
      300   call probe_announce_entry_ (probe_info_ptr);
      301 				/* announce our arrival */
      302   end;				/* process_command_args internal procedure */
      303 
      304   /*  */
      305 
      306   /*	INCLUDE FILES	*/
      307 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      308 
      309 
      310   /* ;;;;;;; */
      311 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      312 
      313 
      314   /* ;;;;;;; */
      315 
  3     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  3     2*
  3     3*  James R. Davis 2 July 79 */
  3     4 
  3     5 dcl 1 source_info based aligned,
  3     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  3     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  3     8       2 block_ptr ptr,				/* to runtime_block node */
  3     9       2 stack_ptr ptr,				/* to a stack frame */
  3    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  3    11       2 seg_info_ptr ptr;				/* to seg_info */
  3    12 
  3    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  3    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  3    15 
  3    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      316 
      317 
      318   /* ;;;;;;; */
      319 
  4     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  4     2*
  4     3*   25 June 79 JRDavis
  4     4*
  4     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  4     6*	correction per file.
  4     7**/
  4     8 
  4     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  4    10     2 language_type fixed bin,			/* language of source program */
  4    11     2 bits aligned,
  4    12       3 ignore_case bit (1) unal,
  4    13       3 bound_segment bit (1) unaligned,
  4    14       3 component bit (1) unaligned,
  4    15       3 pad bit (33) unal,
  4    16     2 names,					/* where to find it */
  4    17       3 directory_name character (168) unal,		/* what directory */
  4    18       3 entry_name character (32) unal,			/* what segment */
  4    19       3 segname character (32) unal,			/* procedure segname definition */
  4    20     2 identifier fixed bin (71),			/* time of object creation */
  4    21     2 pointers,					/* location of various parts of segment */
  4    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  4    23       3 original_source_ptr ptr unal,			/* to segment source map */
  4    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  4    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  4    26*						   bound ones, -> break_map !obsolete, I think! */
  4    27       3 chain ptr unal,				/* to entry for next component if bound */
  4    28       3 linkage_ptr ptr unal,				/* to linkage section */
  4    29     2 bounds aligned,				/* structure of bounds information */
  4    30       3 text_bounds,
  4    31         4 start fixed bin (35),
  4    32         4 end fixed bin (35),
  4    33       3 symbol_bounds,
  4    34         4 start fixed bin (35),
  4    35         4 end fixed bin (35),
  4    36     2 map_size fixed bin,				/* size of statement map */
  4    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  4    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  4    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  4    40     2 pad (1) fixed bin (35),
  4    41 
  4    42     2 nfiles fixed bin,
  4    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  4    44       3 file_pointers ptr unal,
  4    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  4    46 
  4    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      320 
      321 
      322   /* ;;;;;;; */
      323 
  5     1 /*	BEGIN INCLUDE FILE probe_info_constants.incl.pl1	*/
  5     2 /*	Created: 06/25/79 W. Olin Sibert		*/
  5     3 
  5     4 dcl (RETURN_TO_CALLER init (1),			/* return methods */
  5     5      RETURN_TO_FRAME init (2),
  5     6      RETURN_TO_CONDITION init (3),
  5     7      RETURN_TO_BREAK init (4)) fixed bin internal static options (constant);
  5     8 
  5     9 dcl (ENTRY_AT_CALL init (1),				/* entered by a call to probe */
  5    10      ENTRY_AT_BREAK init (2), 			/* entered by a call to probe$break */
  5    11      ENTRY_AT_HALT init (3)) fixed bin internal static options (constant); /* entered by a call to probe$halt */
  5    12 
  5    13 dcl (CONSOLE_INPUT init (1),
  5    14      BREAK_INPUT init (2),
  5    15      MACRO_INPUT init (3)) fixed bin internal static options (constant);
  5    16 
  5    17 /*	END INCLUDE FILE probe_info_constants.incl.pl1	*/
      324 
      325 
      326   /* ;;;;;;; */
      327 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  6     2 
  6     3 /* format: off */
  6     4 
  6     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  6     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  6     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  6     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  6     9 
  6    10 
  6    11 /****^  HISTORY COMMENTS:
  6    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  6    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  6    14*     Modified to add constants for the translator_id field in the stack_frame
  6    15*     structure.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 
  6    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  6    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  6    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  6    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  6    23 
  6    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  6    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  6    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  6    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  6    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  6    29 
  6    30 
  6    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  6    32 
  6    33 dcl  stack_frame_min_length fixed bin static init(48);
  6    34 
  6    35 
  6    36 dcl 1 stack_frame based(sp) aligned,
  6    37     2 pointer_registers(0 : 7) ptr,
  6    38     2 prev_sp pointer,
  6    39     2 next_sp pointer,
  6    40     2 return_ptr pointer,
  6    41     2 entry_ptr pointer,
  6    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  6    43     2 arg_ptr pointer,
  6    44     2 static_ptr ptr unaligned,
  6    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  6    46     2 on_unit_relp1 bit(18) unaligned,
  6    47     2 on_unit_relp2 bit(18) unaligned,
  6    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  6    49*						   0 => PL/I version II
  6    50*						   1 => ALM
  6    51*						   2 => PL/I version I   
  6    52*						   3 => signal caller frame
  6    53*						   4 => signaller frame */
  6    54     2 operator_return_offset bit(18) unaligned,
  6    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  6    56     2 a bit(36),					/* accumulator */
  6    57     2 q bit(36),					/* q-register */
  6    58     2 e bit(36),					/* exponent */
  6    59     2 timer bit(27) unaligned,				/* timer */
  6    60     2 pad bit(6) unaligned,
  6    61     2 ring_alarm_reg bit(3) unaligned;
  6    62 
  6    63 
  6    64 dcl 1 stack_frame_flags based(sp) aligned,
  6    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  6    66     2 xx0 bit(22) unal,
  6    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  6    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  6    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  6    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  6    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  6    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  6    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  6    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  6    75     2 xx0a bit(6) unal,
  6    76     2 xx1 fixed bin,
  6    77     2 xx2 fixed bin,
  6    78     2 xx3 bit(25) unal,
  6    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  6    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  6    81     2 xx3a bit(9) unaligned,
  6    82     2 xx4(9) bit(72) aligned,
  6    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  6    84*						*  operator puts a pointer to the base of
  6    85*						*  the calling procedure here. (text base ptr)  */
  6    86     2 xx5 bit(72) aligned,
  6    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  6    88 
  6    89 /* format: on */
  6    90 
  6    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      328 
      329 
      330   end;				/* probe_command_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1133.0  probe_command_.pl1                >udd>sm>ds>w>ml>probe_command_.pl1
308          1    10/27/88  1439.2  probe_info.incl.pl1               >ldd>incl>probe_info.incl.pl1
312          2    11/12/82  1724.3  probe_static_info.incl.pl1        >ldd>incl>probe_static_info.incl.pl1
316          3    11/26/79  1420.6  probe_source_info.incl.pl1        >ldd>incl>probe_source_info.incl.pl1
320          4    11/02/83  1945.0  probe_seg_info.incl.pl1           >ldd>incl>probe_seg_info.incl.pl1
324          5    11/26/79  1420.9  probe_info_constants.incl.pl1     >ldd>incl>probe_info_constants.incl.pl1
328          6    11/07/86  1650.3  stack_frame.incl.pl1              >ldd>incl>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_alp                                  parameter       pointer                  dcl 179 set ref 174 193* 196* 217*
RETURN_TO_CALLER                       constant        fixed bin(17,0)          initial dcl 5-4 ref 151 263
RETURN_TO_CONDITION                    constant        fixed bin(17,0)          initial dcl 5-4 ref 147 275 283
RETURN_TO_FRAME                        constant        fixed bin(17,0)          initial dcl 5-4 ref 272 290
abort_line_label        226            based           label variable           level 3 dcl 1-18 set ref 123*
abort_probe_label       222            based           label variable           level 3 dcl 1-18 set ref 121*
addr                                                   builtin function         dcl 97 ref 163
al                              000100 automatic       fixed bin(17,0)          dcl 181 set ref 196* 198 200 200 206 210 210 211 211
                                                                                  217* 221 221 223 223 226 228 231 233 236 236
alp                             000102 automatic       pointer                  dcl 51 set ref 127* 137*
ap                              000102 automatic       pointer                  dcl 182 set ref 196* 198 200 206 210 210 211 217*
                                                                                  221 221 223 223 226 228 231 233 236
arg                                    based           char                     packed unaligned dcl 183 set ref 198 200* 206 210
                                                                                  210 211* 221 221 223 223 226 228 231 233 236*
argno                           000166 automatic       fixed bin(17,0)          dcl 186 set ref 195* 196* 211 216* 216 217*
brief_sw                 36            based           bit(1)                   level 3 packed packed unaligned dcl 2-8 set ref 221*
                                                                                  223*
cleanup                         000104 stack reference condition                dcl 95 ref 104
code                            000100 automatic       fixed bin(35,0)          dcl 50 set ref 110* 112 113 113* 245* 254* 255* 259
                                                                                  259*
cond_name                       000170 automatic       char(32)                 packed unaligned dcl 187 set ref 269* 272 281*
cu_$arg_count_rel               000012 constant        entry                    external dcl 53 ref 193
cu_$arg_list_ptr                000014 constant        entry                    external dcl 54 ref 127
cu_$arg_ptr_rel                 000016 constant        entry                    external dcl 55 ref 196 217
current_source                         based           structure                level 1 dcl 3-13 set ref 294*
current_stack_frame      17            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref
                                                                                  124* 287
entry_ptr                10            based           pointer                  level 2 dcl 3-14 ref 283
error_table_$action_not_performed
                                000060 external static fixed bin(35,0)          dcl 89 ref 113
error_table_$badopt             000062 external static fixed bin(35,0)          dcl 89 set ref 236*
error_table_$noarg              000056 external static fixed bin(35,0)          dcl 89 set ref 211*
executing_quit_request
                         64(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 142
file_pointers           117            based           pointer                  array level 3 packed packed unaligned dcl 4-9 set
                                                                                  ref 295*
flags                    52            based           structure                level 3 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_command_"
flags                    64            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_command_"
good_stack               52            based           bit(1)                   level 4 packed packed unaligned dcl 2-8 set ref 125*
                                                                                  163*
have_we_greeted                 000010 internal static bit(1)                   initial dcl 58 set ref 130 131*
initial_source                         based           structure                level 1 dcl 3-14 ref 294
ioa_                            000020 constant        entry                    external dcl 59 ref 132
language_type                          based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_command_" ref 297
language_type            21            based           fixed bin(17,0)          level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_command_" set ref 297*
listener_info           210            based           structure                level 2 dcl 1-18
nargs                           000167 automatic       fixed bin(17,0)          dcl 186 set ref 193* 195 211
nfiles                  116            based           fixed bin(17,0)          level 2 dcl 4-9 ref 295
no_handle_faults_sw      36(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-8 set ref 226*
                                                                                  228*
null                                                   builtin function         dcl 97 ref 102 162 163 263 283 295
per_file                117            based           structure                array level 2 dcl 4-9
prev_sp                  20            based           pointer                  level 2 dcl 6-36 set ref 287*
probe_announce_entry_           000026 constant        entry                    external dcl 66 ref 300
probe_break_mgr_$reset_all_pause_breaks
                                000030 constant        entry                    external dcl 67 ref 106
probe_data_$greeting_msg        000022 external static varying char(256)        dcl 60 set ref 132 132*
probe_data_$version_string      000024 external static char(32)                 dcl 62 set ref 132*
probe_error_                    000032 constant        entry                    external dcl 69 ref 200 211 236 259
probe_error_$malfunction        000036 constant        entry                    external dcl 71 ref 113
probe_error_$warning            000034 constant        entry                    external dcl 70 ref 148
probe_find_procedure_           000040 constant        entry                    external dcl 73 ref 245 255
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000112 automatic       pointer                  dcl 1-86 set ref 102* 106* 110* 113* 121 123 124 125
                                                                                  139* 142 147 148* 151 162 163 163 168* 200* 211*
                                                                                  221 223 226 228 231 233 236* 243 245* 245 252 255*
                                                                                  255 259* 263 263 269* 269 272 275 281* 281 283 283
                                                                                  287* 287 287 290 294 294 295 297 297 300*
probe_info_version              000022 constant        fixed bin(17,0)          initial dcl 1-88 set ref 110*
probe_listen_                   000042 constant        entry                    external dcl 75 ref 139
probe_stack_trace_$condition_raised
                                000050 constant        entry                    external dcl 82 ref 269
probe_stack_trace_$find_condition_frame
                                000052 constant        entry                    external dcl 84 ref 281
probe_stack_trace_$find_frame   000054 constant        entry                    external dcl 86 ref 287
probe_static_info                      based           structure                level 1 dcl 2-8 set ref 163
probe_subsys_util_$create_invocation
                                000044 constant        entry                    external dcl 76 ref 110
probe_subsys_util_$destroy_invocation
                                000046 constant        entry                    external dcl 78 ref 168
procedure_arg                   000104 automatic       char(200)                packed unaligned dcl 185 set ref 191* 200 206* 241
                                                                                  245* 252 253* 253 255*
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 294 295 297
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 set ref 245* 255* 263 269* 281* 283
                                                                                  287* 294
random_info              17            based           structure                level 2 dcl 1-18
recursive_breaks_sw      36(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-8 set ref 231*
                                                                                  233*
retry_using_main        240            based           fixed bin(17,0)          level 2 dcl 1-18 set ref 243* 252
return_method            22            based           fixed bin(17,0)          level 3 dcl 1-18 set ref 147 151* 263* 272* 275*
                                                                                  283* 290*
seg_info                               based           structure                level 1 dcl 4-9
seg_info_ptr             12            based           pointer                  level 2 dcl 3-13 set ref 295 297
source_info                            based           structure                level 1 dcl 3-5
stack_frame                            based           structure                level 1 dcl 6-36
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                 6            based           pointer                  level 2 dcl 3-14 ref 263
stackframeptr                                          builtin function         dcl 97 ref 124
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 125 163
                                                                                  163 221 223 226 228 231 233
substr                                                 builtin function         dcl 97 ref 198
switches                 36            based           structure                level 2 dcl 2-8

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BREAK_INPUT                            internal static fixed bin(17,0)          initial dcl 5-13
CONSOLE_INPUT                          internal static fixed bin(17,0)          initial dcl 5-13
ENTRY_AT_BREAK                         internal static fixed bin(17,0)          initial dcl 5-9
ENTRY_AT_CALL                          internal static fixed bin(17,0)          initial dcl 5-9
ENTRY_AT_HALT                          internal static fixed bin(17,0)          initial dcl 5-9
MACRO_INPUT                            internal static fixed bin(17,0)          initial dcl 5-13
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 6-19
RETURN_TO_BREAK                        internal static fixed bin(17,0)          initial dcl 5-4
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 6-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 6-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 6-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 6-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 6-27
expression_area                        based           area(1024)               dcl 1-95
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
probe_stack_trace_$where_source_info
                                000000 constant        entry                    external dcl 80
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 4-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 6-31
stack_frame_flags                      based           structure                level 1 dcl 6-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 6-33
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
PROBE_COMMAND_RETURNS           000361 constant        label                    dcl 142 ref 121 123
PROCESS_PROCEDURE_NAME          000541 constant        label                    dcl 200 ref 218
clean_things_up                 000426 constant        entry                    internal dcl 159 ref 107 117 154
probe_command_                  000150 constant        entry                    external dcl 36
process_command_arguments       000463 constant        entry                    internal dcl 174 ref 137

NAMES DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 252
rtrim                                                  builtin function         ref 253

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1732        2016    1402        1742
Length      2344    1402        64         312     330           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_command_                      125 external procedure  is an external procedure.  
on unit on line 104                  68 on unit               
clean_things_up                      72 internal procedure  is called by several nonquick procedures.  
process_command_arguments           190 internal procedure  is declared options(non_quick).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 have_we_greeted             probe_command_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_command_           000100 code                        probe_command_
                         000102 alp                         probe_command_
                         000112 probe_info_ptr              probe_command_
process_command_arguments
                         000100 al                          process_command_arguments
                         000102 ap                          process_command_arguments
                         000104 procedure_arg               process_command_arguments
                         000166 argno                       process_command_arguments
                         000167 nargs                       process_command_arguments
                         000170 cond_name                   process_command_arguments

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_count_rel             cu_$arg_list_ptr              cu_$arg_ptr_rel               ioa_
probe_announce_entry_         probe_break_mgr_$reset_all_pause_breaks                     probe_error_
probe_error_$malfunction      probe_error_$warning          probe_find_procedure_         probe_listen_
probe_stack_trace_$condition_raised                         probe_stack_trace_$find_condition_frame
probe_stack_trace_$find_frame probe_subsys_util_$create_invocation
probe_subsys_util_$destroy_invocation

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$badopt           error_table_$noarg
probe_data_$greeting_msg      probe_data_$version_string




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000147       102 000155       104 000157       106 000173       107 000202       108 000207       110 000210
    112 000223       113 000225       117 000253       118 000257       121 000260       123 000264       124 000267
    125 000271       127 000274       130 000304       131 000307       132 000311       137 000341       139 000347
    142 000361       147 000365       148 000370       151 000415       154 000420       155 000424       159 000425
    162 000433       163 000440       168 000453       169 000461       174 000462       191 000470       193 000473
    195 000504       196 000513       198 000534       200 000541       206 000602       207 000607       210 000610
    211 000621       216 000660       217 000661       218 000702       221 000703       223 000721       226 000737
    228 000751       231 000763       233 000775       236 001007       239 001042       241 001044       243 001050
    245 001053       252 001105       253 001123       254 001151       255 001153       259 001205       263 001225
    269 001237       272 001252       275 001263       278 001267       281 001270       283 001305       287 001317
    290 001333       294 001337       295 001344       297 001363       300 001365       302 001374


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
