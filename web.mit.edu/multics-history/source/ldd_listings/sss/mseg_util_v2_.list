	COMPILATION LISTING OF SEGMENT mseg_util_v2_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1120.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mseg_util_v2_: proc;
       12 
       13 /* Adapted from the original version 2 mseg_util_ by J. Stern, 11/4/74 */
       14 
       15 dcl (a_mptr,					/* pointer to the message segment */
       16      prev_tr_ptr,					/* pointer to previous message trailer */
       17      next_tr_ptr,					/* pointer to next message trailer */
       18      ms_ptr,					/* pointer to message wanted */
       19      a_ret_ptr,					/* pointer to returned message */
       20      ret_ptr init (null),
       21      deletep,					/* pointer to block to be zeroed out */
       22      t_ptr,					/* scan pointer for returning message */
       23      a_area_ptr,					/* pointer to allocated area */
       24      a_ms_ptr,					/* pointer to updating message */
       25      area_ptr) ptr;
       26 
       27 dcl (last,					/* ON if message is last in block */
       28      first,					/* ON if message is first in block */
       29      update,					/* ON if message is being updated */
       30      ms_end,					/* ON when end of message is found */
       31      read,					/* ON if message is to be read */
       32      delete) bit (1) aligned;				/* on if message is to be deleted */
       33 
       34 dcl (tr_offset,					/* offset from beginning of block to trailer */
       35      ms_count,					/* number of messages in segment */
       36      mseg_data_v2_$block_trailer_data ext,			/* number of data words in block trailer */
       37      mseg_data_v2_$block_hdr_data ext,			/* number of data words in block header */
       38      prev_offset,					/* offset to previous message */
       39      next_offset,					/* offset to next message */
       40      block_size,					/* size of a message block */
       41      blocks_in_message,				/* number of blocks used for message */
       42      blocks_left,					/* number of free blocks in message segment */
       43      copy_size,					/* size of bit copy mask */
       44      delete_size,					/* bit size of block to be zeroed out */
       45      incr_size,					/* for stepping copy-to pointer */
       46      a_ms_len,					/* length of message in block trailer */
       47      ms_len,
       48      found_ms_len,					/* actual message size */
       49      a_loc,					/* location of message */
       50      loc,
       51      a_ret_loc,					/* location of incremental message */
       52      bit_off) fixed bin (18);				/* location of allocation bit to be turned off */
       53 
       54 dcl (a_ms_wanted,					/* flag telling which message is wanted */
       55      ms_wanted,
       56      a_dir,					/* direction of incremental search */
       57      dir init ("0"b)) bit (2) aligned;
       58 
       59 dcl (
       60      mseg_data_v2_$mseg_tr36 ext
       61      ) bit (36) aligned;
       62 
       63 dcl (a_time,					/* time message was sent */
       64      a_ret_time,
       65      time) fixed bin (54);
       66 
       67 dcl (
       68      a_level,					/* user level: 0 = non-own entry, 1 = own entry (argument) */
       69      alloc_len,					/* length of allocation bit string */
       70      level,					/* user level: 0 = non-own entry, 1 = own entry (internal) */
       71      a_user_level,					/* the callers' initial level */
       72      user_level,
       73      ms_word_len,					/* length of message in words */
       74      zero_words (8) int static init (0, 0, 0, 0, 0, 0, 0, 0), /* for uid credibility check */
       75      name_len) fixed bin;				/* length of person-project portion of group id */
       76 
       77 dcl (
       78      a_code,					/* error code (argument) */
       79      code						/* error code (internal) */
       80      ) fixed bin (35);
       81 
       82 dcl (addr, addrel, bit, divide, fixed, index, null, ptr, rel, substr) builtin;
       83 
       84 dcl (
       85      cleanup
       86      ) condition;
       87 
       88 dcl  area_array area (30) aligned based (area_ptr),	/* for allocating */
       89      ms_word_array (ms_word_len) fixed bin aligned based (ret_ptr);
       90 
       91 dcl (caller_id,					/* id of caller */
       92      ms_sender_id) char (32) aligned;			/* id of message sender */
       93 
       94 dcl  a_sender_id char (32) aligned;			/* id of message sender */
       95 
       96 dcl  bit_copy_mask bit (copy_size) based;		/* bit copy mask */
       97 
       98 dcl  bits (incr_size) bit (1) based unaligned;		/* for resetting copy-to pointer */
       99 
      100 dcl  zeroes char (32) aligned based (addr (zero_words (1))); /* for uid credibility check */
      101 
  1     1 /* BEGIN include file mseg_hdr_v2.incl.pl1 */
  1     2 
  1     3 dcl  mptr ptr,					/* pointer to message segment */
  1     4 
  1     5      1 mseg_hdr_v2 aligned based (mptr),		/* message segment header format */
  1     6      2 lock bit (36) aligned,				/* standard file system lock */
  1     7      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     8      2 pad (6) fixed bin,
  1     9      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    10      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    11      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    12      2 space_left fixed bin,				/* number of empty blocks */
  1    13      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    14      2 block_size fixed bin,				/* message block size */
  1    15      2 switches,
  1    16      3 aip bit (1) unaligned,				/* ON if allocation is in progress */
  1    17      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    18      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    19      3 pad2 bit (30) unaligned,
  1    20      2 version_number fixed bin,
  1    21      2 hdr_ms_len fixed bin,				/* length of header message, if any */
  1    22      2 hdr_ms,					/* space for header message */
  1    23      3 filler (126) fixed bin,
  1    24      3 hdr_ms_end fixed bin,
  1    25      2 alloc_bits bit (alloc_len) aligned;		/* allocation bit string */
  1    26 
  1    27 /* END include file mseg_hdr_v2.incl.pl1 */
      102 
      103 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
      104 
      105 
  3     1 /* BEGIN include file ms_block_trailer_v2.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer_v2 aligned based (tr_ptr),	/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ms_size bit (18) unaligned,			/* bit count of message */
  3    10      2 time bit (54) unaligned,			/* time message was sent */
  3    11      2 ring_no bit (18) unaligned,			/* validation level */
  3    12      2 pad bit (18) unaligned,
  3    13      2 sender_id char (32) aligned;			/* id of message sender */
  3    14 
  3    15 /* END include file ms_block_trailer_v2.incl.pl1 */
      106 
      107 
      108 dcl  error_table_$bad_segment ext fixed bin (35);
      109 dcl  error_table_$moderr ext fixed bin (35);
      110 dcl  error_table_$no_message ext fixed bin (35);
      111 
      112 dcl  get_group_id_$tag_star ext entry
      113      returns (char (32) aligned);
      114 
      115 dcl  ptr_is_good_v2_ ext entry
      116     (ptr) returns (bit (1) aligned);
      117 
      118 /*  */
      119 read:	entry (a_mptr, a_ms_wanted, a_area_ptr, a_loc, a_time, a_user_level, a_ret_ptr, a_ms_len, a_sender_id,
      120 	a_level, a_code);
      121 
      122 	ms_wanted = a_ms_wanted;
      123 	area_ptr = a_area_ptr;
      124 	read = "1"b;
      125 	update,
      126 	delete = "0"b;
      127 	go to COMMON;
      128 
      129 delete:	entry (a_mptr, a_loc, a_time, a_user_level, a_code);
      130 
      131 	ms_wanted = "11"b;				/* delete by id only */
      132 	update,
      133 	read = "0"b;
      134 	delete = "1"b;
      135 	go to COMMON;
      136 
      137 read_and_delete: entry (a_mptr, a_ms_wanted, a_area_ptr, a_user_level, a_ret_ptr, a_ms_len, a_sender_id,
      138 	a_level, a_code);
      139 
      140 	ms_wanted = a_ms_wanted;
      141 	area_ptr = a_area_ptr;
      142 	read, delete = "1"b;
      143 	update = "0"b;
      144 	go to COMMON;
      145 
      146 incremental_read: entry (a_mptr, a_dir, a_area_ptr, a_loc, a_time, a_user_level, a_ret_ptr, a_ms_len, a_ret_loc,
      147 	a_ret_time, a_sender_id, a_level, a_code);
      148 
      149 	ms_wanted = "11"b;
      150 	dir = a_dir;
      151 	area_ptr = a_area_ptr;
      152 	read = "1"b;
      153 	delete = "0"b;
      154 	update = "0"b;
      155 	go to COMMON;
      156 
      157 
      158 update:	entry (a_mptr, a_ms_ptr, a_ms_len, a_loc, a_time, a_user_level, a_code);
      159 
      160 	read,
      161 	delete = "0"b;
      162 	update = "1"b;
      163 	ms_len = a_ms_len;
      164 
      165 /*  */
      166 
      167 COMMON:	
      168 
      169 	on condition (cleanup)			/* establish cleanup handler to free allocated message */
      170 	begin;
      171 	     if ret_ptr ^= null			/* a message was allocated */
      172 	     then do;
      173 		free ms_word_array in (area_array);	/* free it */
      174 		a_ret_ptr = null;			/* and return null argument ptr */
      175 	     end;
      176 	     a_code = error_table_$bad_segment;		/* make sure salvaging happens */
      177 	end;
      178 
      179 	code = 0;
      180 	mptr = a_mptr;
      181 	alloc_len = fixed (bit (mseg_hdr_v2.alloc_len, 16), 17); /* pick allocation bit string length out of header */
      182 
      183 	user_level = a_user_level;
      184 	if user_level ^= 0				/* user calling for his own message */
      185 	then do;
      186 	     caller_id = get_group_id_$tag_star ();	/* get his pers-proj name */
      187 	     name_len = index (caller_id, "*")-2;
      188 	     caller_id = substr (caller_id, 1, name_len);
      189 	end;
      190 
      191 	if ms_wanted = "11"b			/* copy id if given */
      192 	then do;
      193 	     time = a_time;
      194 	     loc = a_loc;				/* copy message location also */
      195 	end;
      196 
      197 	first, last, ms_end = "0"b;			/* initialize flags */
      198 
      199 	ms_count =				/* get number of messages */
      200 	fixed (mptr -> mseg_hdr_v2.number_of_messages, 18);
      201 
      202 	block_size = fixed (mseg_hdr_v2.block_size, 18);	/* pick out block size from header */
      203 
      204 	tr_offset =				/* calculate trailer offset */
      205 	block_size-mseg_data_v2_$block_trailer_data;
      206 
      207 	if (delete)				/* user is deleting a message */
      208 	then do;
      209 	     blocks_left =				/* get present number of free blocks */
      210 	     fixed (mptr -> mseg_hdr_v2.space_left, 18);
      211 	     delete_size = block_size*36;		/* compute bit size for zeroing blocks */
      212 	end;
      213 
      214 /*  */
      215 
      216 /* locate the message */
      217 
      218 	if ms_wanted = "01"b			/* last message wanted */
      219 	then do;
      220 	     loc = fixed (mptr -> mseg_hdr_v2.last_ms_offset, 18);
      221 	     ms_ptr = ptr (mptr, loc);		/* make pointer to last message */
      222 	     last = "1"b;				/* set flag to remember */
      223 	     if ms_count = 1			/* only one message */
      224 	     then first = "1"b;			/* it is first also */
      225 	end;
      226 
      227 	else if ms_wanted = "10"b			/* first message wanted */
      228 	then do;
      229 	     loc = fixed (mptr -> mseg_hdr_v2.first_ms_offset, 18);
      230 	     ms_ptr = ptr (mptr, loc);		/* make pointer to first message */
      231 	     first = "1"b;				/* set flag to remember */
      232 	     if ms_count = 1			/* only one message */
      233 	     then last = "1"b;			/* it is last also */
      234 	end;
      235 
      236 	if (first | last)
      237 	then if ((^ptr_is_good_v2_ (ms_ptr))| (^ms_ptr -> ms_block_hdr.first_block))
      238 	then go to BAD_SEG;				/* inconsistency, must be at least one message in segment */
      239 
      240 	if ms_wanted = "11"b			/* locate message by unique id */
      241 	then do;
      242 
      243 /* check the validity of the given offset */
      244 
      245 	     ms_ptr = ptr (mptr, loc);		/* make pointer to message */
      246 	     if ((^ptr_is_good_v2_ (ms_ptr))| (ms_ptr -> ms_block_hdr.first_block ^= "1"b))
      247 	     then go to NO_MSG;
      248 
      249 
      250 	     tr_ptr = addrel (ms_ptr, tr_offset);	/* get pointer to trailer data */
      251 
      252 	     if tr_ptr -> ms_size = "0"b		/* make credibility check on trailer */
      253 	     | tr_ptr -> ms_block_trailer_v2.time = "0"b
      254 	     | tr_ptr -> sender_id = zeroes
      255 	     | tr_ptr -> ms_block_trailer_v2.tr_pattern ^= mseg_data_v2_$mseg_tr36
      256 	     then go to BAD_SEG;
      257 
      258 	     if tr_ptr -> ms_block_trailer_v2.time = bit (fixed (time, 54), 54) /* message time correct */
      259 	     then do;
      260 
      261 		if (delete) then do;		/* message is to be deleted */
      262 
      263 		     if fixed (mptr -> mseg_hdr_v2.first_ms_offset, 18) = loc /* first message */
      264 		     then first = "1"b;		/* set flag to remember */
      265 
      266 		     if fixed (mptr -> mseg_hdr_v2.last_ms_offset, 18) = loc /* last message */
      267 		     then last = "1"b;		/* set flag to remember */
      268 
      269 		end;
      270 
      271 	     end;
      272 
      273 	     else					/* message time specified is incorrect */
      274 	     go to NO_MSG;
      275 
      276 /* incremental message wanted */
      277 
      278 	     if dir ^= "0"b
      279 	     then do;
      280 
      281 		if dir = "10"b			/* previous message wanted */
      282 		then do;				/* increment message pointer */
      283 		     if tr_ptr -> ms_block_trailer_v2.b_offset ^= "0"b
      284 		     then do;
      285 			loc = fixed (tr_ptr -> ms_block_trailer_v2.b_offset, 18);
      286 			ms_ptr = ptr (ms_ptr, loc);
      287 		     end;
      288 		     else do;			/* error, no previous message */
      289 			if fixed (mseg_hdr_v2.first_ms_offset, 18) ^= loc
      290 			then go to BAD_SEG;		/* format error, not first message */
      291 NO_MSG:			code = error_table_$no_message;
      292 			go to FIN;
      293 		     end;
      294 		end;
      295 
      296 		else if dir = "01"b			/* next message wanted */
      297 		then do;				/* increment message pointer */
      298 		     if tr_ptr -> ms_block_trailer_v2.f_offset ^= "0"b
      299 		     then do;
      300 			loc = fixed (tr_ptr -> ms_block_trailer_v2.f_offset, 18);
      301 			ms_ptr = ptr (ms_ptr, loc);
      302 		     end;
      303 		     else do;			/* error, no next message */
      304 			if fixed (mseg_hdr_v2.last_ms_offset, 18) ^= loc
      305 			then go to BAD_SEG;		/* format error, not last message */
      306 			go to NO_MSG;
      307 		     end;
      308 		end;
      309 
      310 	     end;
      311 
      312 	end;
      313 
      314 /* get information from the first block trailer */
      315 
      316 	tr_ptr =					/* get pointer to trailer */
      317 	addrel (ms_ptr, tr_offset);
      318 
      319 	if tr_ptr -> ms_size = "0"b			/* make trailer credibility check */
      320 	| tr_ptr -> ms_block_trailer_v2.time = "0"b
      321 	| tr_ptr -> sender_id = zeroes
      322 	| tr_ptr -> ms_block_trailer_v2.tr_pattern ^= mseg_data_v2_$mseg_tr36
      323 	then go to BAD_SEG;
      324 
      325 	if dir ^= "0"b				/* pick up incremental id */
      326 	then time = fixed (tr_ptr -> ms_block_trailer_v2.time, 54);
      327 
      328 	if (delete) then do;
      329 
      330 	     if (^first)
      331 	     then do;				/* not first message */
      332 		prev_offset =			/* get offset to previous message */
      333 		fixed (tr_ptr -> ms_block_trailer_v2.b_offset, 18);
      334 		prev_tr_ptr =			/* make pointer to previous trailer */
      335 		ptr (mptr, prev_offset+tr_offset);
      336 	     end;
      337 
      338 	     if (^last)
      339 	     then do;				/* not last message */
      340 		next_offset =			/* get offset to next message */
      341 		fixed (tr_ptr -> ms_block_trailer_v2.f_offset, 18);
      342 		next_tr_ptr =			/* make pointer to next trailer */
      343 		ptr (mptr, next_offset+tr_offset);
      344 	     end;
      345 
      346 	end;
      347 
      348 	ms_sender_id =
      349 	tr_ptr -> ms_block_trailer_v2.sender_id;		/* pick out senders' id */
      350 	level = fixed (ms_block_trailer_v2.ring_no, 17);	/* pick out validation level */
      351 
      352 /* make final access check */
      353 
      354 	if user_level ^= 0				/* user called for own message */
      355 	then if caller_id ^= substr (ms_sender_id, 1, name_len) /* this is not his message */
      356 	then do;
      357 	     ms_len = 0;				/* not found */
      358 	     if (delete | update)			/* no "d" permission, not own message */
      359 	     then code = error_table_$moderr;
      360 	     else					/* user not deleting */
      361 	     if dir = "0"b				/* ordinary read */
      362 	     then time = fixed (bit (tr_ptr -> ms_block_trailer_v2.time, 54), 54); /* return message time */
      363 	     go to FIN;
      364 	end;
      365 
      366 	if update
      367 	then if fixed (tr_ptr -> ms_block_trailer_v2.ms_size, 18) ^= ms_len /* incorrect message size specified */
      368 	then go to NO_MSG;
      369 
      370 /* allocate an area for the returned message */
      371 
      372 	ms_len = fixed (ms_block_trailer_v2.ms_size, 18);	/* pick out message size */
      373 
      374 	if (read)
      375 	then do;
      376 	     ms_word_len = divide (ms_len+35, 36, 17, 0);	/* compute word length from bit count */
      377 	     allocate ms_word_array in (area_array) set (ret_ptr); /* allocate the area */
      378 	     t_ptr = ret_ptr;			/* initialize scan pointer */
      379 	end;
      380 
      381 	else					/* not reading message */
      382 	if update					/* updating message */
      383 	then t_ptr = a_ms_ptr;			/* initialize scan ptr */
      384 
      385 /*  */
      386 /* chase the message thread */
      387 
      388 	found_ms_len = 0;				/* initialize size of found message */
      389 
      390 	blocks_in_message = 0;			/* initialize count */
      391 	block_ptr = ms_ptr;				/* initialize block pointer */
      392 	ms_end = "0"b;				/* initialize end of message flag */
      393 
      394 	if (delete | update)			/* user is deleting or updating a message */
      395 	then mseg_hdr_v2.aip = "1"b;			/* turn on aip bit */
      396 
      397 	do while (^ms_end);
      398 
      399 	     blocks_in_message =			/* increment message block count */
      400 	     blocks_in_message + 1;
      401 
      402 	     found_ms_len = found_ms_len + fixed (ms_block_hdr.block_count, 18); /* increment message size */
      403 	     if found_ms_len > ms_len			/* more message than block trailer specified */
      404 	     then do;				/* error in message segment */
      405 BAD_SEG:		
      406 		code = error_table_$bad_segment;
      407 		go to FIN;
      408 	     end;
      409 
      410 
      411 	     if (read | update)
      412 	     then do;				/* return message for reading */
      413 		copy_size =			/* set size of copy mask */
      414 		fixed (block_ptr -> ms_block_hdr.block_count, 18);
      415 		incr_size = copy_size + 1;		/* to step copy-to ptr later */
      416 		if read				/* reading message */
      417 		then t_ptr -> bit_copy_mask =		/* copy message */
      418 		addrel (block_ptr, mseg_data_v2_$block_hdr_data) -> bit_copy_mask;
      419 		else				/* not reading */
      420 		if update				/* updating message */
      421 		then addrel (block_ptr, mseg_data_v2_$block_hdr_data) -> bit_copy_mask
      422 		= t_ptr -> bit_copy_mask;		/* overwrite */
      423 	     end;
      424 
      425 	     if (delete)
      426 	     then do;				/* user is deleting a message */
      427 		bit_off = divide (fixed (rel (block_ptr), 18), block_size, 18, 0)+1; /* calculate alloc bit for block */
      428 		if substr (mseg_hdr_v2.alloc_bits, bit_off, 1) = "0"b /* block not in use */
      429 		then go to BAD_SEG;			/* format error */
      430 		else
      431 		substr (mseg_hdr_v2.alloc_bits, bit_off, 1) = "0"b; /* turn bit off */
      432 		deletep = block_ptr;		/* remember block ptr to delete later */
      433 	     end;
      434 
      435 	     if blocks_in_message = 1			/* first block */
      436 	     then if ms_wanted ^= "11"b		/* id not given */
      437 	     then do;				/* get id */
      438 		tr_ptr = addrel (block_ptr, block_size-mseg_data_v2_$block_trailer_data);
      439 		time = fixed (bit (tr_ptr -> ms_block_trailer_v2.time, 54), 54);
      440 	     end;
      441 
      442 	     if block_ptr -> ms_block_hdr.f_offset = "0"b
      443 	     then do;				/* message block is last in message */
      444 		if found_ms_len ^= ms_len		/* found size doesn't agree with trailer */
      445 		then go to BAD_SEG;			/* format error */
      446 		else
      447 		ms_end = "1"b;			/* indicate end of message */
      448 	     end;
      449 
      450 	     else do;
      451 		block_ptr =			/* step the block pointer */
      452 		ptr (block_ptr, fixed (block_ptr -> ms_block_hdr.f_offset, 18));
      453 		if (read) then t_ptr =		/* increment copy-to pointer */
      454 		addr (t_ptr -> bits (incr_size));
      455 	     end;
      456 
      457 	     if (delete)				/* message is being deleted */
      458 	     then do;
      459 		copy_size = delete_size;		/* set size of copy mask */
      460 		deletep -> bit_copy_mask = "0"b;	/* use mask to zero out block */
      461 	     end;
      462 
      463 	end;
      464 
      465 /*  */
      466 /* finish deleting message if requested */
      467 
      468 	if (delete) then do;
      469 
      470 	     blocks_left =				/* calculate new remaining blocks */
      471 	     blocks_left + blocks_in_message;
      472 
      473 	     if ms_count > 1			/* there will be a remaining message */
      474 	     then do;
      475 
      476 /* unthread the message */
      477 
      478 		if (first) then do;			/* unthread first message */
      479 		     mptr -> mseg_hdr_v2.first_ms_offset =
      480 		     bit (fixed (next_offset, 18), 18);	/* reset header offset to new first message */
      481 		     next_tr_ptr -> ms_block_trailer_v2.b_offset =
      482 		     "0"b;			/* reset new first message back pointer */
      483 		end;
      484 
      485 		if (last) then do;			/* unthread last message */
      486 		     mptr -> mseg_hdr_v2.last_ms_offset =
      487 		     bit (fixed (prev_offset, 18), 18);	/* reset header offset to new last message */
      488 		     prev_tr_ptr -> ms_block_trailer_v2.f_offset =
      489 		     "0"b;			/* reset new last message forward pointer */
      490 		end;
      491 
      492 		if (^first) then if (^last) then do;	/* unthread mid message */
      493 		     prev_tr_ptr -> ms_block_trailer_v2.f_offset =
      494 		     bit (fixed (next_offset, 18), 18);	/* reset forward offset of previous message */
      495 		     next_tr_ptr -> ms_block_trailer_v2.b_offset =
      496 		     bit (fixed (prev_offset, 18), 18);	/* reset backward offset of next message */
      497 		end;
      498 
      499 	     end;
      500 
      501 	     else					/* no messages left */
      502 	     mseg_hdr_v2.first_ms_offset,		/* zero out hdr pointers */
      503 	     mseg_hdr_v2.last_ms_offset = "0"b;
      504 
      505 /* update header after deletion */
      506 
      507 	     mptr -> mseg_hdr_v2.space_left =		/* reset space left */
      508 	     fixed (blocks_left);
      509 
      510 	     ms_count = ms_count - 1;
      511 	     mptr -> mseg_hdr_v2.number_of_messages =	/* reset number of messages */
      512 	     fixed (ms_count);
      513 
      514 	     mptr -> mseg_hdr_v2.aip = "0"b;		/* turn off allocation in progress bit */
      515 
      516 	end;
      517 
      518 FIN:	
      519 
      520 	if code = 0
      521 	then do;
      522 
      523 	     if (read)
      524 	     then a_ms_len = ms_len;
      525 
      526 	     if (^delete & ^update)
      527 	     then do;
      528 		a_time = time;			/* return loc and time if not given */
      529 		a_loc = loc;
      530 	     end;
      531 
      532 	     if dir ^= "0"b				/* return incremental data */
      533 	     then do;
      534 		a_ret_time = time;
      535 		a_ret_loc = loc;
      536 	     end;
      537 
      538 	end;
      539 
      540 	else do;					/* error, return null arguments */
      541 
      542 	     if (read)
      543 	     then a_ms_len = 0;
      544 
      545 	     if (^delete & ^update)
      546 	     then a_time, a_loc = 0;
      547 
      548 	     if dir ^= "0"b
      549 	     then a_ret_loc, a_ret_time = 0;
      550 
      551 	     if ret_ptr ^= null			/* a message was allocated */
      552 	     then do;
      553 		free ms_word_array in (area_array);	/* free it */
      554 		a_ret_ptr = null;			/* return null argument */
      555 	     end;
      556 
      557 	end;
      558 
      559 	a_code = code;
      560 
      561 	if (read)					/* return allocation pointer for freeing */
      562 	then do;
      563 	     a_ret_ptr = ret_ptr;
      564 	     if code = 0
      565 	     then do;
      566 		a_sender_id = ms_sender_id;
      567 		a_level = level;
      568 	     end;
      569 	     else
      570 	     if ^update
      571 	     then do;
      572 		if user_level = 0
      573 		then a_sender_id = "";
      574 		a_level = -1;
      575 	     end;
      576 	end;
      577 
      578 	return;
      579 
      580 
      581      end mseg_util_v2_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  mseg_util_v2_.pl1                 >spec>on>mseg>mseg_util_v2_.pl1
102          1    05/06/85  1121.8  mseg_hdr_v2.incl.pl1              >spec>on>mseg>mseg_hdr_v2.incl.pl1
104          2    05/06/85  1121.7  ms_block_hdr_v2.incl.pl1          >spec>on>mseg>ms_block_hdr_v2.incl.pl1
106          3    05/06/85  1121.7  ms_block_trailer_v2.incl.pl1      >spec>on>mseg>ms_block_trailer_v2.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_area_ptr                             parameter       pointer                  dcl 15 ref 119 123 137 141 146 151
a_code                                 parameter       fixed bin(35,0)          dcl 77 set ref 119 129 137 146 158 176* 559*
a_dir                                  parameter       bit(2)                   dcl 54 ref 146 150
a_level                                parameter       fixed bin(17,0)          dcl 67 set ref 119 137 146 567* 574*
a_loc                                  parameter       fixed bin(18,0)          dcl 34 set ref 119 129 146 158 194 529* 545*
a_mptr                                 parameter       pointer                  dcl 15 ref 119 129 137 146 158 180
a_ms_len                               parameter       fixed bin(18,0)          dcl 34 set ref 119 137 146 158 163 523* 542*
a_ms_ptr                               parameter       pointer                  dcl 15 ref 158 381
a_ms_wanted                            parameter       bit(2)                   dcl 54 ref 119 122 137 140
a_ret_loc                              parameter       fixed bin(18,0)          dcl 34 set ref 146 535* 548*
a_ret_ptr                              parameter       pointer                  dcl 15 set ref 119 137 146 174* 554* 563*
a_ret_time                             parameter       fixed bin(54,0)          dcl 63 set ref 146 534* 548*
a_sender_id                            parameter       char(32)                 dcl 94 set ref 119 137 146 566* 572*
a_time                                 parameter       fixed bin(54,0)          dcl 63 set ref 119 129 146 158 193 528* 545*
a_user_level                           parameter       fixed bin(17,0)          dcl 67 ref 119 129 137 146 158 183
addr                                                   builtin function         dcl 82 ref 252 319 453
addrel                                                 builtin function         dcl 82 ref 250 316 416 419 438
aip                      16            based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 394* 514*
alloc_bits              220            based           bit                      level 2 dcl 1-3 set ref 428 430*
alloc_len                12            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v2" dcl 1-3
                                                                                  in procedure "mseg_util_v2_" ref 181
alloc_len                       000146 automatic       fixed bin(17,0)          dcl 67 in procedure "mseg_util_v2_" set ref 181* 428
                                                                                  430
area_array                             based           area(30)                 dcl 88 ref 173 377 553
area_ptr                        000114 automatic       pointer                  dcl 15 set ref 123* 141* 151* 173 377 553
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 set ref 283 285 332
                                                                                  481* 495*
bit                                                    builtin function         dcl 82 ref 181 258 360 439 479 486 493 495
bit_copy_mask                          based           bit                      unaligned dcl 96 set ref 416* 416 419* 419 460*
bit_off                         000141 automatic       fixed bin(18,0)          dcl 34 set ref 427* 428 430
bits                                   based           bit(1)                   array unaligned dcl 98 set ref 453
block_count               0(19)        based           bit(17)                  level 2 packed unaligned dcl 2-3 ref 402 413
block_ptr                       000204 automatic       pointer                  dcl 2-3 set ref 391* 402 413 416 419 427 432 438 442
                                                                                  451* 451 451
block_size                      000130 automatic       fixed bin(18,0)          dcl 34 in procedure "mseg_util_v2_" set ref 202* 204
                                                                                  211 427 438
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v2" dcl 1-3
                                                                                  in procedure "mseg_util_v2_" ref 202
blocks_in_message               000131 automatic       fixed bin(18,0)          dcl 34 set ref 390* 399* 399 435 470
blocks_left                     000132 automatic       fixed bin(18,0)          dcl 34 set ref 209* 470* 470 507
caller_id                       000162 automatic       char(32)                 dcl 91 set ref 186* 187 188* 188 354
cleanup                         000154 stack reference condition                dcl 84 ref 167
code                            000153 automatic       fixed bin(35,0)          dcl 77 set ref 179* 291* 358* 405* 518 559 564
copy_size                       000133 automatic       fixed bin(18,0)          dcl 34 set ref 413* 415 416 416 419 419 459* 460
delete                          000123 automatic       bit(1)                   dcl 27 set ref 125* 134* 142* 153* 160* 207 261 328
                                                                                  358 394 425 457 468 526 545
delete_size                     000134 automatic       fixed bin(18,0)          dcl 34 set ref 211* 459
deletep                         000110 automatic       pointer                  dcl 15 set ref 432* 460
dir                             000143 automatic       bit(2)                   initial dcl 54 set ref 54* 150* 278 281 296 325 360
                                                                                  532 548
divide                                                 builtin function         dcl 82 ref 376 427
error_table_$bad_segment        000026 external static fixed bin(35,0)          dcl 108 ref 176 405
error_table_$moderr             000030 external static fixed bin(35,0)          dcl 109 ref 358
error_table_$no_message         000032 external static fixed bin(35,0)          dcl 110 ref 291
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer_v2" packed
                                                                                  unaligned dcl 3-3 in procedure "mseg_util_v2_" set
                                                                                  ref 298 300 340 488* 493*
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "mseg_util_v2_" ref 442 451
first                           000117 automatic       bit(1)                   dcl 27 set ref 197* 223* 231* 236 263* 330 478 492
first_block               0(18)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 236 246
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 set ref 229 263 289 479* 501*
fixed                                                  builtin function         dcl 82 ref 181 199 202 209 220 229 258 263 266 285
                                                                                  289 300 304 325 332 340 350 360 366 372 402 413
                                                                                  427 439 451 479 486 493 495 507 511
found_ms_len                    000137 automatic       fixed bin(18,0)          dcl 34 set ref 388* 402* 402 403 444
get_group_id_$tag_star          000034 constant        entry                    external dcl 112 ref 186
incr_size                       000135 automatic       fixed bin(18,0)          dcl 34 set ref 415* 453
index                                                  builtin function         dcl 82 ref 187
last                            000116 automatic       bit(1)                   dcl 27 set ref 197* 222* 232* 236 266* 338 485 492
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 set ref 220 266 304 486* 501*
level                           000147 automatic       fixed bin(17,0)          dcl 67 set ref 350* 567
loc                             000140 automatic       fixed bin(18,0)          dcl 34 set ref 194* 220* 221 229* 230 245 263 266
                                                                                  285* 286 289 300* 301 304 529 535
mptr                            000202 automatic       pointer                  dcl 1-3 set ref 180* 181 199 202 209 220 221 229 230
                                                                                  245 263 266 289 304 334 342 394 428 430 479 486
                                                                                  501 501 507 511 514
ms_block_hdr                           based           structure                level 1 dcl 2-3
ms_block_trailer_v2                    based           structure                level 1 dcl 3-3
ms_count                        000125 automatic       fixed bin(18,0)          dcl 34 set ref 199* 223 232 473 510* 510 511
ms_end                          000121 automatic       bit(1)                   dcl 27 set ref 197* 392* 397 446*
ms_len                          000136 automatic       fixed bin(18,0)          dcl 34 set ref 163* 357* 366 372* 376 403 444 523
ms_ptr                          000104 automatic       pointer                  dcl 15 set ref 221* 230* 236* 236 245* 246* 246 250
                                                                                  286* 286 301* 301 316 391
ms_sender_id                    000172 automatic       char(32)                 dcl 91 set ref 348* 354 566
ms_size                   2            based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 252 319 366 372
ms_wanted                       000142 automatic       bit(2)                   dcl 54 set ref 122* 131* 140* 149* 191 218 227 240
                                                                                  435
ms_word_array                          based           fixed bin(17,0)          array dcl 88 ref 173 377 553
ms_word_len                     000151 automatic       fixed bin(17,0)          dcl 67 set ref 173 376* 377 553
mseg_data_v2_$block_hdr_data    000022 external static fixed bin(18,0)          dcl 34 ref 416 419
mseg_data_v2_$block_trailer_data
                                000020 external static fixed bin(18,0)          dcl 34 ref 204 438
mseg_data_v2_$mseg_tr36         000024 external static bit(36)                  dcl 59 ref 252 319
mseg_hdr_v2                            based           structure                level 1 dcl 1-3
name_len                        000152 automatic       fixed bin(17,0)          dcl 67 set ref 187* 188 354
next_offset                     000127 automatic       fixed bin(18,0)          dcl 34 set ref 340* 342 479 493
next_tr_ptr                     000102 automatic       pointer                  dcl 15 set ref 342* 481 495
null                                                   builtin function         dcl 82 ref 15 171 174 551 554
number_of_messages       14            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 199 511*
prev_offset                     000126 automatic       fixed bin(18,0)          dcl 34 set ref 332* 334 486 495
prev_tr_ptr                     000100 automatic       pointer                  dcl 15 set ref 334* 488 493
ptr                                                    builtin function         dcl 82 ref 221 230 245 286 301 334 342 451
ptr_is_good_v2_                 000036 constant        entry                    external dcl 115 ref 236 246
read                            000122 automatic       bit(1)                   dcl 27 set ref 124* 132* 142* 152* 160* 374 411 416
                                                                                  453 523 542 561
rel                                                    builtin function         dcl 82 ref 427
ret_ptr                         000106 automatic       pointer                  initial dcl 15 set ref 15* 171 173 377* 378 551 553
                                                                                  563
ring_no                   4            based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 350
sender_id                 5            based           char(32)                 level 2 dcl 3-3 ref 252 319 348
space_left               13            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 209 507*
substr                                                 builtin function         dcl 82 set ref 188 354 428 430*
switches                 16            based           structure                level 2 dcl 1-3
t_ptr                           000112 automatic       pointer                  dcl 15 set ref 378* 381* 416 419 453* 453
time                            000144 automatic       fixed bin(54,0)          dcl 63 in procedure "mseg_util_v2_" set ref 193* 258
                                                                                  325* 360* 439* 528 534
time                      2(18)        based           bit(54)                  level 2 in structure "ms_block_trailer_v2" packed
                                                                                  unaligned dcl 3-3 in procedure "mseg_util_v2_" ref
                                                                                  252 258 319 325 360 439
tr_offset                       000124 automatic       fixed bin(18,0)          dcl 34 set ref 204* 250 316 334 342
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 252 319
tr_ptr                          000206 automatic       pointer                  dcl 3-3 set ref 250* 252 252 252 252 258 283 285 298
                                                                                  300 316* 319 319 319 319 325 332 340 348 350 360
                                                                                  366 372 438* 439
update                          000120 automatic       bit(1)                   dcl 27 set ref 125* 132* 143* 154* 162* 358 366 381
                                                                                  394 411 419 526 545 569
user_level                      000150 automatic       fixed bin(17,0)          dcl 67 set ref 183* 184 354 572
zero_words                      000010 internal static fixed bin(17,0)          initial array dcl 67 set ref 252 319
zeroes                                 based           char(32)                 dcl 100 ref 252 319

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_SEG                         001107 constant        label                    dcl 405 ref 236 252 289 304 319 428 444
COMMON                          000323 constant        label                    dcl 167 ref 127 135 144 155
FIN                             001345 constant        label                    dcl 518 ref 292 363 407
NO_MSG                          000663 constant        label                    dcl 291 ref 246 258 306 366
delete                          000114 constant        entry                    external dcl 129
incremental_read                000221 constant        entry                    external dcl 146
mseg_util_v2_                   000025 constant        entry                    external dcl 11
read                            000044 constant        entry                    external dcl 119
read_and_delete                 000151 constant        entry                    external dcl 137
update                          000274 constant        entry                    external dcl 158

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1646        1706    1456        1656
Length      2160    1456        40         236     170          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_util_v2_                       168 external procedure  is an external procedure.  
on unit on line 167                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 zero_words                  mseg_util_v2_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mseg_util_v2_            000100 prev_tr_ptr                 mseg_util_v2_
                         000102 next_tr_ptr                 mseg_util_v2_
                         000104 ms_ptr                      mseg_util_v2_
                         000106 ret_ptr                     mseg_util_v2_
                         000110 deletep                     mseg_util_v2_
                         000112 t_ptr                       mseg_util_v2_
                         000114 area_ptr                    mseg_util_v2_
                         000116 last                        mseg_util_v2_
                         000117 first                       mseg_util_v2_
                         000120 update                      mseg_util_v2_
                         000121 ms_end                      mseg_util_v2_
                         000122 read                        mseg_util_v2_
                         000123 delete                      mseg_util_v2_
                         000124 tr_offset                   mseg_util_v2_
                         000125 ms_count                    mseg_util_v2_
                         000126 prev_offset                 mseg_util_v2_
                         000127 next_offset                 mseg_util_v2_
                         000130 block_size                  mseg_util_v2_
                         000131 blocks_in_message           mseg_util_v2_
                         000132 blocks_left                 mseg_util_v2_
                         000133 copy_size                   mseg_util_v2_
                         000134 delete_size                 mseg_util_v2_
                         000135 incr_size                   mseg_util_v2_
                         000136 ms_len                      mseg_util_v2_
                         000137 found_ms_len                mseg_util_v2_
                         000140 loc                         mseg_util_v2_
                         000141 bit_off                     mseg_util_v2_
                         000142 ms_wanted                   mseg_util_v2_
                         000143 dir                         mseg_util_v2_
                         000144 time                        mseg_util_v2_
                         000146 alloc_len                   mseg_util_v2_
                         000147 level                       mseg_util_v2_
                         000150 user_level                  mseg_util_v2_
                         000151 ms_word_len                 mseg_util_v2_
                         000152 name_len                    mseg_util_v2_
                         000153 code                        mseg_util_v2_
                         000162 caller_id                   mseg_util_v2_
                         000172 ms_sender_id                mseg_util_v2_
                         000202 mptr                        mseg_util_v2_
                         000204 block_ptr                   mseg_util_v2_
                         000206 tr_ptr                      mseg_util_v2_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out        return              enable              ext_entry           int_entry
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_$tag_star        ptr_is_good_v2_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$moderr           error_table_$no_message       mseg_data_v2_$block_hdr_data
mseg_data_v2_$block_trailer_data                            mseg_data_v2_$mseg_tr36




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000017        54 000021        11 000024       119 000033       122 000073       123 000077       124 000102
    125 000104       127 000106       129 000107       131 000133       132 000135       134 000137       135 000141
    137 000142       140 000174       141 000200       142 000203       143 000206       144 000207       146 000210
    149 000250       150 000252       151 000256       152 000261       153 000263       154 000264       155 000265
    158 000266       160 000315       162 000317       163 000321       167 000323       171 000337       173 000344
    174 000346       176 000351       177 000354       179 000355       180 000356       181 000362       183 000370
    184 000372       186 000373       187 000402       188 000413       191 000416       193 000421       194 000423
    197 000425       199 000430       202 000433       204 000435       207 000440       209 000442       211 000444
    218 000447       220 000452       221 000455       222 000460       223 000462       225 000466       227 000467
    229 000471       230 000474       231 000477       232 000501       236 000505       240 000533       245 000536
    246 000542       250 000566       252 000572       258 000613       261 000621       263 000623       266 000632
    278 000640       281 000642       283 000644       285 000650       286 000652       287 000655       289 000656
    291 000663       292 000666       294 000667       296 000670       298 000672       300 000676       301 000700
    302 000703       304 000704       306 000711       316 000712       319 000716       325 000740       328 000745
    330 000747       332 000751       334 000754       338 000760       340 000762       342 000765       348 000771
    350 000774       354 000777       357 001006       358 001007       360 001016       363 001023       366 001024
    372 001032       374 001035       376 001037       377 001042       378 001047       379 001050       381 001051
    388 001057       390 001060       391 001061       392 001063       394 001064       397 001073       399 001076
    402 001077       403 001104       405 001107       407 001112       411 001113       413 001117       415 001122
    416 001124       419 001140       425 001153       427 001155       428 001162       430 001167       432 001172
    435 001174       438 001202       439 001210       442 001214       444 001220       446 001223       448 001225
    451 001226       453 001232       457 001242       459 001244       460 001246       463 001252       468 001253
    470 001255       473 001257       478 001262       479 001264       481 001272       485 001275       486 001277
    488 001305       492 001310       493 001314       495 001322       499 001330       501 001331       507 001334
    510 001337       511 001341       514 001343       518 001345       523 001347       526 001353       528 001357
    529 001361       532 001363       534 001365       535 001370       538 001372       542 001373       545 001376
    548 001405       551 001413       553 001417       554 001421       559 001423       561 001425       563 001427
    564 001431       566 001433       567 001437       568 001441       569 001442       572 001444       574 001452
    578 001454


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
