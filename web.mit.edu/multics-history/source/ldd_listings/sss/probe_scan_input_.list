	COMPILATION LISTING OF SEGMENT probe_scan_input_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1235.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-05-25,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Modified code in the internal procedure 'build_operator_from_char' to
       18*     evaluate the * character. The * character may be either the TIMES operator
       19*     or the C_INDIRECTION operator. The operator type is resolved based on the
       20*     previous token.
       21*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       22*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       23*     Added format control comment to make the source more readable.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       28 
       29 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       30 
       31 probe_scan_input_:
       32   procedure (P_probe_info_ptr, P_input_ptr, P_input_lth, P_area_ptr,
       33        P_language_type,
       34        P_input_used_lth, P_first_token, P_code);
       35 
       36   /* * 11 Sep 81, S. Herbst:
       37*   *    Changed to handle virtual entries of the form path|N.
       38*   * 05 Oct 81, S. Herbst:
       39*   *    Changed to handle regular expressions.
       40*   * 01 Dec 81, S. Herbst:
       41*   *    Fixed to report illegal char correctly.
       42*   * 18 Oct 82, S. Herbst:
       43*   *    Fixed to handle regular expression containing quotes.
       44*   * ?? Jun 83, JMAthane:
       45*   *    To add PASCAL.
       46*   * 27 Jul 83, S. Herbst:
       47*   *    Changed to accomodate new COLON_CHAR_TYPE, translate Pascal ".." 
       48*   *    to colon.
       49*   * 08 Aug 83, S. Herbst:
       50*   *    Fixed to put current executiogn ring number in createdSSS|OOO
       51*   *    value.
       52*   * 15 Feb 84, S. Herbst:
       53*   *    Fixed to allow dots in entry names when running FORTRAN.
       54*   * 09 Mar 84, S. Herbst:
       55*   *    Changed to allow ".." as double operator anywhere in line.
       56*   * 30 Mar 84, S. Herbst:
       57*   *    Made to save the input ptr & len in probe_info.buffer_(ptr lth).
       58*   * 20 Sep 84, S. Herbst:
       59*   *    Fixed to put -'s in COBOL identifiers, not translate them to _'s.
       60*   * ?? Apr 88, C. Hinatsu:
       61*   *    To add C operators.
       62*   * */
       63 
       64   /* *	Input string scanner for probe debugger.
       65*   Initially coded sometime in the past as part of probe main procedure, J. M. Broughton.
       66*   Split off into external procedure for added versatility, 04/21/79 W. Olin Sibert.
       67*   made  trilingual (and a lot prettier, if I say so myself) JRDavis 3 Aug 79
       68*   bug fixes JRD 7 Feb 80
       69*   extended ptr constants, sp|NNN, lp|NNN, tp|NNN JRD 8 Mar 80 */
       70 
       71   /* This procedure converts an input string into probe tokens. It reads 
       72* * up to the first statement delimiter, and returns a pointer to       
       73* * a chain of tokens allocated in the caller-supplied area. It can     
       74* * return an error code if it encounters a syntax error, or if it runs 
       75* * out of input string without hitting a plausible delimiter.          
       76* *                                                                     
       77* * Arguments:                                                          
       78* *                                                                     
       79* * P_probe_info_ptr                                                    
       80* *   is a pointer to the probe_info structure for this invocation of
       81* *   probe.
       82* *
       83* * P_input_ptr
       84* *   is a pointer to the start of the input string.
       85* *
       86* * P_input_lth
       87* *   is the length of the input string.
       88* *
       89* * P_area_ptr
       90* *   is a pointer to an area in which the scanner will allocate tokens.
       91* *
       92* * P_language_type
       93* *   is the language type for scanning.
       94* *
       95* * P_input_used_lth (Output)
       96* *   is the count of characters read from the input string; in the case of most
       97* *   errors, it will be zero; otherwise, it is the index of the unhappy 
       98* *   character.
       99* *
      100* * P_first_token (Output)
      101* *   is a pointer to the first token in the chain allocated by this procedure.
      102* *
      103* * P_code (Output)
      104* *   is an error code; a value of zero indicates that all has gone well, and 
      105* *   any other value indicates an error, except for 
      106* *   probe_et_$input_exhausted, which indicates that we ran out of 
      107* *   input prematurely.
      108* */
      109 
      110   dcl (
      111       P_probe_info_ptr	pointer,
      112       P_input_ptr		pointer,	/* pointer to input buffer */
      113       P_input_lth		fixed bin (21),
      114 				/* length of input buffer */
      115       P_area_ptr		pointer,	/* pointer to working area for token allocations, etc. */
      116       P_language_type	fixed bin (21),
      117 				/* type of language syntax, for parsing */
      118       P_input_used_lth	fixed bin (21),
      119 				/* (Output) count of chars used from input buffer */
      120       P_first_token		pointer,	/* (Output) pointer to first token in our output chain */
      121       P_code		fixed bin (35)
      122       )			parameter;/* (Output) error code */
      123 
      124 
      125   /* IMPORTANT VARIABLES */
      126 
      127   dcl Cur_state		fixed bin,/* what state we are in (computational, not political) */
      128       Cur_pos		fixed bin (21),
      129 				/* index into Input_str of current char */
      130       Cur_char		char (1) aligned,
      131 				/* the char we are now parsing */
      132       Char_type		fixed bin;/* what kind of char it is */
      133   dcl First_token		ptr;	/* to the first token we allocate */
      134   dcl Last_token		ptr;	/* to the last token we allocated */
      135   dcl Paren_level		fixed bin;/* keep count of ((()())) */
      136   dcl Token_pos		fixed bin (21);
      137 				/* where in buffer the chars of the token begin */
      138 
      139   dcl regexp_sw		bit (1) aligned;
      140 				/* inside /regular expression/ instead of quoted string */
      141 
      142   dcl (ptr_segno, ptr_wordno, ptr_offset, ptr_bitno)
      143 			fixed bin;/* used in building ptr constants */
      144   dcl i			fixed bin;/* every program needs one of these */
      145   dcl code		fixed bin (35);
      146 
      147   dcl token_area		area based (token_area_ptr);
      148 				/* where we do our work */
      149   dcl token_area_ptr	pointer;
      150 
      151   dcl input_string		char (input_string_lth)
      152 			based (input_string_ptr);
      153   dcl input_string_ptr	pointer;
      154   dcl input_string_lth	fixed bin (21);
      155 
      156   dcl string_buffer		character (256) varying aligned;
      157 				/* place to put strings while building them */
      158 
      159   dcl char_type		(0:127) fixed bin (17) unaligned
      160 			based (char_type_ptr);
      161 				/* the char type array we use */
      162   dcl char_type_ptr		ptr;
      163   dcl action_table		(14, 0:27) fixed bin (17) unaligned
      164 			based (action_table_ptr);
      165 				/* the all-important table */
      166   dcl action_table_ptr	ptr;
      167 
      168 
      169   dcl (
      170       probe_scan_data_$pl1_char_type,	/* char_types for three languages */
      171       probe_scan_data_$fortran_char_type,
      172       probe_scan_data_$pascal_char_type,
      173       probe_scan_data_$cobol_char_type,
      174       probe_scan_data_$c_char_type
      175       )			(0:127) fixed bin (17) unaligned external
      176 			static;
      177 
      178   dcl (
      179       probe_scan_data_$pl1_action_table,
      180       probe_scan_data_$fortran_action_table,
      181       probe_scan_data_$pascal_action_table,
      182       probe_scan_data_$cobol_action_table,
      183       probe_scan_data_$c_action_table
      184       )			(14, 0:27) fixed bin (17) unaligned
      185 			external static;
      186 
      187   dcl probe_scan_data_$operator_type
      188 			(0:127) fixed bin (17) unaligned external
      189 			static;
      190 
      191   dcl 1 probe_scan_data_$doubles
      192 			(13) external static,
      193        2 pair		char (2),
      194        2 type		fixed bin;
      195 
      196   dcl 1 probe_scan_data_$fort_ops
      197 			(9) external static,
      198        2 name		char (4) aligned,
      199        2 op_code		fixed bin;
      200 
      201   dcl 1 probe_scan_data_$pasc_ops
      202 			(3) external static,
      203        2 name		char (4) aligned,
      204        2 op_code		fixed bin;
      205 
      206 
      207   dcl (
      208       probe_et_$recorded_message,
      209       probe_et_$unbalanced_parens,
      210       probe_et_$string_long,
      211       probe_et_$illegal_char
      212       )			fixed bin (35) external static;
      213 
      214   dcl CR			char (1) aligned internal static
      215 			options (constant) init ("
      216 ");
      217 
      218 
      219   dcl (cv_dec_check_, cv_oct_check_)
      220 			entry (char (*), fixed bin (35))
      221 			returns (fixed bin (35));
      222   dcl get_ring_		entry returns (fixed bin (3));
      223   dcl probe_error_$record	entry options (variable);
      224 
      225   dcl (addr, baseno, bin, binary, bit, divide, fixed, hbound, index, length,
      226       maxlength)		builtin;
      227   dcl (mod, null, pointer, rank, rel, reverse, substr, translate, unspec)
      228 			builtin;
      229 
      230   P_code = 0;
      231   code = 0;
      232   probe_info_ptr = P_probe_info_ptr;
      233 
      234   input_string_ptr, probe_info.buffer_ptr = P_input_ptr;
      235   input_string_lth, probe_info.buffer_lth = P_input_lth;
      236 
      237   token_area_ptr = P_area_ptr;
      238 
      239   if P_language_type = FORTRAN_lang_type then do;
      240 				/* select proper tables */
      241       char_type_ptr = addr (probe_scan_data_$fortran_char_type);
      242       action_table_ptr = addr (probe_scan_data_$fortran_action_table);
      243     end;
      244   else if P_language_type = COBOL_lang_type then do;
      245       char_type_ptr = addr (probe_scan_data_$cobol_char_type);
      246       action_table_ptr = addr (probe_scan_data_$cobol_action_table);
      247     end;
      248   else if P_language_type = PASCAL_lang_type then do;
      249       char_type_ptr = addr (probe_scan_data_$pascal_char_type);
      250       action_table_ptr = addr (probe_scan_data_$pascal_action_table);
      251     end;
      252   else if P_language_type = C_lang_type then do;
      253       char_type_ptr = addr (probe_scan_data_$c_char_type);
      254       action_table_ptr = addr (probe_scan_data_$c_action_table);
      255     end;
      256   else do;
      257     char_type_ptr = addr (probe_scan_data_$pl1_char_type);
      258     action_table_ptr = addr (probe_scan_data_$pl1_action_table);
      259   end;
      260 
      261 
      262   First_token = null ();
      263   Last_token = null ();
      264   Paren_level = 0;
      265 
      266   Cur_state = NULL_STATE;
      267 
      268 
      269 
      270 
      271 
      272   /* ***** FINITE STATE MACHINE ***** */
      273 
      274 
      275   do Cur_pos = 1 to length (input_string);
      276 
      277     Cur_char = substr (input_string, Cur_pos, 1);
      278     if rank (Cur_char) > hbound (char_type, 1)
      279       then Char_type = ILLEGAL_CHAR_TYPE;
      280       else Char_type = char_type (rank (Cur_char));
      281 
      282     /* Can come here after an action has changed states to re-interpret Cur_char in new state */
      283 
      284 REPROC:
      285     goto ACTION (action_table (Cur_state, Char_type));
      286 
      287 AR:				/* most actions jump back here when done */
      288 
      289   end;
      290 
      291   /* if last char wasn't a new-line, pretend we have another one-
      292*
      293*   this is a bit of a kludge, because all routines jump back to AR or REPROC.
      294*   But we have do do it, so that numbers and identifiers get finished off.
      295*   And we can't just stick a NL after the string.
      296*   Fortunately, nobody is looking at Cur_pos, because this pseduo-CR has no valid position.
      297**/
      298 
      299   if Cur_char ^= CR then do;
      300       Cur_char = CR;
      301       Char_type = char_type (rank (Cur_char));
      302       goto REPROC;
      303     end;
      304 
      305   /* once that's done, we can check for unbalanced parens, quotes,  dot-operators, etc. */
      306 
      307   if Paren_level ^= 0
      308     then call LOSS (probe_et_$unbalanced_parens);
      309   if Cur_state = STRING_STATE then do;
      310       if regexp_sw
      311         then call probe_error_$record (probe_info_ptr, 0,
      312 	        "No closing / for regular expression.");
      313         else call probe_error_$record (probe_info_ptr, 0, "Unbalanced quotes")
      314 	        ;
      315       goto RECORDED_MESSAGE;
      316     end;
      317 
      318   if Cur_state = IN_DOT_OP_STATE then do;
      319       call probe_error_$record (probe_info_ptr, 0,
      320 	 "Ends in an incomplete FORTRAN logical operator or constant");
      321       goto RECORDED_MESSAGE;
      322     end;
      323 
      324 EXIT:				/* all returns come through here */
      325   P_code = code;
      326   P_input_used_lth = Cur_pos;		/* fencepost maybe possible ?? */
      327   P_first_token = First_token;
      328 
      329 MAIN_RETURN:
      330 
      331   return;
      332 
      333 LOSS:
      334   proc (ecode);			/* call me to set error and return */
      335   dcl ecode		fixed bin (35) parameter;
      336   code = ecode;
      337   Cur_pos = 0;			/* show our disgust */
      338   goto EXIT;
      339   end LOSS;
      340 
      341 RECORDED_MESSAGE:
      342   code = probe_et_$recorded_message;
      343   goto EXIT;
      344 
      345   /* NOW COME THE ACTIONS - begining on next page  */
      346 
      347 ACTION (1):			/* when white space is seen in NULL state, it means
      348*						   that previous token was followed by white - set its flag */
      349   if Last_token ^= null ()
      350     then Last_token -> token.header.flags.trailing_whitespace = "1"b;
      351 
      352   goto AR;
      353 
      354 
      355 
      356 ACTION (11):			/* a left paren */
      357   Paren_level = Paren_level + 1;
      358   Token_pos = Cur_pos;
      359   call build_operator_from_char (Cur_char);
      360   goto AR;
      361 
      362 
      363 ACTION (12):			/* right paren */
      364   Paren_level = Paren_level - 1;
      365   if Paren_level < 0
      366     then call LOSS (probe_et_$unbalanced_parens);
      367   Token_pos = Cur_pos;
      368   call build_operator_from_char (Cur_char);
      369   goto AR;
      370 
      371 
      372 
      373 ACTION (13):			/* random ops */
      374   Token_pos = Cur_pos;
      375   if Cur_char = "/" & Last_token = First_token then do;
      376 				/* "/" right after the request name */
      377       Cur_state = STRING_STATE;	/* starts a regular expression */
      378       regexp_sw = "1"b;
      379       string_buffer = "/";
      380     end;
      381     else call build_operator_from_char (Cur_char);
      382   goto AR;
      383 
      384 
      385 
      386 ACTION (14):			/* a dot */
      387   Cur_state = DOT_SEEN_STATE;
      388   Token_pos = Cur_pos;
      389   goto AR;
      390 
      391 
      392 
      393 ACTION (15):			/* first op of a possible double op series */
      394   string_buffer = Cur_char;		/* save it */
      395   Cur_state = POSSIBLE_DOUBLE_STATE;
      396   Token_pos = Cur_pos;
      397   goto AR;
      398 
      399 
      400 
      401 ACTION (16):			/* PASCAL_ARROW char encountered in NULL STATE */
      402   Token_pos = Cur_pos;
      403   call build_operator (bin (substr (PASCAL_ARROW, 13)));
      404   go to AR;
      405 
      406 ACTION (20):			/* a digit - starts a number */
      407   Cur_state = NUMBER_PRE_DOT_STATE;
      408   Token_pos = Cur_pos;
      409   string_buffer = Cur_char;
      410   goto AR;
      411 
      412 
      413 ACTION (21):			/* saw a dot then a number */
      414   Cur_state = NUMBER_POST_DOT_STATE;
      415   string_buffer = ".";
      416   call append (Cur_char);
      417   goto AR;
      418 
      419 
      420 ACTION (22):			/* more numbers */
      421   call append (Cur_char);
      422   goto AR;
      423 
      424 
      425 ACTION (23):			/* something that can't go in a number */
      426   call build_number;		/* finish the number */
      427   Cur_state = NULL_STATE;
      428   goto REPROC;			/* re-interpret the char */
      429 
      430 
      431 ACTION (24):			/* a dot in middle */
      432   call append (Cur_char);
      433   Cur_state = NUMBER_POST_DOT_STATE;
      434   goto AR;
      435 
      436 
      437 ACTION (25):			/* sign is part of exponent */
      438   Cur_state = NUMBER_EXP2_STATE;	/* only one + or - per exponnet, tho */
      439   call append (Cur_char);
      440   goto AR;
      441 
      442 ACTION (26):			/* saw an "e" or an "f" build exponent */
      443   call append (Cur_char);
      444   Token_pos = Cur_pos;
      445   Cur_state = NUMBER_EXP1_STATE;
      446   goto AR;
      447 
      448 
      449 ACTION (27):			/* an i - end of number */
      450   call append (Cur_char);
      451   call build_number;
      452   Cur_state = NULL_STATE;
      453   goto AR;
      454 
      455 
      456 ACTION (28):			/* an "o" - interp as octal */
      457   call build_octal;
      458   Cur_state = NULL_STATE;
      459   goto AR;
      460 
      461 ACTION (30):			/* name begins */
      462   Cur_state = NAME_STATE;
      463   Token_pos = Cur_pos;
      464   string_buffer = Cur_char;
      465   goto AR;
      466 
      467 ACTION (31):			/* name continues */
      468   call append (Cur_char);
      469   goto AR;
      470 
      471 
      472 ACTION (32):			/* name ends */
      473   if P_language_type = PASCAL_lang_type then do;
      474       do i = 1 to hbound (probe_scan_data_$pasc_ops, 1);
      475         if probe_scan_data_$pasc_ops (i).name = string_buffer then do;
      476 	  call build_operator (probe_scan_data_$pasc_ops (i).op_code);
      477 	  Cur_state = NULL_STATE;
      478 	  goto REPROC;
      479 	end;
      480       end;
      481     end;
      482   call build_name;
      483   Cur_state = NULL_STATE;
      484   goto REPROC;
      485 
      486 ACTION (36):			/* have hyphen in COBOL mode */
      487   call append ("-");
      488   goto AR;			/* treat it same as an underscore */
      489 
      490 ACTION (40):			/* begin quoted */
      491   Cur_state = STRING_STATE;
      492   regexp_sw = "0"b;
      493   Token_pos = Cur_pos;
      494   string_buffer = "";
      495   goto AR;
      496 
      497 
      498 ACTION (41):			/* anything but quote */
      499   call append (Cur_char);
      500   if Cur_char = "/" & regexp_sw then do;/* another slash inside regular expression */
      501       if length (string_buffer) > 2
      502         then
      503 	   if substr (string_buffer, length (string_buffer) - 2, 2) = "\c"
      504 	     then go to AR;		/* literal slash */
      505       Cur_state = QUOTE_SEEN_STATE;
      506     end;
      507   goto AR;
      508 
      509 
      510 ACTION (42):
      511   if regexp_sw
      512     then call append (Cur_char);	/* quota means nothing inside regular expression */
      513     else Cur_state = QUOTE_SEEN_STATE;	/* prepare for end of string */
      514   goto AR;
      515 
      516 
      517 
      518 ACTION (45):			/* almost anything after a quote is true end */
      519 END_STRING:
      520   call build_char_string;
      521   Cur_state = NULL_STATE;
      522   goto REPROC;
      523 
      524 
      525 ACTION (46):			/* b after quote - is bit string */
      526   if regexp_sw
      527     then go to END_STRING;
      528   Cur_state = BIT_STR_END_STATE;	/* but what kind? b1? b2? b3? */
      529   goto AR;			/* we'll find out next char */
      530 
      531 
      532 ACTION (47):			/* o after ", is octal string */
      533   if regexp_sw
      534     then go to END_STRING;
      535   call build_bit_string (3);		/* radix 3 */
      536   Cur_state = NULL_STATE;
      537   goto AR;
      538 
      539 
      540 ACTION (48):			/* another quote - is quote doubling */
      541   if regexp_sw
      542     then go to END_STRING;
      543   call append (Cur_char);
      544   Cur_state = STRING_STATE;
      545   goto AR;
      546 
      547 ACTION (50):			/* a digit from 1 to 4 after  "b */
      548   call build_bit_string (fixed (Cur_char));
      549   Cur_state = NULL_STATE;
      550   goto AR;
      551 
      552 
      553 ACTION (51):			/* anthing else after "b default radix is 1 */
      554   call build_bit_string (1);
      555   Cur_state = NULL_STATE;
      556   goto REPROC;
      557 
      558 
      559 
      560 
      561 
      562 
      563 
      564 
      565 ACTION (55):			/* after a dot, a non-letter */
      566   call build_operator_from_char (".");
      567   Cur_state = NULL_STATE;
      568   goto REPROC;
      569 
      570 
      571 ACTION (56):			/* letter after dot (FORTRAN only ) */
      572   Cur_state = IN_DOT_OP_STATE;
      573   string_buffer = Cur_char;
      574   goto AR;
      575 
      576 
      577 ACTION (57):			/* a letter in DOT_OP_STATE */
      578   call append (Cur_char);
      579   goto AR;
      580 
      581 
      582 ACTION (58):			/* final dot delimts */
      583   do i = 1 to hbound (probe_scan_data_$fort_ops, 1);
      584     if probe_scan_data_$fort_ops (i).name = string_buffer then do;
      585 FORTRAN_DOT_OPERATOR:
      586         call build_dot;
      587         Cur_state = NULL_STATE;
      588         go to AR;
      589       end;
      590   end;
      591   if string_buffer = "true" | string_buffer = "false"
      592     then go to FORTRAN_DOT_OPERATOR;
      593   go to NOT_FORTRAN_DOT_OPERATOR;
      594 
      595 
      596 ACTION (59):			/* .foo<not .> might be an entryname (FORTRAN) */
      597 NOT_FORTRAN_DOT_OPERATOR:
      598   call append (Cur_char);
      599   call build_name;
      600   Cur_state = NULL_STATE;
      601   go to REPROC;
      602 
      603 ACTION (60):			/* ptr begins with | after digits */
      604   ptr_segno = cv_oct_check_ ((string_buffer), code);
      605   if code ^= 0
      606     then call segno_err (substr (string_buffer, code, 1));
      607   ptr_wordno, ptr_bitno, ptr_offset = 0;
      608   string_buffer = "";
      609   Cur_state = PTR_WORD_STATE;
      610   goto AR;
      611 
      612 
      613 ACTION (61):			/* digits for wordno or bitno */
      614   call append (Cur_char);
      615   goto AR;
      616 
      617 
      618 ACTION (62):			/* paren begins bit offset */
      619   ptr_wordno = cv_oct_check_ ((string_buffer), code);
      620   if code ^= 0
      621     then call wordno_err (substr (string_buffer, code, 1));
      622   string_buffer = "";
      623   Cur_state = PTR_BIT_STATE;
      624   goto AR;
      625 
      626 
      627 ACTION (63):			/* right paren ends bit offset */
      628   ptr_bitno = cv_dec_check_ ((string_buffer), code);
      629   if code ^= 0
      630     then call bitno_err (substr (string_buffer, code, 1));
      631 
      632   call build_pointer;
      633   Cur_state = NULL_STATE;
      634   goto AR;
      635 
      636 
      637 ACTION (64):			/* other char, while in word no */
      638   ptr_wordno = cv_oct_check_ ((string_buffer), code);
      639   if code ^= 0
      640     then call wordno_err (substr (string_buffer, code, 1));
      641   call build_pointer;
      642   Cur_state = NULL_STATE;
      643   goto REPROC;
      644 
      645 ACTION (65):			/* vertical bar after name */
      646   begin;
      647     dcl init_ptr		  ptr;
      648     if string_buffer = "sp"
      649       then init_ptr = current_source.stack_ptr;
      650     else if string_buffer = "lp"
      651       then init_ptr = current_source.seg_info_ptr -> seg_info.linkage_ptr;
      652     else if string_buffer = "tp"
      653       then init_ptr = pointer (current_source.instruction_ptr, 0);
      654     else if string_buffer = "ip"
      655       then init_ptr = current_source.instruction_ptr;
      656     else do;
      657       call append (Cur_char);		/* a virtual entry of the form path|N */
      658       go to AR;
      659     end;
      660 
      661     ptr_segno = binary (baseno (init_ptr), 18);
      662     ptr_offset = binary (rel (init_ptr), 18);
      663   end;				/* begin */
      664 
      665   Cur_state = PTR_WORD_STATE;
      666   string_buffer = "";
      667   goto AR;
      668 
      669 ACTION (70):			/* another char after poss. double op
      670*						   but we dont form a double op */
      671   call build_operator_from_char (substr (string_buffer, 1, 1));
      672   Cur_state = NULL_STATE;
      673   goto REPROC;
      674 
      675 
      676 ACTION (71):			/* possible double */
      677   if Cur_state = DOT_SEEN_STATE
      678     then string_buffer = ".";		/* first dot seen doesn't normally get saved */
      679 
      680   call append (Cur_char);
      681 
      682   if P_language_type = PASCAL_lang_type
      683        & index (reverse (string_buffer), "..") = 1 then do;
      684 				/* number.. = Pascal range */
      685       if length (string_buffer) > 2 then do;
      686 	string_buffer =
      687 	     substr (string_buffer, 1, length (string_buffer) - 2);
      688 	call build_number;
      689         end;
      690       call build_operator_from_char (":");
      691 				/* Pascal ".." becomes cross-section */
      692       Cur_state = NULL_STATE;
      693       go to AR;
      694     end;
      695 
      696   do i = 1 to hbound (probe_scan_data_$doubles, 1);
      697     if string_buffer = probe_scan_data_$doubles (i).pair then do;
      698         if string_buffer = ".." & P_language_type = PASCAL_lang_type
      699 	then
      700 	     call build_operator_from_char (":");
      701 				/* Pascal ".." becomes cross-section */
      702 	else call build_operator (probe_scan_data_$doubles (i).type);
      703         Cur_state = NULL_STATE;
      704         goto AR;
      705       end;
      706   end;
      707   call build_operator_from_char (substr (string_buffer, 1, 1));
      708   Token_pos = Cur_pos;
      709   call build_operator_from_char (Cur_char);
      710   Cur_state = NULL_STATE;
      711   goto AR;
      712 
      713 
      714 
      715   /* Action Specific for C to handle the address (&) and mod (%) operators */
      716 
      717 
      718   /* ACTION (80): */
      719 
      720 
      721 
      722   /* THESE ARE ERROR ACTIONS */
      723 
      724 
      725 ACTION (90):
      726   call probe_error_$record (probe_info_ptr, 0,
      727        "Too many decimal points in number (after: ""^a"")", string_buffer);
      728   goto RECORDED_MESSAGE;
      729 
      730 
      731 ACTION (91):
      732   call probe_error_$record (probe_info_ptr, 0,
      733        "Syntax error in segment number of pointer constant");
      734   goto RECORDED_MESSAGE;
      735 
      736 
      737 
      738 ACTION (92):
      739   call probe_error_$record (probe_info_ptr, 0,
      740        "Bad character in number: ^a after ^a",
      741        safety (Cur_char), string_buffer);
      742   goto RECORDED_MESSAGE;
      743 
      744 
      745 ACTION (93):
      746   call wordno_err (Cur_char);
      747   goto RECORDED_MESSAGE;
      748 
      749 
      750 ACTION (95):
      751   call bitno_err (Cur_char);
      752   goto RECORDED_MESSAGE;
      753 
      754 
      755 
      756 ACTION (99):
      757   call probe_error_$record (probe_info_ptr, probe_et_$illegal_char, "^a",
      758        safety (Cur_char));
      759   goto RECORDED_MESSAGE;
      760 
      761 
      762 
      763 wordno_err:
      764   proc (c);
      765   dcl c			char (1) aligned parameter;
      766   call probe_error_$record (probe_info_ptr, 0,
      767        "Non octal char in word offset of pointer constant: ^a", safety (c));
      768   goto RECORDED_MESSAGE;
      769 
      770 segno_err:
      771   entry (c);
      772   call probe_error_$record (probe_info_ptr, 0,
      773        "Non octal char in segment number of pointer constant: ^a", safety (c))
      774        ;
      775   goto RECORDED_MESSAGE;
      776 
      777 
      778 bitno_err:
      779   entry (c);
      780   call probe_error_$record (probe_info_ptr, 0,
      781        "Non decimal char in bit offset of pointer constant: ^a", safety (c));
      782   goto RECORDED_MESSAGE;
      783   end;
      784 
      785 
      786 safety:
      787   proc (cc) returns (char (6) aligned);
      788   dcl cc			char (1) aligned parameter;
      789   dcl (digit1, digit2, digit3, ncc)
      790 			fixed;
      791   dcl rsc			char (6) aligned;
      792   dcl ioa_$rsnnl		entry options (variable);
      793 
      794   dcl printable_chars	char (94) internal static
      795 			options (constant) init
      796 			(
      797 			"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,<.>/?;+:*`@_}]~^-=)('&%$#""!{[|\"
      798 			);
      799 
      800   ncc = rank (cc);
      801   digit1 = divide (ncc, 64, 17, 0);
      802   ncc = ncc - digit1 * 64;
      803   digit2 = divide (ncc, 8, 17, 0);
      804   digit3 = ncc - digit2 * 8;
      805   call ioa_$rsnnl ("""^[^a^3s^;^s\^d^d^d^]""", rsc, (0),
      806        index (printable_chars, cc) > 0, cc, digit1, digit2, digit3);
      807   return (rsc);
      808   end safety;
      809 
      810 
      811 append:
      812   proc (c);
      813   dcl c			char (1) aligned parameter;
      814 
      815   if length (string_buffer) = maxlength (string_buffer)
      816     then call LOSS (probe_et_$string_long);
      817   string_buffer = string_buffer || c;
      818   end append;
      819 
      820 
      821   /* CONSTRUCTORS  called to build tokens and thread them on.  They often take input in
      822*   string_buffer, and convert it to right thing.
      823*
      824*   build_operator (op_type)
      825*   build_operator_from_char (op_char)
      826*   build_name
      827*   build_char_string
      828*   build_bit_string(radix)
      829*   build_dot
      830*   build_number
      831*   build_octal
      832*   build_pointer
      833*
      834**/
      835 
      836 build_operator_from_char:
      837   proc (op_name);
      838   dcl op_name		char (1) aligned parameter;
      839   dcl a			ptr;	/* to the op we allocate */
      840   dcl op_type		fixed bin;
      841 
      842   op_type = probe_scan_data_$operator_type (rank (op_name));
      843 
      844   goto com;
      845 
      846 build_operator:
      847   entry (pop_type);
      848   dcl pop_type		fixed bin parameter;
      849 
      850   op_type = pop_type;
      851 
      852 com:
      853 
      854   allocate operator in (token_area) set (a);
      855   call init_token (a);
      856 
      857   a -> token.header.type = OPERATOR_TYPE | bit (fixed (op_type, 18));
      858 
      859   call thread (a);
      860 
      861   /* Here we try to account for the C indirection. eg 'v *tempstr'. We don't
      862*   want to multiply, we want to get the value of whatever tempstr is 
      863*   pointing to. If the previous token is an operator, then the '*' is 
      864*   assumed to mean indirection.  If the previous token is a right 
      865*   paren then the '*' is assumed to be the TIMES operator. */
      866 
      867   if (a -> token.type = TIMES) & (P_language_type = C_lang_type) then do;
      868       if (Last_token -> token.header.prev ^= null ()) then do;
      869 	if (((Last_token -> token.header.prev -> token.header.type
      870 	     > OPERATOR_TYPE) &
      871 	     (Last_token -> token.header.prev -> token.header.type
      872 	     ^= RIGHT_PAREN) &
      873 	     (Last_token -> token.header.prev -> token.header.type
      874 	     ^= RIGHT_BRACKET)) |
      875 	     (Last_token -> token.header.prev -> token.header.prev = null))
      876 	  then
      877 	       a -> token.header.type = C_INDIRECTION;
      878         end;
      879         else a -> token.header.type = C_INDIRECTION;
      880     end;
      881 				/*
      882*          else if (a->token.type = ARROW) & (Planguage_type = C_lang_type) then
      883*	    a->token.header.type = PERIOD;
      884**/
      885 
      886   end;
      887 
      888 
      889 build_name:
      890   proc;
      891   dcl a			ptr;
      892 
      893   allocate identifier in (token_area) set (a);
      894   call init_token (a);
      895 
      896   a -> token.header.type = NAME_TYPE;
      897   a -> identifier.name = ptr_to_nth_char (Token_pos);
      898   a -> identifier.length = length (string_buffer);
      899   call thread (a);
      900 
      901   return;
      902 
      903 ptr_to_nth_char:
      904   proc (cp) returns (ptr);
      905   dcl cp			fixed bin (21) parameter;
      906   dcl char_array		(input_string_lth) char (1) unal
      907 			based (input_string_ptr);
      908   return (addr (char_array (cp)));
      909   end ptr_to_nth_char;
      910   end build_name;
      911 
      912 
      913 build_char_string:
      914   proc;
      915 
      916   dcl a			ptr;
      917   dcl based_chars		char (char_len) based;
      918   dcl char_len		fixed bin (21);
      919 
      920   a = new_constant (char_dtype * 2);
      921   a -> constant.scale = 0;
      922   char_len,
      923        a -> constant.precision,
      924        a -> constant.scale_and_precision = length (string_buffer);
      925 
      926   allocate based_chars in (token_area) set (a -> constant.data_ptr);
      927 
      928   a -> constant.data_ptr -> based_chars = string_buffer;
      929 
      930   call thread (a);
      931   end build_char_string;
      932 
      933 
      934 build_bit_string:
      935   proc (radix);
      936   dcl radix		fixed bin parameter;
      937   dcl a			ptr;
      938   dcl based_bits		bit (bit_len) based;
      939   dcl bit_len		fixed bin (24);
      940 
      941   a = new_constant (bit_dtype * 2);
      942   a -> constant.encoded_precision.scale = 0;
      943   bit_len, a -> constant.encoded_precision.precision,
      944        a -> constant.scale_and_precision = length (string_buffer) * radix;
      945 
      946   allocate based_bits in (token_area) set (a -> constant.data_ptr);
      947 
      948 convert_chars_to_bit:
      949   begin;
      950 
      951     dcl output_index	  fixed bin;
      952     dcl c			  char (1) aligned;
      953 				/* current char being converted */
      954     dcl input_index		  fixed bin;
      955 				/* index of c in input_chars */
      956     dcl fb4		  fixed bin (4);
      957 
      958     dcl radix_chars		  (4) char (16) static internal
      959 			  options (constant)
      960 			  init /*   the chars valid in radix */
      961 			  ("0100000000000000",
      962 				/* we will take index of these */
      963 			  "0123000000000000",
      964 			  "0123456700000000",
      965 			  "0123456789ABCDEF");
      966 
      967     output_index = 1;
      968 
      969     do input_index = 1 to length (string_buffer);
      970 				/* for each char in input */
      971       c = substr (string_buffer, input_index, 1);
      972       if radix = 4
      973         then c = translate (c, "ABCDEF", "abcdef");
      974 				/* hex can be in either case */
      975       fb4 = index (radix_chars (radix), c) - 1;
      976 				/* "0" has index 1, but "is" 0 */
      977       if fb4 < 0 then do;
      978 	call probe_error_$record (probe_info_ptr, 0,
      979 	     "Non-^[binary^;quaternary^;octal^;hex^] character ^a in bit string",
      980 	     radix, safety (c));
      981 	goto RECORDED_MESSAGE;
      982         end;
      983 
      984       /* *	Now fb4 is the number whose bit value is to inserted into the string., that is,
      985*   *	if c is "A" (which implies radix = 4), then fb4 is decimal 10, or "1010"b
      986*   *	For radices lower than four we want  to strip of the leading zeroes. The index
      987*   *	of the first significant bit is given by (5 - radix). */
      988 
      989       substr (a -> constant.data_ptr -> based_bits, output_index, radix) =
      990 	 /* write as many bits as called for */
      991 	 substr (bit (fb4), 5 - radix, radix);
      992       output_index = output_index + radix;
      993 				/* where next string will begin */
      994     end;				/* loop through characters */
      995 
      996   end convert_chars_to_bit;		/* begin block */
      997 
      998 
      999   call thread (a);
     1000   end build_bit_string;
     1001 
     1002 build_dot:
     1003   proc;
     1004   dcl a			ptr;
     1005   dcl based_logical		bit (1) aligned based;
     1006   dcl i			fixed bin;
     1007 
     1008 
     1009   if string_buffer = "true" | string_buffer = "false"
     1010     then do;
     1011       a = new_constant (bit_dtype * 2);
     1012       a -> constant.encoded_precision.scale = 0;
     1013       a -> constant.encoded_precision.precision,
     1014 	 a -> constant.scale_and_precision = 1;
     1015 
     1016       allocate based_logical in (token_area) set (a -> constant.data_ptr);
     1017 
     1018       if string_buffer = "true"
     1019         then a -> constant.data_ptr -> based_logical = "1"b;
     1020         else a -> constant.data_ptr -> based_logical = "0"b;
     1021       call thread (a);
     1022 
     1023     end;				/* logical constant */
     1024     else do;			/* hope its an operator */
     1025       do i = 1 to hbound (probe_scan_data_$fort_ops, 1);
     1026         if probe_scan_data_$fort_ops (i).name = string_buffer
     1027 	then goto MATCH;
     1028       end;
     1029 
     1030       /* fell out - bad name */
     1031 
     1032       call probe_error_$record (probe_info_ptr, 0,
     1033 	 """^a"" is not a recognized FORTRAN operator ", string_buffer);
     1034       goto RECORDED_MESSAGE;
     1035 
     1036 MATCH:
     1037       call build_operator (probe_scan_data_$fort_ops (i).op_code);
     1038     end;				/* making operator */
     1039   end build_dot;
     1040 
     1041 
     1042 build_number:
     1043   proc;
     1044 
     1045   dcl dtype_found		fixed bin (35);
     1046   dcl scale_prec_found	fixed bin (35);
     1047   dcl temp_target		char (256);
     1048 				/* no arith constant can exceed 64 words */
     1049   dcl data_size		fixed bin;/* how many bits data is */
     1050   dcl based_bits		bit (data_size) based;
     1051   dcl a			ptr;
     1052   dcl numbuf		char (128) aligned;
     1053   dcl char_to_numeric_	entry (ptr, fixed bin (35), fixed bin (35), ptr,
     1054 			fixed bin);
     1055   dcl get_size_in_bits_	entry (fixed bin, fixed bin (35),
     1056 			bit (1) aligned) returns (fixed bin);
     1057 
     1058   numbuf = string_buffer;
     1059   call char_to_numeric_ (addr (temp_target), dtype_found, scale_prec_found,
     1060        addr (numbuf), length (string_buffer));
     1061 
     1062   a = new_constant ((dtype_found));
     1063   a -> constant.scale_and_precision = scale_prec_found;
     1064   unspec (a -> constant.encoded_precision) = unspec (scale_prec_found);
     1065 
     1066   data_size =
     1067        get_size_in_bits_ (divide (dtype_found, 2, 17, 0), scale_prec_found,
     1068        bit (mod (dtype_found, 2)));
     1069 
     1070   allocate based_bits in (token_area) set (a -> constant.data_ptr);
     1071 
     1072   a -> constant.data_ptr -> based_bits = addr (temp_target) -> based_bits;
     1073 
     1074   call thread (a);
     1075   end build_number;
     1076 
     1077 
     1078 build_octal:
     1079   proc;
     1080 
     1081   dcl a			ptr;
     1082   dcl code		fixed bin (35);
     1083   dcl based_fixed		fixed bin (35) based;
     1084 
     1085 
     1086   a = new_constant (real_fix_bin_1_dtype * 2);
     1087 
     1088   a -> constant.scale = 0;
     1089   a -> constant.precision, a -> constant.scale_and_precision = 35;
     1090 
     1091   allocate based_fixed in (token_area) set (a -> constant.data_ptr);
     1092 
     1093   a -> constant.data_ptr -> based_fixed =
     1094        cv_oct_check_ ((string_buffer), code);
     1095   if code ^= 0 then do;
     1096       call probe_error_$record (probe_info_ptr, 0,
     1097 	 "Non octal difgit in ""^a""o", string_buffer);
     1098       goto RECORDED_MESSAGE;
     1099     end;
     1100 
     1101   call thread (a);
     1102   end build_octal;
     1103 
     1104 
     1105 build_pointer:
     1106   proc;
     1107 
     1108   dcl a			ptr;
     1109   dcl based_ptr		based ptr;
     1110 
     1111   dcl 1 its_you		aligned like its_unsigned;
     1112 
     1113 
     1114   unspec (its_you) = "0"b;
     1115   its_you.segno = ptr_segno;
     1116   its_you.offset = ptr_offset + ptr_wordno;
     1117   its_you.bit_offset = ptr_bitno;
     1118   its_you.ringno = get_ring_ ();
     1119   its_you.its_mod = ITS_MODIFIER;
     1120 
     1121   a = new_constant (pointer_dtype * 2);
     1122   a -> constant.encoded_precision,
     1123        a -> constant.scale_and_precision = 0;
     1124 
     1125   allocate based_ptr in (token_area) set (a -> constant.data_ptr);
     1126   unspec (a -> constant.data_ptr -> based_ptr) = unspec (its_you);
     1127 
     1128   call thread (a);
     1129   end build_pointer;
     1130 
     1131 
     1132 new_constant:
     1133   proc (dt) returns (ptr);
     1134   dcl dt			fixed bin parameter;
     1135   dcl a			ptr;
     1136 
     1137 
     1138   allocate constant in (token_area) set (a);
     1139   call init_token (a);
     1140   a -> token.header.type = CONSTANT_TYPE;
     1141   a -> constant.data_type = dt;
     1142   return (a);
     1143   end new_constant;
     1144 
     1145 
     1146 
     1147 init_token:
     1148   proc (tp);
     1149   dcl tp			ptr parameter;
     1150 
     1151 
     1152   tp -> token.header.next = null ();
     1153   tp -> token.header.prev = Last_token;
     1154   tp -> token.header.buffer_ptr = input_string_ptr;
     1155   tp -> token.header.location = Token_pos;
     1156   tp -> token.header.flags = "0"b;
     1157   if Last_token ^= null ()
     1158     then tp -> token.header.flags.leading_whitespace =
     1159 	    Last_token -> token.header.trailing_whitespace;
     1160   end init_token;
     1161 
     1162 
     1163 
     1164 thread:
     1165   proc (t);
     1166   dcl t			ptr parameter;
     1167 
     1168 
     1169   if First_token = null ()
     1170     then First_token = t;
     1171     else Last_token -> token.next = t;
     1172   Last_token = t;
     1173   end thread;
     1174 
     1175   /*	INCLUDE FILES		*/
     1176 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
     1177 
  2     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  2     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  2     3 
  2     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  2     5     2 next pointer unaligned,				/* pointer to next token in chain */
  2     6     2 prev pointer unaligned,				/* same for previous token */
  2     7     2 type bit (18) aligned,
  2     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  2     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  2    10     2 length fixed bin (17) unal,
  2    11     2 flags aligned,
  2    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  2    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  2    14       3 pad1 bit (34) unaligned;
  2    15 
  2    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  2    17     2 header aligned like token_header;			/* that's all there is */
  2    18 
  2    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  2    20     2 header aligned like token_header,
  2    21     2 length fixed bin,				/* length of name */
  2    22     2 name pointer unaligned;				/* to string in buffer containing name */
  2    23 
  2    24 dcl 1 operator aligned based,				/* for punctuation */
  2    25     2 header aligned like token_header;			/* nothing but a header here */
  2    26 
  2    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  2    28     2 header aligned like token_header,
  2    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  2    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  2    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  2    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  2    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  2    34     2 data_ptr pointer unaligned;
  2    35 
  2    36 
  2    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  2    38      NAME_TYPE init ("010"b),
  2    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  2    40 
  2    41 
  2    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  2    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  2    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  2    45 dcl 1 current_token aligned like token based (probe_info.ct);
  2    46 
  2    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
     1178 
  3     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  3     2*
  3     3*   JRD 26 June 79
  3     4*   MBW 31 July 1981 to add algol68 */
  3     5 
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  3     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  3    10*     Added C Language type.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  3    15 /*   Modified April 88 Hinatsu to add C language type */
  3    16 
  3    17      dcl	   (UNKNOWN_lang_type     init (1),
  3    18 	   OTHER_lang_type	      init (2),
  3    19 	   PL1_lang_type	      init (3),
  3    20 	   FORTRAN_lang_type      init (4),
  3    21 	   COBOL_lang_type	      init (5),
  3    22 	   ALM_lang_type	      init (6),
  3    23 	   ALGOL68_lang_type      init (7),
  3    24 	   PASCAL_lang_type	      init (8),
  3    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  3    26 
  3    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  3    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  3    29 
  3    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  3    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  3    32 
  3    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
     1179 
  4     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4     8*     Added new C operators.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* These are the operator.types for each defined operator */
  4    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  4    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  4    15 /* Modified April 88 Hinatsu Addition of C types */
  4    16 
  4    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  4    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  4    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  4    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  4    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  4    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  4    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  4    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  4    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  4    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  4    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  4    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  4    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  4    30 
  4    31 /* Additons to support C types */
  4    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  4    33 
  4    34 /* operator 28 are left for future expansion */
  4    35 
  4    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  4    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  4    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  4    39 	   C_INDIRECTION          init ("400034"b3)
  4    40 
  4    41 	   )		      bit (18) aligned internal static options (constant);
  4    42 
  4    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  4    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  4    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  4    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  4    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  4    48 			      "==", "!=", ";","
  4    49 ");
  4    50 
  4    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
     1180 
  5     1 /* BEGIN INCLUDE FILE ... probe_scan_dcls.incl.pl1
  5     2*
  5     3*   James R. Davis 27 July 79
  5     4*   Modified JMAthane June 83 to add PASCAL_ARROW char type
  5     5*   Added COLON_CHAR_TYPE to be used in Pascal operator ":=" 07/26/83 S. Herbst
  5     6*   Modified April 88 Hinatsu to add the C_ADDRESS_CHAR_TYPE, and
  5     7*    C_MOD_CHAR_TYPE to support C
  5     8*
  5     9*   The names of all the  STATES the Finite State Machine can assume */
  5    10 
  5    11      
  5    12 
  5    13 /****^  HISTORY COMMENTS:
  5    14*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  5    15*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  5    16*     Added declarations for C input action tables.
  5    17*                                                   END HISTORY COMMENTS */
  5    18 
  5    19 
  5    20 dcl	   (NULL_STATE	      init (1),
  5    21 	   POSSIBLE_DOUBLE_STATE  init (2),
  5    22 	   NAME_STATE	      init (3),
  5    23 	   STRING_STATE	      init (4),
  5    24 	   QUOTE_SEEN_STATE	      init (5),
  5    25 	   BIT_STR_END_STATE      init (6),
  5    26 	   DOT_SEEN_STATE	      init (7),
  5    27 	   NUMBER_PRE_DOT_STATE   init (8),
  5    28 	   NUMBER_POST_DOT_STATE  init (9),
  5    29 	   NUMBER_EXP1_STATE      init (10),
  5    30 	   NUMBER_EXP2_STATE      init (11),
  5    31 	   IN_DOT_OP_STATE	      init (12),
  5    32 	   PTR_WORD_STATE	      init (13),
  5    33 	   PTR_BIT_STATE	      init (14))
  5    34 			      fixed bin internal static options (constant);
  5    35 
  5    36 /* The types of single character that are recognized: */
  5    37 
  5    38      dcl	   (ILLEGAL_CHAR_TYPE     init (0),
  5    39 	   LEFT_PAREN_CHAR_TYPE   init (1),
  5    40 	   RIGHT_PAREN_CHAR_TYPE  init (2),
  5    41 	   DOT_CHAR_TYPE	      init (3),
  5    42 	   VERTICAL_BAR_CHAR_TYPE init (4),
  5    43 	   PLUS_CHAR_TYPE	      init (5),
  5    44 	   MINUS_CHAR_TYPE	      init (6),
  5    45 	   GREATER_CHAR_TYPE      init (7),
  5    46 	   LESS_CHAR_TYPE	      init (8),
  5    47 	   EQUAL_CHAR_TYPE	      init (9),
  5    48 	   NOT_CHAR_TYPE	      init (10),		/* ^ */
  5    49 	   ZERO_CHAR_TYPE	      init (11),		/* 0 */
  5    50 	   RADIX_DIGITS_CHAR_TYPE init (12),		/* 1-4 can be used after "..."b */
  5    51 	   OCTAL_DIGITS_CHAR_TYPE init (13),		/* 5 - 7 */
  5    52 	   OTHER_DIGITS_CHAR_TYPE init (14),		/* 8-9 */
  5    53 	   LETTER_B_CHAR_TYPE     init (15),		/* speaking words of wisdom */
  5    54 	   LETTER_E_CHAR_TYPE     init (16),
  5    55 	   LETTER_I_CHAR_TYPE     init (17),
  5    56 	   LETTER_O_CHAR_TYPE     init (18),
  5    57 	   LETTER_F_CHAR_TYPE     init (19),
  5    58 	   QUOTE_CHAR_TYPE	      init (20),		/* ",  and ' for FORTRAN */
  5    59 	   WHITE_SPACE_CHAR_TYPE  init (21),		/* SP, CR, HT */
  5    60 	   OTHER_LETTER_CHAR_TYPE init (22),
  5    61 	   COLON_CHAR_TYPE	      init (23),		/* : */
  5    62 	   OTHER_OPS_CHAR_TYPE    init (24),
  5    63 	   PASCAL_ARROW_CHAR_TYPE init (25),
  5    64              C_ADDRESS_CHAR_TYPE    init (26),
  5    65              C_MOD_CHAR_TYPE        init (27)) fixed bin (17) unal internal static options (constant);
  5    66 
  5    67 /* END INCLUDE FILE ... probe_scan_dcls.incl.pl1 */
     1181 
  6     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  6     2*
  6     3*  James R. Davis 2 July 79 */
  6     4 
  6     5 dcl 1 source_info based aligned,
  6     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  6     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  6     8       2 block_ptr ptr,				/* to runtime_block node */
  6     9       2 stack_ptr ptr,				/* to a stack frame */
  6    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  6    11       2 seg_info_ptr ptr;				/* to seg_info */
  6    12 
  6    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  6    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  6    15 
  6    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
     1182 
  7     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  7     2*
  7     3*   25 June 79 JRDavis
  7     4*
  7     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  7     6*	correction per file.
  7     7**/
  7     8 
  7     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  7    10     2 language_type fixed bin,			/* language of source program */
  7    11     2 bits aligned,
  7    12       3 ignore_case bit (1) unal,
  7    13       3 bound_segment bit (1) unaligned,
  7    14       3 component bit (1) unaligned,
  7    15       3 pad bit (33) unal,
  7    16     2 names,					/* where to find it */
  7    17       3 directory_name character (168) unal,		/* what directory */
  7    18       3 entry_name character (32) unal,			/* what segment */
  7    19       3 segname character (32) unal,			/* procedure segname definition */
  7    20     2 identifier fixed bin (71),			/* time of object creation */
  7    21     2 pointers,					/* location of various parts of segment */
  7    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  7    23       3 original_source_ptr ptr unal,			/* to segment source map */
  7    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  7    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  7    26*						   bound ones, -> break_map !obsolete, I think! */
  7    27       3 chain ptr unal,				/* to entry for next component if bound */
  7    28       3 linkage_ptr ptr unal,				/* to linkage section */
  7    29     2 bounds aligned,				/* structure of bounds information */
  7    30       3 text_bounds,
  7    31         4 start fixed bin (35),
  7    32         4 end fixed bin (35),
  7    33       3 symbol_bounds,
  7    34         4 start fixed bin (35),
  7    35         4 end fixed bin (35),
  7    36     2 map_size fixed bin,				/* size of statement map */
  7    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  7    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  7    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  7    40     2 pad (1) fixed bin (35),
  7    41 
  7    42     2 nfiles fixed bin,
  7    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  7    44       3 file_pointers ptr unal,
  7    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  7    46 
  7    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  7    48 
  7    49 
  7    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
     1183 
     1184 
  8     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  8     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  8     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  8     8*     Objects of this type are PASCAL string types.
  8     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  8    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  8    11*     Added the new C types.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 /* This include file defines mnemonic names for the Multics
  8    15*   standard descriptor types, using both pl1 and cobol terminology.
  8    16*   PG 780613
  8    17*   JRD 790530
  8    18*   JRD 791016
  8    19*   MBW 810731
  8    20*   TGO 830614 Add hex types.
  8    21*   Modified June 83 JMAthane to add PASCAL data types
  8    22*   TGO 840120 Add float dec extended and generic, float binary generic
  8    23**/
  8    24 
  8    25      dcl	   (real_fix_bin_1_dtype  init (1),
  8    26 	   real_fix_bin_2_dtype   init (2),
  8    27 	   real_flt_bin_1_dtype   init (3),
  8    28 	   real_flt_bin_2_dtype   init (4),
  8    29 	   cplx_fix_bin_1_dtype   init (5),
  8    30 	   cplx_fix_bin_2_dtype   init (6),
  8    31 	   cplx_flt_bin_1_dtype   init (7),
  8    32 	   cplx_flt_bin_2_dtype   init (8),
  8    33 	   real_fix_dec_9bit_ls_dtype init (9),
  8    34 	   real_flt_dec_9bit_dtype init (10),
  8    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  8    36 	   cplx_flt_dec_9bit_dtype init (12),
  8    37 	   pointer_dtype	      init (13),
  8    38 	   offset_dtype	      init (14),
  8    39 	   label_dtype	      init (15),
  8    40 	   entry_dtype	      init (16),
  8    41 	   structure_dtype	      init (17),
  8    42 	   area_dtype	      init (18),
  8    43 	   bit_dtype	      init (19),
  8    44 	   varying_bit_dtype      init (20),
  8    45 	   char_dtype	      init (21),
  8    46 	   varying_char_dtype     init (22),
  8    47 	   file_dtype	      init (23),
  8    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  8    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  8    50 	   real_fix_bin_1_uns_dtype init (33),
  8    51 	   real_fix_bin_2_uns_dtype init (34),
  8    52 	   real_fix_dec_9bit_uns_dtype init (35),
  8    53 	   real_fix_dec_9bit_ts_dtype init (36),
  8    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  8    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  8    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  8    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  8    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  8    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  8    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  8    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  8    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  8    63 	   real_flt_hex_1_dtype   init (47),
  8    64 	   real_flt_hex_2_dtype   init (48),
  8    65 	   cplx_flt_hex_1_dtype   init (49),
  8    66 	   cplx_flt_hex_2_dtype   init (50),
  8    67 	   c_typeref_dtype        init (54),
  8    68 	   c_enum_dtype           init (55),
  8    69              c_enum_const_dtype     init (56),
  8    70 	   c_union_dtype          init (57),
  8    71 	   algol68_straight_dtype init (59),
  8    72 	   algol68_format_dtype   init (60),
  8    73 	   algol68_array_descriptor_dtype init (61),
  8    74 	   algol68_union_dtype    init (62),
  8    75 
  8    76 	   cobol_comp_6_dtype     init (1),
  8    77 	   cobol_comp_7_dtype     init (1),
  8    78 	   cobol_display_ls_dtype init (9),
  8    79 	   cobol_structure_dtype  init (17),
  8    80 	   cobol_char_string_dtype init (21),
  8    81 	   cobol_display_ls_overp_dtype init (29),
  8    82 	   cobol_display_ts_overp_dtype init (30),
  8    83 	   cobol_display_uns_dtype init (35),
  8    84 	   cobol_display_ts_dtype init (36),
  8    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  8    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  8    87 	   cobol_comp_5_uns_dtype init (40),
  8    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  8    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  8    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  8    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  8    92 	   cplx_flt_dec_generic_dtype init (84),
  8    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  8    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  8    95 
  8    96      dcl	   (ft_integer_dtype      init (1),
  8    97 	   ft_real_dtype	      init (3),
  8    98 	   ft_double_dtype	      init (4),
  8    99 	   ft_complex_dtype	      init (7),
  8   100 	   ft_complex_double_dtype init (8),
  8   101 	   ft_external_dtype      init (16),
  8   102 	   ft_logical_dtype	      init (19),
  8   103 	   ft_char_dtype	      init (21),
  8   104 	   ft_hex_real_dtype      init (47),
  8   105 	   ft_hex_double_dtype    init (48),
  8   106 	   ft_hex_complex_dtype   init (49),
  8   107 	   ft_hex_complex_double_dtype init (50)
  8   108 	   )		      fixed bin internal static options (constant);
  8   109 
  8   110      dcl	   (algol68_short_int_dtype init (1),
  8   111 	   algol68_int_dtype      init (1),
  8   112 	   algol68_long_int_dtype init (2),
  8   113 	   algol68_real_dtype     init (3),
  8   114 	   algol68_long_real_dtype init (4),
  8   115 	   algol68_compl_dtype    init (7),
  8   116 	   algol68_long_compl_dtype init (8),
  8   117 	   algol68_bits_dtype     init (19),
  8   118 	   algol68_bool_dtype     init (19),
  8   119 	   algol68_char_dtype     init (21),
  8   120 	   algol68_byte_dtype     init (21),
  8   121 	   algol68_struct_struct_char_dtype init (22),
  8   122 	   algol68_struct_struct_bool_dtype init (20)
  8   123 	   )		      fixed bin internal static options (constant);
  8   124 
  8   125      dcl	   (label_constant_runtime_dtype init (24),
  8   126 	   int_entry_runtime_dtype init (25),
  8   127 	   ext_entry_runtime_dtype init (26),
  8   128 	   ext_procedure_runtime_dtype init (27),
  8   129 	   picture_runtime_dtype  init (63)
  8   130 	   )		      fixed bin internal static options (constant);
  8   131 
  8   132      dcl	   (pascal_integer_dtype  init (1),
  8   133 	   pascal_real_dtype      init (4),
  8   134 	   pascal_label_dtype     init (24),
  8   135 	   pascal_internal_procedure_dtype init (25),
  8   136 	   pascal_exportable_procedure_dtype init (26),
  8   137 	   pascal_imported_procedure_dtype init (27),
  8   138 	   pascal_typed_pointer_type_dtype init (64),
  8   139 	   pascal_char_dtype      init (65),
  8   140 	   pascal_boolean_dtype   init (66),
  8   141 	   pascal_record_file_type_dtype init (67),
  8   142 	   pascal_record_type_dtype init (68),
  8   143 	   pascal_set_dtype	      init (69),
  8   144 	   pascal_enumerated_type_dtype init (70),
  8   145 	   pascal_enumerated_type_element_dtype init (71),
  8   146 	   pascal_enumerated_type_instance_dtype init (72),
  8   147 	   pascal_user_defined_type_dtype init (73),
  8   148 	   pascal_user_defined_type_instance_dtype init (74),
  8   149 	   pascal_text_file_dtype init (75),
  8   150 	   pascal_procedure_type_dtype init (76),
  8   151 	   pascal_variable_formal_parameter_dtype init (77),
  8   152 	   pascal_value_formal_parameter_dtype init (78),
  8   153 	   pascal_entry_formal_parameter_dtype init (79),
  8   154 	   pascal_parameter_procedure_dtype init (80),
  8   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  8   156 
  8   157 
  8   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
     1185 
  9     1 /* BEGIN INCLUDE FILE ... encoded_precision.incl.pl1
  9     2*
  9     3*   This is the format used by assign_ to encode the precision and scale of
  9     4*   arithmetic data into one word.  This structure should be assigned (use unspec)
  9     5*   to a fixed bin (35).
  9     6**/
  9     7 
  9     8 dcl 1 encoded_precision based aligned,
  9     9       2 scale fixed bin (17) unal,
  9    10       2 prec fixed bin (18) unsigned unal;
  9    11 
  9    12 /* END INCLUDE FILE ... encoded_precision.incl.pl1 */
     1186 
 10     1 /* BEGIN INCLUDE FILE its.incl.pl1
 10     2*   modified 27 July 79 by JRDavis to add its_unsigned
 10     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 10     4 
 10     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 10     6     2 pad1 bit (3) unaligned,
 10     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 10     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 10     9     2 pad2 bit (9) unaligned,
 10    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 10    11 
 10    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 10    13     2 pad3 bit (3) unaligned,
 10    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 10    15     2 pad4 bit (3) unaligned,
 10    16     2 mod bit (6) unaligned;				/* further modification */
 10    17 
 10    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 10    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 10    20     2 pad1 bit (27) unaligned,
 10    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 10    22 
 10    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 10    24     2 pad2 bit (3) unaligned,
 10    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 10    26     2 pad3 bit (3) unaligned,
 10    27     2 mod bit (6) unaligned;				/* further modification */
 10    28 
 10    29 
 10    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 10    31     2 pad1 bit (3) unaligned,
 10    32     2 segno fixed bin (15) unsigned unaligned,
 10    33     2 ringno fixed bin (3) unsigned unaligned,
 10    34     2 pad2 bit (9) unaligned,
 10    35     2 its_mod bit (6) unaligned,
 10    36 
 10    37     2 offset fixed bin (18) unsigned unaligned,
 10    38     2 pad3 bit (3) unaligned,
 10    39     2 bit_offset fixed bin (6) unsigned unaligned,
 10    40     2 pad4 bit (3) unaligned,
 10    41     2 mod bit (6) unaligned;
 10    42 
 10    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 10    44     2 pr_no fixed bin (3) unsigned unaligned,
 10    45     2 pad1 bit (27) unaligned,
 10    46     2 itp_mod bit (6) unaligned,
 10    47 
 10    48     2 offset fixed bin (18) unsigned unaligned,
 10    49     2 pad2 bit (3) unaligned,
 10    50     2 bit_offset fixed bin (6) unsigned unaligned,
 10    51     2 pad3 bit (3) unaligned,
 10    52     2 mod bit (6) unaligned;
 10    53 
 10    54 
 10    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 10    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 10    57 
 10    58 /* END INCLUDE FILE   its.incl.pl1 */
     1187 
     1188 
     1189   end probe_scan_input_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1224.8  probe_scan_input_.pl1             >spec>install>MR12.2-1194>probe_scan_input_.pl1
1177         1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
1178         2    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
1179         3    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
1180         4    10/26/88  1255.5  probe_operators.incl.pl1          >ldd>include>probe_operators.incl.pl1
1181         5    10/26/88  1255.5  probe_scan_dcls.incl.pl1          >ldd>include>probe_scan_dcls.incl.pl1
1182         6    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
1183         7    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
1185         8    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>include>std_descriptor_types.incl.pl1
1186         9    07/11/79  1711.3  encoded_precision.incl.pl1        >ldd>include>encoded_precision.incl.pl1
1187        10    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BIT_STR_END_STATE                      constant        fixed bin(17,0)          initial dcl 5-20 ref 528
COBOL_lang_type                        constant        fixed bin(17,0)          initial dcl 3-17 ref 244
CONSTANT_TYPE                          constant        bit(18)                  initial packed unaligned dcl 2-37 ref 1140
CR                                     constant        char(1)                  initial dcl 214 ref 299 300
C_INDIRECTION                          constant        bit(18)                  initial dcl 4-17 ref 869 879
C_lang_type                            constant        fixed bin(17,0)          initial dcl 3-17 ref 252 867
Char_type                       000103 automatic       fixed bin(17,0)          dcl 127 set ref 278* 280* 284 301*
Cur_char                        000102 automatic       char(1)                  dcl 127 set ref 277* 278 280 299 300* 301 359* 368*
                                                                                  375 381* 393 409 416* 420* 431* 439* 442* 449* 464
                                                                                  467* 498* 500 510* 543* 547 547 573 577* 596* 613*
                                                                                  657* 680* 709* 738* 738* 745* 750* 756* 756*
Cur_pos                         000101 automatic       fixed bin(21,0)          dcl 127 set ref 275* 277* 326 337* 358 367 373 388
                                                                                  396 401 408 444 463 493 708
Cur_state                       000100 automatic       fixed bin(17,0)          dcl 127 set ref 266* 284 309 318 377* 386* 395* 406*
                                                                                  413* 427* 433* 437* 445* 452* 458* 461* 477* 483*
                                                                                  490* 505* 513* 521* 528* 536* 544* 549* 555* 567*
                                                                                  571* 587* 600* 609* 623* 633* 642* 665* 672* 676
                                                                                  692* 703* 710*
DOT_SEEN_STATE                         constant        fixed bin(17,0)          initial dcl 5-20 ref 386 676
FORTRAN_lang_type                      constant        fixed bin(17,0)          initial dcl 3-17 ref 239
First_token                     000104 automatic       pointer                  dcl 133 set ref 262* 327 375 1169 1169*
ILLEGAL_CHAR_TYPE                      constant        fixed bin(17,0)          initial packed unaligned dcl 5-38 ref 278
IN_DOT_OP_STATE                        constant        fixed bin(17,0)          initial dcl 5-20 ref 318 571
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 10-55 ref 1119
Last_token                      000106 automatic       pointer                  dcl 134 set ref 263* 347 347 375 868 869 869 869 869
                                                                                  1153 1157 1157 1171 1172*
NAME_STATE                             constant        fixed bin(17,0)          initial dcl 5-20 ref 461
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 2-37 ref 896
NULL_STATE                             constant        fixed bin(17,0)          initial dcl 5-20 ref 266 427 452 458 477 483 521 536
                                                                                  549 555 567 587 600 633 642 672 692 703 710
NUMBER_EXP1_STATE                      constant        fixed bin(17,0)          initial dcl 5-20 ref 445
NUMBER_EXP2_STATE                      constant        fixed bin(17,0)          initial dcl 5-20 ref 437
NUMBER_POST_DOT_STATE                  constant        fixed bin(17,0)          initial dcl 5-20 ref 413 433
NUMBER_PRE_DOT_STATE                   constant        fixed bin(17,0)          initial dcl 5-20 ref 406
OPERATOR_TYPE                          constant        bit(18)                  initial packed unaligned dcl 2-37 ref 857 869
PASCAL_ARROW                    004450 constant        bit(18)                  initial dcl 4-17 ref 403 403
PASCAL_lang_type                       constant        fixed bin(17,0)          initial dcl 3-17 ref 248 472 682 698
POSSIBLE_DOUBLE_STATE                  constant        fixed bin(17,0)          initial dcl 5-20 ref 395
PTR_BIT_STATE                          constant        fixed bin(17,0)          initial dcl 5-20 ref 623
PTR_WORD_STATE                         constant        fixed bin(17,0)          initial dcl 5-20 ref 609 665
P_area_ptr                             parameter       pointer                  dcl 110 ref 31 237
P_code                                 parameter       fixed bin(35,0)          dcl 110 set ref 31 230* 324*
P_first_token                          parameter       pointer                  dcl 110 set ref 31 327*
P_input_lth                            parameter       fixed bin(21,0)          dcl 110 ref 31 235
P_input_ptr                            parameter       pointer                  dcl 110 ref 31 234
P_input_used_lth                       parameter       fixed bin(21,0)          dcl 110 set ref 31 326*
P_language_type                        parameter       fixed bin(21,0)          dcl 110 ref 31 239 244 248 252 472 682 698 867
P_probe_info_ptr                       parameter       pointer                  dcl 110 ref 31 232
Paren_level                     000110 automatic       fixed bin(17,0)          dcl 135 set ref 264* 307 356* 356 363* 363 365
QUOTE_SEEN_STATE                       constant        fixed bin(17,0)          initial dcl 5-20 ref 505 513
RIGHT_BRACKET                          constant        bit(18)                  initial dcl 4-17 ref 869
RIGHT_PAREN                            constant        bit(18)                  initial dcl 4-17 ref 869
STRING_STATE                           constant        fixed bin(17,0)          initial dcl 5-20 ref 309 377 490 544
TIMES                                  constant        bit(18)                  initial dcl 4-17 ref 867
Token_pos                       000111 automatic       fixed bin(21,0)          dcl 136 set ref 358* 367* 373* 388* 396* 401* 408*
                                                                                  444* 463* 493* 708* 897* 1155
a                               000566 automatic       pointer                  dcl 1108 in procedure "build_pointer" set ref 1121*
                                                                                  1122 1122 1125 1126 1128*
a                               000336 automatic       pointer                  dcl 916 in procedure "build_char_string" set ref
                                                                                  920* 921 922 922 926 928 930*
a                               000366 automatic       pointer                  dcl 1004 in procedure "build_dot" set ref 1011* 1012
                                                                                  1013 1013 1016 1018 1020 1021*
a                               000320 automatic       pointer                  dcl 891 in procedure "build_name" set ref 893* 894*
                                                                                  896 897 898 899*
a                               000554 automatic       pointer                  dcl 1081 in procedure "build_octal" set ref 1086*
                                                                                  1088 1089 1089 1091 1093 1101*
a                               000350 automatic       pointer                  dcl 937 in procedure "build_bit_string" set ref 941*
                                                                                  942 943 943 946 989 999*
a                               000504 automatic       pointer                  dcl 1051 in procedure "build_number" set ref 1062*
                                                                                  1063 1064 1070 1072 1074*
a                               000600 automatic       pointer                  dcl 1135 in procedure "new_constant" set ref 1138*
                                                                                  1139* 1140 1141 1142
a                               000306 automatic       pointer                  dcl 839 in procedure "build_operator_from_char" set
                                                                                  ref 852* 855* 857 859* 867 869 879
action_table                           based           fixed bin(17,0)          array packed unaligned dcl 163 ref 284
action_table_ptr                000232 automatic       pointer                  dcl 166 set ref 242* 246* 250* 254* 258* 284
addr                                                   builtin function         dcl 225 ref 241 242 245 246 249 250 253 254 257 258
                                                                                  908 1059 1059 1059 1059 1072
based_bits                             based           bit                      packed unaligned dcl 1050 in procedure
                                                                                  "build_number" set ref 1070 1072* 1072
based_bits                             based           bit                      packed unaligned dcl 938 in procedure
                                                                                  "build_bit_string" set ref 946 989*
based_chars                            based           char                     packed unaligned dcl 917 set ref 926 928*
based_fixed                            based           fixed bin(35,0)          dcl 1083 set ref 1091 1093*
based_logical                          based           bit(1)                   dcl 1005 set ref 1016 1018* 1020*
based_ptr                              based           pointer                  dcl 1109 set ref 1125 1126*
baseno                                                 builtin function         dcl 225 ref 661
bin                                                    builtin function         dcl 225 ref 403 403
binary                                                 builtin function         dcl 225 ref 661 662
bit                                                    builtin function         dcl 225 ref 857 989 1066 1066
bit_dtype                              constant        fixed bin(17,0)          initial dcl 8-25 ref 941 1011
bit_len                         000352 automatic       fixed bin(24,0)          dcl 939 set ref 943* 946 946 989
bit_offset                1(21) 000570 automatic       fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 1111
                                                                                  set ref 1117*
buffer_lth               16            based           fixed bin(21,0)          level 3 dcl 1-18 set ref 235*
buffer_ptr                3            based           pointer                  level 3 in structure "token" packed packed unaligned
                                                                                  dcl 2-16 in procedure "probe_scan_input_" set ref
                                                                                  1154*
buffer_ptr               15            based           pointer                  level 3 in structure "probe_info" packed packed
                                                                                  unaligned dcl 1-18 in procedure
                                                                                  "probe_scan_input_" set ref 234*
c                                      parameter       char(1)                  dcl 813 in procedure "append" ref 811 817
c                               000354 automatic       char(1)                  dcl 952 in begin block on line 948 set ref 971* 972*
                                                                                  972 975 978* 978*
c                                      parameter       char(1)                  dcl 765 in procedure "wordno_err" set ref 763 766*
                                                                                  766* 770 772* 772* 778 780* 780*
cc                                     parameter       char(1)                  dcl 788 set ref 786 800 805 805*
char_array                             based           char(1)                  array packed unaligned dcl 906 set ref 908
char_dtype                             constant        fixed bin(17,0)          initial dcl 8-25 ref 920
char_len                        000340 automatic       fixed bin(21,0)          dcl 918 set ref 922* 926 926 928
char_to_numeric_                000066 constant        entry                    external dcl 1053 ref 1059
char_type                              based           fixed bin(17,0)          array packed unaligned dcl 159 ref 278 280 301
char_type_ptr                   000230 automatic       pointer                  dcl 162 set ref 241* 245* 249* 253* 257* 278 280 301
code                            000556 automatic       fixed bin(35,0)          dcl 1082 in procedure "build_octal" set ref 1093*
                                                                                  1095
code                            000120 automatic       fixed bin(35,0)          dcl 145 in procedure "probe_scan_input_" set ref
                                                                                  231* 324 336* 341* 603* 605 605 605 618* 620 620
                                                                                  620 627* 629 629 629 637* 639 639 639
constant                               based           structure                level 1 dcl 2-27 set ref 1138
cp                                     parameter       fixed bin(21,0)          dcl 905 ref 903 908
current_source                         based           structure                level 1 dcl 6-13
cv_dec_check_                   000054 constant        entry                    external dcl 219 ref 627
cv_oct_check_                   000056 constant        entry                    external dcl 219 ref 603 618 637 1093
data_ptr                 11            based           pointer                  level 2 packed packed unaligned dcl 2-27 set ref
                                                                                  926* 928 946* 989 1016* 1018 1020 1070* 1072 1091*
                                                                                  1093 1125* 1126
data_size                       000502 automatic       fixed bin(17,0)          dcl 1049 set ref 1066* 1070 1070 1072 1072
data_type                10            based           fixed bin(17,0)          level 2 dcl 2-27 set ref 1141*
digit1                          000264 automatic       fixed bin(17,0)          dcl 789 set ref 801* 802 805*
digit2                          000265 automatic       fixed bin(17,0)          dcl 789 set ref 803* 804 805*
digit3                          000266 automatic       fixed bin(17,0)          dcl 789 set ref 804* 805*
divide                                                 builtin function         dcl 225 ref 801 803 1066 1066
dt                                     parameter       fixed bin(17,0)          dcl 1134 ref 1132 1141
dtype_found                     000400 automatic       fixed bin(35,0)          dcl 1045 set ref 1059* 1062 1066 1066 1066 1066
ecode                                  parameter       fixed bin(35,0)          dcl 335 ref 333 336
encoded_precision         6            based           structure                level 2 dcl 2-27 set ref 1064* 1122*
fb4                             000356 automatic       fixed bin(4,0)           dcl 956 set ref 975* 977 989
fixed                                                  builtin function         dcl 225 ref 547 547 857
flags                     5            based           structure                level 3 dcl 2-16 set ref 1156*
get_ring_                       000060 constant        entry                    external dcl 222 ref 1118
get_size_in_bits_               000070 constant        entry                    external dcl 1055 ref 1066
hbound                                                 builtin function         dcl 225 ref 278 474 582 696 1025
header                                 based           structure                level 2 dcl 2-16
i                               000370 automatic       fixed bin(17,0)          dcl 1006 in procedure "build_dot" set ref 1025*
                                                                                  1026* 1036
i                               000117 automatic       fixed bin(17,0)          dcl 144 in procedure "probe_scan_input_" set ref
                                                                                  474* 475 476* 582* 584* 696* 697 702*
identifier                             based           structure                level 1 dcl 2-19 set ref 893
index                                                  builtin function         dcl 225 ref 682 805 975
init_ptr                        000246 automatic       pointer                  dcl 647 set ref 648* 650* 652* 654* 661 662
input_index                     000355 automatic       fixed bin(17,0)          dcl 954 set ref 969* 971*
input_string                           based           char                     packed unaligned dcl 151 ref 275 277
input_string_lth                000126 automatic       fixed bin(21,0)          dcl 154 set ref 235* 275 277
input_string_ptr                000124 automatic       pointer                  dcl 153 set ref 234* 275 277 908 1154
instruction_ptr           2            based           pointer                  level 2 dcl 6-13 ref 652 654
ioa_$rsnnl                      000064 constant        entry                    external dcl 792 ref 805
its_mod                   0(30) 000570 automatic       bit(6)                   level 2 packed packed unaligned dcl 1111 set ref
                                                                                  1119*
its_unsigned                           based           structure                level 1 dcl 10-30
its_you                         000570 automatic       structure                level 1 dcl 1111 set ref 1114* 1126
leading_whitespace        5            based           bit(1)                   level 4 packed packed unaligned dcl 2-16 set ref
                                                                                  1157*
length                    6            based           fixed bin(17,0)          level 2 in structure "identifier" dcl 2-19
                                                                                  in procedure "probe_scan_input_" set ref 898*
length                                                 builtin function         dcl 225 in procedure "probe_scan_input_" ref 275 501
                                                                                  501 685 686 815 898 922 943 969 1059 1059
linkage_ptr             103            based           pointer                  level 3 packed packed unaligned dcl 7-9 ref 650
location                  4            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 2-16 set ref
                                                                                  1155*
maxlength                                              builtin function         dcl 225 ref 815
mod                                                    builtin function         dcl 227 ref 1066 1066
name                      7            based           pointer                  level 2 in structure "identifier" packed packed
                                                                                  unaligned dcl 2-19 in procedure
                                                                                  "probe_scan_input_" set ref 897*
name                            000040 external static char(4)                  array level 2 in structure
                                                                                  "probe_scan_data_$fort_ops" dcl 196 in procedure
                                                                                  "probe_scan_input_" ref 584 1026
name                            000042 external static char(4)                  array level 2 in structure
                                                                                  "probe_scan_data_$pasc_ops" dcl 201 in procedure
                                                                                  "probe_scan_input_" ref 475
ncc                             000267 automatic       fixed bin(17,0)          dcl 789 set ref 800* 801 802* 802 803 804
next                                   based           pointer                  level 3 packed packed unaligned dcl 2-16 set ref
                                                                                  1152* 1171*
null                                                   builtin function         dcl 227 ref 262 263 347 868 869 1152 1157 1169
numbuf                          000506 automatic       char(128)                dcl 1052 set ref 1058* 1059 1059
offset                    1     000570 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1111
                                                                                  set ref 1116*
op_code                   1     000040 external static fixed bin(17,0)          array level 2 in structure
                                                                                  "probe_scan_data_$fort_ops" dcl 196 in procedure
                                                                                  "probe_scan_input_" set ref 1036*
op_code                   1     000042 external static fixed bin(17,0)          array level 2 in structure
                                                                                  "probe_scan_data_$pasc_ops" dcl 201 in procedure
                                                                                  "probe_scan_input_" set ref 476*
op_name                                parameter       char(1)                  dcl 838 ref 836 842
op_type                         000310 automatic       fixed bin(17,0)          dcl 840 set ref 842* 850* 857
operator                               based           structure                level 1 dcl 2-24 ref 852
output_index                    000353 automatic       fixed bin(17,0)          dcl 951 set ref 967* 989 992* 992
pair                            000036 external static char(2)                  array level 2 packed packed unaligned dcl 191 ref
                                                                                  697
pointer                                                builtin function         dcl 227 ref 652
pointer_dtype                          constant        fixed bin(17,0)          initial dcl 8-25 ref 1121
pointers                 76            based           structure                level 2 dcl 7-9
pop_type                               parameter       fixed bin(17,0)          dcl 848 ref 846 850
precision                 6(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 2-27 set ref
                                                                                  922* 943* 1013* 1089*
prev                      1            based           pointer                  level 3 packed packed unaligned dcl 2-16 set ref 868
                                                                                  869 869 869 869 869 1153*
printable_chars                 000163 constant        char(94)                 initial packed unaligned dcl 794 ref 805
probe_error_$record             000062 constant        entry                    external dcl 223 ref 310 313 319 725 731 738 756 766
                                                                                  772 780 978 1032 1096
probe_et_$illegal_char          000052 external static fixed bin(35,0)          dcl 207 set ref 756*
probe_et_$recorded_message      000044 external static fixed bin(35,0)          dcl 207 ref 341
probe_et_$string_long           000050 external static fixed bin(35,0)          dcl 207 set ref 815*
probe_et_$unbalanced_parens     000046 external static fixed bin(35,0)          dcl 207 set ref 307* 365*
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000234 automatic       pointer                  dcl 1-86 set ref 232* 234 235 310* 313* 319* 648 650
                                                                                  652 654 725* 731* 738* 756* 766* 772* 780* 978*
                                                                                  1032* 1096*
probe_scan_data_$c_action_table 000032 external static fixed bin(17,0)          array packed unaligned dcl 178 set ref 254
probe_scan_data_$c_char_type    000020 external static fixed bin(17,0)          array packed unaligned dcl 169 set ref 253
probe_scan_data_$cobol_action_table
                                000030 external static fixed bin(17,0)          array packed unaligned dcl 178 set ref 246
probe_scan_data_$cobol_char_type
                                000016 external static fixed bin(17,0)          array packed unaligned dcl 169 set ref 245
probe_scan_data_$doubles        000036 external static structure                array level 1 unaligned dcl 191 set ref 696
probe_scan_data_$fort_ops       000040 external static structure                array level 1 unaligned dcl 196 set ref 582 1025
probe_scan_data_$fortran_action_table
                                000024 external static fixed bin(17,0)          array packed unaligned dcl 178 set ref 242
probe_scan_data_$fortran_char_type
                                000012 external static fixed bin(17,0)          array packed unaligned dcl 169 set ref 241
probe_scan_data_$operator_type  000034 external static fixed bin(17,0)          array packed unaligned dcl 187 ref 842
probe_scan_data_$pasc_ops       000042 external static structure                array level 1 unaligned dcl 201 set ref 474
probe_scan_data_$pascal_action_table
                                000026 external static fixed bin(17,0)          array packed unaligned dcl 178 set ref 250
probe_scan_data_$pascal_char_type
                                000014 external static fixed bin(17,0)          array packed unaligned dcl 169 set ref 249
probe_scan_data_$pl1_action_table
                                000022 external static fixed bin(17,0)          array packed unaligned dcl 178 set ref 258
probe_scan_data_$pl1_char_type  000010 external static fixed bin(17,0)          array packed unaligned dcl 169 set ref 257
ptr_bitno                       000116 automatic       fixed bin(17,0)          dcl 142 set ref 607* 627* 1117
ptr_offset                      000115 automatic       fixed bin(17,0)          dcl 142 set ref 607* 662* 1116
ptr_segno                       000113 automatic       fixed bin(17,0)          dcl 142 set ref 603* 661* 1115
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 648 650 652 654
ptr_wordno                      000114 automatic       fixed bin(17,0)          dcl 142 set ref 607* 618* 637* 1116
radix                                  parameter       fixed bin(17,0)          dcl 936 set ref 934 943 972 975 978* 989 989 989 992
radix_chars                     000143 constant        char(16)                 initial array packed unaligned dcl 958 ref 975
rank                                                   builtin function         dcl 227 ref 278 280 301 800 842
real_fix_bin_1_dtype                   constant        fixed bin(17,0)          initial dcl 8-25 ref 1086
regexp_sw                       000112 automatic       bit(1)                   dcl 139 set ref 310 378* 492* 500 510 525 532 540
rel                                                    builtin function         dcl 227 ref 662
reverse                                                builtin function         dcl 227 ref 682
ringno                    0(18) 000570 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 1111
                                                                                  set ref 1118*
rsc                             000270 automatic       char(6)                  dcl 791 set ref 805* 807
scale                     6            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 2-27 set ref
                                                                                  921* 942* 1012* 1088*
scale_and_precision       7            based           fixed bin(35,0)          level 2 dcl 2-27 set ref 922* 943* 1013* 1063* 1089*
                                                                                  1122*
scale_prec_found                000401 automatic       fixed bin(35,0)          dcl 1046 set ref 1059* 1063 1064 1066*
seg_info                               based           structure                level 1 dcl 7-9
seg_info_ptr             12            based           pointer                  level 2 dcl 6-13 ref 650
segno                     0(03) 000570 automatic       fixed bin(15,0)          level 2 packed packed unsigned unaligned dcl 1111
                                                                                  set ref 1115*
source_info                            based           structure                level 1 dcl 6-5
stack_ptr                 6            based           pointer                  level 2 dcl 6-13 ref 648
string_buffer                   000127 automatic       varying char(256)        dcl 156 set ref 379* 393* 409* 415* 464* 475 494*
                                                                                  501 501 501 573* 584 591 591 603 605 605 608* 618
                                                                                  620 620 622* 627 629 629 637 639 639 648 650 652
                                                                                  654 666* 669 669 676* 682 685 686* 686 686 697 698
                                                                                  707 707 725* 738* 815 815 817* 817 898 922 928 943
                                                                                  969 971 1009 1009 1018 1026 1032* 1058 1059 1059
                                                                                  1093 1096*
substr                                                 builtin function         dcl 227 set ref 277 403 403 501 605 605 620 620 629
                                                                                  629 639 639 669 669 686 707 707 971 989* 989
t                                      parameter       pointer                  dcl 1166 ref 1164 1169 1171 1172
temp_target                     000402 automatic       char(256)                packed unaligned dcl 1047 set ref 1059 1059 1072
token                                  based           structure                level 1 dcl 2-16
token_area                             based           area(1024)               dcl 147 ref 852 893 926 946 1016 1070 1091 1125 1138
token_area_ptr                  000122 automatic       pointer                  dcl 149 set ref 237* 852 893 926 946 1016 1070 1091
                                                                                  1125 1138
token_header                           based           structure                level 1 dcl 2-4
token_info               12            based           structure                level 2 dcl 1-18
tp                                     parameter       pointer                  dcl 1149 ref 1147 1152 1153 1154 1155 1156 1157
trailing_whitespace       5(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-16 set ref
                                                                                  347* 1157
translate                                              builtin function         dcl 227 ref 972
type                      1     000036 external static fixed bin(17,0)          array level 2 in structure
                                                                                  "probe_scan_data_$doubles" dcl 191 in procedure
                                                                                  "probe_scan_input_" set ref 702*
type                      2            based           bit(18)                  level 3 in structure "token" dcl 2-16 in procedure
                                                                                  "probe_scan_input_" set ref 857* 867 869 869 869
                                                                                  869* 879* 896* 1140*
unspec                                                 builtin function         dcl 227 set ref 1064* 1064 1114* 1126* 1126

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 3-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 3-17
AMPERSAND                              internal static bit(18)                  initial dcl 4-17
ARROW                                  internal static bit(18)                  initial dcl 4-17
COLON                                  internal static bit(18)                  initial dcl 4-17
COLON_CHAR_TYPE                        internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
COMMA                                  internal static bit(18)                  initial dcl 4-17
C_ADDRESS_CHAR_TYPE                    internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
C_EQUAL                                internal static bit(18)                  initial dcl 4-17
C_LEFT_SHIFT                           internal static bit(18)                  initial dcl 4-17
C_MOD_CHAR_TYPE                        internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
C_NOT_EQUAL                            internal static bit(18)                  initial dcl 4-17
C_RIGHT_SHIFT                          internal static bit(18)                  initial dcl 4-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 4-17
DOT_CHAR_TYPE                          internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
EQUALS                                 internal static bit(18)                  initial dcl 4-17
EQUAL_CHAR_TYPE                        internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
GREATER_CHAR_TYPE                      internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
GREATER_THAN                           internal static bit(18)                  initial dcl 4-17
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 10-56
LEFT_BRACKET                           internal static bit(18)                  initial dcl 4-17
LEFT_PAREN                             internal static bit(18)                  initial dcl 4-17
LEFT_PAREN_CHAR_TYPE                   internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LESS_CHAR_TYPE                         internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LESS_THAN                              internal static bit(18)                  initial dcl 4-17
LETTER_B_CHAR_TYPE                     internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LETTER_E_CHAR_TYPE                     internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LETTER_F_CHAR_TYPE                     internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LETTER_I_CHAR_TYPE                     internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
LETTER_O_CHAR_TYPE                     internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
MINUS                                  internal static bit(18)                  initial dcl 4-17
MINUS_CHAR_TYPE                        internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
NEW_LINE                               internal static bit(18)                  initial dcl 4-17
NOT_CHAR_TYPE                          internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
NOT_EQUALS                             internal static bit(18)                  initial dcl 4-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 4-17
NOT_LESS_THAN                          internal static bit(18)                  initial dcl 4-17
NOT_SIGN                               internal static bit(18)                  initial dcl 4-17
OCTAL_DIGITS_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 4-43
OR_BAR                                 internal static bit(18)                  initial dcl 4-17
OTHER_DIGITS_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
OTHER_LETTER_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
OTHER_OPS_CHAR_TYPE                    internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 3-17
PASCAL_ARROW_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
PASCAL_ASSIGN                          internal static bit(18)                  initial dcl 4-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 4-17
PERCENT                                internal static bit(18)                  initial dcl 4-17
PERIOD                                 internal static bit(18)                  initial dcl 4-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 3-17
PLUS                                   internal static bit(18)                  initial dcl 4-17
PLUS_CHAR_TYPE                         internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
QUESTION_MARK                          internal static bit(18)                  initial dcl 4-17
QUOTE_CHAR_TYPE                        internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
RADIX_DIGITS_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
RIGHT_PAREN_CHAR_TYPE                  internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
SEMI_COLON                             internal static bit(18)                  initial dcl 4-17
SLASH                                  internal static bit(18)                  initial dcl 4-17
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 3-17
VERTICAL_BAR_CHAR_TYPE                 internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
WHITE_SPACE_CHAR_TYPE                  internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
ZERO_CHAR_TYPE                         internal static fixed bin(17,0)          initial packed unaligned dcl 5-38
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 8-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 8-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 8-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 8-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
current_constant                       based           structure                level 1 dcl 2-44
current_identifier_name                based           char                     packed unaligned dcl 2-42
current_token                          based           structure                level 1 dcl 2-45
encoded_precision                      based           structure                level 1 dcl 9-8
entry_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
expression_area                        based           area(1024)               dcl 1-95
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 8-125
file_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 8-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
initial_source                         based           structure                level 1 dcl 6-14
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
itp                                    based           structure                level 1 dcl 10-18
itp_unsigned                           based           structure                level 1 dcl 10-43
its                                    based           structure                level 1 dcl 10-5
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 8-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
official_language_names                internal static char(32)                 initial array packed unaligned dcl 3-27
offset_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 3-30
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 8-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 8-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 8-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 8-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 8-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 8-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 8-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 8-125
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 7-47
structure_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 8-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
ACTION                          000000 constant        label                    array(99) dcl 347 ref 284
AR                              000656 constant        label                    dcl 287 ref 352 360 369 382 389 397 404 410 417 422
                                                                                  434 440 446 453 459 465 469 488 495 501 507 514
                                                                                  529 537 545 550 574 579 588 610 615 624 634 658
                                                                                  667 693 704 711
END_STRING                      001371 constant        label                    dcl 518 ref 525 532 540
EXIT                            001025 constant        label                    dcl 324 ref 338 343
FORTRAN_DOT_OPERATOR            001512 constant        label                    dcl 585 ref 591
LOSS                            002420 constant        entry                    internal dcl 333 ref 307 365 815
MAIN_RETURN                     001034 constant        label                    dcl 329
MATCH                           003451 constant        label                    dcl 1036 ref 1026
NOT_FORTRAN_DOT_OPERATOR        001533 constant        label                    dcl 596 ref 593
RECORDED_MESSAGE                001035 constant        label                    dcl 341 set ref 315 321 728 734 742 747 752 759 768
                                                                                  775 782 981 1034 1098
REPROC                          000641 constant        label                    dcl 284 ref 302 428 478 484 522 556 568 601 643 673
append                          002721 constant        entry                    internal dcl 811 ref 416 420 431 439 442 449 467 486
                                                                                  498 510 543 577 596 613 657 680
bitno_err                       002537 constant        entry                    internal dcl 778 ref 629 750
build_bit_string                003144 constant        entry                    internal dcl 934 ref 535 547 553
build_char_string               003107 constant        entry                    internal dcl 913 ref 518
build_dot                       003323 constant        entry                    internal dcl 1002 ref 585
build_name                      003051 constant        entry                    internal dcl 889 ref 482 599
build_number                    003461 constant        entry                    internal dcl 1042 ref 425 451 688
build_octal                     003575 constant        entry                    internal dcl 1078 ref 456
build_operator                  002765 constant        entry                    internal dcl 846 ref 403 476 702 1036
build_operator_from_char        002747 constant        entry                    internal dcl 836 ref 359 368 381 565 669 690 698 707
                                                                                  709
build_pointer                   003710 constant        entry                    internal dcl 1105 ref 632 641
com                             002772 constant        label                    dcl 852 ref 844
convert_chars_to_bit            003173 constant        label                    dcl 948
init_token                      004017 constant        entry                    internal dcl 1147 ref 855 894 1139
new_constant                    003776 constant        entry                    internal dcl 1132 ref 920 941 1011 1062 1086 1121
probe_scan_input_               000507 constant        entry                    external dcl 31
ptr_to_nth_char                 003076 constant        entry                    internal dcl 903 ref 897
safety                          002604 constant        entry                    internal dcl 786 ref 738 738 756 756 766 766 772 772
                                                                                  780 780 978 978
segno_err                       002472 constant        entry                    internal dcl 770 ref 605
thread                          004054 constant        entry                    internal dcl 1164 ref 859 899 930 999 1021 1074 1101
                                                                                  1128
wordno_err                      002426 constant        entry                    internal dcl 763 ref 620 639 745

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5004        5076    4460        5014
Length      5540    4460        72         425     323           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_scan_input_                   840 external procedure  is an external procedure.  
LOSS                                    internal procedure  shares stack frame of external procedure probe_scan_input_.  
begin block on line 645                 begin block         shares stack frame of external procedure probe_scan_input_.  
wordno_err                              internal procedure  shares stack frame of external procedure probe_scan_input_.  
safety                                  internal procedure  shares stack frame of external procedure probe_scan_input_.  
append                                  internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_operator_from_char                internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_name                              internal procedure  shares stack frame of external procedure probe_scan_input_.  
ptr_to_nth_char                         internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_char_string                       internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_bit_string                        internal procedure  shares stack frame of external procedure probe_scan_input_.  
begin block on line 948                 begin block         shares stack frame of external procedure probe_scan_input_.  
build_dot                               internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_number                            internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_octal                             internal procedure  shares stack frame of external procedure probe_scan_input_.  
build_pointer                           internal procedure  shares stack frame of external procedure probe_scan_input_.  
new_constant                            internal procedure  shares stack frame of external procedure probe_scan_input_.  
init_token                              internal procedure  shares stack frame of external procedure probe_scan_input_.  
thread                                  internal procedure  shares stack frame of external procedure probe_scan_input_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_scan_input_        000100 Cur_state                   probe_scan_input_
                         000101 Cur_pos                     probe_scan_input_
                         000102 Cur_char                    probe_scan_input_
                         000103 Char_type                   probe_scan_input_
                         000104 First_token                 probe_scan_input_
                         000106 Last_token                  probe_scan_input_
                         000110 Paren_level                 probe_scan_input_
                         000111 Token_pos                   probe_scan_input_
                         000112 regexp_sw                   probe_scan_input_
                         000113 ptr_segno                   probe_scan_input_
                         000114 ptr_wordno                  probe_scan_input_
                         000115 ptr_offset                  probe_scan_input_
                         000116 ptr_bitno                   probe_scan_input_
                         000117 i                           probe_scan_input_
                         000120 code                        probe_scan_input_
                         000122 token_area_ptr              probe_scan_input_
                         000124 input_string_ptr            probe_scan_input_
                         000126 input_string_lth            probe_scan_input_
                         000127 string_buffer               probe_scan_input_
                         000230 char_type_ptr               probe_scan_input_
                         000232 action_table_ptr            probe_scan_input_
                         000234 probe_info_ptr              probe_scan_input_
                         000246 init_ptr                    begin block on line 645
                         000264 digit1                      safety
                         000265 digit2                      safety
                         000266 digit3                      safety
                         000267 ncc                         safety
                         000270 rsc                         safety
                         000306 a                           build_operator_from_char
                         000310 op_type                     build_operator_from_char
                         000320 a                           build_name
                         000336 a                           build_char_string
                         000340 char_len                    build_char_string
                         000350 a                           build_bit_string
                         000352 bit_len                     build_bit_string
                         000353 output_index                begin block on line 948
                         000354 c                           begin block on line 948
                         000355 input_index                 begin block on line 948
                         000356 fb4                         begin block on line 948
                         000366 a                           build_dot
                         000370 i                           build_dot
                         000400 dtype_found                 build_number
                         000401 scale_prec_found            build_number
                         000402 temp_target                 build_number
                         000502 data_size                   build_number
                         000504 a                           build_number
                         000506 numbuf                      build_number
                         000554 a                           build_octal
                         000556 code                        build_octal
                         000566 a                           build_pointer
                         000570 its_you                     build_pointer
                         000600 a                           new_constant

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mdfx1
shorten_stack       ext_entry           any_to_any_truncate_op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
char_to_numeric_              cv_dec_check_                 cv_oct_check_                 get_ring_
get_size_in_bits_             ioa_$rsnnl                    probe_error_$record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$illegal_char        probe_et_$recorded_message    probe_et_$string_long         probe_et_$unbalanced_parens
probe_scan_data_$c_action_table                             probe_scan_data_$c_char_type
probe_scan_data_$cobol_action_table                         probe_scan_data_$cobol_char_type
probe_scan_data_$doubles      probe_scan_data_$fort_ops     probe_scan_data_$fortran_action_table
probe_scan_data_$fortran_char_type                          probe_scan_data_$operator_type
probe_scan_data_$pasc_ops     probe_scan_data_$pascal_action_table
probe_scan_data_$pascal_char_type                           probe_scan_data_$pl1_action_table
probe_scan_data_$pl1_char_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 000500       230 000514       231 000516       232 000517       234 000522       235 000526       237 000531
    239 000534       241 000537       242 000541       243 000543       244 000544       245 000546       246 000550
    247 000552       248 000553       249 000555       250 000557       251 000561       252 000562       253 000564
    254 000566       255 000570       257 000571       258 000573       262 000575       263 000577       264 000600
    266 000601       275 000603       277 000613       278 000620       280 000631       284 000641       287 000656
    299 000660       300 000664       301 000666       302 000677       307 000700       309 000711       310 000714
    313 000744       315 000774       318 000775       319 000777       321 001024       324 001025       326 001030
    327 001032       329 001034       341 001035       343 001040       347 001041       352 001050       356 001051
    358 001052       359 001054       360 001056       363 001057       365 001061       367 001072       368 001074
    369 001076       373 001077       375 001101       377 001111       378 001113       379 001115       380 001121
    381 001122       382 001124       386 001125       388 001127       389 001131       393 001132       395 001137
    396 001141       397 001143       401 001144       403 001146       404 001154       406 001155       408 001157
    409 001161       410 001166       413 001167       415 001171       416 001175       417 001177       420 001200
    422 001202       425 001203       427 001204       428 001206       431 001207       433 001211       434 001213
    437 001214       439 001216       440 001220       442 001221       444 001223       445 001225       446 001227
    449 001230       451 001232       452 001233       453 001235       456 001236       458 001237       459 001241
    461 001242       463 001244       464 001246       465 001253       467 001254       469 001256       472 001257
    474 001263       475 001271       476 001303       477 001312       478 001314       480 001315       482 001317
    483 001320       484 001322       486 001323       488 001327       490 001330       492 001332       493 001333
    494 001335       495 001336       498 001337       500 001341       501 001347       505 001356       507 001360
    510 001361       513 001366       514 001370       518 001371       521 001372       522 001374       525 001375
    528 001377       529 001401       532 001402       535 001404       536 001410       537 001412       540 001413
    543 001415       544 001417       545 001421       547 001422       549 001437       550 001441       553 001442
    555 001446       556 001450       565 001451       567 001455       568 001457       571 001460       573 001462
    574 001467       577 001470       579 001472       582 001473       584 001501       585 001512       587 001513
    588 001515       590 001516       591 001520       593 001532       596 001533       599 001535       600 001536
    601 001540       603 001541       605 001573       607 001604       608 001607       609 001610       610 001612
    613 001613       615 001615       618 001616       620 001650       622 001661       623 001662       624 001664
    627 001665       629 001717       632 001730       633 001731       634 001733       637 001734       639 001766
    641 001777       642 002000       643 002002       648 002003       650 002015       652 002030       654 002042
    657 002054       658 002056       661 002057       662 002063       665 002066       666 002070       667 002071
    669 002072       672 002077       673 002101       676 002102       680 002111       682 002113       685 002132
    686 002135       688 002142       690 002143       692 002147       693 002151       696 002152       697 002157
    698 002171       702 002207       703 002217       704 002221       706 002222       707 002224       708 002231
    709 002233       710 002235       711 002237       725 002240       728 002271       731 002272       734 002317
    738 002320       742 002357       745 002360       747 002362       750 002363       752 002365       756 002366
    759 002417       333 002420       336 002422       337 002424       338 002425       763 002426       766 002430
    768 002471       770 002472       772 002474       775 002536       778 002537       780 002541       782 002603
    786 002604       800 002606       801 002611       802 002614       803 002620       804 002623       805 002630
    807 002712       811 002721       815 002723       817 002735       818 002746       836 002747       842 002751
    844 002764       846 002765       850 002767       852 002772       855 002777       857 003001       859 003010
    867 003012       868 003022       869 003026       878 003045       879 003046       886 003050       889 003051
    893 003052       894 003057       896 003061       897 003064       898 003071       899 003073       901 003075
    903 003076       908 003100       913 003107       920 003110       921 003114       922 003117       926 003123
    928 003133       930 003141       931 003143       934 003144       941 003146       942 003152       943 003155
    946 003163       967 003173       969 003175       971 003205       972 003211       975 003222       977 003234
    978 003235       981 003275       989 003276       992 003314       994 003316       999 003320      1000 003322
   1002 003323      1009 003324      1011 003336      1012 003342      1013 003345      1016 003351      1018 003357
   1020 003370      1021 003372      1023 003374      1025 003375      1026 003403      1028 003415      1032 003417
   1034 003450      1036 003451      1039 003460      1042 003461      1058 003462      1059 003466      1062 003513
   1063 003517      1064 003522      1066 003524      1070 003555      1072 003565      1074 003572      1075 003574
   1078 003575      1086 003576      1088 003602      1089 003605      1091 003611      1093 003617      1095 003650
   1096 003653      1098 003704      1101 003705      1102 003707      1105 003710      1114 003711      1115 003713
   1116 003720      1117 003724      1118 003731      1119 003745      1121 003747      1122 003753      1125 003761
   1126 003767      1128 003773      1129 003775      1132 003776      1138 004000      1139 004005      1140 004007
   1141 004012      1142 004015      1147 004017      1152 004021      1153 004024      1154 004027      1155 004031
   1156 004034      1157 004042      1160 004053      1164 004054      1169 004056      1171 004066      1172 004071
   1173 004074


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
