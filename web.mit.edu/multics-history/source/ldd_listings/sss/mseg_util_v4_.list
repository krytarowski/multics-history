	COMPILATION LISTING OF SEGMENT mseg_util_v4_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1127.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mseg_util_v4_: proc;
       12 
       13 /* Modified for version 3 message segments by J. Stern, 10/22/74 */
       14 /* Modified to use mseg_error_ by J. Stern, 11/12/75 */
       15 /* Modified for "o" operations to test only Person_id 12/18/79 S. Herbst */
       16 /* Modified 3/77 by Charlie Davis for the installation of version 4 message segments */
       17 /* Modified: February 1983 by G. Palter for privileged entries used by compacting */
       18 /* Modified: 84-05-07 BIM for get_process_authorization_ instead of get_authorization_ */
       19 /* Modified: August 1984 by G. Palter to fix message segment error #0004 -- If a user's access to a mailbox or message
       20*      segment includes read (r) and own (o) but not delete (d) permission, mailbox_$delete_index,
       21*      message_segment_$delete_index, and message_segment_$delete_file will return error_table_$no_message when asked to
       22*      delete a message not created by the user.  Since, in this case, the user can determine which messages exist in the
       23*      segment, these entrypoints should return error_table_$moderr to indicate that the user doesn't have permission to
       24*      delete the message */
       25 
       26 
       27 dcl (a_mptr,					/* pointer to the message segment */
       28      prev_tr_ptr,					/* pointer to previous message trailer */
       29      next_tr_ptr,					/* pointer to next message trailer */
       30      prev_in_bucket_ptr,				/* pointer to previous message in hash bucket */
       31      ms_ptr,					/* pointer to message wanted */
       32      ret_ptr init (null),
       33      deletep,					/* pointer to block to be zeroed out */
       34      a_arg_ptr,					/*  pointer to return_arg structure (argument) */
       35      arg_ptr,					/* pointer to return_arg structure (internal) */
       36      t_ptr,					/* scan pointer for returning message */
       37      a_area_ptr,					/* pointer to allocated area */
       38      a_ms_ptr,					/* pointer to updating message */
       39      area_ptr) ptr;
       40 
       41 dcl (read init ("0"b),				/* ON for read or read and delete entry */
       42      incr_read init ("0"b),				/* ON for incremental read entry */
       43      delete init ("0"b),				/* ON for delete or read and delete entry */
       44      update init ("0"b),				/* ON for update entry */
       45      get_count init ("0"b),				/* ON for get_count entry */
       46      priv_entry init ("0"b),				/* ON for privileged read entrypoint */
       47      mseg_priv,					/* ON if calling process has privileged access */
       48      a_own,					/* ON if reading own message (argument) */
       49      own,						/* ON if reading own message (internal) */
       50      a_read_access,					/* ON if user has read access to the segment (argument) */
       51      read_access init ("0"b),				/* ON if user has read access to the segment (internal) */
       52      last,					/* ON if message is last in segment */
       53      first,					/* ON if message is first in segment */
       54      search_sw,					/* ON if message id not found for incremental reading */
       55      ms_end) bit (1) aligned;				/* ON when end of message is found */
       56 
       57 dcl  back_in_bucket_offset bit (18) aligned;		/* offset of message one back in hash bucket */
       58 
       59 dcl (tr_offset,					/* offset from beginning of block to trailer */
       60      ms_count,					/* number of messages in segment */
       61      a_count,					/* message count (argument) */
       62      count,					/* message count (internal) */
       63      prev_offset,					/* offset to previous message */
       64      next_offset,					/* offset to next message */
       65      block_size,					/* size of a message block */
       66      blocks_in_message,				/* number of blocks used for message */
       67      update_len,					/* size of update message */
       68      loc,
       69      bit_off) fixed bin (18);				/* location of allocation bit to be turned off */
       70 
       71 dcl (
       72      copy_size,					/* size of bit copy mask */
       73      delete_size,					/* bit size of block to be zeroed out */
       74      a_ms_len,					/* length of message in block trailer */
       75      ms_len,
       76      found_ms_len					/* actual message size */
       77      ) fixed bin (24);
       78 
       79 dcl (a_first_or_last,				/* ON if last message wanted (argument) */
       80      first_or_last) bit (1) aligned;			/* ON if last message wanted (internal) */
       81 
       82 dcl (a_dir,					/* direction of incremental search */
       83      dir init ("00"b)) bit (2) aligned;
       84 
       85 dcl (a_ms_id,					/* message ID (argument) */
       86      ms_id) bit (72) aligned;				/* message ID (internal) */
       87 
       88 dcl (authorization,					/* authorization of calling process */
       89      access_class) bit (72) aligned;			/* access class of message segment */
       90 
       91 dcl  privileges bit (36) aligned;			/* privileges of calling process */
       92 dcl 1 based_priv unal based (addr (privileges)) like aim_template.privileges;
       93 
       94 dcl (
       95      alloc_len,					/* length of allocation bit string */
       96      level,					/* user level: 0 = non-own entry, 1 = own entry (internal) */
       97      ms_word_len,					/* length of message in words */
       98      htx,						/* hash table index */
       99      id_len) fixed bin;				/* length of person-project portion of group id */
      100 
      101 dcl (
      102      a_code,					/* error code (argument) */
      103      code						/* error code (internal) */
      104      ) fixed bin (35);
      105 
      106 dcl (addr, addrel, bit, divide, fixed, index, length, null, ptr, rel, rtrim, size, substr) builtin;
      107 
      108 dcl (
      109      area,
      110      cleanup
      111      ) condition;
      112 
      113 dcl  area_array area (30) aligned based (area_ptr),	/* for allocating */
      114      ms_word_array (ms_word_len) fixed bin aligned based (ret_ptr);
      115 
      116 dcl (caller_id,					/* id of caller */
      117      ms_sender_id) char (32);				/* id of message sender */
      118 
      119 dcl  proc_name char (32);				/* procedure name */
      120 dcl  reason char (40);				/* reason why operation failed */
      121 
      122 dcl  bit_copy_mask bit (copy_size) based;		/* bit copy mask */
      123 
      124 dcl  bits (copy_size) bit (1) based unaligned;		/* for resetting copy-to pointer */
      125 
      126 dcl 1 return_args aligned based (arg_ptr),		/* return argument structure */
      127     2 ms_ptr ptr,					/* pointer to message */
      128     2 ms_len fixed bin (18),				/* length of message in bits */
      129     2 sender_id char (32),				/* person-project ID of message sender */
      130     2 level fixed bin,				/* validation level of sender */
      131     2 ms_id bit (72),				/* unique ID of message */
      132     2 sender_authorization bit (72),			/* access authorization of message sender */
      133     2 access_class bit (72);				/* message access class */
      134 
  1     1 /* BEGIN include file mseg_hdr_v4.incl.pl1 */
  1     2 
  1     3 declare
  1     4      1 mseg_hdr_v4 aligned based,         		/* message segment header format */
  1     5      2 lock bit (36) aligned,				/* standard file system lock */
  1     6      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     7      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     8    2 date_time_last_salvaged fixed bin (71),		/* time message segment was last salvaged */
  1     9      2 pad (2) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (0 refer (mseg_hdr_v4.alloc_len)) aligned;/* allocation bit string */
  1    27 
  1    28 /* END include file mseg_hdr.incl.pl1 */
      135 
      136 declare mptr pointer;
      137 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
      138 
      139 
  3     1 /* BEGIN include file ms_block_trailer.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ring_no bit (18) unaligned,			/* validation level */
  3    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  3    11      2 ms_id bit (72) aligned,			/* message id */
  3    12      2 ms_size bit (24) unaligned,			/* bit count of message */
  3    13      2 pad bit (12) unaligned,
  3    14      2 sender_id char (32) aligned,			/* id of message sender */
  3    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  3    16      2 access_class bit (72) aligned;			/* access class of this message */
  3    17 
  3    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  3    19      internal static;
  3    20 
  3    21 /* END include file ms_block_trailer.incl.pl1 */
      140 
      141 
  4     1 /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  4     2 
  4     3 /* Created 740723 by PG */
  4     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  4     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  4     6 
  4     7 /* This structure defines the components of both an access
  4     8*   class and an access authorization as interpreted by the
  4     9*   Access Isolation Mechanism. */
  4    10 
  4    11 
  4    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  4    13        2 categories bit (36),				/* access categories */
  4    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  4    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  4    16         (3 ipc,					/* interprocess communication privilege */
  4    17          3 dir,					/* directory privilege */
  4    18          3 seg,					/* segment privilege */
  4    19          3 soos,					/* security out-of-service privilege */
  4    20          3 ring1,					/* ring 1 access privilege */
  4    21          3 rcp,					/* RCP resource access privilege */
  4    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  4    23          3 pad bit (11);
  4    24 
  4    25 
  4    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      142 
      143 
      144 dcl  error_table_$bad_segment ext fixed bin (35);
      145 dcl  error_table_$ai_restricted ext fixed bin (35);
      146 dcl  error_table_$moderr fixed binary (35) external;
      147 dcl  error_table_$no_message ext fixed bin (35);
      148 dcl  error_table_$inconsistent ext fixed bin (35);
      149 dcl  error_table_$bigarg ext fixed bin (35);
      150 dcl  error_table_$noalloc ext fixed bin (35);
      151 
      152 dcl  get_group_id_$tag_star entry() returns(char(32));
      153 dcl  get_process_authorization_ ext entry returns (bit (72) aligned);
      154 dcl  get_privileges_ ext entry returns (bit (36) aligned);
      155 dcl  hcs_$get_access_class_seg ext entry (ptr, bit (72) aligned, fixed bin (35));
      156 dcl  mseg_error_v4_ entry options (variable);
      157 dcl  read_allowed_ ext entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      158 dcl  read_write_allowed_ ext entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      159 
      160 /*  */
      161 read_priv: entry (a_mptr, a_area_ptr, a_first_or_last, a_arg_ptr, a_own, a_code);
      162 
      163 	proc_name = "mseg_util_v4_$read_priv";
      164 	priv_entry = "1"b;
      165 	go to R_COMMON;
      166 
      167 read:	entry (a_mptr, a_area_ptr, a_first_or_last, a_arg_ptr, a_own, a_code);
      168 
      169 	proc_name = "mseg_util_v4_$read";
      170 R_COMMON:	first_or_last = a_first_or_last;
      171 	area_ptr = a_area_ptr;
      172 	read = "1"b;
      173 	go to COMMON;
      174 
      175 delete:	entry (a_mptr, a_ms_id, a_own, a_read_access, a_code);
      176 
      177 	proc_name = "mseg_util_v4_$delete";
      178 	ms_id = a_ms_id;
      179 	delete = "1"b;
      180 	read_access = a_read_access;
      181 	go to COMMON;
      182 
      183 read_and_delete: entry (a_mptr, a_area_ptr, a_first_or_last, a_arg_ptr, a_own, a_code);
      184 
      185 	proc_name = "mseg_util_v4_$read_and_delete";
      186 	first_or_last = a_first_or_last;
      187 	area_ptr = a_area_ptr;
      188 	read, delete = "1"b;
      189 	go to COMMON;
      190 
      191 incremental_read_priv: entry (a_mptr, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_own, a_code);
      192 
      193 	proc_name = "mseg_util_v4_$incremental_read_priv";
      194 	priv_entry = "1"b;
      195 	go to IR_COMMON;
      196 
      197 incremental_read: entry (a_mptr, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_own, a_code);
      198 
      199 	proc_name = "mseg_util_v4_$incremental_read";
      200 IR_COMMON: ms_id = a_ms_id;
      201 	dir = a_dir;
      202 	if dir = "11"b then do;			/* undefined */
      203 	     code = error_table_$inconsistent;
      204 	     go to FIN;
      205 	end;
      206 	area_ptr = a_area_ptr;
      207 	incr_read = "1"b;
      208 	go to COMMON;
      209 
      210 
      211 update:	entry (a_mptr, a_ms_ptr, a_ms_len, a_ms_id, a_own, a_read_access, a_code);
      212 
      213 	proc_name = "mseg_util_v4_$update";
      214 	update = "1"b;
      215 	ms_id = a_ms_id;
      216 	read_access = a_read_access;
      217 	go to COMMON;
      218 
      219 get_count: entry (a_mptr, a_count, a_code);
      220 
      221 	proc_name = "mseg_util_v4_$get_count";
      222 	get_count = "1"b;
      223 	own = "0"b;
      224 	go to COMMON2;
      225 
      226 /*  */
      227 
      228 COMMON:
      229 	own = a_own;
      230 
      231 COMMON2:
      232 	mptr = a_mptr;
      233 	code = 0;
      234 	search_sw = "0"b;
      235 
      236 	ms_count =				/* get number of messages */
      237 	     fixed (mptr -> mseg_hdr_v4.number_of_messages, 18);
      238 
      239 	block_size = fixed (mptr -> mseg_hdr_v4.block_size, 18);	/* pick out block size from header */
      240 
      241 	tr_offset = block_size - size (ms_block_trailer); /* calculate trailer offset */
      242 
      243 /* See if first or last message wanted */
      244 
      245 	if get_count then go to COUNT;		/* start counting with first message */
      246 
      247 	if read then do;				/* read first or last message */
      248 	     if first_or_last = "1"b			/* last message wanted */
      249 	     then do;
      250 		dir = "10"b;			/* prepare to scan backward */
      251 LAST:		loc = fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18); /* get offset of last message */
      252 	     end;
      253 
      254 	     else do;				/* first message wanted */
      255 COUNT:		dir = "01"b;			/* prepare to scan forward */
      256 FIRST:		loc = fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18); /* get offset of first message */
      257 	     end;
      258 	     if delete then do;
      259 		ms_ptr = ptr (mptr, loc);
      260 		tr_ptr = addrel (ms_ptr, tr_offset);
      261 		ms_id = tr_ptr -> ms_block_trailer.ms_id;
      262 		go to THREAD;
      263 	     end;
      264 	end;
      265 
      266 /* look up message ID in hash table */
      267 
      268 	else do;					/* for incr read, update ; delete */
      269 THREAD:	     htx = fixed (substr (ms_id, 64, 9));	/* hash table index = low 9 bits of message ID */
      270 	     loc = fixed (mptr -> mseg_hdr_v4.hash_table.last_in_bucket (htx), 18); /* get loc of last message in bucket */
      271 	     prev_in_bucket_ptr = null;		/* no previous message yet */
      272 
      273 	     do while (loc ^= 0);			/* search bucket for matching message ID */
      274 		ms_ptr = ptr (mptr, loc);		/* get ptr to first block of message */
      275 		if ^ms_ptr -> ms_block_hdr.first_block	/* check if really first block */
      276 		then do;
      277 		     reason = "not first block in hash lookup";
      278 		     go to BAD_SEG;
      279 		end;
      280 		tr_ptr = addrel (ms_ptr, tr_offset);	/* get trailer ptr */
      281 		if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* check pattern */
      282 		then do;
      283 		     reason = "bad trailer pattern in hash lookup";
      284 		     go to BAD_SEG;
      285 		end;
      286 		if tr_ptr -> ms_block_trailer.ms_id = ms_id /* found it */
      287 		then go to FOUND_ID;
      288 		prev_in_bucket_ptr = tr_ptr;		/* remember ptr to this message */
      289 		loc = fixed (tr_ptr -> ms_block_trailer.back_in_bucket, 18); /* go back one in bucket */
      290 	     end;
      291 
      292 	     if incr_read then
      293 		if dir ^= "00"b then do;		/* forward or backward incr read */
      294 		     search_sw = "1"b;		/* search for next message even though this message is gone */
      295 		     if dir = "10"b then go to LAST;	/* search for largest message id < ms_id */
      296 		     else go to FIRST;		/* search for smallest message id > ms_id */
      297 		end;
      298 
      299 	     go to NO_MSG;				/* bucket exhausted */
      300 FOUND_ID:
      301 	end;
      302 
      303 
      304 /* prepare to check access */
      305 
      306 	authorization = get_process_authorization_ ();	/* get caller's authorization */
      307 	privileges = get_privileges_ ();		/* get caller's privileges */
      308 	mseg_priv = based_priv.ring1 | priv_entry;	/* get ring 1 privilege flag */
      309 	if own					/* caller can only reference his own message */
      310 	then do;
      311 	     caller_id = get_group_id_$tag_star ();	/* get caller's group id */
      312 	     if substr (caller_id, 1, 10) = "anonymous." then
      313 		id_len = length (rtrim (caller_id)) - 1;	/* ignore .* tag for anonymous */
      314 	     else id_len = index (caller_id, ".");		/* others: compare only Person_id */
      315 	end;
      316 
      317 /* get_count */
      318 
      319 	if get_count
      320 	then do;
      321 	     if mseg_priv				/* caller has privileged access */
      322 	     then do;
      323 FULL_COUNT:	a_count = ms_count;			/* return full count */
      324 		go to FIN;
      325 	     end;
      326 	     call hcs_$get_access_class_seg (mptr, access_class, code); /* get message seg access class */
      327 	     if code ^= 0 then go to FIN;
      328 	     if read_allowed_ (authorization, access_class) /* caller is authorized to see all messages */
      329 	     then go to FULL_COUNT;			/* return full count */
      330 	     count = 0;				/* initialize count */
      331 	     go to READ;				/* get count of read-accessible messages */
      332 	end;
      333 
      334 /* incremental read */
      335 
      336 	else if search_sw then go to READ;
      337 	else if incr_read
      338 	then do;
      339 	     if own				/* must be caller's own message */
      340 	     then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      341 		then go to NO_MSG;			/* pretend it doesn't exist */
      342 	     if ^mseg_priv				/* no special access privilege */
      343 	     then if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read permit */
      344 		then go to NO_MSG;			/* pretend it doesn't exist */
      345 
      346 	     if dir = "10"b				/* previous message wanted */
      347 	     then do;				/* increment message pointer */
      348 		if tr_ptr -> ms_block_trailer.b_offset = "0"b
      349 		then do;				/* error, no previous message */
      350 		     if fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18) ^= loc
      351 		     then do;
      352 			reason = "bad first offset";
      353 			go to BAD_SEG;
      354 		     end;
      355 NO_MSG:		     code = error_table_$no_message;
      356 		     go to FIN;
      357 		end;
      358 		loc = fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      359 		go to READ;
      360 	     end;
      361 
      362 	     else if dir = "01"b			/* next message wanted */
      363 	     then do;				/* increment message pointer */
      364 		if tr_ptr -> ms_block_trailer.f_offset = "0"b
      365 		then do;				/* error, no next message */
      366 		     if fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18) ^= loc
      367 		     then do;
      368 			reason = "bad last offset";
      369 			go to BAD_SEG;
      370 		     end;
      371 		     go to NO_MSG;
      372 		end;
      373 		loc = fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      374 		go to READ;
      375 	     end;
      376 
      377 	end;
      378 
      379 /* read */
      380 
      381 	else if read
      382 	then do;
      383 READ:	     do while (loc ^= 0);			/* scan for read-accessible message */
      384 		ms_ptr = ptr (mptr, loc);		/* get ptr to first block of message */
      385 		if ^ms_ptr -> ms_block_hdr.first_block	/* check if really first block */
      386 		then do;
      387 		     reason = "not first block";
      388 		     go to BAD_SEG;
      389 		end;
      390 		tr_ptr = addrel (ms_ptr, tr_offset);	/* get trailer ptr */
      391 		if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* check pattern */
      392 		then do;
      393 		     reason = "bad trailer pattern";
      394 		     go to BAD_SEG;
      395 		end;
      396 		if own				/* must be caller's own message */
      397 		then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      398 		     then go to NEXT;		/* skip it */
      399 		if ^mseg_priv			/* no special access privileges */
      400 		then do;
      401 		     if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read permit */
      402 		     then go to NEXT;		/* skip over this one */
      403 		     if delete			/* read and delete requested */
      404 		     then if ^read_write_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class)
      405 			then go to AI_ERR;		/* cannot delete this message */
      406 		end;
      407 		if get_count			/* get_count entry */
      408 		then count = count + 1;		/* increment count of read-accessible messages */
      409 		else if search_sw
      410 		then if dir = "01"b
      411 		     then if substr (tr_ptr -> ms_block_trailer.ms_id, 19, 54) > substr (ms_id, 19, 54)
      412 			then go to EXIT;		/* found the one we're searching for */
      413 			else go to NEXT;
      414 		     else if substr (tr_ptr -> ms_block_trailer.ms_id, 19, 54) < substr (ms_id, 19, 54)
      415 		     then go to EXIT;		/* found it */
      416 		     else go to NEXT;
      417 		else go to EXIT;			/* found a message to read, exit loop */
      418 NEXT:
      419 		if dir = "01"b			/* scanning forward */
      420 		then loc = fixed (tr_ptr -> ms_block_trailer.f_offset, 18); /* get loc of next message */
      421 		else loc = fixed (tr_ptr -> ms_block_trailer.b_offset, 18); /* get loc of previous message */
      422 	     end;
      423 
      424 	     if get_count				/* we're finished counting */
      425 	     then do;
      426 		a_count = count;
      427 		go to FIN;
      428 	     end;
      429 	     go to NO_MSG;				/* couldn't find anything to read */
      430 EXIT:	end;
      431 
      432 /* update or delete */
      433 
      434 	else if update | delete
      435 	then do;
      436 	     if own				/* must be caller's own message */
      437 	     then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      438 		then if read_access then do;		/* caller is allowed to know the message is present */
      439 		     code = error_table_$moderr;
      440 		     go to FIN;
      441 		end;
      442 		else go to NO_MSG;			/* pretend it doesn't exist */
      443 	     if ^mseg_priv				/* no special access privilege */
      444 	     then if ^read_write_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read-write permit */
      445 		then if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* not even read permit */
      446 		     then go to NO_MSG;		/* pretend it doesn't exist */
      447 		     else do;			/* caller has read permit, but not modify */
      448 AI_ERR:			code = error_table_$ai_restricted;
      449 			go to FIN;
      450 		     end;
      451 	end;
      452 
      453 /* prepare to perform requested operation */
      454 
      455 	ms_len = fixed (ms_block_trailer.ms_size, 24);	/* pick out message size */
      456 
      457 	if update
      458 	then do;
      459 	     update_len = a_ms_len;
      460 	     if update_len > ms_len			/* incorrect message size specified */
      461 	     then do;
      462 		code = error_table_$bigarg;		/* user message too big */
      463 		go to FIN;
      464 	     end;
      465 	     t_ptr = a_ms_ptr;			/* initialize copy ptr */
      466 	end;
      467 
      468 	if delete
      469 	then do;
      470 
      471 	     if fixed (mptr -> mseg_hdr_v4.first_ms_offset, 18) = loc /* first message */
      472 	     then first = "1"b;			/* set flag to remember */
      473 	     else first = "0"b;
      474 	     if fixed (mptr -> mseg_hdr_v4.last_ms_offset, 18) = loc /* last message */
      475 	     then last = "1"b;			/* set flag to remember */
      476 	     else last = "0"b;
      477 
      478 	     if (^first)
      479 	     then do;				/* not first message */
      480 		prev_offset =			/* get offset to previous message */
      481 		     fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      482 		prev_tr_ptr =			/* make pointer to previous trailer */
      483 		     ptr (mptr, prev_offset+tr_offset);
      484 	     end;
      485 
      486 	     if (^last)
      487 	     then do;				/* not last message */
      488 		next_offset =			/* get offset to next message */
      489 		     fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      490 		next_tr_ptr =			/* make pointer to next trailer */
      491 		     ptr (mptr, next_offset+tr_offset);
      492 	     end;
      493 
      494 	     back_in_bucket_offset = tr_ptr -> ms_block_trailer.back_in_bucket;
      495 
      496 	     delete_size = block_size * 36;		/* the block size in bits */
      497 	     alloc_len = mptr -> mseg_hdr_v4.alloc_len;	/* a local copy of the number of allocation bits */
      498 
      499 	end;
      500 
      501 	if read | incr_read
      502 	then do;
      503 	     ms_sender_id = tr_ptr -> ms_block_trailer.sender_id; /* pick out senders' id */
      504 	     level = fixed (ms_block_trailer.ring_no, 17); /* pick out validation level */
      505 	     ms_id = tr_ptr -> ms_block_trailer.ms_id;	/* pick out message id */
      506 	     authorization = tr_ptr -> ms_block_trailer.sender_authorization; /* pick out sender authorization */
      507 	     access_class = tr_ptr -> ms_block_trailer.access_class; /* pick out message access class */
      508 
      509 /* allocate an area for the returned message */
      510 
      511 	     on cleanup begin;			/* establish cleanup handler to free allocated message */
      512 		if ret_ptr ^= null			/* a message was allocated */
      513 		then do;
      514 		     free ms_word_array in (area_array); /* free it */
      515 		     a_arg_ptr -> return_args.ms_ptr = null; /* and return null argument ptr */
      516 		end;
      517 	     end;
      518 
      519 	     on area begin;
      520 		code = error_table_$noalloc;
      521 		go to FIN;
      522 	     end;
      523 
      524 	     ms_word_len = divide (ms_len+35, 36, 17, 0); /* compute word length from bit count */
      525 	     allocate ms_word_array in (area_array) set (ret_ptr); /* allocate the area */
      526 	     t_ptr = ret_ptr;			/* initialize scan pointer */
      527 	end;
      528 
      529 /*  */
      530 /* chase the message thread */
      531 
      532 	found_ms_len = 0;				/* initialize size of found message */
      533 
      534 	blocks_in_message = 0;			/* initialize count */
      535 	block_ptr = ms_ptr;				/* initialize block pointer */
      536 	ms_end = "0"b;				/* initialize end of message flag */
      537 
      538 	if delete					/* user is deleting a message */
      539 	then mptr -> mseg_hdr_v4.mip = "1"b;			/* turn on mip bit */
      540 
      541 	do while (^ms_end);
      542 
      543 	     blocks_in_message =			/* increment message block count */
      544 		blocks_in_message + 1;
      545 
      546 	     found_ms_len = found_ms_len + fixed (ms_block_hdr.block_count, 24); /* increment message size */
      547 	     if found_ms_len > ms_len			/* more message than block trailer specified */
      548 	     then do;				/* error in message segment */
      549 		reason = "message too long";
      550 		go to BAD_SEG;
      551 	     end;
      552 
      553 
      554 	     if (read | incr_read | update)
      555 	     then do;				/* return message for reading */
      556 		copy_size =			/* set size of copy mask */
      557 		     fixed (block_ptr -> ms_block_hdr.block_count, 24);
      558 		if update then do;			/* updating message */
      559 		     if found_ms_len > update_len then do; /* update only part of this block */
      560 			copy_size = copy_size - (found_ms_len - update_len);
      561 			ms_end = "1"b;
      562 		     end;
      563 		     addrel (block_ptr, size (ms_block_hdr)) -> bit_copy_mask
      564 			= t_ptr -> bit_copy_mask;	/* overwrite */
      565 		end;
      566 		else				/* reading message */
      567 		t_ptr -> bit_copy_mask =		/* copy message */
      568 		     addrel (block_ptr, size (ms_block_hdr)) -> bit_copy_mask;
      569 		t_ptr = addr (t_ptr -> bits (copy_size + 1)); /* increment copy ptr */
      570 	     end;
      571 
      572 	     if (delete)
      573 	     then do;				/* user is deleting a message */
      574 		bit_off = divide (fixed (rel (block_ptr), 18), block_size, 18, 0)+1; /* calculate alloc bit for block */
      575 		if substr (mptr -> mseg_hdr_v4.alloc_bits, bit_off, 1) = "0"b /* block not in use */
      576 		then do;
      577 		     reason = "unprotected block";
      578 		     go to BAD_SEG;
      579 		end;
      580 		else
      581 		substr (mptr -> mseg_hdr_v4.alloc_bits, bit_off, 1) = "0"b; /* turn bit off */
      582 		deletep = block_ptr;		/* remember block ptr to delete later */
      583 	     end;
      584 
      585 	     if ^ms_end then
      586 		if block_ptr -> ms_block_hdr.f_offset = "0"b
      587 		then do;				/* message block is last in message */
      588 		     if found_ms_len ^= ms_len	/* found size doesn't agree with trailer */
      589 		     then do;
      590 			reason = "bad message length";
      591 			go to BAD_SEG;
      592 		     end;
      593 		     else
      594 		     ms_end = "1"b;			/* indicate end of message */
      595 		end;
      596 
      597 		else do;
      598 		     block_ptr =			/* step the block pointer */
      599 			ptr (block_ptr, fixed (block_ptr -> ms_block_hdr.f_offset, 18));
      600 		end;
      601 
      602 	     if (delete)				/* message is being deleted */
      603 	     then do;
      604 		copy_size = delete_size;		/* set size of copy mask */
      605 		deletep -> bit_copy_mask = "0"b;	/* use mask to zero out block */
      606 	     end;
      607 
      608 	end;
      609 
      610 /*  */
      611 /* finish deleting message if requested */
      612 
      613 	if (delete) then do;
      614 
      615 	     if ms_count > 1			/* there will be a remaining message */
      616 	     then do;
      617 
      618 /* unthread the message */
      619 
      620 		if (first) then do;			/* unthread first message */
      621 		     mptr -> mseg_hdr_v4.first_ms_offset =
      622 			bit (fixed (next_offset, 18), 18); /* reset header offset to new first message */
      623 		     next_tr_ptr -> ms_block_trailer.b_offset =
      624 			"0"b;			/* reset new first message back pointer */
      625 		end;
      626 
      627 		if (last) then do;			/* unthread last message */
      628 		     mptr -> mseg_hdr_v4.last_ms_offset =
      629 			bit (fixed (prev_offset, 18), 18); /* reset header offset to new last message */
      630 		     prev_tr_ptr -> ms_block_trailer.f_offset =
      631 			"0"b;			/* reset new last message forward pointer */
      632 		end;
      633 
      634 		if (^first) then if (^last) then do;	/* unthread mid message */
      635 			prev_tr_ptr -> ms_block_trailer.f_offset =
      636 			     bit (fixed (next_offset, 18), 18); /* reset forward offset of previous message */
      637 			next_tr_ptr -> ms_block_trailer.b_offset =
      638 			     bit (fixed (prev_offset, 18), 18); /* reset backward offset of next message */
      639 		     end;
      640 
      641 	     end;
      642 
      643 	     else					/* no messages left */
      644 	     mptr -> mseg_hdr_v4.first_ms_offset,		/* zero out hdr pointers */
      645 		mptr -> mseg_hdr_v4.last_ms_offset = "0"b;
      646 
      647 /* rethread the hash bucket */
      648 	     if prev_in_bucket_ptr = null then
      649 		mptr -> mseg_hdr_v4.hash_table.last_in_bucket (htx) = back_in_bucket_offset;
      650 	     else prev_in_bucket_ptr -> ms_block_trailer.back_in_bucket = back_in_bucket_offset;
      651 
      652 /* update header after deletion */
      653 
      654 	     mptr -> mseg_hdr_v4.space_left =		/* reset space left */
      655 		mptr -> mseg_hdr_v4.space_left + blocks_in_message;
      656 
      657 	     ms_count = ms_count - 1;
      658 	     mptr -> mseg_hdr_v4.number_of_messages =	/* reset number of messages */
      659 		fixed (ms_count);
      660 
      661 	     mptr -> mseg_hdr_v4.mip = "0"b;		/* turn off modification in progress bit */
      662 
      663 	end;
      664 
      665 	if read | incr_read
      666 	then do;					/* fill in return argument structure */
      667 	     arg_ptr = a_arg_ptr;			/* copy ptr to return_args structure */
      668 	     return_args.ms_ptr = ret_ptr;		/* ptr to message */
      669 	     return_args.ms_len = ms_len;		/* length of message */
      670 	     return_args.sender_id = ms_sender_id;	/* person-project ID of message sender */
      671 	     return_args.level = level;		/* validation level of message sender */
      672 	     return_args.ms_id = ms_id;		/* message ID */
      673 	     return_args.sender_authorization = authorization; /* authorization of message sender */
      674 	     return_args.access_class = access_class;	/* access class of message */
      675 	end;
      676 
      677 FIN:
      678 
      679 	a_code = code;
      680 	return;
      681 
      682 BAD_SEG:
      683 	call mseg_error_v4_ (mptr, 0, proc_name, reason);
      684 	code = error_table_$bad_segment;
      685 	go to FIN;
      686 
      687 
      688      end mseg_util_v4_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  mseg_util_v4_.pl1                 >spec>on>mseg>mseg_util_v4_.pl1
135          1    05/06/85  1121.9  mseg_hdr_v4.incl.pl1              >spec>on>mseg>mseg_hdr_v4.incl.pl1
138          2    05/06/85  1121.7  ms_block_hdr_v4.incl.pl1          >spec>on>mseg>ms_block_hdr_v4.incl.pl1
140          3    05/06/85  1121.7  ms_block_trailer_v4.incl.pl1      >spec>on>mseg>ms_block_trailer_v4.incl.pl1
142          4    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_area_ptr                             parameter       pointer                  dcl 27 ref 161 167 171 183 187 191 197 206
a_arg_ptr                              parameter       pointer                  dcl 27 ref 161 167 183 191 197 515 667
a_code                                 parameter       fixed bin(35,0)          dcl 101 set ref 161 167 175 183 191 197 211 219 677*
a_count                                parameter       fixed bin(18,0)          dcl 59 set ref 219 323* 426*
a_dir                                  parameter       bit(2)                   dcl 82 ref 191 197 201
a_first_or_last                        parameter       bit(1)                   dcl 79 ref 161 167 170 183 186
a_mptr                                 parameter       pointer                  dcl 27 ref 161 167 175 183 191 197 211 219 231
a_ms_id                                parameter       bit(72)                  dcl 85 ref 175 178 191 197 200 211 215
a_ms_len                               parameter       fixed bin(24,0)          dcl 71 ref 211 459
a_ms_ptr                               parameter       pointer                  dcl 27 ref 211 465
a_own                                  parameter       bit(1)                   dcl 41 ref 161 167 175 183 191 197 211 228
a_read_access                          parameter       bit(1)                   dcl 41 ref 175 180 211 216
access_class             20            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v4_" set ref 342* 401*
                                                                                  403* 443* 443* 507
access_class             20            based           bit(72)                  level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 674*
access_class                    000164 automatic       bit(72)                  dcl 88 in procedure "mseg_util_v4_" set ref 326*
                                                                                  328* 507* 674
addr                                                   builtin function         dcl 106 ref 308 569
addrel                                                 builtin function         dcl 106 ref 260 280 390 563 566
aim_template                           based           structure                level 1 dcl 4-12
alloc_bits              520            based           bit                      level 2 dcl 1-3 set ref 575 580*
alloc_len                12            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v4" dcl 1-3
                                                                                  in procedure "mseg_util_v4_" ref 497 575 580
alloc_len                       000167 automatic       fixed bin(17,0)          dcl 94 in procedure "mseg_util_v4_" set ref 497*
area                            000176 stack reference condition                dcl 108 ref 519
area_array                             based           area(30)                 dcl 113 ref 514 525
area_ptr                        000120 automatic       pointer                  dcl 27 set ref 171* 187* 206* 514 525
arg_ptr                         000114 automatic       pointer                  dcl 27 set ref 667* 668 669 670 671 672 673 674
authorization                   000162 automatic       bit(72)                  dcl 88 set ref 306* 328* 342* 401* 403* 443* 443*
                                                                                  506* 673
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 set ref 348 358 421
                                                                                  480 623* 637*
back_in_bucket            2(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 set ref 289 494
                                                                                  650*
back_in_bucket_offset           000137 automatic       bit(18)                  dcl 57 set ref 494* 648 650
based_priv                             based           structure                level 1 packed unaligned dcl 92
bit                                                    builtin function         dcl 106 ref 621 628 635 637
bit_copy_mask                          based           bit                      unaligned dcl 122 set ref 563* 563 566* 566 605*
bit_off                         000151 automatic       fixed bin(18,0)          dcl 59 set ref 574* 575 580
bits                                   based           bit(1)                   array unaligned dcl 124 set ref 569
block_count               0(19)        based           bit(17)                  level 2 packed unaligned dcl 2-3 ref 546 556
block_ptr                       000256 automatic       pointer                  dcl 2-3 set ref 535* 546 556 563 563 566 566 574 582
                                                                                  585 598* 598 598
block_size                      000145 automatic       fixed bin(18,0)          dcl 59 in procedure "mseg_util_v4_" set ref 239* 241
                                                                                  496 574
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v4" dcl 1-3
                                                                                  in procedure "mseg_util_v4_" ref 239
blocks_in_message               000146 automatic       fixed bin(18,0)          dcl 59 set ref 534* 543* 543 654
caller_id                       000212 automatic       char(32)                 unaligned dcl 116 set ref 311* 312 312 314 339 396
                                                                                  436
cleanup                         000204 stack reference condition                dcl 108 ref 511
code                            000174 automatic       fixed bin(35,0)          dcl 101 set ref 203* 233* 326* 327 355* 439* 448*
                                                                                  462* 520* 677 684*
copy_size                       000152 automatic       fixed bin(24,0)          dcl 71 set ref 556* 560* 560 563 563 566 566 569
                                                                                  604* 605
count                           000142 automatic       fixed bin(18,0)          dcl 59 set ref 330* 407* 407 426
delete                          000124 automatic       bit(1)                   initial dcl 41 set ref 41* 179* 188* 258 403 434 468
                                                                                  538 572 602 613
delete_size                     000153 automatic       fixed bin(24,0)          dcl 71 set ref 496* 604
deletep                         000112 automatic       pointer                  dcl 27 set ref 582* 605
dir                             000157 automatic       bit(2)                   initial dcl 82 set ref 82* 201* 202 250* 255* 292
                                                                                  295 346 362 409 418
divide                                                 builtin function         dcl 106 ref 524 574
error_table_$ai_restricted      000012 external static fixed bin(35,0)          dcl 145 ref 448
error_table_$bad_segment        000010 external static fixed bin(35,0)          dcl 144 ref 684
error_table_$bigarg             000022 external static fixed bin(35,0)          dcl 149 ref 462
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 148 ref 203
error_table_$moderr             000014 external static fixed bin(35,0)          dcl 146 ref 439
error_table_$no_message         000016 external static fixed bin(35,0)          dcl 147 ref 355
error_table_$noalloc            000024 external static fixed bin(35,0)          dcl 150 ref 520
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "mseg_util_v4_" ref 585 598
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer" packed
                                                                                  unaligned dcl 3-3 in procedure "mseg_util_v4_" set
                                                                                  ref 364 373 418 488 630* 635*
first                           000134 automatic       bit(1)                   dcl 41 set ref 471* 473* 478 620 634
first_block               0(18)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 275 385
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 set ref 256 350 471 621* 643*
first_or_last                   000156 automatic       bit(1)                   dcl 79 set ref 170* 186* 248
fixed                                                  builtin function         dcl 106 ref 236 239 251 256 269 270 289 350 358 366
                                                                                  373 418 421 455 471 474 480 488 504 546 556 574
                                                                                  598 621 628 635 637 658
found_ms_len                    000155 automatic       fixed bin(24,0)          dcl 71 set ref 532* 546* 546 547 559 560 588
get_count                       000126 automatic       bit(1)                   initial dcl 41 set ref 41* 222* 245 319 407 424
get_group_id_$tag_star          000026 constant        entry                    external dcl 152 ref 311
get_privileges_                 000032 constant        entry                    external dcl 154 ref 307
get_process_authorization_      000030 constant        entry                    external dcl 153 ref 306
hash_table              120            based           structure                level 2 dcl 1-3
hcs_$get_access_class_seg       000034 constant        entry                    external dcl 155 ref 326
htx                             000172 automatic       fixed bin(17,0)          dcl 94 set ref 269* 270 648
id_len                          000173 automatic       fixed bin(17,0)          dcl 94 set ref 312* 314* 339 339 396 396 436 436
incr_read                       000123 automatic       bit(1)                   initial dcl 41 set ref 41* 207* 292 337 501 554 665
index                                                  builtin function         dcl 106 ref 314
last                            000133 automatic       bit(1)                   dcl 41 set ref 474* 476* 486 627 634
last_in_bucket          120            based           bit(18)                  array level 3 packed unaligned dcl 1-3 set ref 270
                                                                                  648*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 set ref 251 366 474 628* 643*
length                                                 builtin function         dcl 106 ref 312
level                           000170 automatic       fixed bin(17,0)          dcl 94 in procedure "mseg_util_v4_" set ref 504* 671
level                    13            based           fixed bin(17,0)          level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 671*
loc                             000150 automatic       fixed bin(18,0)          dcl 59 set ref 251* 256* 259 270* 273 274 289* 350
                                                                                  358* 366 373* 383 384 418* 421* 471 474
mip                      16            based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 538* 661*
mptr                            000254 automatic       pointer                  dcl 136 set ref 231* 236 239 251 256 259 270 274
                                                                                  326* 350 366 384 471 474 482 490 497 538 575 580
                                                                                  621 628 643 643 648 654 654 658 661 682*
ms_block_hdr                           based           structure                level 1 dcl 2-3 ref 563 566
ms_block_trailer                       based           structure                level 1 dcl 3-3 set ref 241
ms_count                        000141 automatic       fixed bin(18,0)          dcl 59 set ref 236* 323 615 657* 657 658
ms_end                          000136 automatic       bit(1)                   dcl 41 set ref 536* 541 561* 585 593*
ms_id                     3            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v4_" ref 261 286 409 414
                                                                                  505
ms_id                    14            based           bit(72)                  level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 672*
ms_id                           000160 automatic       bit(72)                  dcl 85 in procedure "mseg_util_v4_" set ref 178*
                                                                                  200* 215* 261* 269 286 409 414 505* 672
ms_len                    2            based           fixed bin(18,0)          level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 669*
ms_len                          000154 automatic       fixed bin(24,0)          dcl 71 in procedure "mseg_util_v4_" set ref 455* 460
                                                                                  524 547 588 669
ms_ptr                                 based           pointer                  level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 515* 668*
ms_ptr                          000106 automatic       pointer                  dcl 27 in procedure "mseg_util_v4_" set ref 259* 260
                                                                                  274* 275 280 384* 385 390 535
ms_sender_id                    000222 automatic       char(32)                 unaligned dcl 116 set ref 503* 670
ms_size                   5            based           bit(24)                  level 2 packed unaligned dcl 3-3 ref 455
ms_word_array                          based           fixed bin(17,0)          array dcl 113 ref 514 525
ms_word_len                     000171 automatic       fixed bin(17,0)          dcl 94 set ref 514 524* 525
mseg_error_v4_                  000036 constant        entry                    external dcl 156 ref 682
mseg_hdr_v4                            based           structure                level 1 dcl 1-3
mseg_priv                       000130 automatic       bit(1)                   dcl 41 set ref 308* 321 342 399 443
next_offset                     000144 automatic       fixed bin(18,0)          dcl 59 set ref 488* 490 621 635
next_tr_ptr                     000102 automatic       pointer                  dcl 27 set ref 490* 623 637
null                                                   builtin function         dcl 106 ref 27 271 512 515 648
number_of_messages       14            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 236 658*
own                             000131 automatic       bit(1)                   dcl 41 set ref 223* 228* 309 339 396 436
prev_in_bucket_ptr              000104 automatic       pointer                  dcl 27 set ref 271* 288* 648 650
prev_offset                     000143 automatic       fixed bin(18,0)          dcl 59 set ref 480* 482 628 637
prev_tr_ptr                     000100 automatic       pointer                  dcl 27 set ref 482* 630 635
priv_entry                      000127 automatic       bit(1)                   initial dcl 41 set ref 41* 164* 194* 308
privileges                      000166 automatic       bit(36)                  dcl 91 in procedure "mseg_util_v4_" set ref 307* 308
privileges                1(18)        based           structure                level 2 in structure "aim_template" packed unaligned
                                                                                  dcl 4-12 in procedure "mseg_util_v4_"
proc_name                       000232 automatic       char(32)                 unaligned dcl 119 set ref 163* 169* 177* 185* 193*
                                                                                  199* 213* 221* 682*
ptr                                                    builtin function         dcl 106 ref 259 274 384 482 490 598
read                            000122 automatic       bit(1)                   initial dcl 41 set ref 41* 172* 188* 247 381 501 554
                                                                                  665
read_access                     000132 automatic       bit(1)                   initial dcl 41 set ref 41* 180* 216* 436
read_allowed_                   000040 constant        entry                    external dcl 157 ref 328 342 401 443
read_write_allowed_             000042 constant        entry                    external dcl 158 ref 403 443
reason                          000242 automatic       char(40)                 unaligned dcl 120 set ref 277* 283* 352* 368* 387*
                                                                                  393* 549* 577* 590* 682*
rel                                                    builtin function         dcl 106 ref 574
ret_ptr                         000110 automatic       pointer                  initial dcl 27 set ref 27* 512 514 525* 526 668
return_args                            based           structure                level 1 dcl 126
ring1                     0(04)        based           bit(1)                   level 2 packed unaligned dcl 92 ref 308
ring_no                   2            based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 504
rtrim                                                  builtin function         dcl 106 ref 312
search_sw                       000135 automatic       bit(1)                   dcl 41 set ref 234* 294* 336 409
sender_authorization     16            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v4_" ref 506
sender_authorization     16            based           bit(72)                  level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 673*
sender_id                 3            based           char(32)                 level 2 in structure "return_args" dcl 126
                                                                                  in procedure "mseg_util_v4_" set ref 670*
sender_id                 6            based           char(32)                 level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v4_" ref 339 396 436 503
size                                                   builtin function         dcl 106 ref 241 563 566
space_left               13            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 654* 654
substr                                                 builtin function         dcl 106 set ref 269 312 339 339 396 396 409 409 414
                                                                                  414 436 436 575 580*
switches                 16            based           structure                level 2 dcl 1-3
t_ptr                           000116 automatic       pointer                  dcl 27 set ref 465* 526* 563 566 569* 569
tr_offset                       000140 automatic       fixed bin(18,0)          dcl 59 set ref 241* 260 280 390 482 490
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 281 391
tr_ptr                          000260 automatic       pointer                  dcl 3-3 set ref 241 260* 261 280* 281 286 288 289
                                                                                  339 342 348 358 364 373 390* 391 396 401 403 409
                                                                                  414 418 421 436 443 443 455 480 488 494 503 504
                                                                                  505 506 507
trailer_pattern                 002245 constant        bit(36)                  initial dcl 3-18 ref 281 391
update                          000125 automatic       bit(1)                   initial dcl 41 set ref 41* 214* 434 457 554 558
update_len                      000147 automatic       fixed bin(18,0)          dcl 59 set ref 459* 460 559 560

NAMES DECLARED BY EXPLICIT CONTEXT.
AI_ERR                          001453 constant        label                    dcl 448 ref 403
BAD_SEG                         002212 constant        label                    dcl 682 ref 278 284 353 369 388 394 550 578 591
COMMON                          000570 constant        label                    dcl 228 ref 173 181 189 208 217
COMMON2                         000573 constant        label                    dcl 231 ref 224
COUNT                           000625 constant        label                    dcl 255 ref 245
EXIT                            001371 constant        label                    dcl 430 ref 409 409 414
FIN                             002207 constant        label                    dcl 677 ref 204 324 327 356 427 440 449 463 521 685
FIRST                           000627 constant        label                    dcl 256 ref 296
FOUND_ID                        000741 constant        label                    dcl 300 ref 286
FULL_COUNT                      001032 constant        label                    dcl 323 ref 328
IR_COMMON                       000456 constant        label                    dcl 200 ref 195
LAST                            000620 constant        label                    dcl 251 ref 295
NEXT                            001345 constant        label                    dcl 418 ref 396 401 413 416
NO_MSG                          001151 constant        label                    dcl 355 ref 299 339 342 371 429 436 443
READ                            001207 constant        label                    dcl 383 ref 331 336 359 374
R_COMMON                        000267 constant        label                    dcl 170 ref 165
THREAD                          000651 constant        label                    dcl 269 ref 262
delete                          000306 constant        entry                    external dcl 175
get_count                       000550 constant        entry                    external dcl 219
incremental_read                000434 constant        entry                    external dcl 197
incremental_read_priv           000405 constant        entry                    external dcl 191
mseg_util_v4_                   000205 constant        entry                    external dcl 11
read                            000247 constant        entry                    external dcl 167
read_and_delete                 000344 constant        entry                    external dcl 183
read_priv                       000222 constant        entry                    external dcl 161
update                          000510 constant        entry                    external dcl 211

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2542        2606    2246        2552
Length      3112    2246        44         267     274           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_util_v4_                       222 external procedure  is an external procedure.  
on unit on line 511                  64 on unit               
on unit on line 519                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mseg_util_v4_            000100 prev_tr_ptr                 mseg_util_v4_
                         000102 next_tr_ptr                 mseg_util_v4_
                         000104 prev_in_bucket_ptr          mseg_util_v4_
                         000106 ms_ptr                      mseg_util_v4_
                         000110 ret_ptr                     mseg_util_v4_
                         000112 deletep                     mseg_util_v4_
                         000114 arg_ptr                     mseg_util_v4_
                         000116 t_ptr                       mseg_util_v4_
                         000120 area_ptr                    mseg_util_v4_
                         000122 read                        mseg_util_v4_
                         000123 incr_read                   mseg_util_v4_
                         000124 delete                      mseg_util_v4_
                         000125 update                      mseg_util_v4_
                         000126 get_count                   mseg_util_v4_
                         000127 priv_entry                  mseg_util_v4_
                         000130 mseg_priv                   mseg_util_v4_
                         000131 own                         mseg_util_v4_
                         000132 read_access                 mseg_util_v4_
                         000133 last                        mseg_util_v4_
                         000134 first                       mseg_util_v4_
                         000135 search_sw                   mseg_util_v4_
                         000136 ms_end                      mseg_util_v4_
                         000137 back_in_bucket_offset       mseg_util_v4_
                         000140 tr_offset                   mseg_util_v4_
                         000141 ms_count                    mseg_util_v4_
                         000142 count                       mseg_util_v4_
                         000143 prev_offset                 mseg_util_v4_
                         000144 next_offset                 mseg_util_v4_
                         000145 block_size                  mseg_util_v4_
                         000146 blocks_in_message           mseg_util_v4_
                         000147 update_len                  mseg_util_v4_
                         000150 loc                         mseg_util_v4_
                         000151 bit_off                     mseg_util_v4_
                         000152 copy_size                   mseg_util_v4_
                         000153 delete_size                 mseg_util_v4_
                         000154 ms_len                      mseg_util_v4_
                         000155 found_ms_len                mseg_util_v4_
                         000156 first_or_last               mseg_util_v4_
                         000157 dir                         mseg_util_v4_
                         000160 ms_id                       mseg_util_v4_
                         000162 authorization               mseg_util_v4_
                         000164 access_class                mseg_util_v4_
                         000166 privileges                  mseg_util_v4_
                         000167 alloc_len                   mseg_util_v4_
                         000170 level                       mseg_util_v4_
                         000171 ms_word_len                 mseg_util_v4_
                         000172 htx                         mseg_util_v4_
                         000173 id_len                      mseg_util_v4_
                         000174 code                        mseg_util_v4_
                         000212 caller_id                   mseg_util_v4_
                         000222 ms_sender_id                mseg_util_v4_
                         000232 proc_name                   mseg_util_v4_
                         000242 reason                      mseg_util_v4_
                         000254 mptr                        mseg_util_v4_
                         000256 block_ptr                   mseg_util_v4_
                         000260 tr_ptr                      mseg_util_v4_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              tra_ext             enable              ext_entry
int_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_$tag_star        get_privileges_               get_process_authorization_    hcs_$get_access_class_seg
mseg_error_v4_                read_allowed_                 read_write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$bad_segment      error_table_$bigarg           error_table_$inconsistent
error_table_$moderr           error_table_$no_message       error_table_$noalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000170        41 000172        82 000201        11 000204       161 000213       163 000237       164 000242
    165 000244       167 000245       169 000264       170 000267       171 000273       172 000276       173 000300
    175 000301       177 000325       178 000330       179 000334       180 000336       181 000341       183 000342
    185 000361       186 000364       187 000370       188 000373       189 000376       191 000377       193 000424
    194 000427       195 000431       197 000432       199 000453       200 000456       201 000462       202 000466
    203 000470       204 000473       206 000474       207 000477       208 000501       211 000502       213 000527
    214 000532       215 000534       216 000540       217 000543       219 000544       221 000561       222 000564
    223 000566       224 000567       228 000570       231 000573       233 000577       234 000600       236 000601
    239 000603       241 000605       245 000607       247 000611       248 000613       250 000616       251 000620
    252 000624       255 000625       256 000627       258 000633       259 000635       260 000640       261 000644
    262 000647       264 000650       269 000651       270 000654       271 000664       273 000666       274 000670
    275 000673       277 000676       278 000701       280 000702       281 000706       283 000711       284 000714
    286 000715       288 000721       289 000722       290 000725       292 000726       294 000732       295 000734
    296 000737       299 000740       306 000741       307 000750       308 000757       309 000764       311 000766
    312 000775       314 001015       319 001026       321 001030       323 001032       324 001035       326 001036
    327 001051       328 001053       330 001071       331 001072       336 001073       337 001075       339 001077
    342 001107       346 001130       348 001133       350 001140       352 001145       353 001150       355 001151
    356 001154       358 001155       359 001157       362 001160       364 001162       366 001167       368 001174
    369 001177       371 001200       373 001201       374 001203       377 001204       381 001205       383 001207
    384 001212       385 001215       387 001220       388 001223       390 001224       391 001230       393 001233
    394 001236       396 001237       399 001246       401 001250       403 001266       407 001307       409 001313
    413 001332       414 001333       416 001344       418 001345       421 001355       422 001361       424 001362
    426 001364       427 001367       429 001370       434 001371       436 001375       439 001407       440 001412
    443 001413       448 001453       449 001456       455 001457       457 001463       459 001465       460 001470
    462 001472       463 001475       465 001476       468 001501       471 001503       473 001513       474 001514
    476 001523       478 001524       480 001526       482 001531       486 001535       488 001537       490 001542
    494 001546       496 001551       497 001554       501 001556       503 001562       504 001565       505 001570
    506 001573       507 001576       511 001601       512 001615       514 001622       515 001624       517 001630
    519 001631       520 001645       521 001650       524 001653       525 001657       526 001664       532 001665
    534 001666       535 001667       536 001671       538 001672       541 001677       543 001702       546 001703
    547 001710       549 001713       550 001716       554 001717       556 001725       558 001730       559 001732
    560 001735       561 001741       563 001743       565 001752       566 001753       569 001761       572 001765
    574 001767       575 001774       577 002001       578 002004       580 002005       582 002010       585 002012
    588 002020       590 002023       591 002026       593 002027       595 002031       598 002032       602 002036
    604 002040       605 002042       608 002046       613 002047       615 002051       620 002054       621 002056
    623 002064       627 002067       628 002071       630 002077       634 002102       635 002106       637 002114
    641 002122       643 002123       648 002126       650 002141       654 002145       657 002150       658 002152
    661 002154       665 002156       667 002162       668 002165       669 002167       670 002171       671 002174
    672 002176       673 002201       674 002204       677 002207       680 002211       682 002212       684 002240
    685 002243


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
