	COMPILATION LISTING OF SEGMENT le_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1257.8 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written as the subroutine interface to the linkage editor.
       11*                                                   END HISTORY COMMENTS */
       12 
       13 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       14 
       15 le_:
       16   proc (leip,			/** le_info pointer	    (in )	*/
       17        severity,			/** max error severity  (out) */
       18        code);			/** error code	    (out) */
       19 
       20   /*** ****************************************************************/
       21   /***							*/
       22   /***	Name:	le_					*/
       23   /***	Input:	leip					*/
       24   /***	Function:	This is the multics linkage_editor subroutine	*/
       25   /***		interface.  It takes as input a structure which	*/
       26   /***		consists of a set of flags, an output pathname,	*/
       27   /***		and a list of options which specify the input	*/
       28   /***		binaries to be included, any library binaries,	*/
       29   /***		synonyms, addnames, and retention and deletion	*/
       30   /***		options for the entire output, one component, or	*/
       31   /***		a single entrypoint.			*/
       32   /***	Output:	severity, code				*/
       33   /***							*/
       34   /*** ****************************************************************/
       35 
       36   /* constants */
       37 
       38   dcl true		bit (1) static options (constant) init ("1"b);
       39   dcl false		bit (1) static options (constant) init ("0"b);
       40 
       41   /* parameters */
       42 
       43   dcl leip		ptr parameter;
       44   dcl severity		fixed bin parameter;
       45   dcl code		fixed bin (35) parameter;
       46 
       47   /* procedures */
       48 
       49   dcl define_area_		entry (ptr, fixed bin (35));
       50   dcl get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
       51   dcl hash_$search		entry (ptr, char (*), bit (36) aligned,
       52 			fixed bin (35));
       53   dcl hcs_$chname_file	entry (char(*), char(*), char(*), char(*),
       54 		          fixed bin(35));
       55   dcl le_apply_def_options_	entry (ptr, ptr);
       56   dcl le_combine_init_info_	entry (ptr);
       57   dcl le_complete_binary_	entry (ptr, ptr);
       58   dcl le_create_binary_	entry (ptr, char (*), char (*), fixed bin,
       59 			bit (1), char (*), char (*));
       60   dcl le_create_list_	entry (ptr, ptr, char (*), char (*), bit (1));
       61   dcl le_error_		entry options (variable);
       62   dcl le_make_comp_tbl_	entry (ptr, ptr);
       63   dcl le_make_component_	entry (char (*), char (*), ptr, ptr, ptr,
       64 			fixed bin, fixed bin);
       65   dcl le_make_link_tbl_	entry (ptr, ptr, ptr);
       66   dcl le_make_opt_tbl_	entry (ptr, ptr);
       67   dcl le_make_segname_tbl_	entry (ptr, ptr, ptr, ptr);
       68   dcl le_msf_partition_	entry (ptr, fixed bin, fixed bin);
       69   dcl nd_handler_		entry (char(*), char(*), char(*),
       70 		          fixed bin(35));
       71   dcl nd_handler_$force	entry (char(*), char(*), char(*),
       72 		          fixed bin(35));
       73   dcl release_area_		entry (ptr);
       74   dcl release_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
       75 
       76   /* external */
       77 
       78   dcl error_table_$dup_ent_name
       79 			external fixed bin (35);
       80   dcl error_table_$namedup	external fixed bin (35);
       81   dcl error_table_$noentry	external fixed bin (35);
       82   dcl error_table_$segnamedup external fixed bin (35);
       83   dcl error_table_$translation_failed
       84 			external fixed bin (35);
       85   dcl le_data_$caller	external char (32) varying;
       86   dcl le_data_$debug	external bit (1);
       87   dcl le_data_$display_severity
       88 			external fixed bin;
       89   dcl le_data_$max_severity	external fixed bin;
       90   dcl le_data_$patch_ptr	external ptr;
       91   dcl le_data_$running	external bit (1);
       92   dcl le_et_$recursive_invocation
       93 			external fixed bin (35);
       94   dcl sys_info$max_seg_size	external fixed bin (35);
       95 
       96   /* based */
       97 
       98   dcl 01 lec		aligned based (ts.lecp),
       99        02 header		aligned like le_components.header,
      100        02 comp		dim (0 refer (lec.n_components)) like le_comp;
      101   dcl 01 lei		aligned based (leip),
      102        02 header		aligned like le_input.header,
      103        02 opt		dim (0 refer (lei.n_opts)) like le_option;
      104   dcl 01 ts		aligned based (addr (temp_segs (1))),
      105        02 lecp		ptr,
      106        02 leop		ptr,
      107        02 leshp		ptr,
      108        02 lebp		ptr,
      109        02 lepp		ptr;
      110 
      111   /* automatic */
      112 
      113   dcl 01 ai		aligned like area_info automatic;
      114   dcl bits		aligned bit (36) automatic;
      115   dcl c			fixed bin automatic;
      116   dcl done		bit (1) automatic;
      117   dcl dname		char (168) automatic;
      118   dcl ec			fixed bin (35) automatic;
      119   dcl ename		char (32) automatic;
      120   dcl i			fixed bin automatic;
      121   dcl leap		ptr automatic;
      122   dcl n_components		fixed bin automatic;
      123   dcl temp_segs		(1:5) aligned ptr automatic;
      124 
      125   /* conditions */
      126 
      127   dcl cleanup		condition;
      128   dcl le_abort_		condition;
      129 
      130   /* builtin */
      131 
      132   dcl addr		builtin;
      133   dcl char		builtin;
      134   dcl ltrim		builtin;
      135   dcl null		builtin;
      136   dcl rtrim		builtin;
      137   dcl unspec		builtin;
      138 
      139 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      140 
      141 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      142 
      143 
      144   /* initialize le_data_ static variables */
      145 
      146   le_data_$max_severity = 0;
      147   le_data_$display_severity = lei.display_severity;
      148   le_data_$debug = lei.flags.debug;
      149   le_data_$caller = rtrim (lei.header.name);
      150 
      151   temp_segs (1) = null;
      152   leap = null;
      153 
      154   on le_abort_ goto ABORT;
      155 
      156   on cleanup
      157     begin;
      158     if temp_segs (1) ^= null
      159       then call release_temp_segments_ ((le_data_$caller), temp_segs, 0);
      160     if leap ^= null
      161       then call release_area_ (leap);
      162     le_data_$running = false;
      163   end;
      164 
      165   /* see if we have a recursive invocation */
      166 
      167   if le_data_$running
      168     then do;
      169       call le_error_ (LE_FATAL_ERROR, le_et_$recursive_invocation, "");
      170       severity = le_data_$max_severity;
      171       code = error_table_$translation_failed;
      172       return;
      173     end;
      174 
      175   le_data_$running = true;
      176 
      177   /* create the area for table allocation */
      178 
      179   unspec (ai) = ""b;
      180 
      181   ai.version = area_info_version_1;
      182   ai.control.extend = true;
      183   ai.control.no_freeing = true;
      184   ai.owner = le_data_$caller;
      185   ai.size = sys_info$max_seg_size;
      186   ai.areap = null;
      187 
      188   call define_area_ (addr (ai), ec);
      189   leap = ai.areap;
      190 
      191   /* get temp segments for extensible tables */
      192 
      193   call get_temp_segments_ ((le_data_$caller), temp_segs, ec);
      194 
      195   /* give the backpatch facility a segment to use */
      196 
      197   le_data_$patch_ptr = ts.lepp;
      198 
      199   /*  1) create option table					*/
      200 
      201   call le_make_opt_tbl_ (leip, ts.leop);
      202 
      203   /* note that until we actually start to emit object, we can keep	*/
      204   /* going with any severity less than 3 so as to get the most info	*/
      205   /* to the user regardless of what severity was given as abort.	*/
      206 
      207   call severity_check (LE_FATAL_ERROR);
      208 
      209   /*  2) create component table				*/
      210 
      211   call le_make_comp_tbl_ (leip, ts.lecp);
      212   call severity_check (LE_FATAL_ERROR);
      213 
      214   /*  3) create segname table					*/
      215 
      216   call le_make_segname_tbl_ (leip, ts.lecp, ts.leshp, leap);
      217   call severity_check (LE_FATAL_ERROR);
      218 
      219   /*  4) apply the options to the definitions extracted		*/
      220 
      221   call le_apply_def_options_ (ts.lecp, ts.leop);
      222   call severity_check (LE_FATAL_ERROR);
      223 
      224   /*  5) recursive link resolution through path and library links	*/
      225 
      226   call le_make_link_tbl_ (ts.lecp, ts.leshp, leap);
      227   call severity_check (LE_FATAL_ERROR);
      228 
      229   /* determine if the new object should have its perprocess_static	*/
      230   /* switch on						*/
      231 
      232   lec.flags.perprocess_static = lei.flags.perprocess_static;
      233 
      234   /* determine if the new object should have separate static sections	*/
      235 
      236   done = false;
      237   lec.header.flags.separate_static = false;
      238 
      239   do c = 1 to lec.n_components while (^done);
      240     if lec.comp (c).flags.include & lec.comp (c).orig.statl > 0
      241       then do;
      242         if ^lec.comp (c).flags.separate_static
      243 	then do;
      244 	  lec.header.flags.separate_static = false;
      245 	  done = true;
      246 	end;
      247 	else lec.header.flags.separate_static = true;
      248       end;
      249   end;
      250 
      251   /*  6) partition into MSF components				*/
      252 
      253   call le_msf_partition_ (lecp, lei.component_size, n_components);
      254   call severity_check (LE_FATAL_ERROR);
      255 
      256   /*  7) resolve init_infos into 1 init_info/external variable	*/
      257 
      258   call le_combine_init_info_ (ts.lecp);
      259   call severity_check (LE_FATAL_ERROR);
      260 
      261   /*  8) insure that the component block segnames don't conflict with	*/
      262   /*     anything.						*/
      263 
      264   if n_components = 1
      265     then do;
      266       call hash_$search (leshp, lei.output_file.entry, bits, ec);
      267       if ec ^= error_table_$noentry
      268         then call le_error_ (LE_FATAL_ERROR, error_table_$dup_ent_name,
      269 	        "^/Name ^a on bound segment " ||
      270 	        "conflicts with another segname.",
      271 	        lei.output_file.entry);
      272     end;
      273     else do;
      274       do i = 1 to n_components;
      275         ename = rtrim (lei.output_file.entry) || ltrim (rtrim (char (i)));
      276         call hash_$search (leshp, ename, bits, ec);
      277         if ec ^= error_table_$noentry
      278 	then call le_error_ (LE_FATAL_ERROR, error_table_$dup_ent_name,
      279 		"^/Name ^a on bound segment " ||
      280 		"conflicts with another segname.",
      281 		ename);
      282       end;
      283     end;
      284 
      285   /* from now on we use the users abort severity, since we are about	*/
      286   /* to try emitting some object code.				*/
      287 
      288   call severity_check (lei.abort_severity);
      289 
      290   /*  9) process each component				*/
      291 
      292   /* create the msf directory if necessary and adjust the dirname	*/
      293 
      294   call le_create_binary_ (ts.lecp, lei.output_file.dir, lei.output_file.entry,
      295        n_components, lei.flags.force, dname, ename);
      296   call severity_check (lei.abort_severity);
      297 
      298   /* 10) now emit each component of the output binary */
      299 
      300   do c = 1 to n_components;
      301     call le_make_component_ (dname, ename, leip, ts.lebp, ts.lecp, c,
      302          n_components);
      303     call severity_check (lei.abort_severity);
      304   end;
      305 
      306   /* 11) create msf component 0 if there more than 1 component and	*/
      307   /*     backpatch and unresolved references			*/
      308 
      309   call le_complete_binary_ (ts.lecp, ts.lebp);
      310 
      311   /* 12) add any names specified by ADDNAME options		*/
      312   
      313   do i = 1 to lei.n_opts;
      314     if lei.opt (i).type = ADDNAME
      315       then do;
      316         call hcs_$chname_file (lei.output_file.dir, lei.output_file.entry,
      317 	   "", lei.opt (i).name, ec);
      318         if ec = error_table_$namedup
      319 	then do;
      320 	  if lei.flags.force
      321 	    then call nd_handler_$force ((lei.header.name),
      322 		    lei.output_file.dir, lei.opt (i).name, ec);
      323 	    else call nd_handler_ ((lei.header.name), lei.output_file.dir,
      324 		    lei.opt (i).name, ec);
      325 	  if ec = 0
      326 	    then call hcs_$chname_file (lei.output_file.dir,
      327 		    lei.output_file.entry, "", lei.opt (i).name, ec);
      328 	end;
      329         else if ec ^= error_table_$segnamedup
      330 	then call le_error_ (LE_WARNING, ec, "^/While adding name ""^a"".",
      331 		lei.opt (i).name);
      332       end;
      333   end;
      334   
      335   /* 13) generate the listing if one was requested		*/
      336 
      337   if lei.flags.list | lei.flags.map
      338     then call le_create_list_ (ts.lecp, ts.lebp, lei.output_file.dir,
      339 	    lei.output_file.entry, lei.flags.list);
      340 
      341 ABORT:
      342   if temp_segs (1) ^= null
      343     then call release_temp_segments_ ((le_data_$caller), temp_segs, ec);
      344   if leap ^= null
      345     then call release_area_ (leap);
      346   severity = le_data_$max_severity;
      347   if severity >= lei.abort_severity
      348     then code = error_table_$translation_failed;
      349     else code = 0;
      350 
      351   le_data_$running = false;
      352 
      353   return;
      354 
      355 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      356 
      357 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      358 
      359 
      360 severity_check:
      361   proc (abort_severity);		/** severity to abort   (in )	*/
      362 
      363   /*** ****************************************************************/
      364   /***							*/
      365   /***	Name:	severity_check				*/
      366   /***	Input:	abort_severity				*/
      367   /***	Function:	determines whether the highest severity error	*/
      368   /***		encountered so far is sufficient to cause us to	*/
      369   /***		abort the run.  If it is, we release out temp	*/
      370   /***		storage and return with an error code of	*/
      371   /***		error_table_$translation_failed		*/
      372   /***	Output:	none					*/
      373   /***							*/
      374   /*** ****************************************************************/
      375 
      376   /* parameters */
      377 
      378   dcl abort_severity	fixed bin parameter;
      379 
      380   if le_data_$max_severity >= abort_severity
      381     then goto ABORT;
      382 
      383   end severity_check;
      384 
      385 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      386 
      387 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      388 
      389 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      390 
  2     1 /****  START OF:	le_input.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3   /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  2     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  2     6*     Orignally written to define the le_ input structures.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9   /*** ****************************************************************/
  2    10   /***							*/
  2    11   /***	Name:	le_input					*/
  2    12   /***	Function:	This include file declares the input structure to	*/
  2    13   /***		to the le_ subroutine.  The structure consists of	*/
  2    14   /***		a set of standard data, and a variable length	*/
  2    15   /***		array of options.  The options have a type field	*/
  2    16   /***		which specified what the option means.  The	*/
  2    17   /***		options can have the following types:		*/
  2    18   /***							*/
  2    19   /***		PATH	  - specified a single input component	*/
  2    20   /***			    to be bound in with the object	*/
  2    21   /***		 name	  - is the name of the component	*/
  2    22   /***		 path_or_ep - is the pathname to the component	*/
  2    23   /***			    this may be an archive component	*/
  2    24   /***			    pathname.			*/
  2    25   /***		 flags      - link is used by the le command to	*/
  2    26   /***			    keep track of the pathnames that	*/
  2    27   /***			    were found via links for chase	*/
  2    28   /***			    processing.			*/
  2    29   /***		 bc	  - is the bit count of the component	*/
  2    30   /***		 optp	  - is a pointer to the component	*/
  2    31   /***							*/
  2    32   /***		LIBRARY	  - specifies a single library	*/
  2    33   /***			    component.  Library components are	*/
  2    34   /***			    only included if they are referred	*/
  2    35   /***			    to by a PATH component or a library	*/
  2    36   /***			    component that is referenced and	*/
  2    37   /***			    therefor included.		*/
  2    38   /***		 name	  - same as for PATH.		*/
  2    39   /***		 path_or_ep - same as for PATH.		*/
  2    40   /***		 flags	  - same as for PATH.		*/
  2    41   /***		 bc	  - same as for PATH.		*/
  2    42   /***		 optp	  - same as for PATH.		*/
  2    43   /***							*/
  2    44   /***		ADDNAME	  - specifies a name to be added to the	*/
  2    45   /***			    bound object.			*/
  2    46   /***		 name	  - is the name to be added to the	*/
  2    47   /***			    bound unit			*/
  2    48   /***							*/
  2    49   /***		SYNONYM	  - specifies a synonym to be added to	*/
  2    50   /***			    a particular component.  This is	*/
  2    51   /***			    reflected as a segname definition	*/
  2    52   /***			    added to the block for that	*/
  2    53   /***			    component.			*/
  2    54   /***		 name	  - specifies the name of the component	*/
  2    55   /***			    to which you are adding a name.	*/
  2    56   /***		 path_or_ep - is the name being added		*/
  2    57   /***							*/
  2    58   /***		RETAIN	  - gives a starname to be used when	*/
  2    59   /***			    determining if a definition should	*/
  2    60   /***			    be retained.  If the definition	*/
  2    61   /***			    matches the starname and no more	*/
  2    62   /***			    specific info is given, the name is	*/
  2    63   /***			    retained.			*/
  2    64   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    65   /***			    that it is not an error if this	*/
  2    66   /***			    option is unused.		*/
  2    67   /***		 path_or_ep - is the starname to match		*/
  2    68   /***							*/
  2    69   /***		DELETE	  - gives a starname to be used when	*/
  2    70   /***			    determining if a definition should	*/
  2    71   /***			    be retained.  If the definition	*/
  2    72   /***			    matches the starname and no more	*/
  2    73   /***			    specific info is given, the name is	*/
  2    74   /***			    deleted.			*/
  2    75   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    76   /***			    that it is not an error if this	*/
  2    77   /***			    option is unused.		*/
  2    78   /***		 path_or_ep - is the starname to match.		*/
  2    79   /***							*/
  2    80   /***		NO_LINK	  - gives a starname to be used when	*/
  2    81   /***			    determining if a definition should	*/
  2    82   /***			    be retained.  If the definition	*/
  2    83   /***			    matches the starname and no more	*/
  2    84   /***			    specific info is given, the name is	*/
  2    85   /***			    retained and references to the	*/
  2    86   /***			    definition within the bound uni	*/
  2    87   /***			    are not resolved but are generated	*/
  2    88   /***			    as external links.		*/
  2    89   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    90   /***			    that it is not an error if this	*/
  2    91   /***			    option is unused.		*/
  2    92   /***		 path_or_ep - is the starname to match		*/
  2    93   /***							*/
  2    94   /***		TABLE	  - specifies that the table for a	*/
  2    95   /***			    particular component is to be	*/
  2    96   /***			    retained.			*/
  2    97   /***		 name	  - is the name of the component to	*/
  2    98   /***			    which the option applies.  If name	*/
  2    99   /***			    is "", this is a global option and	*/
  2   100   /***			    applies to all component for which	*/
  2   101   /***			    a specific option does not exist.	*/
  2   102   /***							*/
  2   103   /***		NO_TABLE	  - specifies that the table for a	*/
  2   104   /***			    particular component is to be	*/
  2   105   /***			    deleted.			*/
  2   106   /***		 name	  - is the name of the component to	*/
  2   107   /***			    which the option applies.  If name	*/
  2   108   /***			    is "", this is a global option and	*/
  2   109   /***			    applies to all component for which	*/
  2   110   /***			    a specific option does not exist.	*/
  2   111   /***							*/
  2   112   /*** ****************************************************************/
  2   113   
  2   114   dcl 01 le_input		aligned based,
  2   115        02 header		aligned,
  2   116         03 version		char (8),
  2   117         03 name		char (32),
  2   118         03 flags		aligned,
  2   119          04 perprocess_static	bit (1) unaligned,
  2   120          04 force		bit (1) unaligned,
  2   121          04 debug		bit (1) unaligned,
  2   122          04 list		bit (1) unaligned,
  2   123          04 map		bit (1) unaligned,
  2   124          04 auto_segnames	bit (1) unaligned,
  2   125          04 mbz		bit (30) unaligned,
  2   126         03 output_file	unaligned,
  2   127          04 dir		char (168),
  2   128          04 entry		char (32),
  2   129         03 component_size	fixed bin,
  2   130         03 display_severity	fixed bin,
  2   131         03 abort_severity	fixed bin,
  2   132         03 bindfile		aligned,
  2   133          04 name		char (32),
  2   134          04 dt_updated	fixed bin (71),
  2   135          04 dt_modified	fixed bin (71),
  2   136         03 pad		bit (36),
  2   137         03 n_opts		fixed bin,
  2   138        02 opt		dim (0 refer (le_input.n_opts)) like le_option;
  2   139   
  2   140   dcl 01 le_option		aligned based,
  2   141        02 name		char (32) unaligned,
  2   142        02 path_or_ep	char (194) unaligned,
  2   143        02 flags		unaligned,
  2   144         03 link		bit (1),
  2   145         03 ignore		bit (1),
  2   146         03 used		bit (1),
  2   147         03 inhibit_error	bit (1),
  2   148         03 mbz		bit (5),
  2   149        02 type		fixed bin (8) unaligned,
  2   150        02 bc		fixed bin (24),
  2   151        02 optp		ptr;
  2   152   
  2   153   dcl le_input_version_1	char (8) static options (constant)
  2   154 			init ("le_ 1.0 ");
  2   155   
  2   156   /* constants for the defined option types */
  2   157   
  2   158   dcl PATH		fixed bin static options (constant) init (1);
  2   159   dcl LIBRARY		fixed bin static options (constant) init (2);
  2   160   dcl ADDNAME		fixed bin static options (constant) init (3);
  2   161   dcl SYNONYM		fixed bin static options (constant) init (4);
  2   162   dcl RETAIN		fixed bin static options (constant) init (5);
  2   163   dcl DELETE		fixed bin static options (constant) init (6);
  2   164   dcl NO_LINK		fixed bin static options (constant) init (7);
  2   165   dcl TABLE		fixed bin static options (constant) init (8);
  2   166   dcl NO_TABLE		fixed bin static options (constant) init (9);
  2   167   
  2   168 /****  END OF:	le_input.incl.pl1			 *  *  *  *  *  */
      391 
  3     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  3     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  3     6*     Originally written to define the structures used internally by le_.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9   /*** ****************************************************************/
  3    10   /***							*/
  3    11   /***	Name:	le_data					*/
  3    12   /***	Function:	This include file defines the data structures	*/
  3    13   /***		used internally by the linkage_editor subroutine.	*/
  3    14   /***							*/
  3    15   /*** ****************************************************************/
  3    16   
  3    17   /* error severity constants */
  3    18   
  3    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  3    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  3    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  3    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  3    23   
  3    24   /* section identifier constants */
  3    25   
  3    26   dcl Text		fixed bin (3) static options (constant)
  3    27 			init (0);
  3    28   dcl Linkage		fixed bin (3) static options (constant)
  3    29 			init (1);
  3    30   dcl Symbol		fixed bin (3) static options (constant)
  3    31 			init (2);
  3    32   dcl Definition		fixed bin (3) static options (constant)
  3    33 			init (3);
  3    34   dcl Static		fixed bin (3) static options (constant)
  3    35 			init (4);
  3    36   dcl System		fixed bin (3) static options (constant)
  3    37 			init (5);
  3    38   dcl Heap		fixed bin (3) static options (constant)
  3    39 			init (6);
  3    40   
  3    41   dcl section_nm		(0:6) char (16) static options (constant)
  3    42 			init ("text", "linkage", "symbol", "definition",
  3    43 			"static", "system", "heap");
  3    44   
  3    45   /* link type constants */
  3    46   
  3    47   dcl Self_Base		fixed bin (3) static options (constant)
  3    48 			init (1);
  3    49   dcl Refname_Base		fixed bin (3) static options (constant)
  3    50 			init (3);
  3    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  3    52 			init (4);
  3    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  3    54 			init (5);
  3    55   
  3    56   /* backpatch type constants */
  3    57   
  3    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  3    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  3    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  3    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  3    62   
  3    63   /*** ****************************************************************/
  3    64   /***							*/
  3    65   /***	Name:	le_components				*/
  3    66   /***	Function:	the component table is used to keep information	*/
  3    67   /***		about the input components being used and their	*/
  3    68   /***		disposition in output components.		*/
  3    69   /***							*/
  3    70   /*** ****************************************************************/
  3    71   
  3    72   dcl 01 le_components	aligned based,
  3    73        02 header		aligned,
  3    74         03 flags		aligned,
  3    75          04 separate_static	bit (1) unaligned,
  3    76          04 perprocess_static	bit (1) unaligned,
  3    77          04 mbz		bit (34) unaligned,
  3    78         03 n_components	fixed bin,
  3    79        02 comp		(0 refer (le_components.n_components))
  3    80 			like le_comp;
  3    81   
  3    82   /*** ****************************************************************/
  3    83   /***							*/
  3    84   /***	Name:	le_comp					*/
  3    85   /***	Function:	this is a single component table entry.		*/
  3    86   /***							*/
  3    87   /*** ****************************************************************/
  3    88   
  3    89   dcl 01 le_comp		aligned based,
  3    90        02 segp		ptr,
  3    91        02 bc		fixed bin (24),
  3    92        02 uid		bit (36) aligned,
  3    93        02 dtcm		fixed bin (71),
  3    94        02 name		char (32) varying,
  3    95        02 path		char (194) varying,
  3    96        02 compiler		char (8),
  3    97        02 target		fixed bin,
  3    98        02 flags		aligned,
  3    99         03 library		bit (1) unaligned,
  3   100         03 include		bit (1) unaligned,
  3   101         03 delete_table	bit (1) unaligned,
  3   102         03 separate_static	bit (1) unaligned,
  3   103         03 io_table		bit (1) unaligned,
  3   104         03 unique_path	bit (1) unaligned,
  3   105         03 mbz		bit (30) unaligned,
  3   106        02 tables		aligned,
  3   107         03 lesp		ptr,
  3   108         03 ledp		ptr,
  3   109         03 lelp		ptr,
  3   110        02 orig		aligned,
  3   111         03 textp		ptr,
  3   112         03 defnp		ptr,
  3   113         03 linkp		ptr,
  3   114         03 statp		ptr,
  3   115         03 symbp		ptr,
  3   116         03 rel_textp	ptr,
  3   117         03 rel_symbp	ptr,
  3   118         03 rel_linkp	ptr,
  3   119         03 textl		fixed bin (18) unsigned unaligned,
  3   120         03 defnl		fixed bin (18) unsigned unaligned,
  3   121         03 linkl		fixed bin (18) unsigned unaligned,
  3   122         03 statl		fixed bin (18) unsigned unaligned,
  3   123         03 symbl		fixed bin (18) unsigned unaligned,
  3   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  3   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  3   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  3   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  3   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  3   129         03 next_comp	fixed bin (18) unsigned unaligned,
  3   130        02 new		aligned,
  3   131         03 rel_text		fixed bin (18) unsigned unaligned,
  3   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  3   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  3   134         03 text_pad		fixed bin (18) unsigned unaligned,
  3   135         03 static_pad	fixed bin (18) unsigned unaligned,
  3   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  3   137   
  3   138   /*** ****************************************************************/
  3   139   /***							*/
  3   140   /***	Name:	le_segnames				*/
  3   141   /***	Function:	the segname table is used for two purposes:	*/
  3   142   /***		 - to determine the target components of links	*/
  3   143   /***		   being resolved internally.			*/
  3   144   /***		 - to determine the segname definitions to be	*/
  3   145   /***		   emited for definitions being retained.	*/
  3   146   /***							*/
  3   147   /*** ****************************************************************/
  3   148   
  3   149   dcl 01 le_segnames	aligned based,
  3   150        02 header		aligned,
  3   151         03 n_segnames	fixed bin,
  3   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  3   153         03 str		char (32) varying,
  3   154         03 relp		fixed bin (18) unsigned unaligned,
  3   155         03 pad		bit (18) unaligned;
  3   156   dcl segname_count		fixed bin automatic;
  3   157   
  3   158   /*** ****************************************************************/
  3   159   /***							*/
  3   160   /***	Name:	le_definitions				*/
  3   161   /***	Function:	the definition table contains the definitions	*/
  3   162   /***		from the input components and is used to resolve	*/
  3   163   /***		link targets, and regenerate definition entries	*/
  3   164   /***							*/
  3   165   /*** ****************************************************************/
  3   166   
  3   167   dcl 01 le_definitions	aligned based,
  3   168        02 header		aligned,
  3   169         03 n_defs		fixed bin,
  3   170         03 pad		bit (36),
  3   171        02 def		(def_count refer (le_definitions.n_defs))
  3   172 			like le_definition;
  3   173   dcl def_count		fixed bin automatic;
  3   174   
  3   175   dcl 01 le_definition	aligned based,
  3   176        02 str		char (256) varying,
  3   177        02 type		fixed bin (18) unsigned unaligned,
  3   178        02 relp		fixed bin (18) unsigned unaligned,
  3   179        02 offset		fixed bin (18) unsigned unaligned,
  3   180        02 new_offset	fixed bin (18) unsigned unaligned,
  3   181        02 flags		aligned,
  3   182         03 force_retain	bit (1) unaligned,
  3   183         03 entrypoint	bit (1) unaligned,
  3   184         03 ignore		bit (1) unaligned,
  3   185         03 referenced	bit (1) unaligned,
  3   186         03 no_link		bit (1) unaligned,
  3   187         03 retain		bit (1) unaligned,
  3   188         03 delete		bit (1) unaligned,
  3   189         03 mbz		bit (29) unaligned;
  3   190   
  3   191   /*** ****************************************************************/
  3   192   /***							*/
  3   193   /***	Name:	le_options				*/
  3   194   /***	Function:	the option table contains definition retention	*/
  3   195   /***		information.  The input retentions options are	*/
  3   196   /***		ordered such that a linear search of the option	*/
  3   197   /***		table for the first matching starname will give	*/
  3   198   /***		the correct retention state.			*/
  3   199   /***							*/
  3   200   /*** ****************************************************************/
  3   201   
  3   202   dcl 01 le_options		aligned based,
  3   203        02 header		aligned,
  3   204         03 n_opts		fixed bin,
  3   205        02 opt		(0 refer (le_options.n_opts)),
  3   206         03 type		fixed bin (8) unaligned,
  3   207         03 used		bit (1) unaligned,
  3   208         03 inhibit_error	bit (1) unaligned,
  3   209         03 class		fixed bin (6) unaligned,
  3   210         03 order		fixed bin (17) unaligned,
  3   211         03 segname		char (32) unaligned,
  3   212         03 ep_name		char (256) unaligned;
  3   213   
  3   214   /*** ****************************************************************/
  3   215   /***							*/
  3   216   /***	Name:	le_links					*/
  3   217   /***	Function:	the link table contains information on all of the	*/
  3   218   /***		links in the input components. It is used to	*/
  3   219   /***		determine link targets, which library components	*/
  3   220   /***		will be included, and what init_info will be	*/
  3   221   /***		used, and where it will be placed.		*/
  3   222   /***							*/
  3   223   /*** ****************************************************************/
  3   224   
  3   225   dcl 01 le_links		aligned based,
  3   226        02 header		aligned,
  3   227         03 offset_adjustment	fixed bin (18),
  3   228         03 n_links		fixed bin,
  3   229        02 link		(link_count refer (le_links.n_links))
  3   230 			like le_link;
  3   231   dcl link_count		fixed bin automatic;
  3   232 
  3   233   dcl 01 le_link		aligned based,
  3   234        02 flags		unaligned,
  3   235         03 used		bit (1),
  3   236         03 mbx		bit (35),
  3   237        02 type		fixed bin (6) unsigned unaligned,
  3   238        02 class		fixed bin (6) unsigned unaligned,
  3   239        02 mod		bit (6) unaligned,
  3   240        02 exp		fixed bin (17) unaligned,
  3   241        02 target		fixed bin (18) unsigned unaligned,
  3   242        02 defx		fixed bin (18) unsigned unaligned,
  3   243        02 relp		fixed bin (18) unsigned unaligned,
  3   244        02 target_comp	fixed bin (18) unsigned unaligned,
  3   245        02 target_link	fixed bin (18) unsigned unaligned,
  3   246        02 extension		fixed bin (18) unsigned unaligned,
  3   247        02 initp		ptr unaligned,
  3   248        02 segnamep		ptr unaligned,
  3   249        02 offsetp		ptr unaligned;
  3   250   
  3   251   /*** ****************************************************************/
  3   252   /***							*/
  3   253   /***	Name:	le_binaries				*/
  3   254   /***	Function:	This table contains information about the output	*/
  3   255   /***		binaries.  It is primarily used for creation and	*/
  3   256   /***		backpatching of MSF output.			*/
  3   257   /***							*/
  3   258   /*** ****************************************************************/
  3   259   
  3   260   dcl 01 le_binaries	aligned based,
  3   261        02 header		aligned,
  3   262         03 n_binaries	fixed bin,
  3   263         03 pad		bit (36),
  3   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  3   265         03 segp		ptr,
  3   266         03 bc		fixed bin (24),
  3   267         03 uid		bit (36),
  3   268         03 aclc		fixed bin,
  3   269         03 aclp		ptr,
  3   270         03 textp		ptr,
  3   271         03 defnp		ptr,
  3   272         03 linkp		ptr,
  3   273         03 symbp		ptr,
  3   274         03 statp		ptr,
  3   275         03 textl		fixed bin (18) unsigned unaligned,
  3   276         03 defnl		fixed bin (18) unsigned unaligned,
  3   277         03 linkl		fixed bin (18) unsigned unaligned,
  3   278         03 symbl		fixed bin (18) unsigned unaligned,
  3   279         03 statl		fixed bin (18) unsigned unaligned,
  3   280         03 mbz2		bit (18) unaligned;
  3   281   
  3   282   /*** ****************************************************************/
  3   283   /***							*/
  3   284   /***	Name:	le_patches				*/
  3   285   /***	Function:	This table contains the list of backpatches to be	*/
  3   286   /***		performed when the rest of the object creation is	*/
  3   287   /***		complete. Since le_backpatch_ is the only routine	*/
  3   288   /***		concerned with this,  it is maintained completely	*/
  3   289   /***		internal to le_backpatch_.			*/
  3   290   /***							*/
  3   291   /*** ****************************************************************/
  3   292   
  3   293   dcl 01 le_patches		aligned based,
  3   294        02 header		aligned,
  3   295         03 n_patches	fixed bin,
  3   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  3   297        
  3   298   dcl 01 le_patch		aligned based,
  3   299        02 type		fixed bin,
  3   300        02 comp		fixed bin,
  3   301        02 relp		fixed bin (18) unsigned,
  3   302        02 target		fixed bin,
  3   303        02 index		fixed bin;
  3   304   
  3   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      392 
      393 
      394   end le_;
      395 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1252.2  le_.pl1                           >special_ldd>install>MR12.0-1241>le_.pl1
390          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
391          2    12/10/86  1248.7  le_input.incl.pl1                 >special_ldd>install>MR12.0-1241>le_input.incl.pl1
392          3    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADDNAME                                constant        fixed bin(17,0)          initial dcl 2-160 ref 314
LE_FATAL_ERROR                  000010 constant        fixed bin(17,0)          initial dcl 3-21 set ref 169* 207* 212* 217* 222*
                                                                                  227* 254* 259* 267* 277*
LE_WARNING                      000013 constant        fixed bin(17,0)          initial dcl 3-19 set ref 329*
abort_severity                         parameter       fixed bin(17,0)          dcl 378 in procedure "severity_check" ref 360 380
abort_severity           77            based           fixed bin(17,0)          level 3 in structure "lei" dcl 101 in procedure
                                                                                  "le_" set ref 288* 296* 303* 347
addr                                                   builtin function         dcl 132 ref 188 188 197 201 211 216 216 221 221 226
                                                                                  226 232 237 239 240 240 242 244 247 253 258 266
                                                                                  276 294 301 301 309 309 337 337
ai                              000100 automatic       structure                level 1 dcl 113 set ref 179* 188 188
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 1-3 ref 181
areap                    16     000100 automatic       pointer                  level 2 dcl 113 set ref 186* 189
bits                            000124 automatic       bit(36)                  dcl 114 set ref 266* 276*
c                               000125 automatic       fixed bin(17,0)          dcl 115 set ref 239* 240 240 242* 300* 301*
char                                                   builtin function         dcl 133 ref 275
cleanup                         000232 stack reference condition                dcl 127 ref 156
code                                   parameter       fixed bin(35,0)          dcl 45 set ref 15 171* 347* 349*
comp                      2            based           structure                array level 2 dcl 98
component_size           75            based           fixed bin(17,0)          level 3 dcl 101 set ref 253*
control                   1     000100 automatic       structure                level 2 dcl 113
debug                    12(02)        based           bit(1)                   level 4 packed unaligned dcl 101 ref 148
define_area_                    000010 constant        entry                    external dcl 49 ref 188
dir                      13            based           char(168)                level 4 packed unaligned dcl 101 set ref 294* 316*
                                                                                  320* 323* 325* 337*
display_severity         76            based           fixed bin(17,0)          level 3 dcl 101 ref 147
dname                           000127 automatic       char(168)                unaligned dcl 117 set ref 294* 301*
done                            000126 automatic       bit(1)                   unaligned dcl 116 set ref 236* 239 245*
ec                              000201 automatic       fixed bin(35,0)          dcl 118 set ref 188* 193* 266* 267 276* 277 316* 318
                                                                                  320* 323* 325 325* 329 329* 341*
ename                           000202 automatic       char(32)                 unaligned dcl 119 set ref 275* 276* 277* 294* 301*
entry                    65            based           char(32)                 level 4 packed unaligned dcl 101 set ref 266* 267*
                                                                                  275 294* 316* 325* 337*
error_table_$dup_ent_name       000060 external static fixed bin(35,0)          dcl 78 set ref 267* 277*
error_table_$namedup            000062 external static fixed bin(35,0)          dcl 80 ref 318
error_table_$noentry            000064 external static fixed bin(35,0)          dcl 81 ref 267 277
error_table_$segnamedup         000066 external static fixed bin(35,0)          dcl 82 ref 329
error_table_$translation_failed 000070 external static fixed bin(35,0)          dcl 83 ref 171 347
extend                    1     000100 automatic       bit(1)                   level 3 packed unaligned dcl 113 set ref 182*
false                                  constant        bit(1)                   initial unaligned dcl 39 ref 162 236 237 244 351
flags                    12            based           structure                level 3 in structure "lei" dcl 101 in procedure
                                                                                  "le_"
flags                   106            based           structure                array level 3 in structure "lec" dcl 98 in procedure
                                                                                  "le_"
flags                                  based           structure                level 3 in structure "lec" dcl 98 in procedure "le_"
force                    12(01)        based           bit(1)                   level 4 packed unaligned dcl 101 set ref 294* 320
get_temp_segments_              000012 constant        entry                    external dcl 50 ref 193
hash_$search                    000014 constant        entry                    external dcl 51 ref 266 276
hcs_$chname_file                000016 constant        entry                    external dcl 53 ref 316 325
header                                 based           structure                level 2 in structure "le_components" dcl 3-72
                                                                                  in procedure "le_"
header                                 based           structure                level 2 in structure "lei" dcl 101 in procedure
                                                                                  "le_"
header                                 based           structure                level 2 in structure "lec" dcl 98 in procedure "le_"
header                                 based           structure                level 2 in structure "le_input" dcl 2-114
                                                                                  in procedure "le_"
i                               000212 automatic       fixed bin(17,0)          dcl 120 set ref 274* 275* 313* 314 316 320 323 325
                                                                                  329*
include                 106(01)        based           bit(1)                   array level 4 packed unaligned dcl 98 ref 240
le_abort_                       000240 stack reference condition                dcl 128 ref 154
le_apply_def_options_           000020 constant        entry                    external dcl 55 ref 221
le_combine_init_info_           000022 constant        entry                    external dcl 56 ref 258
le_comp                                based           structure                level 1 dcl 3-89
le_complete_binary_             000024 constant        entry                    external dcl 57 ref 309
le_components                          based           structure                level 1 dcl 3-72
le_create_binary_               000026 constant        entry                    external dcl 58 ref 294
le_create_list_                 000030 constant        entry                    external dcl 60 ref 337
le_data_$caller                 000072 external static varying char(32)         dcl 85 set ref 149* 158 184 193 341
le_data_$debug                  000074 external static bit(1)                   unaligned dcl 86 set ref 148*
le_data_$display_severity       000076 external static fixed bin(17,0)          dcl 87 set ref 147*
le_data_$max_severity           000100 external static fixed bin(17,0)          dcl 89 set ref 146* 170 346 380
le_data_$patch_ptr              000102 external static pointer                  dcl 90 set ref 197*
le_data_$running                000104 external static bit(1)                   unaligned dcl 91 set ref 162* 167 175* 351*
le_definition                          based           structure                level 1 dcl 3-175
le_error_                       000032 constant        entry                    external dcl 61 ref 169 267 277 329
le_et_$recursive_invocation     000106 external static fixed bin(35,0)          dcl 92 set ref 169*
le_input                               based           structure                level 1 dcl 2-114
le_link                                based           structure                level 1 dcl 3-233
le_make_comp_tbl_               000034 constant        entry                    external dcl 62 ref 211
le_make_component_              000036 constant        entry                    external dcl 63 ref 301
le_make_link_tbl_               000040 constant        entry                    external dcl 65 ref 226
le_make_opt_tbl_                000042 constant        entry                    external dcl 66 ref 201
le_make_segname_tbl_            000044 constant        entry                    external dcl 67 ref 216
le_msf_partition_               000046 constant        entry                    external dcl 68 ref 253
le_option                              based           structure                level 1 dcl 2-140
le_patch                               based           structure                level 1 dcl 3-298
leap                            000214 automatic       pointer                  dcl 121 set ref 152* 160 160* 189* 216* 226* 344
                                                                                  344*
lebp                      6            based           pointer                  level 2 dcl 104 set ref 301* 309* 337*
lec                                    based           structure                level 1 dcl 98
lecp                                   based           pointer                  level 2 dcl 104 set ref 211* 216* 221* 226* 232 237
                                                                                  239 240 240 242 244 247 253* 258* 294* 301* 309*
                                                                                  337*
lei                                    based           structure                level 1 dcl 101
leip                                   parameter       pointer                  dcl 43 set ref 15 147 148 149 201* 211* 216* 232 253
                                                                                  266 267 275 288 294 294 294 296 301* 303 313 314
                                                                                  316 316 316 320 320 320 320 323 323 323 325 325
                                                                                  325 329 337 337 337 337 337 347
leop                      2            based           pointer                  level 2 dcl 104 set ref 201* 221*
lepp                     10            based           pointer                  level 2 dcl 104 ref 197
leshp                     4            based           pointer                  level 2 dcl 104 set ref 216* 226* 266* 276*
list                     12(03)        based           bit(1)                   level 4 packed unaligned dcl 101 set ref 337 337*
ltrim                                                  builtin function         dcl 134 ref 275
map                      12(04)        based           bit(1)                   level 4 packed unaligned dcl 101 ref 337
n_components              1            based           fixed bin(17,0)          level 3 in structure "lec" dcl 98 in procedure "le_"
                                                                                  ref 239
n_components                    000216 automatic       fixed bin(17,0)          dcl 122 in procedure "le_" set ref 253* 264 274 294*
                                                                                  300 301*
n_opts                  115            based           fixed bin(17,0)          level 3 dcl 101 ref 313
name                      2            based           char(32)                 level 3 in structure "lei" dcl 101 in procedure
                                                                                  "le_" ref 149 320 323
name                    116            based           char(32)                 array level 3 in structure "lei" packed unaligned
                                                                                  dcl 101 in procedure "le_" set ref 316* 320* 323*
                                                                                  325* 329*
nd_handler_                     000050 constant        entry                    external dcl 69 ref 323
nd_handler_$force               000052 constant        entry                    external dcl 71 ref 320
no_freeing                1(04) 000100 automatic       bit(1)                   level 3 packed unaligned dcl 113 set ref 183*
null                                                   builtin function         dcl 135 ref 151 152 158 160 186 341 344
opt                     116            based           structure                array level 2 dcl 101
orig                    116            based           structure                array level 3 dcl 98
output_file              13            based           structure                level 3 packed unaligned dcl 101
owner                     2     000100 automatic       char(32)                 level 2 packed unaligned dcl 113 set ref 184*
perprocess_static        12            based           bit(1)                   level 4 in structure "lei" packed unaligned dcl 101
                                                                                  in procedure "le_" ref 232
perprocess_static         0(01)        based           bit(1)                   level 4 in structure "lec" packed unaligned dcl 98
                                                                                  in procedure "le_" set ref 232*
release_area_                   000054 constant        entry                    external dcl 73 ref 160 344
release_temp_segments_          000056 constant        entry                    external dcl 74 ref 158 341
rtrim                                                  builtin function         dcl 136 ref 149 275 275
separate_static         106(03)        based           bit(1)                   array level 4 in structure "lec" packed unaligned
                                                                                  dcl 98 in procedure "le_" ref 242
separate_static                        based           bit(1)                   level 4 in structure "lec" packed unaligned dcl 98
                                                                                  in procedure "le_" set ref 237* 244* 247*
severity                               parameter       fixed bin(17,0)          dcl 44 set ref 15 170* 346* 347
size                     13     000100 automatic       fixed bin(18,0)          level 2 dcl 113 set ref 185*
statl                   137(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 98 ref
                                                                                  240
sys_info$max_seg_size           000110 external static fixed bin(35,0)          dcl 94 ref 185
temp_segs                       000220 automatic       pointer                  array dcl 123 set ref 151* 158 158* 193* 197 201 211
                                                                                  216 216 221 221 226 226 232 237 239 240 240 242
                                                                                  244 247 253 258 266 276 294 301 301 309 309 337
                                                                                  337 341 341*
true                                   constant        bit(1)                   initial unaligned dcl 38 ref 175 182 183 245 247
ts                                     based           structure                level 1 dcl 104
type                    206(27)        based           fixed bin(8,0)           array level 3 packed unaligned dcl 101 ref 314
unspec                                                 builtin function         dcl 137 set ref 179*
version                         000100 automatic       fixed bin(17,0)          level 2 dcl 113 set ref 181*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DELETE                                 internal static fixed bin(17,0)          initial dcl 2-163
Definition                             internal static fixed bin(3,0)           initial dcl 3-32
Heap                                   internal static fixed bin(3,0)           initial dcl 3-38
LE_ABORT_ERROR                         internal static fixed bin(17,0)          initial dcl 3-22
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 3-20
LIBRARY                                internal static fixed bin(17,0)          initial dcl 2-159
Linkage                                internal static fixed bin(3,0)           initial dcl 3-28
NO_LINK                                internal static fixed bin(17,0)          initial dcl 2-164
NO_TABLE                               internal static fixed bin(17,0)          initial dcl 2-166
PATH                                   internal static fixed bin(17,0)          initial dcl 2-158
Patch_Init                             internal static fixed bin(17,0)          initial dcl 3-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 3-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 3-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 3-60
RETAIN                                 internal static fixed bin(17,0)          initial dcl 2-162
Refname_Base                           internal static fixed bin(3,0)           initial dcl 3-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 3-51
SYNONYM                                internal static fixed bin(17,0)          initial dcl 2-161
Self_Base                              internal static fixed bin(3,0)           initial dcl 3-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 3-53
Static                                 internal static fixed bin(3,0)           initial dcl 3-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 3-30
System                                 internal static fixed bin(3,0)           initial dcl 3-36
TABLE                                  internal static fixed bin(17,0)          initial dcl 2-165
Text                                   internal static fixed bin(3,0)           initial dcl 3-26
area_infop                             automatic       pointer                  dcl 1-5
def_count                              automatic       fixed bin(17,0)          dcl 3-173
le_binaries                            based           structure                level 1 dcl 3-260
le_definitions                         based           structure                level 1 dcl 3-167
le_input_version_1                     internal static char(8)                  initial unaligned dcl 2-153
le_links                               based           structure                level 1 dcl 3-225
le_options                             based           structure                level 1 dcl 3-202
le_patches                             based           structure                level 1 dcl 3-293
le_segnames                            based           structure                level 1 dcl 3-149
link_count                             automatic       fixed bin(17,0)          dcl 3-231
section_nm                             internal static char(16)                 initial array unaligned dcl 3-41
segname_count                          automatic       fixed bin(17,0)          dcl 3-156

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT                           001561 constant        label                    dcl 341 ref 154 380
le_                             000063 constant        entry                    external dcl 15
severity_check                  001651 constant        entry                    internal dcl 360 ref 207 212 217 222 227 254 259 288
                                                                                  296 303

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2316        2430    1670        2326
Length      2750    1670       112         303     426           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_                                 262 external procedure  is an external procedure.  
on unit on line 154                  64 on unit               
on unit on line 156                  82 on unit               
severity_check                          internal procedure  shares stack frame of external procedure le_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_                      000100 ai                          le_
                         000124 bits                        le_
                         000125 c                           le_
                         000126 done                        le_
                         000127 dname                       le_
                         000201 ec                          le_
                         000202 ename                       le_
                         000212 i                           le_
                         000214 leap                        le_
                         000216 n_components                le_
                         000220 temp_segs                   le_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           enable_op
shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  get_temp_segments_            hash_$search                  hcs_$chname_file
le_apply_def_options_         le_combine_init_info_         le_complete_binary_           le_create_binary_
le_create_list_               le_error_                     le_make_comp_tbl_             le_make_component_
le_make_link_tbl_             le_make_opt_tbl_              le_make_segname_tbl_          le_msf_partition_
nd_handler_                   nd_handler_$force             release_area_                 release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dup_ent_name     error_table_$namedup          error_table_$noentry          error_table_$segnamedup
error_table_$translation_failed                             le_data_$caller               le_data_$debug
le_data_$display_severity     le_data_$max_severity         le_data_$patch_ptr            le_data_$running
le_et_$recursive_invocation   sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000057       146 000070       147 000071       148 000076       149 000102       151 000123       152 000125
    154 000126       156 000145       158 000161       160 000220       162 000235       163 000237       167 000240
    169 000243       170 000263       171 000267       172 000271       175 000272       179 000274       181 000277
    182 000301       183 000303       184 000305       185 000312       186 000314       188 000316       189 000330
    193 000332       197 000364       201 000370       207 000401       211 000403       212 000415       216 000417
    217 000435       221 000437       222 000450       226 000452       227 000465       232 000467       236 000477
    237 000500       239 000502       240 000515       242 000526       244 000532       245 000534       246 000536
    247 000537       249 000541       253 000543       254 000561       258 000563       259 000572       264 000574
    266 000577       267 000627       272 000665       274 000666       275 000675       276 000767       277 001015
    282 001050       288 001052       294 001063       296 001127       300 001140       301 001147       303 001206
    304 001217       309 001221       313 001232       314 001245       316 001257       318 001313       320 001317
    323 001361       325 001414       328 001456       329 001457       333 001517       337 001521       341 001561
    344 001617       346 001633       347 001637       349 001646       351 001647       353 001650       360 001651
    380 001653       383 001657


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
