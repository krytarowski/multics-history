	COMPILATION LISTING OF SEGMENT bj_storage_get_header
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  1001.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:    
        8*
        9*
       10* ==> bj_storage_get_header (bj_oid, rec_id, header_ptr)
       11*
       12*       Copies into the user's space pointed to by header_ptr (input), the header
       13*       of the record specfied by its rec_id (input), in the journal specified
       14*       by its opening id bj_oid (input).
       15*
       16*
       17* ==> bj_storage_get_header$previous (bj_oid, rec_id, header_ptr)
       18*
       19*       Copies, into the user's space pointed to by header_ptr, the header 
       20*       of the record previous to the record specified by its rec_id (input),
       21*       in the journal specified by its opening id bj_oid (input). It also
       22*       returns the rec_id of previous record in rec_id (input and output).
       23*       If the rec_id passed by the caller has no previous record, this
       24*       procedure sets rec_id to "0"b and does not modify the user's space
       25*       pointed to by header_ptr.
       26*
       27*
       28*
       29* ==> bj_storage_get_header$last (bj_oid, rec_id, header_ptr)
       30*
       31*       Copies, into the user's space pointed to by header_ptr (input), the 
       32*       header of the last record of the journal specified by its opening id
       33*       bj_oid (input), and returns the rec_id of that record in rec_id (output).
       34*       If there is no last record, ie, the journal is empty, it returns a
       35*       null rec_id (rec_id = "0"b) and leaves the user's space pointed to by
       36*       header_ptr unchanged.
       37*
       38*
       39*
       40* ==> bj_storage_get_header$find_last_record (pf_oid, bj_pste_ptr, header_ptr)    returns rec_id.
       41*
       42*
       43*       This procedure is called only by bj_pste_create, while opening
       44*       a journal after a system crash. It does not assume that the process
       45*       has a valid bj_oid for this journal, since the journal is being opened.
       46*
       47*       It assumes however that the bj_pste is completely initialized, with
       48*       the exception of bj_pste.last_rec_id. (In fact bj_pste.n_txn is not
       49*       initialized either at this point, but this is irrelevant for this
       50*       procedure.
       51*
       52*       At this point, the last CI of the journal has already be found, and
       53*       its ci number has been entered in bj_pste.last_ci_buffered, put, flushed
       54*       and on_disk. Where the origin of the circular list was at the time of
       55*       the crash is not known, and it is not neceassry to know it. The origin
       56*       has been temporarly set to be as far as possible from the last CI, so that
       57*       any attempt to append a record to the journal would cause a "journal_full"
       58*       error. Later in the recovery after crash program, the journal will be
       59*       examined to find all the unfinished transactions that were using this
       60*       journal at the time of the crash. At that point, the bj_pste.n_txn 
       61*       will be initialized, and the origin of the circular list will be set
       62*       to the least recently written CI by any of the unfinished transactions.
       63*
       64*       In order to do its job, this program starts with the last element of
       65*       the last CI. If it is a full record, it is the last record of the
       66*       journal. Otherwise, the previous elements have to be examined until
       67*       a record is found. Most of the logic needed by this program already
       68*       exist in bj_storage_get_header$previous; that is why find_last_record
       69*       has been packaged in this segment. 
       70*
       71*
       72**/
       73 
       74 /* HISTORY:
       75*
       76*Written by A. Bensoussan, 12/06/82.
       77*Modified:
       78*02/23/83 by A. Bensoussan:  to lock/unlock using bj_pste_lock$lock/unlock.
       79*12/06/84 by M. Sharpe:  to set/reset validation level around the call to
       80*	  file_manager_, to use ERROR_RETURN.
       81*12/06/84 by Matthew Pierret:  Changed to set current_ring in each entry
       82*            instead of just the first.  current_ring is used to set the
       83*            validation level.
       84*01/17/85 by Matthew Pierret:  Changed to recognize FM_ROLLBACK_HANDLER and
       85*            FM_POSTCOMMIT_HANDLER records.
       86*01/23/85 by Lee A. Newcomb:  Fixed to recognize BEGIN_COMMIT records.
       87**/
       88 /* format: style4,^indcomtxt,indattr,^inddcls,idind40 */
       89 
       90 bj_storage_get_header: proc (p_bj_oid, p_rec_id, p_header_ptr);
       91 
       92 /* Parameters */
       93 
       94 dcl  p_bj_oid			     bit (36) aligned; /* opening id.  Input */
       95 dcl  p_rec_id			     bit (36) aligned; /* rec_id of curr/last/prev. Input + Output */
       96 dcl  p_header_ptr			     ptr;		/* ptr to record header.  Input */
       97 dcl  p_pf_oid			     bit (36) aligned; /* page file oid . Input */
       98 dcl  p_bj_pste_ptr			     ptr;		/* pste ptr. Input */
       99 
      100 
      101 /* Automatic */
      102 
      103 
      104 dcl  code				     fixed bin (35);
      105 dcl  rel_distance			     fixed bin (35);
      106 
      107 dcl  ci_no			     fixed bin (24) uns;
      108 dcl  sl_no			     fixed bin (12) uns;
      109 
      110 dcl  pf_oid			     bit (36) aligned;
      111 dcl  rec_id			     bit (36) aligned;
      112 dcl  expected_rec_id		     bit (36) aligned;
      113 dcl  element_id			     bit (36) aligned;
      114 dcl  record_id			     bit (36) aligned;
      115 
      116 dcl  element_type			     char (8) aligned;
      117 dcl  entry_point			     char (8) aligned;
      118 
      119 dcl  LOCAL_CI			     dim (512) fixed bin (71);
      120 
      121 dcl  saved_level			     fixed bin init (-1);
      122 dcl  current_ring			     fixed bin (3) init (-1);
      123 
      124 
      125 /* Based */
      126 
      127 dcl  1 str_rec_id			     based aligned,
      128        2 ci_no			     fixed bin (24) uns unal,
      129        2 sl_no			     fixed bin (12) uns unal;
      130 
      131 dcl  ci_bytes			     char (bj_pste.ci_size) aligned based (addr (LOCAL_CI));
      132 
      133 
      134 /* Builtin */
      135 
      136 dcl  (addr, null, ptr, size, substr)	     builtin;
      137 
      138 
      139 /* Condition */
      140 
      141 dcl  cleanup			     condition;
      142 
      143 
      144 /* Constant */
      145 
      146 dcl  ME				     char (21) int static
      147 				     options (constant) init ("bj_storage_get_header");
      148 
      149 
      150 /* Entries */
      151 
      152 dcl  bj_oid_util$get_ptr		     entry (bit (36) aligned) returns (ptr);
      153 dcl  bj_pste_lock$lock		     entry (ptr, bit (36) aligned);
      154 dcl  bj_pste_lock$lock_partial_check	     entry (ptr);
      155 dcl  bj_pste_lock$unlock		     entry (ptr);
      156 dcl  bj_report_err			     entry (fixed bin (35), char (*));
      157 dcl  bj_storage_util$distance		     entry (ptr, fixed bin (24) uns) returns (fixed bin (24) uns);
      158 dcl  cu_$level_get			     entry (fixed bin);
      159 dcl  cu_$level_set			     entry (fixed bin);
      160 dcl  file_manager_$get		     entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35));
      161 dcl  get_ring_			     entry () returns (fixed bin (3));
      162 
      163 
      164 /* External */
      165 
      166 dcl  dm_error_$bj_inconsistent_ci	     fixed bin (35) ext;
      167 dcl  dm_error_$bj_bad_ci_no		     fixed bin (35) ext;
      168 dcl  dm_error_$bj_bad_slot_no		     fixed bin (35) ext;
      169 dcl  dm_error_$bj_bad_rec_id		     fixed bin (35) ext;
      170 dcl  dm_error_$bj_unknown_record_type	     fixed bin (35) ext;
      171 dcl  dm_error_$bj_logic_err		     fixed bin (35) ext;
      172 
      173 
      174 	entry_point = "";
      175 
      176 	bj_ppte_ptr = bj_oid_util$get_ptr (p_bj_oid);	/* USED GLOBALLY */
      177 	bj_pste_ptr = bj_ppte.bj_pste_ptr;		/* USED GLOBALLY */
      178 	pf_oid = bj_ppte.pf_oid;			/* USED GLOBALLY */
      179 	bj_ci_ptr = addr (LOCAL_CI);			/* USED GLOBALLY */
      180 
      181 
      182 	call bj_pste_lock$lock (bj_pste_ptr, bj_ppte.bj_uid);
      183 
      184 
      185 	rec_id = p_rec_id;
      186 
      187 	ci_no = addr (rec_id) -> str_rec_id.ci_no;
      188 	sl_no = addr (rec_id) -> str_rec_id.sl_no;
      189 
      190 	call cu_$level_get (saved_level);
      191 	current_ring = get_ring_ ();
      192 
      193 	on cleanup call cu_$level_set (saved_level);
      194 
      195 	call COPY_CI_LOCALLY (ci_no);			/* Copies the CI from the file 
      196*							   or the buffer into LOCAL_CI */
      197 
      198 	element_type = ELEMENT_TYPE (sl_no);		/* Operates on LOCAL_CI; returns 
      199*							   "full","head", "tail" or "middle" */
      200 	if element_type = "tail" | element_type = "middle"
      201 	then call ERROR_RETURN (dm_error_$bj_bad_rec_id);
      202 
      203 
      204 	call GET_RECORD_HEADER (p_rec_id, p_header_ptr);	/* Operates on LOCAL_CI */
      205 						/* Record header is never split */
      206 
      207 
      208 
      209 	call bj_pste_lock$unlock (bj_pste_ptr);
      210 
      211 	return;
      212 
      213 previous: entry (p_bj_oid, p_rec_id, p_header_ptr);
      214 
      215 
      216 	entry_point = "previous";
      217 
      218 	bj_ppte_ptr = bj_oid_util$get_ptr (p_bj_oid);	/* USED GLOBALLY */
      219 	bj_pste_ptr = bj_ppte.bj_pste_ptr;		/* USED GLOBALLY */
      220 	pf_oid = bj_ppte.pf_oid;			/* USED GLOBALLY */
      221 	bj_ci_ptr = addr (LOCAL_CI);			/* USED GLOBALLY */
      222 
      223 	call bj_pste_lock$lock (bj_pste_ptr, bj_ppte.bj_uid);
      224 
      225 
      226 	rec_id = p_rec_id;
      227 
      228 	ci_no = addr (rec_id) -> str_rec_id.ci_no;
      229 	sl_no = addr (rec_id) -> str_rec_id.sl_no;
      230 
      231 	call cu_$level_get (saved_level);
      232 	current_ring = get_ring_ ();
      233 	on cleanup call cu_$level_set (saved_level);
      234 
      235 	call COPY_CI_LOCALLY (ci_no);			/* Copies the CI from the file 
      236*							   or the buffer into LOCAL_CI */
      237 
      238 	element_type = ELEMENT_TYPE (sl_no);		/* Operates on LOCAL_CI; returns 
      239*							   "full","head", "tail" or "middle" */
      240 	if element_type = "tail" | element_type = "middle"
      241 	then call ERROR_RETURN (dm_error_$bj_bad_rec_id);
      242 
      243 	element_id = rec_id;
      244 	record_id = "0"b;
      245 	expected_rec_id = "0"b;
      246 
      247 	do while (record_id = "0"b & element_id ^= "0"b);
      248 
      249 	     element_id = PREVIOUS_ELEMENT_ID (element_id); /* Gets previous ci in LOCAL_CI if necessary.
      250*							   Returns "0"b if there is no previous. */
      251 	     if element_id ^= "0"b then
      252 		record_id = RECORD_ID (element_id, expected_rec_id); /* Returns "0"b if element_id is not a record_id. */
      253 	end;
      254 
      255 
      256 	if record_id ^= "0"b then
      257 	     call GET_RECORD_HEADER (record_id, p_header_ptr); /* Operates on LOCAL_CI */
      258 						/* Record header is never split */
      259 
      260 	p_rec_id = record_id;
      261 
      262 
      263 	call bj_pste_lock$unlock (bj_pste_ptr);
      264 
      265 	return;
      266 
      267 
      268 
      269 last: entry (p_bj_oid, p_rec_id, p_header_ptr);
      270 
      271 
      272 	entry_point = "last";
      273 
      274 	bj_ppte_ptr = bj_oid_util$get_ptr (p_bj_oid);	/* USED GLOBALLY */
      275 	bj_pste_ptr = bj_ppte.bj_pste_ptr;		/* USED GLOBALLY */
      276 	pf_oid = bj_ppte.pf_oid;			/* USED GLOBALLY */
      277 	bj_ci_ptr = addr (LOCAL_CI);			/* USED GLOBALLY */
      278 
      279 
      280 
      281 	call bj_pste_lock$lock (bj_pste_ptr, bj_ppte.bj_uid);
      282 
      283 
      284 	ci_no = bj_pste.last_ci_buffered;
      285 
      286 	call cu_$level_get (saved_level);
      287 	current_ring = get_ring_ ();
      288 	on cleanup call cu_$level_set (saved_level);
      289 
      290 	call COPY_CI_LOCALLY (ci_no);
      291 
      292 	if bj_ci.header2.n_slots = 0 then
      293 	     do;
      294 	     ci_no = bj_pste.last_ci_put;
      295 	     call COPY_CI_LOCALLY (ci_no);
      296 	end;
      297 
      298 	sl_no = bj_ci.header2.n_slots;
      299 
      300 	addr (rec_id) -> str_rec_id.ci_no = ci_no;
      301 	addr (rec_id) -> str_rec_id.sl_no = sl_no;
      302 
      303 
      304 
      305 	element_id = rec_id;
      306 	record_id = "0"b;
      307 	expected_rec_id = "0"b;
      308 
      309 	do while (record_id = "0"b & element_id ^= "0"b);
      310 
      311 	     record_id = RECORD_ID (element_id, expected_rec_id); /* Returns "0"b if element_id is not a record_id */
      312 
      313 	     if record_id = "0"b then
      314 		element_id = PREVIOUS_ELEMENT_ID (element_id); /* Returns "0"b if there is no previous element */
      315 	end;
      316 
      317 	if record_id ^= "0"b then
      318 	     call GET_RECORD_HEADER (record_id, p_header_ptr); /* Operates on LOCAL_CI */
      319 						/* Assumes record is never split */
      320 	p_rec_id = record_id;
      321 
      322 
      323 	call bj_pste_lock$unlock (bj_pste_ptr);
      324 
      325 
      326 	return;
      327 
      328 
      329 find_last_record: entry (p_pf_oid, p_bj_pste_ptr, p_header_ptr) returns (bit (36) aligned);
      330 
      331 
      332 	entry_point = "findlast";
      333 	bj_pste_ptr = p_bj_pste_ptr;
      334 	pf_oid = p_pf_oid;
      335 	bj_ci_ptr = addr (LOCAL_CI);
      336 
      337 
      338 	call bj_pste_lock$lock_partial_check (bj_pste_ptr);
      339 
      340 	ci_no = bj_pste.last_ci_buffered;
      341 
      342 	call cu_$level_get (saved_level);
      343 	current_ring = get_ring_ ();
      344 	on cleanup call cu_$level_set (saved_level);
      345 
      346 	call COPY_CI_LOCALLY (ci_no);
      347 
      348 	if bj_ci.n_slots = 0 then
      349 	     do;
      350 	     ci_no = bj_pste.last_ci_put;
      351 	     call COPY_CI_LOCALLY (ci_no);
      352 	end;
      353 
      354 	sl_no = bj_ci.n_slots;
      355 
      356 	addr (rec_id) -> str_rec_id.ci_no = ci_no;
      357 	addr (rec_id) -> str_rec_id.sl_no = sl_no;
      358 
      359 
      360 
      361 	element_id = rec_id;
      362 	record_id = "0"b;
      363 	expected_rec_id = "0"b;
      364 
      365 	do while (record_id = "0"b & element_id ^= "0"b);
      366 
      367 	     record_id = RECORD_ID (element_id, expected_rec_id); /* Returns "0"b if element_id is not a record_id*/
      368 
      369 	     if record_id = "0"b then
      370 		element_id = PREVIOUS_ELEMENT_ID (element_id); /* Returns "0"b if no more previous element.*/
      371 						/* Gets previous CI in LOCAL_CI if necessary. */
      372 	end;
      373 
      374 	if record_id ^= "0"b then
      375 	     call GET_RECORD_HEADER (record_id, p_header_ptr); /* Operates on LOCAL_CI. */
      376 						/* Assumes header never split */
      377 
      378 	call bj_pste_lock$unlock (bj_pste_ptr);
      379 
      380 MAIN_RETURN:
      381 	return (record_id);
      382 
      383 
      384 ERROR_RETURN:
      385      proc (er_code);
      386 
      387 dcl  er_code			     fixed bin (35);
      388 
      389 	call bj_report_err (er_code, ME || "$" || entry_point);
      390 						/* does not return */
      391      end ERROR_RETURN;
      392 
      393 
      394 COPY_CI_LOCALLY: proc (ci);
      395 
      396 /* Copies the specified control interval into LOCAL_CI. 
      397*	If the ci has already been put in the file, it reads it from the file. 
      398*	If the ci is still in the buffer, it reads it from the buffer.
      399*	It checks the consistency of the slot table. */
      400 
      401 /* This function should be available in bj_storage_util. It could
      402*	be used by bj_storage_get, which has almost duplicate code */
      403 
      404 
      405 dcl  ci				     fixed bin (24) uns parameter;
      406 
      407 dcl  p				     ptr;
      408 dcl  q				     ptr;
      409 
      410 
      411 
      412 	rel_distance = bj_storage_util$distance (bj_pste_ptr, bj_pste.last_ci_put)
      413 	     - bj_storage_util$distance (bj_pste_ptr, ci);
      414 
      415 	if rel_distance >= 0
      416 
      417 	then do;
      418 	     call cu_$level_set ((current_ring));
      419 	     call GET_CI (ci);			/* Normal case: get ci from file */
      420 	     call cu_$level_set (saved_level);
      421 	end;
      422 
      423 	else if rel_distance = -1
      424 
      425 	then if ci = bj_pste.last_ci_buffered
      426 	     then do;				/* Special case: get ci from buffer */
      427 		p = addr (LOCAL_CI);
      428 		q = ptr (bj_pste_ptr, bj_pste.buffer_offset);
      429 		p -> ci_bytes = q -> ci_bytes;
      430 	     end;
      431 
      432 	     else call ERROR_RETURN (dm_error_$bj_logic_err);
      433 
      434 	else call ERROR_RETURN (dm_error_$bj_bad_rec_id);
      435 
      436 
      437 	if bj_ci.n_slots > 64 | bj_ci.n_slots < 0
      438 	then call ERROR_RETURN (dm_error_$bj_inconsistent_ci);
      439 
      440 	if bj_ci.n_slots > 0 then
      441 	     if (bj_ci.header2.first_is_contn
      442 		& bj_ci.header2.first_rec_id = "0"b)
      443 	     then call ERROR_RETURN (dm_error_$bj_inconsistent_ci);
      444 
      445 	return;
      446 
      447      end COPY_CI_LOCALLY;
      448 
      449 
      450 GET_CI: proc (ci);					/* Could also be part of bj_storage_util */
      451 
      452 
      453 dcl  ci				     fixed bin (24) uns;
      454 
      455 dcl  my_ci_parts			     (5) fixed bin (71);
      456 
      457 
      458 
      459 	if ci = 0
      460 	     | ci < bj_pste.cl.lowest_ci
      461 	     | ci > bj_pste.cl.highest_ci
      462 	then call ERROR_RETURN (dm_error_$bj_bad_ci_no);
      463 
      464 
      465 	ci_parts_ptr = addr (my_ci_parts);
      466 
      467 	ci_parts.number_of_parts = 1;
      468 
      469 	ci_parts.part (1).offset_in_bytes = 0;		/* Relative to header2 */
      470 	ci_parts.part (1).length_in_bytes = bj_pste.ci_size - (size (ci_header) + size (ci_trailer)) * 4;
      471 	ci_parts.part (1).local_ptr = addr (bj_ci.header2);
      472 
      473 	call file_manager_$get (pf_oid, ci, ci_parts_ptr, code);
      474 	if code ^= 0 then call ERROR_RETURN (code);
      475 
      476 
      477 	return;
      478      end GET_CI;
      479 
      480 
      481 
      482 ELEMENT_TYPE: proc (sl) returns (char (8) aligned);
      483 
      484 /* Operate on LOCAL_CI pointed to by bj_ci_ptr. Determines if
      485*	the element specified by its slot number sl is a "full" record,
      486*	or only the "head", the "middle" or the "tail" part of a record.
      487*	Returns the corresponding character string of the type found.
      488*	Also validates the slot no and does some consistency checks. */
      489 
      490 
      491 dcl  sl				     fixed bin (12) uns;
      492 
      493 
      494 	if sl = 0 | sl > bj_ci.n_slots
      495 	then call ERROR_RETURN (dm_error_$bj_bad_slot_no);
      496 
      497 
      498 	if bj_ci.header2.first_is_contn
      499 	     & bj_ci.header2.last_is_contd
      500 	then do;
      501 	     if sl = 1 & bj_ci.n_slots = 1 then return ("middle");
      502 	end;
      503 
      504 
      505 	if bj_ci.header2.first_is_contn
      506 	     & sl = 1 then return ("tail");
      507 
      508 
      509 	if bj_ci.header2.last_is_contd
      510 	     & sl = bj_ci.header2.n_slots then return ("head");
      511 
      512 
      513 	else return ("full");
      514 
      515      end ELEMENT_TYPE;
      516 
      517 RECORD_ID: proc (element_id, expected_rec_id) returns (bit (36) aligned);
      518 
      519 
      520 dcl  element_id			     bit (36) aligned; /* Input param */
      521 dcl  expected_rec_id		     bit (36) aligned; /* Input + Output param */
      522 
      523 dcl  sl				     fixed bin (12) uns;
      524 
      525 
      526 
      527 	sl = addr (element_id) -> str_rec_id.sl_no;
      528 
      529 	element_type = ELEMENT_TYPE (sl);
      530 
      531 	if element_type = "full" then return (element_id);
      532 
      533 	if element_type = "head"
      534 	     & element_id = expected_rec_id then return (element_id);
      535 
      536 	if element_type = "tail" then
      537 	     expected_rec_id = bj_ci.header2.first_rec_id;
      538 
      539 	if element_type = "middle"
      540 	     & bj_ci.header2.first_rec_id ^= expected_rec_id then expected_rec_id = "0"b;
      541 
      542 	return ("0"b);
      543 
      544      end RECORD_ID;
      545 
      546 
      547 PREVIOUS_ELEMENT_ID: proc (element_id) returns (bit (36) aligned);
      548 
      549 /* Operate on LOCAL_CI pointed to by bj_ci_ptr.
      550*	The input argument is the element_id of the current element;
      551*	that is, the element is currently in the LOCAL_CI. If there is
      552*	a previous element in this ci, it just decreases sl by 1.
      553*	Otherwise, it reads the previous CI into LOCAL_CI and
      554*	sets ci to the value of the previous ci and sl to the value
      555*	of the last slot in the CI.*/
      556 
      557 
      558 dcl  element_id			     bit (36) aligned; /* Parameter */
      559 
      560 dcl  ci				     fixed bin (24) uns;
      561 dcl  sl				     fixed bin (12) uns;
      562 
      563 dcl  bj_storage_util$previous_used_ci
      564 				     entry (ptr, fixed bin (24) uns) returns (fixed bin (24) uns);
      565 
      566 
      567 	ci = addr (element_id) -> str_rec_id.ci_no;
      568 	sl = addr (element_id) -> str_rec_id.sl_no;
      569 
      570 
      571 	if sl > 1
      572 	then sl = sl - 1;
      573 	else do;
      574 	     if ci = bj_pste.cl.origin_ci then return ("0"b);
      575 	     ci = bj_storage_util$previous_used_ci (bj_pste_ptr, ci); /* Never returns "nul value */
      576 	     call GET_CI (ci);
      577 	     sl = bj_ci.n_slots;
      578 	     if sl = 0 | sl > 64			/* What is the max_sl ? */
      579 	     then call ERROR_RETURN (dm_error_$bj_bad_slot_no);
      580 	end;
      581 
      582 	addr (element_id) -> str_rec_id.ci_no = ci;
      583 	addr (element_id) -> str_rec_id.sl_no = sl;
      584 
      585 	return (element_id);
      586 
      587      end PREVIOUS_ELEMENT_ID;
      588 
      589 
      590 GET_RECORD_HEADER: proc (rec_id, header_ptr);
      591 
      592 
      593 /* Operates on LOCAL_CI. It knows that a record header is never
      594*	split between 2 CI's. */
      595 
      596 dcl  rec_id			     bit (36) aligned; /* Parameter */
      597 dcl  header_ptr			     ptr;		/* Parameter */
      598 
      599 dcl  header_bytes			     char (4 * size (bj_rec_hdr)) aligned based (header_ptr);
      600 
      601 dcl  sl				     fixed bin (12) uns;
      602 dcl  offset			     fixed bin (18) uns;
      603 dcl  rec_type			     char (4);
      604 
      605 
      606 
      607 
      608 	sl = addr (rec_id) -> str_rec_id.sl_no;
      609 
      610 	offset = bj_ci.slot (sl).offset;
      611 
      612 	if bj_ci.slot (sl).length < size (bj_rec_hdr) * 4
      613 	then call ERROR_RETURN (dm_error_$bj_inconsistent_ci);
      614 
      615 	header_bytes = substr (ci_bytes, size (ci_header) * 4 + (offset + 1), size (bj_rec_hdr) * 4);
      616 
      617 
      618 	rec_type = header_ptr -> bj_rec_hdr.type;
      619 
      620 	if rec_type = BJ_RECORD_TYPE.COMMITTED
      621 	     | rec_type = BJ_RECORD_TYPE.ABORTED
      622 	     | rec_type = BJ_RECORD_TYPE.ROLLED_BACK
      623 	     | rec_type = BJ_RECORD_TYPE.BEFORE_IMAGE
      624 	     | rec_type = BJ_RECORD_TYPE.HANDLER
      625 	     | rec_type = BJ_RECORD_TYPE.FM_ROLLBACK_HANDLER
      626 	     | rec_type = BJ_RECORD_TYPE.FM_POSTCOMMIT_HANDLER
      627 	     | rec_type = BJ_RECORD_TYPE.BEGIN_COMMIT
      628 						/*
      629*               | rec_type = BJ_RECORD_TYPE.PERFORM_COMMIT
      630*               | rec_type = BJ_RECORD_TYPE.BEGIN_MARK
      631**/
      632 	then ;					/* OK */
      633 	else call ERROR_RETURN (dm_error_$bj_unknown_record_type);
      634 
      635 	return;
      636 
      637      end GET_RECORD_HEADER;
      638 
      639 
  1     1 	/* BEGIN dm_bj_static.incl.pl1 */
  1     2 /*
  1     3*Modified: 
  1     4*10/04/82 by Lee A. Newcomb:  To change from internal static to external
  1     5*	  static.
  1     6**/
  1     7 
  1     8 dcl dm_system_data_$bj_max_n_journals		fixed bin ext static;
  1     9 dcl dm_system_data_$bj_max_n_processes		fixed bin ext static;
  1    10 dcl dm_system_data_$max_n_transactions     fixed bin ext static;
  1    11 
  1    12 	/* END dm_bj_static.incl.pl1 */
  1    13 
      640 
      641 
      642 
  2     1 /*  BEGIN INCLUDE FILE:	dm_bj_ppt.incl.pl1	*/
  2     2 /*
  2     3*Layout of the per-process before journal table and entries.
  2     4*
  2     5*Written by Andre Bensoussan June/July 1982
  2     6*Modified:
  2     7*09/29/82 by Lee A. Newcomb:  To make two default oid cells, pad ppte's
  2     8*	  to account for all used space, and use dm_system_data_ for
  2     9*	  determining dimension of bj_ppt.e.
  2    10**/
  2    11 /* format: style4,indattr,idind33,^indcomtxt */
  2    12 
  2    13 dcl  BJ_PPT_VERSION_1	        fixed bin int static options (constant) init (1);
  2    14 dcl  BJ_PPTE_VERSION_1	        fixed bin int static options (constant) init (1);
  2    15 
  2    16 dcl  bj_ppt_ptr		        ptr;
  2    17 
  2    18 dcl  1 bj_ppt		        based (bj_ppt_ptr) aligned,
  2    19        2 version		        fixed bin,
  2    20        2 max_n_entries	        fixed bin,		/* should be = dm_system_data_$bj_max_n_journals */
  2    21        2 n_entries_used	        fixed bin,		/* # of BJs open in this process */
  2    22        2 highest_ix_used	        fixed bin,		/* max. # of BJs ever opened in this process */
  2    23        2 default_bj,				/* for selecting a txn def. BJ by write_before_mark protocol */
  2    24          3 user_set_oid	        bit (36),		/* explicit user setting via $set_default_bj */
  2    25          3 last_opened_oid	        bit (36),		/* implicit if no user setting, set by open and close */
  2    26 						/* if both zero, use system default BJ */
  2    27        2 process_id		        bit (36),		/* so we don't have to keep calling for it. */
  2    28        2 process_ix		        fixed bin,		/* index into bj_check_in_table */
  2    29        2 mod_list_area	        (100) fixed bin (35), /* for keeping track of ppt mods, not curr. used */
  2    30 
  2    31        2 e		        dim (dm_system_data_$bj_max_n_journals refer (bj_ppt.max_n_entries))
  2    32 			        like bj_ppte;	/* an entry for each BJ open in this process */
  2    33 						/* always make sure bj_ppt.e is on a even word boundary */
  2    34 
  2    35 /* now specify the format of each per-process BJ table entry */
  2    36 
  2    37 dcl  bj_ppte_ptr		        ptr;
  2    38 
  2    39 dcl  1 bj_ppte		        based (bj_ppte_ptr) aligned,
  2    40        2 version		        fixed bin,		/* better be the same for all entries in a bj_ppt */
  2    41        2 bj_uid		        bit (36),		/* UID of the BJ page file */
  2    42        2 pf_oid		        bit (36),		/* OID of the BJ page file */
  2    43        2 n_opening		        fixed bin,		/* how many openings this process has done for this BJ */
  2    44        2 bj_pste_ptr	        ptr,		/* "link" to per-system BJ table entry */
  2    45        2 open_time		        fixed bin (71);	/* used to fill in bj_ppt.default_bj.last_opened_oid */
  2    46 						/* if the last opened BJ is closed */
  2    47 
  2    48 /* END INCLUDE FILE:	bj_ppt.incl.pl1	*/
      643 
      644 
      645 
  3     1 /*  BEGIN INCLUDE FILE:	dm_bj_pst.incl.pl1	*/
  3     2 /*
  3     3*Layout of the before journal per-system table header and BJ table entries.
  3     4*
  3     5*Written by Andre Bensoussan 06-15-1982
  3     6*Modified:
  3     7*09/29/82 by Lee A. Newcomb:  To use dm_system_data_ for determining
  3     8*	  dimension of bj_pst.e and force bj_pst.mod_list_area and
  3     9*	  bj_pst.e to even word boundaries.
  3    10*04/27/82 by M. Pandolf:  To add meter space by cutting away from mod_list_area.
  3    11**/
  3    12 /* format: style4,indattr,idind33,^indcomtxt */
  3    13 
  3    14 dcl  BJ_PST_VERSION_1	        fixed bin internal static options (constant) init (1);
  3    15 
  3    16 dcl  bj_pst_ptr		        ptr;
  3    17 
  3    18 dcl  1 bj_pst		        based (bj_pst_ptr) aligned,
  3    19        2 version		        fixed bin,
  3    20        2 pad1		        bit (36),
  3    21        2 lock,
  3    22          3 pid		        bit (36),		/* process_id holding lock */
  3    23          3 event		        bit (36),
  3    24        2 time_of_bootload	        fixed bin (71),	/* for ease of access */
  3    25        2 max_n_entries	        fixed bin,		/* as determined from dm_system_data_$bj_max_n_journals */
  3    26        2 n_entries_used	        fixed bin,		/* current # of BJs open on the system */
  3    27        2 highest_ix_used	        fixed bin,		/* max. # of BJs that has ever been open of the system */
  3    28        2 pn_table_offset	        fixed bin (18) uns,	/* relative offset of bj_pn_table in bj_pst seg. */
  3    29        2 check_in_table_offset        fixed bin (18) uns,	/* ditto for bj_check_in_table */
  3    30        2 buffer_table_offset	        fixed bin (18) uns,	/* ditto for where our BJ buffers are located */
  3    31        2 max_n_buffers	        fixed bin,		/* must be <= to max_n_entries */
  3    32        2 pad2		        bit (36),		/* force next on even word boundary */
  3    33        2 meters,					/* dim (50) fixed bin (71), */
  3    34          3 n_calls_begin_txn          fixed bin (71),	/* meter (1) */
  3    35          3 n_calls_before_image       fixed bin (71),	/* meter (2) */
  3    36          3 n_calls_abort              fixed bin (71),	/* meter (3) */
  3    37          3 n_calls_commit             fixed bin (71),	/* meter (4) */
  3    38          3 n_calls_rb_mark            fixed bin (71),	/* meter (5) */
  3    39          3 n_calls_fm_pc_mark         fixed bin (71),	/* meter (6) */
  3    40          3 n_calls_fm_rbh             fixed bin (71),	/* meter (7) */
  3    41          3 n_calls_rollback           fixed bin (71),	/* meter (8) */
  3    42          3 meter dim (9:50)           fixed bin (71),	/* meter (9) - meter (50) */
  3    43        2 mod_list_area	        (100) fixed bin (35), /* for keeping track of pst mods */
  3    44 
  3    45        2 e		        dim (dm_system_data_$bj_max_n_journals refer (bj_pst.max_n_entries))
  3    46 			        like bj_pste;	/* per system BJ table entries */
  3    47 
  3    48 
  3    49 /* END INCLUDE FILE:	dm_bj_pst.incl.pl1	*/
      646 
      647 
      648 
  4     1 /* BEGIN INCLUDE FILE:	dm_bj_pste.incl.pl1	*/
  4     2 
  4     3 /* DESCRIPTION
  4     4*
  4     5*	Layout of the per-system before journal table
  4     6*     entries.  This structure is used to contain information
  4     7*     about a before journal active in a running DMS.  It is
  4     8*     currently also used as the header of a before journal
  4     9*     (see dm_bj_header.incl.pl1).  Version changes to this
  4    10*     structure require either automatic conversion to be set
  4    11*     up, or users to be told to re-create their journals.
  4    12*
  4    13*	Currently, a bj_pste must be 64 words long;  any
  4    14*     future changes must at least make sure a bj_pste is an
  4    15*     even # of words for the alignment of some of its
  4    16*     elements.
  4    17**/
  4    18 
  4    19 /*  HISTORY:
  4    20*
  4    21*Written by Andre Bensoussan, 06/15/82.
  4    22*Modified:
  4    23*08/16/82 by Andre Bensoussan: to add stamp_for_last_ci_put.
  4    24*09/29/82 by Lee A. Newcomb: to fix BJ_PSTE_VERSION_1 and fix some
  4    25*	  alignments.
  4    26*11/01/82 by Andre Bensoussan: to add "stamp_for_last_ci_on_disk",
  4    27*	  "n_bi_still_unsafe", and "n_bi_being_saved".
  4    28*02/08/83 by M. Pandolf: to add append_state structure.
  4    29*03/19/83 by L. A. Newcomb: to fix up some alignments and spelling problems.
  4    30*04/27/83 by M. Pandolf: to add meter structure at end.
  4    31*02/11/85 by Lee A. Newcomb:  Fixed version constant name to agree with its
  4    32*            value of 2; fixed references to page files or PF's; fixed format
  4    33*            of description and history sections.
  4    34*03/07/85 by Lee A. Newcomb:  Changed a pad word to be txn_storage_limit and
  4    35*            expanded on the description for future generations (no
  4    36*            version was made).
  4    37*03/27/85 by Lee A. Newcomb:  Changed one of the unused meters to
  4    38*            n_txn_storage_limit_hits (again without a version change).
  4    39**/
  4    40 /* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo,^inddcls,dclind5,idind35,linecom */
  4    41 
  4    42 dcl  BJ_PSTE_VERSION_2		fixed bin internal static
  4    43 				options (constant) init (2);
  4    44 
  4    45 dcl  bj_pste_ptr			ptr;
  4    46 
  4    47 /* MUST HAVE EVEN NUMBER OR WORDS */
  4    48 dcl  1 bj_pste			based (bj_pste_ptr) aligned,
  4    49        2 version			fixed bin,
  4    50        2 bj_ix			fixed bin,	/* Index of this entry in bj_pst table */
  4    51        2 lock			aligned,
  4    52          3 pid			bit (36),		/* process ID of lock owner */
  4    53          3 event			bit (36),
  4    54        2 bj_uid			bit (36),		/* UID of BJ file */
  4    55        2 ci_size			fixed bin,	/* In number of bytes */
  4    56        2 max_size			fixed bin,	/* In number of ci's */
  4    57        2 active			bit (1) aligned,	/* 0 means journal not being used */
  4    58        2 time_header_updated		fixed bin (71),
  4    59        2 earliest_meaningful_time	fixed bin (71),	/* time stamp on first valid control interval */
  4    60        2 update_frequency		fixed bin,	/* Not used yet, probably will be how many CIs */
  4    61        2 last_rec_id		bit (36),		/* rec id of the last logical record in journal */
  4    62        2 n_processes		fixed bin,	/* Number of processes using this BJ */
  4    63        2 n_txn			fixed bin,	/* Number of txn in progress using this BJ */
  4    64        2 last_ci_info		aligned,
  4    65          3 last_ci_buffered		fixed bin (24) uns, /* Last ci encached in the buffer */
  4    66          3 last_ci_put		fixed bin (24) uns, /* Last ci put in the BJ */
  4    67          3 last_ci_flushed		fixed bin (24) uns, /* Last ci for which flush initiated */
  4    68          3 last_ci_on_disk		fixed bin (24) uns, /* Last ci of that portion of the BJ known to be ... */
  4    69 						/* .. completely on disk */
  4    70          3 stamp_for_last_ci_put	fixed bin (71),	/* Time stamp associated with the last ci put in the BJ */
  4    71          3 stamp_for_last_ci_on_disk	fixed bin (71),	/* Time stamp associated with the last ci on disk in the BJ */
  4    72        2 n_bi_still_unsafe		fixed bin,	/* number of bi's still not on disk */
  4    73        2 n_bi_being_saved		fixed bin,	/* number of bi's for which flush initiated */
  4    74        2 buffer_offset		fixed bin (18) uns, /* Now allocated in the bj_pst segment */
  4    75        2 txn_storage_limit		fixed bin (35),	/* # of bytes a single txn may write */
  4    76        2 cl			aligned,		/* Circular List */
  4    77          3 origin_ci		fixed bin (24) uns,
  4    78          3 lowest_ci		fixed bin (24) uns,
  4    79          3 highest_ci		fixed bin (24) uns,
  4    80          3 number_ci		fixed bin (24) uns,
  4    81        2 append_state		aligned,
  4    82          3 current_operation		char (4),		/* equal to "appe" when append in progress */
  4    83          3 pending_n_txn		fixed bin,	/* n_txn value when append done */
  4    84          3 pending_last_rec_id	bit (36),		/* last_rec_id value after append done */
  4    85          3 pending_last_element_id	bit (36),		/* last element id after append done */
  4    86          3 txte_rec_id_relp		bit (18),		/* rel ptr into seg containing TXT for txte.pending_bj_rec_id */
  4    87        2 pad_to_even_word1		bit (36) aligned,
  4    88        2 meters			aligned,		/* dim (10) fixed bin (71), */
  4    89          3 n_bi_written		fixed bin (71),	/* meter (1) */
  4    90          3 n_bi_bytes_written		fixed bin (71),	/* meter (2) */
  4    91          3 n_journal_full		fixed bin (71),	/* meter (3) */
  4    92          3 n_successful_recycles	fixed bin (71),	/* meter (4) */
  4    93          3 n_ci_recycled		fixed bin (71),	/* meter (5) */
  4    94          3 n_txn_started		fixed bin (71),	/* meter (6) */
  4    95          3 n_non_null_txn		fixed bin (71),	/* meter (7) */
  4    96          3 n_txn_storage_limit_hits	fixed bin (71),	/* meter (8) */
  4    97          3 meter			(9:10) fixed bin (71),
  4    98 						/* meter (9) - meter (10) */
  4    99        2 pad_to_64_words		(6) bit (36);	/* 64 is even (see below) */
  4   100 
  4   101 
  4   102 /*  END INCLUDE FILE:	dm_bj_pste.incl.pl1	*/
      649 
      650 
      651 
  5     1 /* BEGIN INCLUDE FILE:	dm_bj_ci.incl.pl1	*/
  5     2 /*
  5     3*Layout of a BJ control interval excluding the actual data records.
  5     4*
  5     5*Written  by Andre Bensoussan  07/02/1982
  5     6*Modified:
  5     7*08/15/82 by Andre Bensoussan:  For implementing the flush function;
  5     8*	  header2.reserved_1 has been renamed first_rec_id.
  5     9*01nov82  by M. Pandolf to eliminate reserved_2 (after first_rec_id)
  5    10*	  and to add n_bi, and more reserved space.
  5    11**/
  5    12 
  5    13 /* format: style4,indattr,idind33,^indcomtxt */
  5    14 
  5    15 dcl  bj_ci_ptr		        ptr;
  5    16 
  5    17 dcl  1 bj_ci		        based (bj_ci_ptr) aligned, /* Structure of any CI in BJ except CI zero */
  5    18        2 header1		        like ci_header,	/* Standard PF CI header */
  5    19        2 header2,					/* Header specific to BJ CI */
  5    20          3 layout_type	        bit (36),
  5    21          3 first_rec_id	        bit (36),		/* Relevant only if first_is_contn = 1 */
  5    22 
  5    23          3 n_slots		        fixed bin (17) unal,	/* n_slots, first, last in same word ... */
  5    24          3 first_is_contn	        bit (1) unal,	/* ..so that they can be changed all ... */
  5    25          3 last_is_contd	        bit (1) unal,	/* ..at the same time in one instruction */
  5    26          3 pad		        bit (16) unal,
  5    27 
  5    28          3 n_bi		        fixed bin (35),	/* number of BI's in buffer*/
  5    29          3 reserved		        bit (36) dim (4),
  5    30 
  5    31        2 slot		        dim (1:1000),
  5    32          3 offset		        fixed bin (18) uns unal,    /* In number of bytes */
  5    33          3 length		        fixed bin (18) uns unal;    /* In number of bytes */
  5    34 
  5    35 dcl  1 header2		        like bj_ci.header2 aligned; /* Used for size calculation */
  5    36 
  5    37 /* END INCLUDE FILE:	dm_bj_ci.incl.pl1	*/
  5    38 
  5    39 
  5    40 
  5    41 
  5    42 
  5    43 
  5    44 
  5    45 
  5    46 
  5    47 
      652 
      653 
      654 
  6     1 /* BEGIN INCLUDE FILE:  dm_ci_header.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        This include file contains various structures which make up the
  6     6*   header and trailer of a control interval.
  6     7*   
  6     8*   ****  NOTE:  The include file dm_ci.incl.pl1 is heavily dependent ****
  6     9*   ****  on this include file.  When changing this include file,     ****
  6    10*   ****  check dm_ci.incl.pl1 to see if it is affected.              ****
  6    11**/
  6    12 
  6    13 /* HISTORY:
  6    14*Written by Jeffrey D. Ives, 03/02/82.
  6    15*  (Design by Andre Bensoussan and Jeffrey D. Ives)
  6    16*Modified:
  6    17*11/02/84 by Matthew Pierret:  Re-organized so that dm_ci.incl.pl1 and
  6    18*            dm_ci_header.incl.pl1 do not duplicate structures or constants.
  6    19**/
  6    20 
  6    21 /* format: style2,ind3 */
  6    22 
  6    23 /* ci_header is the first four words of a control interval. Its contents
  6    24*   are used to verify that a control interval is in an expected format,
  6    25*   to identify the control interval and the file to which the control
  6    26*   interval belongs, and to maintain information for the synchronization
  6    27*   of disk I/O between DM file control intervals and associated before
  6    28*   journal control intervals.  The first two words are the time stamp for
  6    29*   synchronization; the latter two identify the control interval. */
  6    30 
  6    31      dcl	   ci_header_ptr	      ptr;
  6    32      dcl	   1 ci_header	      aligned based (ci_header_ptr),
  6    33 	     2 stamp	      like ci_stamp,
  6    34 	     2 id		      like ci_id;
  6    35 
  6    36 /* ci_trailer is the last two words of a control interval and must match
  6    37*   the first two words (ci_header.stamp). */
  6    38 
  6    39      dcl	   ci_trailer_ptr	      ptr;
  6    40      dcl	   1 ci_trailer	      like ci_header.stamp aligned based (ci_trailer_ptr);
  6    41 
  6    42 
  6    43 /* ci_stamp is a two-word date/time modified stamp, consisting of:
  6    44*     version: a 9-bit version string for the structure
  6    45*     bj_idx:  before journal index for I/O synchronization
  6    46*     time_modified:  Multics clock time of last modification */
  6    47 
  6    48      dcl	   1 ci_stamp	      aligned based,
  6    49 	     3 version	      bit (9) unal,
  6    50 	     3 bj_idx	      fixed bin (9) uns unal,
  6    51 	     3 time_modified      fixed bin (53) unal;
  6    52 
  6    53      dcl	   CI_HEADER_STAMP_VERSION_1
  6    54 			      bit (9) aligned static options (constant) init ("641"b3);
  6    55 
  6    56 /* ci_id is a two-word identification of the control interval, which
  6    57*   rarely changes and consists of:
  6    58*     uid:   DM file unique identifier
  6    59*     size_code:  the control interval size in bytes, in an encoded
  6    60*                 form (see ci_size_code below).
  6    61*     num:   the control interval number.  0 is the number of the first
  6    62*            control interval of a file. */
  6    63 
  6    64      dcl	   1 ci_id	      aligned based,
  6    65 	     3 uid	      bit (36),
  6    66 	     3 size_code	      bit (9) unal,
  6    67 	     3 num	      fixed bin (27) uns unal;
  6    68 
  6    69 /* ci_size_code is the structure which defines the content of ci_id.size_code.
  6    70*   The size in bytes of a control interval is equal to 
  6    71*   (2 ** ci_size_code.exponent * (64 + 8 * ci_size_code.addon)).  */
  6    72 
  6    73      dcl	   1 ci_size_code	      aligned based,
  6    74 	     2 exponent	      fixed bin (6) uns unal,
  6    75 	     2 addon	      fixed bin (3) uns unal;
  6    76 
  6    77 /* ci_header_chunks is a structure which can be used to update the
  6    78*   ci_stamp or ci_id in one memory cycle. */
  6    79 
  6    80      dcl	   1 ci_header_chunks     aligned based (ci_header_ptr),
  6    81 	     2 stamp	      fixed bin (71),
  6    82 	     2 id		      fixed bin (71);
  6    83 
  6    84 /* ci_trailer_chunk is a structure which can e used to update the
  6    85*   ci_trailer in one memory cycle. */
  6    86 
  6    87      dcl	   1 ci_trailer_chunk     aligned based,
  6    88 	     2 stamp	      fixed bin (71);
  6    89 
  6    90 
  6    91 /*  END INCLUDE FILE:  dm_ci_header.incl.pl1  */
      655 
      656 
      657 
  7     1 /*  BEGIN INCLUDE FILE:  dm_ci.incl.pl1  */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        This include file contains the structure which defines the 
  7     6*   format of a control interval.  
  7     7*   
  7     8*   ****  NOTE:  This include file depends on the dm_ci_header.incl.pl1 ****
  7     9*   ****  Any program which includes dm_ci.incl.pl1 must also include   ****
  7    10*   ****  dm_ci_header.incl.pl1.                                        ****
  7    11**/
  7    12 
  7    13 /* HISTORY:
  7    14*Written by Jeffrey D. Ives, 09/07/82.
  7    15*     (design by Andre Bensoussan and Jeffrey Ives.)
  7    16*Modified:
  7    17*11/07/84 by Matthew Pierret:  To remove declarations which are also in
  7    18*            dm_ci_header.incl.pl1.
  7    19**/
  7    20 
  7    21 /* format: style2,ind3 */
  7    22 
  7    23      dcl	   ci_ptr		      ptr;
  7    24      dcl	   1 ci		      aligned based (ci_ptr),
  7    25 	     2 header	      like ci_header_chunks,
  7    26 	     2 addressable_bytes  char (4072),
  7    27 	     2 trailer	      like ci_trailer_chunk;
  7    28 
  7    29 
  7    30 /*  END INCLUDE FILE:  dm_ci.incl.pl1  */
      658 
      659 
      660 
  8     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*        This include file contains the ci_parts structure.  This structure
  8     6*   is used across the file_manager_ interface to specify the parts of a
  8     7*   control interval to get or put.  If the number_of parts is equal to 0,
  8     8*   modules which take ci_parts interpret this case to mean to do everything
  8     9*   except the actual requested operation, i.e., lock the control interval
  8    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  8    11*   bytes from the beginning of the addressable portion of the control interval.
  8    12*   An offset_in_bytes which is in the addressable portion is in error.
  8    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  8    14*   portion, it is in error.
  8    15**/
  8    16 
  8    17 /* HISTORY:
  8    18*Written by Matthew Pierret, 01/28/82.
  8    19*  (01/28/82 Andre Bensoussan, Design.)
  8    20*Modified:
  8    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  8    22*            automatic storge.
  8    23**/
  8    24 
  8    25 /* format: style2,ind3 */
  8    26 
  8    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  8    28 	     2 number_of_parts    fixed bin (17),
  8    29 	     2 must_be_zero	      fixed bin,
  8    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  8    31 	       3 offset_in_bytes  fixed bin (17),
  8    32 	       3 length_in_bytes  fixed bin (17),
  8    33 	       3 local_ptr	      ptr;
  8    34 
  8    35      dcl	   ci_parts_ptr	      ptr init (null ());
  8    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  8    37 
  8    38 
  8    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      661 
      662 
      663 
  9     1 /* format: style4,indattr,idind33,^indcomtxt */
  9     2 
  9     3 /* BEGIN INCLUDE FILE:	dm_bj_records.incl.pl1	*/
  9     4 /*
  9     5*Before journal records - images and marks
  9     6*
  9     7*Designed by Andre Bensoussan 02/03/82
  9     8*Written by Mike Pandolf 07/07/82
  9     9*Modified:
  9    10*10/01/82 by Lee A. Newcomb:  To add n_txn to all records so rollback after
  9    11*	  crash knows how many transactions were active at crash time.
  9    12*15feb83  by M. Pandolf: To add fm_handler_rec for both rollback and postcommit
  9    13*	  handler used exclusively by file_manager_, add BEGIN_COMMIT mark,
  9    14*	  and add PREFORM_BEGIN mark (for housekeeping, never written).
  9    15*05apr83 by M. Pandolf to add BEGIN_MARK for bj_txte.last_completed_operation
  9    16**/
  9    17 
  9    18 
  9    19 dcl  bj_rec_hdr_ptr		        ptr;		/* pointer to various bj records */
  9    20 
  9    21 dcl  1 bj_rec_hdr		        aligned based (bj_rec_hdr_ptr),
  9    22        2 type		        char (4),		/* see types below */
  9    23        2 tid		        bit (36),		/* transaction id for this record */
  9    24        2 process_id		        bit (36),		/* of process initiating this transaction */
  9    25        2 prev_rec_id	        bit (36),		/* of record in this transaction */
  9    26        2 prev_rec_byte_size	        fixed bin (24),	/* of record in this transaction */
  9    27        2 tx_rec_no		        fixed bin (35),	/* number of this record in transaction list */
  9    28        2 n_txn		        fixed bin;		/* number of active txn's in the BJ containing this txn */
  9    29 						/* with at least one record written in the BJ.  This is */
  9    30 						/* used for rollback after crash */
  9    31 						/* N.B. commits and abort marks do not count themselves */
  9    32 
  9    33 /* before journal records for the various record types */
  9    34 
  9    35 dcl  1 bj_committed_rec	        aligned like bj_rec_hdr based (bj_rec_hdr_ptr);
  9    36 
  9    37 dcl  1 bj_begin_commit_rec	        aligned like bj_rec_hdr based (bj_rec_hdr_ptr);
  9    38 
  9    39 dcl  1 bj_aborted_rec	        aligned like bj_rec_hdr based (bj_rec_hdr_ptr);
  9    40 
  9    41 dcl  1 bj_rolled_back_rec	        aligned based (bj_rec_hdr_ptr),
  9    42        2 header		        like bj_rec_hdr,
  9    43        2 checkpoint_no	        fixed bin (35),
  9    44        2 last_rolled_back_rec_id      bit (36);
  9    45 
  9    46 dcl  1 bj_rollback_handler_rec        aligned based (bj_rec_hdr_ptr),
  9    47        2 header		        like bj_rec_hdr,
  9    48        2 name_len		        fixed bin (24),
  9    49        2 info_len		        fixed bin (24),
  9    50        2 proc_name		        char (bj_rollback_name_len refer (bj_rollback_handler_rec.name_len)),
  9    51        2 info_bits		        bit (bj_rollback_info_len refer (bj_rollback_handler_rec.info_len));
  9    52 
  9    53 /* dm_bj_records.incl.pl1 CONTINUED NEXT PAGE */
  9    54 
  9    55 /* dm_bj_records.incl.pl1 CONTINUATION FROM PREVIOUS PAGE */
  9    56 
  9    57 dcl  1 bj_before_image	        aligned based (bj_rec_hdr_ptr),
  9    58        2 header		        like bj_rec_hdr,
  9    59        2 fm_uid		        bit (36),
  9    60        2 fm_oid		        bit (36),
  9    61        2 ci_no		        fixed bin (35),
  9    62        2 n_parts		        fixed bin (17),
  9    63        2 image_len		        fixed bin (24),
  9    64        2 part		        dim (bj_before_image_n_parts refer (bj_before_image.n_parts)),
  9    65          3 byte_offset	        fixed bin (24),
  9    66          3 byte_length	        fixed bin (24),
  9    67        2 image		        char (bj_before_image_len refer (bj_before_image.image_len));
  9    68 
  9    69 dcl  1 bj_fm_handler_rec	        aligned based (bj_rec_hdr_ptr),
  9    70        2 header		        like bj_rec_hdr,
  9    71        2 fm_uid		        bit (36),
  9    72        2 fm_oid		        bit (36),
  9    73        2 prev_fm_handler_rec_id       bit (36),
  9    74        2 info_len		        fixed bin,
  9    75        2 info_bytes		        char (bj_fm_handler_info_len refer (bj_fm_handler_rec.info_len));
  9    76 
  9    77 /* extent definers */
  9    78 
  9    79 dcl  bj_rollback_name_len	        fixed bin (24);
  9    80 dcl  bj_rollback_info_len	        fixed bin (24);
  9    81 dcl  bj_before_image_n_parts	        fixed bin;
  9    82 dcl  bj_before_image_len	        fixed bin (24);
  9    83 dcl  bj_fm_handler_info_len	        fixed bin (24);
  9    84 
  9    85 /* record type identifiers */
  9    86 
  9    87 dcl  1 BJ_RECORD_TYPE	        int static options (constant) aligned,
  9    88      ( 2 BEGIN_COMMIT	        init ("bcom"),
  9    89        2 PERFORM_COMMIT	        init ("pcom"),
  9    90        2 COMMITTED		        init ("comm"),
  9    91        2 ABORTED		        init ("abor"),
  9    92        2 ROLLED_BACK	        init ("roll"),
  9    93        2 HANDLER		        init ("hand"),
  9    94        2 FM_ROLLBACK_HANDLER	        init ("fmrb"),
  9    95        2 FM_POSTCOMMIT_HANDLER        init ("fmpc"),
  9    96        2 BEGIN_MARK		        init ("begi"),
  9    97        2 BEFORE_IMAGE	        init ("befo")) char (4);
  9    98 
  9    99 /* END INCLUDE FILE:	dm_bj_records.incl.pl1	*/
      664 
      665 
      666 
      667      end bj_storage_get_header;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0914.7  bj_storage_get_header.pl1         >spec>on>7192.pbf-04/04/85>bj_storage_get_header.pl1
640          1    01/07/85  0857.8  dm_bj_static.incl.pl1             >ldd>include>dm_bj_static.incl.pl1
643          2    01/07/85  0857.6  dm_bj_ppt.incl.pl1                >ldd>include>dm_bj_ppt.incl.pl1
646          3    01/07/85  0857.7  dm_bj_pst.incl.pl1                >ldd>include>dm_bj_pst.incl.pl1
649          4    04/04/85  0819.1  dm_bj_pste.incl.pl1               >spec>on>7192.pbf-04/04/85>dm_bj_pste.incl.pl1
652          5    01/07/85  0857.3  dm_bj_ci.incl.pl1                 >ldd>include>dm_bj_ci.incl.pl1
655          6    01/07/85  0900.5  dm_ci_header.incl.pl1             >ldd>include>dm_ci_header.incl.pl1
658          7    01/07/85  0900.4  dm_ci.incl.pl1                    >ldd>include>dm_ci.incl.pl1
661          8    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
664          9    01/07/85  0857.7  dm_bj_records.incl.pl1            >ldd>include>dm_bj_records.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABORTED                   3     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
BEFORE_IMAGE             11     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
BEGIN_COMMIT                    000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
BJ_RECORD_TYPE                  000000 constant        structure                level 1 dcl 9-87
COMMITTED                 2     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
FM_POSTCOMMIT_HANDLER
                          7     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
FM_ROLLBACK_HANDLER       6     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
HANDLER                   5     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
LOCAL_CI                        000116 automatic       fixed bin(71,0)          array dcl 119 set ref 179 221 277 335 427 615
ME                              000012 constant        char(21)                 initial unaligned dcl 146 ref 389
ROLLED_BACK               4     000000 constant        char(4)                  initial level 2 dcl 9-87 ref 620
addr                                                   builtin function         dcl 136 ref 179 187 188 221 228 229 277 300 301 335
                                                                                  356 357 427 465 471 527 567 568 582 583 608 615
bj_ci                                  based           structure                level 1 dcl 5-17
bj_ci_ptr                       002132 automatic       pointer                  dcl 5-15 set ref 179* 221* 277* 292 298 335* 348 354
                                                                                  437 437 440 440 440 471 494 498 498 501 505 509
                                                                                  509 536 539 577 610 612
bj_oid_util$get_ptr             000010 constant        entry                    external dcl 152 ref 176 218 274
bj_ppte                                based           structure                level 1 dcl 2-39
bj_ppte_ptr                     002126 automatic       pointer                  dcl 2-37 set ref 176* 177 178 182 218* 219 220 223
                                                                                  274* 275 276 281
bj_pste                                based           structure                level 1 dcl 4-48
bj_pste_lock$lock               000012 constant        entry                    external dcl 153 ref 182 223 281
bj_pste_lock$lock_partial_check 000014 constant        entry                    external dcl 154 ref 338
bj_pste_lock$unlock             000016 constant        entry                    external dcl 155 ref 209 263 323 378
bj_pste_ptr               4            based           pointer                  level 2 in structure "bj_ppte" dcl 2-39 in procedure
                                                                                  "bj_storage_get_header" ref 177 219 275
bj_pste_ptr                     002130 automatic       pointer                  dcl 4-45 in procedure "bj_storage_get_header" set
                                                                                  ref 177* 182* 209* 219* 223* 263* 275* 281* 284
                                                                                  294 323* 333* 338* 340 350 378* 412* 412 412* 423
                                                                                  428 428 429 429 459 459 470 574 575* 615
bj_rec_hdr                             based           structure                level 1 dcl 9-21 ref 612 615 615
bj_rec_hdr_ptr                         automatic       pointer                  dcl 9-19 ref 612 615 615
bj_report_err                   000020 constant        entry                    external dcl 156 ref 389
bj_storage_util$distance        000022 constant        entry                    external dcl 157 ref 412 412
bj_storage_util$previous_used_ci
                                000050 constant        entry                    external dcl 563 ref 575
bj_uid                    1            based           bit(36)                  level 2 dcl 2-39 set ref 182* 223* 281*
buffer_offset            32            based           fixed bin(18,0)          level 2 unsigned dcl 4-48 ref 428
ci                              002224 automatic       fixed bin(24,0)          unsigned dcl 560 in procedure "PREVIOUS_ELEMENT_ID"
                                                                                  set ref 567* 574 575* 575* 576* 582
ci                                     parameter       fixed bin(24,0)          unsigned dcl 453 in procedure "GET_CI" set ref 450
                                                                                  459 459 459 473*
ci                                     parameter       fixed bin(24,0)          unsigned dcl 405 in procedure "COPY_CI_LOCALLY" set
                                                                                  ref 394 412* 419* 423
ci_bytes                               based           char                     dcl 131 set ref 429* 429 615
ci_header                              based           structure                level 1 dcl 6-32 ref 470 615
ci_header_chunks                       based           structure                level 1 dcl 6-80
ci_header_ptr                          automatic       pointer                  dcl 6-31 ref 470 615
ci_id                                  based           structure                level 1 dcl 6-64
ci_no                                  based           fixed bin(24,0)          level 2 in structure "str_rec_id" packed unsigned
                                                                                  unaligned dcl 127 in procedure
                                                                                  "bj_storage_get_header" set ref 187 228 300* 356*
                                                                                  567 582*
ci_no                           000102 automatic       fixed bin(24,0)          unsigned dcl 107 in procedure
                                                                                  "bj_storage_get_header" set ref 187* 195* 228*
                                                                                  235* 284* 290* 294* 295* 300 340* 346* 350* 351*
                                                                                  356
ci_parts                               based           structure                level 1 dcl 8-27
ci_parts_ptr                    002134 automatic       pointer                  initial dcl 8-35 set ref 8-35* 465* 467 469 470 471
                                                                                  473*
ci_size                   5            based           fixed bin(17,0)          level 2 dcl 4-48 ref 429 429 470 615
ci_stamp                               based           structure                level 1 dcl 6-48
ci_trailer                             based           structure                level 1 dcl 6-40 ref 470
ci_trailer_chunk                       based           structure                level 1 dcl 6-87
ci_trailer_ptr                         automatic       pointer                  dcl 6-39 ref 470
cip_number_of_parts             002136 automatic       fixed bin(17,0)          initial dcl 8-36 set ref 8-36*
cl                       34            based           structure                level 2 dcl 4-48
cleanup                         002120 stack reference condition                dcl 141 ref 193 233 288 344
code                            000100 automatic       fixed bin(35,0)          dcl 104 set ref 473* 474 474*
cu_$level_get                   000024 constant        entry                    external dcl 158 ref 190 231 286 342
cu_$level_set                   000026 constant        entry                    external dcl 159 ref 193 233 288 344 418 420
current_ring                    002117 automatic       fixed bin(3,0)           initial dcl 122 set ref 122* 191* 232* 287* 343* 418
dm_error_$bj_bad_ci_no          000036 external static fixed bin(35,0)          dcl 167 set ref 459*
dm_error_$bj_bad_rec_id         000042 external static fixed bin(35,0)          dcl 169 set ref 200* 240* 434*
dm_error_$bj_bad_slot_no        000040 external static fixed bin(35,0)          dcl 168 set ref 494* 578*
dm_error_$bj_inconsistent_ci    000034 external static fixed bin(35,0)          dcl 166 set ref 437* 440* 612*
dm_error_$bj_logic_err          000046 external static fixed bin(35,0)          dcl 171 set ref 432*
dm_error_$bj_unknown_record_type
                                000044 external static fixed bin(35,0)          dcl 170 set ref 633*
element_id                             parameter       bit(36)                  dcl 558 in procedure "PREVIOUS_ELEMENT_ID" set ref
                                                                                  547 567 568 582 583 585
element_id                             parameter       bit(36)                  dcl 520 in procedure "RECORD_ID" set ref 517 527 531
                                                                                  533 533
element_id                      000107 automatic       bit(36)                  dcl 113 in procedure "bj_storage_get_header" set ref
                                                                                  243* 247 249* 249* 251 251* 305* 309 311* 313*
                                                                                  313* 361* 365 367* 369* 369*
element_type                    000112 automatic       char(8)                  dcl 116 set ref 198* 200 200 238* 240 240 529* 531
                                                                                  533 536 539
entry_point                     000114 automatic       char(8)                  dcl 117 set ref 174* 216* 272* 332* 389
er_code                                parameter       fixed bin(35,0)          dcl 387 set ref 384 389*
expected_rec_id                 000106 automatic       bit(36)                  dcl 112 in procedure "bj_storage_get_header" set ref
                                                                                  245* 251* 307* 311* 363* 367*
expected_rec_id                        parameter       bit(36)                  dcl 521 in procedure "RECORD_ID" set ref 517 533
                                                                                  536* 539 539*
file_manager_$get               000030 constant        entry                    external dcl 160 ref 473
first_is_contn            6(18)        based           bit(1)                   level 3 packed unaligned dcl 5-17 set ref 440 498
                                                                                  505
first_rec_id              5            based           bit(36)                  level 3 dcl 5-17 set ref 440 536 539
get_ring_                       000032 constant        entry                    external dcl 161 ref 191 232 287 343
header2                   4            based           structure                level 2 dcl 5-17 set ref 471
header_bytes                           based           char                     dcl 599 set ref 615*
header_ptr                             parameter       pointer                  dcl 597 ref 590 615 618
highest_ci               36            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 ref 459
last_ci_buffered         20            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 ref 284 340 423
last_ci_info             20            based           structure                level 2 dcl 4-48
last_ci_put              21            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 set ref 294 350 412*
last_is_contd             6(19)        based           bit(1)                   level 3 packed unaligned dcl 5-17 set ref 498 509
length                   14(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 5-17 ref
                                                                                  612
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 8-27 set ref 470*
local_ptr                 4            based           pointer                  array level 3 dcl 8-27 set ref 471*
lowest_ci                35            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 ref 459
my_ci_parts                     002166 automatic       fixed bin(71,0)          array dcl 455 set ref 465
n_slots                   6            based           fixed bin(17,0)          level 3 packed unaligned dcl 5-17 set ref 292 298
                                                                                  348 354 437 437 440 494 501 509 577
null                                                   builtin function         dcl 136 ref 8-35
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 8-27 set ref 467*
offset                          002235 automatic       fixed bin(18,0)          unsigned dcl 602 in procedure "GET_RECORD_HEADER"
                                                                                  set ref 610* 615
offset                   14            based           fixed bin(18,0)          array level 3 in structure "bj_ci" packed unsigned
                                                                                  unaligned dcl 5-17 in procedure
                                                                                  "bj_storage_get_header" ref 610
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 dcl 8-27 set ref 469*
origin_ci                34            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 ref 574
p                               002154 automatic       pointer                  dcl 407 set ref 427* 429
p_bj_oid                               parameter       bit(36)                  dcl 94 set ref 90 176* 213 218* 269 274*
p_bj_pste_ptr                          parameter       pointer                  dcl 98 ref 329 333
p_header_ptr                           parameter       pointer                  dcl 96 set ref 90 204* 213 256* 269 317* 329 374*
p_pf_oid                               parameter       bit(36)                  dcl 97 ref 329 334
p_rec_id                               parameter       bit(36)                  dcl 95 set ref 90 185 204* 213 226 260* 269 320*
part                      2            based           structure                array level 2 dcl 8-27
pf_oid                          000104 automatic       bit(36)                  dcl 110 in procedure "bj_storage_get_header" set ref
                                                                                  178* 220* 276* 334* 473*
pf_oid                    2            based           bit(36)                  level 2 in structure "bj_ppte" dcl 2-39 in procedure
                                                                                  "bj_storage_get_header" ref 178 220 276
ptr                                                    builtin function         dcl 136 ref 428
q                               002156 automatic       pointer                  dcl 408 set ref 428* 429
rec_id                          000105 automatic       bit(36)                  dcl 111 in procedure "bj_storage_get_header" set ref
                                                                                  185* 187 188 226* 228 229 243 300 301 305 356 357
                                                                                  361
rec_id                                 parameter       bit(36)                  dcl 596 in procedure "GET_RECORD_HEADER" set ref 590
                                                                                  608
rec_type                        002236 automatic       char(4)                  unaligned dcl 603 set ref 618* 620 620 620 620 620
                                                                                  620 620 620
record_id                       000110 automatic       bit(36)                  dcl 114 set ref 244* 247 251* 256 256* 260 306* 309
                                                                                  311* 313 317 317* 320 362* 365 367* 369 374 374*
                                                                                  380
rel_distance                    000101 automatic       fixed bin(35,0)          dcl 105 set ref 412* 415 423
saved_level                     002116 automatic       fixed bin(17,0)          initial dcl 121 set ref 121* 190* 193* 231* 233*
                                                                                  286* 288* 342* 344* 420*
size                                                   builtin function         dcl 136 ref 470 470 612 615 615 615
sl                              002214 automatic       fixed bin(12,0)          unsigned dcl 523 in procedure "RECORD_ID" set ref
                                                                                  527* 529*
sl                                     parameter       fixed bin(12,0)          unsigned dcl 491 in procedure "ELEMENT_TYPE" ref 482
                                                                                  494 494 501 505 509
sl                              002225 automatic       fixed bin(12,0)          unsigned dcl 561 in procedure "PREVIOUS_ELEMENT_ID"
                                                                                  set ref 568* 571 571* 571 577* 578 578 583
sl                              002234 automatic       fixed bin(12,0)          unsigned dcl 601 in procedure "GET_RECORD_HEADER"
                                                                                  set ref 608* 610 612
sl_no                     0(24)        based           fixed bin(12,0)          level 2 in structure "str_rec_id" packed unsigned
                                                                                  unaligned dcl 127 in procedure
                                                                                  "bj_storage_get_header" set ref 188 229 301* 357*
                                                                                  527 568 583* 608
sl_no                           000103 automatic       fixed bin(12,0)          unsigned dcl 108 in procedure
                                                                                  "bj_storage_get_header" set ref 188* 198* 229*
                                                                                  238* 298* 301 354* 357
slot                     14            based           structure                array level 2 dcl 5-17
stamp                                  based           structure                level 3 in structure "bj_ci" dcl 5-17 in procedure
                                                                                  "bj_storage_get_header"
stamp                                  based           structure                level 2 in structure "ci_header" dcl 6-32
                                                                                  in procedure "bj_storage_get_header"
str_rec_id                             based           structure                level 1 dcl 127
substr                                                 builtin function         dcl 136 ref 615
type                                   based           char(4)                  level 2 dcl 9-21 ref 618

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BJ_PPTE_VERSION_1                      internal static fixed bin(17,0)          initial dcl 2-14
BJ_PPT_VERSION_1                       internal static fixed bin(17,0)          initial dcl 2-13
BJ_PSTE_VERSION_2                      internal static fixed bin(17,0)          initial dcl 4-42
BJ_PST_VERSION_1                       internal static fixed bin(17,0)          initial dcl 3-14
CI_HEADER_STAMP_VERSION_1              internal static bit(9)                   initial dcl 6-53
bj_aborted_rec                         based           structure                level 1 dcl 9-39
bj_before_image                        based           structure                level 1 dcl 9-57
bj_before_image_len                    automatic       fixed bin(24,0)          dcl 9-82
bj_before_image_n_parts                automatic       fixed bin(17,0)          dcl 9-81
bj_begin_commit_rec                    based           structure                level 1 dcl 9-37
bj_committed_rec                       based           structure                level 1 dcl 9-35
bj_fm_handler_info_len                 automatic       fixed bin(24,0)          dcl 9-83
bj_fm_handler_rec                      based           structure                level 1 dcl 9-69
bj_ppt                                 based           structure                level 1 dcl 2-18
bj_ppt_ptr                             automatic       pointer                  dcl 2-16
bj_pst                                 based           structure                level 1 dcl 3-18
bj_pst_ptr                             automatic       pointer                  dcl 3-16
bj_rollback_handler_rec                based           structure                level 1 dcl 9-46
bj_rollback_info_len                   automatic       fixed bin(24,0)          dcl 9-80
bj_rollback_name_len                   automatic       fixed bin(24,0)          dcl 9-79
bj_rolled_back_rec                     based           structure                level 1 dcl 9-41
ci                                     based           structure                level 1 dcl 7-24
ci_ptr                                 automatic       pointer                  dcl 7-23
ci_size_code                           based           structure                level 1 dcl 6-73
dm_system_data_$bj_max_n_journals      external static fixed bin(17,0)          dcl 1-8
dm_system_data_$bj_max_n_processes     external static fixed bin(17,0)          dcl 1-9
dm_system_data_$max_n_transactions     external static fixed bin(17,0)          dcl 1-10
header2                                automatic       structure                level 1 dcl 5-35

NAMES DECLARED BY EXPLICIT CONTEXT.
COPY_CI_LOCALLY                 001177 constant        entry                    internal dcl 394 ref 195 235 290 295 346 351
ELEMENT_TYPE                    001447 constant        entry                    internal dcl 482 ref 198 238 529
ERROR_RETURN                    001137 constant        entry                    internal dcl 384 ref 200 240 432 434 437 440 459 474
                                                                                  494 578 612 633
GET_CI                          001366 constant        entry                    internal dcl 450 ref 419 576
GET_RECORD_HEADER               001726 constant        entry                    internal dcl 590 ref 204 256 317 374
MAIN_RETURN                     001125 constant        label                    dcl 380
PREVIOUS_ELEMENT_ID             001636 constant        entry                    internal dcl 547 ref 249 313 369
RECORD_ID                       001555 constant        entry                    internal dcl 517 ref 251 311 367
bj_storage_get_header           000104 constant        entry                    external dcl 90
find_last_record                000742 constant        entry                    external dcl 329
last                            000523 constant        entry                    external dcl 269
previous                        000301 constant        entry                    external dcl 213

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2406        2460    2102        2416
Length      3076    2102        52         402     304           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bj_storage_get_header              1269 external procedure  is an external procedure.  
on unit on line 193                  68 on unit               
on unit on line 233                  68 on unit               
on unit on line 288                  68 on unit               
on unit on line 344                  68 on unit               
ERROR_RETURN                            internal procedure  shares stack frame of external procedure bj_storage_get_header.  
COPY_CI_LOCALLY                         internal procedure  shares stack frame of external procedure bj_storage_get_header.  
GET_CI                                  internal procedure  shares stack frame of external procedure bj_storage_get_header.  
ELEMENT_TYPE                            internal procedure  shares stack frame of external procedure bj_storage_get_header.  
RECORD_ID                               internal procedure  shares stack frame of external procedure bj_storage_get_header.  
PREVIOUS_ELEMENT_ID                     internal procedure  shares stack frame of external procedure bj_storage_get_header.  
GET_RECORD_HEADER                       internal procedure  shares stack frame of external procedure bj_storage_get_header.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bj_storage_get_header    000100 code                        bj_storage_get_header
                         000101 rel_distance                bj_storage_get_header
                         000102 ci_no                       bj_storage_get_header
                         000103 sl_no                       bj_storage_get_header
                         000104 pf_oid                      bj_storage_get_header
                         000105 rec_id                      bj_storage_get_header
                         000106 expected_rec_id             bj_storage_get_header
                         000107 element_id                  bj_storage_get_header
                         000110 record_id                   bj_storage_get_header
                         000112 element_type                bj_storage_get_header
                         000114 entry_point                 bj_storage_get_header
                         000116 LOCAL_CI                    bj_storage_get_header
                         002116 saved_level                 bj_storage_get_header
                         002117 current_ring                bj_storage_get_header
                         002126 bj_ppte_ptr                 bj_storage_get_header
                         002130 bj_pste_ptr                 bj_storage_get_header
                         002132 bj_ci_ptr                   bj_storage_get_header
                         002134 ci_parts_ptr                bj_storage_get_header
                         002136 cip_number_of_parts         bj_storage_get_header
                         002154 p                           COPY_CI_LOCALLY
                         002156 q                           COPY_CI_LOCALLY
                         002166 my_ci_parts                 GET_CI
                         002214 sl                          RECORD_ID
                         002224 ci                          PREVIOUS_ELEMENT_ID
                         002225 sl                          PREVIOUS_ELEMENT_ID
                         002234 sl                          GET_RECORD_HEADER
                         002235 offset                      GET_RECORD_HEADER
                         002236 rec_type                    GET_RECORD_HEADER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              signal              enable
shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bj_oid_util$get_ptr           bj_pste_lock$lock             bj_pste_lock$lock_partial_check
bj_pste_lock$unlock           bj_report_err                 bj_storage_util$distance
bj_storage_util$previous_used_ci                            cu_$level_get                 cu_$level_set
file_manager_$get             get_ring_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_bad_ci_no        dm_error_$bj_bad_rec_id       dm_error_$bj_bad_slot_no      dm_error_$bj_inconsistent_ci
dm_error_$bj_logic_err        dm_error_$bj_unknown_record_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    121 000067       122 000071    8   35 000073    8   36 000075        90 000100       174 000114       176 000116
    177 000130       178 000133       179 000136       182 000140       185 000151       187 000154       188 000157
    190 000162       191 000171       193 000200       195 000224       198 000226       200 000230       204 000250
    209 000261       211 000270       213 000277       216 000311       218 000313       219 000325       220 000330
    221 000333       223 000335       226 000346       228 000351       229 000354       231 000357       232 000366
    233 000375       235 000421       238 000423       240 000425       243 000445       244 000447       245 000450
    247 000451       249 000456       251 000460       253 000464       256 000465       260 000500       263 000503
    265 000512       269 000521       272 000533       274 000535       275 000547       276 000552       277 000555
    281 000557       284 000570       286 000573       287 000602       288 000611       290 000635       292 000637
    294 000643       295 000646       298 000650       300 000654       301 000657       305 000661       306 000663
    307 000664       309 000665       311 000672       313 000674       315 000700       317 000701       320 000714
    323 000717       326 000726       329 000735       332 000751       333 000753       334 000757       335 000761
    338 000763       340 000772       342 000775       343 001004       344 001013       346 001037       348 001041
    350 001045       351 001050       354 001052       356 001056       357 001061       361 001063       362 001065
    363 001066       365 001067       367 001074       369 001076       372 001102       374 001103       378 001116
    380 001125       384 001137       389 001141       391 001175       394 001177       412 001201       415 001234
    418 001235       419 001246       420 001255       421 001264       423 001265       427 001274       428 001276
    429 001302       430 001306       432 001307       434 001317       437 001326       440 001345       445 001365
    450 001366       459 001370       465 001406       467 001410       469 001412       470 001413       471 001421
    473 001424       474 001442       477 001446       482 001447       494 001451       498 001467       501 001503
    505 001520       509 001533       513 001547       517 001555       527 001557       529 001562       531 001564
    533 001575       536 001610       539 001621       542 001633       547 001636       567 001640       568 001643
    571 001646       574 001653       575 001661       576 001673       577 001675       578 001701       582 001713
    583 001720       585 001723       590 001726       608 001730       610 001733       612 001737       615 001755
    618 001777       620 002001       633 002022       635 002031


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
