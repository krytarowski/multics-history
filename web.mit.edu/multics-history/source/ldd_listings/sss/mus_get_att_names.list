	COMPILATION LISTING OF SEGMENT mus_get_att_names
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1342.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-08-12,Blair), approve(86-08-12,MCR7311),
       15*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       16*     Check for when the submodel name doesn't match any name in the model so
       17*     that we can tell the user to correct and recreate his submodel.  This
       18*     situation can arise as the result of restructuring.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 mus_get_att_names:
       23      proc (dbm_ptr, dsm_sw, rns_ptr, rel_index, wa_ptr, ans_ptr, error_code);
       24 
       25 /* DESCRIPTION:
       26*
       27*   BEGIN_DESCRIPTION
       28*   For  a given relation in a submodel or model, return an array of attributes
       29*   defined  for  that relation, giving the number of attributes, number of key
       30*   attributes,  attribute  model  name,  it's  submodel  name,  attribute info
       31*   pointer, and domain info pointer.
       32*
       33*
       34*
       35*   PARAMETERS:
       36*
       37*   dbm_ptr - - (input) pointer to the db_model segment in the database model
       38*
       39*   dsm_sw  -  -  (input)  bit  (1), ON => this is a submodel relation, else =>
       40*   model relation
       41*
       42*   rns_ptr - - (input) pointer to the rel_names array structure containing the
       43*   relation model and submodel name, and it's rel info pointer
       44*
       45*   rel_index  - - (input) fixed bin, index into the rel_names array giving the
       46*   desired relation for which to return attribute information
       47*
       48*   wa_ptr  -  -  (input) pointer to an area in which to allocate the attribute
       49*   information array to be returned
       50*
       51*   ans_ptr  -  -  (output) pointer to the att_name array allocated in the area
       52*   pointed  to by wa_ptr, containing the desired attribute information for the
       53*   relation specified by the rel_name array and index
       54*
       55*   error_code  -  -  (output) fixed bin (35), error type encoding, 0 unless an
       56*   error occured
       57*
       58*   sub_error_  -  - (output) condition, signaled upon occurence of an error to
       59*   provide more info
       60*   END_DESCRIPTION
       61*
       62*
       63*   HISTORY:
       64*
       65*   78-08-01 Oris D. Friesen: Originally written.
       66*
       67*   79-06-01 Jim Gray : Modified to
       68*   1) add number of key and varying attributes to info returned
       69*   2) add sub_err_ reporting of errors
       70*   3) change from freeing to area deleting in higher routine for cleanup
       71*   4) document the program interface and logic
       72*
       73*   80-08-01  Spratt:  Changed  to  understand new submodel system; an external
       74*   submodel  iocb ptr was added for reference through mrds_dsm modules, set by
       75*   higher  program;  dsmd_$foo  calls  changed  to  mrds_dsm_foo  calls;  uses
       76*   relation_block structure instead of dsm_relation_str; the r_perm and u_perm
       77*   switches    are   now   set   in   the   attr_names.item   structure;   the
       78*   mrds_dsm_rel_block and mrds_dsm_entry_dcls include files were added.
       79*
       80*   80-09-23  Davids: modified so that att_names.item.r_perm and u_perm are set
       81*   to "1"b when opening is done via the model.
       82*
       83*   81-01-14  Davids:  modified  to  use the new relation_block structure which
       84*   individually names the attribute access bits.
       85*
       86*   81-01-23  Jim  Gray  :  added  last_model_attr_char_var  bit  to  att_names
       87*   interface  structure,  so that partial view submodels can properly find the
       88*   end of tuple.
       89*
       90*   81-05-29   Jim   Gray   :   modified   to  use  resultant  structures,  and
       91*   mdbm_rel_att_array include file without foreign key info.
       92*
       93*   81-07-01  Rickie  E.  Brinegar: modified to set last_model_attr_char_var to
       94*   "1"b if the current attribute is character varying and to set it to "0"b if
       95*   the  current  attribute  is  bit varying.  This guarantees that if the last
       96*   varying attribute in the definition order character type (implying the last
       97*   attribute    in    the    tuple    will    be   character   varying)   then
       98*   att_names.last_model_attr_char_var  is  set.  This is a part of the fix for
       99*   TR 9755.
      100*
      101*   82-06-03 Mike Kubicar : added fix for TR phx12282.  The problem was that
      102*   last_mode_attr_char_var could be set incorrectly if a submodel instead of
      103*   a model were opened.
      104*
      105**/
      106 
      107 /* initialize */
      108 
      109 	error_code = 0;
      110 	ans_ptr = null;
      111 
      112 /* get the rel_info pointer, and number of attributes from the rel_name array */
      113 
      114 	ri_ptr = rel_names.item.ri_ptr (rel_index);
      115 	num_atts_init = rel_names.item.natts (rel_index);
      116 
      117 /* initialize the attribute array to be returned */
      118 
      119 	allocate att_names in (work_area);
      120 	unspec (att_names) = "0"b;
      121 	att_names.num = num_atts_init;
      122 
      123 /* fill in the attribute array information */
      124 
      125 	if dsm_sw then
      126 	     call submodel_relation ();
      127 	else call model_relation ();
      128 
      129 	return;
      130 
      131 submodel_relation:
      132      procedure ();
      133 
      134 /* call the submodel(opened in a higher routine) to get the
      135*   attributes involved with this submodel definition of this relation */
      136 
      137 	num_dims = 0;
      138 	call mrds_dsm_read_relation (rel_names.item.sm (rel_index), wa_ptr, relation_block_ptr, submodel_iocb_ptr, error_code);
      139 	if error_code ^= 0 then
      140 	     call
      141 		sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      142 		"Unable to get the attribute information for submodel relation ""^a"".", rel_names.item (rel_index).sm);
      143 	else if relation_block.version ^= RELATION_BLOCK_VERSION_1 then do;
      144 		error_code = error_table_$unimplemented_version;
      145 		call
      146 		     sub_err_ (error_table_$unimplemented_version, caller_name, continue, info_ptr, return_value,
      147 		     "Expecting version ^d of the relation_block structure, got version ^d.", RELATION_BLOCK_VERSION_1,
      148 		     relation_block.version);
      149 	     end;
      150 	else do;
      151 
      152 /* go through all attributes defined for this submodel relation */
      153 
      154 		j = 0;				/* no key attrs yet */
      155 		k = 0;
      156 		do i = 1 to relation_block_ptr -> relation_block.no_rb_attributes;
      157 
      158 /* search the model attribute list for this relation,
      159*   to find the current submodel attribute, in order to get
      160*   the correct attr_info for this attribute */
      161 
      162 		     do ai_ptr = ptr (ri_ptr, rel_info.attr_ptr) repeat ptr (ri_ptr, attr_info.fwd_thread)
      163 			while (attr_info.name ^= relation_block.attribute_info.dm_attr_name (i) &  attr_info.fwd_thread ^= NULL_OFFSET);
      164 		     end;
      165 
      166 /* fill in the att_name array slot for this submodel attribute */
      167 
      168 		     if (attr_info.fwd_thread = NULL_OFFSET & attr_info.name ^= relation_block.attribute_info.dm_attr_name (i))
      169 		     then do;
      170 			error_code = mrds_error_$inconsistent_submodel;
      171 			call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, 
      172 			"Attribute ""^a"" in the submodel does not correspond to an attribute in the model. Please correct and recreate the submodel.", rtrim (relation_block.attribute_info.dm_attr_name (i)));
      173 			end;
      174 		     att_names.item.sm (i) = relation_block.attribute_info.dsm_attr_name (i);
      175 		     att_names.item.dm (i) = attr_info.name;
      176 		     att_names.item.ai_ptr (i) = ai_ptr;
      177 		     att_names.item.di_ptr (i), di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      178 		     att_names.item.rai_ptr (i) = null;
      179 		     att_names.item.r_perm (i) = relation_block.attribute_info.attr_access.read (i);
      180 		     att_names.item.u_perm (i) = relation_block.attribute_info.attr_access.modify (i);
      181 
      182 /* count up key and varying attributes */
      183 
      184 		     if attr_info.key_attr
      185 		     then j = j + 1;
      186 
      187 		     if domain_info.db_desc_is_ptr then
      188 			desc_ptr = addr (domain_info.db_desc) -> pointer_format;
      189 		     else desc_ptr = addr (domain_info.db_desc);
      190 
      191 		     if descriptor.type = 20 | descriptor.type = 22
      192 		     then k = k + 1;		/* this is a varying bit or char string data type */
      193 		end;
      194 
      195 		att_names.num_key_attrs = j;
      196 		att_names.num_varying_attrs = k;
      197 	     end;
      198 
      199 /* find out if the last attr in the model is character or not */
      200 
      201 	i = 1;
      202 	do ai_ptr = ptr (ri_ptr, rel_info.attr_ptr) repeat ptr (ri_ptr, attr_info.fwd_thread) while (i <= rel_info.num_attr);
      203 	     i = i + 1;
      204 	end;
      205 
      206 	     di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      207 
      208 	     if domain_info.db_desc_is_ptr then
      209 		desc_ptr = addr (domain_info.db_desc) -> pointer_format;
      210 	     else desc_ptr = addr (domain_info.db_desc);
      211 
      212 	     if descriptor.type = 22 then
      213 		att_names.last_model_attr_char_var = "1"b;
      214 	     else if descriptor.type = 20 then
      215 		att_names.last_model_attr_char_var = "0"b;
      216 
      217      end;
      218 
      219 model_relation:
      220      procedure ();
      221 
      222 /* go through the model's list of attributes for this relation,
      223*   and fill in the attribute array to be returned */
      224 
      225 	i = 1;
      226 	do ai_ptr = ptr (ri_ptr, rel_info.attr_ptr) repeat ptr (ri_ptr, attr_info.fwd_thread) while (i <= att_names.num);
      227 
      228 	     att_names.item.sm (i) = attr_info.name;
      229 	     att_names.item.dm (i) = attr_info.name;
      230 	     att_names.item.ai_ptr (i) = ai_ptr;
      231 	     att_names.item.di_ptr (i), di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      232 	     att_names.item.rai_ptr (i) = null;
      233 	     att_names.item.r_perm = "1"b;		/* opening via the model gives complete access */
      234 	     att_names.item.u_perm = "1"b;
      235 
      236 
      237 	     if domain_info.db_desc_is_ptr then
      238 		desc_ptr = addr (domain_info.db_desc) -> pointer_format;
      239 	     else desc_ptr = addr (domain_info.db_desc);
      240 
      241 	     if descriptor.type = 22 then
      242 		att_names.last_model_attr_char_var = "1"b;
      243 	     else if descriptor.type = 20 then
      244 		att_names.last_model_attr_char_var = "0"b;
      245 
      246 	     i = i + 1;
      247 
      248 	end;
      249 
      250 /* set the number of key and varying attributes */
      251 
      252 	att_names.num_key_attrs = rel_info.num_key_attrs;
      253 	att_names.num_varying_attrs = rel_info.nvar_atts;
      254 
      255      end;
      256 
      257 	dcl     wa_ptr		 ptr;		/* points to working area */
      258 	dcl     (i, j, k)		 fixed bin;	/* index variable */
      259 	dcl     rel_index		 fixed bin;	/* index into rel_names structure */
      260 	dcl     error_code		 fixed bin (35);
      261 
      262 	dcl     dsm_sw		 bit (1) unal;	/* ON => data submodel was used to open the data base */
      263 
      264 	dcl     work_area		 area based (wa_ptr);
      265 
      266 	dcl     (ptr, addr, null, unspec) builtin;
      267 
      268 	dcl     error_table_$unimplemented_version fixed bin (35) ext;
      269           dcl     mrds_error_$inconsistent_submodel fixed bin(35) ext static;
      270 
      271 	declare caller_name		 char (20) init ("mrds_dsl_ready_file") int static options (constant);
      272 						/* name of calling routine */
      273 	declare continue		 char (1) init ("c") int static options (constant);
      274 						/* no stop after printing */
      275           declare NULL_OFFSET            bit (18) unaligned int static options (constant) init ((18)"1"b);
      276 	declare info_ptr		 ptr init (null ());/* unused */
      277 	declare return_value	 fixed bin (35);	/* unused */
      278 	declare sub_err_		 entry options (variable); /* error reporting routine */
      279 	declare submodel_iocb_ptr	 ext ptr init (null); /* Set in mrds_dsl_init_res, used by
      280*						   mu_sec_init_res and
      281*						   mus_get_rel_names. */
      282 	declare pointer_format	 ptr based;	/* overlay to pick up a pointer */
      283 
  1     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  1     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  1     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  1     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  1     5 
  1     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  1     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  1     8     2 type unsigned fixed bin (6) unal,			/* data type */
  1     9     2 packed bit (1) unal,				/* on if data item is packed */
  1    10     2 number_dims bit (4) unal,			/* dimensions */
  1    11     2 size,					/* size for string data */
  1    12       3 scale bit (12) unal,				/* scale for num. data */
  1    13       3 precision bit (12) unal,			/* prec. for num. data */
  1    14     2 array_info (num_dims),
  1    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  1    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  1    17       3 multiplier fixed bin (35);			/*  element separation */
  1    18 
  1    19 dcl  desc_ptr ptr;
  1    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  1    21 
  1    22 /* END mdbm_descriptor.incl.pl1 */
  1    23 
  1    24 
      284 
      285 
  2     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  2     8*     to add mdbm_secured bit in db_model
  2     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  2    10*     collapsed the following into an unused_offset array:
  2    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  2    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  2    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  2    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  2    15*       unused_1
  2    16*     Also changed the name of unused_2 to restructuring_history_offset
  2    17*     and changed the comment on the changer structure to indicate
  2    18*     that it will contain on database creation information.
  2    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  2    20*     used one of the unused_offsets to point to a message which indicates
  2    21*     why the db is inconsistent. The offset will be null when the db is created
  2    22*     and set the first time the message is used. this is so it will be
  2    23*     consistent with existing data bases. Also added the message structure.
  2    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  2    25*     added the undo_request element to the message structure
  2    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  2    27*     changed unused_offset (12) to last_restructruring_history_offset and
  2    28*     changed restructuring_history_offset to first_restructuring_history_offset
  2    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  2    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  2    31*     1 => vfile database and 2 => page_file database. Up to this point all
  2    32*     database types were equal to 1.
  2    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  2    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  2    35*     flags. This will allow information about transactions and dm_file
  2    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  2    37*     change is compatable with all datamodels created by the released version
  2    38*     of mrds.
  2    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  2    40*     added the rollback_on flag to the db_type_flags since it appears that you
  2    41*     can have a dmfile database that requires transactions but does not have any
  2    42*     journalizing. Also switched the order of the transactions_needed and
  2    43*     concurrency_on flags - this makes the change compatable with existing
  2    44*     dmfile databases except when displaying the model since concurrency_on and
  2    45*     rollback_on will be off in the model even though the dmfile relations had
  2    46*     them on during creation.
  2    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  2    48*      Removed ctl_file_path_ptr.
  2    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  2    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  2    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  2    53*      in the flag word for rmdb copying.
  2    54*                                                   END HISTORY COMMENTS */
  2    55 
  2    56 
  2    57 /* this include file contains the structures that go into the make up
  2    58*   of the "db_model" segment in the model for the database.
  2    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  2    60*
  2    61*   the db_model structure goes at the base of the segment, and contains items unique to
  2    62*   the whole databse. in addition, it has an area of size to fill the
  2    63*   rest of a segment, that holds the lists of files and domains in the database.
  2    64*   these lists are singly forward linked lists. all "pointers" in the database model
  2    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  2    66*   since actual pointers are process dependent on segment number.
  2    67*   the remaining structures are first a path_entry one to save pathnames in,
  2    68*   and the stack_item and constent structures, used to save a boolean
  2    69*   expression in polish form, with the stack represented by a linked list.
  2    70*   the final structure is one for identifying the status of version information */
  2    71 
  2    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  2    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  2    74 	     2 db_type_flags      unal,
  2    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  2    76 	       3 unused	      (13) bit (1) unal,
  2    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  2    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  2    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  2    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  2    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  2    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  2    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  2    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  2    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  2    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  2    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  2    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  2    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  2    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  2    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  2    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  2    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  2    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  2    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  2    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  2    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  2    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  2    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  2   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  2   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  2   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  2   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  2   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  2   105 
  2   106      dcl	   dbm_ptr	      ptr;
  2   107 
  2   108 /* the files in the database each have a file_info containing
  2   109*   their name, the file_model for each file is found by initiating the
  2   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  2   111*   the file_info list is a singly linked list in definition order */
  2   112 
  2   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  2   114 	     2 file_name	      char (30),		/* name of file */
  2   115 	     2 file_id	      bit (36),		/* id number of file */
  2   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  2   117 	     2 unused	      unal bit (18);	/* for future expansion */
  2   118 
  2   119      dcl	   fi_ptr		      ptr;
  2   120 
  2   121 /* each domain used in the database will have a domain info saved in the db_model
  2   122*   segment. it describes the domain of the given name, and it's options.
  2   123*   the domain_info's form a singly linked list in definition order */
  2   124 
  2   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  2   126 	     2 name	      char (32),		/* name of domain */
  2   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  2   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  2   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  2   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  2   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  2   132 	     2 reserved	      bit (31) unal,
  2   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  2   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  2   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  2   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  2   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  2   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  2   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  2   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  2   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  2   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  2   143 	     2 str_err_path_ptr   unal bit (18),
  2   144 	     2 str_after_path_ptr unal bit (18),
  2   145 	     2 get_before_path_ptr unal bit (18),
  2   146 	     2 get_err_path_ptr   unal bit (18),
  2   147 	     2 get_after_path_ptr unal bit (18),
  2   148 	     2 mod_before_path_ptr unal bit (18),
  2   149 	     2 mod_err_path_ptr   unal bit (18),
  2   150 	     2 mod_after_path_ptr unal bit (18),
  2   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  2   152 	     2 unused_2	      unal bit (18),
  2   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  2   154 
  2   155      dcl	   di_ptr		      ptr;
  2   156 
  2   157 /* information necessary for attributes that are not used in any relation */
  2   158 
  2   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  2   160 	     2 name char (32),			/* name of attribute */
  2   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  2   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  2   163 	     2 unused (2) bit (18) unal;
  2   164 
  2   165      dcl     ua_ptr ptr;
  2   166 
  2   167 
  2   168 /* space saving pathname$entryname structure, to be allocated
  2   169*   only when a path$entry has to be saved, else only a bit(18)
  2   170*   offset takes up space in the main model structure */
  2   171 
  2   172      declare 1 path_entry	      based (path_entry_ptr),
  2   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  2   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  2   175 	     2 reserved	      unal bit (36);	/* for future use */
  2   176 
  2   177      declare path_entry_ptr	      ptr;
  2   178 
  2   179 
  2   180 
  2   181 
  2   182 
  2   183 /* declarations for model of postfix stack holding the check option boolean expression
  2   184*   the following encoding values indicate the corresponding type of stack element
  2   185*
  2   186*   1  =
  2   187*   2  ^=
  2   188*   3  >
  2   189*   4  <
  2   190*   5  >=
  2   191*   6  <=
  2   192*
  2   193*   10  and
  2   194*   20  or
  2   195*   30  not
  2   196*
  2   197*   40  - (minus)
  2   198*
  2   199*   50  domain variable(same name as domain)
  2   200*
  2   201*   60  constant(number, bit string, or character string)
  2   202*
  2   203**/
  2   204 
  2   205 
  2   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  2   207 	     2 next	      bit (18),		/* link to next in list */
  2   208 	     2 type	      fixed binary,		/* code for this element type */
  2   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  2   210*						   if this is a constant element type */
  2   211 
  2   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  2   213 
  2   214 
  2   215 
  2   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  2   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  2   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  2   219 
  2   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  2   221 
  2   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  2   223 
  2   224 /* version structure, giving status of source for CMDB/RMDB,
  2   225*   status of model, and status of resultant */
  2   226 
  2   227 /* version number is in form MM.N.Y
  2   228*   where MM is the major version number, N is the minor version alteration,
  2   229*   and Y is the lastest modification to that alteration,
  2   230*   where M and N represent numbers 0-9, and Y is a letter */
  2   231 
  2   232      declare 1 version_status	      unal based (version_status_ptr),
  2   233 	     2 cmdb_rmdb,
  2   234 	       3 major	      fixed bin,
  2   235 	       3 minor	      fixed bin,
  2   236 	       3 modification     char (4),
  2   237 	     2 model,
  2   238 	       3 major	      fixed bin,
  2   239 	       3 minor	      fixed bin,
  2   240 	       3 modification     char (4),
  2   241 	     2 resultant,
  2   242 	       3 major	      fixed bin,
  2   243 	       3 minor	      fixed bin,
  2   244 	       3 modification     char (4);
  2   245 
  2   246      declare version_status_ptr     ptr;
  2   247 
  2   248 
  2   249 /* maintains information only about the db creation */
  2   250 
  2   251      declare 1 changer	      unal based (changer_ptr),
  2   252 	     2 id		      char (32),
  2   253 	     2 time	      fixed bin (71),
  2   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  2   255 
  2   256      declare changer_ptr	      ptr;
  2   257 
  2   258 
  2   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  2   260 	     02 len	      fixed bin,		/* length of the message */
  2   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  2   262 	     02 name	      char (32),		/* name of thing that set the message */
  2   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  2   264*                                                               that caused the database to become inconsistent */
  2   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  2   266 
  2   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  2   268 
  2   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  2   270 
  2   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  2   272 
  2   273 
      286 
      287 
  3     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  3     6*     modified to save space occupied by model
  3     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  3     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  3     9*     the number of secondary indices in the relation - it was always zero.
  3    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  3    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  3    12*     DMS conversion.
  3    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  3    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  3    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  3    16*     for relation manager changes.
  3    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  3    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  3    20*     <rel> files are good (for rmdb)
  3    21*                                                   END HISTORY COMMENTS */
  3    22 
  3    23 
  3    24 /* each file in the database will have a model segment with the name
  3    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  3    26*   the file_model structure is allocated at the base of the segment for a given file.
  3    27*   it contains an area with which all other structures in this include file are allocated.
  3    28*   these structures contain the information about which relations, foreign keys,
  3    29*   and attributes are members of this file. all lists are singly linked lists in
  3    30*   definition order. pointers to these structures are obtained by using the "pointer"
  3    31*   builtin function with arguments of the segment base pointer, and the
  3    32*   offset (bit (18)) relative to that pointer that is actually stored in
  3    33*   the file model itself. this is because pointer segment numbers are
  3    34*   per process dependent. the major lists pointed to by the file_model structure
  3    35*   are the list of relations in this file(each with a contained attribute list),
  3    36*   and the list of foreign keys whose parent relation resides in this file
  3    37*   (along with a participating attribute sublist, and the child relation list,
  3    38*   if they are also in this file) */
  3    39 
  3    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  3    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  3    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  3    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  3    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  3    45     2 reserved bit (32) unal,				/* reserved for future flags */
  3    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  3    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  3    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  3    49     2 pad_1 fixed bin (35),				/* for future use */
  3    50     2 pad_2 fixed bin (35),
  3    51     2 ratd_len fixed bin (21),			/* length of above */
  3    52     2 mratd_len fixed bin (21),			/* length of above */
  3    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  3    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  3    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  3    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  3    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  3    58     2 block_size unal fixed bin,			/* no. pages in block */
  3    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  3    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  3    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  3    62     2 num_rels unal fixed bin,			/* number of relations in file */
  3    63     2 num_links unal fixed bin,			/* number of links in file */
  3    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  3    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  3    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  3    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  3    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  3    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  3    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  3    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  3    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  3    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  3    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  3    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  3    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  3    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    78     2 open_eu_err_path_ptr unal bit (18),
  3    79     2 open_eu_after_path_ptr unal bit (18),
  3    80     2 open_er_before_path_ptr unal bit (18),
  3    81     2 open_er_err_path_ptr unal bit (18),
  3    82     2 open_er_after_path_ptr unal bit (18),
  3    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  3    84     2 open_neu_err_path_ptr unal bit (18),
  3    85     2 open_neu_after_path_ptr unal bit (18),
  3    86     2 open_ner_before_path_ptr unal bit (18),
  3    87     2 open_ner_err_path_ptr unal bit (18),
  3    88     2 open_ner_after_path_ptr unal bit (18),
  3    89     2 open_pu_before_path_ptr unal bit (18),
  3    90     2 open_pu_err_path_ptr unal bit (18),
  3    91     2 open_pu_after_path_ptr unal bit (18),
  3    92     2 open_pr_before_path_ptr unal bit (18),
  3    93     2 open_pr_err_path_ptr unal bit (18),
  3    94     2 open_pr_after_path_ptr unal bit (18),
  3    95     2 open_cu_before_path_ptr unal bit (18),
  3    96     2 open_cu_err_path_ptr unal bit (18),
  3    97     2 open_cu_after_path_ptr unal bit (18),
  3    98     2 open_cr_before_path_ptr unal bit (18),
  3    99     2 open_cr_err_path_ptr unal bit (18),
  3   100     2 open_cr_after_path_ptr unal bit (18),
  3   101     2 close_before_path_ptr unal bit (18),
  3   102     2 close_err_path_ptr unal bit (18),
  3   103     2 close_after_path_ptr unal bit (18),
  3   104     2 unused_1 unal bit (18),				/* for future expansion */
  3   105     2 unused_2 unal bit (18),
  3   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  3   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  3   108 dcl  fm_ptr ptr;
  3   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  3   110 dcl  atd_ptr ptr;
  3   111 dcl  atd_len fixed bin;
  3   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  3   113     2 ncomponents fixed bin,
  3   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  3   115 dcl  cna_ptr ptr;
  3   116 dcl  ncomp_init fixed bin;
  3   117 
  3   118 /* a rel_info structure contains information describing a relation.
  3   119*   a relation may only occur in one file, thus there is one rel_info
  3   120*   per relation per database, each stored in the file_model area for
  3   121*   the file that contains it. the list of rel_info's in this file
  3   122*   form a singly linked list in definition order.
  3   123*   the rel_info itself points to a list of the attributes it contains,
  3   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  3   125 
  3   126 dcl 1 rel_info aligned based (ri_ptr),
  3   127     2 name char (32),				/* relation name */
  3   128     2 id  bit (36) aligned,				/* relation id number */
  3   129     2 hashed bit (1) unal,				/* on if hashed */
  3   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  3   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  3   132     2 system bit (1) unal,				/* on if dont care how stored */
  3   133     2 indexed bit (1) unal,				/* on if secondary index */
  3   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  3   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  3   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  3   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   138     2 reserved bit (27) unal,				/* for future flags */
  3   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  3   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  3   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  3   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  3   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  3   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  3   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  3   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  3   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  3   148     2 unused_3 unal fixed bin,			/* element that was never used */
  3   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  3   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  3   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  3   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  3   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  3   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  3   155     2 attr_ptr unal bit (18),				/* to attr. info */
  3   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  3   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  3   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  3   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  3   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  3   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  3   162     2 link_err_path_ptr unal bit (18),
  3   163     2 link_after_path_ptr unal bit (18),
  3   164     2 unlk_before_path_ptr unal bit (18),
  3   165     2 unlk_err_path_ptr unal bit (18),
  3   166     2 unlk_after_path_ptr unal bit (18),
  3   167     2 str_before_path_ptr unal bit (18),
  3   168     2 str_err_path_ptr unal bit (18),
  3   169     2 str_after_path_ptr unal bit (18),
  3   170     2 del_before_path_ptr unal bit (18),
  3   171     2 del_err_path_ptr unal bit (18),
  3   172     2 del_after_path_ptr unal bit (18),
  3   173     2 mod_before_path_ptr unal bit (18),
  3   174     2 mod_err_path_ptr unal bit (18),
  3   175     2 mod_after_path_ptr unal bit (18),
  3   176     2 find_before_path_ptr unal bit (18),
  3   177     2 find_err_path_ptr unal bit (18),
  3   178     2 find_after_path_ptr unal bit (18),
  3   179     2 retr_before_path_ptr unal bit (18),
  3   180     2 retr_err_path_ptr unal bit (18),
  3   181     2 retr_after_path_ptr unal bit (18),
  3   182     2 unused_1 unal bit (18),				/* for future expansion */
  3   183     2 unused_2 unal bit (18),
  3   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   185 dcl  ri_ptr ptr;
  3   186 
  3   187 /* a attr_info structure contains information about an attribute in a given relation.
  3   188*   since attributes may appear in more than one relation, each occurence of an attribute
  3   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  3   190*   the list is singly linked in definition order. the attr_info describes
  3   191*   the data it represents, and how that data is used during a database search. */
  3   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  3   193     2 name char (32),				/* name of attribute */
  3   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  3   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  3   196     2 link_attr bit (1) unal,				/* on if participates in link */
  3   197     2 reserved bit (33) unal,
  3   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  3   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  3   200     2 key_order unal fixed bin,			/* relative posit. in key */
  3   201     2 bit_offset fixed bin (35),			/* position in tuple */
  3   202     2 bit_length fixed bin (35),			/* length if fixed */
  3   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  3   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  3   205     2 domain_ptr unal bit (18),			/* to domain info */
  3   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  3   207     2 fwd_thread unal bit (18),			/* to next in list */
  3   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  3   209 dcl  ai_ptr ptr;
  3   210 
  3   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  3   212*   each time a foreign key definition indicates a relation as it's parent,
  3   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  3   214*   a relation can be parent and/or child in any number of foreign keys.
  3   215*   the parent_link_info structure describes the foreign key, and also points
  3   216*   to a list of the attributes that participate in this foreign key.
  3   217*   (this could be from 1 up to all attributes in the relation)
  3   218*   the attr_list structures are in a singly linked list in definition order
  3   219*   for this purpose. also pointed to is a list of child_link_info's
  3   220*   that describe the child relations in this foreign key. since foreign keys
  3   221*   may span files, not all related child_link_info's have to be in this file's
  3   222*   model area. */
  3   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  3   224     2 name char (32),				/* name of link */
  3   225     2 singular bit (1) unal,				/* on if system owned link */
  3   226     2 temp bit (1) unal,				/* on if temp. order */
  3   227     2 first bit (1) unal,				/* insertion indicators */
  3   228     2 last bit (1) unal,
  3   229     2 next bit (1) unal,
  3   230     2 prior bit (1) unal,
  3   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  3   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  3   233     2 dup_first bit (1) unal,				/* duplicates first */
  3   234     2 dup_last bit (1) unal,				/* duplicates last */
  3   235     2 indexed bit (1) unal,				/* locate parent via index */
  3   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  3   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  3   238     2 thread_27 bit (1) unal,
  3   239     2 thread_18 bit (1) unal,
  3   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  3   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  3   242     2 reserved bit (19) unal,				/* reserved for future flags */
  3   243     2 index_id aligned bit (8),			/* id of index if indexed */
  3   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  3   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  3   246     2 n_children unal fixed bin,			/* no. children in link */
  3   247     2 child_fn char (30),				/* file name for first child in list */
  3   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  3   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  3   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  3   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  3   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   254     2 sort_err_path_ptr unal bit (18),
  3   255     2 sort_after_path_ptr unal bit (18),
  3   256     2 srch_before_path_ptr unal bit (18),
  3   257     2 srch_err_path_ptr unal bit (18),
  3   258     2 srch_after_path_ptr unal bit (18),
  3   259     2 link_before_path_ptr unal bit (18),
  3   260     2 link_err_path_ptr unal bit (18),
  3   261     2 link_after_path_ptr unal bit (18),
  3   262     2 unlk_before_path_ptr unal bit (18),
  3   263     2 unlk_err_path_ptr unal bit (18),
  3   264     2 unlk_after_path_ptr unal bit (18),
  3   265     2 unused_1 unal bit (18),				/* for future expansion */
  3   266     2 unused_2 unal bit (18),
  3   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  3   268 dcl  pli_ptr ptr;
  3   269 
  3   270 /* a child_link_info structure is the counter part of a parent_link_info
  3   271*   for foreign key child relations. each time a relation is defined to be
  3   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  3   273*   this list is singly linked in foreign key definition order.
  3   274*   the child_link_info points to a list of participating attributes from the
  3   275*   child relation by means of a singly linked list of attr_list structures
  3   276*   in definition order. the number of attributes in the parent attr_list
  3   277*   and the child attr_list lists are the same with corresponding attr_list
  3   278*   attributes having the same domain. all child_link_infos in this file
  3   279*   are on a seperately linked list. this may not include all
  3   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  3   281*   since foreign keys may span files, and the child_link_info will
  3   282*   reside in the file containing it's associated relation_info. */
  3   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  3   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  3   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  3   286     2 fixed bit (1) unal,				/* on if membership fixed */
  3   287     2 optional bit (1) unal,				/* on if membership optional */
  3   288     2 auto bit (1) unal,				/* on if insertion automatic */
  3   289     2 manual bit (1) unal,				/* on if insertion manual */
  3   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  3   291     2 range_sel bit (1) unal,				/* on if range type selection */
  3   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  3   293     2 key_dup_last bit (1) unal,
  3   294     2 key_null bit (1) unal,				/* on if null allowed */
  3   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  3   296     2 sel_current bit (1) unal,
  3   297     2 sel_key bit (1) unal,
  3   298     2 sel_proc bit (1) unal,
  3   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  3   300     2 reserved bit (21) unal,
  3   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  3   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  3   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  3   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  3   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  3   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  3   307     2 parent_fn char (30),				/* file name for parent info */
  3   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  3   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  3   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  3   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  3   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  3   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  3   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  3   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  3   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  3   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  3   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  3   319     2 link_err_path_ptr unal bit (18),
  3   320     2 link_after_path_ptr unal bit (18),
  3   321     2 unlk_before_path_ptr unal bit (18),
  3   322     2 unlk_err_path_ptr unal bit (18),
  3   323     2 unlk_after_path_ptr unal bit (18),
  3   324     2 srch_before_path_ptr unal bit (18),
  3   325     2 srch_err_path_ptr unal bit (18),
  3   326     2 srch_after_path_ptr unal bit (18),
  3   327     2 unused_1 unal bit (18),				/* for future expansion */
  3   328     2 unused_2 unal bit (18) ;
  3   329 dcl  cli_ptr ptr;
  3   330 
  3   331 /* the attr_list structure is associated with the parent_link_info
  3   332*   and child_link_info structures to represent by means of a singly linked list
  3   333*   the participating attributes from relations in a foreign key.
  3   334*   the parent_link_info has a list for the parent relation,
  3   335*   and the child_link_info has a list for the child relation.
  3   336*   the participating attributes are a subset(not necessary proper) of
  3   337*   those attributes contained in a relation definition.
  3   338*   there are equal numbers of attr_list structures in the parent and
  3   339*   child lists of the same foreign key. the corresponding attributes in these
  3   340*   lists must have the same domain. */
  3   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  3   342     2 attr_fn char (30),				/* file name for attr. */
  3   343     2 attr_ptr unal bit (18),				/* to attr info block */
  3   344     2 fwd_thread unal bit (18);			/* to next in list */
  3   345 dcl  al_ptr ptr;
  3   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  3   347     2 ascend bit (1) unal,				/* ascending order */
  3   348     2 descend bit (1) unal,				/* descending order */
  3   349     2 reserved bit (34) unal,
  3   350     2 attr_ptr unal bit (18),				/* to attr info */
  3   351     2 fwd_thread unal bit (18);			/* to next in list */
  3   352 dcl  sk_ptr ptr;
  3   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  3   354     2 attr_ptr unal bit (18),				/* to attr info */
  3   355     2 fwd_thread unal bit (18);			/* to next in list */
  3   356 dcl  dp_ptr ptr;
  3   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  3   358     2 link_fn char (30),				/* file name for thru link */
  3   359     2 link_ptr unal bit (18),				/* to parent link info */
  3   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  3   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  3   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  3   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  3   364     2 fwd_thread unal bit (18);			/* to next in chain */
  3   365 dcl  sc_ptr ptr;
  3   366 
  3   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  3   368 
  3   369 
      288 
      289 
  4     1 /* BEGIN mdbm_rel_att_array.incl.pl1 -- odf 8/21/78 */
  4     2 /* modified by Jim Gray - - June/July 1979 to add key/varying attr counts and comments
  4     3*   Modified by Jim Gray - - April 1980, to add submodel's total_view bit to rel_names.
  4     4*   Modified by Lindsey Spratt - - August 1980, to add security permission bits to rel/att_names.
  4     5*   Modified by Jim Gray - - 80-11-06, to change s_perm = append_tuple_perm,
  4     6*   d_perm = delete_tuple_perm, r_perm = status_perm, m_perm = unused_perm.
  4     7*
  4     8*   81-01-23 Jim Gray : added bit to att_names so that the resultant can
  4     9*   be build for partial view submodels, and know whether the last varying attr
  4    10*   is a character or bit string type, for determining the bit offset of end of tuple.
  4    11*
  4    12*   81-05-28 Jim Gray : removed structures for foreign key interface.
  4    13*
  4    14*
  4    15*
  4    16*   NOTE: These structures are used as the parameters in the "mus_get_" routines
  4    17*   that are called by mu_sec_make_res, to return the users view of
  4    18*   either the model or submodel he has opened with. */
  4    19 
  4    20 dcl 1 rel_names based (rns_ptr),			/* array of relations in a file to be readied */
  4    21     2 num fixed bin,				/* nbr. of relations in this file */
  4    22     2 item (num_rels_init refer (rel_names.num)),
  4    23       3 sm char (32),				/* submodel name of relation */
  4    24       3 dm char (32),				/* data model name */
  4    25       3 natts fixed bin,				/* nbr. of attrs. in this relation */
  4    26       3 ri_ptr ptr,					/* points to rel_info in file_model */
  4    27       3 total_view bit (1) unal,			/* ON --> all attrs in model rel present */
  4    28       3 status_perm bit (1) unal,			/* ON --> opener has permission to look at relation */
  4    29       3 append_tuple_perm bit (1) unal,			/* ON --> opener has permission to store into this relation */
  4    30       3 delete_tuple_perm bit (1) unal,			/* ON --> opener has permission to delete tuples */
  4    31       3 unused_perm bit (1) unal,			/* unused perm */
  4    32       3 pad bit (31) unal ;				/* for future use */
  4    33 
  4    34 dcl 1 att_names based (ans_ptr),			/* array of attributes in a relation */
  4    35     2 num fixed bin,				/* attributes in a relation */
  4    36     2 num_key_attrs fixed bin,			/* number of key attributes in model/submodel relation */
  4    37     2 num_varying_attrs fixed bin,			/* count of varying bit/char data type attrs */
  4    38     2 last_model_attr_char_var bit (1) unal,		/* on => last attr in model view is char varying */
  4    39     2 mbz bit (35) unal,				/* for future use */
  4    40     2 item (num_atts_init refer (att_names.num)),
  4    41       3 sm char (32),				/* submodel name */
  4    42       3 dm char (32),				/* data model name */
  4    43       3 ai_ptr ptr,					/* points to attr_info in file_model */
  4    44       3 di_ptr ptr,					/* points to domain_info in file_model */
  4    45       3 rai_ptr ptr,				/* points to attr info in resultant model */
  4    46       3 r_perm bit (1) unal,				/* ON --> opener has permission to retrieve attribute */
  4    47       3 u_perm bit (1) unal,				/* ON --> opener has permission to update attribute */
  4    48       3 pad bit (34) unal;				/* future use */
  4    49 
  4    50 dcl  num_rels_init fixed bin;
  4    51 dcl  num_atts_init fixed bin;
  4    52 
  4    53 dcl  rns_ptr ptr;
  4    54 dcl  ans_ptr ptr;
  4    55 
  4    56 /* END mdbm_rel_att_array.incl.pl1 */
  4    57 
      290 
      291 
  5     1 /*	BEGIN INCLUDE FILE		mrds_dsm_rel_block.incl.pl1
  5     2*
  5     3*   Created October, 1975 for release in MR 4.0
  5     4*
  5     5*   The relation_block contains the relation name and  the  attribute
  5     6*   names and access information
  5     7*
  5     8*   HISTORY
  5     9*
  5    10*   80-04-10 Spratt: changed to have version  number,  be  explicitly
  5    11*   .        based, use an automatic variable in the refer for num of
  5    12*   .        attributes,  add access flags for rel and attr's, remove
  5    13*   .        attr key flags. This is for the  first  Attribute  Level
  5    14*   .        Security version of MRDS.
  5    15*
  5    16*   81-01-14 Davids: increased submodel rel  and  attr  names  to  64
  5    17*   .        characters and made dsm_rel_name char  varying.  changed
  5    18*   .        access  bits  from  a  bit  string to individually named
  5    19*   .        flags.
  5    20**/
  5    21 
  5    22 dcl  relation_block_ptr ptr;
  5    23 dcl  rb_number_of_attributes fixed bin (35);
  5    24 dcl  RELATION_BLOCK_VERSION_1 fixed bin (35) internal static options (constant) init (1);
  5    25 
  5    26 dcl 1 relation_block based (relation_block_ptr),
  5    27 						/* Relation block */
  5    28     2 version fixed bin (35),
  5    29     2 dsm_rel_name char (64) varying,			/* Data submodel relation name */
  5    30     2 dm_rel_name char (32),				/* Data model relation name */
  5    31     2 rel_access unal,
  5    32       3 append bit (1),
  5    33       3 delete bit (1),
  5    34       3 null bit (1),
  5    35       3 mbz1 bit (33),
  5    36     2 no_rb_attributes fixed bin,			/* The number of attributes in this relation */
  5    37     2 attribute_info (rb_number_of_attributes refer (relation_block.no_rb_attributes)),
  5    38       3 dsm_attr_name char (64) varying,		/* Data submodel attribute name */
  5    39       3 attr_access unal,				/* Data submodel attribute flags */
  5    40         4 read bit (1),
  5    41         4 modify bit (1),
  5    42         4 null bit (1),
  5    43         4 mbz2 bit (33),				/* For future use */
  5    44       3 dm_attr_name char (32) varying,			/* Data model attribute name */
  5    45       3 dm_attr_flags,				/* Data model attribute flags */
  5    46         4 mbz3 bit (36);				/* For future use */
  5    47 
  5    48 /* 	END INCLUDE FILE 		mrds_dsm_rel_block.incl.pl1  */
  5    49 
      292 
  6     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_entry_dcls.incl.pl1 */
  6     2 /* Written by Lindsey Spratt - - 80-10-24 */
  6     3 /* Modified by Jim Gray - - 80-11-13, to remove  declarations of non-existant modules */
  6     4 
  6     5 /* format: style2 */
  6     6 dcl  mrds_dsm_close entry (ptr, fixed bin (35));
  6     7 dcl  mrds_dsm_close$force entry (ptr);
  6     8 dcl  mrds_dsm_copy entry (char (*), char (*), fixed bin (35));
  6     9 dcl  mrds_dsm_set_db_path entry (ptr, char (*), fixed bin (35));
  6    10 dcl  mrds_dsm_define_temp
  6    11      entry (char (*), ptr, fixed bin (35));
  6    12 dcl  mrds_dsm_open_read entry (char (*), ptr, fixed bin (35));
  6    13 dcl  mrds_dsm_read_header entry (ptr, ptr, ptr, fixed bin (35));
  6    14 dcl  mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
  6    15 dcl  mrds_dsm_get_relation_names
  6    16      entry (ptr, ptr, ptr, fixed bin (35));
  6    17 dcl  mrds_dsm_validate_header
  6    18      entry (ptr, fixed bin (35));
  6    19 dcl  mrds_dsm_dmdsm entry (ptr, fixed bin (35));
  6    20 dcl  mrds_dsm_valid_$validate
  6    21      entry (ptr, ptr, char (*), char (*), ptr, ptr, fixed bin (35));
  6    22 
  6    23 
  6    24 /* END INCLUDE FILE  -  mrds_dsm_entry_dcls.incl.pl1 */
      293 
      294      end mus_get_att_names;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.6  mus_get_att_names.pl1             >special_ldd>install>MR12.0-1187>mus_get_att_names.pl1
284          1    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
286          2    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
288          3    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
290          4    10/14/83  1608.9  mdbm_rel_att_array.incl.pl1       >ldd>include>mdbm_rel_att_array.incl.pl1
292          5    10/14/83  1608.7  mrds_dsm_rel_block.incl.pl1       >ldd>include>mrds_dsm_rel_block.incl.pl1
293          6    10/14/83  1608.7  mrds_dsm_entry_dcls.incl.pl1      >ldd>include>mrds_dsm_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 275 ref 162 168
RELATION_BLOCK_VERSION_1        000015 constant        fixed bin(35,0)          initial dcl 5-24 set ref 143 145*
addr                                                   builtin function         dcl 266 ref 187 189 208 210 237 239
ai_ptr                   24            based           pointer                  array level 3 in structure "att_names" dcl 4-34
                                                                                  in procedure "mus_get_att_names" set ref 176* 230*
ai_ptr                          000120 automatic       pointer                  dcl 3-209 in procedure "mus_get_att_names" set ref
                                                                                  162* 162 162* 164 168 168 175 176 177 184 202*
                                                                                  204* 206 226* 228 229 230 231* 248*
ans_ptr                                parameter       pointer                  dcl 4-54 set ref 22 110* 119* 120 121 174 175 176
                                                                                  177 178 179 180 195 196 212 214 226 228 229 230
                                                                                  231 232 233 234 241 243 252 253
att_names                              based           structure                level 1 unaligned dcl 4-34 set ref 119 120*
attr_access              55            based           structure                array level 3 packed unaligned dcl 5-26
attr_info                              based           structure                level 1 dcl 3-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 3-126 ref 162 202 226
attribute_info           34            based           structure                array level 2 unaligned dcl 5-26
caller_name                     000001 constant        char(20)                 initial unaligned dcl 271 set ref 139* 145* 171*
continue                        000000 constant        char(1)                  initial unaligned dcl 273 set ref 139* 145* 171*
db_desc                  11            based           bit(36)                  level 2 dcl 2-125 set ref 187 189 208 210 237 239
db_desc_is_ptr           10            based           bit(1)                   level 2 packed unaligned dcl 2-125 ref 187 208 237
dbm_ptr                                parameter       pointer                  dcl 2-106 ref 22 177 206 231
desc_ptr                        000110 automatic       pointer                  dcl 1-19 set ref 187* 189* 191 191 208* 210* 212 214
                                                                                  237* 239* 241 243
descriptor                             based           structure                level 1 unaligned dcl 1-6
di_ptr                          000114 automatic       pointer                  dcl 2-155 in procedure "mus_get_att_names" set ref
                                                                                  177* 187 187 189 206* 208 208 210 231* 237 237 239
di_ptr                   26            based           pointer                  array level 3 in structure "att_names" dcl 4-34
                                                                                  in procedure "mus_get_att_names" set ref 177* 231*
dm                       14            based           char(32)                 array level 3 packed unaligned dcl 4-34 set ref 175*
                                                                                  229*
dm_attr_name             56            based           varying char(32)         array level 3 dcl 5-26 ref 162 168 171 171
domain_info                            based           structure                level 1 dcl 2-125
domain_ptr               17            based           bit(18)                  level 2 packed unaligned dcl 3-192 ref 177 206 231
dsm_attr_name            34            based           varying char(64)         array level 3 dcl 5-26 ref 174
dsm_sw                                 parameter       bit(1)                   unaligned dcl 262 ref 22 125
error_code                             parameter       fixed bin(35,0)          dcl 260 set ref 22 109* 138* 139 139* 144* 170* 171*
error_table_$unimplemented_version
                                000010 external static fixed bin(35,0)          dcl 268 set ref 144 145*
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 3-192 ref 162 164 168
                                                                                  204 248
i                               000100 automatic       fixed bin(17,0)          dcl 258 set ref 156* 162 168 171 171 174 174 175 176
                                                                                  177 178 179 179 180 180* 201* 202 203* 203 225*
                                                                                  226 228 229 230 231 232 246* 246
info_ptr                        000104 automatic       pointer                  initial dcl 276 set ref 139* 145* 171* 276*
item                      4            based           structure                array level 2 in structure "att_names" unaligned
                                                                                  dcl 4-34 in procedure "mus_get_att_names"
item                      2            based           structure                array level 2 in structure "rel_names" unaligned
                                                                                  dcl 4-20 in procedure "mus_get_att_names"
j                               000101 automatic       fixed bin(17,0)          dcl 258 set ref 154* 184* 184 195
k                               000102 automatic       fixed bin(17,0)          dcl 258 set ref 155* 191* 191 196
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 3-192 ref 184
last_model_attr_char_var
                          3            based           bit(1)                   level 2 packed unaligned dcl 4-34 set ref 212* 214*
                                                                                  241* 243*
modify                   55(01)        based           bit(1)                   array level 4 packed unaligned dcl 5-26 ref 180
mrds_dsm_read_relation          000020 constant        entry                    external dcl 6-14 ref 138
mrds_error_$inconsistent_submodel
                                000012 external static fixed bin(35,0)          dcl 269 ref 170
name                                   based           char(32)                 level 2 dcl 3-192 ref 162 168 175 228 229
natts                    22            based           fixed bin(17,0)          array level 3 dcl 4-20 ref 115
no_rb_attributes         33            based           fixed bin(17,0)          level 2 dcl 5-26 ref 156
null                                                   builtin function         dcl 266 ref 110 178 232 276
num                                    based           fixed bin(17,0)          level 2 dcl 4-34 set ref 119* 120 121* 226 233 234
num_attr                 12            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-126 ref 202
num_atts_init                   000122 automatic       fixed bin(17,0)          dcl 4-51 set ref 115* 119 119 121
num_dims                        000112 automatic       fixed bin(17,0)          initial dcl 1-20 set ref 1-20* 137*
num_key_attrs            14            based           fixed bin(17,0)          level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 3-126 in procedure "mus_get_att_names" ref 252
num_key_attrs             1            based           fixed bin(17,0)          level 2 in structure "att_names" dcl 4-34
                                                                                  in procedure "mus_get_att_names" set ref 195* 252*
num_varying_attrs         2            based           fixed bin(17,0)          level 2 dcl 4-34 set ref 196* 253*
nvar_atts                14(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 3-126 ref 253
pointer_format                         based           pointer                  dcl 282 ref 187 208 237
ptr                                                    builtin function         dcl 266 ref 162 164 177 202 204 206 226 231 248
r_perm                   32            based           bit(1)                   array level 3 packed unaligned dcl 4-34 set ref 179*
                                                                                  233*
rai_ptr                  30            based           pointer                  array level 3 dcl 4-34 set ref 178* 232*
read                     55            based           bit(1)                   array level 4 packed unaligned dcl 5-26 ref 179
rel_index                              parameter       fixed bin(17,0)          dcl 259 ref 22 114 115 138 139
rel_info                               based           structure                level 1 dcl 3-126
rel_names                              based           structure                level 1 unaligned dcl 4-20
relation_block                         based           structure                level 1 unaligned dcl 5-26
relation_block_ptr              000124 automatic       pointer                  dcl 5-22 set ref 138* 143 145 156 162 168 171 171
                                                                                  174 179 180
return_value                    000106 automatic       fixed bin(35,0)          dcl 277 set ref 139* 145* 171*
ri_ptr                   24            based           pointer                  array level 3 in structure "rel_names" dcl 4-20
                                                                                  in procedure "mus_get_att_names" ref 114
ri_ptr                          000116 automatic       pointer                  dcl 3-185 in procedure "mus_get_att_names" set ref
                                                                                  114* 162 162 164 202 202 202 204 226 226 248 252
                                                                                  253
rns_ptr                                parameter       pointer                  dcl 4-53 ref 22 114 115 138 139
sm                        4            based           char(32)                 array level 3 in structure "att_names" packed
                                                                                  unaligned dcl 4-34 in procedure
                                                                                  "mus_get_att_names" set ref 174* 228*
sm                        2            based           char(32)                 array level 3 in structure "rel_names" packed
                                                                                  unaligned dcl 4-20 in procedure
                                                                                  "mus_get_att_names" set ref 138* 139*
sub_err_                        000014 constant        entry                    external dcl 278 ref 139 145 171
submodel_iocb_ptr               000016 external static pointer                  initial dcl 279 set ref 138*
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 1-6 ref 191
                                                                                  191 212 214 241 243
u_perm                   32(01)        based           bit(1)                   array level 3 packed unaligned dcl 4-34 set ref 180*
                                                                                  234*
unspec                                                 builtin function         dcl 266 set ref 120*
version                                based           fixed bin(35,0)          level 2 dcl 5-26 set ref 143 145*
wa_ptr                                 parameter       pointer                  dcl 257 set ref 22 119 138*
work_area                              based           area(1024)               dcl 264 ref 119

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
al_ptr                                 automatic       pointer                  dcl 3-345
alloc_length                           internal static fixed bin(35,0)          dcl 2-222
atd                                    based           char                     unaligned dcl 3-109
atd_len                                automatic       fixed bin(17,0)          dcl 3-111
atd_ptr                                automatic       pointer                  dcl 3-110
attr_list                              based           structure                level 1 dcl 3-341
changer                                based           structure                level 1 packed unaligned dcl 2-251
changer_ptr                            automatic       pointer                  dcl 2-256
child_link_info                        based           structure                level 1 dcl 3-283
cli_ptr                                automatic       pointer                  dcl 3-329
cna_ptr                                automatic       pointer                  dcl 3-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 3-112
constant                               based           structure                level 1 unaligned dcl 2-216
constant_ptr                           automatic       pointer                  dcl 2-220
db_model                               based           structure                level 1 dcl 2-72
dp_ptr                                 automatic       pointer                  dcl 3-356
dup_prev                               based           structure                level 1 dcl 3-353
fi_ptr                                 automatic       pointer                  dcl 2-119
file_info                              based           structure                level 1 dcl 2-113
file_model                             based           structure                level 1 dcl 3-40
fm_ptr                                 automatic       pointer                  dcl 3-108
message_str                            based           structure                level 1 packed unaligned dcl 2-259
message_str_len                        automatic       fixed bin(17,0)          dcl 2-269
message_str_ptr                        automatic       pointer                  dcl 2-267
mrds_dsm_close                  000000 constant        entry                    external dcl 6-6
mrds_dsm_close$force            000000 constant        entry                    external dcl 6-7
mrds_dsm_copy                   000000 constant        entry                    external dcl 6-8
mrds_dsm_define_temp            000000 constant        entry                    external dcl 6-10
mrds_dsm_dmdsm                  000000 constant        entry                    external dcl 6-19
mrds_dsm_get_relation_names     000000 constant        entry                    external dcl 6-15
mrds_dsm_open_read              000000 constant        entry                    external dcl 6-12
mrds_dsm_read_header            000000 constant        entry                    external dcl 6-13
mrds_dsm_set_db_path            000000 constant        entry                    external dcl 6-9
mrds_dsm_valid_$validate        000000 constant        entry                    external dcl 6-20
mrds_dsm_validate_header        000000 constant        entry                    external dcl 6-17
ncomp_init                             automatic       fixed bin(17,0)          dcl 3-116
num_rels_init                          automatic       fixed bin(17,0)          dcl 4-50
parent_link_info                       based           structure                level 1 dcl 3-223
path_entry                             based           structure                level 1 packed unaligned dcl 2-172
path_entry_ptr                         automatic       pointer                  dcl 2-177
pli_ptr                                automatic       pointer                  dcl 3-268
rb_number_of_attributes                automatic       fixed bin(35,0)          dcl 5-23
sc_ptr                                 automatic       pointer                  dcl 3-365
select_chain                           based           structure                level 1 dcl 3-357
sk_ptr                                 automatic       pointer                  dcl 3-352
sort_key                               based           structure                level 1 dcl 3-346
stack_item                             based           structure                level 1 unaligned dcl 2-206
stack_item_ptr                         automatic       pointer                  dcl 2-212
ua_ptr                                 automatic       pointer                  dcl 2-165
unreferenced_attribute                 based           structure                level 1 dcl 2-159
version_status                         based           structure                level 1 packed unaligned dcl 2-232
version_status_ptr                     automatic       pointer                  dcl 2-246

NAMES DECLARED BY EXPLICIT CONTEXT.
model_relation                  000771 constant        entry                    internal dcl 219 ref 127
mus_get_att_names               000134 constant        entry                    external dcl 22
submodel_relation               000216 constant        entry                    internal dcl 131 ref 125

NAME DECLARED BY CONTEXT OR IMPLICATION.
rtrim                                                  builtin function         ref 171 171

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1264        1306    1151        1274
Length      1624    1151        22         302     113           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mus_get_att_names                   198 external procedure  is an external procedure.  
submodel_relation                       internal procedure  shares stack frame of external procedure mus_get_att_names.  
model_relation                          internal procedure  shares stack frame of external procedure mus_get_att_names.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mus_get_att_names        000100 i                           mus_get_att_names
                         000101 j                           mus_get_att_names
                         000102 k                           mus_get_att_names
                         000104 info_ptr                    mus_get_att_names
                         000106 return_value                mus_get_att_names
                         000110 desc_ptr                    mus_get_att_names
                         000112 num_dims                    mus_get_att_names
                         000114 di_ptr                      mus_get_att_names
                         000116 ri_ptr                      mus_get_att_names
                         000120 ai_ptr                      mus_get_att_names
                         000122 num_atts_init               mus_get_att_names
                         000124 relation_block_ptr          mus_get_att_names

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   return_mac          shorten_stack       ext_entry
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_dsm_read_relation        sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          mrds_error_$inconsistent_submodel
submodel_iocb_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000126       276 000141    1   20 000143       109 000144       110 000146       114 000147       115 000155
    119 000157       120 000173       121 000203       125 000205       127 000214       129 000215       131 000216
    137 000217       138 000220       139 000256       143 000333       144 000336       145 000341       149 000405
    154 000406       155 000407       156 000410       162 000421       164 000453       168 000457       170 000464
    171 000470       173 000566       174 000567       175 000604       176 000611       177 000612       178 000625
    179 000630       180 000637       184 000643       187 000647       189 000655       191 000657       193 000670
    195 000672       196 000677       201 000701       202 000703       203 000717       204 000720       206 000727
    208 000737       210 000745       212 000747       214 000762       217 000770       219 000771       225 000772
    226 000774       228 001007       229 001016       230 001022       231 001023       232 001037       233 001042
    234 001057       237 001076       239 001105       241 001107       243 001121       246 001126       248 001127
    252 001136       253 001143       255 001147


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
