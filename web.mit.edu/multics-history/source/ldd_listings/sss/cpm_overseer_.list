	COMPILATION LISTING OF SEGMENT cpm_overseer_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/04/86  1435.9 mst Tue
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: off */
        8 
        9 /* Control Point Management -- Entrypoints which manage the environment of a control point */
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
       13*     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
       14*     Written to support control point management in March 1985 by G. Palter.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 /* format: style3,linecom */
       18 
       19 cpm_overseer_:
       20      procedure ();
       21 
       22 	return;					/* not an entrypoint */
       23 
       24 
       25 /* Parameters */
       26 
       27 dcl	P_ccpi_ptr	pointer parameter;		/* overseer: -> describes how to create the control point */
       28 dcl	P_initproc				/* overseer: first user program to run in the control point */
       29 			entry (pointer) variable parameter;
       30 dcl	P_initproc_arg_list_ptr			/* overseer: -> the above program's argument list */
       31 			pointer parameter;
       32 
       33 dcl	P_gcf_ptr		pointer parameter;		/* generate_call: -> generate_call_flags (see include file) */
       34 dcl	P_userproc				/* generate_call: the user program to be executed */
       35 			entry (pointer) variable parameter;
       36 dcl	P_userproc_arg_list_ptr			/* generate_call: -> the above program's argument list */
       37 			pointer parameter;
       38 
       39 dcl	P_cl_flags	bit (36) aligned parameter;	/* cl_intermediary: flags which control new command level */
       40 
       41 
       42 /* Parameters for entrypoints used to prevent non-quick procedures */
       43 
       44 dcl	P_cpd_ptr		pointer parameter;
       45 
       46 dcl	P_old_cpd_ptr	pointer parameter;
       47 dcl	P_new_cpd_ptr	pointer parameter;
       48 dcl	P_cpd_swapped_switches
       49 			bit (1) unaligned parameter;
       50 dcl	P_new_swapped_switches_setting
       51 			bit (1) aligned parameter;
       52 
       53 dcl	P_new_mask	bit (36) aligned parameter;
       54 dcl	P_old_mask	bit (36) aligned parameter;
       55 
       56 
       57 /* Remaining declarations */
       58 
       59 dcl	1 parent_control_point_data
       60 			like control_point_data aligned based (control_point_data.parent);
       61 
       62 dcl	based_generate_call_flags
       63 			bit (36) aligned based;
       64 
       65 dcl	old_mask		bit (36) aligned;
       66 
       67 dcl	generate_call_flags bit (36) aligned;
       68 dcl	pushed_preferred_state
       69 			bit (1) aligned;
       70 dcl	prior_state	fixed binary;
       71 dcl	return_from_intermediary
       72 			bit (1) aligned;
       73 dcl	saved_swapped_switches
       74 			bit (1) aligned;
       75 
       76 dcl	(
       77 	sys_info$comm_privilege,
       78 	sys_info$dir_privilege,
       79 	sys_info$ipc_privilege,
       80 	sys_info$rcp_privilege,
       81 	sys_info$ring1_privilege,
       82 	sys_info$seg_privilege,
       83 	sys_info$soos_privilege
       84 	)		bit (36) aligned external;
       85 
       86 dcl	continue_to_signal_ entry (fixed binary (35));
       87 dcl	cpm_$call_self_destruct
       88 			entry ();
       89 dcl	cpm_$update_state_caller
       90 			entry (pointer, fixed binary);
       91 dcl	cu_$arg_list_ptr	entry () returns (pointer);
       92 dcl	cu_$generate_call	entry (entry, pointer);
       93 dcl	(
       94 	cu_$get_cl_intermediary,
       95 	cu_$set_cl_intermediary
       96 	)		entry (entry (bit (36) aligned));
       97 dcl	default_error_handler_$wall
       98 			entry ();
       99 dcl	default_error_handler_$wall_ignore_pi
      100 			entry ();
      101 dcl	get_privileges_	entry () returns (bit (36) aligned);
      102 dcl	hcs_$get_ips_mask	entry (bit (36) aligned);
      103 dcl	hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
      104 dcl	hcs_$set_ips_mask	entry (bit (36) aligned, bit (36) aligned);
      105 dcl	ioa_$ioa_switch	entry () options (variable);
      106 dcl	ioa_$rsnnl	entry () options (variable);
      107 dcl	sub_err_		entry () options (variable);
      108 dcl	(
      109 	system_privilege_$comm_priv_on,
      110 	system_privilege_$comm_priv_off,
      111 	system_privilege_$dir_priv_on,
      112 	system_privilege_$dir_priv_off,
      113 	system_privilege_$ipc_priv_on,
      114 	system_privilege_$ipc_priv_off,
      115 	system_privilege_$rcp_priv_on,
      116 	system_privilege_$rcp_priv_off,
      117 	system_privilege_$ring1_priv_on,
      118 	system_privilege_$ring1_priv_off,
      119 	system_privilege_$seg_priv_on,
      120 	system_privilege_$seg_priv_off,
      121 	system_privilege_$soos_priv_on,
      122 	system_privilege_$soos_priv_off
      123 	)		entry (fixed binary (35));
      124 
      125 dcl	any_other		condition;
      126 dcl	cleanup		condition;
      127 
      128 dcl	(addr, bool, null, stackbaseptr, substr)
      129 			builtin;
      130 
      131 /* The initial procedure for a new control point -- This entrypoint is responsible for completing the creation of an
      132*   environment for the new control point.  This responsibility includes establishing the standard I/O switches for this
      133*   control point if they are to be different from our parent's control point. */
      134 
      135 /* NOTE: This entrypoint is always called with all IPS signals masked. */
      136 
      137 overseer:
      138      entry (P_ccpi_ptr, P_initproc, P_initproc_arg_list_ptr);
      139 
      140 	on any_other call error_handler$catch_all ();	/* setup our unclaimed signal handler */
      141 
      142 	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;/* get our definitions */
      143 	ccpi_ptr = P_ccpi_ptr;
      144 
      145 	if trace_$transaction_end (1)			/* setup tracing according to our stack */
      146 	then ;
      147 
      148 	call cu_$set_cl_intermediary (control_point_data.cl_intermediary);
      149 						/* set our initial CL intermediary ($cl_intermediary below) */
      150 
      151 	call restore_privileges ();			/* set our initial privileges (all OFF) */
      152 
      153 	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);
      154 						/* unmask all IPS interrupts (most likely) */
      155 
      156 	on cleanup call issue_root_start_order_caller (cpd_ptr);
      157 
      158 	if create_control_point_info.separate_standard_iocbs
      159 	then do;					/* setup our I/O switches */
      160 		call create_control_point_switches ();
      161 		on cleanup
      162 		     begin;			/* ... and be sure to get rid of them on explicit destroy */
      163 			call destroy_control_point_switches_caller (cpd_ptr, ccpi_ptr, old_mask);
      164 			call issue_root_start_order_caller (cpd_ptr);
      165 		     end;
      166 	     end;
      167 
      168 	call cu_$generate_call (P_initproc, P_initproc_arg_list_ptr);
      169 						/* start the control point running */
      170 
      171 	if create_control_point_info.separate_standard_iocbs
      172 	then call destroy_control_point_switches (old_mask);
      173 						/* we're done with these switches */
      174 
      175 	/*** We must leave all IPS signals unmasked when we return.  Otherwise, cpm_$self_destruct will call the
      176*	     scheduler with all IPS signals masked and, if there are no ready control points, we will call hardcore to
      177*	     block with all signals masked which is clearly wrong. */
      178 
      179 RETURN_FROM_OVERSEER:
      180 	call issue_root_start_order ();		/* kick the root */
      181 
      182 	return;					/* complete the control point's destruction */
      183 
      184 /* The portion of cpm_$generate_call which executes in the target control point -- This entrypoint is responsible for
      185*   readying the control point's environment before executing the user program requested by the call to cu_$generate_call.
      186*   If cpm_$generate_call or cpm_$generate_call_preferred were used, this entrypoint will force the control point into the
      187*   READY state and restore it to its prior state when execution is completed.  If cpm_$generate_call_preferred was used,
      188*   this entrypoint will push the preferred control point, make this control point preferred, and restore the preferred
      189*   control point when execution is completed.  In addition, if this control point uses a different set of standard I/O
      190*   switches than the previously executing control point, this entrypoint must restore the switches before executing the
      191*   user's program and then save them upon completion.  This action is required as the scheduler will have saved our
      192*   switches before running any control point with different switches and will expect to restore them when it regains
      193*   control in this control point which will occur after we return. */
      194 
      195 /* NOTE: This entrypoint is always invoked with all IPS signals masked. */
      196 
      197 generate_call:
      198      entry (P_gcf_ptr, P_userproc, P_userproc_arg_list_ptr);
      199 
      200 	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;/* get our definition */
      201 	generate_call_flags = P_gcf_ptr -> based_generate_call_flags;
      202 
      203 	if trace_$transaction_end (1)			/* setup tracing according to our stack */
      204 	then ;
      205 
      206 	pushed_preferred_state = "0"b;		/* for cleanup handler */
      207 
      208 	on cleanup				/* in case the user's program aborts */
      209 	     begin;
      210 		/*** On a non-local goto, we must not restore the IPS mask.  If we did, the control point would
      211*		     continue execution with all IPS signals masked which would, eventually, cause problems when it
      212*		     tries to block.  In addition, we do not restore the prior state as, if we were blocked, we are
      213*		     about to release past the scheduler and the ipc_$block call which caused us to become blocked in
      214*		     the first place.  If we had been stopped, we are about to release past the cu_$cl call which
      215*		     place us in that state.  Finally, we do not save our I/O switches as we are not going to return
      216*		     to our caller (the scheduler) which would restore them. */
      217 		call cpm_$pop_preferred_control_point (pushed_preferred_state);
      218 		call issue_start_orders_caller (cpd_ptr);
      219 	     end;
      220 
      221 	if generate_call_flags & CPM_GC_FORCE_READY	/* cpm_$generate_call or cpm_$generate_call_preferred ... */
      222 	then do;					/* ... so make sure this control point is READY */
      223 		prior_state = control_point_data.state;
      224 		if control_point_data.state ^= CPM_READY
      225 		then call cpm_$update_state_caller (cpd_ptr, CPM_READY);
      226 	     end;
      227 
      228 	if generate_call_flags & CPM_GC_PUSH_PREFERRED	/* cpm_$generate_call_preferred: make us temporarily "it" */
      229 	then call cpm_$push_preferred_control_point (control_point_data.id, pushed_preferred_state, (0));
      230 
      231 	saved_swapped_switches = control_point_data.swapped_switches;
      232 	control_point_data.swapped_switches = "0"b;	/* don't use the root's switches during a generate_call */
      233 
      234 	if different_switches (cpd_ptr, cpm_data_$previous_control_point)
      235 	then call restore_io_switches ();		/* we need to get our switches back */
      236 
      237 	call cu_$set_cl_intermediary (control_point_data.cl_intermediary);
      238 						/* restore our control point's CL intermediary */
      239 
      240 	call restore_privileges ();			/* restore our system privileges */
      241 
      242 	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);
      243 						/* restore our control point's IPS mask */
      244 
      245 	call cu_$generate_call (P_userproc, P_userproc_arg_list_ptr);
      246 						/* run the user's procedure */
      247 
      248 	call issue_start_orders ();			/* in case the user's procedure did I/O */
      249 
      250 	call hcs_$get_ips_mask (control_point_data.ips_mask);
      251 	substr (control_point_data.ips_mask, 36) = "1"b;	/* construct possible new IPS mask for this control point */
      252 
      253 	call unmask_ips_interrupts (old_mask);		/* restore the IPS mask */
      254 
      255 	control_point_data.privileges = get_privileges_ ();
      256 						/* preceeding call may permanently affect our privileges */
      257 
      258 	call cu_$get_cl_intermediary (control_point_data.cl_intermediary);
      259 						/* it may also permanently change the CL intermediary */
      260 
      261 	if different_switches (cpd_ptr, cpm_data_$previous_control_point)
      262 	then call save_io_switches ();		/* put our switches back where the scheduler will find them */
      263 
      264 	control_point_data.swapped_switches = saved_swapped_switches;
      265 
      266 	call cpm_$pop_preferred_control_point (pushed_preferred_state);
      267 						/* restore the previous preferred control point if pushed */
      268 
      269 	if generate_call_flags & CPM_GC_FORCE_READY	/* cpm_$generate_call or cpm_$generate_call_preferred ... */
      270 	then if prior_state ^= CPM_READY		/* ... so reset our state if it wasn't READY */
      271 	     then call cpm_$update_state_caller (cpd_ptr, prior_state);
      272 
      273 	if trace_$transaction_begin (1)		/* disbale tracing until we're in another control point */
      274 	then ;
      275 
      276 	return;					/* return to the scheduler ... */
      277 
      278 /* The command level intermediary used by Control Point Management */
      279 
      280 cl_intermediary:
      281      entry (P_cl_flags);
      282 
      283 	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;
      284 
      285 
      286 /* If we were invoked by default_error_handler_, our standard I/O switches will have been swapped with those belonging to
      287*   the root control point.  Before reaching command level, we must be sure to be using the proper set of switches. */
      288 
      289 	saved_swapped_switches = control_point_data.swapped_switches;
      290 						/* we must remember whether to restore the switches */
      291 
      292 	old_mask = ""b;				/* used by swap_switches */
      293 
      294 	on cleanup
      295 	     begin;				/* in case of a release ... */
      296 		call issue_start_orders_caller (cpd_ptr);
      297 		if saved_swapped_switches & ^control_point_data.swapped_switches
      298 		then call swap_switches_caller (cpd_ptr, addr (cpm_data_$root_control_point_data),
      299 			control_point_data.swapped_switches, "1"b);
      300 	     end;					/* ... put things back the way the error_handler expects them */
      301 
      302 	if control_point_data.swapped_switches		/* restore the control point's native switches */
      303 	then call swap_switches (addr (cpm_data_$root_control_point_data), cpd_ptr, control_point_data.swapped_switches,
      304 		"0"b, "0"b);
      305 
      306 
      307 /* Invoke the user's CL intermediary if defined for this control point -- On return, if it requests, simply return without
      308*   getting a new command level as if a "start" command had been issued. */
      309 
      310 	if control_point_data.user_cl_intermediary ^= cpm_$nulle
      311 	then do;
      312 
      313 		return_from_intermediary = "0"b;	/* in case the user's CL intermediary doesn't set it */
      314 
      315 		call control_point_data.user_cl_intermediary (return_from_intermediary);
      316 
      317 		if return_from_intermediary
      318 		then go to RETURN_FROM_CL_INTERMEDIARY;
      319 	     end;
      320 
      321 
      322 /* Now get to command level -- If we are the root control point, we can invoke the saved intermediary to get a new
      323*   listener level.  Otherwise, we must stop this control point and let some other control point run; however, before we
      324*   stop, we will try to print a message that we have stopped this control point. */
      325 
      326 	if cpd_ptr = addr (cpm_data_$root_control_point_data)
      327 	then call cpm_data_$saved_cl_intermediary (P_cl_flags);
      328 
      329 	else do;
      330 		on any_other			/* fault occured trying to write the following message ... */
      331 		     call cpm_$call_self_destruct ();
      332 		call ioa_$ioa_switch (iox_$error_output, "^a: Control point ^12.3b^[ (^a)^] stopped.",
      333 		     cpm_data_$subsystem_name, control_point_data.id, (control_point_data.comment ^= ""),
      334 		     control_point_data.comment);
      335 
      336 		on any_other call error_handler$ignore_pi ();
      337 						/* setup a condition wall */
      338 
      339 		call issue_root_start_order ();	/* kick the root */
      340 
      341 		call cpm_$stop (control_point_data.id, (0));
      342 		call cpm_$scheduler ();		/* find something to do */
      343 
      344 		revert any_other;			/* we've been restarted ... */
      345 	     end;
      346 
      347 
      348 /* Return to the caller of cu_$cl -- Reswap the standard switches if needed and issue a "start" control order on both our
      349*   own user_i/o and the root's user_i/o to avoid possible lost wakeups. */
      350 
      351 RETURN_FROM_CL_INTERMEDIARY:
      352 	call issue_start_orders ();
      353 
      354 	if saved_swapped_switches			/* put things back the way the error_handler expects them */
      355 	then call swap_switches (cpd_ptr, addr (cpm_data_$root_control_point_data), control_point_data.swapped_switches,
      356 		"1"b, "0"b);
      357 
      358 	return;
      359 
      360 /* The unclaimed signal (any_other) handler for any control point other than the root --  Before actually processing the
      361*   signal, we first swap the current control point's I/O switches with those belonging to the root control point.  Thus,
      362*   any messages printed by default_error_handler_ will be displayed on the original login terminal as opposed to whatever
      363*   connection the control point might be using.  Of course, we must be certain to put things back after processing is
      364*   completed. */
      365 
      366 error_handler:
      367      procedure ();
      368 	return;					/* not used */
      369 
      370 dcl	real_error_handler	entry () variable;
      371 dcl	must_swap_switches	bit (1) aligned;
      372 dcl	our_arg_list_ptr	pointer;
      373 
      374 
      375 error_handler$catch_all:				/* catch everything including program_interrupt */
      376      entry ();
      377 	real_error_handler = default_error_handler_$wall;
      378 	go to ERROR_HANDLER;
      379 
      380 
      381 error_handler$ignore_pi:				/* catch everything but program_interrupt and a few others */
      382      entry ();
      383 	real_error_handler = default_error_handler_$wall_ignore_pi;
      384 	go to ERROR_HANDLER;
      385 
      386 
      387 ERROR_HANDLER:
      388 	our_arg_list_ptr = cu_$arg_list_ptr ();
      389 
      390 	must_swap_switches = ^control_point_data.swapped_switches;
      391 
      392 	on cleanup
      393 	     begin;
      394 		if must_swap_switches & control_point_data.swapped_switches
      395 		then call swap_switches_caller (addr (cpm_data_$root_control_point_data), cpd_ptr,
      396 			control_point_data.swapped_switches, "0"b);
      397 	     end;
      398 
      399 	if must_swap_switches
      400 	then call swap_switches_caller (cpd_ptr, addr (cpm_data_$root_control_point_data),
      401 		control_point_data.swapped_switches, "1"b);
      402 
      403 	call cu_$generate_call (real_error_handler, our_arg_list_ptr);
      404 
      405 	if must_swap_switches & control_point_data.swapped_switches
      406 	then call swap_switches_caller (addr (cpm_data_$root_control_point_data), cpd_ptr,
      407 		control_point_data.swapped_switches, "0"b);
      408 
      409 	return;
      410 
      411      end error_handler;
      412 
      413 /* Setup the control point's I/O switches when separate switches are requested -- Four uniquely named switches are created
      414*   to represent the new control point's standard switches.  If an attach description for user_i/o is provided, it is used
      415*   to create an independent attachment for the new control point; otherwise, the new control point's user_i/o is syn_'ed
      416*   to its parent's user_i/o.  If any switch can not be setup, sub_err_ is used to inform the user. */
      417 
      418 create_control_point_switches:
      419      procedure ();
      420 
      421 dcl	1 local_io_switches like control_point_data.io_switches aligned;
      422 
      423 dcl	an_iocb_ptr	pointer;
      424 dcl	id_string		character (12);
      425 dcl	parents_user_io	character (21);
      426 dcl	our_user_io	character (21);
      427 dcl	code		fixed binary (35);
      428 
      429 	local_io_switches = null ();			/* for proper error recovery */
      430 
      431 	call ioa_$rsnnl ("^12.3b", id_string, (0), control_point_data.id);
      432 	our_user_io = id_string || ".user_i/o";		/* construct the name of our user_i/o switch */
      433 
      434 	if create_control_point_info.user_io_attach_desc_given
      435 	then do;					/* new control point has its own user_i/o */
      436 		call iox_$attach_name (our_user_io, local_io_switches.user_io,
      437 		     create_control_point_info.user_io_attach_desc, null (), code);
      438 		if code ^= 0
      439 		then call attach_failure (our_user_io, create_control_point_info.user_io_attach_desc, code);
      440 		call iox_$open (local_io_switches.user_io, Stream_input_output, "0"b, code);
      441 		if code ^= 0
      442 		then call open_failure (our_user_io, code);
      443 	     end;
      444 
      445 	else do;					/* new control point is to share its parent's user_i/o */
      446 		call ioa_$rsnnl ("^12.3b.user_i/o", parents_user_io, (0), parent_control_point_data.id);
      447 		call attach_syn ("user_i/o", parents_user_io, "", local_io_switches.user_io);
      448 	     end;
      449 
      450 	/*** Attach user_input, user_output, and error_output as synonyms of user_i/o.  These switches are not syn_'ed
      451*	     to the control point's private user_i/o because, if they were, they will always be syn_'ed to that switch
      452*	     even after it is moved to the real user_i/o. */
      453 
      454 	call attach_syn ("user_input", "user_i/o", "put_chars", local_io_switches.user_input);
      455 	call attach_syn ("user_output", "user_i/o", "get_chars get_line", local_io_switches.user_output);
      456 	call attach_syn ("error_output", "user_i/o", "get_chars get_line", local_io_switches.error_output);
      457 
      458 	call unmask_ips_interrupts (old_mask);		/* prevent interrupts while updating control_point_data */
      459 
      460 	control_point_data.io_switches = local_io_switches;
      461 	control_point_data.group_id = control_point_data.id;
      462 						/* we've now created the switches */
      463 
      464 	if cpm_data_$previous_control_point -> control_point_data.swapped_switches
      465 	then call swap_switches (addr (cpm_data_$root_control_point_data), cpd_ptr, control_point_data.swapped_switches,
      466 		"0"b, "1"b);
      467 	else call swap_switches (cpm_data_$previous_control_point, cpd_ptr, control_point_data.swapped_switches, "0"b,
      468 		"1"b);
      469 
      470 	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);
      471 
      472 	return;
      473 
      474 
      475 /* Control arrives here iff an error occurs while trying to create the control point's standard switches */
      476 
      477 ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES:
      478 	do an_iocb_ptr = local_io_switches.user_input, local_io_switches.user_output, local_io_switches.error_output;
      479 	     if an_iocb_ptr ^= null ()
      480 	     then do;
      481 		     call iox_$detach_iocb (an_iocb_ptr, (0));
      482 		     call iox_$destroy_iocb (an_iocb_ptr, (0));
      483 		end;
      484 	end;
      485 
      486 	if local_io_switches.user_io ^= null ()
      487 	then do;
      488 		if create_control_point_info.user_io_attach_desc_given
      489 		then call iox_$close (local_io_switches.user_io, (0));
      490 		call iox_$detach_iocb (local_io_switches.user_io, (0));
      491 		call iox_$destroy_iocb (local_io_switches.user_io, (0));
      492 	     end;
      493 
      494 	go to RETURN_FROM_OVERSEER;
      495 
      496 
      497 
      498 /* Attaches an I/O switch as a synonym to the supplied target switch */
      499 
      500 attach_syn:
      501      procedure (p_switch_name, p_target_switch_name, p_inhibits, p_switch_iocb);
      502 
      503 dcl	p_switch_name	character (*) parameter;
      504 dcl	p_target_switch_name
      505 			character (*) parameter;
      506 dcl	p_inhibits	character (*) parameter;
      507 dcl	p_switch_iocb	pointer parameter;
      508 
      509 dcl	switch_name	character (32) varying;
      510 dcl	attach_description	character (128) varying;
      511 
      512 	switch_name = id_string;			/* construct the switch's name */
      513 	switch_name = switch_name || ".";
      514 	switch_name = switch_name || p_switch_name;
      515 
      516 	attach_description = "syn_ ";			/* now construct the attach description */
      517 	attach_description = attach_description || p_target_switch_name;
      518 	attach_description = attach_description || " -inhibit close ";
      519 	if p_inhibits ^= ""
      520 	then attach_description = attach_description || p_inhibits;
      521 
      522 	call iox_$attach_name ((switch_name), p_switch_iocb, (attach_description), null (), code);
      523 	if code ^= 0
      524 	then call attach_failure (switch_name, attach_description, code);
      525 
      526 	return;
      527 
      528      end attach_syn;
      529 
      530 
      531 
      532 /* Reports an error while attaching one of the control point's standard I/O switches */
      533 
      534 /* format: off */
      535 dcl	attach_failure	generic (
      536 		attach_failure_nonvarying
      537 			when (character (*) nonvarying, character (*) nonvarying, fixed binary (35)),
      538 		attach_failure_varying
      539 			when (character (*) varying, character (*) varying, fixed binary (35)));
      540 /* format: on */
      541 
      542 
      543 attach_failure_nonvarying:				/* ... with nonvarying parameters */
      544      procedure (p_switch_name, p_attach_desc, p_code);
      545 
      546 dcl	p_switch_name	character (*) parameter;
      547 dcl	p_attach_desc	character (*) parameter;
      548 dcl	p_code		fixed binary (35) parameter;
      549 
      550 	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0,
      551 	     "Trying to attach ^a using the attach description -^/^-^a", p_switch_name, p_attach_desc);
      552 
      553 	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;
      554 
      555      end attach_failure_nonvarying;
      556 
      557 
      558 attach_failure_varying:				/* ... with varying parameters */
      559      procedure (p_switch_name, p_attach_desc, p_code);
      560 
      561 dcl	p_switch_name	character (*) varying parameter;
      562 dcl	p_attach_desc	character (*) varying parameter;
      563 dcl	p_code		fixed binary (35) parameter;
      564 
      565 	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0,
      566 	     "Trying to attach ^a using the attach description -^/^-^a", p_switch_name, p_attach_desc);
      567 
      568 	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;
      569 
      570      end attach_failure_varying;
      571 
      572 
      573 
      574 /* Reports an error while trying to open one of the control point's standard I/O switches */
      575 
      576 open_failure:					/* ... while trying to open a switch */
      577      procedure (p_switch_name, p_code);
      578 
      579 dcl	p_switch_name	character (*) parameter;
      580 dcl	p_code		fixed binary (35) parameter;
      581 
      582 	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0, "Trying to open ^a.",
      583 	     p_switch_name);
      584 
      585 	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;
      586 
      587      end open_failure;
      588 
      589      end create_control_point_switches;
      590 
      591 /* Destroy the control point's standard I/O switches setup by a prior call to create_control_point_switches */
      592 
      593 destroy_control_point_switches:
      594      procedure (p_old_mask);
      595 
      596 dcl	p_old_mask	bit (36) aligned parameter;
      597 
      598 dcl	1 local_io_switches like control_point_data.io_switches aligned;
      599 dcl	an_iocb_ptr	pointer;
      600 
      601 	call unmask_ips_interrupts (p_old_mask);	/* prevent interrupts while updating control_point_data */
      602 
      603 	if parent_control_point_data.swapped_switches	/* revert to our parent's switches or the root's if swapped */
      604 	then call swap_switches (cpd_ptr, addr (cpm_data_$root_control_point_data), control_point_data.swapped_switches,
      605 		"1"b, "1"b);
      606 	else call swap_switches (cpd_ptr, control_point_data.parent, control_point_data.swapped_switches, "0"b, "1"b);
      607 
      608 	local_io_switches = control_point_data.io_switches;
      609 						/* work on local copies so we're never without switches */
      610 
      611 	control_point_data.group_id = parent_control_point_data.group_id;
      612 	control_point_data.io_switches = parent_control_point_data.io_switches;
      613 						/* switch back to our parent's switches */
      614 
      615 	call mask_ips_interrupts (control_point_data.ips_mask, p_old_mask);
      616 
      617 	do an_iocb_ptr = local_io_switches.user_input, local_io_switches.user_output, local_io_switches.error_output;
      618 	     if an_iocb_ptr ^= null ()
      619 	     then do;				/* one of the always syn_'ed switches exists */
      620 		     call iox_$detach_iocb (an_iocb_ptr, (0));
      621 		     call iox_$destroy_iocb (an_iocb_ptr, (0));
      622 		end;
      623 	end;
      624 
      625 	if local_io_switches.user_io ^= null ()
      626 	then do;					/* it's user_i/o switch exists */
      627 		if create_control_point_info.user_io_attach_desc_given
      628 		then call iox_$close (local_io_switches.user_io, (0));
      629 		call iox_$detach_iocb (local_io_switches.user_io, (0));
      630 		call iox_$destroy_iocb (local_io_switches.user_io, (0));
      631 	     end;
      632 
      633 	return;
      634 
      635      end destroy_control_point_switches;
      636 
      637 
      638 
      639 /* Invoke destroy_control_point_switches -- This entrypoint exists to prevent making destroy_control_point_switches
      640*   non-quick by invoking it from within an on unit or other non-quick procedure. */
      641 
      642 destroy_control_point_switches_caller:
      643      entry (P_cpd_ptr, P_ccpi_ptr, P_old_mask);
      644 
      645 	cpd_ptr = P_cpd_ptr;
      646 	ccpi_ptr = P_ccpi_ptr;
      647 
      648 	call destroy_control_point_switches (P_old_mask);
      649 
      650 	return;
      651 
      652 /* Swap the standard I/O switches in force from the old control point's switches to those of a new control point */
      653 
      654 swap_switches:
      655      procedure (p_old_cpd_ptr, p_new_cpd_ptr, p_cpd_swapped_switches, p_new_swapped_switches_setting, p_caller_is_masked);
      656 
      657 dcl	1 old_cpd		like control_point_data aligned based (p_old_cpd_ptr);
      658 dcl	p_old_cpd_ptr	pointer parameter;
      659 
      660 dcl	1 new_cpd		like control_point_data aligned based (p_new_cpd_ptr);
      661 dcl	p_new_cpd_ptr	pointer parameter;
      662 
      663 dcl	p_cpd_swapped_switches			/* a control point's swapped_switches flag ... */
      664 			bit (1) unaligned parameter;
      665 dcl	p_new_swapped_switches_setting		/* ... and the above flag's new setting */
      666 			bit (1) aligned parameter;
      667 
      668 dcl	p_caller_is_masked	bit (1) aligned parameter;	/* ON => the caller has already masked IPS interrupts */
      669 
      670 	if old_cpd.group_id = new_cpd.group_id		/* they are using the same switches: this is a no-op */
      671 	then return;
      672 
      673 	if ^p_caller_is_masked			/* prevent interrupts while playing with the switches */
      674 	then call mask_ips_interrupts (""b, old_mask);
      675 
      676 	call iox_$move_attach (iox_$user_io, old_cpd.io_switches.user_io, (0));
      677 	call iox_$move_attach (iox_$user_input, old_cpd.io_switches.user_input, (0));
      678 	call iox_$move_attach (iox_$user_output, old_cpd.io_switches.user_output, (0));
      679 	call iox_$move_attach (iox_$error_output, old_cpd.io_switches.error_output, (0));
      680 
      681 	call iox_$move_attach (new_cpd.io_switches.user_io, iox_$user_io, (0));
      682 	call iox_$move_attach (new_cpd.io_switches.user_input, iox_$user_input, (0));
      683 	call iox_$move_attach (new_cpd.io_switches.user_output, iox_$user_output, (0));
      684 	call iox_$move_attach (new_cpd.io_switches.error_output, iox_$error_output, (0));
      685 
      686 	p_cpd_swapped_switches = p_new_swapped_switches_setting;
      687 
      688 	if ^p_caller_is_masked			/* it's safe now */
      689 	then call unmask_ips_interrupts (old_mask);
      690 
      691 	return;
      692 
      693      end swap_switches;
      694 
      695 
      696 
      697 /* Invoke swap_switches -- This entrypoint exists to prevent making swap_switches
      698*   non-quick by invoking it from an on unit or other non-quick procedure. */
      699 
      700 swap_switches_caller:
      701      entry (P_new_cpd_ptr, P_old_cpd_ptr, P_cpd_swapped_switches, P_new_swapped_switches_setting);
      702 
      703 	old_mask = ""b;				/* for any_other handler */
      704 	on any_other
      705 	     begin;
      706 		if substr (old_mask, 36, 1) = "1"b
      707 		then call unmask_ips_interrupts_caller (old_mask);
      708 		call continue_to_signal_ ((0));	/* ... let the error get through */
      709 	     end;
      710 
      711 	call swap_switches (P_new_cpd_ptr, P_old_cpd_ptr, P_cpd_swapped_switches, P_new_swapped_switches_setting, "0"b);
      712 
      713 	return;
      714 
      715 /* Issue "start" control orders on the appropriate user_i/o switches -- This procedure is invoked after any operation
      716*   which may have caused asynchronous I/O to prevent lost wakeups.  A "start" order is issued on the current control
      717*   point's user_i/o and also on the user_i/o associated with the root control point (i.e., the user's terminal) if it is
      718*   different from the current control point's user_i/o. */
      719 
      720 issue_start_orders:
      721      procedure ();
      722 
      723 	call iox_$control (iox_$user_io, "start", null (), (0));
      724 
      725 	if control_point_data.swapped_switches		/* user_i/o above is the root's: must also start our's */
      726 	then call iox_$control (control_point_data.user_io, "start", null (), (0));
      727 
      728 	else					/* user_i/o above was our's: check the root's */
      729 	     if control_point_data.group_id ^= cpm_data_$root_control_point_data.group_id
      730 	then call iox_$control (cpm_data_$root_control_point_data.user_io, "start", null (), (0));
      731 
      732 	return;
      733 
      734      end issue_start_orders;
      735 
      736 
      737 
      738 /* Invoke issue_start_orders -- This entrypoint exists to prevent making the issue_start_orders internal procedure
      739*   non-quick by invoking it from within an on unit or other non-quick procedure. */
      740 
      741 issue_start_orders_caller:
      742      entry (P_cpd_ptr);
      743 
      744 	cpd_ptr = P_cpd_ptr;
      745 
      746 	call issue_start_orders ();
      747 
      748 	return;
      749 
      750 /* Issue a "start" control order on the root control point's user_i/o switch -- This procedure is invoked whenever the
      751*   current control point is about to be stopped or destroyed.  If the root control point was blocked for input on its
      752*   user_i/o, any I/O performed to that switch by another control point would be considered asynchronous I/O and, without a
      753*   "start" order, could leave the root control point blocked forever for an event that will never occur. */
      754 
      755 issue_root_start_order:
      756      procedure ();
      757 
      758 	if different_switches (cpd_ptr, addr (cpm_data_$root_control_point_data))
      759 	then call iox_$control (cpm_data_$root_control_point_data.user_io, "start", null (), (0));
      760 
      761 	else call iox_$control (iox_$user_io, "start", null (), (0));
      762 						/* this control point shares its switches with the root */
      763 
      764 	return;
      765 
      766      end issue_root_start_order;
      767 
      768 
      769 
      770 /* Invoke issue_root_start_order -- This entrypoint exists to prevent making the issue_root_start_order internal procedure
      771*   non-quick by invoking it from within an on unit or other non-quick procedure. */
      772 
      773 issue_root_start_order_caller:
      774      entry (P_cpd_ptr);
      775 
      776 	cpd_ptr = P_cpd_ptr;
      777 
      778 	call issue_root_start_order ();
      779 
      780 	return;
      781 
      782 /* Restore the standard I/O switches assigned to this control point */
      783 
      784 restore_io_switches:
      785      procedure ();
      786 
      787 	call iox_$move_attach (control_point_data.user_io, iox_$user_io, (0));
      788 	call iox_$move_attach (control_point_data.user_input, iox_$user_input, (0));
      789 	call iox_$move_attach (control_point_data.user_output, iox_$user_output, (0));
      790 	call iox_$move_attach (control_point_data.error_output, iox_$error_output, (0));
      791 
      792 	return;
      793 
      794      end restore_io_switches;
      795 
      796 
      797 
      798 /* Save the standard I/O switches assigned to this control point */
      799 
      800 save_io_switches:
      801      procedure ();
      802 
      803 	call iox_$move_attach (iox_$user_io, control_point_data.user_io, (0));
      804 	call iox_$move_attach (iox_$user_input, control_point_data.user_input, (0));
      805 	call iox_$move_attach (iox_$user_output, control_point_data.user_output, (0));
      806 	call iox_$move_attach (iox_$error_output, control_point_data.error_output, (0));
      807 
      808 	return;
      809 
      810      end save_io_switches;
      811 
      812 
      813 
      814 /* Determines if the two specified control points use different sets of standard I/O switches */
      815 
      816 different_switches:
      817      procedure (p_cpd_1_ptr, p_cpd_2_ptr) returns (bit (1) aligned);
      818 
      819 dcl	1 cpd_1		like control_point_data aligned based (p_cpd_1_ptr);
      820 dcl	1 cpd_2		like control_point_data aligned based (p_cpd_2_ptr);
      821 dcl	(p_cpd_1_ptr, p_cpd_2_ptr)
      822 			pointer parameter;
      823 
      824 	if cpd_1.swapped_switches & cpd_2.swapped_switches
      825 	then return ("0"b);				/* both control points are using the root's switches */
      826 
      827 	else if cpd_1.group_id = cpd_2.group_id		/* same group: they use the same switches ... */
      828 	then return (cpd_1.swapped_switches ^= cpd_2.swapped_switches);
      829 						/* ... unless one is using the root's but not the other */
      830 
      831 	else if (cpd_1.swapped_switches & (cpd_2.group_id = cpm_data_$root_control_point_data.group_id))
      832 	     | (cpd_2.swapped_switches & (cpd_1.group_id = cpm_data_$root_control_point_data.group_id))
      833 	then return ("0"b);				/* different groups: but one is swapped to the other */
      834 
      835 	else return ("1"b);				/* different groups really using different switches */
      836 
      837      end different_switches;
      838 
      839 /* Restore the current control point's system privileges -- We need not worry about access to system_privilege_ as we only
      840*   call it when we actually discover that a privilege has changed and the only way to change privileges is to use the
      841*   system_privilege_ gate itself. */
      842 
      843 restore_privileges:
      844      procedure ();
      845 
      846 dcl	current_privileges	bit (36) aligned;
      847 
      848 	current_privileges = get_privileges_ ();
      849 
      850 	if control_point_data.privileges = current_privileges
      851 	then return;				/* privileges are already correct */
      852 
      853 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$comm_privilege
      854 	then if control_point_data.privileges & sys_info$comm_privilege
      855 	     then call system_privilege_$comm_priv_on ((0));
      856 	     else call system_privilege_$comm_priv_off ((0));
      857 
      858 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$dir_privilege
      859 	then if control_point_data.privileges & sys_info$dir_privilege
      860 	     then call system_privilege_$dir_priv_on ((0));
      861 	     else call system_privilege_$dir_priv_off ((0));
      862 
      863 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$ipc_privilege
      864 	then if control_point_data.privileges & sys_info$ipc_privilege
      865 	     then call system_privilege_$ipc_priv_on ((0));
      866 	     else call system_privilege_$ipc_priv_off ((0));
      867 
      868 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$rcp_privilege
      869 	then if control_point_data.privileges & sys_info$rcp_privilege
      870 	     then call system_privilege_$rcp_priv_on ((0));
      871 	     else call system_privilege_$rcp_priv_off ((0));
      872 
      873 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$ring1_privilege
      874 	then if control_point_data.privileges & sys_info$ring1_privilege
      875 	     then call system_privilege_$ring1_priv_on ((0));
      876 	     else call system_privilege_$ring1_priv_off ((0));
      877 
      878 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$seg_privilege
      879 	then if control_point_data.privileges & sys_info$seg_privilege
      880 	     then call system_privilege_$seg_priv_on ((0));
      881 	     else call system_privilege_$seg_priv_off ((0));
      882 
      883 	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$soos_privilege
      884 	then if control_point_data.privileges & sys_info$soos_privilege
      885 	     then call system_privilege_$soos_priv_on ((0));
      886 	     else call system_privilege_$soos_priv_off ((0));
      887 
      888 	return;
      889 
      890      end restore_privileges;
      891 
      892 /* Mask the specified IPS interrupts */
      893 
      894 mask_ips_interrupts:
      895      procedure (p_new_mask, p_old_mask);
      896 
      897 dcl	p_new_mask	bit (36) aligned parameter;
      898 dcl	p_old_mask	bit (36) aligned parameter;
      899 
      900 	call hcs_$set_ips_mask (p_new_mask, p_old_mask);
      901 
      902      end mask_ips_interrupts;
      903 
      904 
      905 
      906 /* Invoke mask_ips_interrupts -- This entrypoint exists to prevent making the mask_ips_interrupts internal procedure
      907*   non-quick by invoking it from within an on unit or other non-quick procedure. */
      908 
      909 mask_ips_interrupts_caller:
      910      entry (P_new_mask, P_old_mask);
      911 
      912 	call mask_ips_interrupts (P_new_mask, P_old_mask);
      913 	return;
      914 
      915 
      916 
      917 /* Restore the IPS mask to its state prior to calling mask_ips_interrupts */
      918 
      919 unmask_ips_interrupts:
      920      procedure (p_old_mask);
      921 
      922 dcl	p_old_mask	bit (36) aligned parameter;
      923 
      924 	if substr (p_old_mask, 36, 1) = "1"b
      925 	then call hcs_$reset_ips_mask (p_old_mask, p_old_mask);
      926 
      927      end unmask_ips_interrupts;
      928 
      929 
      930 
      931 /* Invoke unmask_ips_interrupts -- This entrypoint exists to prevent making the unmask_ips_interrupts internal procedure
      932*   non-quick by invoking it from within an on unit or other non-quick procedure. */
      933 
      934 unmask_ips_interrupts_caller:
      935      entry (P_old_mask);
      936 
      937 	call unmask_ips_interrupts (P_old_mask);
      938 	return;
      939 
      940 /* format: off */
      941  /* BEGIN INCLUDE FILE ... cpm_internal_data.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  1     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  1     6*     Written to support control point management in March 1985 by G. Palter.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9 /* format: style3,linecom */
  1    10 
  1    11 /* NOTE: This include file references structures contained in the following independent include files --
  1    12*	cpm_control_point_data.incl.pl1	cpm_ctrl_pt_meters.incl.pl1
  1    13*	process_usage.incl.pl1	*/
  1    14 
  1    15 
  1    16 /* Constants defined by the Control Point Manager for internal use only */
  1    17 
  1    18 dcl	cpm_data_$subsystem_name			/* our name for use in error messages, etc. */
  1    19 			character (32) external;
  1    20 
  1    21 
  1    22 /* Static data defined by the Control Point Manager for internal use only */
  1    23 
  1    24 dcl	1 cpm_data_$root_control_point_data		/* definition of the root control point */
  1    25 			like control_point_data aligned external;
  1    26 
  1    27 dcl	cpm_data_$gc_control_points			/* ON => there are destroyed control points to ... */
  1    28 			bit (1) aligned external;	/* ... be garbage collected */
  1    29 
  1    30 dcl	cpm_data_$saved_cl_intermediary		/* the process' original CL intermediary */
  1    31 			entry (bit (36) aligned) variable external;
  1    32 
  1    33 dcl	cpm_data_$preferred_control_point		/* -> definition of the preferred control point */
  1    34 			pointer external;
  1    35 
  1    36 dcl	1 cpm_data_$preferred_control_point_stack	/* preferred control points stacked by ... */
  1    37 			aligned external,		/* ... event calls and timers */
  1    38 	  2 stack_depth	fixed binary,		/* ... # of entries in the stack at present */
  1    39 	  2 pad		bit (36) aligned,
  1    40 	  2 cpd_ptr_stack	(16) pointer;		/* ... the actual stack */
  1    41 
  1    42 dcl	1 cpm_data_$ready_queue			/* ordered list of ready control points in the process */
  1    43 			aligned external,
  1    44 	  2 first		pointer,
  1    45 	  2 last		pointer;
  1    46 
  1    47 dcl	cpm_data_$previous_control_point		/* -> definition of control point which ran before current */
  1    48 			pointer external;
  1    49 
  1    50 dcl	1 cpm_data_$valid_control_points		/* maps stack segment numbers into an indication of ... */
  1    51 			aligned external,		/* ... whether there is a live control point there */
  1    52 	  2 map		(0:4095) bit (1) unaligned;
  1    53 
  1    54 dcl	1 cpm_data_$global_meters			/* global meters kept by the control point manager */
  1    55 			aligned external,
  1    56 	  2 overhead	like control_point_meters,	/* ... scheduling overhead */
  1    57 	  2 last_meters	like control_point_meters;	/* ... used to compute meters (not really a meter) */
  1    58 
  1    59 /* END INCLUDE FILE ... cpm_internal_data.incl.pl1 */
      941 
      942  /* BEGIN INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  2     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  2     6*     Written to support control point management in March 1985 by G. Palter.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 /* format: style3,linecom,idind22 */
  2    10 
  2    11 /* NOTE: This include file references structures contained in the following independent include files --
  2    12*	cpm_ctrl_pt_meters.incl.pl1		process_usage.incl.pl1	*/
  2    13 
  2    14 
  2    15 /* Definition of a single control point in the process */
  2    16 
  2    17 dcl	1 control_point_data  aligned based (cpd_ptr),
  2    18 	  2 id		  bit (36) aligned,		/* unique ID of this control point */
  2    19 	  2 group_id	  bit (36) aligned,		/* unique ID of containing group of control points */
  2    20 	  2 state		  fixed binary,		/* scheduling state (see below) */
  2    21 	  2 flags,
  2    22 	    3 preferred	  bit (1) unaligned,	/* ON => this is the preferred task (infinite priority) */
  2    23 	    3 swapped_switches			/* ON => this control point's switches were swapped ... */
  2    24 			  bit (1) unaligned,	/* ... with the root's during an unclaimed signal */
  2    25 	    3 pad		  bit (34) unaligned,
  2    26 	  2 priority	  fixed binary,		/* scheduling priority */
  2    27 	  2 pad		  bit (36) aligned,
  2    28 	  2 stack_ptr	  pointer,		/* -> the stack used by this control point */
  2    29 	  2 last_frame_ptr	  pointer,		/* -> last frame in said stack where control is to resume */
  2    30 	  2 destroy	  label,			/* transferring to this label will kill the control point */
  2    31 	  2 parent	  pointer,		/* -> defintion of this control point's parent */
  2    32 	  2 peers,				/* linked list of this control point's peers */
  2    33 	    3 prev_peer	  pointer,
  2    34 	    3 next_peer	  pointer,
  2    35 	  2 children,				/* linked list of this control point's children */
  2    36 	    3 first_child	  pointer,
  2    37 	    3 last_child	  pointer,
  2    38 	  2 ready_queue,				/* ordered list of control points in the ready state */
  2    39 	    3 prev_ready	  pointer,
  2    40 	    3 next_ready	  pointer,
  2    41 	  2 user_cl_intermediary			/* procedure to be called by cpm_overseer_$cl_intermediary */
  2    42 			  entry (bit (1) aligned),
  2    43 	  2 comment	  character (64),		/* a description of this control point */
  2    44 	  2 saved_environment,			/* data saved when the control point stops running ... */
  2    45 	    3 ips_mask	  bit (36) aligned,		/* ... IPS mask when it stopped running */
  2    46 	    3 privileges	  bit (36) aligned,		/* ... system privileges */
  2    47 	    3 cl_intermediary entry (bit (36) aligned),	/* ... CL intermediary */
  2    48 	    3 io_switches,				/* ... standard I/O switches */
  2    49 	      4 user_io	  pointer,
  2    50 	      4 user_input	  pointer,
  2    51 	      4 user_output	  pointer,
  2    52 	      4 error_output  pointer,
  2    53 	  2 meters	  like control_point_meters;	/* per control point metering data */
  2    54 
  2    55 dcl	cpd_ptr		  pointer;
  2    56 
  2    57 
  2    58 /* Scheduler states for a control point */
  2    59 
  2    60 dcl	(
  2    61 	CPM_DESTROYED	  initial (0),		/* waiting to be deleted */
  2    62 	CPM_STOPPED	  initial (1),		/* can not run without an explicit cpm_$start */
  2    63 	CPM_BLOCKED	  initial (2),		/* blocked on an IPC event channel */
  2    64 	CPM_READY		  initial (3)		/* eligible to run on next call to cpm_$scheduler */
  2    65 	)		  fixed binary static options (constant);
  2    66 
  2    67 /* END INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
      942 
  3     1 /* BEGIN INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  3     6*     Written to support control point management in March 1985 by G. Palter.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9 /* format: style3,linecom */
  3    10 
  3    11 /* NOTE: The include file references structures contained in the following independent include file --
  3    12*	process_usage.incl.pl1	*/
  3    13 
  3    14 
  3    15 /* Definition of control point metering data -- A set of metering data is kept independently for each control point which
  3    16*   provides usage statistics for that control point.  In addition, another set of metering data is kept to record the
  3    17*   overhead involved in the control point scheduler */
  3    18 
  3    19 dcl	1 control_point_meters
  3    20 			aligned based (cpm_ptr),
  3    21 	  2 n_schedules	fixed binary,		/* # of times the control point has been run or
  3    22*						   # of times the scheduler has been invoked */
  3    23 	  2 pad		fixed binary,
  3    24 	  2 real_time	fixed binary (71),		/* ... real time used by the control point or scheduler */
  3    25 	  2 usage		like process_usage;		/* ... CPU, memory, etc. */
  3    26 
  3    27 dcl	cpm_ptr		pointer;
  3    28 
  3    29 
  3    30 /* Definition of the structure used in calls to cpm_$get_control_point_meters and cpm_$get_scheduler_meters */
  3    31 
  3    32 dcl	1 control_point_meters_argument
  3    33 			aligned based (cpma_ptr),
  3    34 	  2 version	character (8) unaligned,
  3    35 	  2 meters	like control_point_meters;
  3    36 
  3    37 dcl	CONTROL_POINT_METERS_ARGUMENT_VERSION_1
  3    38 			character (8) static options (constant) initial ("cpma_001");
  3    39 
  3    40 dcl	MAX_NUMBER_OF_METERS
  3    41 			fixed bin internal static options (constant) init (9);
  3    42 
  3    43 dcl	cpma_ptr		pointer;
  3    44 
  3    45 /* END INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
      943 
  4     1 /* BEGIN INCLUDE FILE process_usage.incl.pl1 WRITTEN 09/17/76 BY Richard Bratt */
  4     2 
  4     3 declare
  4     4          process_usage_pointer pointer,
  4     5          1 process_usage based (process_usage_pointer),
  4     6          2 number_wanted fixed bin,			/* max number of entries to be returned */
  4     7          2 number_can_return fixed bin,			/* the number of entries currently returnable */
  4     8          2 cpu_time fixed bin (71),
  4     9          2 paging_measure fixed bin (71),
  4    10          2 page_faults fixed bin (34),
  4    11          2 pd_faults fixed bin (34),
  4    12          2 virtual_cpu_time fixed bin (71),
  4    13          2 segment_faults fixed bin (34),
  4    14          2 bounds_faults fixed bin (34),
  4    15          2 vtoc_reads fixed bin (34),
  4    16          2 vtoc_writes fixed bin (34);
  4    17 
  4    18 /* END INCLUDE FILE process_usage.incl.pl1      */
      944 
      945  /* BEGIN INCLUDE FILE ... cpm_create_ctrl_pt_info.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  5     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  5     6*     Written to support control point management in March 1985 by G. Palter.
  5     7*                                                   END HISTORY COMMENTS */
  5     8 
  5     9 /* format: style3,linecom */
  5    10 
  5    11 /* Description of a new control point to be created by a call to cpm_$create */
  5    12 
  5    13 dcl	1 create_control_point_info
  5    14 			aligned based (ccpi_ptr),
  5    15 	  2 header,
  5    16 	    3 version	character (8) unaligned,
  5    17 	    3 comment	character (64) unaligned,	/* a description of the control point */
  5    18 	    3 initproc,				/* definition of the first user code to be run */
  5    19 	      4 entry	entry (pointer) variable,	/* ... the actual program */
  5    20 	      4 info_ptr	pointer,			/* ... and its single parameter */
  5    21 	    3 user_cl_intermediary			/* user program to be called by cpm_cl_intermediary_ */
  5    22 			entry (bit (1) aligned) variable,
  5    23 	    3 priority	fixed binary,		/* scheduling prioirty (1 is highest, 2 next, etc.) */
  5    24 	    3 flags,
  5    25 	      4 independent bit (1) unaligned,		/* ON => the new control point is standalone */
  5    26 						/* OFF => the new control point belongs to the current one */
  5    27 	      4 separate_standard_iocbs		/* ON => the new control point should have its own switches */
  5    28 			bit (1) unaligned,		/* OFF => the new control point shares its parent's */
  5    29 	      4 user_io_attach_desc_given		/* ON => there is an attach description for user_i/o */
  5    30 			bit (1) unaligned,		/* OFF => user_i/o should be syn_'ed to the parent's */
  5    31 	      4 user_cl_intermediary_given		/* ON => user has supplied a program to be called by ... */
  5    32 			bit (1) unaligned,		/* ... cpm_cl_intermediary_ before creating a new level */
  5    33 	      4 pad	bit (32) unaligned,
  5    34 	    3 pad		bit (36) aligned,
  5    35 	    3 user_io_attach_desc_length		/* length of the user_i/o attach description (if present) */
  5    36 			fixed binary (21),
  5    37 	  2 user_io_attach_desc			/* attach description for user_i/o */
  5    38 			character (ccpi_user_io_attach_desc_length
  5    39 			refer (create_control_point_info.user_io_attach_desc_length)) unaligned;
  5    40 
  5    41 dcl	CREATE_CONTROL_POINT_INFO_VERSION_1
  5    42 			character (8) static options (constant) initial ("ccpi_001");
  5    43 
  5    44 dcl	ccpi_user_io_attach_desc_length		/* required to allocate the above structure */
  5    45 			fixed binary (21);
  5    46 dcl	ccpi_ptr		pointer;
  5    47 
  5    48 /* END INCLUDE FILE ... cpm_create_ctrl_pt_info.incl.pl1 */
      945 
      946  /* BEGIN INCLUDE FILE ... cpm_entries.incl.pl1 */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  6     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  6     6*     Written to support control point management in March 1985 by G. Palter.
  6     7*                                                   END HISTORY COMMENTS */
  6     8 
  6     9 /* format: style3,linecom */
  6    10 
  6    11 /* Control Point Manager (cpm_) entrypoint definitions */
  6    12 
  6    13 dcl	get_control_point_id_			/* returns the ID of the currently running control point */
  6    14 			entry () returns (bit (36) aligned);
  6    15 
  6    16 dcl	cpm_$create				/* create a new control point */
  6    17 			entry (pointer, bit (36) aligned, fixed binary (35));
  6    18 
  6    19 dcl	(
  6    20 	cpm_$destroy,				/* destroy the specified control point */
  6    21 	cpm_$start,				/* start the specified control point if its stopped */
  6    22 	cpm_$wakeup,				/* make the specified control point ready if its blocked */
  6    23 	cpm_$stop					/* stop the specified control point if its ready or blocked */
  6    24 	)		entry (bit (36) aligned, fixed binary (35));
  6    25 
  6    26 dcl	cpm_$block	entry ();			/* block the current control point */
  6    27 
  6    28 dcl	cpm_$scheduler	entry ();			/* find a runnable control point and let it run */
  6    29 
  6    30 dcl	(
  6    31 	cpm_$get_user_cl_intermediary,		/* get the user supplied procedure to run during cu_$cl */
  6    32 	cpm_$set_user_cl_intermediary			/* set the user supplied procedure to run during cu_$cl */
  6    33 	)		entry (bit (36) aligned, entry (bit (1) aligned), fixed binary (35));
  6    34 
  6    35 dcl	(
  6    36 	cpm_$generate_call,				/* generate an immediate call */
  6    37 	cpm_$generate_call_preferred,			/* generate an immediate call and make it run preferred */
  6    38 	cpm_$generate_call_when_ready			/* generate a call when the control point is next ready */
  6    39 	)		entry (bit (36) aligned, entry (pointer), pointer, fixed binary (35));
  6    40 
  6    41 dcl	cpm_$get_preferred_control_point		/* return the ID of the preferred control point */
  6    42 			entry () returns (bit (36) aligned);
  6    43 dcl	cpm_$set_preferred_control_point		/* make the specified control point preferred */
  6    44 			entry (bit (36) aligned, fixed binary (35));
  6    45 dcl	cpm_$push_preferred_control_point		/* switch preferred control points */
  6    46 			entry (bit (36) aligned, bit (1) aligned, fixed binary (35));
  6    47 dcl	cpm_$pop_preferred_control_point		/* restore the previous preferred control point */
  6    48 			entry (bit (1) aligned);
  6    49 
  6    50 dcl	cpm_$get_control_point_meters			/* get the usage meters for a specific control point */
  6    51 			entry (bit (36) aligned, pointer, fixed binary (35));
  6    52 dcl	cpm_$get_scheduler_meters			/* get the usage meters for the control point scheduler */
  6    53 			entry (pointer, fixed binary (35));
  6    54 
  6    55 dcl	cpm_$nulle	entry () options (variable);	/* a "null" entry value which should never be called */
  6    56 
  6    57 /* END INCLUDE FILE ... cpm_entries.incl.pl1 */
      946 
      947  /* BEGIN INCLUDE FILE ... cpm_generate_call_flags.incl.pl1 */
  7     2 
  7     3 /****^  HISTORY COMMENTS:
  7     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  7     6*     Written to support control point management in March 1985 by G. Palter.
  7     7*                                                   END HISTORY COMMENTS */
  7     8 
  7     9 /* format: style3,linecom */
  7    10 
  7    11 /* Flags used to control the operation of cpm_overseer_$generate_call */
  7    12 
  7    13 dcl	(
  7    14 	CPM_GC_FORCE_READY				/* force the control point into the ready state */
  7    15 			initial ("400000000000"b3),
  7    16 	CPM_GC_PUSH_PREFERRED			/* make the control point preferred while running */
  7    17 			initial ("200000000000"b3)
  7    18 	)		bit (36) aligned static options (constant);
  7    19 
  7    20 /* END INCLUDE FILE ... cpm_generate_call_flags.incl.pl1 */
      947 
      948  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  8     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  8     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  8     4 /*	Modified April 1983 by C. Hornig for tasking */
  8     5 
  8     6 /****^  HISTORY COMMENTS:
  8     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  8     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  8     9*     added the heap_header_ptr definition.
  8    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  8    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  8    12*     Modified to support control point management.  These changes were actually
  8    13*     made in February 1985 by G. Palter.
  8    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  8    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  8    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  8    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  8    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  8    19*     (ITS pair).
  8    20*                                                   END HISTORY COMMENTS */
  8    21 
  8    22 /* format: style2 */
  8    23 
  8    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  8    25 
  8    26      dcl	   1 stack_header	      based (sb) aligned,
  8    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  8    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  8    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  8    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  8    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  8    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  8    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  8    34 	     2 pad4	      bit (2) unal,
  8    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  8    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  8    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  8    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  8    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  8    40 	     2 null_ptr	      ptr,		/*  (16)  */
  8    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  8    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  8    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  8    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  8    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  8    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  8    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  8    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  8    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  8    50 	     2 return_no_pop_op_ptr
  8    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  8    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  8    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  8    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  8    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  8    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  8    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  8    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  8    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  8    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  8    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  8    62 	     2 trace,
  8    63 	       3 frames,
  8    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  8    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  8    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  8    67 	     2 pad2	      bit (36),		/*  (61) */
  8    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  8    69 
  8    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  8    71 
  8    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  8    73 						/* (551) octal */
  8    74 
  8    75 
  8    76 /*	The following constants are offsets within this transfer vector table.  */
  8    77 
  8    78      dcl	   (
  8    79 	   call_offset	      fixed bin init (271),
  8    80 	   push_offset	      fixed bin init (272),
  8    81 	   return_offset	      fixed bin init (273),
  8    82 	   return_no_pop_offset   fixed bin init (274),
  8    83 	   entry_offset	      fixed bin init (275)
  8    84 	   )		      internal static;
  8    85 
  8    86 
  8    87 
  8    88 
  8    89 
  8    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  8    91*	move the whole stack header should use this overlay.
  8    92**/
  8    93 
  8    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  8    95 
  8    96 
  8    97 
  8    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      948 
      949  /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  9     2 
  9     3 /* Written 05/04/78 by C. D. Tavares */
  9     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  9     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  9     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  9     7 
  9     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  9     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  9    10      iox_$close entry (pointer, fixed bin (35)),
  9    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  9    12      iox_$delete_record entry (pointer, fixed bin (35)),
  9    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  9    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  9    15      iox_$err_not_attached entry options (variable),
  9    16      iox_$err_not_closed entry options (variable),
  9    17      iox_$err_no_operation entry options (variable),
  9    18      iox_$err_not_open entry options (variable),
  9    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  9    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  9    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  9    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  9    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  9    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  9    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  9    28      iox_$propagate entry (pointer),
  9    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  9    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  9    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  9    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  9    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  9    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  9    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  9    40 
  9    41 dcl (iox_$user_output,
  9    42      iox_$user_input,
  9    43      iox_$user_io,
  9    44      iox_$error_output) external static pointer;
  9    45 
  9    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      949 
      950  /* Begin include file ..... iox_modes.incl.pl1 */
 10     2 
 10     3 /* Written by C. D. Tavares, 03/17/75 */
 10     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 10     5 
 10     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 10     7     ("stream_input", "stream_output", "stream_input_output",
 10     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 10     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 10    10      "direct_input", "direct_output", "direct_update");
 10    11 
 10    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 10    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 10    14 
 10    15 dcl (Stream_input initial (1),
 10    16      Stream_output initial (2),
 10    17      Stream_input_output initial (3),
 10    18      Sequential_input initial (4),
 10    19      Sequential_output initial (5),
 10    20      Sequential_input_output initial (6),
 10    21      Sequential_update initial (7),
 10    22      Keyed_sequential_input initial (8),
 10    23      Keyed_sequential_output initial (9),
 10    24      Keyed_sequential_update initial (10),
 10    25      Direct_input initial (11),
 10    26      Direct_output initial (12),
 10    27      Direct_update initial (13)) fixed bin int static options (constant);
 10    28 
 10    29 /* End include file ..... iox_modes.incl.pl1 */
      950 
      951  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
      951 
      952  /*  START OF:	trace_interface.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12     2 /* Written: May 1984 by Jeffrey D. Ives. */
 12     3 /* format: style2,^inddcls,^indnoniterdo,^inditerdo,dclind5,idind35 */
 12     4 
 12     5 /* IDENTIFICATION */
 12     6 
 12     7 dcl  trace_$me			entry () returns (char (32));
 12     8 dcl  trace_$version			entry () returns (char (32));
 12     9 
 12    10 /* TRANSACTIONS */
 12    11 
 12    12 dcl  trace_$transaction_begin		entry (fixed bin (71)) returns (bit aligned);
 12    13 dcl  trace_$transaction_begin_force	entry (fixed bin (71));
 12    14 dcl  trace_$transaction_end		entry (fixed bin (71)) returns (bit aligned);
 12    15 
 12    16 /* ACTIONS */
 12    17 
 12    18 dcl  trace_$update_default_parms	entry () returns (bit aligned);
 12    19 dcl  trace_$update_global_parms	entry () returns (bit aligned);
 12    20 dcl  trace_$add_specified_eps		entry (fixed bin, fixed bin);
 12    21 dcl  trace_$add_specified_locs	entry (fixed bin, fixed bin);
 12    22 dcl  trace_$remove_specified_eps	entry (fixed bin);
 12    23 dcl  trace_$remove_specified_locs	entry (fixed bin);
 12    24 dcl  trace_$turn_on_specified_eps	entry (fixed bin);
 12    25 dcl  trace_$turn_off_specified_eps	entry (fixed bin);
 12    26 
 12    27 /* CONVERSION */
 12    28 
 12    29 dcl  trace_$cv_inout_to_bits		entry (char (8) aligned) returns (bit (2) aligned);
 12    30 dcl  trace_$cv_bits_to_inout		entry (bit (2) aligned) returns (char (8) aligned);
 12    31 dcl  trace_$cv_n_to_number		entry (char (16)) returns (fixed bin (34));
 12    32 dcl  trace_$cv_onoff_to_bit		entry (char (8) aligned) returns (bit aligned);
 12    33 dcl  trace_$cv_bit_to_onoff		entry (bit aligned) returns (char (8) aligned);
 12    34 dcl  trace_$cv_entry_name_to_spp	entry (char (256) var, ptr) returns (1 like stop_proc aligned);
 12    35 dcl  trace_$cv_file_path_to_osw	entry (char (256) var, ptr) returns (1 like output_switch aligned);
 12    36 dcl  trace_$cv_stream_name_to_osw	entry (char (32) var) returns (1 like output_switch aligned);
 12    37 
 12    38 /* METERS */
 12    39 
 12    40 dcl  trace_$entrypoint_counts		entry (fixed bin) returns (1 aligned like counts);
 12    41 dcl  trace_$entrypoint_global_meters	entry (fixed bin) returns (1 like meters aligned);
 12    42 dcl  trace_$entrypoint_local_meters	entry (fixed bin) returns (1 like meters aligned);
 12    43 dcl  trace_$metered			entry () returns (1 like meters aligned);
 12    44 dcl  trace_$removed			entry () returns (1 like meters aligned);
 12    45 dcl  trace_$reset_meters		entry ();
 12    46 
 12    47 /* ENTRYPOINTS */
 12    48 
 12    49 dcl  trace_$entrypoint_index		entry (ptr unal) returns (fixed bin);
 12    50 dcl  trace_$entrypoint_name		entry (fixed bin) returns (char (65) var);
 12    51 dcl  trace_$entrypoint_ptr		entry (fixed bin) returns (ptr);
 12    52 dcl  trace_$entrypoint_seg_path	entry (fixed bin) returns (char (256) var);
 12    53 dcl  trace_$entrypoint_status		entry (fixed bin) returns (char (32) var);
 12    54 dcl  trace_$function		entry (fixed bin) returns (bit aligned);
 12    55 dcl  trace_$num_entrypoints		entry () returns (fixed bin);
 12    56 dcl  trace_$num_specified_entrypoints	entry () returns (fixed bin);
 12    57 dcl  trace_$specified_entrypoint_index	entry (fixed bin) returns (fixed bin);
 12    58 dcl  trace_$specify_entrypoints	entry (char (256) var, ptr);
 12    59 dcl  trace_$translator_id		entry (fixed bin) returns (fixed bin);
 12    60 
 12    61 /* LOCATIONS */
 12    62 
 12    63 dcl  trace_$location_ptr		entry (fixed bin) returns (ptr);
 12    64 dcl  trace_$location_seg_path		entry (fixed bin) returns (char (256) var);
 12    65 dcl  trace_$location_values		entry (fixed bin) returns (1 aligned like watch_values);
 12    66 dcl  trace_$num_locations		entry () returns (fixed bin);
 12    67 dcl  trace_$num_specified_locations	entry () returns (fixed bin);
 12    68 dcl  trace_$specified_location_index	entry (fixed bin) returns (fixed bin);
 12    69 dcl  trace_$specify_locations		entry (char (256) var);
 12    70 dcl  trace_$specify_changed_locations	entry ();
 12    71 
 12    72 /* EVENT BUFFER */
 12    73 
 12    74 dcl  trace_$buffer_counts		entry (fixed bin (34), fixed bin (34));
 12    75 dcl  trace_$buffer_event		entry (fixed bin (34), fixed bin, char (2), ptr unal, 1 like counts aligned, 1 like meters aligned);
 12    76 dcl  trace_$buffer_event_header	entry (fixed bin (34)) returns (char (256) var);
 12    77 dcl  trace_$buffer_event_string	entry (fixed bin (34)) returns (char (256) var);
 12    78 dcl  trace_$buffer_ptr		entry () returns (ptr unal);
 12    79 
 12    80 /* TRACE PARAMETERS */
 12    81 
 12    82 dcl  trace_$arguments		entry (fixed bin) returns (bit (2) aligned);
 12    83 dcl  trace_$set_arguments		entry (bit (2) aligned);
 12    84 dcl  trace_$call			entry (fixed bin) returns (char (256) var);
 12    85 dcl  trace_$set_call		entry (char (256) var);
 12    86 dcl  trace_$every			entry (fixed bin) returns (fixed bin (34));
 12    87 dcl  trace_$set_every		entry (fixed bin (34));
 12    88 dcl  trace_$first			entry (fixed bin) returns (fixed bin (34));
 12    89 dcl  trace_$set_first		entry (fixed bin (34));
 12    90 dcl  trace_$high			entry (fixed bin) returns (fixed bin (34));
 12    91 dcl  trace_$set_high		entry (fixed bin (34));
 12    92 dcl  trace_$last			entry (fixed bin) returns (fixed bin (34));
 12    93 dcl  trace_$set_last		entry (fixed bin (34));
 12    94 dcl  trace_$low			entry (fixed bin) returns (fixed bin (34));
 12    95 dcl  trace_$set_low			entry (fixed bin (34));
 12    96 dcl  trace_$new_high		entry (fixed bin) returns (bit aligned);
 12    97 dcl  trace_$set_new_high		entry (bit aligned);
 12    98 dcl  trace_$parms_string		entry (fixed bin, bit aligned) returns (char (256) var);
 12    99 dcl  trace_$parms_specified		entry () returns (bit aligned);
 12   100 dcl  trace_$stop			entry (fixed bin) returns (bit (2) aligned);
 12   101 dcl  trace_$set_stop		entry (bit (2) aligned);
 12   102 dcl  trace_$stop_every		entry (fixed bin) returns (fixed bin (34));
 12   103 dcl  trace_$set_stop_every		entry (fixed bin (34));
 12   104 dcl  trace_$stop_low		entry (fixed bin) returns (fixed bin (34));
 12   105 dcl  trace_$set_stop_low		entry (fixed bin (34));
 12   106 dcl  trace_$trace			entry (fixed bin) returns (bit (2) aligned);
 12   107 dcl  trace_$set_trace		entry (bit (2) aligned);
 12   108 
 12   109 /* GLOBAL PARAMETERS */
 12   110 
 12   111 dcl  trace_$alm			entry () returns (bit aligned);
 12   112 dcl  trace_$set_alm			entry (bit aligned);
 12   113 dcl  trace_$automatic		entry () returns (bit aligned);
 12   114 dcl  trace_$set_automatic		entry (bit aligned);
 12   115 dcl  trace_$buffer			entry () returns (bit aligned);
 12   116 dcl  trace_$set_buffer		entry (bit aligned);
 12   117 dcl  trace_$calibrate		entry () returns (bit aligned);
 12   118 dcl  trace_$set_calibrate		entry (bit aligned);
 12   119 dcl  trace_$compensation		entry (fixed bin) returns (1 aligned like compensation);
 12   120 dcl  trace_$set_compensation		entry (fixed bin, 1 aligned like compensation);
 12   121 dcl  trace_$enabled			entry () returns (bit aligned);
 12   122 dcl  trace_$set_enabled		entry (bit aligned);
 12   123 dcl  trace_$global_parms_string	entry () returns (char (256) var);
 12   124 dcl  trace_$long			entry () returns (bit aligned);
 12   125 dcl  trace_$set_long		entry (bit aligned);
 12   126 dcl  trace_$meter			entry () returns (bit aligned);
 12   127 dcl  trace_$set_meter		entry (bit aligned);
 12   128 dcl  trace_$output_switch		entry () returns (1 like output_switch aligned);
 12   129 dcl  trace_$set_output_switch		entry (1 like output_switch aligned);
 12   130 dcl  trace_$signals			entry () returns (bit aligned);
 12   131 dcl  trace_$set_signals		entry (bit aligned);
 12   132 dcl  trace_$stop_proc		entry () returns (1 like stop_proc);
 12   133 dcl  trace_$set_stop_proc		entry (1 like stop_proc);
 12   134 dcl  trace_$stop_routine		entry () returns (entry);
 12   135 dcl  trace_$set_stop_routine		entry (entry);
 12   136 dcl  trace_$trace_routine		entry () returns (entry);
 12   137 dcl  trace_$set_trace_routine		entry (entry);
 12   138 dcl  trace_$loud			entry () returns (bit aligned);
 12   139 dcl  trace_$set_loud		entry (bit aligned);
 12   140 
 12   141 /* MISCELLANEOUS */
 12   142 
 12   143 dcl  trace_$in_trace		entry () returns (bit aligned);
 12   144 
 12   145 /* STRUCTURES AND CONSTANTS */
 12   146 
 12   147 dcl  1 watch_values			aligned,
 12   148        2 old			bit (36),
 12   149        2 new			bit (36);
 12   150 
 12   151 dcl  1 counts			aligned,
 12   152        2 calls			fixed bin (53),	/* total number of calls			*/
 12   153        2 level			fixed bin (34),	/* current recursion level			*/
 12   154        2 max_level			fixed bin (34);	/* max ever recursion level			*/
 12   155 
 12   156 
 12   157 dcl  1 meters			aligned,
 12   158        2 real_time			fixed bin (53),	/* The total amount of real time metered.	*/
 12   159        2 vcpu_time			fixed bin (53),	/* The total amount of virtual cpu time metered.	*/
 12   160        2 page_faults		fixed bin (34);	/* The total number of page faults metered.	*/
 12   161 
 12   162 dcl  1 output_switch		aligned based,
 12   163        2 iocb_ptr			ptr,
 12   164        2 stream_name		char (32) var,
 12   165        2 file_path			char (256) var;
 12   166 
 12   167 dcl  1 stop_proc			aligned based,
 12   168        2 entry_value		entry (),
 12   169        2 entry_name			char (256) var;
 12   170 
 12   171 dcl  1 compensation			aligned,
 12   172        2 real_time			fixed bin (53),
 12   173        2 vcpu_time			fixed bin (53);
 12   174 
 12   175 dcl  (
 12   176      COMPENSATION_FROM_ENTRY_TO_ENTRY	init (1),
 12   177      COMPENSATION_FROM_ENTRY_TO_RETURN	init (2),
 12   178      COMPENSATION_FROM_RETURN_TO_ENTRY	init (3),
 12   179      COMPENSATION_FROM_RETURN_TO_RETURN init (4)
 12   180      )				static options (constant);
 12   181 
 12   182 /*  END OF:	trace_interface.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      952 
      953 /* format: on */
      954 
      955      end cpm_overseer_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1031.4  cpm_overseer_.pl1                 >special_ldd>install>MR12.0-1206>cpm_overseer_.pl1
941          1    11/03/86  1113.3  cpm_internal_data.incl.pl1        >special_ldd>install>MR12.0-1206>cpm_internal_data.incl.pl1
942          2    11/03/86  1112.9  cpm_control_point_data.incl.pl1   >special_ldd>install>MR12.0-1206>cpm_control_point_data.incl.pl1
943          3    11/03/86  1114.7  cpm_ctrl_pt_meters.incl.pl1       >special_ldd>install>MR12.0-1206>cpm_ctrl_pt_meters.incl.pl1
944          4    10/26/76  1333.6  process_usage.incl.pl1            >ldd>include>process_usage.incl.pl1
945          5    11/03/86  1113.1  cpm_create_ctrl_pt_info.incl.pl1  >special_ldd>install>MR12.0-1206>cpm_create_ctrl_pt_info.incl.pl1
946          6    11/03/86  1113.3  cpm_entries.incl.pl1              >special_ldd>install>MR12.0-1206>cpm_entries.incl.pl1
947          7    11/03/86  1113.3  cpm_generate_call_flags.incl.pl1  >special_ldd>install>MR12.0-1206>cpm_generate_call_flags.incl.pl1
948          8    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
949          9    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
950         10    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
951         11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
952         12    10/23/84  1349.5  trace_interface.incl.pl1          >ldd>include>trace_interface.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_DEFAULT_RESTART          000000 constant        bit(36)                  initial dcl 11-7 set ref 550* 565* 582*
CPM_GC_FORCE_READY                     constant        bit(36)                  initial dcl 7-13 ref 221 269
CPM_GC_PUSH_PREFERRED           000000 constant        bit(36)                  initial dcl 7-13 ref 228
CPM_READY                       000041 constant        fixed bin(17,0)          initial dcl 2-60 set ref 224 224* 269
P_ccpi_ptr                             parameter       pointer                  dcl 27 ref 137 143 642 646
P_cl_flags                             parameter       bit(36)                  dcl 39 set ref 280 326*
P_cpd_ptr                              parameter       pointer                  dcl 44 ref 642 645 741 744 773 776
P_cpd_swapped_switches                 parameter       bit(1)                   unaligned dcl 48 set ref 700 711*
P_gcf_ptr                              parameter       pointer                  dcl 33 ref 197 201
P_initproc                             parameter       entry variable           dcl 28 set ref 137 168*
P_initproc_arg_list_ptr                parameter       pointer                  dcl 30 set ref 137 168*
P_new_cpd_ptr                          parameter       pointer                  dcl 47 set ref 700 711*
P_new_mask                             parameter       bit(36)                  dcl 53 set ref 909 912*
P_new_swapped_switches_setting         parameter       bit(1)                   dcl 50 set ref 700 711*
P_old_cpd_ptr                          parameter       pointer                  dcl 46 set ref 700 711*
P_old_mask                             parameter       bit(36)                  dcl 54 set ref 642 648* 909 912* 934 937*
P_userproc                             parameter       entry variable           dcl 34 set ref 197 245*
P_userproc_arg_list_ptr                parameter       pointer                  dcl 36 set ref 197 245*
Stream_input_output             000041 constant        fixed bin(17,0)          initial dcl 10-15 set ref 440*
addr                                                   builtin function         dcl 128 ref 297 297 302 302 326 354 354 394 394 399
                                                                                  399 405 405 464 464 603 603 758 758
an_iocb_ptr                     000170 automatic       pointer                  dcl 423 in procedure "create_control_point_switches"
                                                                                  set ref 477* 479 481* 482*
an_iocb_ptr                     000334 automatic       pointer                  dcl 599 in procedure
                                                                                  "destroy_control_point_switches" set ref 617* 618
                                                                                  620* 621*
any_other                       000106 stack reference condition                dcl 125 ref 140 330 336 344 704
attach_description              000233 automatic       varying char(128)        dcl 510 set ref 516* 517* 517 518* 518 519* 519 522
                                                                                  523*
attach_failure                                         generic function         dcl 535 ref 438 523
based_generate_call_flags              based           bit(36)                  dcl 62 ref 201
bool                                                   builtin function         dcl 128 ref 853 858 863 868 873 878 883
ccpi_ptr                        000124 automatic       pointer                  dcl 5-46 set ref 143* 158 163* 171 434 436 438 488
                                                                                  627 646*
cl_intermediary          62            based           entry variable           level 3 dcl 2-17 set ref 148* 237* 258*
cleanup                         000114 stack reference condition                dcl 126 ref 156 161 208 294 392
code                            000211 automatic       fixed bin(35,0)          dcl 427 set ref 436* 438 438* 440* 441 441* 522* 523
                                                                                  523*
comment                  40            based           char(64)                 level 2 dcl 2-17 set ref 332 332*
compensation                    000142 automatic       structure                level 1 dcl 12-171
continue_to_signal_             000026 constant        entry                    external dcl 86 ref 708
control_point_data                     based           structure                level 1 dcl 2-17
control_point_meters                   based           structure                level 1 dcl 3-19
counts                          000130 automatic       structure                level 1 dcl 12-151
cpd_1                                  based           structure                level 1 dcl 819
cpd_2                                  based           structure                level 1 dcl 820
cpd_ptr                         000122 automatic       pointer                  dcl 2-55 set ref 142* 148 153 156* 163* 164* 200*
                                                                                  218* 223 224 224* 228 231 232 234* 237 242 250 251
                                                                                  255 258 261* 264 269* 283* 289 296* 297 297* 297
                                                                                  302 302* 302 310 315 326 332 332 332 341 354* 354
                                                                                  390 394 394* 394 399* 399 405 405* 405 431 446 460
                                                                                  461 461 464* 464 467* 467 470 603 603* 603 606*
                                                                                  606 606 608 611 611 612 612 615 645* 725 725 728
                                                                                  744* 758* 776* 787 788 789 790 803 804 805 806 850
                                                                                  853 853 858 858 863 863 868 868 873 873 878 878
                                                                                  883 883
cpm_$call_self_destruct         000030 constant        entry                    external dcl 87 ref 330
cpm_$nulle                      000142 constant        entry                    external dcl 6-55 ref 310
cpm_$pop_preferred_control_point
                                000140 constant        entry                    external dcl 6-47 ref 217 266
cpm_$push_preferred_control_point
                                000136 constant        entry                    external dcl 6-45 ref 228
cpm_$scheduler                  000134 constant        entry                    external dcl 6-28 ref 342
cpm_$stop                       000132 constant        entry                    external dcl 6-19 ref 341
cpm_$update_state_caller        000032 constant        entry                    external dcl 89 ref 224 269
cpm_data_$previous_control_point
                                000130 external static pointer                  dcl 1-47 set ref 234* 261* 464 467*
cpm_data_$root_control_point_data
                                000124 external static structure                level 1 dcl 1-24 set ref 297 297 302 302 326 354 354
                                                                                  394 394 399 399 405 405 464 464 603 603 758 758
cpm_data_$saved_cl_intermediary 000126 external static entry variable           dcl 1-30 ref 326
cpm_data_$subsystem_name        000122 external static char(32)                 unaligned dcl 1-18 set ref 332* 550* 565* 582*
cpm_data_ptr              4            based           pointer                  level 2 dcl 8-26 ref 142 200 283
create_control_point_info              based           structure                level 1 dcl 5-13
cu_$arg_list_ptr                000034 constant        entry                    external dcl 91 ref 387
cu_$generate_call               000036 constant        entry                    external dcl 92 ref 168 245 403
cu_$get_cl_intermediary         000040 constant        entry                    external dcl 93 ref 258
cu_$set_cl_intermediary         000042 constant        entry                    external dcl 93 ref 148 237
current_privileges              000412 automatic       bit(36)                  dcl 846 set ref 848* 850 853 858 863 868 873 878 883
default_error_handler_$wall     000044 constant        entry                    external dcl 97 ref 377
default_error_handler_$wall_ignore_pi
                                000046 constant        entry                    external dcl 99 ref 383
error_output             74            based           pointer                  level 4 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 790* 806*
error_output              6     000324 automatic       pointer                  level 2 in structure "local_io_switches" dcl 598
                                                                                  in procedure "destroy_control_point_switches" set
                                                                                  ref 617
error_output             74            based           pointer                  level 4 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches" set ref 679*
error_output             74            based           pointer                  level 4 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches" set ref 684*
error_output              6     000160 automatic       pointer                  level 2 in structure "local_io_switches" dcl 421
                                                                                  in procedure "create_control_point_switches" set
                                                                                  ref 456* 477
flags                     3            based           structure                level 2 in structure "cpd_1" dcl 819 in procedure
                                                                                  "different_switches"
flags                     3            based           structure                level 2 in structure "cpd_2" dcl 820 in procedure
                                                                                  "different_switches"
flags                     3            based           structure                level 2 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_"
flags                     3            based           structure                level 2 in structure "parent_control_point_data"
                                                                                  dcl 59 in procedure "cpm_overseer_"
flags                    35            based           structure                level 3 in structure "create_control_point_info"
                                                                                  dcl 5-13 in procedure "cpm_overseer_"
generate_call_flags             000101 automatic       bit(36)                  dcl 67 set ref 201* 221 228 269
get_privileges_                 000050 constant        entry                    external dcl 101 ref 255 848
group_id                  1            based           bit(36)                  level 2 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 461* 611* 728
group_id                  1            based           bit(36)                  level 2 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches" ref 670
group_id                  1            based           bit(36)                  level 2 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches" ref 670
group_id                  1            based           bit(36)                  level 2 in structure "parent_control_point_data"
                                                                                  dcl 59 in procedure "cpm_overseer_" ref 611
group_id                  1     000124 external static bit(36)                  level 2 in structure
                                                                                  "cpm_data_$root_control_point_data" dcl 1-24
                                                                                  in procedure "cpm_overseer_" set ref 728 831 831
group_id                  1            based           bit(36)                  level 2 in structure "cpd_2" dcl 820 in procedure
                                                                                  "different_switches" ref 827 831
group_id                  1            based           bit(36)                  level 2 in structure "cpd_1" dcl 819 in procedure
                                                                                  "different_switches" ref 827 831
hcs_$get_ips_mask               000052 constant        entry                    external dcl 102 ref 250
hcs_$reset_ips_mask             000054 constant        entry                    external dcl 103 ref 924
hcs_$set_ips_mask               000056 constant        entry                    external dcl 104 ref 900
header                                 based           structure                level 2 dcl 5-13
id                                     based           bit(36)                  level 2 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 228* 332*
                                                                                  341* 431* 461
id                                     based           bit(36)                  level 2 in structure "parent_control_point_data"
                                                                                  dcl 59 in procedure "cpm_overseer_" set ref 446*
id_string                       000172 automatic       char(12)                 unaligned dcl 424 set ref 431* 432 512
io_switches              66            based           structure                level 3 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 460* 608 612*
io_switches              66            based           structure                level 3 in structure "parent_control_point_data"
                                                                                  dcl 59 in procedure "cpm_overseer_" ref 612
io_switches              66            based           structure                level 3 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches"
io_switches              66            based           structure                level 3 in structure "cpd_2" dcl 820 in procedure
                                                                                  "different_switches"
io_switches              66            based           structure                level 3 in structure "cpd_1" dcl 819 in procedure
                                                                                  "different_switches"
io_switches              66     000124 external static structure                level 3 in structure
                                                                                  "cpm_data_$root_control_point_data" dcl 1-24
                                                                                  in procedure "cpm_overseer_"
io_switches              66            based           structure                level 3 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches"
ioa_$ioa_switch                 000060 constant        entry                    external dcl 105 ref 332
ioa_$rsnnl                      000062 constant        entry                    external dcl 106 ref 431 446
iox_$attach_name                000144 constant        entry                    external dcl 9-8 ref 436 522
iox_$close                      000146 constant        entry                    external dcl 9-8 ref 488 627
iox_$control                    000150 constant        entry                    external dcl 9-8 ref 723 725 728 758 761
iox_$destroy_iocb               000152 constant        entry                    external dcl 9-8 ref 482 491 621 630
iox_$detach_iocb                000154 constant        entry                    external dcl 9-8 ref 481 490 620 629
iox_$error_output               000170 external static pointer                  dcl 9-41 set ref 332* 679* 684* 790* 806*
iox_$move_attach                000156 constant        entry                    external dcl 9-8 ref 676 677 678 679 681 682 683 684
                                                                                  787 788 789 790 803 804 805 806
iox_$open                       000160 constant        entry                    external dcl 9-8 ref 440
iox_$user_input                 000164 external static pointer                  dcl 9-41 set ref 677* 682* 788* 804*
iox_$user_io                    000166 external static pointer                  dcl 9-41 set ref 676* 681* 723* 761* 787* 803*
iox_$user_output                000162 external static pointer                  dcl 9-41 set ref 678* 683* 789* 805*
ips_mask                 60            based           bit(36)                  level 3 dcl 2-17 set ref 153* 242* 250* 251* 470*
                                                                                  615*
local_io_switches               000160 automatic       structure                level 1 dcl 421 in procedure
                                                                                  "create_control_point_switches" set ref 429* 460
local_io_switches               000324 automatic       structure                level 1 dcl 598 in procedure
                                                                                  "destroy_control_point_switches" set ref 608*
meters                          000134 automatic       structure                level 1 dcl 12-157
must_swap_switches              000104 automatic       bit(1)                   dcl 371 set ref 390* 394 399 405
new_cpd                                based           structure                level 1 dcl 660
null                                                   builtin function         dcl 128 ref 429 436 436 479 486 522 522 550 550 565
                                                                                  565 582 582 618 625 723 723 725 725 728 728 758
                                                                                  758 761 761
old_cpd                                based           structure                level 1 dcl 657
old_mask                        000100 automatic       bit(36)                  dcl 65 set ref 153* 163* 171* 242* 253* 292* 458*
                                                                                  470* 673* 688* 703* 706 706*
our_arg_list_ptr                000106 automatic       pointer                  dcl 372 set ref 387* 403*
our_user_io                     000203 automatic       char(21)                 unaligned dcl 426 set ref 432* 436* 438* 441*
output_switch                          based           structure                level 1 dcl 12-162
p_attach_desc                          parameter       varying char             dcl 562 in procedure "attach_failure_varying" set
                                                                                  ref 558 565*
p_attach_desc                          parameter       char                     unaligned dcl 547 in procedure
                                                                                  "attach_failure_nonvarying" set ref 543 550*
p_caller_is_masked                     parameter       bit(1)                   dcl 668 ref 654 673 688
p_code                                 parameter       fixed bin(35,0)          dcl 548 in procedure "attach_failure_nonvarying" set
                                                                                  ref 543 550*
p_code                                 parameter       fixed bin(35,0)          dcl 580 in procedure "open_failure" set ref 576 582*
p_code                                 parameter       fixed bin(35,0)          dcl 563 in procedure "attach_failure_varying" set
                                                                                  ref 558 565*
p_cpd_1_ptr                            parameter       pointer                  dcl 821 ref 816 824 827 827 831 831
p_cpd_2_ptr                            parameter       pointer                  dcl 821 ref 816 824 827 827 831 831
p_cpd_swapped_switches                 parameter       bit(1)                   unaligned dcl 663 set ref 654 686*
p_inhibits                             parameter       char                     unaligned dcl 506 ref 500 519 519
p_new_cpd_ptr                          parameter       pointer                  dcl 661 ref 654 670 681 682 683 684
p_new_mask                             parameter       bit(36)                  dcl 897 set ref 894 900*
p_new_swapped_switches_setting         parameter       bit(1)                   dcl 665 ref 654 686
p_old_cpd_ptr                          parameter       pointer                  dcl 658 ref 654 670 676 677 678 679
p_old_mask                             parameter       bit(36)                  dcl 596 in procedure
                                                                                  "destroy_control_point_switches" set ref 593 601*
                                                                                  615*
p_old_mask                             parameter       bit(36)                  dcl 898 in procedure "mask_ips_interrupts" set ref
                                                                                  894 900*
p_old_mask                             parameter       bit(36)                  dcl 922 in procedure "unmask_ips_interrupts" set ref
                                                                                  919 924 924* 924*
p_switch_iocb                          parameter       pointer                  dcl 507 set ref 500 522*
p_switch_name                          parameter       char                     unaligned dcl 579 in procedure "open_failure" set
                                                                                  ref 576 582*
p_switch_name                          parameter       char                     unaligned dcl 503 in procedure "attach_syn" ref 500
                                                                                  514
p_switch_name                          parameter       varying char             dcl 561 in procedure "attach_failure_varying" set
                                                                                  ref 558 565*
p_switch_name                          parameter       char                     unaligned dcl 546 in procedure
                                                                                  "attach_failure_nonvarying" set ref 543 550*
p_target_switch_name                   parameter       char                     unaligned dcl 504 ref 500 517
parent                   16            based           pointer                  level 2 dcl 2-17 set ref 446 603 606* 611 612
parent_control_point_data              based           structure                level 1 dcl 59
parents_user_io                 000175 automatic       char(21)                 unaligned dcl 425 set ref 446* 447*
prior_state                     000103 automatic       fixed bin(17,0)          dcl 70 set ref 223* 269 269*
privileges               61            based           bit(36)                  level 3 dcl 2-17 set ref 255* 850 853 853 858 858
                                                                                  863 863 868 868 873 873 878 878 883 883
process_usage                          based           structure                level 1 unaligned dcl 4-3
pushed_preferred_state          000102 automatic       bit(1)                   dcl 68 set ref 206* 217* 228* 266*
real_error_handler              000100 automatic       entry variable           dcl 370 set ref 377* 383* 403*
return_from_intermediary        000104 automatic       bit(1)                   dcl 71 set ref 313* 315* 317
saved_environment        60            based           structure                level 2 in structure "cpd_1" dcl 819 in procedure
                                                                                  "different_switches"
saved_environment        60            based           structure                level 2 in structure "cpd_2" dcl 820 in procedure
                                                                                  "different_switches"
saved_environment        60            based           structure                level 2 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_"
saved_environment        60     000124 external static structure                level 2 in structure
                                                                                  "cpm_data_$root_control_point_data" dcl 1-24
                                                                                  in procedure "cpm_overseer_"
saved_environment        60            based           structure                level 2 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches"
saved_environment        60            based           structure                level 2 in structure "parent_control_point_data"
                                                                                  dcl 59 in procedure "cpm_overseer_"
saved_environment        60            based           structure                level 2 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches"
saved_swapped_switches          000105 automatic       bit(1)                   dcl 73 set ref 231* 264 289* 297 354
separate_standard_iocbs
                         35(01)        based           bit(1)                   level 4 packed unaligned dcl 5-13 ref 158 171
stack_header                           based           structure                level 1 dcl 8-26
stackbaseptr                                           builtin function         dcl 128 ref 142 200 283
state                     2            based           fixed bin(17,0)          level 2 dcl 2-17 ref 223 224
stop_proc                              based           structure                level 1 dcl 12-167
sub_err_                        000064 constant        entry                    external dcl 107 ref 550 565 582
substr                                                 builtin function         dcl 128 set ref 251* 706 924
swapped_switches          3(01)        based           bit(1)                   level 3 in structure "cpd_2" packed unaligned
                                                                                  dcl 820 in procedure "different_switches" ref 824
                                                                                  827 831
swapped_switches          3(01)        based           bit(1)                   level 3 in structure "control_point_data" packed
                                                                                  unaligned dcl 2-17 in procedure "cpm_overseer_"
                                                                                  set ref 231 232* 264* 289 297 297* 302 302* 354*
                                                                                  390 394 394* 399* 405 405* 464 464* 467* 603* 606*
                                                                                  725
swapped_switches          3(01)        based           bit(1)                   level 3 in structure "cpd_1" packed unaligned
                                                                                  dcl 819 in procedure "different_switches" ref 824
                                                                                  827 831
swapped_switches          3(01)        based           bit(1)                   level 3 in structure "parent_control_point_data"
                                                                                  packed unaligned dcl 59 in procedure
                                                                                  "cpm_overseer_" ref 603
switch_name                     000222 automatic       varying char(32)         dcl 509 set ref 512* 513* 513 514* 514 522 523*
sys_info$comm_privilege         000010 external static bit(36)                  dcl 76 ref 853 853
sys_info$dir_privilege          000012 external static bit(36)                  dcl 76 ref 858 858
sys_info$ipc_privilege          000014 external static bit(36)                  dcl 76 ref 863 863
sys_info$rcp_privilege          000016 external static bit(36)                  dcl 76 ref 868 868
sys_info$ring1_privilege        000020 external static bit(36)                  dcl 76 ref 873 873
sys_info$seg_privilege          000022 external static bit(36)                  dcl 76 ref 878 878
sys_info$soos_privilege         000024 external static bit(36)                  dcl 76 ref 883 883
system_privilege_$comm_priv_off 000070 constant        entry                    external dcl 108 ref 856
system_privilege_$comm_priv_on  000066 constant        entry                    external dcl 108 ref 853
system_privilege_$dir_priv_off  000074 constant        entry                    external dcl 108 ref 861
system_privilege_$dir_priv_on   000072 constant        entry                    external dcl 108 ref 858
system_privilege_$ipc_priv_off  000100 constant        entry                    external dcl 108 ref 866
system_privilege_$ipc_priv_on   000076 constant        entry                    external dcl 108 ref 863
system_privilege_$rcp_priv_off  000104 constant        entry                    external dcl 108 ref 871
system_privilege_$rcp_priv_on   000102 constant        entry                    external dcl 108 ref 868
system_privilege_$ring1_priv_off
                                000110 constant        entry                    external dcl 108 ref 876
system_privilege_$ring1_priv_on 000106 constant        entry                    external dcl 108 ref 873
system_privilege_$seg_priv_off  000114 constant        entry                    external dcl 108 ref 881
system_privilege_$seg_priv_on   000112 constant        entry                    external dcl 108 ref 878
system_privilege_$soos_priv_off 000120 constant        entry                    external dcl 108 ref 886
system_privilege_$soos_priv_on  000116 constant        entry                    external dcl 108 ref 883
trace_$transaction_begin        000172 constant        entry                    external dcl 12-12 ref 273
trace_$transaction_end          000174 constant        entry                    external dcl 12-14 ref 145 203
user_cl_intermediary     34            based           entry variable           level 2 dcl 2-17 ref 310 315
user_input                2     000324 automatic       pointer                  level 2 in structure "local_io_switches" dcl 598
                                                                                  in procedure "destroy_control_point_switches" set
                                                                                  ref 617
user_input               70            based           pointer                  level 4 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 788* 804*
user_input               70            based           pointer                  level 4 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches" set ref 682*
user_input                2     000160 automatic       pointer                  level 2 in structure "local_io_switches" dcl 421
                                                                                  in procedure "create_control_point_switches" set
                                                                                  ref 454* 477
user_input               70            based           pointer                  level 4 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches" set ref 677*
user_io                         000324 automatic       pointer                  level 2 in structure "local_io_switches" dcl 598
                                                                                  in procedure "destroy_control_point_switches" set
                                                                                  ref 625 627* 629* 630*
user_io                  66            based           pointer                  level 4 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches" set ref 681*
user_io                  66     000124 external static pointer                  level 4 in structure
                                                                                  "cpm_data_$root_control_point_data" dcl 1-24
                                                                                  in procedure "cpm_overseer_" set ref 728* 758*
user_io                  66            based           pointer                  level 4 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches" set ref 676*
user_io                         000160 automatic       pointer                  level 2 in structure "local_io_switches" dcl 421
                                                                                  in procedure "create_control_point_switches" set
                                                                                  ref 436* 440* 447* 486 488* 490* 491*
user_io                  66            based           pointer                  level 4 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 725* 787*
                                                                                  803*
user_io_attach_desc      40            based           char                     level 2 packed unaligned dcl 5-13 set ref 436* 438*
user_io_attach_desc_given
                         35(02)        based           bit(1)                   level 4 packed unaligned dcl 5-13 ref 434 488 627
user_io_attach_desc_length
                         37            based           fixed bin(21,0)          level 3 dcl 5-13 ref 436 436 438 438
user_output              72            based           pointer                  level 4 in structure "control_point_data" dcl 2-17
                                                                                  in procedure "cpm_overseer_" set ref 789* 805*
user_output              72            based           pointer                  level 4 in structure "old_cpd" dcl 657 in procedure
                                                                                  "swap_switches" set ref 678*
user_output               4     000160 automatic       pointer                  level 2 in structure "local_io_switches" dcl 421
                                                                                  in procedure "create_control_point_switches" set
                                                                                  ref 455* 477
user_output               4     000324 automatic       pointer                  level 2 in structure "local_io_switches" dcl 598
                                                                                  in procedure "destroy_control_point_switches" set
                                                                                  ref 617
user_output              72            based           pointer                  level 4 in structure "new_cpd" dcl 660 in procedure
                                                                                  "swap_switches" set ref 683*
watch_values                    000126 automatic       structure                level 1 dcl 12-147

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CANT_RESTART                    internal static bit(36)                  initial dcl 11-7
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
COMPENSATION_FROM_ENTRY_TO_ENTRY       internal static fixed bin(17,0)          initial dcl 12-175
COMPENSATION_FROM_ENTRY_TO_RETURN      internal static fixed bin(17,0)          initial dcl 12-175
COMPENSATION_FROM_RETURN_TO_ENTRY      internal static fixed bin(17,0)          initial dcl 12-175
COMPENSATION_FROM_RETURN_TO_RETURN     internal static fixed bin(17,0)          initial dcl 12-175
CONTROL_POINT_METERS_ARGUMENT_VERSION_1
                                       internal static char(8)                  initial unaligned dcl 3-37
CPM_BLOCKED                            internal static fixed bin(17,0)          initial dcl 2-60
CPM_DESTROYED                          internal static fixed bin(17,0)          initial dcl 2-60
CPM_STOPPED                            internal static fixed bin(17,0)          initial dcl 2-60
CREATE_CONTROL_POINT_INFO_VERSION_1    internal static char(8)                  initial unaligned dcl 5-41
Direct_input                           internal static fixed bin(17,0)          initial dcl 10-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 10-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 10-15
MAX_NUMBER_OF_METERS                   internal static fixed bin(17,0)          initial dcl 3-40
Sequential_input                       internal static fixed bin(17,0)          initial dcl 10-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 10-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 10-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 10-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 10-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 10-15
call_offset                            internal static fixed bin(17,0)          initial dcl 8-78
ccpi_user_io_attach_desc_length        automatic       fixed bin(21,0)          dcl 5-44
control_point_meters_argument          based           structure                level 1 dcl 3-32
cpm_$block                      000000 constant        entry                    external dcl 6-26
cpm_$create                     000000 constant        entry                    external dcl 6-16
cpm_$destroy                    000000 constant        entry                    external dcl 6-19
cpm_$generate_call              000000 constant        entry                    external dcl 6-35
cpm_$generate_call_preferred    000000 constant        entry                    external dcl 6-35
cpm_$generate_call_when_ready   000000 constant        entry                    external dcl 6-35
cpm_$get_control_point_meters   000000 constant        entry                    external dcl 6-50
cpm_$get_preferred_control_point
                                000000 constant        entry                    external dcl 6-41
cpm_$get_scheduler_meters       000000 constant        entry                    external dcl 6-52
cpm_$get_user_cl_intermediary   000000 constant        entry                    external dcl 6-30
cpm_$set_preferred_control_point
                                000000 constant        entry                    external dcl 6-43
cpm_$set_user_cl_intermediary   000000 constant        entry                    external dcl 6-30
cpm_$start                      000000 constant        entry                    external dcl 6-19
cpm_$wakeup                     000000 constant        entry                    external dcl 6-19
cpm_data_$gc_control_points            external static bit(1)                   dcl 1-27
cpm_data_$global_meters                external static structure                level 1 dcl 1-54
cpm_data_$preferred_control_point      external static pointer                  dcl 1-33
cpm_data_$preferred_control_point_stack
                                       external static structure                level 1 dcl 1-36
cpm_data_$ready_queue                  external static structure                level 1 dcl 1-42
cpm_data_$valid_control_points         external static structure                level 1 dcl 1-50
cpm_ptr                                automatic       pointer                  dcl 3-27
cpma_ptr                               automatic       pointer                  dcl 3-43
entry_offset                           internal static fixed bin(17,0)          initial dcl 8-78
get_control_point_id_           000000 constant        entry                    external dcl 6-13
iox_$attach_loud                000000 constant        entry                    external dcl 9-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 9-8
iox_$close_file                 000000 constant        entry                    external dcl 9-8
iox_$delete_record              000000 constant        entry                    external dcl 9-8
iox_$detach                     000000 constant        entry                    external dcl 9-8
iox_$err_no_operation           000000 constant        entry                    external dcl 9-8
iox_$err_not_attached           000000 constant        entry                    external dcl 9-8
iox_$err_not_closed             000000 constant        entry                    external dcl 9-8
iox_$err_not_open               000000 constant        entry                    external dcl 9-8
iox_$find_iocb                  000000 constant        entry                    external dcl 9-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 9-8
iox_$get_chars                  000000 constant        entry                    external dcl 9-8
iox_$get_line                   000000 constant        entry                    external dcl 9-8
iox_$look_iocb                  000000 constant        entry                    external dcl 9-8
iox_$modes                      000000 constant        entry                    external dcl 9-8
iox_$open_file                  000000 constant        entry                    external dcl 9-8
iox_$position                   000000 constant        entry                    external dcl 9-8
iox_$propagate                  000000 constant        entry                    external dcl 9-8
iox_$put_chars                  000000 constant        entry                    external dcl 9-8
iox_$read_key                   000000 constant        entry                    external dcl 9-8
iox_$read_length                000000 constant        entry                    external dcl 9-8
iox_$read_record                000000 constant        entry                    external dcl 9-8
iox_$rewrite_record             000000 constant        entry                    external dcl 9-8
iox_$seek_key                   000000 constant        entry                    external dcl 9-8
iox_$write_record               000000 constant        entry                    external dcl 9-8
iox_modes                              internal static char(24)                 initial array dcl 10-6
process_usage_pointer                  automatic       pointer                  dcl 4-3
push_offset                            internal static fixed bin(17,0)          initial dcl 8-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 8-78
return_offset                          internal static fixed bin(17,0)          initial dcl 8-78
sb                                     automatic       pointer                  dcl 8-24
short_iox_modes                        internal static char(4)                  initial array dcl 10-12
stack_header_overlay                   based           fixed bin(17,0)          array dcl 8-94
trace_$add_specified_eps        000000 constant        entry                    external dcl 12-20
trace_$add_specified_locs       000000 constant        entry                    external dcl 12-21
trace_$alm                      000000 constant        entry                    external dcl 12-111
trace_$arguments                000000 constant        entry                    external dcl 12-82
trace_$automatic                000000 constant        entry                    external dcl 12-113
trace_$buffer                   000000 constant        entry                    external dcl 12-115
trace_$buffer_counts            000000 constant        entry                    external dcl 12-74
trace_$buffer_event             000000 constant        entry                    external dcl 12-75
trace_$buffer_event_header      000000 constant        entry                    external dcl 12-76
trace_$buffer_event_string      000000 constant        entry                    external dcl 12-77
trace_$buffer_ptr               000000 constant        entry                    external dcl 12-78
trace_$calibrate                000000 constant        entry                    external dcl 12-117
trace_$call                     000000 constant        entry                    external dcl 12-84
trace_$compensation             000000 constant        entry                    external dcl 12-119
trace_$cv_bit_to_onoff          000000 constant        entry                    external dcl 12-33
trace_$cv_bits_to_inout         000000 constant        entry                    external dcl 12-30
trace_$cv_entry_name_to_spp     000000 constant        entry                    external dcl 12-34
trace_$cv_file_path_to_osw      000000 constant        entry                    external dcl 12-35
trace_$cv_inout_to_bits         000000 constant        entry                    external dcl 12-29
trace_$cv_n_to_number           000000 constant        entry                    external dcl 12-31
trace_$cv_onoff_to_bit          000000 constant        entry                    external dcl 12-32
trace_$cv_stream_name_to_osw    000000 constant        entry                    external dcl 12-36
trace_$enabled                  000000 constant        entry                    external dcl 12-121
trace_$entrypoint_counts        000000 constant        entry                    external dcl 12-40
trace_$entrypoint_global_meters 000000 constant        entry                    external dcl 12-41
trace_$entrypoint_index         000000 constant        entry                    external dcl 12-49
trace_$entrypoint_local_meters  000000 constant        entry                    external dcl 12-42
trace_$entrypoint_name          000000 constant        entry                    external dcl 12-50
trace_$entrypoint_ptr           000000 constant        entry                    external dcl 12-51
trace_$entrypoint_seg_path      000000 constant        entry                    external dcl 12-52
trace_$entrypoint_status        000000 constant        entry                    external dcl 12-53
trace_$every                    000000 constant        entry                    external dcl 12-86
trace_$first                    000000 constant        entry                    external dcl 12-88
trace_$function                 000000 constant        entry                    external dcl 12-54
trace_$global_parms_string      000000 constant        entry                    external dcl 12-123
trace_$high                     000000 constant        entry                    external dcl 12-90
trace_$in_trace                 000000 constant        entry                    external dcl 12-143
trace_$last                     000000 constant        entry                    external dcl 12-92
trace_$location_ptr             000000 constant        entry                    external dcl 12-63
trace_$location_seg_path        000000 constant        entry                    external dcl 12-64
trace_$location_values          000000 constant        entry                    external dcl 12-65
trace_$long                     000000 constant        entry                    external dcl 12-124
trace_$loud                     000000 constant        entry                    external dcl 12-138
trace_$low                      000000 constant        entry                    external dcl 12-94
trace_$me                       000000 constant        entry                    external dcl 12-7
trace_$meter                    000000 constant        entry                    external dcl 12-126
trace_$metered                  000000 constant        entry                    external dcl 12-43
trace_$new_high                 000000 constant        entry                    external dcl 12-96
trace_$num_entrypoints          000000 constant        entry                    external dcl 12-55
trace_$num_locations            000000 constant        entry                    external dcl 12-66
trace_$num_specified_entrypoints
                                000000 constant        entry                    external dcl 12-56
trace_$num_specified_locations  000000 constant        entry                    external dcl 12-67
trace_$output_switch            000000 constant        entry                    external dcl 12-128
trace_$parms_specified          000000 constant        entry                    external dcl 12-99
trace_$parms_string             000000 constant        entry                    external dcl 12-98
trace_$remove_specified_eps     000000 constant        entry                    external dcl 12-22
trace_$remove_specified_locs    000000 constant        entry                    external dcl 12-23
trace_$removed                  000000 constant        entry                    external dcl 12-44
trace_$reset_meters             000000 constant        entry                    external dcl 12-45
trace_$set_alm                  000000 constant        entry                    external dcl 12-112
trace_$set_arguments            000000 constant        entry                    external dcl 12-83
trace_$set_automatic            000000 constant        entry                    external dcl 12-114
trace_$set_buffer               000000 constant        entry                    external dcl 12-116
trace_$set_calibrate            000000 constant        entry                    external dcl 12-118
trace_$set_call                 000000 constant        entry                    external dcl 12-85
trace_$set_compensation         000000 constant        entry                    external dcl 12-120
trace_$set_enabled              000000 constant        entry                    external dcl 12-122
trace_$set_every                000000 constant        entry                    external dcl 12-87
trace_$set_first                000000 constant        entry                    external dcl 12-89
trace_$set_high                 000000 constant        entry                    external dcl 12-91
trace_$set_last                 000000 constant        entry                    external dcl 12-93
trace_$set_long                 000000 constant        entry                    external dcl 12-125
trace_$set_loud                 000000 constant        entry                    external dcl 12-139
trace_$set_low                  000000 constant        entry                    external dcl 12-95
trace_$set_meter                000000 constant        entry                    external dcl 12-127
trace_$set_new_high             000000 constant        entry                    external dcl 12-97
trace_$set_output_switch        000000 constant        entry                    external dcl 12-129
trace_$set_signals              000000 constant        entry                    external dcl 12-131
trace_$set_stop                 000000 constant        entry                    external dcl 12-101
trace_$set_stop_every           000000 constant        entry                    external dcl 12-103
trace_$set_stop_low             000000 constant        entry                    external dcl 12-105
trace_$set_stop_proc            000000 constant        entry                    external dcl 12-133
trace_$set_stop_routine         000000 constant        entry                    external dcl 12-135
trace_$set_trace                000000 constant        entry                    external dcl 12-107
trace_$set_trace_routine        000000 constant        entry                    external dcl 12-137
trace_$signals                  000000 constant        entry                    external dcl 12-130
trace_$specified_entrypoint_index
                                000000 constant        entry                    external dcl 12-57
trace_$specified_location_index 000000 constant        entry                    external dcl 12-68
trace_$specify_changed_locations
                                000000 constant        entry                    external dcl 12-70
trace_$specify_entrypoints      000000 constant        entry                    external dcl 12-58
trace_$specify_locations        000000 constant        entry                    external dcl 12-69
trace_$stop                     000000 constant        entry                    external dcl 12-100
trace_$stop_every               000000 constant        entry                    external dcl 12-102
trace_$stop_low                 000000 constant        entry                    external dcl 12-104
trace_$stop_proc                000000 constant        entry                    external dcl 12-132
trace_$stop_routine             000000 constant        entry                    external dcl 12-134
trace_$trace                    000000 constant        entry                    external dcl 12-106
trace_$trace_routine            000000 constant        entry                    external dcl 12-136
trace_$transaction_begin_force  000000 constant        entry                    external dcl 12-13
trace_$translator_id            000000 constant        entry                    external dcl 12-59
trace_$turn_off_specified_eps   000000 constant        entry                    external dcl 12-25
trace_$turn_on_specified_eps    000000 constant        entry                    external dcl 12-24
trace_$update_default_parms     000000 constant        entry                    external dcl 12-18
trace_$update_global_parms      000000 constant        entry                    external dcl 12-19
trace_$version                  000000 constant        entry                    external dcl 12-8
tv_offset                              internal static fixed bin(17,0)          initial dcl 8-72

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_HANDLER                   001652 constant        label                    dcl 387 ref 378 384
ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES
                                002434 constant        label                    dcl 477 ref 553 568 585
RETURN_FROM_CL_INTERMEDIARY     001324 constant        label                    dcl 351 ref 317
RETURN_FROM_OVERSEER            000427 constant        label                    dcl 179 ref 494
attach_failure_nonvarying       002757 constant        entry                    internal dcl 543 ref 438
attach_failure_varying          003053 constant        entry                    internal dcl 558 ref 523
attach_syn                      002552 constant        entry                    internal dcl 500 ref 447 454 455 456
cl_intermediary                 000776 constant        entry                    external dcl 280
cpm_overseer_                   000205 constant        entry                    external dcl 19
create_control_point_switches   002031 constant        entry                    internal dcl 418 ref 160
destroy_control_point_switches  003232 constant        entry                    internal dcl 593 ref 171 648
destroy_control_point_switches_caller
                                001364 constant        entry                    external dcl 642 ref 163
different_switches              004311 constant        entry                    internal dcl 816 ref 234 261 758
error_handler                   001614 constant        entry                    internal dcl 366
error_handler$catch_all         001623 constant        entry                    internal dcl 375 ref 140
error_handler$ignore_pi         001637 constant        entry                    internal dcl 381 ref 336
generate_call                   000433 constant        entry                    external dcl 197
issue_root_start_order          004037 constant        entry                    internal dcl 755 ref 179 339 778
issue_root_start_order_caller   001531 constant        entry                    external dcl 773 ref 156 164
issue_start_orders              003711 constant        entry                    internal dcl 720 ref 248 351 746
issue_start_orders_caller       001514 constant        entry                    external dcl 741 ref 218 296
mask_ips_interrupts             004653 constant        entry                    internal dcl 894 ref 153 242 470 615 673 912
mask_ips_interrupts_caller      001550 constant        entry                    external dcl 909
open_failure                    003147 constant        entry                    internal dcl 576 ref 441
overseer                        000217 constant        entry                    external dcl 137
restore_io_switches             004135 constant        entry                    internal dcl 784 ref 234
restore_privileges              004367 constant        entry                    internal dcl 843 ref 151 240
save_io_switches                004223 constant        entry                    internal dcl 800 ref 261
swap_switches                   003464 constant        entry                    internal dcl 654 ref 302 354 464 467 603 606 711
swap_switches_caller            001421 constant        entry                    external dcl 700 ref 297 394 399 405
unmask_ips_interrupts           004670 constant        entry                    internal dcl 919 ref 253 458 601 688 937
unmask_ips_interrupts_caller    001574 constant        entry                    external dcl 934 ref 706

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6246        6444    5101        6256
Length      7376    5101       176         716    1144           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cpm_overseer_                       698 external procedure  is an external procedure.  
on unit on line 140                  64 on unit               
on unit on line 156                  68 on unit               
on unit on line 161                  72 on unit               
on unit on line 208                  68 on unit               
on unit on line 294                  82 on unit               
on unit on line 330                  64 on unit               
on unit on line 336                  64 on unit               
error_handler                        96 internal procedure  enables or reverts conditions.  
on unit on line 392                  78 on unit               
create_control_point_switches           internal procedure  shares stack frame of external procedure cpm_overseer_.  
attach_syn                              internal procedure  shares stack frame of external procedure cpm_overseer_.  
attach_failure_nonvarying               internal procedure  shares stack frame of external procedure cpm_overseer_.  
attach_failure_varying                  internal procedure  shares stack frame of external procedure cpm_overseer_.  
open_failure                            internal procedure  shares stack frame of external procedure cpm_overseer_.  
destroy_control_point_switches
                                        internal procedure  shares stack frame of external procedure cpm_overseer_.  
swap_switches                           internal procedure  shares stack frame of external procedure cpm_overseer_.  
on unit on line 704                  69 on unit               
issue_start_orders                      internal procedure  shares stack frame of external procedure cpm_overseer_.  
issue_root_start_order                  internal procedure  shares stack frame of external procedure cpm_overseer_.  
restore_io_switches                     internal procedure  shares stack frame of external procedure cpm_overseer_.  
save_io_switches                        internal procedure  shares stack frame of external procedure cpm_overseer_.  
different_switches                      internal procedure  shares stack frame of external procedure cpm_overseer_.  
restore_privileges                      internal procedure  shares stack frame of external procedure cpm_overseer_.  
mask_ips_interrupts                     internal procedure  shares stack frame of external procedure cpm_overseer_.  
unmask_ips_interrupts                   internal procedure  shares stack frame of external procedure cpm_overseer_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cpm_overseer_            000100 old_mask                    cpm_overseer_
                         000101 generate_call_flags         cpm_overseer_
                         000102 pushed_preferred_state      cpm_overseer_
                         000103 prior_state                 cpm_overseer_
                         000104 return_from_intermediary    cpm_overseer_
                         000105 saved_swapped_switches      cpm_overseer_
                         000122 cpd_ptr                     cpm_overseer_
                         000124 ccpi_ptr                    cpm_overseer_
                         000126 watch_values                cpm_overseer_
                         000130 counts                      cpm_overseer_
                         000134 meters                      cpm_overseer_
                         000142 compensation                cpm_overseer_
                         000160 local_io_switches           create_control_point_switches
                         000170 an_iocb_ptr                 create_control_point_switches
                         000172 id_string                   create_control_point_switches
                         000175 parents_user_io             create_control_point_switches
                         000203 our_user_io                 create_control_point_switches
                         000211 code                        create_control_point_switches
                         000222 switch_name                 attach_syn
                         000233 attach_description          attach_syn
                         000324 local_io_switches           destroy_control_point_switches
                         000334 an_iocb_ptr                 destroy_control_point_switches
                         000412 current_privileges          restore_privileges
error_handler            000100 real_error_handler          error_handler
                         000104 must_swap_switches          error_handler
                         000106 our_arg_list_ptr            error_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ent_var        call_ext_in         call_ext_out_desc   call_ext_out
call_int_other      return_mac          enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cpm_$call_self_destruct       cpm_$nulle
cpm_$pop_preferred_control_point                            cpm_$push_preferred_control_point
cpm_$scheduler                cpm_$stop                     cpm_$update_state_caller      cu_$arg_list_ptr
cu_$generate_call             cu_$get_cl_intermediary       cu_$set_cl_intermediary       default_error_handler_$wall
default_error_handler_$wall_ignore_pi                       get_privileges_               hcs_$get_ips_mask
hcs_$reset_ips_mask           hcs_$set_ips_mask             ioa_$ioa_switch               ioa_$rsnnl
iox_$attach_name              iox_$close                    iox_$control                  iox_$destroy_iocb
iox_$detach_iocb              iox_$move_attach              iox_$open                     sub_err_
system_privilege_$comm_priv_off                             system_privilege_$comm_priv_on
system_privilege_$dir_priv_off                              system_privilege_$dir_priv_on
system_privilege_$ipc_priv_off                              system_privilege_$ipc_priv_on
system_privilege_$rcp_priv_off                              system_privilege_$rcp_priv_on
system_privilege_$ring1_priv_off                            system_privilege_$ring1_priv_on
system_privilege_$seg_priv_off                              system_privilege_$seg_priv_on
system_privilege_$soos_priv_off                             system_privilege_$soos_priv_on
trace_$transaction_begin      trace_$transaction_end

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpm_data_$previous_control_point                            cpm_data_$root_control_point_data
cpm_data_$saved_cl_intermediary                             cpm_data_$subsystem_name      iox_$error_output
iox_$user_input               iox_$user_io                  iox_$user_output              sys_info$comm_privilege
sys_info$dir_privilege        sys_info$ipc_privilege        sys_info$rcp_privilege        sys_info$ring1_privilege
sys_info$seg_privilege        sys_info$soos_privilege


CONSTANTS
004712  aa     000006000000
004713  aa     000000000000
004714  aa     600000000041
004715  aa     000122000000
004716  aa     600000000041
004717  aa     001172000000
004720  aa     600000000041
004721  aa     001174000000

004722  aa     000004000000
004723  aa     000000000000
004724  aa     600000000041
004725  aa     001130000000
004726  aa     600000000041
004727  aa     000100000000

004730  aa     000006000000
004731  aa     000006000000
004732  aa     600000000041
004733  aa     000223000000
004734  aa     600000000041
004735  aa     000234000000
004736  aa     600000000041
004737  aa     000211000000
004740  ta     000026000000
004741  aa     000000000000
004742  ta     000004000000
004743  aa     000000000000
004744  ta     000015000000
004745  aa     000000000000

004746  aa     000010000000
004747  aa     000010000000
004750  aa     600000000041
004751  aa     000542000000
004752  aa     600000000041
004753  aa     000536000000
004754  aa     600000000041
004755  aa     000564000000
004756  aa     600000000041
004757  aa     000166000000
004760  ta     000006000000
004761  aa     000000000000
004762  ta     000033000000
004763  aa     000000000000
004764  ta     000007000000
004765  aa     000000000000
004766  ta     000043000000
004767  aa     000000000000

004770  aa     000010000000
004771  aa     000010000000
004772  aa     600000000041
004773  aa     000542000000
004774  aa     600000000041
004775  aa     000536000000
004776  aa     600000000041
004777  aa     000564000000
005000  aa     600000000041
005001  aa     000164000000
005002  ta     000010000000
005003  aa     000000000000
005004  ta     000033000000
005005  aa     000000000000
005006  ta     000007000000
005007  aa     000000000000
005010  ta     000043000000
005011  aa     000000000000

005012  aa     000010000000
005013  aa     000010000000
005014  aa     600000000041
005015  aa     000542000000
005016  aa     600000000041
005017  aa     000536000000
005020  aa     600000000041
005021  aa     000564000000
005022  aa     600000000041
005023  aa     000162000000
005024  ta     000012000000
005025  aa     000000000000
005026  ta     000033000000
005027  aa     000000000000
005030  ta     000011000000
005031  aa     000000000000
005032  ta     000043000000
005033  aa     000000000000

005034  aa     000010000000
005035  aa     000010000000
005036  aa     600000000041
005037  aa     000536000000
005040  aa     600000000041
005041  aa     000175000000
005042  aa     600000000041
005043  aa     000540000000
005044  aa     600000000041
005045  aa     000160000000
005046  ta     000033000000
005047  aa     000000000000
005050  ta     000017000000
005051  aa     000000000000
005052  ta     000013000000
005053  aa     000000000000
005054  ta     000043000000
005055  aa     000000000000

005056  aa     000004000000
005057  aa     000004000000
005060  aa     600000000041
005061  aa     000203000000
005062  aa     600000000041
005063  aa     000211000000
005064  ta     000017000000
005065  aa     000000000000
005066  ta     000015000000
005067  aa     000000000000

005070  aa     077777000043
005071  aa     000001000000

005072  aa     577777777777

005074  aa     000002000000
005075  aa     000000000000
005076  aa     600000000041
005077  aa     000100000000

000000  aa     200000000000


000001  aa     524000000005

000002  aa     530077777777

000003  aa     524000000070

000004  aa     530000000200

005100  aa  056 000 000 000	.

000005  aa     526077777777

000006  aa     524000000014

000007  aa     524000000022

000010  aa     524000000013

000011  aa     524000000011

000012  aa     524000000012

000013  aa     524000000000

000014  aa     524000000017

000015  aa     404000000043

000016  aa     526000000000

000017  aa     526000000025

000020  aa     404000000005

000021  aa     526000000014

000022  aa     524000000006

000023  aa     524000000100

000024  aa     524000000052

000025  aa     466000000000

000026  aa     530000000040

000027  aa     530000000400

000030  aa     530000000101

000031  aa     404000000021

000032  aa     404000000042

000033  aa     524000000010

000034  aa     514000000002

000035  aa     526000000040

000036  aa     514000000001

000037  aa     516000000001

000040  aa     514000000044

000041  aa     000000000003

000042  aa     500000000000

000043  aa     464000000000

000044  aa  163 164 141 162	star
000045  aa  164 000 000 000	t

000046  aa  163 171 156 137	syn_
000047  aa  040 000 000 000	 

000050  aa  165 163 145 162	user
000051  aa  137 151 057 157	_i/o

000052  aa  136 061 062 056	^12.
000053  aa  063 142 000 000	3b

000054  aa     077777000043
000055  aa     000001000000

000056  aa     000000000000
000057  aa     000000000001

000060  aa  143 154 145 141	clea
000061  aa  156 165 160 000	nup

000062  aa  145 162 162 157	erro
000063  aa  162 137 157 165	r_ou
000064  aa  164 160 165 164	tput

000065  aa  165 163 145 162	user
000066  aa  137 157 165 164	_out
000067  aa  160 165 164 000	put

000070  aa  160 165 164 137	put_
000071  aa  143 150 141 162	char
000072  aa  163 000 000 000	s

000073  aa  165 163 145 162	user
000074  aa  137 151 156 160	_inp
000075  aa  165 164 000 000	ut

000076  aa  056 165 163 145	.use
000077  aa  162 137 151 057	r_i/
000100  aa  157 000 000 000	o

000101  aa     504000000002
000102  aa     410000000065
000103  aa     410000000065

000104  aa     504000000002
000105  aa     514000000044
000106  aa     514000000044

000107  aa     504000000002
000110  aa     500000000000
000111  aa     530000000400

000112  aa  141 156 171 137	any_
000113  aa  157 164 150 145	othe
000114  aa  162 000 000 000	r

000115  aa  040 055 151 156	 -in
000116  aa  150 151 142 151	hibi
000117  aa  164 040 143 154	t cl
000120  aa  157 163 145 040	ose 

000121  aa  136 061 062 056	^12.
000122  aa  063 142 056 165	3b.u
000123  aa  163 145 162 137	ser_
000124  aa  151 057 157 000	i/o

000125  aa     504000000003
000126  aa     410000000065
000127  aa     410000000065
000130  aa     404000000042

000131  aa     504000000003
000132  aa     410000000065
000133  aa     404000000042
000134  aa     404000000042

000135  aa     504000000003
000136  aa     464000000000
000137  aa     530000000040
000140  aa     530000000400

000141  aa  124 162 171 151	Tryi
000142  aa  156 147 040 164	ng t
000143  aa  157 040 157 160	o op
000144  aa  145 156 040 136	en ^
000145  aa  141 056 000 000	a.

000146  aa  147 145 164 137	get_
000147  aa  143 150 141 162	char
000150  aa  163 040 147 145	s ge
000151  aa  164 137 154 151	t_li
000152  aa  156 145 000 000	ne

000153  aa  136 141 072 040	^a: 
000154  aa  103 157 156 164	Cont
000155  aa  162 157 154 040	rol 
000156  aa  160 157 151 156	poin
000157  aa  164 040 136 061	t ^1
000160  aa  062 056 063 142	2.3b
000161  aa  136 133 040 050	^[ (
000162  aa  136 141 051 136	^a)^
000163  aa  135 040 163 164	] st
000164  aa  157 160 160 145	oppe
000165  aa  144 056 000 000	d.

000166  aa  124 162 171 151	Tryi
000167  aa  156 147 040 164	ng t
000170  aa  157 040 141 164	o at
000171  aa  164 141 143 150	tach
000172  aa  040 136 141 040	 ^a 
000173  aa  165 163 151 156	usin
000174  aa  147 040 164 150	g th
000175  aa  145 040 141 164	e at
000176  aa  164 141 143 150	tach
000177  aa  040 144 145 163	 des
000200  aa  143 162 151 160	crip
000201  aa  164 151 157 156	tion
000202  aa  040 055 136 057	 -^/
000203  aa  136 055 136 141	^-^a

BEGIN PROCEDURE cpm_overseer_
ENTRY TO cpm_overseer_                                      STATEMENT 1 ON LINE 19
cpm_overseer_:
     procedure ();

000204  da     000701200000
000205  aa   001300 6270 00	eax7 	704
000206  aa  7 00034 3521 20	epp2 	pr7|28,*
000207  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000210  aa     000000000000
000211  aa     000000000000
						STATEMENT 1 ON LINE 22
	return;

000212  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO overseer                                           STATEMENT 1 ON LINE 137
overseer:
     entry (P_ccpi_ptr, P_initproc, P_initproc_arg_list_ptr);

000213  at     000003000043
000214  tt     000042000043
000215  ta     000213000000
000216  da     000707300000
000217  aa   001300 6270 00	eax7 	704
000220  aa  7 00034 3521 20	epp2 	pr7|28,*
000221  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000222  aa     000006000000
000223  aa     000000000000
000224  aa  6 00032 3735 20	epp7 	pr6|26,*
000225  aa  7 00002 3715 20	epp5 	pr7|2,*
000226  aa  6 00146 6515 00	spri5	pr6|102
						STATEMENT 1 ON LINE 140
	on any_other call error_handler$catch_all ();

000227  aa   000011 7260 07	lxl6 	9,dl
000230  aa   777662 3520 04	epp2 	-78,ic		000112 = 141156171137
000231  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000232  aa   000004 7100 04	tra  	4,ic		000236
000233  aa     000106000000
000234  aa   000015 7100 04	tra  	13,ic		000251
BEGIN CONDITION any_other.1
ENTRY TO any_other.1                                        STATEMENT 1 ON LINE 140
	on any_other call error_handler$catch_all ();

000235  da     000715200000
000236  aa   000100 6270 00	eax7 	64
000237  aa  7 00034 3521 20	epp2 	pr7|28,*
000240  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000241  aa     000000000000
000242  aa     000000000000
000243  aa   000001 7270 07	lxl7 	1,dl
000244  aa  6 00056 6211 00	eax1 	pr6|46
000245  aa   000000 4310 07	fld  	0,dl
000246  aa   001355 3520 04	epp2 	749,ic		001623 = 000140627000
000247  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
000250  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION any_other.1
						STATEMENT 1 ON LINE 142
	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

000251  aa  6 00000 3525 00	epbp2	pr6|0
000252  aa  2 00004 3735 20	epp7 	pr2|4,*		stack_header.cpm_data_ptr
000253  aa  6 00122 6535 00	spri7	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 143
	ccpi_ptr = P_ccpi_ptr;

000254  aa  6 00146 3715 20	epp5 	pr6|102,*		P_ccpi_ptr
000255  aa  5 00000 3715 20	epp5 	pr5|0,*		P_ccpi_ptr
000256  aa  6 00124 6515 00	spri5	pr6|84		ccpi_ptr
						STATEMENT 1 ON LINE 145
	if trace_$transaction_end (1)			/* setup tracing according to our stack */
	then ;

000257  aa   777577 2370 04	ldaq 	-129,ic		000056 = 000000000000 000000000001
000260  aa  6 00430 7571 00	staq 	pr6|280
000261  aa  6 00430 3521 00	epp2 	pr6|280
000262  aa  6 00436 2521 00	spri2	pr6|286
000263  aa  6 00432 3521 00	epp2 	pr6|282
000264  aa  6 00440 2521 00	spri2	pr6|288
000265  aa  6 00434 6211 00	eax1 	pr6|284
000266  aa   010000 4310 07	fld  	4096,dl
000267  aa  6 00044 3701 20	epp4 	pr6|36,*
000270  la  4 00174 3521 20	epp2 	pr4|124,*		trace_$transaction_end
000271  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000272  aa  6 00432 2351 00	lda  	pr6|282
000273  aa   400000 3150 03	cana 	131072,du
000274  aa   000001 6000 04	tze  	1,ic		000275
						STATEMENT 1 ON LINE 148
	call cu_$set_cl_intermediary (control_point_data.cl_intermediary);

000275  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000276  aa  7 00062 3521 00	epp2 	pr7|50		control_point_data.cl_intermediary
000277  aa  6 00436 2521 00	spri2	pr6|286
000300  aa  6 00434 6211 00	eax1 	pr6|284
000301  aa   004000 4310 07	fld  	2048,dl
000302  aa  6 00044 3701 20	epp4 	pr6|36,*
000303  la  4 00042 3521 20	epp2 	pr4|34,*		cu_$set_cl_intermediary
000304  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 151
	call restore_privileges ();

000305  aa   004062 6700 04	tsp4 	2098,ic		004367
						STATEMENT 1 ON LINE 153
	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);

000306  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000307  aa  7 00060 3521 00	epp2 	pr7|48		control_point_data.ips_mask
000310  aa  6 00444 2521 00	spri2	pr6|292
000311  aa  6 00100 3521 00	epp2 	pr6|64		old_mask
000312  aa  6 00446 2521 00	spri2	pr6|294
000313  aa  6 00442 3521 00	epp2 	pr6|290
000314  aa   010000 4310 07	fld  	4096,dl
000315  aa  2 00000 7571 00	staq 	pr2|0
000316  aa   004335 6700 04	tsp4 	2269,ic		004653
						STATEMENT 1 ON LINE 156
	on cleanup call issue_root_start_order_caller (cpd_ptr);

000317  aa   000007 7260 07	lxl6 	7,dl
000320  aa   777540 3520 04	epp2 	-160,ic		000060 = 143154145141
000321  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000322  aa   000004 7100 04	tra  	4,ic		000326
000323  aa     000114000000
000324  aa   000017 7100 04	tra  	15,ic		000343
BEGIN CONDITION cleanup.2
ENTRY TO cleanup.2                                          STATEMENT 1 ON LINE 156
	on cleanup call issue_root_start_order_caller (cpd_ptr);

000325  da     000723200000
000326  aa   000120 6270 00	eax7 	80
000327  aa  7 00034 3521 20	epp2 	pr7|28,*
000330  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000331  aa     000000000000
000332  aa     000000000000
000333  aa  6 00040 3735 20	epp7 	pr6|32,*
000334  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
000335  aa  6 00102 2521 00	spri2	pr6|66
000336  aa  6 00100 6211 00	eax1 	pr6|64
000337  aa   004000 4310 07	fld  	2048,dl
000340  aa   001171 3520 04	epp2 	633,ic		001531 = 001300627000
000341  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
000342  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.2
						STATEMENT 1 ON LINE 158
	if create_control_point_info.separate_standard_iocbs
	then do;

000343  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
000344  aa  7 00035 2351 00	lda  	pr7|29		create_control_point_info.separate_standard_iocbs
000345  aa   200000 3150 03	cana 	65536,du
000346  aa   000041 6000 04	tze  	33,ic		000407
						STATEMENT 1 ON LINE 160
		call create_control_point_switches ();

000347  aa   001462 6700 04	tsp4 	818,ic		002031
						STATEMENT 1 ON LINE 161
		on cleanup
		     begin;

000350  aa   000007 7260 07	lxl6 	7,dl
000351  aa   777507 3520 04	epp2 	-185,ic		000060 = 143154145141
000352  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000353  aa   000004 7100 04	tra  	4,ic		000357
000354  aa     000114000000
000355  aa   000032 7100 04	tra  	26,ic		000407
BEGIN CONDITION cleanup.3
ENTRY TO cleanup.3                                          STATEMENT 1 ON LINE 161
		on cleanup
		     begin;

000356  da     000731200000
000357  aa   000120 6270 00	eax7 	80
000360  aa  7 00034 3521 20	epp2 	pr7|28,*
000361  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000362  aa     000000000000
000363  aa     000000000000
						STATEMENT 1 ON LINE 163
			call destroy_control_point_switches_caller (cpd_ptr, ccpi_ptr, old_mask);

000364  aa  6 00040 3735 20	epp7 	pr6|32,*
000365  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
000366  aa  6 00102 2521 00	spri2	pr6|66
000367  aa  7 00124 3521 00	epp2 	pr7|84		ccpi_ptr
000370  aa  6 00104 2521 00	spri2	pr6|68
000371  aa  7 00100 3521 00	epp2 	pr7|64		old_mask
000372  aa  6 00106 2521 00	spri2	pr6|70
000373  aa  6 00100 6211 00	eax1 	pr6|64
000374  aa   014000 4310 07	fld  	6144,dl
000375  aa   000767 3520 04	epp2 	503,ic		001364 = 001300627000
000376  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 164
			call issue_root_start_order_caller (cpd_ptr);

000377  aa  6 00040 3735 20	epp7 	pr6|32,*
000400  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
000401  aa  6 00102 2521 00	spri2	pr6|66
000402  aa  6 00100 6211 00	eax1 	pr6|64
000403  aa   004000 4310 07	fld  	2048,dl
000404  aa   001125 3520 04	epp2 	597,ic		001531 = 001300627000
000405  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 165
		     end;

000406  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.3
						STATEMENT 1 ON LINE 166
	     end;

						STATEMENT 1 ON LINE 168
	call cu_$generate_call (P_initproc, P_initproc_arg_list_ptr);

000407  aa  6 00032 3735 20	epp7 	pr6|26,*
000410  aa  7 00004 3521 20	epp2 	pr7|4,*		P_initproc
000411  aa  6 00436 2521 00	spri2	pr6|286
000412  aa  7 00006 3521 20	epp2 	pr7|6,*		P_initproc_arg_list_ptr
000413  aa  6 00440 2521 00	spri2	pr6|288
000414  aa  6 00434 6211 00	eax1 	pr6|284
000415  aa   010000 4310 07	fld  	4096,dl
000416  aa  6 00044 3701 20	epp4 	pr6|36,*
000417  la  4 00036 3521 20	epp2 	pr4|30,*		cu_$generate_call
000420  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 171
	if create_control_point_info.separate_standard_iocbs
	then call destroy_control_point_switches (old_mask);

000421  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
000422  aa  7 00035 2351 00	lda  	pr7|29		create_control_point_info.separate_standard_iocbs
000423  aa   200000 3150 03	cana 	65536,du
000424  aa   000003 6000 04	tze  	3,ic		000427
000425  aa   004447 3520 04	epp2 	2343,ic		005074 = 000002000000
000426  aa   002604 6700 04	tsp4 	1412,ic		003232
						STATEMENT 1 ON LINE 179
RETURN_FROM_OVERSEER:
	call issue_root_start_order ();

000427  aa   003410 6700 04	tsp4 	1800,ic		004037
						STATEMENT 1 ON LINE 182
	return;

000430  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO generate_call                                      STATEMENT 1 ON LINE 197
generate_call:
     entry (P_gcf_ptr, P_userproc, P_userproc_arg_list_ptr);

000431  ta     000213000000
000432  da     000734300000
000433  aa   001300 6270 00	eax7 	704
000434  aa  7 00034 3521 20	epp2 	pr7|28,*
000435  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000436  aa     000006000000
000437  aa     000000000000
						STATEMENT 1 ON LINE 200
	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

000440  aa  6 00000 3525 00	epbp2	pr6|0
000441  aa  2 00004 3735 20	epp7 	pr2|4,*		stack_header.cpm_data_ptr
000442  aa  6 00122 6535 00	spri7	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 201
	generate_call_flags = P_gcf_ptr -> based_generate_call_flags;

000443  aa  6 00032 3715 20	epp5 	pr6|26,*
000444  aa  5 00002 3535 20	epp3 	pr5|2,*		P_gcf_ptr
000445  aa  3 00000 2351 20	lda  	pr3|0,*		based_generate_call_flags
000446  aa  6 00101 7551 00	sta  	pr6|65		generate_call_flags
						STATEMENT 1 ON LINE 203
	if trace_$transaction_end (1)			/* setup tracing according to our stack */
	then ;

000447  aa   777407 2370 04	ldaq 	-249,ic		000056 = 000000000000 000000000001
000450  aa  6 00430 7571 00	staq 	pr6|280
000451  aa  6 00430 3521 00	epp2 	pr6|280
000452  aa  6 00436 2521 00	spri2	pr6|286
000453  aa  6 00432 3521 00	epp2 	pr6|282
000454  aa  6 00440 2521 00	spri2	pr6|288
000455  aa  6 00434 6211 00	eax1 	pr6|284
000456  aa   010000 4310 07	fld  	4096,dl
000457  aa  6 00044 3701 20	epp4 	pr6|36,*
000460  la  4 00174 3521 20	epp2 	pr4|124,*		trace_$transaction_end
000461  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000462  aa  6 00432 2351 00	lda  	pr6|282
000463  aa   400000 3150 03	cana 	131072,du
000464  aa   000001 6000 04	tze  	1,ic		000465
						STATEMENT 1 ON LINE 206
	pushed_preferred_state = "0"b;

000465  aa  6 00102 4501 00	stz  	pr6|66		pushed_preferred_state
						STATEMENT 1 ON LINE 208
	on cleanup				/* in case the user's program aborts */
	     begin;

000466  aa   000007 7260 07	lxl6 	7,dl
000467  aa   777371 3520 04	epp2 	-263,ic		000060 = 143154145141
000470  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000471  aa   000004 7100 04	tra  	4,ic		000475
000472  aa     000114000000
000473  aa   000026 7100 04	tra  	22,ic		000521
BEGIN CONDITION cleanup.4
ENTRY TO cleanup.4                                          STATEMENT 1 ON LINE 208
	on cleanup				/* in case the user's program aborts */
	     begin;

000474  da     000742200000
000475  aa   000120 6270 00	eax7 	80
000476  aa  7 00034 3521 20	epp2 	pr7|28,*
000477  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000500  aa     000000000000
000501  aa     000000000000
						STATEMENT 1 ON LINE 217
		call cpm_$pop_preferred_control_point (pushed_preferred_state);

000502  aa  6 00040 3735 20	epp7 	pr6|32,*
000503  aa  7 00102 3521 00	epp2 	pr7|66		pushed_preferred_state
000504  aa  6 00102 2521 00	spri2	pr6|66
000505  aa  6 00100 6211 00	eax1 	pr6|64
000506  aa   004000 4310 07	fld  	2048,dl
000507  la  4 00140 3521 20	epp2 	pr4|96,*		cpm_$pop_preferred_control_point
000510  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 218
		call issue_start_orders_caller (cpd_ptr);

000511  aa  6 00040 3735 20	epp7 	pr6|32,*
000512  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
000513  aa  6 00102 2521 00	spri2	pr6|66
000514  aa  6 00100 6211 00	eax1 	pr6|64
000515  aa   004000 4310 07	fld  	2048,dl
000516  aa   000776 3520 04	epp2 	510,ic		001514 = 001300627000
000517  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 219
	     end;

000520  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.4
						STATEMENT 1 ON LINE 221
	if generate_call_flags & CPM_GC_FORCE_READY	/* cpm_$generate_call or cpm_$generate_call_preferred ... */
	then do;

000521  aa  6 00101 2351 00	lda  	pr6|65		generate_call_flags
000522  aa   400000 3150 03	cana 	131072,du
000523  aa   000017 6000 04	tze  	15,ic		000542
						STATEMENT 1 ON LINE 223
		prior_state = control_point_data.state;

000524  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000525  aa  7 00002 2361 00	ldq  	pr7|2		control_point_data.state
000526  aa  6 00103 7561 00	stq  	pr6|67		prior_state
						STATEMENT 1 ON LINE 224
		if control_point_data.state ^= CPM_READY
		then call cpm_$update_state_caller (cpd_ptr, CPM_READY);

000527  aa   000003 1160 07	cmpq 	3,dl
000530  aa   000012 6000 04	tze  	10,ic		000542
000531  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
000532  aa  6 00436 2521 00	spri2	pr6|286
000533  aa   777306 3520 04	epp2 	-314,ic		000041 = 000000000003
000534  aa  6 00440 2521 00	spri2	pr6|288
000535  aa  6 00434 6211 00	eax1 	pr6|284
000536  aa   010000 4310 07	fld  	4096,dl
000537  aa  6 00044 3701 20	epp4 	pr6|36,*
000540  la  4 00032 3521 20	epp2 	pr4|26,*		cpm_$update_state_caller
000541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 226
	     end;

						STATEMENT 1 ON LINE 228
	if generate_call_flags & CPM_GC_PUSH_PREFERRED	/* cpm_$generate_call_preferred: make us temporarily "it" */
	then call cpm_$push_preferred_control_point (control_point_data.id, pushed_preferred_state, (0));

000542  aa  6 00101 2351 00	lda  	pr6|65		generate_call_flags
000543  aa   200000 3150 03	cana 	65536,du
000544  aa   000015 6000 04	tze  	13,ic		000561
000545  aa  6 00432 4501 00	stz  	pr6|282
000546  aa  6 00122 3521 20	epp2 	pr6|82,*		control_point_data.id
000547  aa  6 00444 2521 00	spri2	pr6|292
000550  aa  6 00102 3521 00	epp2 	pr6|66		pushed_preferred_state
000551  aa  6 00446 2521 00	spri2	pr6|294
000552  aa  6 00432 3521 00	epp2 	pr6|282
000553  aa  6 00450 2521 00	spri2	pr6|296
000554  aa  6 00442 6211 00	eax1 	pr6|290
000555  aa   014000 4310 07	fld  	6144,dl
000556  aa  6 00044 3701 20	epp4 	pr6|36,*
000557  la  4 00136 3521 20	epp2 	pr4|94,*		cpm_$push_preferred_control_point
000560  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 231
	saved_swapped_switches = control_point_data.swapped_switches;

000561  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000562  aa  7 00003 2351 00	lda  	pr7|3		control_point_data.swapped_switches
000563  aa   000001 7350 00	als  	1
000564  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000565  aa  6 00105 7551 00	sta  	pr6|69		saved_swapped_switches
						STATEMENT 1 ON LINE 232
	control_point_data.swapped_switches = "0"b;

000566  aa   004304 2350 04	lda  	2244,ic		005072 = 577777777777
000567  aa  7 00003 3551 00	ansa 	pr7|3		control_point_data.swapped_switches
						STATEMENT 1 ON LINE 234
	if different_switches (cpd_ptr, cpm_data_$previous_control_point)
	then call restore_io_switches ();

000570  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
000571  aa  6 00454 2521 00	spri2	pr6|300
000572  aa  6 00044 3701 20	epp4 	pr6|36,*
000573  la  4 00130 3521 20	epp2 	pr4|88,*		cpm_data_$previous_control_point
000574  aa  6 00456 2521 00	spri2	pr6|302
000575  aa  6 00432 3521 00	epp2 	pr6|282
000576  aa  6 00460 2521 00	spri2	pr6|304
000577  aa  6 00452 3521 00	epp2 	pr6|298
000600  aa   014000 4310 07	fld  	6144,dl
000601  aa  2 00000 7571 00	staq 	pr2|0
000602  aa   003507 6700 04	tsp4 	1863,ic		004311
000603  aa  6 00432 2351 00	lda  	pr6|282
000604  aa   400000 3150 03	cana 	131072,du
000605  aa   000002 6000 04	tze  	2,ic		000607
000606  aa   003327 6700 04	tsp4 	1751,ic		004135
						STATEMENT 1 ON LINE 237
	call cu_$set_cl_intermediary (control_point_data.cl_intermediary);

000607  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000610  aa  7 00062 3521 00	epp2 	pr7|50		control_point_data.cl_intermediary
000611  aa  6 00436 2521 00	spri2	pr6|286
000612  aa  6 00434 6211 00	eax1 	pr6|284
000613  aa   004000 4310 07	fld  	2048,dl
000614  aa  6 00044 3701 20	epp4 	pr6|36,*
000615  la  4 00042 3521 20	epp2 	pr4|34,*		cu_$set_cl_intermediary
000616  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 240
	call restore_privileges ();

000617  aa   003550 6700 04	tsp4 	1896,ic		004367
						STATEMENT 1 ON LINE 242
	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);

000620  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000621  aa  7 00060 3521 00	epp2 	pr7|48		control_point_data.ips_mask
000622  aa  6 00444 2521 00	spri2	pr6|292
000623  aa  6 00100 3521 00	epp2 	pr6|64		old_mask
000624  aa  6 00446 2521 00	spri2	pr6|294
000625  aa  6 00442 3521 00	epp2 	pr6|290
000626  aa   010000 4310 07	fld  	4096,dl
000627  aa  2 00000 7571 00	staq 	pr2|0
000630  aa   004023 6700 04	tsp4 	2067,ic		004653
						STATEMENT 1 ON LINE 245
	call cu_$generate_call (P_userproc, P_userproc_arg_list_ptr);

000631  aa  6 00032 3735 20	epp7 	pr6|26,*
000632  aa  7 00004 3521 20	epp2 	pr7|4,*		P_userproc
000633  aa  6 00436 2521 00	spri2	pr6|286
000634  aa  7 00006 3521 20	epp2 	pr7|6,*		P_userproc_arg_list_ptr
000635  aa  6 00440 2521 00	spri2	pr6|288
000636  aa  6 00434 6211 00	eax1 	pr6|284
000637  aa   010000 4310 07	fld  	4096,dl
000640  aa  6 00044 3701 20	epp4 	pr6|36,*
000641  la  4 00036 3521 20	epp2 	pr4|30,*		cu_$generate_call
000642  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 248
	call issue_start_orders ();

000643  aa   003046 6700 04	tsp4 	1574,ic		003711
						STATEMENT 1 ON LINE 250
	call hcs_$get_ips_mask (control_point_data.ips_mask);

000644  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000645  aa  7 00060 3521 00	epp2 	pr7|48		control_point_data.ips_mask
000646  aa  6 00436 2521 00	spri2	pr6|286
000647  aa  6 00434 6211 00	eax1 	pr6|284
000650  aa   004000 4310 07	fld  	2048,dl
000651  aa  6 00044 3701 20	epp4 	pr6|36,*
000652  la  4 00052 3521 20	epp2 	pr4|42,*		hcs_$get_ips_mask
000653  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 251
	substr (control_point_data.ips_mask, 36) = "1"b;

000654  aa   000001 2350 07	lda  	1,dl
000655  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000656  aa  7 00060 2551 00	orsa 	pr7|48		control_point_data.ips_mask
						STATEMENT 1 ON LINE 253
	call unmask_ips_interrupts (old_mask);

000657  aa   004215 3520 04	epp2 	2189,ic		005074 = 000002000000
000660  aa   004010 6700 04	tsp4 	2056,ic		004670
						STATEMENT 1 ON LINE 255
	control_point_data.privileges = get_privileges_ ();

000661  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000662  aa  7 00061 3521 00	epp2 	pr7|49		control_point_data.privileges
000663  aa  6 00436 2521 00	spri2	pr6|286
000664  aa  6 00434 6211 00	eax1 	pr6|284
000665  aa   004000 4310 07	fld  	2048,dl
000666  aa  6 00044 3701 20	epp4 	pr6|36,*
000667  la  4 00050 3521 20	epp2 	pr4|40,*		get_privileges_
000670  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 258
	call cu_$get_cl_intermediary (control_point_data.cl_intermediary);

000671  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000672  aa  7 00062 3521 00	epp2 	pr7|50		control_point_data.cl_intermediary
000673  aa  6 00436 2521 00	spri2	pr6|286
000674  aa  6 00434 6211 00	eax1 	pr6|284
000675  aa   004000 4310 07	fld  	2048,dl
000676  aa  6 00044 3701 20	epp4 	pr6|36,*
000677  la  4 00040 3521 20	epp2 	pr4|32,*		cu_$get_cl_intermediary
000700  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 261
	if different_switches (cpd_ptr, cpm_data_$previous_control_point)
	then call save_io_switches ();

000701  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
000702  aa  6 00454 2521 00	spri2	pr6|300
000703  aa  6 00044 3701 20	epp4 	pr6|36,*
000704  la  4 00130 3521 20	epp2 	pr4|88,*		cpm_data_$previous_control_point
000705  aa  6 00456 2521 00	spri2	pr6|302
000706  aa  6 00432 3521 00	epp2 	pr6|282
000707  aa  6 00460 2521 00	spri2	pr6|304
000710  aa  6 00452 3521 00	epp2 	pr6|298
000711  aa   014000 4310 07	fld  	6144,dl
000712  aa  2 00000 7571 00	staq 	pr2|0
000713  aa   003376 6700 04	tsp4 	1790,ic		004311
000714  aa  6 00432 2351 00	lda  	pr6|282
000715  aa   400000 3150 03	cana 	131072,du
000716  aa   000002 6000 04	tze  	2,ic		000720
000717  aa   003304 6700 04	tsp4 	1732,ic		004223
						STATEMENT 1 ON LINE 264
	control_point_data.swapped_switches = saved_swapped_switches;

000720  aa  6 00105 2351 00	lda  	pr6|69		saved_swapped_switches
000721  aa   000001 7710 00	arl  	1
000722  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
000723  aa  7 00003 6751 00	era  	pr7|3		control_point_data.swapped_switches
000724  aa   200000 3750 03	ana  	65536,du
000725  aa  7 00003 6551 00	ersa 	pr7|3		control_point_data.swapped_switches
						STATEMENT 1 ON LINE 266
	call cpm_$pop_preferred_control_point (pushed_preferred_state);

000726  aa  6 00102 3521 00	epp2 	pr6|66		pushed_preferred_state
000727  aa  6 00436 2521 00	spri2	pr6|286
000730  aa  6 00434 6211 00	eax1 	pr6|284
000731  aa   004000 4310 07	fld  	2048,dl
000732  aa  6 00044 3701 20	epp4 	pr6|36,*
000733  la  4 00140 3521 20	epp2 	pr4|96,*		cpm_$pop_preferred_control_point
000734  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 269
	if generate_call_flags & CPM_GC_FORCE_READY	/* cpm_$generate_call or cpm_$generate_call_preferred ... */
	then if prior_state ^= CPM_READY		/* ... so reset our state if it wasn't READY */
	     then call cpm_$update_state_caller (cpd_ptr, prior_state);

000735  aa  6 00101 2351 00	lda  	pr6|65		generate_call_flags
000736  aa   400000 3150 03	cana 	131072,du
000737  aa   000015 6000 04	tze  	13,ic		000754
000740  aa  6 00103 2361 00	ldq  	pr6|67		prior_state
000741  aa   000003 1160 07	cmpq 	3,dl
000742  aa   000012 6000 04	tze  	10,ic		000754
000743  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
000744  aa  6 00436 2521 00	spri2	pr6|286
000745  aa  6 00103 3521 00	epp2 	pr6|67		prior_state
000746  aa  6 00440 2521 00	spri2	pr6|288
000747  aa  6 00434 6211 00	eax1 	pr6|284
000750  aa   010000 4310 07	fld  	4096,dl
000751  aa  6 00044 3701 20	epp4 	pr6|36,*
000752  la  4 00032 3521 20	epp2 	pr4|26,*		cpm_$update_state_caller
000753  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 273
	if trace_$transaction_begin (1)		/* disbale tracing until we're in another control point */
	then ;

000754  aa   777102 2370 04	ldaq 	-446,ic		000056 = 000000000000 000000000001
000755  aa  6 00430 7571 00	staq 	pr6|280
000756  aa  6 00430 3521 00	epp2 	pr6|280
000757  aa  6 00436 2521 00	spri2	pr6|286
000760  aa  6 00432 3521 00	epp2 	pr6|282
000761  aa  6 00440 2521 00	spri2	pr6|288
000762  aa  6 00434 6211 00	eax1 	pr6|284
000763  aa   010000 4310 07	fld  	4096,dl
000764  aa  6 00044 3701 20	epp4 	pr6|36,*
000765  la  4 00172 3521 20	epp2 	pr4|122,*		trace_$transaction_begin
000766  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000767  aa  6 00432 2351 00	lda  	pr6|282
000770  aa   400000 3150 03	cana 	131072,du
000771  aa   000001 6000 04	tze  	1,ic		000772
						STATEMENT 1 ON LINE 276
	return;

000772  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO cl_intermediary                                    STATEMENT 1 ON LINE 280
cl_intermediary:
     entry (P_cl_flags);

000773  at     000001000040
000774  ta     000773000000
000775  da     000751300000
000776  aa   001300 6270 00	eax7 	704
000777  aa  7 00034 3521 20	epp2 	pr7|28,*
001000  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001001  aa     000002000000
001002  aa     000000000000
						STATEMENT 1 ON LINE 283
	cpd_ptr = stackbaseptr () -> stack_header.cpm_data_ptr;

001003  aa  6 00000 3525 00	epbp2	pr6|0
001004  aa  2 00004 3735 20	epp7 	pr2|4,*		stack_header.cpm_data_ptr
001005  aa  6 00122 6535 00	spri7	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 289
	saved_swapped_switches = control_point_data.swapped_switches;

001006  aa  7 00003 2351 00	lda  	pr7|3		control_point_data.swapped_switches
001007  aa   000001 7350 00	als  	1
001010  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001011  aa  6 00105 7551 00	sta  	pr6|69		saved_swapped_switches
						STATEMENT 1 ON LINE 292
	old_mask = ""b;

001012  aa  6 00100 4501 00	stz  	pr6|64		old_mask
						STATEMENT 1 ON LINE 294
	on cleanup
	     begin;

001013  aa   000007 7260 07	lxl6 	7,dl
001014  aa  6 00432 7551 00	sta  	pr6|282		control_point_data.swapped_switches
001015  aa   777043 3520 04	epp2 	-477,ic		000060 = 143154145141
001016  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001017  aa   000004 7100 04	tra  	4,ic		001023
001020  aa     000114000000
001021  aa   000051 7100 04	tra  	41,ic		001072
BEGIN CONDITION cleanup.5
ENTRY TO cleanup.5                                          STATEMENT 1 ON LINE 294
	on cleanup
	     begin;

001022  da     000757200000
001023  aa   000140 6270 00	eax7 	96
001024  aa  7 00034 3521 20	epp2 	pr7|28,*
001025  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001026  aa     000000000000
001027  aa     000000000000
						STATEMENT 1 ON LINE 296
		call issue_start_orders_caller (cpd_ptr);

001030  aa  6 00040 3735 20	epp7 	pr6|32,*
001031  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
001032  aa  6 00102 2521 00	spri2	pr6|66
001033  aa  6 00100 6211 00	eax1 	pr6|64
001034  aa   004000 4310 07	fld  	2048,dl
001035  aa   000457 3520 04	epp2 	303,ic		001514 = 001300627000
001036  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 297
		if saved_swapped_switches & ^control_point_data.swapped_switches
		then call swap_switches_caller (cpd_ptr, addr (cpm_data_$root_control_point_data),
			control_point_data.swapped_switches, "1"b);

001037  aa  6 00040 3735 20	epp7 	pr6|32,*
001040  aa  7 00105 2351 00	lda  	pr7|69		saved_swapped_switches
001041  aa   000030 6000 04	tze  	24,ic		001071
001042  aa  7 00122 3715 20	epp5 	pr7|82,*		cpd_ptr
001043  aa  5 00003 2351 00	lda  	pr5|3		control_point_data.swapped_switches
001044  aa   200000 3150 03	cana 	65536,du
001045  aa   000024 6010 04	tnz  	20,ic		001071
001046  aa  6 00044 3701 20	epp4 	pr6|36,*
001047  la  4 00124 3535 20	epp3 	pr4|84,*		cpm_data_$root_control_point_data
001050  aa  6 00104 2535 00	spri3	pr6|68
001051  aa   400000 2350 03	lda  	131072,du
001052  aa  6 00106 7551 00	sta  	pr6|70
001053  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
001054  aa  6 00112 2521 00	spri2	pr6|74
001055  aa  6 00104 3521 00	epp2 	pr6|68
001056  aa  6 00114 2521 00	spri2	pr6|76
001057  aa   000001 7270 07	lxl7 	1,dl
001060  aa  5 00003 3521 00	epp2 	pr5|3		control_point_data.swapped_switches
001061  aa  2 00000 5035 17	abd  	pr2|0,7
001062  aa  6 00116 2521 00	spri2	pr6|78
001063  aa  6 00106 3521 00	epp2 	pr6|70
001064  aa  6 00120 2521 00	spri2	pr6|80
001065  aa  6 00110 6211 00	eax1 	pr6|72
001066  aa   020000 4310 07	fld  	8192,dl
001067  aa   000332 3520 04	epp2 	218,ic		001421 = 001300627000
001070  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 300
	     end;

001071  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.5
						STATEMENT 1 ON LINE 302
	if control_point_data.swapped_switches		/* restore the control point's native switches */
	then call swap_switches (addr (cpm_data_$root_control_point_data), cpd_ptr, control_point_data.swapped_switches,
		"0"b, "0"b);

001072  aa  6 00432 2351 00	lda  	pr6|282		control_point_data.swapped_switches
001073  aa   000030 6000 04	tze  	24,ic		001123
001074  aa  6 00044 3701 20	epp4 	pr6|36,*
001075  la  4 00124 3735 20	epp7 	pr4|84,*		cpm_data_$root_control_point_data
001076  aa  6 00430 6535 00	spri7	pr6|280
001077  aa   000000 2350 07	lda  	0,dl
001100  aa  6 00432 7551 00	sta  	pr6|282
001101  aa  6 00433 7551 00	sta  	pr6|283
001102  aa  6 00430 3521 00	epp2 	pr6|280
001103  aa  6 00466 2521 00	spri2	pr6|310
001104  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
001105  aa  6 00470 2521 00	spri2	pr6|312
001106  aa   000001 7270 07	lxl7 	1,dl
001107  aa  2 00000 3715 20	epp5 	pr2|0,*		cpd_ptr
001110  aa  5 00003 3521 00	epp2 	pr5|3		control_point_data.swapped_switches
001111  aa  2 00000 5035 17	abd  	pr2|0,7
001112  aa  6 00472 2521 00	spri2	pr6|314
001113  aa  6 00432 3521 00	epp2 	pr6|282
001114  aa  6 00474 2521 00	spri2	pr6|316
001115  aa  6 00433 3521 00	epp2 	pr6|283
001116  aa  6 00476 2521 00	spri2	pr6|318
001117  aa  6 00464 3521 00	epp2 	pr6|308
001120  aa   024000 4310 07	fld  	10240,dl
001121  aa  2 00000 7571 00	staq 	pr2|0
001122  aa   002342 6700 04	tsp4 	1250,ic		003464
						STATEMENT 1 ON LINE 310
	if control_point_data.user_cl_intermediary ^= cpm_$nulle
	then do;

001123  aa  6 00044 3701 20	epp4 	pr6|36,*
001124  la  4 00142 3521 20	epp2 	pr4|98,*		cpm_$nulle
001125  aa  6 00070 2521 00	spri2	pr6|56
001126  aa   003742 2370 04	ldaq 	2018,ic		005070 = 077777000043 000001000000
001127  aa  6 00072 7571 00	staq 	pr6|58
001130  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
001131  aa  6 00070 2371 00	ldaq 	pr6|56
001132  aa  7 00034 6771 00	eraq 	pr7|28		control_point_data.user_cl_intermediary
001133  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001134  aa   000004 6010 04	tnz  	4,ic		001140
001135  aa  6 00072 2371 00	ldaq 	pr6|58
001136  aa  7 00036 6771 00	eraq 	pr7|30		control_point_data.user_cl_intermediary
001137  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001140  aa   000013 6000 04	tze  	11,ic		001153
						STATEMENT 1 ON LINE 313
		return_from_intermediary = "0"b;

001141  aa  6 00104 4501 00	stz  	pr6|68		return_from_intermediary
						STATEMENT 1 ON LINE 315
		call control_point_data.user_cl_intermediary (return_from_intermediary);

001142  aa  6 00104 3521 00	epp2 	pr6|68		return_from_intermediary
001143  aa  6 00436 2521 00	spri2	pr6|286
001144  aa  6 00434 6211 00	eax1 	pr6|284
001145  aa   004000 4310 07	fld  	2048,dl
001146  aa  7 00034 3521 00	epp2 	pr7|28		control_point_data.user_cl_intermediary
001147  aa  0 00617 7001 00	tsx0 	pr0|399		call_ent_var
						STATEMENT 1 ON LINE 317
		if return_from_intermediary
		then go to RETURN_FROM_CL_INTERMEDIARY;

001150  aa  6 00104 2351 00	lda  	pr6|68		return_from_intermediary
001151  aa   400000 3150 03	cana 	131072,du
001152  aa   000152 6010 04	tnz  	106,ic		001324
						STATEMENT 1 ON LINE 319
	     end;

						STATEMENT 1 ON LINE 326
	if cpd_ptr = addr (cpm_data_$root_control_point_data)
	then call cpm_data_$saved_cl_intermediary (P_cl_flags);

001153  aa  6 00044 3701 20	epp4 	pr6|36,*
001154  la  4 00124 3735 20	epp7 	pr4|84,*		cpm_data_$root_control_point_data
001155  aa  6 00430 6535 00	spri7	pr6|280
001156  aa  6 00430 2371 00	ldaq 	pr6|280
001157  aa  6 00122 6771 00	eraq 	pr6|82		cpd_ptr
001160  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001161  aa   000011 6010 04	tnz  	9,ic		001172
001162  aa  6 00032 3715 20	epp5 	pr6|26,*
001163  aa  5 00002 3521 20	epp2 	pr5|2,*		P_cl_flags
001164  aa  6 00436 2521 00	spri2	pr6|286
001165  aa  6 00434 6211 00	eax1 	pr6|284
001166  aa   004000 4310 07	fld  	2048,dl
001167  la  4 00126 3521 20	epp2 	pr4|86,*		cpm_data_$saved_cl_intermediary
001170  aa  0 00617 7001 00	tsx0 	pr0|399		call_ent_var
001171  aa   000133 7100 04	tra  	91,ic		001324
						STATEMENT 1 ON LINE 329
	else do;

						STATEMENT 1 ON LINE 330
		on any_other			/* fault occured trying to write the following message ... */
		     call cpm_$call_self_destruct ();

001172  aa   000011 7260 07	lxl6 	9,dl
001173  aa   776717 3520 04	epp2 	-561,ic		000112 = 141156171137
001174  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001175  aa   000004 7100 04	tra  	4,ic		001201
001176  aa     000106000000
001177  aa   000014 7100 04	tra  	12,ic		001213
BEGIN CONDITION any_other.6
ENTRY TO any_other.6                                        STATEMENT 1 ON LINE 330
		on any_other			/* fault occured trying to write the following message ... */
		     call cpm_$call_self_destruct ();

001200  da     000765200000
001201  aa   000100 6270 00	eax7 	64
001202  aa  7 00034 3521 20	epp2 	pr7|28,*
001203  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001204  aa     000000000000
001205  aa     000000000000
001206  aa  6 00056 6211 00	eax1 	pr6|46
001207  aa   000000 4310 07	fld  	0,dl
001210  la  4 00030 3521 20	epp2 	pr4|24,*		cpm_$call_self_destruct
001211  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
001212  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION any_other.6
						STATEMENT 1 ON LINE 332
		call ioa_$ioa_switch (iox_$error_output, "^a: Control point ^12.3b^[ (^a)^] stopped.",
		     cpm_data_$subsystem_name, control_point_data.id, (control_point_data.comment ^= ""),
		     control_point_data.comment);

001213  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001214  aa   776740 00 0054	desc9a	-544,44		000153 = 136141072040
001215  aa  6 00464 00 0054	desc9a	pr6|308,44
001216  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
001217  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001220  aa  7 00040 00 0100	desc9a	pr7|32,64		control_point_data.comment
001221  aa   003661 00 0000	desc9a	1969,0		005100 = 056000000000
001222  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001223  aa  6 00433 7551 00	sta  	pr6|283
001224  aa  6 00044 3701 20	epp4 	pr6|36,*
001225  la  4 00170 3521 20	epp2 	pr4|120,*		iox_$error_output
001226  aa  6 00504 2521 00	spri2	pr6|324
001227  aa  6 00464 3521 00	epp2 	pr6|308
001230  aa  6 00506 2521 00	spri2	pr6|326
001231  la  4 00122 3521 20	epp2 	pr4|82,*		cpm_data_$subsystem_name
001232  aa  6 00510 2521 00	spri2	pr6|328
001233  aa  7 00000 3521 00	epp2 	pr7|0		control_point_data.id
001234  aa  6 00512 2521 00	spri2	pr6|330
001235  aa  6 00433 3521 00	epp2 	pr6|283
001236  aa  6 00514 2521 00	spri2	pr6|332
001237  aa  7 00040 3521 00	epp2 	pr7|32		control_point_data.comment
001240  aa  6 00516 2521 00	spri2	pr6|334
001241  aa   776602 3520 04	epp2 	-638,ic		000043 = 464000000000
001242  aa  6 00520 2521 00	spri2	pr6|336
001243  aa   776561 3520 04	epp2 	-655,ic		000024 = 524000000052
001244  aa  6 00522 2521 00	spri2	pr6|338
001245  aa   776570 3520 04	epp2 	-648,ic		000035 = 526000000040
001246  aa  6 00524 2521 00	spri2	pr6|340
001247  aa   776571 3520 04	epp2 	-647,ic		000040 = 514000000044
001250  aa  6 00526 2521 00	spri2	pr6|342
001251  aa   776565 3520 04	epp2 	-651,ic		000036 = 514000000001
001252  aa  6 00530 2521 00	spri2	pr6|344
001253  aa   776550 3520 04	epp2 	-664,ic		000023 = 524000000100
001254  aa  6 00532 2521 00	spri2	pr6|346
001255  aa  6 00502 6211 00	eax1 	pr6|322
001256  aa   030000 4310 07	fld  	12288,dl
001257  la  4 00060 3521 20	epp2 	pr4|48,*		ioa_$ioa_switch
001260  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 336
		on any_other call error_handler$ignore_pi ();

001261  aa   000011 7260 07	lxl6 	9,dl
001262  aa   776630 3520 04	epp2 	-616,ic		000112 = 141156171137
001263  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001264  aa   000004 7100 04	tra  	4,ic		001270
001265  aa     000106000000
001266  aa   000015 7100 04	tra  	13,ic		001303
BEGIN CONDITION any_other.7
ENTRY TO any_other.7                                        STATEMENT 1 ON LINE 336
		on any_other call error_handler$ignore_pi ();

001267  da     000773200000
001270  aa   000100 6270 00	eax7 	64
001271  aa  7 00034 3521 20	epp2 	pr7|28,*
001272  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001273  aa     000000000000
001274  aa     000000000000
001275  aa   000001 7270 07	lxl7 	1,dl
001276  aa  6 00056 6211 00	eax1 	pr6|46
001277  aa   000000 4310 07	fld  	0,dl
001300  aa   000337 3520 04	epp2 	223,ic		001637 = 000140627000
001301  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
001302  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION any_other.7
						STATEMENT 1 ON LINE 339
		call issue_root_start_order ();

001303  aa   002534 6700 04	tsp4 	1372,ic		004037
						STATEMENT 1 ON LINE 341
		call cpm_$stop (control_point_data.id, (0));

001304  aa  6 00433 4501 00	stz  	pr6|283
001305  aa  6 00122 3521 20	epp2 	pr6|82,*		control_point_data.id
001306  aa  6 00436 2521 00	spri2	pr6|286
001307  aa  6 00433 3521 00	epp2 	pr6|283
001310  aa  6 00440 2521 00	spri2	pr6|288
001311  aa  6 00434 6211 00	eax1 	pr6|284
001312  aa   010000 4310 07	fld  	4096,dl
001313  aa  6 00044 3701 20	epp4 	pr6|36,*
001314  la  4 00132 3521 20	epp2 	pr4|90,*		cpm_$stop
001315  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 342
		call cpm_$scheduler ();

001316  aa  6 00056 6211 00	eax1 	pr6|46
001317  aa   000000 4310 07	fld  	0,dl
001320  aa  6 00044 3701 20	epp4 	pr6|36,*
001321  la  4 00134 3521 20	epp2 	pr4|92,*		cpm_$scheduler
001322  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 344
		revert any_other;

001323  aa  6 00112 4501 00	stz  	pr6|74
						STATEMENT 1 ON LINE 345
	     end;

						STATEMENT 1 ON LINE 351
RETURN_FROM_CL_INTERMEDIARY:
	call issue_start_orders ();

001324  aa   002365 6700 04	tsp4 	1269,ic		003711
						STATEMENT 1 ON LINE 354
	if saved_swapped_switches			/* put things back the way the error_handler expects them */
	then call swap_switches (cpd_ptr, addr (cpm_data_$root_control_point_data), control_point_data.swapped_switches,
		"1"b, "0"b);

001325  aa  6 00105 2351 00	lda  	pr6|69		saved_swapped_switches
001326  aa   000031 6000 04	tze  	25,ic		001357
001327  aa  6 00044 3701 20	epp4 	pr6|36,*
001330  la  4 00124 3735 20	epp7 	pr4|84,*		cpm_data_$root_control_point_data
001331  aa  6 00534 6535 00	spri7	pr6|348
001332  aa   400000 2350 03	lda  	131072,du
001333  aa  6 00433 7551 00	sta  	pr6|283
001334  aa   000000 2350 07	lda  	0,dl
001335  aa  6 00432 7551 00	sta  	pr6|282
001336  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
001337  aa  6 00466 2521 00	spri2	pr6|310
001340  aa  6 00534 3521 00	epp2 	pr6|348
001341  aa  6 00470 2521 00	spri2	pr6|312
001342  aa   000001 7270 07	lxl7 	1,dl
001343  aa  6 00122 3715 20	epp5 	pr6|82,*		cpd_ptr
001344  aa  5 00003 3521 00	epp2 	pr5|3		control_point_data.swapped_switches
001345  aa  2 00000 5035 17	abd  	pr2|0,7
001346  aa  6 00472 2521 00	spri2	pr6|314
001347  aa  6 00433 3521 00	epp2 	pr6|283
001350  aa  6 00474 2521 00	spri2	pr6|316
001351  aa  6 00432 3521 00	epp2 	pr6|282
001352  aa  6 00476 2521 00	spri2	pr6|318
001353  aa  6 00464 3521 00	epp2 	pr6|308
001354  aa   024000 4310 07	fld  	10240,dl
001355  aa  2 00000 7571 00	staq 	pr2|0
001356  aa   002106 6700 04	tsp4 	1094,ic		003464
						STATEMENT 1 ON LINE 358
	return;

001357  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO destroy_control_point_switches_c                   STATEMENT 1 ON LINE 642
destroy_control_point_switches_caller:
     entry (P_cpd_ptr, P_ccpi_ptr, P_old_mask);

001360  at     000003000043
001361  tt     000043000040
001362  ta     001360000000
001363  da     001010300000
001364  aa   001300 6270 00	eax7 	704
001365  aa  7 00034 3521 20	epp2 	pr7|28,*
001366  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001367  aa     000006000000
001370  aa     000000000000
001371  aa  6 00032 3735 20	epp7 	pr6|26,*
001372  aa  7 00004 3715 20	epp5 	pr7|4,*
001373  aa  6 00146 6515 00	spri5	pr6|102
001374  aa  7 00006 3535 20	epp3 	pr7|6,*
001375  aa  6 00150 2535 00	spri3	pr6|104
						STATEMENT 1 ON LINE 645
	cpd_ptr = P_cpd_ptr;

001376  aa  6 00032 3735 20	epp7 	pr6|26,*
001377  aa  7 00002 3715 20	epp5 	pr7|2,*		P_cpd_ptr
001400  aa  5 00000 3715 20	epp5 	pr5|0,*		P_cpd_ptr
001401  aa  6 00122 6515 00	spri5	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 646
	ccpi_ptr = P_ccpi_ptr;

001402  aa  6 00146 3535 20	epp3 	pr6|102,*		P_ccpi_ptr
001403  aa  3 00000 3535 20	epp3 	pr3|0,*		P_ccpi_ptr
001404  aa  6 00124 2535 00	spri3	pr6|84		ccpi_ptr
						STATEMENT 1 ON LINE 648
	call destroy_control_point_switches (P_old_mask);

001405  aa  6 00150 3521 20	epp2 	pr6|104,*		P_old_mask
001406  aa  6 00436 2521 00	spri2	pr6|286
001407  aa  6 00434 3521 00	epp2 	pr6|284
001410  aa   004000 4310 07	fld  	2048,dl
001411  aa  2 00000 7571 00	staq 	pr2|0
001412  aa   001620 6700 04	tsp4 	912,ic		003232
						STATEMENT 1 ON LINE 650
	return;

001413  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO swap_switches_caller                               STATEMENT 1 ON LINE 700
swap_switches_caller:
     entry (P_new_cpd_ptr, P_old_cpd_ptr, P_cpd_swapped_switches, P_new_swapped_switches_setting);

001414  at     000004000043
001415  tt     000043000037
001416  ta     000036000000
001417  ta     001414000000
001420  da     001021300000
001421  aa   001300 6270 00	eax7 	704
001422  aa  7 00034 3521 20	epp2 	pr7|28,*
001423  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001424  aa     000010000000
001425  aa     000000000000
						STATEMENT 1 ON LINE 703
	old_mask = ""b;

001426  aa  6 00100 4501 00	stz  	pr6|64		old_mask
						STATEMENT 1 ON LINE 704
	on any_other
	     begin;

001427  aa   000011 7260 07	lxl6 	9,dl
001430  aa   776462 3520 04	epp2 	-718,ic		000112 = 141156171137
001431  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001432  aa   000004 7100 04	tra  	4,ic		001436
001433  aa     000106000000
001434  aa   000033 7100 04	tra  	27,ic		001467
BEGIN CONDITION any_other.9
ENTRY TO any_other.9                                        STATEMENT 1 ON LINE 704
	on any_other
	     begin;

001435  da     001027200000
001436  aa   000120 6270 00	eax7 	80
001437  aa  7 00034 3521 20	epp2 	pr7|28,*
001440  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001441  aa     000000000000
001442  aa     000000000000
						STATEMENT 1 ON LINE 706
		if substr (old_mask, 36, 1) = "1"b
		then call unmask_ips_interrupts_caller (old_mask);

001443  aa  6 00040 3735 20	epp7 	pr6|32,*
001444  aa  7 00100 2351 00	lda  	pr7|64		old_mask
001445  aa   000043 7350 00	als  	35
001446  aa   400000 1150 03	cmpa 	131072,du
001447  aa   000007 6010 04	tnz  	7,ic		001456
001450  aa  7 00100 3521 00	epp2 	pr7|64		old_mask
001451  aa  6 00102 2521 00	spri2	pr6|66
001452  aa  6 00100 6211 00	eax1 	pr6|64
001453  aa   004000 4310 07	fld  	2048,dl
001454  aa   000120 3520 04	epp2 	80,ic		001574 = 001300627000
001455  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 708
		call continue_to_signal_ ((0));

001456  aa  6 00104 4501 00	stz  	pr6|68
001457  aa  6 00104 3521 00	epp2 	pr6|68
001460  aa  6 00102 2521 00	spri2	pr6|66
001461  aa  6 00100 6211 00	eax1 	pr6|64
001462  aa   004000 4310 07	fld  	2048,dl
001463  aa  6 00044 3701 20	epp4 	pr6|36,*
001464  la  4 00026 3521 20	epp2 	pr4|22,*		continue_to_signal_
001465  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 709
	     end;

001466  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION any_other.9
						STATEMENT 1 ON LINE 711
	call swap_switches (P_new_cpd_ptr, P_old_cpd_ptr, P_cpd_swapped_switches, P_new_swapped_switches_setting, "0"b);

001467  aa   000000 2350 07	lda  	0,dl
001470  aa  6 00432 7551 00	sta  	pr6|282
001471  aa  6 00032 3735 20	epp7 	pr6|26,*
001472  aa  7 00002 3521 20	epp2 	pr7|2,*		P_new_cpd_ptr
001473  aa  6 00466 2521 00	spri2	pr6|310
001474  aa  7 00004 3521 20	epp2 	pr7|4,*		P_old_cpd_ptr
001475  aa  6 00470 2521 00	spri2	pr6|312
001476  aa  7 00006 3521 20	epp2 	pr7|6,*		P_cpd_swapped_switches
001477  aa  6 00472 2521 00	spri2	pr6|314
001500  aa  7 00010 3521 20	epp2 	pr7|8,*		P_new_swapped_switches_setting
001501  aa  6 00474 2521 00	spri2	pr6|316
001502  aa  6 00432 3521 00	epp2 	pr6|282
001503  aa  6 00476 2521 00	spri2	pr6|318
001504  aa  6 00464 3521 00	epp2 	pr6|308
001505  aa   024000 4310 07	fld  	10240,dl
001506  aa  2 00000 7571 00	staq 	pr2|0
001507  aa   001755 6700 04	tsp4 	1005,ic		003464
						STATEMENT 1 ON LINE 713
	return;

001510  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO issue_start_orders_caller                          STATEMENT 1 ON LINE 741
issue_start_orders_caller:
     entry (P_cpd_ptr);

001511  at     000001000043
001512  ta     001511000000
001513  da     001041300000
001514  aa   001300 6270 00	eax7 	704
001515  aa  7 00034 3521 20	epp2 	pr7|28,*
001516  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001517  aa     000002000000
001520  aa     000000000000
						STATEMENT 1 ON LINE 744
	cpd_ptr = P_cpd_ptr;

001521  aa  6 00032 3735 20	epp7 	pr6|26,*
001522  aa  7 00002 3715 20	epp5 	pr7|2,*		P_cpd_ptr
001523  aa  5 00000 3715 20	epp5 	pr5|0,*		P_cpd_ptr
001524  aa  6 00122 6515 00	spri5	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 746
	call issue_start_orders ();

001525  aa   002164 6700 04	tsp4 	1140,ic		003711
						STATEMENT 1 ON LINE 748
	return;

001526  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO issue_root_start_order_caller                      STATEMENT 1 ON LINE 773
issue_root_start_order_caller:
     entry (P_cpd_ptr);

001527  ta     001511000000
001530  da     001054300000
001531  aa   001300 6270 00	eax7 	704
001532  aa  7 00034 3521 20	epp2 	pr7|28,*
001533  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001534  aa     000002000000
001535  aa     000000000000
						STATEMENT 1 ON LINE 776
	cpd_ptr = P_cpd_ptr;

001536  aa  6 00032 3735 20	epp7 	pr6|26,*
001537  aa  7 00002 3715 20	epp5 	pr7|2,*		P_cpd_ptr
001540  aa  5 00000 3715 20	epp5 	pr5|0,*		P_cpd_ptr
001541  aa  6 00122 6515 00	spri5	pr6|82		cpd_ptr
						STATEMENT 1 ON LINE 778
	call issue_root_start_order ();

001542  aa   002275 6700 04	tsp4 	1213,ic		004037
						STATEMENT 1 ON LINE 780
	return;

001543  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO mask_ips_interrupts_caller                         STATEMENT 1 ON LINE 909
mask_ips_interrupts_caller:
     entry (P_new_mask, P_old_mask);

001544  at     000002000040
001545  ta     000040000000
001546  ta     001544000000
001547  da     001066300000
001550  aa   001300 6270 00	eax7 	704
001551  aa  7 00034 3521 20	epp2 	pr7|28,*
001552  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001553  aa     000004000000
001554  aa     000000000000
001555  aa  6 00032 3735 20	epp7 	pr6|26,*
001556  aa  7 00004 3715 20	epp5 	pr7|4,*
001557  aa  6 00150 6515 00	spri5	pr6|104
						STATEMENT 1 ON LINE 912
	call mask_ips_interrupts (P_new_mask, P_old_mask);

001560  aa  6 00032 3735 20	epp7 	pr6|26,*
001561  aa  7 00002 3521 20	epp2 	pr7|2,*		P_new_mask
001562  aa  6 00444 2521 00	spri2	pr6|292
001563  aa  6 00150 3521 20	epp2 	pr6|104,*		P_old_mask
001564  aa  6 00446 2521 00	spri2	pr6|294
001565  aa  6 00442 3521 00	epp2 	pr6|290
001566  aa   010000 4310 07	fld  	4096,dl
001567  aa  2 00000 7571 00	staq 	pr2|0
001570  aa   003063 6700 04	tsp4 	1587,ic		004653
						STATEMENT 1 ON LINE 913
	return;

001571  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO unmask_ips_interrupts_caller                       STATEMENT 1 ON LINE 934
unmask_ips_interrupts_caller:
     entry (P_old_mask);

001572  ta     000773000000
001573  da     001101300000
001574  aa   001300 6270 00	eax7 	704
001575  aa  7 00034 3521 20	epp2 	pr7|28,*
001576  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001577  aa     000002000000
001600  aa     000000000000
001601  aa  6 00032 3735 20	epp7 	pr6|26,*
001602  aa  7 00002 3715 20	epp5 	pr7|2,*
001603  aa  6 00150 6515 00	spri5	pr6|104
						STATEMENT 1 ON LINE 937
	call unmask_ips_interrupts (P_old_mask);

001604  aa  6 00150 3521 20	epp2 	pr6|104,*		P_old_mask
001605  aa  6 00436 2521 00	spri2	pr6|286
001606  aa  6 00434 3521 00	epp2 	pr6|284
001607  aa   004000 4310 07	fld  	2048,dl
001610  aa  2 00000 7571 00	staq 	pr2|0
001611  aa   003057 6700 04	tsp4 	1583,ic		004670
						STATEMENT 1 ON LINE 938
	return;

001612  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 955
     end cpm_overseer_;

BEGIN PROCEDURE error_handler
ENTRY TO error_handler                                      STATEMENT 1 ON LINE 366
error_handler:
     procedure ();

001613  da     001110200000
001614  aa   000140 6270 00	eax7 	96
001615  aa  7 00034 3521 20	epp2 	pr7|28,*
001616  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001617  aa     000000000000
001620  aa     000000000000
						STATEMENT 1 ON LINE 368
	return;

001621  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO error_handler$catch_all                            STATEMENT 1 ON LINE 375
error_handler$catch_all:				/* catch everything including program_interrupt */
     entry ();

001622  da     001121200000
001623  aa   000140 6270 00	eax7 	96
001624  aa  7 00034 3521 20	epp2 	pr7|28,*
001625  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001626  aa     000000000000
001627  aa     000000000000
						STATEMENT 1 ON LINE 377
	real_error_handler = default_error_handler_$wall;

001630  aa  6 00044 3701 20	epp4 	pr6|36,*
001631  la  4 00044 3521 20	epp2 	pr4|36,*		default_error_handler_$wall
001632  aa  6 00100 2521 00	spri2	pr6|64		real_error_handler
001633  aa   003235 2370 04	ldaq 	1693,ic		005070 = 077777000043 000001000000
001634  aa  6 00102 7571 00	staq 	pr6|66		real_error_handler
						STATEMENT 1 ON LINE 378
	go to ERROR_HANDLER;

001635  aa   000015 7100 04	tra  	13,ic		001652
ENTRY TO error_handler$ignore_pi                            STATEMENT 1 ON LINE 381
error_handler$ignore_pi:				/* catch everything but program_interrupt and a few others */
     entry ();

001636  da     001132200000
001637  aa   000140 6270 00	eax7 	96
001640  aa  7 00034 3521 20	epp2 	pr7|28,*
001641  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001642  aa     000000000000
001643  aa     000000000000
						STATEMENT 1 ON LINE 383
	real_error_handler = default_error_handler_$wall_ignore_pi;

001644  aa  6 00044 3701 20	epp4 	pr6|36,*
001645  la  4 00046 3521 20	epp2 	pr4|38,*		default_error_handler_$wall_ignore_pi
001646  aa  6 00100 2521 00	spri2	pr6|64		real_error_handler
001647  aa   003221 2370 04	ldaq 	1681,ic		005070 = 077777000043 000001000000
001650  aa  6 00102 7571 00	staq 	pr6|66		real_error_handler
						STATEMENT 1 ON LINE 384
	go to ERROR_HANDLER;

001651  aa   000001 7100 04	tra  	1,ic		001652
						STATEMENT 1 ON LINE 387
ERROR_HANDLER:
	our_arg_list_ptr = cu_$arg_list_ptr ();

001652  aa  6 00106 3521 00	epp2 	pr6|70		our_arg_list_ptr
001653  aa  6 00120 2521 00	spri2	pr6|80
001654  aa  6 00116 6211 00	eax1 	pr6|78
001655  aa   004000 4310 07	fld  	2048,dl
001656  la  4 00034 3521 20	epp2 	pr4|28,*		cu_$arg_list_ptr
001657  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 390
	must_swap_switches = ^control_point_data.swapped_switches;

001660  aa  6 00040 3735 20	epp7 	pr6|32,*
001661  aa  7 00122 3715 20	epp5 	pr7|82,*		cpd_ptr
001662  aa  5 00003 2351 00	lda  	pr5|3		control_point_data.swapped_switches
001663  aa   000001 7350 00	als  	1
001664  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001665  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001666  aa  6 00104 7551 00	sta  	pr6|68		must_swap_switches
						STATEMENT 1 ON LINE 392
	on cleanup
	     begin;

001667  aa   000007 7260 07	lxl6 	7,dl
001670  aa   776170 3520 04	epp2 	-904,ic		000060 = 143154145141
001671  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001672  aa   000004 7100 04	tra  	4,ic		001676
001673  aa     000110000000
001674  aa   000042 7100 04	tra  	34,ic		001736
BEGIN CONDITION cleanup.8
ENTRY TO cleanup.8                                          STATEMENT 1 ON LINE 392
	on cleanup
	     begin;

001675  da     001140200000
001676  aa   000120 6270 00	eax7 	80
001677  aa  7 00034 3521 20	epp2 	pr7|28,*
001700  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001701  aa     000000000000
001702  aa     000000000000
						STATEMENT 1 ON LINE 394
		if must_swap_switches & control_point_data.swapped_switches
		then call swap_switches_caller (addr (cpm_data_$root_control_point_data), cpd_ptr,
			control_point_data.swapped_switches, "0"b);

001703  aa  6 00040 3735 20	epp7 	pr6|32,*
001704  aa  7 00104 2351 00	lda  	pr7|68		must_swap_switches
001705  aa   000030 6000 04	tze  	24,ic		001735
001706  aa  7 00040 3715 20	epp5 	pr7|32,*
001707  aa  5 00122 3535 20	epp3 	pr5|82,*		cpd_ptr
001710  aa  3 00003 2351 00	lda  	pr3|3		control_point_data.swapped_switches
001711  aa   200000 3150 03	cana 	65536,du
001712  aa   000023 6000 04	tze  	19,ic		001735
001713  la  4 00124 3515 20	epp1 	pr4|84,*		cpm_data_$root_control_point_data
001714  aa  6 00100 2515 00	spri1	pr6|64
001715  aa   000000 2350 07	lda  	0,dl
001716  aa  6 00102 7551 00	sta  	pr6|66
001717  aa  6 00100 3521 00	epp2 	pr6|64
001720  aa  6 00106 2521 00	spri2	pr6|70
001721  aa  5 00122 3521 00	epp2 	pr5|82		cpd_ptr
001722  aa  6 00110 2521 00	spri2	pr6|72
001723  aa   000001 7270 07	lxl7 	1,dl
001724  aa  3 00003 3521 00	epp2 	pr3|3		control_point_data.swapped_switches
001725  aa  2 00000 5035 17	abd  	pr2|0,7
001726  aa  6 00112 2521 00	spri2	pr6|74
001727  aa  6 00102 3521 00	epp2 	pr6|66
001730  aa  6 00114 2521 00	spri2	pr6|76
001731  aa  6 00104 6211 00	eax1 	pr6|68
001732  aa   020000 4310 07	fld  	8192,dl
001733  aa   777466 3520 04	epp2 	-202,ic		001421 = 001300627000
001734  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 397
	     end;

001735  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.8
						STATEMENT 1 ON LINE 399
	if must_swap_switches
	then call swap_switches_caller (cpd_ptr, addr (cpm_data_$root_control_point_data),
		control_point_data.swapped_switches, "1"b);

001736  aa  6 00104 2351 00	lda  	pr6|68		must_swap_switches
001737  aa   000026 6000 04	tze  	22,ic		001765
001740  aa  6 00044 3701 20	epp4 	pr6|36,*
001741  la  4 00124 3735 20	epp7 	pr4|84,*		cpm_data_$root_control_point_data
001742  aa  6 00122 6535 00	spri7	pr6|82
001743  aa   400000 2350 03	lda  	131072,du
001744  aa  6 00124 7551 00	sta  	pr6|84
001745  aa  6 00040 3715 20	epp5 	pr6|32,*
001746  aa  5 00122 3521 00	epp2 	pr5|82		cpd_ptr
001747  aa  6 00130 2521 00	spri2	pr6|88
001750  aa  6 00122 3521 00	epp2 	pr6|82
001751  aa  6 00132 2521 00	spri2	pr6|90
001752  aa   000001 7270 07	lxl7 	1,dl
001753  aa  5 00122 3535 20	epp3 	pr5|82,*		cpd_ptr
001754  aa  3 00003 3521 00	epp2 	pr3|3		control_point_data.swapped_switches
001755  aa  2 00000 5035 17	abd  	pr2|0,7
001756  aa  6 00134 2521 00	spri2	pr6|92
001757  aa  6 00124 3521 00	epp2 	pr6|84
001760  aa  6 00136 2521 00	spri2	pr6|94
001761  aa  6 00126 6211 00	eax1 	pr6|86
001762  aa   020000 4310 07	fld  	8192,dl
001763  aa   777436 3520 04	epp2 	-226,ic		001421 = 001300627000
001764  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 403
	call cu_$generate_call (real_error_handler, our_arg_list_ptr);

001765  aa  6 00100 3521 00	epp2 	pr6|64		real_error_handler
001766  aa  6 00130 2521 00	spri2	pr6|88
001767  aa  6 00106 3521 00	epp2 	pr6|70		our_arg_list_ptr
001770  aa  6 00132 2521 00	spri2	pr6|90
001771  aa  6 00126 6211 00	eax1 	pr6|86
001772  aa   010000 4310 07	fld  	4096,dl
001773  aa  6 00044 3701 20	epp4 	pr6|36,*
001774  la  4 00036 3521 20	epp2 	pr4|30,*		cu_$generate_call
001775  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 405
	if must_swap_switches & control_point_data.swapped_switches
	then call swap_switches_caller (addr (cpm_data_$root_control_point_data), cpd_ptr,
		control_point_data.swapped_switches, "0"b);

001776  aa  6 00104 2351 00	lda  	pr6|68		must_swap_switches
001777  aa   000031 6000 04	tze  	25,ic		002030
002000  aa  6 00040 3735 20	epp7 	pr6|32,*
002001  aa  7 00122 3715 20	epp5 	pr7|82,*		cpd_ptr
002002  aa  5 00003 2351 00	lda  	pr5|3		control_point_data.swapped_switches
002003  aa   200000 3150 03	cana 	65536,du
002004  aa   000024 6000 04	tze  	20,ic		002030
002005  aa  6 00044 3701 20	epp4 	pr6|36,*
002006  la  4 00124 3535 20	epp3 	pr4|84,*		cpm_data_$root_control_point_data
002007  aa  6 00122 2535 00	spri3	pr6|82
002010  aa   000000 2350 07	lda  	0,dl
002011  aa  6 00124 7551 00	sta  	pr6|84
002012  aa  6 00122 3521 00	epp2 	pr6|82
002013  aa  6 00130 2521 00	spri2	pr6|88
002014  aa  7 00122 3521 00	epp2 	pr7|82		cpd_ptr
002015  aa  6 00132 2521 00	spri2	pr6|90
002016  aa   000001 7270 07	lxl7 	1,dl
002017  aa  5 00003 3521 00	epp2 	pr5|3		control_point_data.swapped_switches
002020  aa  2 00000 5035 17	abd  	pr2|0,7
002021  aa  6 00134 2521 00	spri2	pr6|92
002022  aa  6 00124 3521 00	epp2 	pr6|84
002023  aa  6 00136 2521 00	spri2	pr6|94
002024  aa  6 00126 6211 00	eax1 	pr6|86
002025  aa   020000 4310 07	fld  	8192,dl
002026  aa   777373 3520 04	epp2 	-261,ic		001421 = 001300627000
002027  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 409
	return;

002030  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 411
     end error_handler;

  END PROCEDURE error_handler
BEGIN PROCEDURE create_control_point_switches
ENTRY TO create_control_point_switches                      STATEMENT 1 ON LINE 418
create_control_point_switches:
     procedure ();

002031  aa  6 00152 6501 00	spri4	pr6|106
						STATEMENT 1 ON LINE 429
	local_io_switches = null ();

002032  aa   776022 2370 04	ldaq 	-1006,ic		000054 = 077777000043 000001000000
002033  aa  6 00160 7571 00	staq 	pr6|112		local_io_switches.user_io
002034  aa  6 00162 7571 00	staq 	pr6|114		local_io_switches.user_input
002035  aa  6 00164 7571 00	staq 	pr6|116		local_io_switches.user_output
002036  aa  6 00166 7571 00	staq 	pr6|118		local_io_switches.error_output
						STATEMENT 1 ON LINE 431
	call ioa_$rsnnl ("^12.3b", id_string, (0), control_point_data.id);

002037  aa   776013 2370 04	ldaq 	-1013,ic		000052 = 136061062056 063142000000
002040  aa  6 00536 7571 00	staq 	pr6|350
002041  aa  6 00540 4501 00	stz  	pr6|352
002042  aa  6 00536 3521 00	epp2 	pr6|350
002043  aa  6 00544 2521 00	spri2	pr6|356
002044  aa  6 00172 3521 00	epp2 	pr6|122		id_string
002045  aa  6 00546 2521 00	spri2	pr6|358
002046  aa  6 00540 3521 00	epp2 	pr6|352
002047  aa  6 00550 2521 00	spri2	pr6|360
002050  aa  6 00122 3521 20	epp2 	pr6|82,*		control_point_data.id
002051  aa  6 00552 2521 00	spri2	pr6|362
002052  aa   775750 3520 04	epp2 	-1048,ic		000022 = 524000000006
002053  aa  6 00554 2521 00	spri2	pr6|364
002054  aa   775745 3520 04	epp2 	-1051,ic		000021 = 526000000014
002055  aa  6 00556 2521 00	spri2	pr6|366
002056  aa   775742 3520 04	epp2 	-1054,ic		000020 = 404000000005
002057  aa  6 00560 2521 00	spri2	pr6|368
002060  aa   775760 3520 04	epp2 	-1040,ic		000040 = 514000000044
002061  aa  6 00562 2521 00	spri2	pr6|370
002062  aa  6 00542 6211 00	eax1 	pr6|354
002063  aa   020000 4310 07	fld  	8192,dl
002064  aa  6 00044 3701 20	epp4 	pr6|36,*
002065  la  4 00062 3521 20	epp2 	pr4|50,*		ioa_$rsnnl
002066  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 432
	our_user_io = id_string || ".user_i/o";

002067  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002070  aa  6 00172 00 0014	desc9a	pr6|122,12	id_string
002071  aa  6 00203 00 0014	desc9a	pr6|131,12	our_user_io
002072  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002073  aa   776004 00 0011	desc9a	-1020,9		000076 = 056165163145
002074  aa  6 00206 00 0011	desc9a	pr6|134,9		our_user_io
						STATEMENT 1 ON LINE 434
	if create_control_point_info.user_io_attach_desc_given
	then do;

002075  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
002076  aa  7 00035 2351 00	lda  	pr7|29		create_control_point_info.user_io_attach_desc_given
002077  aa   100000 3150 03	cana 	32768,du
002100  aa   000111 6000 04	tze  	73,ic		002211
						STATEMENT 1 ON LINE 436
		call iox_$attach_name (our_user_io, local_io_switches.user_io,
		     create_control_point_info.user_io_attach_desc, null (), code);

002101  aa  7 00037 2361 00	ldq  	pr7|31		create_control_point_info.user_io_attach_desc_length
002102  aa   526000 2760 03	orq  	175104,du
002103  aa  6 00540 7561 00	stq  	pr6|352
002104  aa   775750 3714 24	epp5 	-1048,ic*
002105  aa  6 00536 6515 00	spri5	pr6|350
002106  aa  6 00203 3521 00	epp2 	pr6|131		our_user_io
002107  aa  6 00566 2521 00	spri2	pr6|374
002110  aa  6 00160 3521 00	epp2 	pr6|112		local_io_switches.user_io
002111  aa  6 00570 2521 00	spri2	pr6|376
002112  aa  7 00040 3521 00	epp2 	pr7|32		create_control_point_info.user_io_attach_desc
002113  aa  6 00572 2521 00	spri2	pr6|378
002114  aa  6 00536 3521 00	epp2 	pr6|350
002115  aa  6 00574 2521 00	spri2	pr6|380
002116  aa  6 00211 3521 00	epp2 	pr6|137		code
002117  aa  6 00576 2521 00	spri2	pr6|382
002120  aa   775677 3520 04	epp2 	-1089,ic		000017 = 526000000025
002121  aa  6 00600 2521 00	spri2	pr6|384
002122  aa   775721 3520 04	epp2 	-1071,ic		000043 = 464000000000
002123  aa  6 00602 2521 00	spri2	pr6|386
002124  aa  6 00606 2521 00	spri2	pr6|390
002125  aa  6 00540 3521 00	epp2 	pr6|352
002126  aa  6 00604 2521 00	spri2	pr6|388
002127  aa   775666 3520 04	epp2 	-1098,ic		000015 = 404000000043
002130  aa  6 00610 2521 00	spri2	pr6|392
002131  aa  6 00564 6211 00	eax1 	pr6|372
002132  aa   024000 4310 07	fld  	10240,dl
002133  aa  6 00044 3701 20	epp4 	pr6|36,*
002134  la  4 00144 3521 20	epp2 	pr4|100,*		iox_$attach_name
002135  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 438
		if code ^= 0
		then call attach_failure (our_user_io, create_control_point_info.user_io_attach_desc, code);

002136  aa  6 00211 2361 00	ldq  	pr6|137		code
002137  aa   000025 6000 04	tze  	21,ic		002164
002140  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
002141  aa  7 00037 2361 00	ldq  	pr7|31		create_control_point_info.user_io_attach_desc_length
002142  aa   526000 2760 03	orq  	175104,du
002143  aa  6 00540 7561 00	stq  	pr6|352
002144  aa  6 00203 3521 00	epp2 	pr6|131		our_user_io
002145  aa  6 00544 2521 00	spri2	pr6|356
002146  aa  7 00040 3521 00	epp2 	pr7|32		create_control_point_info.user_io_attach_desc
002147  aa  6 00546 2521 00	spri2	pr6|358
002150  aa  6 00211 3521 00	epp2 	pr6|137		code
002151  aa  6 00550 2521 00	spri2	pr6|360
002152  aa   775645 3520 04	epp2 	-1115,ic		000017 = 526000000025
002153  aa  6 00552 2521 00	spri2	pr6|362
002154  aa  6 00540 3521 00	epp2 	pr6|352
002155  aa  6 00554 2521 00	spri2	pr6|364
002156  aa   775637 3520 04	epp2 	-1121,ic		000015 = 404000000043
002157  aa  6 00556 2521 00	spri2	pr6|366
002160  aa  6 00542 3521 00	epp2 	pr6|354
002161  aa   014000 4310 07	fld  	6144,dl
002162  aa  2 00000 7571 00	staq 	pr2|0
002163  aa   000574 6700 04	tsp4 	380,ic		002757
						STATEMENT 1 ON LINE 440
		call iox_$open (local_io_switches.user_io, Stream_input_output, "0"b, code);

002164  aa   000000 2350 07	lda  	0,dl
002165  aa  6 00540 7551 00	sta  	pr6|352
002166  aa  6 00160 3521 00	epp2 	pr6|112		local_io_switches.user_io
002167  aa  6 00544 2521 00	spri2	pr6|356
002170  aa   775651 3520 04	epp2 	-1111,ic		000041 = 000000000003
002171  aa  6 00546 2521 00	spri2	pr6|358
002172  aa  6 00540 3521 00	epp2 	pr6|352
002173  aa  6 00550 2521 00	spri2	pr6|360
002174  aa  6 00211 3521 00	epp2 	pr6|137		code
002175  aa  6 00552 2521 00	spri2	pr6|362
002176  aa  6 00542 6211 00	eax1 	pr6|354
002177  aa   020000 4310 07	fld  	8192,dl
002200  aa  6 00044 3701 20	epp4 	pr6|36,*
002201  la  4 00160 3521 20	epp2 	pr4|112,*		iox_$open
002202  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 441
		if code ^= 0
		then call open_failure (our_user_io, code);

002203  aa  6 00211 2361 00	ldq  	pr6|137		code
002204  aa   000047 6000 04	tze  	39,ic		002253
002205  aa   002651 3520 04	epp2 	1449,ic		005056 = 000004000000
002206  aa  2 00000 2351 00	lda  	pr2|0
002207  aa   000740 6700 04	tsp4 	480,ic		003147
						STATEMENT 1 ON LINE 443
	     end;

002210  aa   000043 7100 04	tra  	35,ic		002253
						STATEMENT 1 ON LINE 445
	else do;

						STATEMENT 1 ON LINE 446
		call ioa_$rsnnl ("^12.3b.user_i/o", parents_user_io, (0), parent_control_point_data.id);

002211  aa   775710 2350 04	lda  	-1080,ic		000121 = 136061062056
002212  aa   775710 2360 04	ldq  	-1080,ic		000122 = 063142056165
002213  aa  6 00542 7571 00	staq 	pr6|354
002214  aa   775707 2350 04	lda  	-1081,ic		000123 = 163145162137
002215  aa   775707 2360 04	ldq  	-1081,ic		000124 = 151057157000
002216  aa  6 00544 7571 00	staq 	pr6|356
002217  aa  6 00540 4501 00	stz  	pr6|352
002220  aa  6 00542 3521 00	epp2 	pr6|354
002221  aa  6 00566 2521 00	spri2	pr6|374
002222  aa  6 00175 3521 00	epp2 	pr6|125		parents_user_io
002223  aa  6 00570 2521 00	spri2	pr6|376
002224  aa  6 00540 3521 00	epp2 	pr6|352
002225  aa  6 00572 2521 00	spri2	pr6|378
002226  aa  6 00122 3715 20	epp5 	pr6|82,*		cpd_ptr
002227  aa  5 00016 3521 20	epp2 	pr5|14,*		parent_control_point_data.id
002230  aa  6 00574 2521 00	spri2	pr6|380
002231  aa   775563 3520 04	epp2 	-1165,ic		000014 = 524000000017
002232  aa  6 00576 2521 00	spri2	pr6|382
002233  aa   775564 3520 04	epp2 	-1164,ic		000017 = 526000000025
002234  aa  6 00600 2521 00	spri2	pr6|384
002235  aa   775563 3520 04	epp2 	-1165,ic		000020 = 404000000005
002236  aa  6 00602 2521 00	spri2	pr6|386
002237  aa   775601 3520 04	epp2 	-1151,ic		000040 = 514000000044
002240  aa  6 00604 2521 00	spri2	pr6|388
002241  aa  6 00564 6211 00	eax1 	pr6|372
002242  aa   020000 4310 07	fld  	8192,dl
002243  aa  6 00044 3701 20	epp4 	pr6|36,*
002244  la  4 00062 3521 20	epp2 	pr4|50,*		ioa_$rsnnl
002245  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 447
		call attach_syn ("user_i/o", parents_user_io, "", local_io_switches.user_io);

002246  aa   775602 2370 04	ldaq 	-1150,ic		000050 = 165163145162 137151057157
002247  aa  6 00536 7571 00	staq 	pr6|350
002250  aa   002564 3520 04	epp2 	1396,ic		005034 = 000010000000
002251  aa  2 00000 2351 00	lda  	pr2|0
002252  aa   000300 6700 04	tsp4 	192,ic		002552
						STATEMENT 1 ON LINE 448
	     end;

						STATEMENT 1 ON LINE 454
	call attach_syn ("user_input", "user_i/o", "put_chars", local_io_switches.user_input);

002253  aa   775620 2350 04	lda  	-1136,ic		000073 = 165163145162
002254  aa   775620 2360 04	ldq  	-1136,ic		000074 = 137151156160
002255  aa  6 00542 7571 00	staq 	pr6|354
002256  aa   165164 2350 03	lda  	60020,du
002257  aa  6 00544 7551 00	sta  	pr6|356
002260  aa   775570 2370 04	ldaq 	-1160,ic		000050 = 165163145162 137151057157
002261  aa  6 00536 7571 00	staq 	pr6|350
002262  aa   775606 2370 04	ldaq 	-1146,ic		000070 = 160165164137 143150141162
002263  aa  6 00564 7571 00	staq 	pr6|372
002264  aa   163000 2350 03	lda  	58880,du
002265  aa  6 00566 7551 00	sta  	pr6|374
002266  aa   002524 3520 04	epp2 	1364,ic		005012 = 000010000000
002267  aa  2 00000 2351 00	lda  	pr2|0
002270  aa   000262 6700 04	tsp4 	178,ic		002552
						STATEMENT 1 ON LINE 455
	call attach_syn ("user_output", "user_i/o", "get_chars get_line", local_io_switches.user_output);

002271  aa   775574 2350 04	lda  	-1156,ic		000065 = 165163145162
002272  aa   775574 2360 04	ldq  	-1156,ic		000066 = 137157165164
002273  aa  6 00542 7571 00	staq 	pr6|354
002274  aa   775573 2350 04	lda  	-1157,ic		000067 = 160165164000
002275  aa  6 00544 7551 00	sta  	pr6|356
002276  aa   775552 2370 04	ldaq 	-1174,ic		000050 = 165163145162 137151057157
002277  aa  6 00536 7571 00	staq 	pr6|350
002300  aa   775646 2370 04	ldaq 	-1114,ic		000146 = 147145164137 143150141162
002301  aa  6 00564 7571 00	staq 	pr6|372
002302  aa   775646 2370 04	ldaq 	-1114,ic		000150 = 163040147145 164137154151
002303  aa  6 00566 7571 00	staq 	pr6|374
002304  aa   156145 2350 03	lda  	56421,du
002305  aa  6 00570 7551 00	sta  	pr6|376
002306  aa   002462 3520 04	epp2 	1330,ic		004770 = 000010000000
002307  aa  2 00000 2351 00	lda  	pr2|0
002310  aa   000242 6700 04	tsp4 	162,ic		002552
						STATEMENT 1 ON LINE 456
	call attach_syn ("error_output", "user_i/o", "get_chars get_line", local_io_switches.error_output);

002311  aa   775551 2370 04	ldaq 	-1175,ic		000062 = 145162162157 162137157165
002312  aa  6 00542 7571 00	staq 	pr6|354
002313  aa   775551 2350 04	lda  	-1175,ic		000064 = 164160165164
002314  aa  6 00544 7551 00	sta  	pr6|356
002315  aa   775533 2370 04	ldaq 	-1189,ic		000050 = 165163145162 137151057157
002316  aa  6 00536 7571 00	staq 	pr6|350
002317  aa   775627 2370 04	ldaq 	-1129,ic		000146 = 147145164137 143150141162
002320  aa  6 00564 7571 00	staq 	pr6|372
002321  aa   775627 2370 04	ldaq 	-1129,ic		000150 = 163040147145 164137154151
002322  aa  6 00566 7571 00	staq 	pr6|374
002323  aa   156145 2350 03	lda  	56421,du
002324  aa  6 00570 7551 00	sta  	pr6|376
002325  aa   002421 3520 04	epp2 	1297,ic		004746 = 000010000000
002326  aa  2 00000 2351 00	lda  	pr2|0
002327  aa   000223 6700 04	tsp4 	147,ic		002552
						STATEMENT 1 ON LINE 458
	call unmask_ips_interrupts (old_mask);

002330  aa   002544 3520 04	epp2 	1380,ic		005074 = 000002000000
002331  aa   002337 6700 04	tsp4 	1247,ic		004670
						STATEMENT 1 ON LINE 460
	control_point_data.io_switches = local_io_switches;

002332  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
002333  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002334  aa  6 00160 00 0040	desc9a	pr6|112,32	local_io_switches
002335  aa  7 00066 00 0040	desc9a	pr7|54,32		control_point_data.io_switches
						STATEMENT 1 ON LINE 461
	control_point_data.group_id = control_point_data.id;

002336  aa  6 00122 2351 20	lda  	pr6|82,*		control_point_data.id
002337  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
002340  aa  7 00001 7551 00	sta  	pr7|1		control_point_data.group_id
						STATEMENT 1 ON LINE 464
	if cpm_data_$previous_control_point -> control_point_data.swapped_switches
	then call swap_switches (addr (cpm_data_$root_control_point_data), cpd_ptr, control_point_data.swapped_switches,
		"0"b, "1"b);

002341  aa  6 00044 3701 20	epp4 	pr6|36,*
002342  la  4 00130 3715 20	epp5 	pr4|88,*		cpm_data_$previous_control_point
002343  aa  5 00000 3715 20	epp5 	pr5|0,*		cpm_data_$previous_control_point
002344  aa  5 00003 2351 00	lda  	pr5|3		control_point_data.swapped_switches
002345  aa   200000 3150 03	cana 	65536,du
002346  aa   000030 6000 04	tze  	24,ic		002376
002347  la  4 00124 3535 20	epp3 	pr4|84,*		cpm_data_$root_control_point_data
002350  aa  6 00536 2535 00	spri3	pr6|350
002351  aa   000000 2350 07	lda  	0,dl
002352  aa  6 00540 7551 00	sta  	pr6|352
002353  aa   400000 2350 03	lda  	131072,du
002354  aa  6 00541 7551 00	sta  	pr6|353
002355  aa  6 00536 3521 00	epp2 	pr6|350
002356  aa  6 00544 2521 00	spri2	pr6|356
002357  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
002360  aa  6 00546 2521 00	spri2	pr6|358
002361  aa   000001 7270 07	lxl7 	1,dl
002362  aa  7 00003 3521 00	epp2 	pr7|3		control_point_data.swapped_switches
002363  aa  2 00000 5035 17	abd  	pr2|0,7
002364  aa  6 00550 2521 00	spri2	pr6|360
002365  aa  6 00540 3521 00	epp2 	pr6|352
002366  aa  6 00552 2521 00	spri2	pr6|362
002367  aa  6 00541 3521 00	epp2 	pr6|353
002370  aa  6 00554 2521 00	spri2	pr6|364
002371  aa  6 00542 3521 00	epp2 	pr6|354
002372  aa   024000 4310 07	fld  	10240,dl
002373  aa  2 00000 7571 00	staq 	pr2|0
002374  aa   001070 6700 04	tsp4 	568,ic		003464
002375  aa   000025 7100 04	tra  	21,ic		002422
						STATEMENT 1 ON LINE 467
	else call swap_switches (cpm_data_$previous_control_point, cpd_ptr, control_point_data.swapped_switches, "0"b,
		"1"b);

002376  aa   000000 2350 07	lda  	0,dl
002377  aa  6 00541 7551 00	sta  	pr6|353
002400  aa   400000 2350 03	lda  	131072,du
002401  aa  6 00540 7551 00	sta  	pr6|352
002402  la  4 00130 3521 20	epp2 	pr4|88,*		cpm_data_$previous_control_point
002403  aa  6 00544 2521 00	spri2	pr6|356
002404  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
002405  aa  6 00546 2521 00	spri2	pr6|358
002406  aa   000001 7270 07	lxl7 	1,dl
002407  aa  7 00003 3521 00	epp2 	pr7|3		control_point_data.swapped_switches
002410  aa  2 00000 5035 17	abd  	pr2|0,7
002411  aa  6 00550 2521 00	spri2	pr6|360
002412  aa  6 00541 3521 00	epp2 	pr6|353
002413  aa  6 00552 2521 00	spri2	pr6|362
002414  aa  6 00540 3521 00	epp2 	pr6|352
002415  aa  6 00554 2521 00	spri2	pr6|364
002416  aa  6 00542 3521 00	epp2 	pr6|354
002417  aa   024000 4310 07	fld  	10240,dl
002420  aa  2 00000 7571 00	staq 	pr2|0
002421  aa   001043 6700 04	tsp4 	547,ic		003464
						STATEMENT 1 ON LINE 470
	call mask_ips_interrupts (control_point_data.ips_mask, old_mask);

002422  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
002423  aa  7 00060 3521 00	epp2 	pr7|48		control_point_data.ips_mask
002424  aa  6 00544 2521 00	spri2	pr6|356
002425  aa  6 00100 3521 00	epp2 	pr6|64		old_mask
002426  aa  6 00546 2521 00	spri2	pr6|358
002427  aa  6 00542 3521 00	epp2 	pr6|354
002430  aa   010000 4310 07	fld  	4096,dl
002431  aa  2 00000 7571 00	staq 	pr2|0
002432  aa   002221 6700 04	tsp4 	1169,ic		004653
						STATEMENT 1 ON LINE 472
	return;

002433  aa  6 00152 6101 00	rtcd 	pr6|106
						STATEMENT 1 ON LINE 477
ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES:
	do an_iocb_ptr = local_io_switches.user_input, local_io_switches.user_output, local_io_switches.error_output;

002434  aa   000035 3520 04	epp2 	29,ic		002471 = 000005352004
002435  aa  6 00212 2521 00	spri2	pr6|138
002436  aa  6 00162 3735 20	epp7 	pr6|114,*		local_io_switches.user_input
002437  aa  6 00170 6535 00	spri7	pr6|120		an_iocb_ptr
						STATEMENT 1 ON LINE 479
	     if an_iocb_ptr ^= null ()
	     then do;

002440  aa  6 00170 2371 00	ldaq 	pr6|120		an_iocb_ptr
002441  aa   775413 6770 04	eraq 	-1269,ic		000054 = 077777000043 000001000000
002442  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002443  aa   000025 6000 04	tze  	21,ic		002470
						STATEMENT 1 ON LINE 481
		     call iox_$detach_iocb (an_iocb_ptr, (0));

002444  aa  6 00540 4501 00	stz  	pr6|352
002445  aa  6 00170 3521 00	epp2 	pr6|120		an_iocb_ptr
002446  aa  6 00544 2521 00	spri2	pr6|356
002447  aa  6 00540 3521 00	epp2 	pr6|352
002450  aa  6 00546 2521 00	spri2	pr6|358
002451  aa  6 00542 6211 00	eax1 	pr6|354
002452  aa   010000 4310 07	fld  	4096,dl
002453  aa  6 00044 3701 20	epp4 	pr6|36,*
002454  la  4 00154 3521 20	epp2 	pr4|108,*		iox_$detach_iocb
002455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 482
		     call iox_$destroy_iocb (an_iocb_ptr, (0));

002456  aa  6 00540 4501 00	stz  	pr6|352
002457  aa  6 00170 3521 00	epp2 	pr6|120		an_iocb_ptr
002460  aa  6 00544 2521 00	spri2	pr6|356
002461  aa  6 00540 3521 00	epp2 	pr6|352
002462  aa  6 00546 2521 00	spri2	pr6|358
002463  aa  6 00542 6211 00	eax1 	pr6|354
002464  aa   010000 4310 07	fld  	4096,dl
002465  aa  6 00044 3701 20	epp4 	pr6|36,*
002466  la  4 00152 3521 20	epp2 	pr4|106,*		iox_$destroy_iocb
002467  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 483
		end;

						STATEMENT 1 ON LINE 484
	end;

002470  aa  6 00212 7101 20	tra  	pr6|138,*
002471  aa   000005 3520 04	epp2 	5,ic		002476 = 000005352004
002472  aa  6 00212 2521 00	spri2	pr6|138
002473  aa  6 00164 3735 20	epp7 	pr6|116,*		local_io_switches.user_output
002474  aa  6 00170 6535 00	spri7	pr6|120		an_iocb_ptr
002475  aa   777743 7100 04	tra  	-29,ic		002440
002476  aa   000005 3520 04	epp2 	5,ic		002503 = 600160237100
002477  aa  6 00212 2521 00	spri2	pr6|138
002500  aa  6 00166 3735 20	epp7 	pr6|118,*		local_io_switches.error_output
002501  aa  6 00170 6535 00	spri7	pr6|120		an_iocb_ptr
002502  aa   777736 7100 04	tra  	-34,ic		002440
						STATEMENT 1 ON LINE 486
	if local_io_switches.user_io ^= null ()
	then do;

002503  aa  6 00160 2371 00	ldaq 	pr6|112		local_io_switches.user_io
002504  aa   775350 6770 04	eraq 	-1304,ic		000054 = 077777000043 000001000000
002505  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002506  aa   000043 6000 04	tze  	35,ic		002551
						STATEMENT 1 ON LINE 488
		if create_control_point_info.user_io_attach_desc_given
		then call iox_$close (local_io_switches.user_io, (0));

002507  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
002510  aa  7 00035 2351 00	lda  	pr7|29		create_control_point_info.user_io_attach_desc_given
002511  aa   100000 3150 03	cana 	32768,du
002512  aa   000013 6000 04	tze  	11,ic		002525
002513  aa  6 00540 4501 00	stz  	pr6|352
002514  aa  6 00160 3521 00	epp2 	pr6|112		local_io_switches.user_io
002515  aa  6 00544 2521 00	spri2	pr6|356
002516  aa  6 00540 3521 00	epp2 	pr6|352
002517  aa  6 00546 2521 00	spri2	pr6|358
002520  aa  6 00542 6211 00	eax1 	pr6|354
002521  aa   010000 4310 07	fld  	4096,dl
002522  aa  6 00044 3701 20	epp4 	pr6|36,*
002523  la  4 00146 3521 20	epp2 	pr4|102,*		iox_$close
002524  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 490
		call iox_$detach_iocb (local_io_switches.user_io, (0));

002525  aa  6 00540 4501 00	stz  	pr6|352
002526  aa  6 00160 3521 00	epp2 	pr6|112		local_io_switches.user_io
002527  aa  6 00544 2521 00	spri2	pr6|356
002530  aa  6 00540 3521 00	epp2 	pr6|352
002531  aa  6 00546 2521 00	spri2	pr6|358
002532  aa  6 00542 6211 00	eax1 	pr6|354
002533  aa   010000 4310 07	fld  	4096,dl
002534  aa  6 00044 3701 20	epp4 	pr6|36,*
002535  la  4 00154 3521 20	epp2 	pr4|108,*		iox_$detach_iocb
002536  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 491
		call iox_$destroy_iocb (local_io_switches.user_io, (0));

002537  aa  6 00540 4501 00	stz  	pr6|352
002540  aa  6 00160 3521 00	epp2 	pr6|112		local_io_switches.user_io
002541  aa  6 00544 2521 00	spri2	pr6|356
002542  aa  6 00540 3521 00	epp2 	pr6|352
002543  aa  6 00546 2521 00	spri2	pr6|358
002544  aa  6 00542 6211 00	eax1 	pr6|354
002545  aa   010000 4310 07	fld  	4096,dl
002546  aa  6 00044 3701 20	epp4 	pr6|36,*
002547  la  4 00152 3521 20	epp2 	pr4|106,*		iox_$destroy_iocb
002550  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 492
	     end;

						STATEMENT 1 ON LINE 494
	go to RETURN_FROM_OVERSEER;

002551  aa   775656 7100 04	tra  	-1106,ic		000427
						STATEMENT 1 ON LINE 589
     end create_control_point_switches;

BEGIN PROCEDURE attach_syn
ENTRY TO attach_syn                                         STATEMENT 1 ON LINE 500
attach_syn:
     procedure (p_switch_name, p_target_switch_name, p_inhibits, p_switch_iocb);

002552  aa  6 00214 6501 00	spri4	pr6|140
002553  aa  6 00216 2521 00	spri2	pr6|142
002554  aa  2 00002 3521 01	epp2 	pr2|2,au
002555  aa  6 00220 2521 00	spri2	pr6|144
002556  aa  2 00000 2361 20	ldq  	pr2|0,*
002557  aa   000002 6040 04	tmi  	2,ic		002561
002560  aa   777777 3760 07	anq  	262143,dl
002561  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002562  aa  6 00612 7561 00	stq  	pr6|394
002563  aa  2 00002 2361 20	ldq  	pr2|2,*
002564  aa   000002 6040 04	tmi  	2,ic		002566
002565  aa   777777 3760 07	anq  	262143,dl
002566  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002567  aa  6 00613 7561 00	stq  	pr6|395
002570  aa  2 00004 2361 20	ldq  	pr2|4,*
002571  aa   000002 6040 04	tmi  	2,ic		002573
002572  aa   777777 3760 07	anq  	262143,dl
002573  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002574  aa  6 00614 7561 00	stq  	pr6|396
						STATEMENT 1 ON LINE 512
	switch_name = id_string;

002575  aa   000014 2360 07	ldq  	12,dl
002576  aa  6 00222 7561 00	stq  	pr6|146		switch_name
002577  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002600  aa  6 00172 00 0006	desc9a	pr6|122,ql	id_string
002601  aa  6 00223 00 0006	desc9a	pr6|147,ql	switch_name
						STATEMENT 1 ON LINE 513
	switch_name = switch_name || ".";

002602  aa  6 00222 2361 00	ldq  	pr6|146		switch_name
002603  aa   000040 1160 07	cmpq 	32,dl
002604  aa   000005 6050 04	tpl  	5,ic		002611
002605  aa  6 00222 0541 00	aos  	pr6|146		switch_name
002606  aa  040 106 100 404	mlr  	(ic),(pr,ql),fill(040)
002607  aa   002272 00 0001	desc9a	1210,1		005100 = 056000000000
002610  aa  6 00223 00 0001	desc9a	pr6|147,1		switch_name
						STATEMENT 1 ON LINE 514
	switch_name = switch_name || p_switch_name;

002611  aa  6 00216 3735 20	epp7 	pr6|142,*
002612  aa  7 00002 3715 20	epp5 	pr7|2,*
002613  aa   000040 2360 07	ldq  	32,dl
002614  aa  6 00222 1761 00	sbq  	pr6|146		switch_name
002615  aa  6 00612 1161 00	cmpq 	pr6|394
002616  aa   000002 6040 04	tmi  	2,ic		002620
002617  aa  6 00612 2361 00	ldq  	pr6|394
002620  aa  6 00222 7271 00	lxl7 	pr6|146		switch_name
002621  aa  6 00222 0561 00	asq  	pr6|146		switch_name
002622  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
002623  aa  5 00000 00 0006	desc9a	pr5|0,ql		p_switch_name
002624  aa  6 00223 00 0006	desc9a	pr6|147,ql	switch_name
						STATEMENT 1 ON LINE 516
	attach_description = "syn_ ";

002625  aa   775221 2370 04	ldaq 	-1391,ic		000046 = 163171156137 040000000000
002626  aa  6 00234 7571 00	staq 	pr6|156		attach_description
002627  aa   000005 2360 07	ldq  	5,dl
002630  aa  6 00233 7561 00	stq  	pr6|155		attach_description
						STATEMENT 1 ON LINE 517
	attach_description = attach_description || p_target_switch_name;

002631  aa  7 00004 3535 20	epp3 	pr7|4,*
002632  aa   000200 2360 07	ldq  	128,dl
002633  aa  6 00233 1761 00	sbq  	pr6|155		attach_description
002634  aa  6 00613 1161 00	cmpq 	pr6|395
002635  aa   000002 6040 04	tmi  	2,ic		002637
002636  aa  6 00613 2361 00	ldq  	pr6|395
002637  aa  6 00233 7271 00	lxl7 	pr6|155		attach_description
002640  aa  6 00233 0561 00	asq  	pr6|155		attach_description
002641  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
002642  aa  3 00000 00 0006	desc9a	pr3|0,ql		p_target_switch_name
002643  aa  6 00234 00 0006	desc9a	pr6|156,ql	attach_description
						STATEMENT 1 ON LINE 518
	attach_description = attach_description || " -inhibit close ";

002644  aa   000200 2360 07	ldq  	128,dl
002645  aa  6 00233 1761 00	sbq  	pr6|155		attach_description
002646  aa   000020 1160 07	cmpq 	16,dl
002647  aa   000002 6040 04	tmi  	2,ic		002651
002650  aa   000020 2360 07	ldq  	16,dl
002651  aa  6 00233 7271 00	lxl7 	pr6|155		attach_description
002652  aa  6 00233 0561 00	asq  	pr6|155		attach_description
002653  aa  040 157 100 444	mlr  	(rl,ic),(pr,rl,x7),fill(040)
002654  aa   775242 00 0006	desc9a	-1374,ql		000115 = 040055151156
002655  aa  6 00234 00 0006	desc9a	pr6|156,ql	attach_description
						STATEMENT 1 ON LINE 519
	if p_inhibits ^= ""
	then attach_description = attach_description || p_inhibits;

002656  aa  7 00006 3515 20	epp1 	pr7|6,*
002657  aa  6 00614 2351 00	lda  	pr6|396
002660  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
002661  aa  1 00000 00 0005	desc9a	pr1|0,al		p_inhibits
002662  aa   002220 00 0000	desc9a	1168,0		005100 = 056000000000
002663  aa   000013 6000 04	tze  	11,ic		002676
002664  aa   000200 2360 07	ldq  	128,dl
002665  aa  6 00233 1761 00	sbq  	pr6|155		attach_description
002666  aa  6 00614 1161 00	cmpq 	pr6|396
002667  aa   000002 6040 04	tmi  	2,ic		002671
002670  aa  6 00614 2361 00	ldq  	pr6|396
002671  aa  6 00233 7271 00	lxl7 	pr6|155		attach_description
002672  aa  6 00233 0561 00	asq  	pr6|155		attach_description
002673  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
002674  aa  1 00000 00 0006	desc9a	pr1|0,ql		p_inhibits
002675  aa  6 00234 00 0006	desc9a	pr6|156,ql	attach_description
						STATEMENT 1 ON LINE 522
	call iox_$attach_name ((switch_name), p_switch_iocb, (attach_description), null (), code);

002676  aa  6 00222 2361 00	ldq  	pr6|146		switch_name
002677  aa   524000 2760 03	orq  	174080,du
002700  aa  6 00615 7561 00	stq  	pr6|397
002701  aa  6 00233 2361 00	ldq  	pr6|155		attach_description
002702  aa   524000 2760 03	orq  	174080,du
002703  aa  6 00616 7561 00	stq  	pr6|398
002704  aa  6 00222 2361 00	ldq  	pr6|146		switch_name
002705  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002706  aa  6 00630 2521 00	spri2	pr6|408
002707  aa  6 00222 7271 00	lxl7 	pr6|146		switch_name
002710  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002711  aa  6 00223 00 0017	desc9a	pr6|147,x7	switch_name
002712  aa  2 00000 00 0006	desc9a	pr2|0,ql
002713  aa  6 00233 2361 00	ldq  	pr6|155		attach_description
002714  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002715  aa  6 00634 2521 00	spri2	pr6|412
002716  aa  6 00233 7271 00	lxl7 	pr6|155		attach_description
002717  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
002720  aa  6 00234 00 0017	desc9a	pr6|156,x7	attach_description
002721  aa  2 00000 00 0006	desc9a	pr2|0,ql
002722  aa   775132 3714 24	epp5 	-1446,ic*
002723  aa  6 00624 6515 00	spri5	pr6|404
002724  aa  7 00010 3521 20	epp2 	pr7|8,*		p_switch_iocb
002725  aa  6 00632 2521 00	spri2	pr6|410
002726  aa  6 00624 3521 00	epp2 	pr6|404
002727  aa  6 00636 2521 00	spri2	pr6|414
002730  aa  6 00211 3521 00	epp2 	pr6|137		code
002731  aa  6 00640 2521 00	spri2	pr6|416
002732  aa  6 00615 3521 00	epp2 	pr6|397
002733  aa  6 00642 2521 00	spri2	pr6|418
002734  aa   775107 3520 04	epp2 	-1465,ic		000043 = 464000000000
002735  aa  6 00644 2521 00	spri2	pr6|420
002736  aa  6 00650 2521 00	spri2	pr6|424
002737  aa  6 00616 3521 00	epp2 	pr6|398
002740  aa  6 00646 2521 00	spri2	pr6|422
002741  aa   775054 3520 04	epp2 	-1492,ic		000015 = 404000000043
002742  aa  6 00652 2521 00	spri2	pr6|426
002743  aa  6 00626 6211 00	eax1 	pr6|406
002744  aa   024000 4310 07	fld  	10240,dl
002745  aa  6 00044 3701 20	epp4 	pr6|36,*
002746  la  4 00144 3521 20	epp2 	pr4|100,*		iox_$attach_name
002747  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 523
	if code ^= 0
	then call attach_failure (switch_name, attach_description, code);

002750  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002751  aa  6 00211 2361 00	ldq  	pr6|137		code
002752  aa   000004 6000 04	tze  	4,ic		002756
002753  aa   001755 3520 04	epp2 	1005,ic		004730 = 000006000000
002754  aa  2 00000 2351 00	lda  	pr2|0
002755  aa   000076 6700 04	tsp4 	62,ic		003053
						STATEMENT 1 ON LINE 526
	return;

002756  aa  6 00214 6101 00	rtcd 	pr6|140
						STATEMENT 1 ON LINE 528
     end attach_syn;

  END PROCEDURE attach_syn
BEGIN PROCEDURE attach_failure_nonvarying
ENTRY TO attach_failure_nonvarying                          STATEMENT 1 ON LINE 543
attach_failure_nonvarying:				/* ... with nonvarying parameters */
     procedure (p_switch_name, p_attach_desc, p_code);

002757  aa  6 00274 6501 00	spri4	pr6|188
002760  aa  6 00276 2521 00	spri2	pr6|190
002761  aa  2 00002 3521 01	epp2 	pr2|2,au
002762  aa  6 00300 2521 00	spri2	pr6|192
002763  aa  2 00000 2361 20	ldq  	pr2|0,*
002764  aa   000002 6040 04	tmi  	2,ic		002766
002765  aa   777777 3760 07	anq  	262143,dl
002766  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002767  aa  6 00654 7561 00	stq  	pr6|428
002770  aa  2 00002 2361 20	ldq  	pr2|2,*
002771  aa   000002 6040 04	tmi  	2,ic		002773
002772  aa   777777 3760 07	anq  	262143,dl
002773  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002774  aa  6 00655 7561 00	stq  	pr6|429
						STATEMENT 1 ON LINE 550
	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0,
	     "Trying to attach ^a using the attach description -^/^-^a", p_switch_name, p_attach_desc);

002775  aa   775057 3734 24	epp7 	-1489,ic*
002776  aa  6 00656 6535 00	spri7	pr6|430
002777  aa  6 00660 4501 00	stz  	pr6|432
003000  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003001  aa   775166 00 0070	desc9a	-1418,56		000166 = 124162171151
003002  aa  6 00662 00 0070	desc9a	pr6|434,56
003003  aa  6 00276 3715 20	epp5 	pr6|190,*
003004  aa  5 00006 3521 20	epp2 	pr5|6,*		p_code
003005  aa  6 00702 2521 00	spri2	pr6|450
003006  aa  6 00044 3701 20	epp4 	pr6|36,*
003007  la  4 00122 3521 20	epp2 	pr4|82,*		cpm_data_$subsystem_name
003010  aa  6 00704 2521 00	spri2	pr6|452
003011  aa   774767 3520 04	epp2 	-1545,ic		000000 = 200000000000
003012  aa  6 00706 2521 00	spri2	pr6|454
003013  aa  6 00656 3521 00	epp2 	pr6|430
003014  aa  6 00710 2521 00	spri2	pr6|456
003015  aa  6 00660 3521 00	epp2 	pr6|432
003016  aa  6 00712 2521 00	spri2	pr6|458
003017  aa  6 00662 3521 00	epp2 	pr6|434
003020  aa  6 00714 2521 00	spri2	pr6|460
003021  aa  5 00002 3521 20	epp2 	pr5|2,*		p_switch_name
003022  aa  6 00716 2521 00	spri2	pr6|462
003023  aa  5 00004 3521 20	epp2 	pr5|4,*		p_attach_desc
003024  aa  6 00720 2521 00	spri2	pr6|464
003025  aa   774770 3520 04	epp2 	-1544,ic		000015 = 404000000043
003026  aa  6 00722 2521 00	spri2	pr6|466
003027  aa   775006 3520 04	epp2 	-1530,ic		000035 = 526000000040
003030  aa  6 00724 2521 00	spri2	pr6|468
003031  aa   775007 3520 04	epp2 	-1529,ic		000040 = 514000000044
003032  aa  6 00726 2521 00	spri2	pr6|470
003033  aa   775010 3520 04	epp2 	-1528,ic		000043 = 464000000000
003034  aa  6 00730 2521 00	spri2	pr6|472
003035  aa   774763 3520 04	epp2 	-1549,ic		000020 = 404000000005
003036  aa  6 00732 2521 00	spri2	pr6|474
003037  aa   774744 3520 04	epp2 	-1564,ic		000003 = 524000000070
003040  aa  6 00734 2521 00	spri2	pr6|476
003041  aa  6 00300 3535 20	epp3 	pr6|192,*
003042  aa  3 00000 3521 20	epp2 	pr3|0,*
003043  aa  6 00736 2521 00	spri2	pr6|478
003044  aa  3 00002 3521 20	epp2 	pr3|2,*
003045  aa  6 00740 2521 00	spri2	pr6|480
003046  aa  6 00700 6211 00	eax1 	pr6|448
003047  aa   040000 4310 07	fld  	16384,dl
003050  la  4 00064 3521 20	epp2 	pr4|52,*		sub_err_
003051  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 553
	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;

003052  aa   777362 7100 04	tra  	-270,ic		002434
						STATEMENT 1 ON LINE 555
     end attach_failure_nonvarying;

  END PROCEDURE attach_failure_nonvarying
BEGIN PROCEDURE attach_failure_varying
ENTRY TO attach_failure_varying                             STATEMENT 1 ON LINE 558
attach_failure_varying:				/* ... with varying parameters */
     procedure (p_switch_name, p_attach_desc, p_code);

003053  aa  6 00302 6501 00	spri4	pr6|194
003054  aa  6 00304 2521 00	spri2	pr6|196
003055  aa  2 00002 3521 01	epp2 	pr2|2,au
003056  aa  6 00306 2521 00	spri2	pr6|198
003057  aa  2 00000 2361 20	ldq  	pr2|0,*
003060  aa   000002 6040 04	tmi  	2,ic		003062
003061  aa   777777 3760 07	anq  	262143,dl
003062  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003063  aa  6 00742 7561 00	stq  	pr6|482
003064  aa  2 00002 2361 20	ldq  	pr2|2,*
003065  aa   000002 6040 04	tmi  	2,ic		003067
003066  aa   777777 3760 07	anq  	262143,dl
003067  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003070  aa  6 00743 7561 00	stq  	pr6|483
						STATEMENT 1 ON LINE 565
	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0,
	     "Trying to attach ^a using the attach description -^/^-^a", p_switch_name, p_attach_desc);

003071  aa   774763 3734 24	epp7 	-1549,ic*
003072  aa  6 00744 6535 00	spri7	pr6|484
003073  aa  6 00746 4501 00	stz  	pr6|486
003074  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003075  aa   775072 00 0070	desc9a	-1478,56		000166 = 124162171151
003076  aa  6 00750 00 0070	desc9a	pr6|488,56
003077  aa  6 00304 3715 20	epp5 	pr6|196,*
003100  aa  5 00006 3521 20	epp2 	pr5|6,*		p_code
003101  aa  6 00770 2521 00	spri2	pr6|504
003102  aa  6 00044 3701 20	epp4 	pr6|36,*
003103  la  4 00122 3521 20	epp2 	pr4|82,*		cpm_data_$subsystem_name
003104  aa  6 00772 2521 00	spri2	pr6|506
003105  aa   774673 3520 04	epp2 	-1605,ic		000000 = 200000000000
003106  aa  6 00774 2521 00	spri2	pr6|508
003107  aa  6 00744 3521 00	epp2 	pr6|484
003110  aa  6 00776 2521 00	spri2	pr6|510
003111  aa  6 00746 3521 00	epp2 	pr6|486
003112  aa  6 01000 2521 00	spri2	pr6|512
003113  aa  6 00750 3521 00	epp2 	pr6|488
003114  aa  6 01002 2521 00	spri2	pr6|514
003115  aa  5 00002 3521 20	epp2 	pr5|2,*		p_switch_name
003116  aa  6 01004 2521 00	spri2	pr6|516
003117  aa  5 00004 3521 20	epp2 	pr5|4,*		p_attach_desc
003120  aa  6 01006 2521 00	spri2	pr6|518
003121  aa   774674 3520 04	epp2 	-1604,ic		000015 = 404000000043
003122  aa  6 01010 2521 00	spri2	pr6|520
003123  aa   774712 3520 04	epp2 	-1590,ic		000035 = 526000000040
003124  aa  6 01012 2521 00	spri2	pr6|522
003125  aa   774713 3520 04	epp2 	-1589,ic		000040 = 514000000044
003126  aa  6 01014 2521 00	spri2	pr6|524
003127  aa   774714 3520 04	epp2 	-1588,ic		000043 = 464000000000
003130  aa  6 01016 2521 00	spri2	pr6|526
003131  aa   774667 3520 04	epp2 	-1609,ic		000020 = 404000000005
003132  aa  6 01020 2521 00	spri2	pr6|528
003133  aa   774650 3520 04	epp2 	-1624,ic		000003 = 524000000070
003134  aa  6 01022 2521 00	spri2	pr6|530
003135  aa  6 00306 3535 20	epp3 	pr6|198,*
003136  aa  3 00000 3521 20	epp2 	pr3|0,*
003137  aa  6 01024 2521 00	spri2	pr6|532
003140  aa  3 00002 3521 20	epp2 	pr3|2,*
003141  aa  6 01026 2521 00	spri2	pr6|534
003142  aa  6 00766 6211 00	eax1 	pr6|502
003143  aa   040000 4310 07	fld  	16384,dl
003144  la  4 00064 3521 20	epp2 	pr4|52,*		sub_err_
003145  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 568
	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;

003146  aa   777266 7100 04	tra  	-330,ic		002434
						STATEMENT 1 ON LINE 570
     end attach_failure_varying;

  END PROCEDURE attach_failure_varying
BEGIN PROCEDURE open_failure
ENTRY TO open_failure                                       STATEMENT 1 ON LINE 576
open_failure:					/* ... while trying to open a switch */
     procedure (p_switch_name, p_code);

003147  aa  6 00310 6501 00	spri4	pr6|200
003150  aa  6 00312 2521 00	spri2	pr6|202
003151  aa  2 00002 3521 01	epp2 	pr2|2,au
003152  aa  6 00314 2521 00	spri2	pr6|204
003153  aa  2 00000 2361 20	ldq  	pr2|0,*
003154  aa   000002 6040 04	tmi  	2,ic		003156
003155  aa   777777 3760 07	anq  	262143,dl
003156  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003157  aa  6 01030 7561 00	stq  	pr6|536
						STATEMENT 1 ON LINE 582
	call sub_err_ (p_code, cpm_data_$subsystem_name, ACTION_DEFAULT_RESTART, null (), 0, "Trying to open ^a.",
	     p_switch_name);

003160  aa   774674 3734 24	epp7 	-1604,ic*
003161  aa  6 01032 6535 00	spri7	pr6|538
003162  aa  6 01031 4501 00	stz  	pr6|537
003163  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003164  aa   774756 00 0024	desc9a	-1554,20		000141 = 124162171151
003165  aa  6 01034 00 0024	desc9a	pr6|540,20
003166  aa  6 00312 3715 20	epp5 	pr6|202,*
003167  aa  5 00004 3521 20	epp2 	pr5|4,*		p_code
003170  aa  6 01044 2521 00	spri2	pr6|548
003171  aa  6 00044 3701 20	epp4 	pr6|36,*
003172  la  4 00122 3521 20	epp2 	pr4|82,*		cpm_data_$subsystem_name
003173  aa  6 01046 2521 00	spri2	pr6|550
003174  aa   774604 3520 04	epp2 	-1660,ic		000000 = 200000000000
003175  aa  6 01050 2521 00	spri2	pr6|552
003176  aa  6 01032 3521 00	epp2 	pr6|538
003177  aa  6 01052 2521 00	spri2	pr6|554
003200  aa  6 01031 3521 00	epp2 	pr6|537
003201  aa  6 01054 2521 00	spri2	pr6|556
003202  aa  6 01034 3521 00	epp2 	pr6|540
003203  aa  6 01056 2521 00	spri2	pr6|558
003204  aa  5 00002 3521 20	epp2 	pr5|2,*		p_switch_name
003205  aa  6 01060 2521 00	spri2	pr6|560
003206  aa   774607 3520 04	epp2 	-1657,ic		000015 = 404000000043
003207  aa  6 01062 2521 00	spri2	pr6|562
003210  aa   774625 3520 04	epp2 	-1643,ic		000035 = 526000000040
003211  aa  6 01064 2521 00	spri2	pr6|564
003212  aa   774626 3520 04	epp2 	-1642,ic		000040 = 514000000044
003213  aa  6 01066 2521 00	spri2	pr6|566
003214  aa   774627 3520 04	epp2 	-1641,ic		000043 = 464000000000
003215  aa  6 01070 2521 00	spri2	pr6|568
003216  aa   774602 3520 04	epp2 	-1662,ic		000020 = 404000000005
003217  aa  6 01072 2521 00	spri2	pr6|570
003220  aa   774567 3520 04	epp2 	-1673,ic		000007 = 524000000022
003221  aa  6 01074 2521 00	spri2	pr6|572
003222  aa  6 00314 3535 20	epp3 	pr6|204,*
003223  aa  3 00000 3521 20	epp2 	pr3|0,*
003224  aa  6 01076 2521 00	spri2	pr6|574
003225  aa  6 01042 6211 00	eax1 	pr6|546
003226  aa   034000 4310 07	fld  	14336,dl
003227  la  4 00064 3521 20	epp2 	pr4|52,*		sub_err_
003230  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 585
	go to ERROR_RETURN_FROM_CREATE_CONTROL_POINT_SWITCHES;

003231  aa   777203 7100 04	tra  	-381,ic		002434
						STATEMENT 1 ON LINE 587
     end open_failure;

  END PROCEDURE open_failure
  END PROCEDURE create_control_point_switches
BEGIN PROCEDURE destroy_control_point_switches
ENTRY TO destroy_control_point_switches                     STATEMENT 1 ON LINE 593
destroy_control_point_switches:
     procedure (p_old_mask);

003232  aa  6 00316 6501 00	spri4	pr6|206
003233  aa  6 00320 2521 00	spri2	pr6|208
						STATEMENT 1 ON LINE 601
	call unmask_ips_interrupts (p_old_mask);

003234  aa  2 00002 3521 20	epp2 	pr2|2,*		p_old_mask
003235  aa  6 01102 2521 00	spri2	pr6|578
003236  aa  6 01100 3521 00	epp2 	pr6|576
003237  aa   004000 4310 07	fld  	2048,dl
003240  aa  2 00000 7571 00	staq 	pr2|0
003241  aa   001427 6700 04	tsp4 	791,ic		004670
						STATEMENT 1 ON LINE 603
	if parent_control_point_data.swapped_switches	/* revert to our parent's switches or the root's if swapped */
	then call swap_switches (cpd_ptr, addr (cpm_data_$root_control_point_data), control_point_data.swapped_switches,
		"1"b, "1"b);

003242  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
003243  aa  7 00016 3715 20	epp5 	pr7|14,*		control_point_data.parent
003244  aa  5 00003 2351 00	lda  	pr5|3		parent_control_point_data.swapped_switches
003245  aa   200000 3150 03	cana 	65536,du
003246  aa   000030 6000 04	tze  	24,ic		003276
003247  aa  6 00044 3701 20	epp4 	pr6|36,*
003250  la  4 00124 3535 20	epp3 	pr4|84,*		cpm_data_$root_control_point_data
003251  aa  6 01106 2535 00	spri3	pr6|582
003252  aa   400000 2350 03	lda  	131072,du
003253  aa  6 01110 7551 00	sta  	pr6|584
003254  aa  6 01111 7551 00	sta  	pr6|585
003255  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
003256  aa  6 01114 2521 00	spri2	pr6|588
003257  aa  6 01106 3521 00	epp2 	pr6|582
003260  aa  6 01116 2521 00	spri2	pr6|590
003261  aa   000001 7270 07	lxl7 	1,dl
003262  aa  7 00003 3521 00	epp2 	pr7|3		control_point_data.swapped_switches
003263  aa  2 00000 5035 17	abd  	pr2|0,7
003264  aa  6 01120 2521 00	spri2	pr6|592
003265  aa  6 01110 3521 00	epp2 	pr6|584
003266  aa  6 01122 2521 00	spri2	pr6|594
003267  aa  6 01111 3521 00	epp2 	pr6|585
003270  aa  6 01124 2521 00	spri2	pr6|596
003271  aa  6 01112 3521 00	epp2 	pr6|586
003272  aa   024000 4310 07	fld  	10240,dl
003273  aa  2 00000 7571 00	staq 	pr2|0
003274  aa   000170 6700 04	tsp4 	120,ic		003464
003275  aa   000025 7100 04	tra  	21,ic		003322
						STATEMENT 1 ON LINE 606
	else call swap_switches (cpd_ptr, control_point_data.parent, control_point_data.swapped_switches, "0"b, "1"b);

003276  aa   000000 2350 07	lda  	0,dl
003277  aa  6 01111 7551 00	sta  	pr6|585
003300  aa   400000 2350 03	lda  	131072,du
003301  aa  6 01110 7551 00	sta  	pr6|584
003302  aa  6 00122 3521 00	epp2 	pr6|82		cpd_ptr
003303  aa  6 01114 2521 00	spri2	pr6|588
003304  aa  7 00016 3521 00	epp2 	pr7|14		control_point_data.parent
003305  aa  6 01116 2521 00	spri2	pr6|590
003306  aa   000001 7270 07	lxl7 	1,dl
003307  aa  7 00003 3521 00	epp2 	pr7|3		control_point_data.swapped_switches
003310  aa  2 00000 5035 17	abd  	pr2|0,7
003311  aa  6 01120 2521 00	spri2	pr6|592
003312  aa  6 01111 3521 00	epp2 	pr6|585
003313  aa  6 01122 2521 00	spri2	pr6|594
003314  aa  6 01110 3521 00	epp2 	pr6|584
003315  aa  6 01124 2521 00	spri2	pr6|596
003316  aa  6 01112 3521 00	epp2 	pr6|586
003317  aa   024000 4310 07	fld  	10240,dl
003320  aa  2 00000 7571 00	staq 	pr2|0
003321  aa   000143 6700 04	tsp4 	99,ic		003464
						STATEMENT 1 ON LINE 608
	local_io_switches = control_point_data.io_switches;

003322  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
003323  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003324  aa  7 00066 00 0040	desc9a	pr7|54,32		control_point_data.io_switches
003325  aa  6 00324 00 0040	desc9a	pr6|212,32	local_io_switches
						STATEMENT 1 ON LINE 611
	control_point_data.group_id = parent_control_point_data.group_id;

003326  aa  7 00016 3715 20	epp5 	pr7|14,*		control_point_data.parent
003327  aa  5 00001 2351 00	lda  	pr5|1		parent_control_point_data.group_id
003330  aa  7 00001 7551 00	sta  	pr7|1		control_point_data.group_id
						STATEMENT 1 ON LINE 612
	control_point_data.io_switches = parent_control_point_data.io_switches;

003331  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003332  aa  5 00066 00 0040	desc9a	pr5|54,32		parent_control_point_data.io_switches
003333  aa  7 00066 00 0040	desc9a	pr7|54,32		control_point_data.io_switches
						STATEMENT 1 ON LINE 615
	call mask_ips_interrupts (control_point_data.ips_mask, p_old_mask);

003334  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
003335  aa  7 00060 3521 00	epp2 	pr7|48		control_point_data.ips_mask
003336  aa  6 01114 2521 00	spri2	pr6|588
003337  aa  6 00320 3535 20	epp3 	pr6|208,*
003340  aa  3 00002 3521 20	epp2 	pr3|2,*		p_old_mask
003341  aa  6 01116 2521 00	spri2	pr6|590
003342  aa  6 01112 3521 00	epp2 	pr6|586
003343  aa   010000 4310 07	fld  	4096,dl
003344  aa  2 00000 7571 00	staq 	pr2|0
003345  aa   001306 6700 04	tsp4 	710,ic		004653
						STATEMENT 1 ON LINE 617
	do an_iocb_ptr = local_io_switches.user_input, local_io_switches.user_output, local_io_switches.error_output;

003346  aa   000035 3520 04	epp2 	29,ic		003403 = 000005352004
003347  aa  6 00336 2521 00	spri2	pr6|222
003350  aa  6 00326 3735 20	epp7 	pr6|214,*		local_io_switches.user_input
003351  aa  6 00334 6535 00	spri7	pr6|220		an_iocb_ptr
						STATEMENT 1 ON LINE 618
	     if an_iocb_ptr ^= null ()
	     then do;

003352  aa  6 00334 2371 00	ldaq 	pr6|220		an_iocb_ptr
003353  aa   774501 6770 04	eraq 	-1727,ic		000054 = 077777000043 000001000000
003354  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003355  aa   000025 6000 04	tze  	21,ic		003402
						STATEMENT 1 ON LINE 620
		     call iox_$detach_iocb (an_iocb_ptr, (0));

003356  aa  6 01110 4501 00	stz  	pr6|584
003357  aa  6 00334 3521 00	epp2 	pr6|220		an_iocb_ptr
003360  aa  6 01102 2521 00	spri2	pr6|578
003361  aa  6 01110 3521 00	epp2 	pr6|584
003362  aa  6 01104 2521 00	spri2	pr6|580
003363  aa  6 01100 6211 00	eax1 	pr6|576
003364  aa   010000 4310 07	fld  	4096,dl
003365  aa  6 00044 3701 20	epp4 	pr6|36,*
003366  la  4 00154 3521 20	epp2 	pr4|108,*		iox_$detach_iocb
003367  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 621
		     call iox_$destroy_iocb (an_iocb_ptr, (0));

003370  aa  6 01110 4501 00	stz  	pr6|584
003371  aa  6 00334 3521 00	epp2 	pr6|220		an_iocb_ptr
003372  aa  6 01102 2521 00	spri2	pr6|578
003373  aa  6 01110 3521 00	epp2 	pr6|584
003374  aa  6 01104 2521 00	spri2	pr6|580
003375  aa  6 01100 6211 00	eax1 	pr6|576
003376  aa   010000 4310 07	fld  	4096,dl
003377  aa  6 00044 3701 20	epp4 	pr6|36,*
003400  la  4 00152 3521 20	epp2 	pr4|106,*		iox_$destroy_iocb
003401  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 622
		end;

						STATEMENT 1 ON LINE 623
	end;

003402  aa  6 00336 7101 20	tra  	pr6|222,*
003403  aa   000005 3520 04	epp2 	5,ic		003410 = 000005352004
003404  aa  6 00336 2521 00	spri2	pr6|222
003405  aa  6 00330 3735 20	epp7 	pr6|216,*		local_io_switches.user_output
003406  aa  6 00334 6535 00	spri7	pr6|220		an_iocb_ptr
003407  aa   777743 7100 04	tra  	-29,ic		003352
003410  aa   000005 3520 04	epp2 	5,ic		003415 = 600324237100
003411  aa  6 00336 2521 00	spri2	pr6|222
003412  aa  6 00332 3735 20	epp7 	pr6|218,*		local_io_switches.error_output
003413  aa  6 00334 6535 00	spri7	pr6|220		an_iocb_ptr
003414  aa   777736 7100 04	tra  	-34,ic		003352
						STATEMENT 1 ON LINE 625
	if local_io_switches.user_io ^= null ()
	then do;

003415  aa  6 00324 2371 00	ldaq 	pr6|212		local_io_switches.user_io
003416  aa   774436 6770 04	eraq 	-1762,ic		000054 = 077777000043 000001000000
003417  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003420  aa   000043 6000 04	tze  	35,ic		003463
						STATEMENT 1 ON LINE 627
		if create_control_point_info.user_io_attach_desc_given
		then call iox_$close (local_io_switches.user_io, (0));

003421  aa  6 00124 3735 20	epp7 	pr6|84,*		ccpi_ptr
003422  aa  7 00035 2351 00	lda  	pr7|29		create_control_point_info.user_io_attach_desc_given
003423  aa   100000 3150 03	cana 	32768,du
003424  aa   000013 6000 04	tze  	11,ic		003437
003425  aa  6 01110 4501 00	stz  	pr6|584
003426  aa  6 00324 3521 00	epp2 	pr6|212		local_io_switches.user_io
003427  aa  6 01102 2521 00	spri2	pr6|578
003430  aa  6 01110 3521 00	epp2 	pr6|584
003431  aa  6 01104 2521 00	spri2	pr6|580
003432  aa  6 01100 6211 00	eax1 	pr6|576
003433  aa   010000 4310 07	fld  	4096,dl
003434  aa  6 00044 3701 20	epp4 	pr6|36,*
003435  la  4 00146 3521 20	epp2 	pr4|102,*		iox_$close
003436  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 629
		call iox_$detach_iocb (local_io_switches.user_io, (0));

003437  aa  6 01110 4501 00	stz  	pr6|584
003440  aa  6 00324 3521 00	epp2 	pr6|212		local_io_switches.user_io
003441  aa  6 01102 2521 00	spri2	pr6|578
003442  aa  6 01110 3521 00	epp2 	pr6|584
003443  aa  6 01104 2521 00	spri2	pr6|580
003444  aa  6 01100 6211 00	eax1 	pr6|576
003445  aa   010000 4310 07	fld  	4096,dl
003446  aa  6 00044 3701 20	epp4 	pr6|36,*
003447  la  4 00154 3521 20	epp2 	pr4|108,*		iox_$detach_iocb
003450  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 630
		call iox_$destroy_iocb (local_io_switches.user_io, (0));

003451  aa  6 01110 4501 00	stz  	pr6|584
003452  aa  6 00324 3521 00	epp2 	pr6|212		local_io_switches.user_io
003453  aa  6 01102 2521 00	spri2	pr6|578
003454  aa  6 01110 3521 00	epp2 	pr6|584
003455  aa  6 01104 2521 00	spri2	pr6|580
003456  aa  6 01100 6211 00	eax1 	pr6|576
003457  aa   010000 4310 07	fld  	4096,dl
003460  aa  6 00044 3701 20	epp4 	pr6|36,*
003461  la  4 00152 3521 20	epp2 	pr4|106,*		iox_$destroy_iocb
003462  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 631
	     end;

						STATEMENT 1 ON LINE 633
	return;

003463  aa  6 00316 6101 00	rtcd 	pr6|206
						STATEMENT 1 ON LINE 635
     end destroy_control_point_switches;

  END PROCEDURE destroy_control_point_switches
BEGIN PROCEDURE swap_switches
ENTRY TO swap_switches                                      STATEMENT 1 ON LINE 654
swap_switches:
     procedure (p_old_cpd_ptr, p_new_cpd_ptr, p_cpd_swapped_switches, p_new_swapped_switches_setting, p_caller_is_masked);

003464  aa  6 00340 6501 00	spri4	pr6|224
003465  aa  6 00342 2521 00	spri2	pr6|226
						STATEMENT 1 ON LINE 670
	if old_cpd.group_id = new_cpd.group_id		/* they are using the same switches: this is a no-op */
	then return;

003466  aa  2 00002 3735 20	epp7 	pr2|2,*		p_old_cpd_ptr
003467  aa  7 00000 3735 20	epp7 	pr7|0,*		p_old_cpd_ptr
003470  aa  7 00001 2351 00	lda  	pr7|1		old_cpd.group_id
003471  aa  2 00004 3715 20	epp5 	pr2|4,*		p_new_cpd_ptr
003472  aa  5 00000 3715 20	epp5 	pr5|0,*		p_new_cpd_ptr
003473  aa  5 00001 1151 00	cmpa 	pr5|1		new_cpd.group_id
003474  aa   000002 6010 04	tnz  	2,ic		003476
003475  aa  6 00340 6101 00	rtcd 	pr6|224
						STATEMENT 1 ON LINE 673
	if ^p_caller_is_masked			/* prevent interrupts while playing with the switches */
	then call mask_ips_interrupts (""b, old_mask);

003476  aa  2 00012 2351 20	lda  	pr2|10,*		p_caller_is_masked
003477  aa   400000 3150 03	cana 	131072,du
003500  aa   000005 6010 04	tnz  	5,ic		003505
003501  aa   000000 2350 07	lda  	0,dl
003502  aa  6 01130 7551 00	sta  	pr6|600
003503  aa   001217 3520 04	epp2 	655,ic		004722 = 000004000000
003504  aa   001147 6700 04	tsp4 	615,ic		004653
						STATEMENT 1 ON LINE 676
	call iox_$move_attach (iox_$user_io, old_cpd.io_switches.user_io, (0));

003505  aa  6 01130 4501 00	stz  	pr6|600
003506  aa  6 00044 3701 20	epp4 	pr6|36,*
003507  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
003510  aa  6 01134 2521 00	spri2	pr6|604
003511  aa  6 00342 3735 20	epp7 	pr6|226,*
003512  aa  7 00002 3715 20	epp5 	pr7|2,*		p_old_cpd_ptr
003513  aa  5 00000 3715 20	epp5 	pr5|0,*		p_old_cpd_ptr
003514  aa  5 00066 3521 00	epp2 	pr5|54		old_cpd.user_io
003515  aa  6 01136 2521 00	spri2	pr6|606
003516  aa  6 01130 3521 00	epp2 	pr6|600
003517  aa  6 01140 2521 00	spri2	pr6|608
003520  aa  6 01132 6211 00	eax1 	pr6|602
003521  aa   014000 4310 07	fld  	6144,dl
003522  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003523  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 677
	call iox_$move_attach (iox_$user_input, old_cpd.io_switches.user_input, (0));

003524  aa  6 01130 4501 00	stz  	pr6|600
003525  aa  6 00044 3701 20	epp4 	pr6|36,*
003526  la  4 00164 3521 20	epp2 	pr4|116,*		iox_$user_input
003527  aa  6 01134 2521 00	spri2	pr6|604
003530  aa  6 00342 3735 20	epp7 	pr6|226,*
003531  aa  7 00002 3715 20	epp5 	pr7|2,*		p_old_cpd_ptr
003532  aa  5 00000 3715 20	epp5 	pr5|0,*		p_old_cpd_ptr
003533  aa  5 00070 3521 00	epp2 	pr5|56		old_cpd.user_input
003534  aa  6 01136 2521 00	spri2	pr6|606
003535  aa  6 01130 3521 00	epp2 	pr6|600
003536  aa  6 01140 2521 00	spri2	pr6|608
003537  aa  6 01132 6211 00	eax1 	pr6|602
003540  aa   014000 4310 07	fld  	6144,dl
003541  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003542  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 678
	call iox_$move_attach (iox_$user_output, old_cpd.io_switches.user_output, (0));

003543  aa  6 01130 4501 00	stz  	pr6|600
003544  aa  6 00044 3701 20	epp4 	pr6|36,*
003545  la  4 00162 3521 20	epp2 	pr4|114,*		iox_$user_output
003546  aa  6 01134 2521 00	spri2	pr6|604
003547  aa  6 00342 3735 20	epp7 	pr6|226,*
003550  aa  7 00002 3715 20	epp5 	pr7|2,*		p_old_cpd_ptr
003551  aa  5 00000 3715 20	epp5 	pr5|0,*		p_old_cpd_ptr
003552  aa  5 00072 3521 00	epp2 	pr5|58		old_cpd.user_output
003553  aa  6 01136 2521 00	spri2	pr6|606
003554  aa  6 01130 3521 00	epp2 	pr6|600
003555  aa  6 01140 2521 00	spri2	pr6|608
003556  aa  6 01132 6211 00	eax1 	pr6|602
003557  aa   014000 4310 07	fld  	6144,dl
003560  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003561  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 679
	call iox_$move_attach (iox_$error_output, old_cpd.io_switches.error_output, (0));

003562  aa  6 01130 4501 00	stz  	pr6|600
003563  aa  6 00044 3701 20	epp4 	pr6|36,*
003564  la  4 00170 3521 20	epp2 	pr4|120,*		iox_$error_output
003565  aa  6 01134 2521 00	spri2	pr6|604
003566  aa  6 00342 3735 20	epp7 	pr6|226,*
003567  aa  7 00002 3715 20	epp5 	pr7|2,*		p_old_cpd_ptr
003570  aa  5 00000 3715 20	epp5 	pr5|0,*		p_old_cpd_ptr
003571  aa  5 00074 3521 00	epp2 	pr5|60		old_cpd.error_output
003572  aa  6 01136 2521 00	spri2	pr6|606
003573  aa  6 01130 3521 00	epp2 	pr6|600
003574  aa  6 01140 2521 00	spri2	pr6|608
003575  aa  6 01132 6211 00	eax1 	pr6|602
003576  aa   014000 4310 07	fld  	6144,dl
003577  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003600  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 681
	call iox_$move_attach (new_cpd.io_switches.user_io, iox_$user_io, (0));

003601  aa  6 01130 4501 00	stz  	pr6|600
003602  aa  6 00342 3735 20	epp7 	pr6|226,*
003603  aa  7 00004 3715 20	epp5 	pr7|4,*		p_new_cpd_ptr
003604  aa  5 00000 3715 20	epp5 	pr5|0,*		p_new_cpd_ptr
003605  aa  5 00066 3521 00	epp2 	pr5|54		new_cpd.user_io
003606  aa  6 01134 2521 00	spri2	pr6|604
003607  aa  6 00044 3701 20	epp4 	pr6|36,*
003610  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
003611  aa  6 01136 2521 00	spri2	pr6|606
003612  aa  6 01130 3521 00	epp2 	pr6|600
003613  aa  6 01140 2521 00	spri2	pr6|608
003614  aa  6 01132 6211 00	eax1 	pr6|602
003615  aa   014000 4310 07	fld  	6144,dl
003616  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003617  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 682
	call iox_$move_attach (new_cpd.io_switches.user_input, iox_$user_input, (0));

003620  aa  6 01130 4501 00	stz  	pr6|600
003621  aa  6 00342 3735 20	epp7 	pr6|226,*
003622  aa  7 00004 3715 20	epp5 	pr7|4,*		p_new_cpd_ptr
003623  aa  5 00000 3715 20	epp5 	pr5|0,*		p_new_cpd_ptr
003624  aa  5 00070 3521 00	epp2 	pr5|56		new_cpd.user_input
003625  aa  6 01134 2521 00	spri2	pr6|604
003626  aa  6 00044 3701 20	epp4 	pr6|36,*
003627  la  4 00164 3521 20	epp2 	pr4|116,*		iox_$user_input
003630  aa  6 01136 2521 00	spri2	pr6|606
003631  aa  6 01130 3521 00	epp2 	pr6|600
003632  aa  6 01140 2521 00	spri2	pr6|608
003633  aa  6 01132 6211 00	eax1 	pr6|602
003634  aa   014000 4310 07	fld  	6144,dl
003635  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003636  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 683
	call iox_$move_attach (new_cpd.io_switches.user_output, iox_$user_output, (0));

003637  aa  6 01130 4501 00	stz  	pr6|600
003640  aa  6 00342 3735 20	epp7 	pr6|226,*
003641  aa  7 00004 3715 20	epp5 	pr7|4,*		p_new_cpd_ptr
003642  aa  5 00000 3715 20	epp5 	pr5|0,*		p_new_cpd_ptr
003643  aa  5 00072 3521 00	epp2 	pr5|58		new_cpd.user_output
003644  aa  6 01134 2521 00	spri2	pr6|604
003645  aa  6 00044 3701 20	epp4 	pr6|36,*
003646  la  4 00162 3521 20	epp2 	pr4|114,*		iox_$user_output
003647  aa  6 01136 2521 00	spri2	pr6|606
003650  aa  6 01130 3521 00	epp2 	pr6|600
003651  aa  6 01140 2521 00	spri2	pr6|608
003652  aa  6 01132 6211 00	eax1 	pr6|602
003653  aa   014000 4310 07	fld  	6144,dl
003654  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003655  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 684
	call iox_$move_attach (new_cpd.io_switches.error_output, iox_$error_output, (0));

003656  aa  6 01130 4501 00	stz  	pr6|600
003657  aa  6 00342 3735 20	epp7 	pr6|226,*
003660  aa  7 00004 3715 20	epp5 	pr7|4,*		p_new_cpd_ptr
003661  aa  5 00000 3715 20	epp5 	pr5|0,*		p_new_cpd_ptr
003662  aa  5 00074 3521 00	epp2 	pr5|60		new_cpd.error_output
003663  aa  6 01134 2521 00	spri2	pr6|604
003664  aa  6 00044 3701 20	epp4 	pr6|36,*
003665  la  4 00170 3521 20	epp2 	pr4|120,*		iox_$error_output
003666  aa  6 01136 2521 00	spri2	pr6|606
003667  aa  6 01130 3521 00	epp2 	pr6|600
003670  aa  6 01140 2521 00	spri2	pr6|608
003671  aa  6 01132 6211 00	eax1 	pr6|602
003672  aa   014000 4310 07	fld  	6144,dl
003673  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
003674  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 686
	p_cpd_swapped_switches = p_new_swapped_switches_setting;

003675  aa  6 00342 3735 20	epp7 	pr6|226,*
003676  aa  7 00006 3715 20	epp5 	pr7|6,*
003677  aa  7 00010 3535 20	epp3 	pr7|8,*
003700  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003701  aa  3 00000 00 0001	descb	pr3|0,1		p_new_swapped_switches_setting
003702  aa  5 00000 00 0001	descb	pr5|0,1		p_cpd_swapped_switches
						STATEMENT 1 ON LINE 688
	if ^p_caller_is_masked			/* it's safe now */
	then call unmask_ips_interrupts (old_mask);

003703  aa  7 00012 2351 20	lda  	pr7|10,*		p_caller_is_masked
003704  aa   400000 3150 03	cana 	131072,du
003705  aa   000003 6010 04	tnz  	3,ic		003710
003706  aa   001166 3520 04	epp2 	630,ic		005074 = 000002000000
003707  aa   000761 6700 04	tsp4 	497,ic		004670
						STATEMENT 1 ON LINE 691
	return;

003710  aa  6 00340 6101 00	rtcd 	pr6|224
						STATEMENT 1 ON LINE 693
     end swap_switches;

  END PROCEDURE swap_switches
BEGIN PROCEDURE issue_start_orders
ENTRY TO issue_start_orders                                 STATEMENT 1 ON LINE 720
issue_start_orders:
     procedure ();

003711  aa  6 00346 6501 00	spri4	pr6|230
						STATEMENT 1 ON LINE 723
	call iox_$control (iox_$user_io, "start", null (), (0));

003712  aa   774132 2370 04	ldaq 	-1958,ic		000044 = 163164141162 164000000000
003713  aa  6 01142 7571 00	staq 	pr6|610
003714  aa   774140 3734 24	epp7 	-1952,ic*
003715  aa  6 01144 6535 00	spri7	pr6|612
003716  aa  6 01146 4501 00	stz  	pr6|614
003717  aa  6 00044 3701 20	epp4 	pr6|36,*
003720  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
003721  aa  6 01152 2521 00	spri2	pr6|618
003722  aa  6 01142 3521 00	epp2 	pr6|610
003723  aa  6 01154 2521 00	spri2	pr6|620
003724  aa  6 01144 3521 00	epp2 	pr6|612
003725  aa  6 01156 2521 00	spri2	pr6|622
003726  aa  6 01146 3521 00	epp2 	pr6|614
003727  aa  6 01160 2521 00	spri2	pr6|624
003730  aa   774113 3520 04	epp2 	-1973,ic		000043 = 464000000000
003731  aa  6 01162 2521 00	spri2	pr6|626
003732  aa  6 01166 2521 00	spri2	pr6|630
003733  aa   774046 3520 04	epp2 	-2010,ic		000001 = 524000000005
003734  aa  6 01164 2521 00	spri2	pr6|628
003735  aa   774060 3520 04	epp2 	-2000,ic		000015 = 404000000043
003736  aa  6 01170 2521 00	spri2	pr6|632
003737  aa  6 01150 6211 00	eax1 	pr6|616
003740  aa   020000 4310 07	fld  	8192,dl
003741  la  4 00150 3521 20	epp2 	pr4|104,*		iox_$control
003742  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 725
	if control_point_data.swapped_switches		/* user_i/o above is the root's: must also start our's */
	then call iox_$control (control_point_data.user_io, "start", null (), (0));

003743  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
003744  aa  7 00003 2351 00	lda  	pr7|3		control_point_data.swapped_switches
003745  aa   200000 3150 03	cana 	65536,du
003746  aa   000033 6000 04	tze  	27,ic		004001
003747  aa   774075 2370 04	ldaq 	-1987,ic		000044 = 163164141162 164000000000
003750  aa  6 01144 7571 00	staq 	pr6|612
003751  aa   774103 3714 24	epp5 	-1981,ic*
003752  aa  6 01142 6515 00	spri5	pr6|610
003753  aa  6 01146 4501 00	stz  	pr6|614
003754  aa  7 00066 3521 00	epp2 	pr7|54		control_point_data.user_io
003755  aa  6 01152 2521 00	spri2	pr6|618
003756  aa  6 01144 3521 00	epp2 	pr6|612
003757  aa  6 01154 2521 00	spri2	pr6|620
003760  aa  6 01142 3521 00	epp2 	pr6|610
003761  aa  6 01156 2521 00	spri2	pr6|622
003762  aa  6 01146 3521 00	epp2 	pr6|614
003763  aa  6 01160 2521 00	spri2	pr6|624
003764  aa   774057 3520 04	epp2 	-2001,ic		000043 = 464000000000
003765  aa  6 01162 2521 00	spri2	pr6|626
003766  aa  6 01166 2521 00	spri2	pr6|630
003767  aa   774012 3520 04	epp2 	-2038,ic		000001 = 524000000005
003770  aa  6 01164 2521 00	spri2	pr6|628
003771  aa   774024 3520 04	epp2 	-2028,ic		000015 = 404000000043
003772  aa  6 01170 2521 00	spri2	pr6|632
003773  aa  6 01150 6211 00	eax1 	pr6|616
003774  aa   020000 4310 07	fld  	8192,dl
003775  aa  6 00044 3701 20	epp4 	pr6|36,*
003776  la  4 00150 3521 20	epp2 	pr4|104,*		iox_$control
003777  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004000  aa   000036 7100 04	tra  	30,ic		004036
						STATEMENT 1 ON LINE 728
	else					/* user_i/o above was our's: check the root's */
	     if control_point_data.group_id ^= cpm_data_$root_control_point_data.group_id
	then call iox_$control (cpm_data_$root_control_point_data.user_io, "start", null (), (0));

004001  aa  7 00001 2351 00	lda  	pr7|1		control_point_data.group_id
004002  aa  6 00044 3701 20	epp4 	pr6|36,*
004003  la  4 00124 3715 20	epp5 	pr4|84,*
004004  aa  5 00001 1151 00	cmpa 	pr5|1		cpm_data_$root_control_point_data.group_id
004005  aa   000031 6000 04	tze  	25,ic		004036
004006  aa   774036 2370 04	ldaq 	-2018,ic		000044 = 163164141162 164000000000
004007  aa  6 01142 7571 00	staq 	pr6|610
004010  aa   774044 3534 24	epp3 	-2012,ic*
004011  aa  6 01144 2535 00	spri3	pr6|612
004012  aa  6 01146 4501 00	stz  	pr6|614
004013  aa  5 00066 3521 00	epp2 	pr5|54		cpm_data_$root_control_point_data.user_io
004014  aa  6 01152 2521 00	spri2	pr6|618
004015  aa  6 01142 3521 00	epp2 	pr6|610
004016  aa  6 01154 2521 00	spri2	pr6|620
004017  aa  6 01144 3521 00	epp2 	pr6|612
004020  aa  6 01156 2521 00	spri2	pr6|622
004021  aa  6 01146 3521 00	epp2 	pr6|614
004022  aa  6 01160 2521 00	spri2	pr6|624
004023  aa   774020 3520 04	epp2 	-2032,ic		000043 = 464000000000
004024  aa  6 01162 2521 00	spri2	pr6|626
004025  aa  6 01166 2521 00	spri2	pr6|630
004026  aa   773753 3520 04	epp2 	-2069,ic		000001 = 524000000005
004027  aa  6 01164 2521 00	spri2	pr6|628
004030  aa   773765 3520 04	epp2 	-2059,ic		000015 = 404000000043
004031  aa  6 01170 2521 00	spri2	pr6|632
004032  aa  6 01150 6211 00	eax1 	pr6|616
004033  aa   020000 4310 07	fld  	8192,dl
004034  la  4 00150 3521 20	epp2 	pr4|104,*		iox_$control
004035  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 732
	return;

004036  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 734
     end issue_start_orders;

  END PROCEDURE issue_start_orders
BEGIN PROCEDURE issue_root_start_order
ENTRY TO issue_root_start_order                             STATEMENT 1 ON LINE 755
issue_root_start_order:
     procedure ();

004037  aa  6 00354 6501 00	spri4	pr6|236
						STATEMENT 1 ON LINE 758
	if different_switches (cpd_ptr, addr (cpm_data_$root_control_point_data))
	then call iox_$control (cpm_data_$root_control_point_data.user_io, "start", null (), (0));

004040  aa  6 00044 3701 20	epp4 	pr6|36,*
004041  la  4 00124 3735 20	epp7 	pr4|84,*		cpm_data_$root_control_point_data
004042  aa  6 01172 6535 00	spri7	pr6|634
004043  aa   000647 3520 04	epp2 	423,ic		004712 = 000006000000
004044  aa   000245 6700 04	tsp4 	165,ic		004311
004045  aa  6 01174 2351 00	lda  	pr6|636
004046  aa   400000 3150 03	cana 	131072,du
004047  aa   000034 6000 04	tze  	28,ic		004103
004050  aa   773774 2370 04	ldaq 	-2052,ic		000044 = 163164141162 164000000000
004051  aa  6 01172 7571 00	staq 	pr6|634
004052  aa   774002 3734 24	epp7 	-2046,ic*
004053  aa  6 01176 6535 00	spri7	pr6|638
004054  aa  6 01175 4501 00	stz  	pr6|637
004055  aa  6 00044 3701 20	epp4 	pr6|36,*
004056  la  4 00124 3715 20	epp5 	pr4|84,*
004057  aa  5 00066 3521 00	epp2 	pr5|54		cpm_data_$root_control_point_data.user_io
004060  aa  6 01202 2521 00	spri2	pr6|642
004061  aa  6 01172 3521 00	epp2 	pr6|634
004062  aa  6 01204 2521 00	spri2	pr6|644
004063  aa  6 01176 3521 00	epp2 	pr6|638
004064  aa  6 01206 2521 00	spri2	pr6|646
004065  aa  6 01175 3521 00	epp2 	pr6|637
004066  aa  6 01210 2521 00	spri2	pr6|648
004067  aa   773754 3520 04	epp2 	-2068,ic		000043 = 464000000000
004070  aa  6 01212 2521 00	spri2	pr6|650
004071  aa  6 01216 2521 00	spri2	pr6|654
004072  aa   773707 3520 04	epp2 	-2105,ic		000001 = 524000000005
004073  aa  6 01214 2521 00	spri2	pr6|652
004074  aa   773721 3520 04	epp2 	-2095,ic		000015 = 404000000043
004075  aa  6 01220 2521 00	spri2	pr6|656
004076  aa  6 01200 6211 00	eax1 	pr6|640
004077  aa   020000 4310 07	fld  	8192,dl
004100  la  4 00150 3521 20	epp2 	pr4|104,*		iox_$control
004101  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004102  aa   000032 7100 04	tra  	26,ic		004134
						STATEMENT 1 ON LINE 761
	else call iox_$control (iox_$user_io, "start", null (), (0));

004103  aa   773741 2370 04	ldaq 	-2079,ic		000044 = 163164141162 164000000000
004104  aa  6 01176 7571 00	staq 	pr6|638
004105  aa   773747 3734 24	epp7 	-2073,ic*
004106  aa  6 01172 6535 00	spri7	pr6|634
004107  aa  6 01175 4501 00	stz  	pr6|637
004110  aa  6 00044 3701 20	epp4 	pr6|36,*
004111  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
004112  aa  6 01202 2521 00	spri2	pr6|642
004113  aa  6 01176 3521 00	epp2 	pr6|638
004114  aa  6 01204 2521 00	spri2	pr6|644
004115  aa  6 01172 3521 00	epp2 	pr6|634
004116  aa  6 01206 2521 00	spri2	pr6|646
004117  aa  6 01175 3521 00	epp2 	pr6|637
004120  aa  6 01210 2521 00	spri2	pr6|648
004121  aa   773722 3520 04	epp2 	-2094,ic		000043 = 464000000000
004122  aa  6 01212 2521 00	spri2	pr6|650
004123  aa  6 01216 2521 00	spri2	pr6|654
004124  aa   773655 3520 04	epp2 	-2131,ic		000001 = 524000000005
004125  aa  6 01214 2521 00	spri2	pr6|652
004126  aa   773667 3520 04	epp2 	-2121,ic		000015 = 404000000043
004127  aa  6 01220 2521 00	spri2	pr6|656
004130  aa  6 01200 6211 00	eax1 	pr6|640
004131  aa   020000 4310 07	fld  	8192,dl
004132  la  4 00150 3521 20	epp2 	pr4|104,*		iox_$control
004133  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 764
	return;

004134  aa  6 00354 6101 00	rtcd 	pr6|236
						STATEMENT 1 ON LINE 766
     end issue_root_start_order;

  END PROCEDURE issue_root_start_order
BEGIN PROCEDURE restore_io_switches
ENTRY TO restore_io_switches                                STATEMENT 1 ON LINE 784
restore_io_switches:
     procedure ();

004135  aa  6 00362 6501 00	spri4	pr6|242
						STATEMENT 1 ON LINE 787
	call iox_$move_attach (control_point_data.user_io, iox_$user_io, (0));

004136  aa  6 01222 4501 00	stz  	pr6|658
004137  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004140  aa  7 00066 3521 00	epp2 	pr7|54		control_point_data.user_io
004141  aa  6 01226 2521 00	spri2	pr6|662
004142  aa  6 00044 3701 20	epp4 	pr6|36,*
004143  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
004144  aa  6 01230 2521 00	spri2	pr6|664
004145  aa  6 01222 3521 00	epp2 	pr6|658
004146  aa  6 01232 2521 00	spri2	pr6|666
004147  aa  6 01224 6211 00	eax1 	pr6|660
004150  aa   014000 4310 07	fld  	6144,dl
004151  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004152  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 788
	call iox_$move_attach (control_point_data.user_input, iox_$user_input, (0));

004153  aa  6 01222 4501 00	stz  	pr6|658
004154  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004155  aa  7 00070 3521 00	epp2 	pr7|56		control_point_data.user_input
004156  aa  6 01226 2521 00	spri2	pr6|662
004157  aa  6 00044 3701 20	epp4 	pr6|36,*
004160  la  4 00164 3521 20	epp2 	pr4|116,*		iox_$user_input
004161  aa  6 01230 2521 00	spri2	pr6|664
004162  aa  6 01222 3521 00	epp2 	pr6|658
004163  aa  6 01232 2521 00	spri2	pr6|666
004164  aa  6 01224 6211 00	eax1 	pr6|660
004165  aa   014000 4310 07	fld  	6144,dl
004166  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004167  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 789
	call iox_$move_attach (control_point_data.user_output, iox_$user_output, (0));

004170  aa  6 01222 4501 00	stz  	pr6|658
004171  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004172  aa  7 00072 3521 00	epp2 	pr7|58		control_point_data.user_output
004173  aa  6 01226 2521 00	spri2	pr6|662
004174  aa  6 00044 3701 20	epp4 	pr6|36,*
004175  la  4 00162 3521 20	epp2 	pr4|114,*		iox_$user_output
004176  aa  6 01230 2521 00	spri2	pr6|664
004177  aa  6 01222 3521 00	epp2 	pr6|658
004200  aa  6 01232 2521 00	spri2	pr6|666
004201  aa  6 01224 6211 00	eax1 	pr6|660
004202  aa   014000 4310 07	fld  	6144,dl
004203  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004204  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 790
	call iox_$move_attach (control_point_data.error_output, iox_$error_output, (0));

004205  aa  6 01222 4501 00	stz  	pr6|658
004206  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004207  aa  7 00074 3521 00	epp2 	pr7|60		control_point_data.error_output
004210  aa  6 01226 2521 00	spri2	pr6|662
004211  aa  6 00044 3701 20	epp4 	pr6|36,*
004212  la  4 00170 3521 20	epp2 	pr4|120,*		iox_$error_output
004213  aa  6 01230 2521 00	spri2	pr6|664
004214  aa  6 01222 3521 00	epp2 	pr6|658
004215  aa  6 01232 2521 00	spri2	pr6|666
004216  aa  6 01224 6211 00	eax1 	pr6|660
004217  aa   014000 4310 07	fld  	6144,dl
004220  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004221  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 792
	return;

004222  aa  6 00362 6101 00	rtcd 	pr6|242
						STATEMENT 1 ON LINE 794
     end restore_io_switches;

  END PROCEDURE restore_io_switches
BEGIN PROCEDURE save_io_switches
ENTRY TO save_io_switches                                   STATEMENT 1 ON LINE 800
save_io_switches:
     procedure ();

004223  aa  6 00370 6501 00	spri4	pr6|248
						STATEMENT 1 ON LINE 803
	call iox_$move_attach (iox_$user_io, control_point_data.user_io, (0));

004224  aa  6 01234 4501 00	stz  	pr6|668
004225  aa  6 00044 3701 20	epp4 	pr6|36,*
004226  la  4 00166 3521 20	epp2 	pr4|118,*		iox_$user_io
004227  aa  6 01240 2521 00	spri2	pr6|672
004230  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004231  aa  7 00066 3521 00	epp2 	pr7|54		control_point_data.user_io
004232  aa  6 01242 2521 00	spri2	pr6|674
004233  aa  6 01234 3521 00	epp2 	pr6|668
004234  aa  6 01244 2521 00	spri2	pr6|676
004235  aa  6 01236 6211 00	eax1 	pr6|670
004236  aa   014000 4310 07	fld  	6144,dl
004237  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004240  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 804
	call iox_$move_attach (iox_$user_input, control_point_data.user_input, (0));

004241  aa  6 01234 4501 00	stz  	pr6|668
004242  aa  6 00044 3701 20	epp4 	pr6|36,*
004243  la  4 00164 3521 20	epp2 	pr4|116,*		iox_$user_input
004244  aa  6 01240 2521 00	spri2	pr6|672
004245  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004246  aa  7 00070 3521 00	epp2 	pr7|56		control_point_data.user_input
004247  aa  6 01242 2521 00	spri2	pr6|674
004250  aa  6 01234 3521 00	epp2 	pr6|668
004251  aa  6 01244 2521 00	spri2	pr6|676
004252  aa  6 01236 6211 00	eax1 	pr6|670
004253  aa   014000 4310 07	fld  	6144,dl
004254  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004255  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 805
	call iox_$move_attach (iox_$user_output, control_point_data.user_output, (0));

004256  aa  6 01234 4501 00	stz  	pr6|668
004257  aa  6 00044 3701 20	epp4 	pr6|36,*
004260  la  4 00162 3521 20	epp2 	pr4|114,*		iox_$user_output
004261  aa  6 01240 2521 00	spri2	pr6|672
004262  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004263  aa  7 00072 3521 00	epp2 	pr7|58		control_point_data.user_output
004264  aa  6 01242 2521 00	spri2	pr6|674
004265  aa  6 01234 3521 00	epp2 	pr6|668
004266  aa  6 01244 2521 00	spri2	pr6|676
004267  aa  6 01236 6211 00	eax1 	pr6|670
004270  aa   014000 4310 07	fld  	6144,dl
004271  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004272  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 806
	call iox_$move_attach (iox_$error_output, control_point_data.error_output, (0));

004273  aa  6 01234 4501 00	stz  	pr6|668
004274  aa  6 00044 3701 20	epp4 	pr6|36,*
004275  la  4 00170 3521 20	epp2 	pr4|120,*		iox_$error_output
004276  aa  6 01240 2521 00	spri2	pr6|672
004277  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004300  aa  7 00074 3521 00	epp2 	pr7|60		control_point_data.error_output
004301  aa  6 01242 2521 00	spri2	pr6|674
004302  aa  6 01234 3521 00	epp2 	pr6|668
004303  aa  6 01244 2521 00	spri2	pr6|676
004304  aa  6 01236 6211 00	eax1 	pr6|670
004305  aa   014000 4310 07	fld  	6144,dl
004306  la  4 00156 3521 20	epp2 	pr4|110,*		iox_$move_attach
004307  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 808
	return;

004310  aa  6 00370 6101 00	rtcd 	pr6|248
						STATEMENT 1 ON LINE 810
     end save_io_switches;

  END PROCEDURE save_io_switches
BEGIN PROCEDURE different_switches
ENTRY TO different_switches                                 STATEMENT 1 ON LINE 816
different_switches:
     procedure (p_cpd_1_ptr, p_cpd_2_ptr) returns (bit (1) aligned);

004311  aa  6 00376 6501 00	spri4	pr6|254
004312  aa  6 00400 2521 00	spri2	pr6|256
						STATEMENT 1 ON LINE 824
	if cpd_1.swapped_switches & cpd_2.swapped_switches
	then return ("0"b);

004313  aa  2 00002 3735 20	epp7 	pr2|2,*		p_cpd_1_ptr
004314  aa  7 00000 3735 20	epp7 	pr7|0,*		p_cpd_1_ptr
004315  aa  7 00003 2351 00	lda  	pr7|3		cpd_1.swapped_switches
004316  aa   000001 7350 00	als  	1
004317  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
004320  aa  6 01246 7551 00	sta  	pr6|678		cpd_1.swapped_switches
004321  aa  2 00004 3715 20	epp5 	pr2|4,*		p_cpd_2_ptr
004322  aa  5 00000 3715 20	epp5 	pr5|0,*		p_cpd_2_ptr
004323  aa  5 00003 2351 00	lda  	pr5|3		cpd_2.swapped_switches
004324  aa   000001 7350 00	als  	1
004325  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
004326  aa  6 01247 7551 00	sta  	pr6|679		cpd_2.swapped_switches
004327  aa   000005 6000 04	tze  	5,ic		004334
004330  aa  6 01246 2351 00	lda  	pr6|678		cpd_1.swapped_switches
004331  aa   000003 6000 04	tze  	3,ic		004334
004332  aa  2 00006 4501 20	stz  	pr2|6,*
004333  aa  6 00376 6101 00	rtcd 	pr6|254
						STATEMENT 1 ON LINE 827
	else if cpd_1.group_id = cpd_2.group_id		/* same group: they use the same switches ... */
	then return (cpd_1.swapped_switches ^= cpd_2.swapped_switches);

004334  aa  7 00001 2351 00	lda  	pr7|1		cpd_1.group_id
004335  aa  5 00001 1151 00	cmpa 	pr5|1		cpd_2.group_id
004336  aa   000006 6010 04	tnz  	6,ic		004344
004337  aa  6 01246 2351 00	lda  	pr6|678		cpd_1.swapped_switches
004340  aa  6 01247 1151 00	cmpa 	pr6|679		cpd_2.swapped_switches
004341  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
004342  aa  2 00006 7551 20	sta  	pr2|6,*
004343  aa  6 00376 6101 00	rtcd 	pr6|254
						STATEMENT 1 ON LINE 831
	else if (cpd_1.swapped_switches & (cpd_2.group_id = cpm_data_$root_control_point_data.group_id))
	     | (cpd_2.swapped_switches & (cpd_1.group_id = cpm_data_$root_control_point_data.group_id))
	then return ("0"b);

004344  aa  6 01246 2351 00	lda  	pr6|678		cpd_1.swapped_switches
004345  aa   000006 6000 04	tze  	6,ic		004353
004346  aa  5 00001 2351 00	lda  	pr5|1		cpd_2.group_id
004347  aa  6 00044 3701 20	epp4 	pr6|36,*
004350  la  4 00124 3535 20	epp3 	pr4|84,*
004351  aa  3 00001 1151 00	cmpa 	pr3|1		cpm_data_$root_control_point_data.group_id
004352  aa   000010 6000 04	tze  	8,ic		004362
004353  aa  6 01247 2351 00	lda  	pr6|679		cpd_2.swapped_switches
004354  aa   000010 6000 04	tze  	8,ic		004364
004355  aa  7 00001 2351 00	lda  	pr7|1		cpd_1.group_id
004356  aa  6 00044 3701 20	epp4 	pr6|36,*
004357  la  4 00124 3535 20	epp3 	pr4|84,*
004360  aa  3 00001 1151 00	cmpa 	pr3|1		cpm_data_$root_control_point_data.group_id
004361  aa   000003 6010 04	tnz  	3,ic		004364
004362  aa  2 00006 4501 20	stz  	pr2|6,*
004363  aa  6 00376 6101 00	rtcd 	pr6|254
						STATEMENT 1 ON LINE 835
	else return ("1"b);

004364  aa   400000 2350 03	lda  	131072,du
004365  aa  2 00006 7551 20	sta  	pr2|6,*
004366  aa  6 00376 6101 00	rtcd 	pr6|254
						STATEMENT 1 ON LINE 837
     end different_switches;

  END PROCEDURE different_switches
BEGIN PROCEDURE restore_privileges
ENTRY TO restore_privileges                                 STATEMENT 1 ON LINE 843
restore_privileges:
     procedure ();

004367  aa  6 00404 6501 00	spri4	pr6|260
						STATEMENT 1 ON LINE 848
	current_privileges = get_privileges_ ();

004370  aa  6 00412 3521 00	epp2 	pr6|266		current_privileges
004371  aa  6 01252 2521 00	spri2	pr6|682
004372  aa  6 01250 6211 00	eax1 	pr6|680
004373  aa   004000 4310 07	fld  	2048,dl
004374  aa  6 00044 3701 20	epp4 	pr6|36,*
004375  la  4 00050 3521 20	epp2 	pr4|40,*		get_privileges_
004376  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 850
	if control_point_data.privileges = current_privileges
	then return;

004377  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004400  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004401  aa  6 00412 1151 00	cmpa 	pr6|266		current_privileges
004402  aa   000002 6010 04	tnz  	2,ic		004404
004403  aa  6 00404 6101 00	rtcd 	pr6|260
						STATEMENT 1 ON LINE 853
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$comm_privilege
	then if control_point_data.privileges & sys_info$comm_privilege
	     then call system_privilege_$comm_priv_on ((0));

004404  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004405  aa  6 00044 3701 20	epp4 	pr6|36,*
004406  la  4 00010 3151 20	cana 	pr4|8,*		sys_info$comm_privilege
004407  aa   000023 6000 04	tze  	19,ic		004432
004410  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004411  la  4 00010 3151 20	cana 	pr4|8,*		sys_info$comm_privilege
004412  aa   000011 6000 04	tze  	9,ic		004423
004413  aa  6 01254 4501 00	stz  	pr6|684
004414  aa  6 01254 3521 00	epp2 	pr6|684
004415  aa  6 01252 2521 00	spri2	pr6|682
004416  aa  6 01250 6211 00	eax1 	pr6|680
004417  aa   004000 4310 07	fld  	2048,dl
004420  la  4 00066 3521 20	epp2 	pr4|54,*		system_privilege_$comm_priv_on
004421  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004422  aa   000010 7100 04	tra  	8,ic		004432
						STATEMENT 1 ON LINE 856
	     else call system_privilege_$comm_priv_off ((0));

004423  aa  6 01254 4501 00	stz  	pr6|684
004424  aa  6 01254 3521 00	epp2 	pr6|684
004425  aa  6 01252 2521 00	spri2	pr6|682
004426  aa  6 01250 6211 00	eax1 	pr6|680
004427  aa   004000 4310 07	fld  	2048,dl
004430  la  4 00070 3521 20	epp2 	pr4|56,*		system_privilege_$comm_priv_off
004431  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 858
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$dir_privilege
	then if control_point_data.privileges & sys_info$dir_privilege
	     then call system_privilege_$dir_priv_on ((0));

004432  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004433  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004434  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004435  aa  6 00044 3701 20	epp4 	pr6|36,*
004436  la  4 00012 3151 20	cana 	pr4|10,*		sys_info$dir_privilege
004437  aa   000023 6000 04	tze  	19,ic		004462
004440  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004441  la  4 00012 3151 20	cana 	pr4|10,*		sys_info$dir_privilege
004442  aa   000011 6000 04	tze  	9,ic		004453
004443  aa  6 01254 4501 00	stz  	pr6|684
004444  aa  6 01254 3521 00	epp2 	pr6|684
004445  aa  6 01252 2521 00	spri2	pr6|682
004446  aa  6 01250 6211 00	eax1 	pr6|680
004447  aa   004000 4310 07	fld  	2048,dl
004450  la  4 00072 3521 20	epp2 	pr4|58,*		system_privilege_$dir_priv_on
004451  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004452  aa   000010 7100 04	tra  	8,ic		004462
						STATEMENT 1 ON LINE 861
	     else call system_privilege_$dir_priv_off ((0));

004453  aa  6 01254 4501 00	stz  	pr6|684
004454  aa  6 01254 3521 00	epp2 	pr6|684
004455  aa  6 01252 2521 00	spri2	pr6|682
004456  aa  6 01250 6211 00	eax1 	pr6|680
004457  aa   004000 4310 07	fld  	2048,dl
004460  la  4 00074 3521 20	epp2 	pr4|60,*		system_privilege_$dir_priv_off
004461  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 863
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$ipc_privilege
	then if control_point_data.privileges & sys_info$ipc_privilege
	     then call system_privilege_$ipc_priv_on ((0));

004462  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004463  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004464  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004465  aa  6 00044 3701 20	epp4 	pr6|36,*
004466  la  4 00014 3151 20	cana 	pr4|12,*		sys_info$ipc_privilege
004467  aa   000023 6000 04	tze  	19,ic		004512
004470  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004471  la  4 00014 3151 20	cana 	pr4|12,*		sys_info$ipc_privilege
004472  aa   000011 6000 04	tze  	9,ic		004503
004473  aa  6 01254 4501 00	stz  	pr6|684
004474  aa  6 01254 3521 00	epp2 	pr6|684
004475  aa  6 01252 2521 00	spri2	pr6|682
004476  aa  6 01250 6211 00	eax1 	pr6|680
004477  aa   004000 4310 07	fld  	2048,dl
004500  la  4 00076 3521 20	epp2 	pr4|62,*		system_privilege_$ipc_priv_on
004501  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004502  aa   000010 7100 04	tra  	8,ic		004512
						STATEMENT 1 ON LINE 866
	     else call system_privilege_$ipc_priv_off ((0));

004503  aa  6 01254 4501 00	stz  	pr6|684
004504  aa  6 01254 3521 00	epp2 	pr6|684
004505  aa  6 01252 2521 00	spri2	pr6|682
004506  aa  6 01250 6211 00	eax1 	pr6|680
004507  aa   004000 4310 07	fld  	2048,dl
004510  la  4 00100 3521 20	epp2 	pr4|64,*		system_privilege_$ipc_priv_off
004511  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 868
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$rcp_privilege
	then if control_point_data.privileges & sys_info$rcp_privilege
	     then call system_privilege_$rcp_priv_on ((0));

004512  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004513  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004514  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004515  aa  6 00044 3701 20	epp4 	pr6|36,*
004516  la  4 00016 3151 20	cana 	pr4|14,*		sys_info$rcp_privilege
004517  aa   000023 6000 04	tze  	19,ic		004542
004520  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004521  la  4 00016 3151 20	cana 	pr4|14,*		sys_info$rcp_privilege
004522  aa   000011 6000 04	tze  	9,ic		004533
004523  aa  6 01254 4501 00	stz  	pr6|684
004524  aa  6 01254 3521 00	epp2 	pr6|684
004525  aa  6 01252 2521 00	spri2	pr6|682
004526  aa  6 01250 6211 00	eax1 	pr6|680
004527  aa   004000 4310 07	fld  	2048,dl
004530  la  4 00102 3521 20	epp2 	pr4|66,*		system_privilege_$rcp_priv_on
004531  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004532  aa   000010 7100 04	tra  	8,ic		004542
						STATEMENT 1 ON LINE 871
	     else call system_privilege_$rcp_priv_off ((0));

004533  aa  6 01254 4501 00	stz  	pr6|684
004534  aa  6 01254 3521 00	epp2 	pr6|684
004535  aa  6 01252 2521 00	spri2	pr6|682
004536  aa  6 01250 6211 00	eax1 	pr6|680
004537  aa   004000 4310 07	fld  	2048,dl
004540  la  4 00104 3521 20	epp2 	pr4|68,*		system_privilege_$rcp_priv_off
004541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 873
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$ring1_privilege
	then if control_point_data.privileges & sys_info$ring1_privilege
	     then call system_privilege_$ring1_priv_on ((0));

004542  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004543  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004544  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004545  aa  6 00044 3701 20	epp4 	pr6|36,*
004546  la  4 00020 3151 20	cana 	pr4|16,*		sys_info$ring1_privilege
004547  aa   000023 6000 04	tze  	19,ic		004572
004550  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004551  la  4 00020 3151 20	cana 	pr4|16,*		sys_info$ring1_privilege
004552  aa   000011 6000 04	tze  	9,ic		004563
004553  aa  6 01254 4501 00	stz  	pr6|684
004554  aa  6 01254 3521 00	epp2 	pr6|684
004555  aa  6 01252 2521 00	spri2	pr6|682
004556  aa  6 01250 6211 00	eax1 	pr6|680
004557  aa   004000 4310 07	fld  	2048,dl
004560  la  4 00106 3521 20	epp2 	pr4|70,*		system_privilege_$ring1_priv_on
004561  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004562  aa   000010 7100 04	tra  	8,ic		004572
						STATEMENT 1 ON LINE 876
	     else call system_privilege_$ring1_priv_off ((0));

004563  aa  6 01254 4501 00	stz  	pr6|684
004564  aa  6 01254 3521 00	epp2 	pr6|684
004565  aa  6 01252 2521 00	spri2	pr6|682
004566  aa  6 01250 6211 00	eax1 	pr6|680
004567  aa   004000 4310 07	fld  	2048,dl
004570  la  4 00110 3521 20	epp2 	pr4|72,*		system_privilege_$ring1_priv_off
004571  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 878
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$seg_privilege
	then if control_point_data.privileges & sys_info$seg_privilege
	     then call system_privilege_$seg_priv_on ((0));

004572  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004573  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004574  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004575  aa  6 00044 3701 20	epp4 	pr6|36,*
004576  la  4 00022 3151 20	cana 	pr4|18,*		sys_info$seg_privilege
004577  aa   000023 6000 04	tze  	19,ic		004622
004600  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004601  la  4 00022 3151 20	cana 	pr4|18,*		sys_info$seg_privilege
004602  aa   000011 6000 04	tze  	9,ic		004613
004603  aa  6 01254 4501 00	stz  	pr6|684
004604  aa  6 01254 3521 00	epp2 	pr6|684
004605  aa  6 01252 2521 00	spri2	pr6|682
004606  aa  6 01250 6211 00	eax1 	pr6|680
004607  aa   004000 4310 07	fld  	2048,dl
004610  la  4 00112 3521 20	epp2 	pr4|74,*		system_privilege_$seg_priv_on
004611  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004612  aa   000010 7100 04	tra  	8,ic		004622
						STATEMENT 1 ON LINE 881
	     else call system_privilege_$seg_priv_off ((0));

004613  aa  6 01254 4501 00	stz  	pr6|684
004614  aa  6 01254 3521 00	epp2 	pr6|684
004615  aa  6 01252 2521 00	spri2	pr6|682
004616  aa  6 01250 6211 00	eax1 	pr6|680
004617  aa   004000 4310 07	fld  	2048,dl
004620  la  4 00114 3521 20	epp2 	pr4|76,*		system_privilege_$seg_priv_off
004621  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 883
	if bool (control_point_data.privileges, current_privileges, "0110"b) & sys_info$soos_privilege
	then if control_point_data.privileges & sys_info$soos_privilege
	     then call system_privilege_$soos_priv_on ((0));

004622  aa  6 00122 3735 20	epp7 	pr6|82,*		cpd_ptr
004623  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004624  aa  6 00412 6751 00	era  	pr6|266		current_privileges
004625  aa  6 00044 3701 20	epp4 	pr6|36,*
004626  la  4 00024 3151 20	cana 	pr4|20,*		sys_info$soos_privilege
004627  aa   000023 6000 04	tze  	19,ic		004652
004630  aa  7 00061 2351 00	lda  	pr7|49		control_point_data.privileges
004631  la  4 00024 3151 20	cana 	pr4|20,*		sys_info$soos_privilege
004632  aa   000011 6000 04	tze  	9,ic		004643
004633  aa  6 01254 4501 00	stz  	pr6|684
004634  aa  6 01254 3521 00	epp2 	pr6|684
004635  aa  6 01252 2521 00	spri2	pr6|682
004636  aa  6 01250 6211 00	eax1 	pr6|680
004637  aa   004000 4310 07	fld  	2048,dl
004640  la  4 00116 3521 20	epp2 	pr4|78,*		system_privilege_$soos_priv_on
004641  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
004642  aa   000010 7100 04	tra  	8,ic		004652
						STATEMENT 1 ON LINE 886
	     else call system_privilege_$soos_priv_off ((0));

004643  aa  6 01254 4501 00	stz  	pr6|684
004644  aa  6 01254 3521 00	epp2 	pr6|684
004645  aa  6 01252 2521 00	spri2	pr6|682
004646  aa  6 01250 6211 00	eax1 	pr6|680
004647  aa   004000 4310 07	fld  	2048,dl
004650  la  4 00120 3521 20	epp2 	pr4|80,*		system_privilege_$soos_priv_off
004651  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 888
	return;

004652  aa  6 00404 6101 00	rtcd 	pr6|260
						STATEMENT 1 ON LINE 890
     end restore_privileges;

  END PROCEDURE restore_privileges
BEGIN PROCEDURE mask_ips_interrupts
ENTRY TO mask_ips_interrupts                                STATEMENT 1 ON LINE 894
mask_ips_interrupts:
     procedure (p_new_mask, p_old_mask);

004653  aa  6 00414 6501 00	spri4	pr6|268
004654  aa  6 00416 2521 00	spri2	pr6|270
						STATEMENT 1 ON LINE 900
	call hcs_$set_ips_mask (p_new_mask, p_old_mask);

004655  aa  2 00002 3521 20	epp2 	pr2|2,*		p_new_mask
004656  aa  6 01260 2521 00	spri2	pr6|688
004657  aa  6 00416 3735 20	epp7 	pr6|270,*
004660  aa  7 00004 3521 20	epp2 	pr7|4,*		p_old_mask
004661  aa  6 01262 2521 00	spri2	pr6|690
004662  aa  6 01256 6211 00	eax1 	pr6|686
004663  aa   010000 4310 07	fld  	4096,dl
004664  aa  6 00044 3701 20	epp4 	pr6|36,*
004665  la  4 00056 3521 20	epp2 	pr4|46,*		hcs_$set_ips_mask
004666  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 902
     end mask_ips_interrupts;

004667  aa  6 00414 6101 00	rtcd 	pr6|268
  END PROCEDURE mask_ips_interrupts
BEGIN PROCEDURE unmask_ips_interrupts
ENTRY TO unmask_ips_interrupts                              STATEMENT 1 ON LINE 919
unmask_ips_interrupts:
     procedure (p_old_mask);

004670  aa  6 00422 6501 00	spri4	pr6|274
004671  aa  6 00424 2521 00	spri2	pr6|276
						STATEMENT 1 ON LINE 924
	if substr (p_old_mask, 36, 1) = "1"b
	then call hcs_$reset_ips_mask (p_old_mask, p_old_mask);

004672  aa  2 00002 2351 20	lda  	pr2|2,*		p_old_mask
004673  aa   000043 7350 00	als  	35
004674  aa   400000 1150 03	cmpa 	131072,du
004675  aa   000013 6010 04	tnz  	11,ic		004710
004676  aa  2 00002 3521 20	epp2 	pr2|2,*		p_old_mask
004677  aa  6 01266 2521 00	spri2	pr6|694
004700  aa  6 00424 3735 20	epp7 	pr6|276,*
004701  aa  7 00002 3521 20	epp2 	pr7|2,*		p_old_mask
004702  aa  6 01270 2521 00	spri2	pr6|696
004703  aa  6 01264 6211 00	eax1 	pr6|692
004704  aa   010000 4310 07	fld  	4096,dl
004705  aa  6 00044 3701 20	epp4 	pr6|36,*
004706  la  4 00054 3521 20	epp2 	pr4|44,*		hcs_$reset_ips_mask
004707  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 927
     end unmask_ips_interrupts;

004710  aa  6 00422 6101 00	rtcd 	pr6|274
  END PROCEDURE unmask_ips_interrupts
  END PROCEDURE cpm_overseer_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
