	COMPILATION LISTING OF SEGMENT dm_lock_status
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0934.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /*  DESCRIPTION:
        8*    Program to display the Data Management lock_seg. Data Management
        9*    must be initialized for this process.
       10*
       11*    dm_lock_status {-control_args}
       12*
       13*    Control Arguments:
       14*-all_transactions, -atxn
       15*   displays lock data for all transactions.
       16*-current_transaction, -ctxn
       17*   displays lock data for the current transaction in the user's
       18*   process.  (DEFAULT)
       19*-file_locks, -flk
       20*   displays file-level locks.  (DEFAULT)
       21*-no_file_locks, -nflk
       22*   suppresses the display of file-level locks.
       23*-control_interval_locks, -cilk
       24*   displays control-interval-level locks.  (DEFAULT)
       25*-no_control_interval_locks, -ncilk
       26*   suppresses the display of control-interval-level locks.
       27*-header, -he
       28*   displays data from the header of the lock database.
       29*-no_header, -nhe
       30*   suppresses the display of data from the header of the lock database.
       31*   (DEFAULT)
       32*
       33*
       34*Notes:  This command requires e (execute) access to the dm_admin_gate_.
       35**/
       36 
       37 /* HISTORY:
       38*
       39*Written by J. Bongiovanni, 11/01/82.
       40*Modified:
       41*12/01/82 by J. Bongiovanni:  For multi-segment lock data.
       42*04/25/83 by Benson I. Margulies:  To add -file, interpret process ids.
       43*04/29/83 by Benson I. Margulies:  To use lock_manager_$copy_data.
       44*05/01/84 by R. Michael Tague:  Added the History section.  Added
       45*            %include dm_lm_meters.
       46*10/19/84 by Stanford S. Cox:  For DM program standards.
       47*11/29/84 by Lindsey L. Spratt:  Renamed from display_lm_data to
       48*            dm_lock_status.  Completely reconstructed the argument processing.
       49*            Changed to be a ssu_ standalone invocation.
       50*12/05/84 by Lindsey L. Spratt:  Added the REPORT_MISSING_ARGUMENT proc.
       51*01/02/85 by Lindsey L. Spratt:  Changed to use
       52*            hbound(lock_seg.transaction_table,1), instead of
       53*            dm_system_data_$max_n_transactions.
       54*           Changed to use more of ssu_'s services, where feasible;
       55*            ssu_$get/release_area, ssu_$get/release_temp_segment.  Fixed the
       56*            allocations to be done in ssu_area.  Added new internal proc,
       57*            REPORT_INVALID_VIRTUAL_POINTER, and changed all reports of invalid
       58*            virtual ptrs to use it.  This proc gives the invalid value, while
       59*            the old messages did not.  Changed to use an "indent" variable in
       60*            DISPLAY_LOCK and DISPLAY_TRANSACTION to specify the level of
       61*            indentation of the messages.  Fixed variables in
       62*            DISPLAY_TRANSACTION to have the dt_ prefix instead of the dp_
       63*            prefix.
       64*
       65*01/04/85 by Lindsey L. Spratt:  Added the DISPLAY_BLOCK_LIST internal proc to
       66*            have a common subr for displaying the lists of waiters and owners.
       67*02/08/85 by Lindsey L. Spratt:  Changed dcl of temp_string to have a length of
       68*            (sys_info$max_seg_size-1)*4, to allow for the length word.
       69*            Removed spurious check of "code" after call of
       70*            ssu_$get_temp_segment.
       71*03/19/85 by S. Cox: Added dm_not_available_ handler.
       72**/
       73 
       74 /* format: style2,ind3 */
       75 dm_lock_status:
       76    procedure options (variable);
       77 
       78 /*  Automatic  */
       79 
       80       dcl	    accept_control_argument
       81 			       bit (1) aligned init ("0"b);
       82       dcl	    arg_idx	       fixed bin;
       83       dcl	    arg_len	       fixed bin (21);
       84       dcl	    arg_list_ptr	       ptr init (null);
       85       dcl	    arg_ptr	       ptr;
       86       dcl	    cur_txn_id	       bit (36) aligned;
       87       dcl	    code		       fixed bin (35);
       88       dcl	    control_argument_idx   fixed bin;
       89       dcl	    display_control_interval_locks
       90 			       bit (1) aligned init (YES);
       91       dcl	    display_file_locks     bit (1) aligned init (YES);
       92       dcl	    display_hash_table     bit (1) aligned init (NO);
       93       dcl	    display_header	       bit (1) aligned init (NO);
       94       dcl	    duplication_indicator_has_been_displayed
       95 			       bit (1) aligned init (NO);
       96       dcl	    force_interpretation_as_argument
       97 			       bit (1) aligned init (NO);
       98       dcl	    hash_table_idx	       fixed bin;
       99       dcl	    is_active_function     bit (1) aligned init (NO);
      100       dcl	    number_of_args	       fixed bin;
      101       dcl	    previous_bucket	       bit (36) aligned;
      102       dcl	    1 pdi		       aligned like print_data_info;
      103       dcl	    return_arg_len	       fixed bin (21) init (0);
      104       dcl	    return_arg_ptr	       ptr init (null);
      105       dcl	    sci_ptr	       ptr init (null);
      106       dcl	    ssu_area_ptr	       ptr init (null);
      107       dcl	    temp_string_ptr	       ptr init (null);
      108       dcl	    there_is_an_active_transaction
      109 			       bit (1) aligned init (NO);
      110       dcl	    this_is_a_standalone_invocation
      111 			       bit (1) aligned init (YES);
      112       dcl	    transaction_idx	       fixed bin;
      113       dcl	    transaction_selection  fixed bin (35) init (CURRENT_TRANSACTION);
      114 
      115 /*  Based  */
      116 
      117       dcl	    arg		       char (arg_len) based (arg_ptr);
      118       dcl	    ssu_area	       area (1024) based (ssu_area_ptr);
      119       dcl	    temp_string	       char ((sys_info$max_seg_size - 1) * 4) varying based (temp_string_ptr);
      120 
      121 /* Builtin */
      122 
      123       dcl	    (addr, bin, hbound, index, null, ptr, setwordno, substr, unspec)
      124 			       builtin;
      125 
      126 /* Condition */
      127 
      128       dcl	    (cleanup, dm_not_available_)
      129 			       condition;
      130 
      131 /* Constant */
      132 
      133       dcl	    myname	       init ("dm_lock_status") char (14) internal static options (constant);
      134       dcl	    (
      135 	    YES		       init ("1"b),
      136 	    NO		       init ("0"b)
      137 	    )		       bit (1) aligned internal static options (constant);
      138 
      139 
      140       dcl	    (
      141 	    ALL_TRANSACTIONS       init (1),
      142 	    CURRENT_TRANSACTION    init (0)
      143 	    )		       fixed bin (35) internal static options (constant);
      144 
      145       dcl	    FILE_LOCK_CI_NUMBER    init (-1) fixed bin (35) internal static options (constant);
      146       dcl	    DEFAULT_AREA_INFO_PTR  init (null) ptr internal static options (constant);
      147 
      148       dcl	    ARGUMENT_TYPE	       (20) internal static options (constant) char (64) varying
      149 			       init ("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "")
      150 			       ;
      151 
      152       dcl	    CONTROL_ARGUMENT       (20) internal static options (constant) char (64) varying
      153 			       init ("-all_transactions", "-atxn", "-current_transaction", "-ctxn", "-file_locks",
      154 			       "-flk", "-no_file_locks", "-nflk", "-control_interval_locks", "-cilk",
      155 			       "-no_control_interval_locks", "-ncilk", "-header", "-he", "-no_header", "-nhe",
      156 			       "-hash_table", "-ht", "-no_hash_table", "-nht");
      157 
      158 
      159 /*  External  */
      160 
      161       dcl	    (
      162 	    dm_error_$no_current_transaction,
      163 	    dm_error_$system_not_initialized,
      164 	    error_table_$bad_arg,
      165 	    error_table_$badopt,
      166 	    error_table_$noarg,
      167 	    error_table_$smallarg,
      168 	    error_table_$unimplemented_version
      169 	    )		       fixed bin (35) external;
      170 
      171       dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
      172 
      173 /*  Entry  */
      174 
      175       dcl	    cu_$arg_list_ptr       entry (ptr);
      176       dcl	    get_temp_segments_     entry (character (*), (*) pointer, fixed binary (35));
      177       dcl	    ioa_		       entry options (variable);
      178       dcl	    lock_manager_$copy_data
      179 			       entry (ptr, fixed bin (35));
      180       dcl	    lock_manager_$system_segment_count
      181 			       entry (fixed bin (35)) returns (fixed bin);
      182       dcl	    print_data_	       entry (character (*) var, pointer, fixed binary (35));
      183       dcl	    release_temp_segments_ entry (character (*), (*) pointer, fixed binary (35));
      184       dcl	    ssu_$abort_line	       entry () options (variable);
      185       dcl	    ssu_$arg_count	       entry (ptr, fixed bin);
      186       dcl	    ssu_$arg_ptr	       entry (ptr, fixed bin, ptr, fixed bin (21));
      187       dcl	    ssu_$destroy_invocation
      188 			       entry (ptr);
      189       dcl	    ssu_$get_area	       entry (ptr, ptr, char (*), ptr);
      190       dcl	    ssu_$get_temp_segment  entry (ptr, char (*), ptr);
      191       dcl	    ssu_$release_area      entry (ptr, ptr);
      192       dcl	    ssu_$release_temp_segment
      193 			       entry (ptr, ptr);
      194       dcl	    ssu_$standalone_invocation
      195 			       entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
      196       dcl	    sub_err_	       entry () options (variable);
      197       dcl	    transaction_manager_$get_current_txn_id
      198 			       entry (bit (36) aligned, fixed bin (35));
      199       dcl	    transaction_manager_$get_txn_info
      200 			       entry (bit (36) aligned, ptr, fixed bin (35));
      201 
      202       pdi.version = print_data_info_version_1;
      203       pdi.indentation = 3;
      204       pdi.value_column = 30;
      205       pdi.output_switch = null ();
      206       pdi.octal = YES;
      207       pdi.intervals = "";
      208 
      209       lm_copy_data_ptr, lock_segments_ptr = null ();
      210 
      211       on cleanup call CLEANUP ();
      212 
      213       call cu_$arg_list_ptr (arg_list_ptr);
      214       call ssu_$standalone_invocation (sci_ptr, myname, "", arg_list_ptr, ABORT_ENTRY, code);
      215 
      216       on dm_not_available_ call ssu_$abort_line (sci_ptr, dm_error_$system_not_initialized);
      217 
      218       call ssu_$get_area (sci_ptr, DEFAULT_AREA_INFO_PTR, "", ssu_area_ptr);
      219 
      220       call ssu_$arg_count (sci_ptr, number_of_args);
      221 
      222       accept_control_argument = YES;
      223       control_argument_idx = -1;
      224 
      225 ARG_PROCESSING_LOOP:
      226       do arg_idx = 1 to number_of_args;
      227          call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_len);
      228          if index (arg, "-") ^= 1 | force_interpretation_as_argument = YES
      229          then call PROCESS_ARGUMENT (arg, control_argument_idx, accept_control_argument);
      230          else if accept_control_argument = YES
      231          then call PROCESS_CONTROL_ARGUMENT (arg, control_argument_idx, accept_control_argument,
      232 	         force_interpretation_as_argument);
      233          else call REPORT_MISSING_ARGUMENT (control_argument_idx);
      234       end ARG_PROCESSING_LOOP;
      235 
      236       if control_argument_idx >= 0 & accept_control_argument = NO
      237       then call REPORT_MISSING_ARGUMENT (control_argument_idx);
      238 
      239       call GET_SEGMENT_PTRS ();
      240 
      241       if display_header
      242       then
      243          do;
      244 	  call ssu_$get_temp_segment (sci_ptr, "", temp_string_ptr);
      245 
      246 	  put data (lock_seg.version, lock_seg.header) string (temp_string);
      247 
      248 	  call print_data_ (temp_string, addr (pdi), (0));
      249 
      250 	  call ioa_;
      251          end;
      252 
      253       lock_hash_table_ptr = setwordno (lock_seg_ptr, lock_seg.hash_table_offset);
      254       if lock_hash_table_ptr ^= addr (lock_seg.hash_table)
      255       then call ioa_ ("hash table offset is wrong");
      256       else if display_hash_table
      257       then
      258          do;
      259 	  hash_table_idx = 1;
      260 	  previous_bucket = unspec (lock_hash_table.buckets (1));
      261 	  call ioa_ ("Bucket ^20tPointer to first lock object.");
      262 	  call ioa_ ("^d ^20t^w", hash_table_idx, unspec (lock_hash_table.buckets (hash_table_idx)));
      263 	  do hash_table_idx = 2 to lock_seg.n_hash_table_entries - 1;
      264 	     if previous_bucket ^= unspec (lock_hash_table.buckets (hash_table_idx))
      265 	     then
      266 	        do;
      267 		 call ioa_ ("^d ^20t^w", hash_table_idx, unspec (lock_hash_table.buckets (hash_table_idx)));
      268 		 previous_bucket = unspec (lock_hash_table.buckets (hash_table_idx));
      269 		 duplication_indicator_has_been_displayed = NO;
      270 	        end;
      271 	     else if duplication_indicator_has_been_displayed = NO
      272 	     then
      273 	        do;
      274 		 call ioa_ ("===");
      275 		 duplication_indicator_has_been_displayed = YES;
      276 	        end;
      277 	  end;
      278 	  call ioa_ ("^d ^20t^w", hash_table_idx, unspec (lock_hash_table.buckets (hash_table_idx)));
      279          end;
      280 
      281       cur_txn_id = ""b;				/* start somewhere in case of error */
      282       call transaction_manager_$get_current_txn_id (cur_txn_id, code);
      283       if code ^= 0
      284       then if cur_txn_id = "0"b & code ^= dm_error_$no_current_transaction
      285 	 then call ssu_$abort_line (sci_ptr, code, "^/Unable to get the current transaction id.");
      286 
      287       there_is_an_active_transaction = NO;
      288 
      289       do transaction_idx = 1 to hbound (lock_seg.transaction_table, 1);
      290          lock_transaction_table_ptr = addr (lock_seg.transaction_table (transaction_idx));
      291          if (transaction_selection = ALL_TRANSACTIONS | lock_transaction_table.txn_id = cur_txn_id)
      292 	    & lock_transaction_table.txn_id ^= ""b
      293          then
      294 	  do;
      295 	     there_is_an_active_transaction = YES;
      296 	     call DISPLAY_TRANSACTION (lock_transaction_table_ptr);
      297 	  end;
      298       end;
      299 
      300       if there_is_an_active_transaction = NO
      301       then
      302          do;
      303 	  if transaction_selection = ALL_TRANSACTIONS
      304 	  then call ioa_ ("There are no transactions holding locks.");
      305 	  else if cur_txn_id ^= "0"b
      306 	  then call ioa_ ("The current transaction does not hold any locks.");
      307 	  else call ioa_ ("There is no current transaction for which to display locks.");
      308          end;
      309 
      310       call CLEANUP ();
      311 
      312 MAIN_RETURN:
      313       return;
      314 
      315 ABORT_ENTRY:
      316    procedure ();
      317       call CLEANUP ();
      318       go to MAIN_RETURN;
      319    end ABORT_ENTRY;
      320 
      321 
      322 
      323 CLEANUP:
      324    procedure ();
      325       if lm_copy_data_ptr ^= null ()
      326       then call release_temp_segments_ (myname, lm_copy_data.segment_ptrs, (0));
      327 
      328       call ssu_$release_area (sci_ptr, ssu_area_ptr);
      329       call ssu_$release_temp_segment (sci_ptr, temp_string_ptr);
      330 
      331       if this_is_a_standalone_invocation
      332       then call ssu_$destroy_invocation (sci_ptr);
      333       else ;
      334 
      335       lm_copy_data_ptr, lock_segments_ptr = null ();
      336    end CLEANUP;
      337 
      338 PROCESS_ARGUMENT:
      339    proc (pa_p_arg, pa_p_control_argument_idx, pa_p_accept_control_argument);
      340 
      341       dcl	    pa_p_arg	       char (*) parm;
      342       dcl	    pa_p_control_argument_idx
      343 			       fixed bin parm;
      344       dcl	    pa_p_accept_control_argument
      345 			       bit (1) aligned parm;
      346 
      347       dcl	    pa_code	       fixed bin (35);
      348 
      349       pa_code = 0;
      350 
      351       goto ARGUMENT (pa_p_control_argument_idx);
      352 ARGUMENT (-1):
      353       call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^/The argument ""^a"" is out of place.", arg);
      354       return;
      355    end PROCESS_ARGUMENT;
      356 
      357 PROCESS_CONTROL_ARGUMENT:
      358    proc (pca_p_arg, pca_p_control_argument_idx, pca_p_accept_control_argument, pca_p_force_interpretation_as_argument);
      359 
      360 
      361       dcl	    pca_p_arg	       char (*) parm;
      362       dcl	    pca_p_control_argument_idx
      363 			       fixed bin parm;
      364       dcl	    pca_p_accept_control_argument
      365 			       bit (1) aligned parm;
      366       dcl	    pca_p_force_interpretation_as_argument
      367 			       bit (1) aligned parm;
      368 
      369       pca_p_control_argument_idx = CONTROL_ARGUMENT_INDEX (pca_p_arg);
      370       pca_p_accept_control_argument = YES;
      371       pca_p_force_interpretation_as_argument = NO;
      372 
      373       go to CONTROL_ARGUMENT (pca_p_control_argument_idx);
      374 
      375 CONTROL_ARGUMENT (-1):				/* not a control argument */
      376       call ssu_$abort_line (sci_ptr, error_table_$badopt, pca_p_arg);
      377 
      378 CONTROL_ARGUMENT (1):				/* -all_transactions */
      379 CONTROL_ARGUMENT (2):				/* -atxn */
      380       transaction_selection = ALL_TRANSACTIONS;
      381 
      382       pca_p_control_argument_idx = -1;
      383       pca_p_accept_control_argument = YES;
      384       return;
      385 
      386 CONTROL_ARGUMENT (3):				/* -current_transaction */
      387 CONTROL_ARGUMENT (4):				/* -ctxn */
      388       transaction_selection = CURRENT_TRANSACTION;
      389 
      390       pca_p_control_argument_idx = -1;
      391       pca_p_accept_control_argument = YES;
      392       return;
      393 
      394 
      395 CONTROL_ARGUMENT (5):				/* -file_locks */
      396 CONTROL_ARGUMENT (6):				/* -flk */
      397       display_file_locks = YES;
      398 
      399       pca_p_control_argument_idx = -1;
      400       pca_p_accept_control_argument = YES;
      401       return;
      402 
      403 
      404 CONTROL_ARGUMENT (7):				/* -no_file_locks */
      405 CONTROL_ARGUMENT (8):				/* -nflk */
      406       display_file_locks = NO;
      407 
      408       pca_p_control_argument_idx = -1;
      409       pca_p_accept_control_argument = YES;
      410       return;
      411 
      412 
      413 CONTROL_ARGUMENT (9):				/* -control_interval_locks */
      414 CONTROL_ARGUMENT (10):				/* -cilk */
      415       display_control_interval_locks = YES;
      416 
      417       pca_p_control_argument_idx = -1;
      418       pca_p_accept_control_argument = YES;
      419       return;
      420 
      421 
      422 CONTROL_ARGUMENT (11):				/* -no_control_interval_locks */
      423 CONTROL_ARGUMENT (12):				/* -ncilk */
      424       display_control_interval_locks = NO;
      425 
      426       pca_p_control_argument_idx = -1;
      427       pca_p_accept_control_argument = YES;
      428       return;
      429 
      430 
      431 CONTROL_ARGUMENT (13):				/* -header */
      432 CONTROL_ARGUMENT (14):				/* -he */
      433       display_header = YES;
      434 
      435       pca_p_control_argument_idx = -1;
      436       pca_p_accept_control_argument = YES;
      437       return;
      438 
      439 
      440 CONTROL_ARGUMENT (15):				/* -no_header */
      441 CONTROL_ARGUMENT (16):				/* -nhe */
      442       display_header = NO;
      443 
      444       pca_p_control_argument_idx = -1;
      445       pca_p_accept_control_argument = YES;
      446       return;
      447 
      448 
      449 CONTROL_ARGUMENT (17):				/* -hash_table */
      450 CONTROL_ARGUMENT (18):				/* -ht */
      451       display_hash_table = YES;
      452 
      453       pca_p_control_argument_idx = -1;
      454       pca_p_accept_control_argument = YES;
      455       return;
      456 
      457 
      458 CONTROL_ARGUMENT (19):				/* -no_hash_table */
      459 CONTROL_ARGUMENT (20):				/* -nht */
      460       display_hash_table = NO;
      461 
      462       pca_p_control_argument_idx = -1;
      463       pca_p_accept_control_argument = YES;
      464       return;
      465 
      466 
      467    end PROCESS_CONTROL_ARGUMENT;
      468 
      469 
      470 CONTROL_ARGUMENT_INDEX:
      471    proc (cai_p_arg) returns (fixed bin);
      472 
      473       dcl	    cai_p_arg	       char (*);
      474       dcl	    cai_control_argument_idx
      475 			       fixed bin;
      476 
      477       do cai_control_argument_idx = 1 to hbound (CONTROL_ARGUMENT, 1)
      478 	 while (CONTROL_ARGUMENT (cai_control_argument_idx) ^= cai_p_arg);
      479       end;
      480       if cai_control_argument_idx > hbound (CONTROL_ARGUMENT, 1)
      481       then return (-1);
      482       else return (cai_control_argument_idx);
      483 
      484    end CONTROL_ARGUMENT_INDEX;
      485 
      486 
      487 REPORT_MISSING_ARGUMENT:
      488    proc (rma_p_control_argument_idx);
      489       dcl	    rma_p_control_argument_idx
      490 			       fixed bin parm;
      491 
      492       call ssu_$abort_line (sci_ptr, error_table_$noarg, "^a must be followed by a^[n^] ^a.",
      493 	 CONTROL_ARGUMENT (rma_p_control_argument_idx),
      494 	 (index ("aeiouh", substr (ARGUMENT_TYPE (rma_p_control_argument_idx), 1, 1)) > 0),
      495 	 ARGUMENT_TYPE (rma_p_control_argument_idx));
      496    end REPORT_MISSING_ARGUMENT;
      497 
      498 /*  Internal Procedure to display locks for one process  */
      499 
      500 DISPLAY_TRANSACTION:
      501    proc (dt_p_lock_transaction_table_ptr);
      502 
      503       dcl	    dt_p_lock_transaction_table_ptr
      504 			       ptr;
      505 
      506       dcl	    1 dt_process_vptr      aligned like lock_virtual_ptr;
      507       dcl	    dt_lock_owner_ptr      ptr;
      508       dcl	    dt_lock_waiter_ptr     ptr;
      509 
      510       dcl	    1 dt_lock_owner	       aligned like lock_owner based (dt_lock_owner_ptr);
      511       dcl	    1 dt_lock_transaction_table
      512 			       aligned like lock_transaction_table based (dt_p_lock_transaction_table_ptr);
      513       dcl	    1 dt_lock_waiter       aligned like lock_waiter based (dt_lock_waiter_ptr);
      514       dcl	    1 dt_txi	       aligned like txn_info;
      515 
      516       dcl	    dt_indent	       fixed bin init (0);
      517 
      518       unspec (dt_txi) = ""b;
      519       dt_txi.version = TXN_INFO_VERSION_5;
      520       dt_txi.owner_name = "";
      521       call transaction_manager_$get_txn_info (dt_lock_transaction_table.txn_id, addr (dt_txi), code);
      522       call ioa_ ("^/^a ^w  Transaction ^d  ^[Ev Chan ^o^]", dt_txi.owner_name, dt_lock_transaction_table.process_id,
      523 	 bin (dt_lock_transaction_table.txn_id, 71, 0), (dt_lock_transaction_table.ev_channel ^= 0),
      524 	 dt_lock_transaction_table.ev_channel);
      525 
      526       dt_indent = 2;
      527 
      528       if dt_lock_transaction_table.wait_ptr.seg_inx ^= NULL_VPTR.seg_inx
      529       then
      530          do;
      531 	  dt_lock_waiter_ptr = PTR (dt_lock_transaction_table.wait_ptr);
      532 	  if dt_lock_waiter_ptr = null ()
      533 	  then call REPORT_INVALID_VIRTUAL_POINTER (dt_indent, "Waiting", dt_lock_transaction_table.wait_ptr);
      534 	  else
      535 	     do;
      536 	        call ioa_ ("^vxWaiting for ^a mode", dt_indent, LOCK_MODE_NAMES (dt_lock_waiter.mode));
      537 	        call DISPLAY_LOCK (dt_indent, dt_lock_waiter.lock_ptr);
      538 	     end;
      539          end;
      540 
      541       dt_indent = dt_indent + 2;
      542 
      543       dt_process_vptr = dt_lock_transaction_table.own_ptr;
      544       do while (dt_process_vptr.seg_inx ^= NULL_VPTR.seg_inx);
      545          dt_lock_owner_ptr = PTR (dt_process_vptr);
      546          if dt_lock_owner_ptr = null ()
      547          then
      548 	  do;
      549 	     call REPORT_INVALID_VIRTUAL_POINTER (dt_indent, "Owner", dt_process_vptr);
      550 	     dt_process_vptr = NULL_VPTR;
      551 	  end;
      552          else if dt_lock_owner.type ^= TYPE_OWNER
      553          then
      554 	  do;
      555 	     call ioa_ ("^vxInvalid Owner Type ^d at ^p", dt_indent, dt_lock_owner.type, dt_lock_owner_ptr);
      556 	     dt_process_vptr = NULL_VPTR;
      557 	  end;
      558          else
      559 	  do;
      560 	     call DISPLAY_LOCK (dt_indent, dt_lock_owner.lock_ptr);
      561 	     dt_process_vptr = dt_lock_owner.transaction_fp;
      562 	  end;
      563       end;
      564 
      565       call ioa_ ("");
      566 
      567    end DISPLAY_TRANSACTION;
      568 
      569 /*  Internal Procedure to display a lock  */
      570 
      571 DISPLAY_LOCK:
      572    proc (dl_p_indent, dl_p_lock_object_vptr);
      573 
      574       dcl	    1 dl_p_lock_object_vptr
      575 			       aligned like lock_virtual_ptr parameter;
      576       dcl	    dl_p_indent	       fixed bin parm;
      577 
      578       dcl	    dl_indent	       fixed bin init (0);
      579       dcl	    dl_lock_object_ptr     ptr;
      580       dcl	    1 dl_lock_object       aligned like lock_object based (dl_lock_object_ptr);
      581       dcl	    1 dl_txi	       aligned like txn_info;
      582 
      583 
      584       dl_indent = dl_p_indent;
      585 
      586       dl_lock_object_ptr = PTR (dl_p_lock_object_vptr);
      587       if dl_lock_object_ptr = null ()
      588       then
      589          do;
      590 	  call REPORT_INVALID_VIRTUAL_POINTER (dl_indent, "Object", dl_p_lock_object_vptr);
      591 	  return;
      592          end;
      593       if dl_lock_object.type ^= TYPE_OBJECT
      594       then
      595          do;
      596 	  call ioa_ ("^vxInvalid Object Type ^d at ^p", dl_indent, dl_lock_object.type, dl_lock_object_ptr);
      597 	  return;
      598          end;
      599 
      600       if dl_lock_object.ci_no = FILE_LOCK_CI_NUMBER
      601       then if display_file_locks = NO
      602 	 then return;
      603 	 else ;
      604       else if display_control_interval_locks = NO
      605       then return;
      606       else ;
      607 
      608 
      609       call ioa_ ("^vxLock  UID=^w ^[FILE^s^;CI=^d^]", dl_indent, dl_lock_object.uid,
      610 	 (dl_lock_object.ci_no = FILE_LOCK_CI_NUMBER), dl_lock_object.ci_no);
      611 
      612       dl_indent = dl_indent + 2;
      613 
      614       call DISPLAY_BLOCK_LIST (dl_lock_object.owners_ptr, dl_indent, "Owner", TYPE_OWNER, OWNER_GET_TXN_VPTR,
      615 	 OWNER_GET_MODE, OWNER_GET_NEXT_BLOCK_VPTR);
      616 
      617       call DISPLAY_BLOCK_LIST (dl_lock_object.waiters_ptr, dl_indent, "Waiter", TYPE_WAITER, WAITER_GET_TXN_VPTR,
      618 	 WAITER_GET_MODE, WAITER_GET_NEXT_BLOCK_VPTR);
      619 
      620 
      621    end DISPLAY_LOCK;
      622 
      623 DISPLAY_BLOCK_LIST:
      624    proc (dbl_p_first_block_vptr, dbl_p_indent, dbl_p_str, dbl_p_type, dbl_p_get_txn_vptr, dbl_p_get_mode,
      625         dbl_p_get_next_block_vptr);
      626       dcl	    1 dbl_p_first_block_vptr
      627 			       aligned like lock_virtual_ptr parm;
      628       dcl	    dbl_p_indent	       fixed bin parm;
      629       dcl	    dbl_p_str	       char (*) parm;
      630       dcl	    dbl_p_type	       fixed bin parm;
      631       dcl	    dbl_p_get_txn_vptr     variable entry (ptr) returns (1 aligned like lock_virtual_ptr) parm;
      632       dcl	    dbl_p_get_mode	       variable entry (ptr) returns (fixed bin) parm;
      633       dcl	    dbl_p_get_next_block_vptr
      634 			       variable entry (ptr) returns (1 aligned like lock_virtual_ptr) parm;
      635 
      636       dcl	    dbl_indent	       fixed bin init (0);
      637 
      638       dcl	    1 dbl_lock_block_vptr  aligned like lock_virtual_ptr;
      639       dcl	    1 dbl_txi	       aligned like txn_info;
      640       dcl	    dbl_lock_block_ptr     ptr;
      641       dcl	    1 dbl_lock_block       aligned like lock_block based (dbl_lock_block_ptr);
      642       dcl	    1 dbl_lock_transaction_table_vptr
      643 			       aligned like lock_virtual_ptr;
      644       dcl	    dbl_lock_transaction_table_ptr
      645 			       ptr;
      646       dcl	    1 dbl_lock_transaction_table
      647 			       aligned like lock_transaction_table based (dbl_lock_transaction_table_ptr);
      648       dcl	    dbl_code	       fixed bin (35) init (0);
      649 
      650       dbl_lock_block_vptr = dbl_p_first_block_vptr;
      651       dbl_indent = dbl_p_indent;
      652 
      653       dbl_txi.version = TXN_INFO_VERSION_5;
      654       dbl_txi.owner_name = "";
      655 
      656       do while (dbl_lock_block_vptr.seg_inx ^= NULL_VPTR.seg_inx);
      657          dbl_lock_block_ptr = PTR (dbl_lock_block_vptr);
      658          if dbl_lock_block_ptr = null ()
      659          then
      660 	  do;
      661 	     call REPORT_INVALID_VIRTUAL_POINTER (dbl_indent, dbl_p_str, dbl_lock_block_vptr);
      662 	     dbl_lock_block_vptr = NULL_VPTR;
      663 	  end;
      664          else if dbl_lock_block.type ^= dbl_p_type
      665          then
      666 	  do;
      667 	     call ioa_ ("^vxInvalid ^a Type ^d at ^p", dbl_p_str, dbl_indent, dbl_lock_block.type, dbl_lock_block_ptr);
      668 	     dbl_lock_block_vptr = NULL_VPTR;
      669 	  end;
      670          else
      671 	  do;
      672 	     dbl_lock_transaction_table_vptr = dbl_p_get_txn_vptr (dbl_lock_block_ptr);
      673 	     dbl_lock_transaction_table_ptr = PTR (dbl_lock_transaction_table_vptr);
      674 	     if dbl_lock_transaction_table_ptr = null ()
      675 	     then call REPORT_INVALID_VIRTUAL_POINTER (dbl_indent, "Lock txn table", dbl_lock_transaction_table_vptr);
      676 	     else
      677 	        do;
      678 		 call transaction_manager_$get_txn_info (dbl_lock_transaction_table.txn_id, addr (dbl_txi), dbl_code);
      679 		 call ioa_ ("^vx^a ^a ^w Txn ^d ^45tMode ^3a", dbl_indent, dbl_p_str, dbl_txi.owner_name,
      680 		      dbl_lock_transaction_table.process_id, bin (dbl_lock_transaction_table.txn_id, 71, 0),
      681 		      LOCK_MODE_NAMES (dbl_p_get_mode (dbl_lock_block_ptr)));
      682 		 dbl_lock_block_vptr = dbl_p_get_next_block_vptr (dbl_lock_block_ptr);
      683 	        end;
      684 	  end;
      685       end;
      686    end DISPLAY_BLOCK_LIST;
      687 
      688 OWNER_GET_TXN_VPTR:
      689    proc (ogtv_p_lock_owner_ptr) returns (1 aligned like lock_virtual_ptr);
      690       dcl	    ogtv_p_lock_owner_ptr  ptr parm;
      691       dcl	    1 ogtv_p_lock_owner    aligned like lock_owner based (ogtv_p_lock_owner_ptr);
      692 
      693       return (ogtv_p_lock_owner.transaction_ptr);
      694 
      695 OWNER_GET_MODE:
      696    entry (ogtv_p_lock_owner_ptr) returns (fixed bin);
      697       return (ogtv_p_lock_owner.mode);
      698 
      699 OWNER_GET_NEXT_BLOCK_VPTR:
      700    entry (ogtv_p_lock_owner_ptr) returns (1 aligned like lock_virtual_ptr);
      701       return (ogtv_p_lock_owner.owners_fp);
      702    end OWNER_GET_TXN_VPTR;
      703 
      704 WAITER_GET_TXN_VPTR:
      705    proc (wgtv_p_lock_waiter_ptr) returns (1 aligned like lock_virtual_ptr);
      706       dcl	    wgtv_p_lock_waiter_ptr ptr parm;
      707       dcl	    1 wgtv_p_lock_waiter   aligned like lock_waiter based (wgtv_p_lock_waiter_ptr);
      708 
      709       return (wgtv_p_lock_waiter.transaction_ptr);
      710 
      711 WAITER_GET_MODE:
      712    entry (wgtv_p_lock_waiter_ptr) returns (fixed bin);
      713       return (wgtv_p_lock_waiter.mode);
      714 
      715 WAITER_GET_NEXT_BLOCK_VPTR:
      716    entry (wgtv_p_lock_waiter_ptr) returns (1 aligned like lock_virtual_ptr);
      717       return (wgtv_p_lock_waiter.waiters_fp);
      718    end WAITER_GET_TXN_VPTR;
      719 
      720 /*  Internal Procedure to turn a virtual pointer into a pointer  */
      721 
      722 PTR:
      723    proc (ptr_p_lock_virtual_ptr) returns (ptr);
      724 
      725       dcl	    1 ptr_p_lock_virtual_ptr
      726 			       aligned like lock_virtual_ptr parameter;
      727 
      728 
      729       if ptr_p_lock_virtual_ptr.seg_inx < 0 | ptr_p_lock_virtual_ptr.seg_inx > lm_copy_data_n_segments
      730       then return (null ());
      731       return (ptr (lock_segments.seg_baseptr (ptr_p_lock_virtual_ptr.seg_inx), ptr_p_lock_virtual_ptr.offset));
      732 
      733    end PTR;
      734 
      735 GET_SEGMENT_PTRS:
      736    procedure ();
      737       dcl	    gs_code	       fixed bin (35) init (0);
      738       dcl	    gs_try_idx	       fixed bin;
      739 
      740 
      741       gs_code = error_table_$smallarg;
      742       do gs_try_idx = 1 to 10 while (gs_code = error_table_$smallarg);
      743          lm_copy_data_n_segments = lock_manager_$system_segment_count (gs_code);
      744          allocate lm_copy_data in (ssu_area);
      745          lm_copy_data.version = LM_COPY_DATA_VERSION_1;
      746          call get_temp_segments_ (myname, lm_copy_data.segment_ptrs, gs_code);
      747          if gs_code ^= 0
      748          then call ssu_$abort_line (sci_ptr, gs_code, "^/Unable to get temp segments to hold the copy of lock data.");
      749          call lock_manager_$copy_data (addr (lm_copy_data), gs_code);
      750          if gs_code ^= 0
      751          then
      752 	  do;
      753 	     call release_temp_segments_ (myname, lm_copy_data.segment_ptrs, (0));
      754 	     free lm_copy_data;
      755 	  end;
      756       end;
      757       if gs_code ^= 0
      758       then call ssu_$abort_line (sci_ptr, gs_code, "^/Unable to copy the lock data.");
      759 
      760       lock_seg_ptr = lm_copy_data.segment_ptrs (1);
      761       call CHECK_VERSION (LOCK_SEG_VERSION_1, lock_seg.version, "lock_seg");
      762       allocate lock_segments in (ssu_area);
      763       lock_segments.seg_baseptr (*) = lm_copy_data.segment_ptrs (*);
      764       return;
      765 
      766    end GET_SEGMENT_PTRS;
      767 
      768 
      769 
      770 CHECK_VERSION:
      771    proc (cv_p_expected_version, cv_p_received_version, cv_p_structure_name);
      772 
      773       dcl	    cv_p_expected_version  char (8) aligned parameter;
      774       dcl	    cv_p_received_version  char (8) aligned parameter;
      775       dcl	    cv_p_structure_name    char (32) aligned parameter;
      776 
      777       if cv_p_expected_version ^= cv_p_received_version
      778       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null (), 0,
      779 	      "^/Expected version ^a of the ^a structure." || "^/Received version ^a instead.", cv_p_expected_version,
      780 	      cv_p_structure_name, cv_p_received_version);
      781    end CHECK_VERSION;
      782 
      783 REPORT_INVALID_VIRTUAL_POINTER:
      784    proc (rivp_p_indent, rivp_p_str, rivp_p_virtual_ptr);
      785       dcl	    rivp_p_indent	       fixed bin parm;
      786       dcl	    rivp_p_str	       char (*) parm;
      787       dcl	    1 rivp_p_virtual_ptr   aligned like lock_virtual_ptr parm;
      788 
      789       call ioa_ ("^vx^a - invalid virtual pointer (segment index ^d, offset ^d).", rivp_p_indent, rivp_p_str,
      790 	 rivp_p_virtual_ptr.seg_inx, rivp_p_virtual_ptr.offset);
      791 
      792    end REPORT_INVALID_VIRTUAL_POINTER;
      793 
  1     1 /*  START OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*     Hierarchical lock modes for Data Management control interval locking.  In
  1     6*addition to conventional read and write locks, intention locks are provided
  1     7*for finer locking granularity.
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*Written by Jeffrey D. Ives, 04/30/82.
  1    12*Modified:
  1    13*12/05/84 by Stanford S. Cox: Added Description.
  1    14**/
  1    15 /* format: style3,idind25 */
  1    16 
  1    17      dcl	   LOCK_MODE_S	      fixed bin static options (constant) init (2);
  1    18      dcl	   LOCK_MODE_X	      fixed bin static options (constant) init (3);
  1    19      dcl	   LOCK_MODE_IS	      fixed bin static options (constant) init (4);
  1    20      dcl	   LOCK_MODE_IX	      fixed bin static options (constant) init (5);
  1    21      dcl	   LOCK_MODE_SIX	      fixed bin static options (constant) init (6);
  1    22 
  1    23      dcl	   LOCK_ENTIRE_FILE	      fixed bin (27) static options (constant) init (-1);
  1    24 
  1    25      dcl	   LOCK_MODE_NAMES (2:6)  char (3) int static options (constant)
  1    26 			      init ("  S", "  X", " IS", " IX", "SIX");
  1    27 
  1    28 /*
  1    29*     S       Share                           Let others read it but not modify it.
  1    30*     X	   Exclusive		     Let nobody else read or modify it.
  1    31*     IS	   Intention Share		     I am only using S locks, because I am only reading CIs.
  1    32*     IX	   Intention Exclusive	     I am using S and X locks, because I am reading and modifying CIs.
  1    33*     SIX	   Share with Intention Exclusive  I am reading control intervals, but only locking the ones I modify.
  1    34**/
  1    35 
  1    36 /*  END OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      794 
      795 
  2     1 /* BEGIN INCLUDE FILE - dm_lm_meters.incl.pl1 *
  2     2*
  2     3*/* format: style3,idind25 */
  2     4 
  2     5 /* DESCRIPTION:
  2     6*
  2     7*     This is the lock manager meters structure.
  2     8**/
  2     9 /* HISTORY:
  2    10*Written by R. Michael Tague, 4/24/84.
  2    11*Modified:
  2    12*05/01/84 by R. Michael Tague:  Collected all of the meters together into
  2    13*            the meters structure.
  2    14**/
  2    15 
  2    16 dcl	lock_meters_ptr	     ptr;
  2    17 dcl	LOCK_METERS_VERSION_1    char (8) aligned int static options (constant)
  2    18 			     init ("LMMETER1");
  2    19 
  2    20 dcl	1 lock_meters	     aligned based (lock_meters_ptr),
  2    21 	  2 version	     char (8),
  2    22 	  2 lm_meters	     aligned,
  2    23 	    3 lock_calls	     fixed bin (35),
  2    24 	    3 unlock_all_calls   fixed bin (35),
  2    25 	    3 waits	     fixed bin (35),
  2    26 	    3 deadlock_checks    fixed bin (35),
  2    27 	    3 real_deadlock_checks
  2    28 			     fixed bin (35),
  2    29 	    3 deadlock_checks_36 fixed bin (35),
  2    30 	    3 deadlock_checks_72 fixed bin (35),
  2    31 	    3 deadlock_self_youngest
  2    32 			     fixed bin (35),
  2    33 	    3 deadlock_other_youngest
  2    34 			     fixed bin (35),
  2    35 	    3 file_locks_by_mode (2:6) fixed bin (35),
  2    36 	    3 ci_locks_by_mode   (2:3) fixed bin (35),
  2    37 	    3 allocates	     fixed bin (35),
  2    38 	    3 frees	     fixed bin (35),
  2    39 	    3 dup_file_locks_by_mode
  2    40 			     (2:6) fixed bin (35),
  2    41 	    3 dup_ci_locks_by_mode
  2    42 			     (2:3) fixed bin (35),
  2    43 	    3 pad		     (11) fixed bin (35);
  2    44 
  2    45 /* END INCLUDE FILE - dm_lm_meters.incl.pl1 */
      796 
      797 
  3     1 /* BEGIN INCLUDE FILE - dm_lm_system_data.incl.pl1 */
  3     2 
  3     3 /* format: style3,idind25 */
  3     4 /* HISTORY:
  3     5*
  3     6*Written by Benson Margulies, 4/83.
  3     7*Modified:
  3     8*04/24/84 by R. Michael Tague:  moved the meters structure definition to
  3     9*   dm_lm_meters.incl.pl1.  Added this history section.
  3    10*05/01/84 by R. Michael Tague:  removed the %include dm_lm_meters.
  3    11*10/17/84 by Stanford S. Cox:  Added version constant, and changed 
  3    12*   transaction_table to use a refer extent (to allow outer ring reference).
  3    13**/
  3    14 
  3    15 dcl	lock_seg_ptr	     ptr;
  3    16 dcl	lock_transaction_table_ptr
  3    17 			     ptr;
  3    18 dcl	lock_hash_table_ptr	     ptr;
  3    19 dcl	lock_aux_seg_ptr	     ptr;
  3    20 dcl	lock_block_ptr	     ptr;
  3    21 dcl	lock_block_array_ptr     ptr;
  3    22 dcl	lock_free_block_ptr	     ptr;
  3    23 dcl	lock_object_ptr	     ptr;
  3    24 dcl	lock_owner_ptr	     ptr;
  3    25 dcl	lock_segments_ptr	     ptr;
  3    26 dcl	lock_waiter_ptr	     ptr;
  3    27 dcl	lock_deadlock_ptr	     ptr;
  3    28 
  3    29 dcl	n_lock_blocks	     fixed bin;
  3    30 dcl	n_lock_deadlock	     fixed bin;
  3    31 
  3    32 dcl	LOCK_SEG_VERSION_1	     char (8) aligned init ("locksg 1") int static options (constant);
  3    33 
  3    34 dcl	1 lock_seg	     aligned based (lock_seg_ptr),
  3    35 						/* Per-system lock data */
  3    36 	  2 version	     char (8) aligned,
  3    37 	  2 header	     aligned,
  3    38 	    3 lock	     fixed bin (71),	/* Fast Lock on system lock operations */
  3    39 	    3 n_lock_segments    fixed bin,		/* Number of segments in system lock data */
  3    40 	    3 lock_seg_size	     fixed bin (19),	/* Number of words per segment */
  3    41 	    3 max_lock_segments  fixed bin,		/* Maximum number of segments */
  3    42 	    3 n_transaction_table_entries
  3    43 			     fixed bin,		/* Size of transaction table */
  3    44 	    3 n_hash_table_entries
  3    45 			     fixed bin,		/* Size of hash table */
  3    46 	    3 hash_mask	     bit (36) aligned,	/* Used by hashing routine */
  3    47 	    3 free_list_ptr	     aligned like lock_virtual_ptr,
  3    48 						/* Thread of free blocks */
  3    49 	    3 transaction_table_offset
  3    50 			     fixed bin (18) unsigned aligned,
  3    51 						/* Offset of transaction table */
  3    52 	    3 hash_table_offset  fixed bin (18) unsigned aligned,
  3    53 						/* Offset of hash table */
  3    54 	    3 n_lock_blocks	     fixed bin,		/* Number of blocks crated */
  3    55 	    3 lock_array_offset  fixed bin (18) unsigned aligned,
  3    56 						/* Offset of block array */
  3    57 	  2 transaction_table    (0 refer (lock_seg.n_transaction_table_entries)) aligned like lock_transaction_table,
  3    58 	  2 hash_table	     aligned like lock_hash_table,
  3    59 	  2 meters	     aligned like lock_meters,
  3    60 	  2 free		     fixed bin (71);	/* Free space */
  3    61 
  3    62 dcl	1 lock_aux_seg	     aligned based (lock_aux_seg_ptr),
  3    63 						/* Other than first segment */
  3    64 	  2 n_lock_blocks	     fixed bin,		/* Number of blocks in this segment */
  3    65 	  2 lock_array_offset    fixed bin (18) unsigned aligned,
  3    66 						/* Offset of block array */
  3    67 	  2 free		     fixed bin (71);	/* Free space */
  3    68 
  3    69 dcl	1 lock_transaction_table aligned based (lock_transaction_table_ptr),
  3    70 						/* Process table entry */
  3    71 	  2 deadlock_inx	     fixed bin,		/* Index used for deadlock detection */
  3    72 	  2 process_id	     bit (36) aligned,	/* Multics process identifier */
  3    73 	  2 txn_id	     bit (36) aligned,	/* Current transaction ID */
  3    74 	  2 ev_channel	     fixed bin (71),
  3    75 	  2 own_ptr	     aligned like lock_virtual_ptr,
  3    76 						/* First in thread of owning blocks */
  3    77 	  2 wait_ptr	     aligned like lock_virtual_ptr;
  3    78 						/* Waiting block */
  3    79 
  3    80 dcl	1 lock_hash_table	     aligned based (lock_hash_table_ptr),
  3    81 	  2 buckets	     (lock_seg.n_hash_table_entries) aligned like lock_virtual_ptr;
  3    82 
  3    83 
  3    84 dcl	1 lock_block	     aligned based (lock_block_ptr),
  3    85 						/* Generic block */
  3    86 	  2 seg_inx	     fixed bin unal,
  3    87 	  2 type		     fixed bin unal,
  3    88 	  2 pad		     (5) bit (36) aligned;
  3    89 
  3    90 dcl	1 lock_block_array	     (n_lock_blocks) aligned like lock_block based (lock_block_array_ptr);
  3    91 
  3    92 dcl	1 lock_free_block	     aligned based (lock_free_block_ptr),
  3    93 						/* Free block */
  3    94 	  2 seg_inx	     fixed bin unal,
  3    95 	  2 type		     fixed bin unal,	/* TYPE_FREE */
  3    96 	  2 free_fp	     aligned like lock_virtual_ptr,
  3    97 						/* Thread of free blocks */
  3    98 	  2 pad		     (4) bit (36) aligned;
  3    99 
  3   100 dcl	1 lock_object	     aligned based (lock_object_ptr),
  3   101 						/* That which is locked */
  3   102 	  2 seg_inx	     fixed bin unal,
  3   103 	  2 type		     fixed bin unal,	/* TYPE_OBJECT */
  3   104 	  2 uid		     bit (36) aligned,	/* Page File UID */
  3   105 	  2 ci_no		     fixed bin (35),	/* Control Interval (-1 => Page File) */
  3   106 	  2 owners_ptr	     aligned like lock_virtual_ptr,
  3   107 						/* First in thread of owning blocks */
  3   108 	  2 waiters_ptr	     aligned like lock_virtual_ptr,
  3   109 						/* First in thread of waiting blocks */
  3   110 	  2 ht_fp		     aligned like lock_virtual_ptr;
  3   111 						/* Hash Table thread */
  3   112 
  3   113 dcl	1 lock_owner	     aligned based (lock_owner_ptr),
  3   114 						/* Owner of a lock */
  3   115 	  2 seg_inx	     fixed bin unal,
  3   116 	  2 type		     fixed bin unal,	/* TYPE_OWNER */
  3   117 	  2 lock_ptr	     aligned like lock_virtual_ptr,
  3   118 						/* Pointer to lock_object */
  3   119 	  2 mode		     fixed bin,		/* Type of lock */
  3   120 	  2 owners_fp	     aligned like lock_virtual_ptr,
  3   121 						/* Thread of owners */
  3   122 	  2 transaction_fp	     aligned like lock_virtual_ptr,
  3   123 						/* Thread of locks owned by this transaction */
  3   124 	  2 transaction_ptr	     aligned like lock_virtual_ptr;
  3   125 						/* Pointer to transaction table entry */
  3   126 
  3   127 
  3   128 dcl	1 lock_waiter	     aligned based (lock_waiter_ptr),
  3   129 						/* Waiter for a lock */
  3   130 	  2 seg_inx	     fixed bin unal,
  3   131 	  2 type		     fixed bin unal,	/* TYPE_WAITER */
  3   132 	  2 lock_ptr	     aligned like lock_virtual_ptr,
  3   133 						/* Pointer to lock_object */
  3   134 	  2 mode		     fixed bin,		/* Desired mode */
  3   135 	  2 waiters_fp	     aligned like lock_virtual_ptr,
  3   136 						/* Thread of waiters */
  3   137 	  2 transaction_ptr	     aligned like lock_virtual_ptr,
  3   138 						/* Process table entry of this proces */
  3   139 	  2 pad		     bit (36) aligned;
  3   140 
  3   141 
  3   142 dcl	1 lock_segments	     aligned based (lock_segments_ptr),
  3   143 	  2 seg_baseptr	     (lock_seg.n_lock_segments) ptr unal;
  3   144 
  3   145 dcl	1 lock_virtual_ptr	     aligned based,
  3   146 	  2 seg_inx	     fixed bin unal,
  3   147 	  2 offset	     fixed bin (18) unsigned unal;
  3   148 
  3   149 dcl	1 lock_deadlock	     aligned based (lock_deadlock_ptr),
  3   150 	  2 wait_own	     (n_lock_deadlock, n_lock_deadlock) bit (1) unaligned;
  3   151 
  3   152 declare	1 lock_deadlock_36	     aligned based (lock_deadlock_ptr),
  3   153 	  2 wait_own	     (36, 36) bit (1) unaligned;
  3   154 
  3   155 declare	1 lock_deadlock_72	     aligned based (lock_deadlock_ptr),
  3   156 	  2 wait_own	     (72, 72) bit (1) unaligned;
  3   157 						/* (x,y) ON => x waiting for lock owned by y */
  3   158 
  3   159 declare	lock_deadlock_txn_ids_ptr
  3   160 			     pointer;
  3   161 declare	lock_deadlock_txn_ids    (n_lock_deadlock) bit (36) aligned based (lock_deadlock_txn_ids_ptr);
  3   162 dcl	(
  3   163 	TYPE_FREE		     init (1),
  3   164 	TYPE_OBJECT	     init (2),
  3   165 	TYPE_OWNER	     init (3),
  3   166 	TYPE_WAITER	     init (4),
  3   167 	MAX_TYPE		     init (4)
  3   168 	)		     fixed bin int static options (constant);
  3   169 
  3   170 
  3   171 dcl	1 NULL_VPTR	     aligned int static options (constant),
  3   172 	  2 seg_inx	     fixed bin unal init (-1),
  3   173 	  2 offset	     fixed bin (18) unsigned unal init (0);
  3   174 
  3   175 
  3   176 dcl	LOCK_BLOCK_SIZE	     fixed bin int static options (constant) init (6);
  3   177 						/* Size of all lock blocks */
  3   178 
  3   179 dcl	LOCK_SEGNAME	     char (9) int static options (constant) init ("lock_seg_");
  3   180 
  3   181 dcl	lock_segno	     pic "999";
  3   182 
  3   183 dcl	(
  3   184 	LOCK_MESSAGE_DEADLOCK    init (1243657)
  3   185 	)		     fixed bin (71) int static options (constant);
  3   186 
  3   187 
  3   188 /* END INCLUDE FILE - dm_lm_system_data.incl.pl1 */
      798 
      799 
  4     1 /*  START OF:	dm_lm_copy_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*     Pointers to copied lock segments data.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*
  4    10*Written by Benson Margulies, 04/29/83.
  4    11*Modified:
  4    12*12/04/84 by Stanford S. Cox:  Added Description.
  4    13**/
  4    14 /* format:style3 */
  4    15 
  4    16 declare lm_copy_data_ptr pointer;
  4    17 declare 1 lm_copy_data aligned based (lm_copy_data_ptr),
  4    18 	2 version char (8) aligned,
  4    19           2 n_system_segments fixed bin, /* Output, for convienience */
  4    20 	2 n_segments fixed bin, /* Input */
  4    21 	2 segment_ptrs (lm_copy_data_n_segments refer (lm_copy_data.n_segments))
  4    22 		pointer;
  4    23 
  4    24 declare lm_copy_data_n_segments fixed bin;
  4    25 declare LM_COPY_DATA_VERSION_1 char (8) aligned init ("lmdt0001") int static options (constant);
  4    26 
  4    27 
  4    28 /*  END OF:	dm_lm_copy_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      800 
      801 
  5     1 /*  START OF:	dm_tm_txn_info.incl.pl1	*/
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*Designed by Matt Pierret, 01/26/82.
  5     6*Coded by Steve Herbst, 08/06/82.
  5     7*Modified:
  5     8*01/18/83 by Steve Herbst: Version 2, added new TDT info.
  5     9*05/06/83 by Steve Herbst: Version 3, added journal_info.
  5    10*05/27/83 by Steve Herbst: Version 4, added checkpoint_id & rollback_count.
  5    11*05/10/84 by Steve Herbst: Version 5, added bj_oid.
  5    12**/
  5    13 
  5    14 dcl  1	txn_info		aligned based (txn_info_ptr),
  5    15       2	version		char (8),			/* = "TXNINF05" */
  5    16       2	txn_id		bit (36) aligned,		/* unique id of transaction */
  5    17       2	txn_index		fixed bin,		/* index of TDT entry */
  5    18       2	mode		fixed bin,		/* mode in which transaction was begun */
  5    19       2	state		fixed bin,		/* current state of transaction */
  5    20       2	error_code	fixed bin (35),		/* nonzero if error_sw is ON */
  5    21       2	checkpoint_id	fixed bin,		/* number of current checkpoint (0 = begin) */
  5    22       2	rollback_count	fixed bin,		/* number of times bjm_$rollback has been called */
  5    23       2	owner_process_id	bit (36),			/* id of process that began and owns the txn */
  5    24       2	owner_name	char (32),		/* Person.Project of owner process */
  5    25       2	date_time_created	fixed bin (71),
  5    26       2	flags,
  5    27        3	dead_process_sw	bit (1) unaligned,
  5    28        3	suspended_sw	bit (1) unaligned,
  5    29        3	error_sw		bit (1) unaligned,
  5    30        3	abandoned_sw	bit (1) unaligned,
  5    31        3	kill_sw		bit (1) unaligned,
  5    32        3	mbz		bit (31) unaligned,
  5    33       2	journal_info	aligned,			/* NEW in Version 3 */
  5    34        3	bj_uid		bit (36),			/* UID of before journal chosen at begin time */
  5    35        3  bj_oid		bit (36),			/* perprocess opening id of before journal */
  5    36        3	last_completed_operation
  5    37 			char (4),
  5    38        3	first_bj_rec_id	bit (36),			/* id of first mark for this transaction */
  5    39        3	last_bj_rec_id	bit (36),			/* id of last mark for this transaction */
  5    40        3	n_rec_written	fixed bin (35),		/* number of marks written for this transaction */
  5    41        3	n_bytes_written	fixed bin (35);		/* total number of bytes written to the journal */
  5    42 
  5    43 
  5    44 dcl txn_info_ptr ptr;
  5    45 
  5    46 dcl TXN_INFO_VERSION_5 char (8) int static options (constant) init ("TXNINF05");
  5    47 
  5    48 
  5    49 /*  END OF:	dm_tm_txn_info.incl.pl1	*/
      802 
      803 
  6     1 /* BEGIN INCLUDE FILE -- print_data_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*          This structure is used by print_data to set various parameters
  6     5*     controlling the format of the output it produces.
  6     6*
  6     7*/* HISTORY:
  6     8*
  6     9*Written by Lindsey L. Spratt, 06/05/79.
  6    10*Modified:
  6    11*02/08/85 by Lindsey L. Spratt:  Fixed the HISTORY and DESCRIPTION sections.
  6    12**/
  6    13 
  6    14 /* format: style3,idind30,indcomtxt */
  6    15 dcl	print_data_info_version_1	fixed bin options (constant) init (1) internal static;
  6    16 
  6    17 dcl	print_data_info_ptr		ptr;
  6    18 dcl	1 print_data_info		based (print_data_info_ptr),
  6    19 	  2 version		fixed bin,
  6    20 	  2 indentation		fixed bin,	/* This sets the number of spaces by which structure level names are indented. */
  6    21 	  2 value_column		fixed bin,	/* This is the column in which the printing of values begins. */
  6    22 	  2 output_switch		ptr,		/* If null, user_output is used. */
  6    23 	  2 flags,
  6    24 	    3 octal		bit (1) unal,	/* Convert bit strings to octal. */
  6    25 	    3 hex			bit (1) unal,	/* hex, ditto */
  6    26 	    3 pad			bit (34) unaligned,
  6    27 	  2 intervals		char (256) varying;
  6    28 
  6    29 /* End include file print_data_info.incl.pl1 */
      804 
      805 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      806 
      807    end dm_lock_status;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0824.8  dm_lock_status.pl1                >spec>on>7192.pbf-04/04/85>dm_lock_status.pl1
794          1    01/07/85  0901.4  dm_lock_modes.incl.pl1            >ldd>include>dm_lock_modes.incl.pl1
796          2    01/07/85  0859.1  dm_lm_meters.incl.pl1             >ldd>include>dm_lm_meters.incl.pl1
798          3    01/07/85  0859.2  dm_lm_system_data.incl.pl1        >ldd>include>dm_lm_system_data.incl.pl1
800          4    01/07/85  0901.2  dm_lm_copy_data.incl.pl1          >ldd>include>dm_lm_copy_data.incl.pl1
802          5    01/07/85  0900.2  dm_tm_txn_info.incl.pl1           >ldd>include>dm_tm_txn_info.incl.pl1
804          6    03/06/85  1031.4  print_data_info.incl.pl1          >ldd>include>print_data_info.incl.pl1
806          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             001316 constant        bit(36)                  initial dcl 7-7 set ref 777*
ALL_TRANSACTIONS                006706 constant        fixed bin(35,0)          initial dcl 140 ref 291 303 378
ARGUMENT_TYPE                   000570 constant        varying char(64)         initial array dcl 148 set ref 492 492*
CONTROL_ARGUMENT                000044 constant        varying char(64)         initial array dcl 152 set ref 477 477 480 492*
CURRENT_TRANSACTION             006711 constant        fixed bin(35,0)          initial dcl 140 ref 113 386
DEFAULT_AREA_INFO_PTR           001314 constant        pointer                  initial dcl 146 set ref 218*
FILE_LOCK_CI_NUMBER             006710 constant        fixed bin(35,0)          initial dcl 145 ref 600 609
LM_COPY_DATA_VERSION_1          000032 constant        char(8)                  initial dcl 4-25 ref 745
LOCK_MESSAGE_DEADLOCK           000034 constant        fixed bin(71,0)          initial dcl 3-183
LOCK_MODE_NAMES                 000040 constant        char(3)                  initial array unaligned dcl 1-25 set ref 536* 679*
LOCK_SEG_VERSION_1              000036 constant        char(8)                  initial dcl 3-32 set ref 761*
NO                              006711 constant        bit(1)                   initial dcl 134 ref 92 93 94 96 99 108 236 269 271
                                                                                  287 300 371 404 422 440 458 600 604
NULL_VPTR                       000000 constant        structure                level 1 dcl 3-171 ref 550 556 662 668
TXN_INFO_VERSION_5              000030 constant        char(8)                  initial unaligned dcl 5-46 ref 519 653
TYPE_OBJECT                     006707 constant        fixed bin(17,0)          initial dcl 3-162 ref 593
TYPE_OWNER                      001374 constant        fixed bin(17,0)          initial dcl 3-162 set ref 552 614*
TYPE_WAITER                     001373 constant        fixed bin(17,0)          initial dcl 3-162 set ref 617*
YES                             001316 constant        bit(1)                   initial dcl 134 ref 89 91 110 206 222 228 230 275
                                                                                  295 370 383 391 395 400 409 413 418 427 431 436
                                                                                  445 449 454 463
accept_control_argument         000100 automatic       bit(1)                   initial dcl 80 set ref 80* 222* 228* 230 230* 236
addr                                                   builtin function         dcl 123 ref 248 248 254 290 521 521 678 678 749 749
arg                                    based           char                     unaligned dcl 117 set ref 228 228* 230* 352*
arg_idx                         000101 automatic       fixed bin(17,0)          dcl 82 set ref 225* 227*
arg_len                         000102 automatic       fixed bin(21,0)          dcl 83 set ref 227* 228 228 228 230 230 352 352
arg_list_ptr                    000104 automatic       pointer                  initial dcl 84 set ref 84* 213* 214*
arg_ptr                         000106 automatic       pointer                  dcl 85 set ref 227* 228 228 230 352
bin                                                    builtin function         dcl 123 ref 522 522 679 679
buckets                                based           structure                array level 2 dcl 3-80 ref 260 262 262 264 267 267
                                                                                  268 278 278
cai_control_argument_idx        000524 automatic       fixed bin(17,0)          dcl 474 set ref 477* 477* 480 482
cai_p_arg                              parameter       char                     unaligned dcl 473 ref 470 477
ci_no                     2            based           fixed bin(35,0)          level 2 dcl 580 set ref 600 609 609*
cleanup                         000254 stack reference condition                dcl 128 ref 211
code                            000111 automatic       fixed bin(35,0)          dcl 87 set ref 214* 282* 283 283 283* 521*
control_argument_idx            000112 automatic       fixed bin(17,0)          dcl 88 set ref 223* 228* 230* 233* 236 236*
cu_$arg_list_ptr                000032 constant        entry                    external dcl 175 ref 213
cur_txn_id                      000110 automatic       bit(36)                  dcl 86 set ref 281* 282* 283 291 305
cv_p_expected_version                  parameter       char(8)                  dcl 773 set ref 770 777 777*
cv_p_received_version                  parameter       char(8)                  dcl 774 set ref 770 777 777*
cv_p_structure_name                    parameter       char(32)                 dcl 775 set ref 770 777*
dbl_code                        000726 automatic       fixed bin(35,0)          initial dcl 648 set ref 648* 678*
dbl_indent                      000662 automatic       fixed bin(17,0)          initial dcl 636 set ref 636* 651* 661* 667* 674*
                                                                                  679*
dbl_lock_block                         based           structure                level 1 dcl 641
dbl_lock_block_ptr              000720 automatic       pointer                  dcl 640 set ref 657* 658 664 667 667* 672* 679* 682*
dbl_lock_block_vptr             000663 automatic       structure                level 1 dcl 638 set ref 650* 657* 661* 662* 668*
                                                                                  682*
dbl_lock_transaction_table             based           structure                level 1 dcl 646
dbl_lock_transaction_table_ptr  000724 automatic       pointer                  dcl 644 set ref 673* 674 678 679 679 679
dbl_lock_transaction_table_vptr 000722 automatic       structure                level 1 dcl 642 set ref 672* 673* 674*
dbl_p_first_block_vptr                 parameter       structure                level 1 dcl 626 ref 623 650
dbl_p_get_mode                         parameter       entry variable           dcl 632 ref 623 679
dbl_p_get_next_block_vptr              parameter       entry variable           dcl 633 ref 623 682
dbl_p_get_txn_vptr                     parameter       entry variable           dcl 631 ref 623 672
dbl_p_indent                           parameter       fixed bin(17,0)          dcl 628 ref 623 651
dbl_p_str                              parameter       char                     unaligned dcl 629 set ref 623 661* 667* 679*
dbl_p_type                             parameter       fixed bin(17,0)          dcl 630 ref 623 664
dbl_txi                         000664 automatic       structure                level 1 dcl 639 set ref 678 678
display_control_interval_locks  000113 automatic       bit(1)                   initial dcl 89 set ref 89* 413* 422* 604
display_file_locks              000114 automatic       bit(1)                   initial dcl 91 set ref 91* 395* 404* 600
display_hash_table              000115 automatic       bit(1)                   initial dcl 92 set ref 92* 256 449* 458*
display_header                  000116 automatic       bit(1)                   initial dcl 93 set ref 93* 241 431* 440*
dl_indent                       000614 automatic       fixed bin(17,0)          initial dcl 578 set ref 578* 584* 590* 596* 609*
                                                                                  612* 612 614* 617*
dl_lock_object                         based           structure                level 1 dcl 580
dl_lock_object_ptr              000616 automatic       pointer                  dcl 579 set ref 586* 587 593 596 596* 600 609 609
                                                                                  609 614 617
dl_p_indent                            parameter       fixed bin(17,0)          dcl 576 ref 571 584
dl_p_lock_object_vptr                  parameter       structure                level 1 dcl 574 set ref 571 586* 590*
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 161 ref 283
dm_error_$system_not_initialized
                                000014 external static fixed bin(35,0)          dcl 161 set ref 216*
dm_not_available_               000262 stack reference condition                dcl 128 ref 216
dt_indent                       000604 automatic       fixed bin(17,0)          initial dcl 516 set ref 516* 526* 532* 536* 537*
                                                                                  541* 541 549* 555* 560*
dt_lock_owner                          based           structure                level 1 dcl 510
dt_lock_owner_ptr               000544 automatic       pointer                  dcl 507 set ref 545* 546 552 555 555* 560 561
dt_lock_transaction_table              based           structure                level 1 dcl 511
dt_lock_waiter                         based           structure                level 1 dcl 513
dt_lock_waiter_ptr              000546 automatic       pointer                  dcl 508 set ref 531* 532 536 537
dt_p_lock_transaction_table_ptr        parameter       pointer                  dcl 503 ref 500 521 522 522 522 522 522 528 531 532
                                                                                  543
dt_process_vptr                 000542 automatic       structure                level 1 dcl 506 set ref 543* 545* 549* 550* 556*
                                                                                  561*
dt_txi                          000550 automatic       structure                level 1 dcl 514 set ref 518* 521 521
duplication_indicator_has_been_displayed
                                000117 automatic       bit(1)                   initial dcl 94 set ref 94* 269* 271 275*
error_table_$bad_arg            000016 external static fixed bin(35,0)          dcl 161 set ref 352*
error_table_$badopt             000020 external static fixed bin(35,0)          dcl 161 set ref 375*
error_table_$noarg              000022 external static fixed bin(35,0)          dcl 161 set ref 492*
error_table_$smallarg           000024 external static fixed bin(35,0)          dcl 161 ref 741 742
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 161 set ref 777*
ev_channel                4            based           fixed bin(71,0)          level 2 dcl 511 set ref 522 522*
flags                     6     000126 automatic       structure                level 2 dcl 102
force_interpretation_as_argument
                                000120 automatic       bit(1)                   initial dcl 96 set ref 96* 228 230*
get_temp_segments_              000034 constant        entry                    external dcl 176 ref 746
gs_code                         000744 automatic       fixed bin(35,0)          initial dcl 737 set ref 737* 741* 742 743* 746* 747
                                                                                  747* 749* 750 757 757*
gs_try_idx                      000745 automatic       fixed bin(17,0)          dcl 738 set ref 742*
hash_table                             based           structure                level 2 dcl 3-34 set ref 254
hash_table_idx                  000121 automatic       fixed bin(17,0)          dcl 98 set ref 259* 262* 262 262 263* 264 267* 267
                                                                                  267 268* 278* 278 278
hash_table_offset        14            based           fixed bin(18,0)          level 3 unsigned dcl 3-34 ref 253
hbound                                                 builtin function         dcl 123 ref 289 477 480
header                    2            based           structure                level 2 dcl 3-34 ref 246
indentation               1     000126 automatic       fixed bin(17,0)          level 2 dcl 102 set ref 203*
index                                                  builtin function         dcl 123 ref 228 492
intervals                 7     000126 automatic       varying char(256)        level 2 dcl 102 set ref 207*
ioa_                            000036 constant        entry                    external dcl 177 ref 250 254 261 262 267 274 278 303
                                                                                  305 307 522 536 555 565 596 609 667 679 789
is_active_function              000122 automatic       bit(1)                   initial dcl 99 set ref 99*
lm_copy_data                           based           structure                level 1 dcl 4-17 set ref 744 749 749 754
lm_copy_data_n_segments         000332 automatic       fixed bin(17,0)          dcl 4-24 set ref 729 743* 744 744
lm_copy_data_ptr                000330 automatic       pointer                  dcl 4-16 set ref 209* 325 325 335* 744* 745 746 749
                                                                                  749 753 754 760 763
lock_block                             based           structure                level 1 dcl 3-84
lock_hash_table                        based           structure                level 1 dcl 3-80
lock_hash_table_ptr             000276 automatic       pointer                  dcl 3-18 set ref 253* 254 260 262 262 264 267 267
                                                                                  268 278 278
lock_manager_$copy_data         000040 constant        entry                    external dcl 178 ref 749
lock_manager_$system_segment_count
                                000042 constant        entry                    external dcl 180 ref 743
lock_meters                            based           structure                level 1 dcl 2-20
lock_object                            based           structure                level 1 dcl 3-100
lock_owner                             based           structure                level 1 dcl 3-113
lock_ptr                  1            based           structure                level 2 in structure "dt_lock_owner" dcl 510
                                                                                  in procedure "DISPLAY_TRANSACTION" set ref 560*
lock_ptr                  1            based           structure                level 2 in structure "dt_lock_waiter" dcl 513
                                                                                  in procedure "DISPLAY_TRANSACTION" set ref 537*
lock_seg                               based           structure                level 1 dcl 3-34
lock_seg_ptr                    000272 automatic       pointer                  dcl 3-15 set ref 246 246 253 253 254 263 289 290
                                                                                  760* 761 762 763 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34
lock_segments                          based           structure                level 1 dcl 3-142 set ref 762
lock_segments_ptr               000314 automatic       pointer                  dcl 3-25 set ref 209* 335* 731 762* 763
lock_transaction_table                 based           structure                level 1 dcl 3-69
lock_transaction_table_ptr      000274 automatic       pointer                  dcl 3-16 set ref 290* 291 291 296*
lock_virtual_ptr                       based           structure                level 1 dcl 3-145
lock_waiter                            based           structure                level 1 dcl 3-128
mode                      2            based           fixed bin(17,0)          level 2 in structure "ogtv_p_lock_owner" dcl 691
                                                                                  in procedure "OWNER_GET_TXN_VPTR" ref 697
mode                      2            based           fixed bin(17,0)          level 2 in structure "dt_lock_waiter" dcl 513
                                                                                  in procedure "DISPLAY_TRANSACTION" ref 536
mode                      2            based           fixed bin(17,0)          level 2 in structure "wgtv_p_lock_waiter" dcl 707
                                                                                  in procedure "WAITER_GET_TXN_VPTR" ref 713
myname                          001317 constant        char(14)                 initial unaligned dcl 133 set ref 214* 325* 746*
                                                                                  753* 777*
n_hash_table_entries     10            based           fixed bin(17,0)          level 3 dcl 3-34 ref 263 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
n_lock_segments           4            based           fixed bin(17,0)          level 3 dcl 3-34 ref 762 763
n_segments                3            based           fixed bin(17,0)          level 2 dcl 4-17 set ref 325 744* 746 753 754 763
n_transaction_table_entries
                          7            based           fixed bin(17,0)          level 3 dcl 3-34 ref 254 289 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34 3-34
                                                                                  3-34
null                                                   builtin function         dcl 123 ref 84 104 105 106 107 205 209 325 335 532
                                                                                  546 587 658 674 729 777 777
number_of_args                  000123 automatic       fixed bin(17,0)          dcl 100 set ref 220* 225
octal                     6     000126 automatic       bit(1)                   level 3 packed unaligned dcl 102 set ref 206*
offset                    0(18)        parameter       fixed bin(18,0)          level 2 packed unsigned unaligned dcl 725 ref 731
ogtv_p_lock_owner                      based           structure                level 1 dcl 691
ogtv_p_lock_owner_ptr                  parameter       pointer                  dcl 690 ref 688 693 695 697 699 701
output_switch             4     000126 automatic       pointer                  level 2 dcl 102 set ref 205*
own_ptr                   6            based           structure                level 2 dcl 511 ref 543
owner_name               12     000664 automatic       char(32)                 level 2 in structure "dbl_txi" dcl 639 in procedure
                                                                                  "DISPLAY_BLOCK_LIST" set ref 654* 679*
owner_name               12     000550 automatic       char(32)                 level 2 in structure "dt_txi" dcl 514 in procedure
                                                                                  "DISPLAY_TRANSACTION" set ref 520* 522*
owners_fp                 3            based           structure                level 2 dcl 691 ref 701
owners_ptr                3            based           structure                level 2 dcl 580 set ref 614*
pa_code                         000506 automatic       fixed bin(35,0)          dcl 347 set ref 349*
pa_p_accept_control_argument           parameter       bit(1)                   dcl 344 ref 338
pa_p_arg                               parameter       char                     unaligned dcl 341 ref 338
pa_p_control_argument_idx              parameter       fixed bin(17,0)          dcl 342 ref 338 351
pca_p_accept_control_argument          parameter       bit(1)                   dcl 364 set ref 357 370* 383* 391* 400* 409* 418*
                                                                                  427* 436* 445* 454* 463*
pca_p_arg                              parameter       char                     unaligned dcl 361 set ref 357 369* 375*
pca_p_control_argument_idx             parameter       fixed bin(17,0)          dcl 362 set ref 357 369* 373 382* 390* 399* 408*
                                                                                  417* 426* 435* 444* 453* 462*
pca_p_force_interpretation_as_argument parameter       bit(1)                   dcl 366 set ref 357 371*
pdi                             000126 automatic       structure                level 1 dcl 102 set ref 248 248
previous_bucket                 000124 automatic       bit(36)                  dcl 101 set ref 260* 264 268*
print_data_                     000044 constant        entry                    external dcl 182 ref 248
print_data_info                        based           structure                level 1 unaligned dcl 6-18
print_data_info_version_1       006706 constant        fixed bin(17,0)          initial dcl 6-15 ref 202
process_id                1            based           bit(36)                  level 2 in structure "dbl_lock_transaction_table"
                                                                                  dcl 646 in procedure "DISPLAY_BLOCK_LIST" set ref
                                                                                  679*
process_id                1            based           bit(36)                  level 2 in structure "dt_lock_transaction_table"
                                                                                  dcl 511 in procedure "DISPLAY_TRANSACTION" set ref
                                                                                  522*
ptr                                                    builtin function         dcl 123 ref 731
ptr_p_lock_virtual_ptr                 parameter       structure                level 1 dcl 725 ref 722
release_temp_segments_          000046 constant        entry                    external dcl 183 ref 325 753
return_arg_len                  000236 automatic       fixed bin(21,0)          initial dcl 103 set ref 103*
return_arg_ptr                  000240 automatic       pointer                  initial dcl 104 set ref 104*
rivp_p_indent                          parameter       fixed bin(17,0)          dcl 785 set ref 783 789*
rivp_p_str                             parameter       char                     unaligned dcl 786 set ref 783 789*
rivp_p_virtual_ptr                     parameter       structure                level 1 dcl 787 set ref 783
rma_p_control_argument_idx             parameter       fixed bin(17,0)          dcl 489 ref 487 492 492 492
sci_ptr                         000242 automatic       pointer                  initial dcl 105 set ref 105* 214* 216* 218* 220*
                                                                                  227* 244* 283* 328* 329* 331* 352* 375* 492* 747*
                                                                                  757*
seg_baseptr                            based           pointer                  array level 2 packed unaligned dcl 3-142 set ref 731
                                                                                  763*
seg_inx                         000663 automatic       fixed bin(17,0)          level 2 in structure "dbl_lock_block_vptr" packed
                                                                                  unaligned dcl 638 in procedure
                                                                                  "DISPLAY_BLOCK_LIST" set ref 656
seg_inx                   7            based           fixed bin(17,0)          level 3 in structure "dt_lock_transaction_table"
                                                                                  packed unaligned dcl 511 in procedure
                                                                                  "DISPLAY_TRANSACTION" set ref 528
seg_inx                                parameter       fixed bin(17,0)          level 2 in structure "ptr_p_lock_virtual_ptr" packed
                                                                                  unaligned dcl 725 in procedure "PTR" ref 729 729
                                                                                  731
seg_inx                         000000 constant        fixed bin(17,0)          initial level 2 in structure "NULL_VPTR" packed
                                                                                  unaligned dcl 3-171 in procedure "dm_lock_status"
                                                                                  ref 528 544 656
seg_inx                         000542 automatic       fixed bin(17,0)          level 2 in structure "dt_process_vptr" packed
                                                                                  unaligned dcl 506 in procedure
                                                                                  "DISPLAY_TRANSACTION" set ref 544
segment_ptrs              4            based           pointer                  array level 2 dcl 4-17 set ref 325* 746* 753* 760
                                                                                  763
setwordno                                              builtin function         dcl 123 ref 253
ssu_$abort_line                 000050 constant        entry                    external dcl 184 ref 216 283 352 375 492 747 757
ssu_$arg_count                  000052 constant        entry                    external dcl 185 ref 220
ssu_$arg_ptr                    000054 constant        entry                    external dcl 186 ref 227
ssu_$destroy_invocation         000056 constant        entry                    external dcl 187 ref 331
ssu_$get_area                   000060 constant        entry                    external dcl 189 ref 218
ssu_$get_temp_segment           000062 constant        entry                    external dcl 190 ref 244
ssu_$release_area               000064 constant        entry                    external dcl 191 ref 328
ssu_$release_temp_segment       000066 constant        entry                    external dcl 192 ref 329
ssu_$standalone_invocation      000070 constant        entry                    external dcl 194 ref 214
ssu_area                               based           area(1024)               dcl 118 ref 744 762
ssu_area_ptr                    000244 automatic       pointer                  initial dcl 106 set ref 106* 218* 328* 744 762
sub_err_                        000072 constant        entry                    external dcl 196 ref 777
substr                                                 builtin function         dcl 123 ref 492
sys_info$max_seg_size           000030 external static fixed bin(35,0)          dcl 171 ref 246 248
temp_string                            based           varying char             dcl 119 set ref 246* 248*
temp_string_ptr                 000246 automatic       pointer                  initial dcl 107 set ref 107* 244* 246 248 329*
there_is_an_active_transaction  000250 automatic       bit(1)                   initial dcl 108 set ref 108* 287* 295* 300
this_is_a_standalone_invocation 000251 automatic       bit(1)                   initial dcl 110 set ref 110* 331
transaction_fp            4            based           structure                level 2 dcl 510 ref 561
transaction_idx                 000252 automatic       fixed bin(17,0)          dcl 112 set ref 289* 290*
transaction_manager_$get_current_txn_id
                                000074 constant        entry                    external dcl 197 ref 282
transaction_manager_$get_txn_info
                                000076 constant        entry                    external dcl 199 ref 521 678
transaction_ptr           4            based           structure                level 2 in structure "wgtv_p_lock_waiter" dcl 707
                                                                                  in procedure "WAITER_GET_TXN_VPTR" ref 709
transaction_ptr           5            based           structure                level 2 in structure "ogtv_p_lock_owner" dcl 691
                                                                                  in procedure "OWNER_GET_TXN_VPTR" ref 693
transaction_selection           000253 automatic       fixed bin(35,0)          initial dcl 113 set ref 113* 291 303 378* 386*
transaction_table        20            based           structure                array level 2 dcl 3-34 set ref 289 290
txn_id                    2            based           bit(36)                  level 2 in structure "lock_transaction_table"
                                                                                  dcl 3-69 in procedure "dm_lock_status" ref 291 291
txn_id                    2            based           bit(36)                  level 2 in structure "dt_lock_transaction_table"
                                                                                  dcl 511 in procedure "DISPLAY_TRANSACTION" set ref
                                                                                  521* 522 522
txn_id                    2            based           bit(36)                  level 2 in structure "dbl_lock_transaction_table"
                                                                                  dcl 646 in procedure "DISPLAY_BLOCK_LIST" set ref
                                                                                  678* 679 679
txn_info                               based           structure                level 1 dcl 5-14
type                      0(18)        based           fixed bin(17,0)          level 2 in structure "dbl_lock_block" packed
                                                                                  unaligned dcl 641 in procedure
                                                                                  "DISPLAY_BLOCK_LIST" set ref 664 667*
type                      0(18)        based           fixed bin(17,0)          level 2 in structure "dl_lock_object" packed
                                                                                  unaligned dcl 580 in procedure "DISPLAY_LOCK" set
                                                                                  ref 593 596*
type                      0(18)        based           fixed bin(17,0)          level 2 in structure "dt_lock_owner" packed
                                                                                  unaligned dcl 510 in procedure
                                                                                  "DISPLAY_TRANSACTION" set ref 552 555*
uid                       1            based           bit(36)                  level 2 dcl 580 set ref 609*
unspec                                                 builtin function         dcl 123 set ref 260 262 262 264 267 267 268 278 278
                                                                                  518*
value_column              2     000126 automatic       fixed bin(17,0)          level 2 dcl 102 set ref 204*
version                                based           char(8)                  level 2 in structure "lm_copy_data" dcl 4-17
                                                                                  in procedure "dm_lock_status" set ref 745*
version                         000664 automatic       char(8)                  level 2 in structure "dbl_txi" dcl 639 in procedure
                                                                                  "DISPLAY_BLOCK_LIST" set ref 653*
version                         000126 automatic       fixed bin(17,0)          level 2 in structure "pdi" dcl 102 in procedure
                                                                                  "dm_lock_status" set ref 202*
version                         000550 automatic       char(8)                  level 2 in structure "dt_txi" dcl 514 in procedure
                                                                                  "DISPLAY_TRANSACTION" set ref 519*
version                                based           char(8)                  level 2 in structure "lock_seg" dcl 3-34
                                                                                  in procedure "dm_lock_status" set ref 246 761*
wait_ptr                  7            based           structure                level 2 dcl 511 set ref 531* 532*
waiters_fp                3            based           structure                level 2 dcl 707 ref 717
waiters_ptr               4            based           structure                level 2 dcl 580 set ref 617*
wgtv_p_lock_waiter                     based           structure                level 1 dcl 707
wgtv_p_lock_waiter_ptr                 parameter       pointer                  dcl 706 ref 704 709 711 713 715 717

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     constant        bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 constant        bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   constant        bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  constant        bit(36)                  initial dcl 7-7
LOCK_BLOCK_SIZE                        constant        fixed bin(17,0)          initial dcl 3-176
LOCK_ENTIRE_FILE                       constant        fixed bin(27,0)          initial dcl 1-23
LOCK_METERS_VERSION_1                  constant        char(8)                  initial dcl 2-17
LOCK_MODE_IS                           constant        fixed bin(17,0)          initial dcl 1-19
LOCK_MODE_IX                           constant        fixed bin(17,0)          initial dcl 1-20
LOCK_MODE_S                            constant        fixed bin(17,0)          initial dcl 1-17
LOCK_MODE_SIX                          constant        fixed bin(17,0)          initial dcl 1-21
LOCK_MODE_X                            constant        fixed bin(17,0)          initial dcl 1-18
LOCK_SEGNAME                           constant        char(9)                  initial unaligned dcl 3-179
MAX_TYPE                               constant        fixed bin(17,0)          initial dcl 3-162
TYPE_FREE                              constant        fixed bin(17,0)          initial dcl 3-162
dl_txi                          000620 automatic       structure                level 1 dcl 581
lock_aux_seg                           based           structure                level 1 dcl 3-62
lock_aux_seg_ptr                000300 automatic       pointer                  dcl 3-19
lock_block_array                       based           structure                array level 1 dcl 3-90
lock_block_array_ptr            000304 automatic       pointer                  dcl 3-21
lock_block_ptr                  000302 automatic       pointer                  dcl 3-20
lock_deadlock                          based           structure                level 1 dcl 3-149
lock_deadlock_36                       based           structure                level 1 dcl 3-152
lock_deadlock_72                       based           structure                level 1 dcl 3-155
lock_deadlock_ptr               000320 automatic       pointer                  dcl 3-27
lock_deadlock_txn_ids                  based           bit(36)                  array dcl 3-161
lock_deadlock_txn_ids_ptr       000324 automatic       pointer                  dcl 3-159
lock_free_block                        based           structure                level 1 dcl 3-92
lock_free_block_ptr             000306 automatic       pointer                  dcl 3-22
lock_meters_ptr                 000270 automatic       pointer                  dcl 2-16
lock_object_ptr                 000310 automatic       pointer                  dcl 3-23
lock_owner_ptr                  000312 automatic       pointer                  dcl 3-24
lock_segno                      000326 automatic       picture(3)               unaligned dcl 3-181
lock_waiter_ptr                 000316 automatic       pointer                  dcl 3-26
n_lock_blocks                   000322 automatic       fixed bin(17,0)          dcl 3-29
n_lock_deadlock                 000323 automatic       fixed bin(17,0)          dcl 3-30
print_data_info_ptr             000336 automatic       pointer                  dcl 6-17
txn_info_ptr                    000334 automatic       pointer                  dcl 5-44

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_ENTRY                     004030 constant        entry                    internal dcl 315 ref 214 214
ARGUMENT                        000001 constant        label                    array(-1:-1) dcl 352 set ref 351
ARG_PROCESSING_LOOP             003030 constant        label                    dcl 225
CHECK_VERSION                   006454 constant        entry                    internal dcl 770 ref 761
CLEANUP                         004046 constant        entry                    internal dcl 323 ref 211 310 317
CONTROL_ARGUMENT                000002 constant        label                    array(-1:20) dcl 375 ref 373
CONTROL_ARGUMENT_INDEX          004373 constant        entry                    internal dcl 470 ref 369
DISPLAY_BLOCK_LIST              005374 constant        entry                    internal dcl 623 ref 614 617
DISPLAY_LOCK                    005066 constant        entry                    internal dcl 571 ref 537 560
DISPLAY_TRANSACTION             004517 constant        entry                    internal dcl 500 ref 296
GET_SEGMENT_PTRS                006147 constant        entry                    internal dcl 735 ref 239
MAIN_RETURN                     004026 constant        label                    dcl 312 ref 318
OWNER_GET_MODE                  005735 constant        entry                    internal dcl 695 ref 614 614
OWNER_GET_NEXT_BLOCK_VPTR       005770 constant        entry                    internal dcl 699 ref 614 614
OWNER_GET_TXN_VPTR              005710 constant        entry                    internal dcl 688 ref 614 614
PROCESS_ARGUMENT                004155 constant        entry                    internal dcl 338 ref 228
PROCESS_CONTROL_ARGUMENT        004226 constant        entry                    internal dcl 357 ref 230
PTR                             006123 constant        entry                    internal dcl 722 ref 531 545 586 657 673
REPORT_INVALID_VIRTUAL_POINTER  006546 constant        entry                    internal dcl 783 ref 532 549 590 661 674
REPORT_MISSING_ARGUMENT         004437 constant        entry                    internal dcl 487 ref 233 236
WAITER_GET_MODE                 006043 constant        entry                    internal dcl 711 ref 617 617
WAITER_GET_NEXT_BLOCK_VPTR      006076 constant        entry                    internal dcl 715 ref 617 617
WAITER_GET_TXN_VPTR             006016 constant        entry                    internal dcl 704 ref 617 617
dm_lock_status                  002564 constant        entry                    external dcl 75

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7402        7502    6712        7412
Length     12000    6712       100        2262     470           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dm_lock_status                     1016 external procedure  is an external procedure.  
on unit on line 211                  64 on unit               
on unit on line 216                  74 on unit               
ABORT_ENTRY                          64 internal procedure  is assigned to an entry variable.  
CLEANUP                              86 internal procedure  is called by several nonquick procedures.  
PROCESS_ARGUMENT                        internal procedure  shares stack frame of external procedure dm_lock_status.  
PROCESS_CONTROL_ARGUMENT                internal procedure  shares stack frame of external procedure dm_lock_status.  
CONTROL_ARGUMENT_INDEX                  internal procedure  shares stack frame of external procedure dm_lock_status.  
REPORT_MISSING_ARGUMENT                 internal procedure  shares stack frame of external procedure dm_lock_status.  
DISPLAY_TRANSACTION                     internal procedure  shares stack frame of external procedure dm_lock_status.  
DISPLAY_LOCK                            internal procedure  shares stack frame of external procedure dm_lock_status.  
DISPLAY_BLOCK_LIST                      internal procedure  shares stack frame of external procedure dm_lock_status.  
OWNER_GET_TXN_VPTR                   67 internal procedure  is assigned to an entry variable.  
WAITER_GET_TXN_VPTR                  67 internal procedure  is assigned to an entry variable.  
PTR                                     internal procedure  shares stack frame of external procedure dm_lock_status.  
GET_SEGMENT_PTRS                        internal procedure  shares stack frame of external procedure dm_lock_status.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure dm_lock_status.  
REPORT_INVALID_VIRTUAL_POINTER
                                        internal procedure  shares stack frame of external procedure dm_lock_status.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dm_lock_status           000100 accept_control_argument     dm_lock_status
                         000101 arg_idx                     dm_lock_status
                         000102 arg_len                     dm_lock_status
                         000104 arg_list_ptr                dm_lock_status
                         000106 arg_ptr                     dm_lock_status
                         000110 cur_txn_id                  dm_lock_status
                         000111 code                        dm_lock_status
                         000112 control_argument_idx        dm_lock_status
                         000113 display_control_interval_locks
                                                            dm_lock_status
                         000114 display_file_locks          dm_lock_status
                         000115 display_hash_table          dm_lock_status
                         000116 display_header              dm_lock_status
                         000117 duplication_indicator_has_been_displayed
                                                            dm_lock_status
                         000120 force_interpretation_as_argument
                                                            dm_lock_status
                         000121 hash_table_idx              dm_lock_status
                         000122 is_active_function          dm_lock_status
                         000123 number_of_args              dm_lock_status
                         000124 previous_bucket             dm_lock_status
                         000126 pdi                         dm_lock_status
                         000236 return_arg_len              dm_lock_status
                         000240 return_arg_ptr              dm_lock_status
                         000242 sci_ptr                     dm_lock_status
                         000244 ssu_area_ptr                dm_lock_status
                         000246 temp_string_ptr             dm_lock_status
                         000250 there_is_an_active_transaction
                                                            dm_lock_status
                         000251 this_is_a_standalone_invocation
                                                            dm_lock_status
                         000252 transaction_idx             dm_lock_status
                         000253 transaction_selection       dm_lock_status
                         000270 lock_meters_ptr             dm_lock_status
                         000272 lock_seg_ptr                dm_lock_status
                         000274 lock_transaction_table_ptr  dm_lock_status
                         000276 lock_hash_table_ptr         dm_lock_status
                         000300 lock_aux_seg_ptr            dm_lock_status
                         000302 lock_block_ptr              dm_lock_status
                         000304 lock_block_array_ptr        dm_lock_status
                         000306 lock_free_block_ptr         dm_lock_status
                         000310 lock_object_ptr             dm_lock_status
                         000312 lock_owner_ptr              dm_lock_status
                         000314 lock_segments_ptr           dm_lock_status
                         000316 lock_waiter_ptr             dm_lock_status
                         000320 lock_deadlock_ptr           dm_lock_status
                         000322 n_lock_blocks               dm_lock_status
                         000323 n_lock_deadlock             dm_lock_status
                         000324 lock_deadlock_txn_ids_ptr   dm_lock_status
                         000326 lock_segno                  dm_lock_status
                         000330 lm_copy_data_ptr            dm_lock_status
                         000332 lm_copy_data_n_segments     dm_lock_status
                         000334 txn_info_ptr                dm_lock_status
                         000336 print_data_info_ptr         dm_lock_status
                         000506 pa_code                     PROCESS_ARGUMENT
                         000524 cai_control_argument_idx    CONTROL_ARGUMENT_INDEX
                         000542 dt_process_vptr             DISPLAY_TRANSACTION
                         000544 dt_lock_owner_ptr           DISPLAY_TRANSACTION
                         000546 dt_lock_waiter_ptr          DISPLAY_TRANSACTION
                         000550 dt_txi                      DISPLAY_TRANSACTION
                         000604 dt_indent                   DISPLAY_TRANSACTION
                         000614 dl_indent                   DISPLAY_LOCK
                         000616 dl_lock_object_ptr          DISPLAY_LOCK
                         000620 dl_txi                      DISPLAY_LOCK
                         000662 dbl_indent                  DISPLAY_BLOCK_LIST
                         000663 dbl_lock_block_vptr         DISPLAY_BLOCK_LIST
                         000664 dbl_txi                     DISPLAY_BLOCK_LIST
                         000720 dbl_lock_block_ptr          DISPLAY_BLOCK_LIST
                         000722 dbl_lock_transaction_table_vptr
                                                            DISPLAY_BLOCK_LIST
                         000724 dbl_lock_transaction_table_ptr
                                                            DISPLAY_BLOCK_LIST
                         000726 dbl_code                    DISPLAY_BLOCK_LIST
                         000744 gs_code                     GET_SEGMENT_PTRS
                         000745 gs_try_idx                  GET_SEGMENT_PTRS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             call_var            call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              tra_ext             bound_check_signal  mpfx2
signal              enable              ext_entry           int_entry           put_end             stream_io
put_data_eis        alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              get_temp_segments_            ioa_                          lock_manager_$copy_data
lock_manager_$system_segment_count                          print_data_                   release_temp_segments_
ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr                  ssu_$destroy_invocation
ssu_$get_area                 ssu_$get_temp_segment         ssu_$release_area             ssu_$release_temp_segment
ssu_$standalone_invocation    sub_err_                      transaction_manager_$get_current_txn_id
transaction_manager_$get_txn_info

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_current_transaction                            dm_error_$system_not_initialized
error_table_$bad_arg          error_table_$badopt           error_table_$noarg            error_table_$smallarg
error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     75 002563        80 002602        84 002603        89 002605        91 002607        92 002610        93 002611
     94 002612        96 002613        99 002614       103 002615       104 002616       105 002620       106 002621
    107 002622       108 002623       110 002624       113 002626       202 002630       203 002632       204 002634
    205 002636       206 002640       207 002642       209 002643       211 002646       213 002670       214 002677
    216 002736       218 002770       220 003013       222 003024       223 003026       225 003030       227 003037
    228 003054       230 003120       233 003153       234 003155       236 003157       239 003166       241 003167
    244 003171       246 003211       248 003346       250 003406       253 003413       254 003420       256 003445
    259 003447       260 003451       261 003453       262 003467       263 003520       264 003531       267 003535
    268 003565       269 003571       270 003572       271 003573       274 003575       275 003610       277 003612
    278 003614       281 003645       282 003646       283 003657       287 003711       289 003712       290 003723
    291 003727       295 003737       296 003741       298 003743       300 003745       303 003747       305 003767
    307 004006       310 004022       312 004026       315 004027       317 004035       318 004042       323 004045
    325 004053       328 004112       329 004124       331 004136       335 004150       336 004154       338 004155
    349 004166       351 004167       352 004172       354 004225       357 004226       369 004237       370 004255
    371 004260       373 004261       375 004263       378 004305       382 004307       383 004312       384 004314
    386 004315       390 004317       391 004321       392 004322       395 004323       399 004324       400 004326
    401 004327       404 004330       408 004331       409 004333       410 004334       413 004335       417 004336
    418 004340       419 004341       422 004342       426 004343       427 004345       428 004346       431 004347
    435 004350       436 004352       437 004353       440 004354       444 004355       445 004357       446 004360
    449 004361       453 004362       454 004364       455 004365       458 004366       462 004367       463 004371
    464 004372       470 004373       477 004404       479 004423       480 004425       482 004434       487 004437
    492 004441       496 004516       500 004517       516 004521       518 004522       519 004525       520 004527
    521 004532       522 004551       526 004621       528 004623       531 004635       532 004645       536 004677
    537 004730       541 004741       543 004743       544 004750       545 004757       546 004761       549 004765
    550 004772       551 004774       552 004775       555 005002       556 005034       557 005036       560 005037
    561 005050       563 005053       565 005054       567 005065       571 005066       578 005070       584 005071
    586 005073       587 005103       590 005107       591 005132       593 005133       596 005140       597 005172
    600 005173       603 005202       604 005203       609 005206       612 005247       614 005251       617 005322
    621 005373       623 005374       636 005405       648 005406       650 005407       651 005412       653 005414
    654 005416       656 005421       657 005431       658 005433       661 005437       662 005461       663 005463
    664 005464       667 005472       668 005531       669 005533       672 005534       673 005546       674 005550
    678 005564       679 005602       682 005672       685 005705       686 005706       688 005707       693 005717
    695 005734       697 005743       699 005767       701 005777       704 006015       709 006025       711 006042
    713 006051       715 006075       717 006105       722 006123       729 006125       731 006136       735 006147
    737 006150       741 006151       742 006154       743 006165       744 006175       745 006206       746 006211
    747 006243       749 006271       750 006304       753 006306       754 006341       756 006347       757 006351
    760 006377       761 006402       762 006417       763 006425       764 006453       770 006454       777 006456
    781 006545       783 006546       789 006557       792 006617


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
