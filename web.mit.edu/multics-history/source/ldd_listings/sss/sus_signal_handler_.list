	COMPILATION LISTING OF SEGMENT sus_signal_handler_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/29/88  0920.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-01-17,Swenson), approve(86-07-31,MCR7443), audit(86-07-31,Wong),
       14*     install(86-08-21,MR12.0-1137):
       15*     Changed to allow the IPC wakeup which kicks the process into execution
       16*     after a suspension to come from any process.  This is required so that the
       17*     login server process can send the wakeup.  Since process suspension can be
       18*     arbitrarily spoofed and replaced anyway, this presents no security
       19*     problem.
       20*  2) change(87-10-09,GDixon), approve(88-08-15,MCR7969),
       21*     audit(88-08-04,Lippard), install(88-08-29,MR12.2-1093):
       22*      A) Changed to call the term_signal_handler_ entrypoint of logout,
       23*         rather than the logout entrypoint, when the no_save_on_disconnect
       24*         command has been issued by the user.  Use of this command should
       25*         cause terminal disconnections to be indistinguishable from the case
       26*         in which the process does not have the save_on_disconnect attribute.
       27*         In that case, dialup_ signals trm_ (instead of sus_) which invokes
       28*         the term_signal_handler_.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 /* format: style2 */
       32 sus_signal_handler_:
       33      procedure;
       34 
       35 /* Handler for ips signal "sus_". A process receiving this signal
       36*   must suspend itself until the initializer signals it that it may run again.
       37*   If it fails to respond within a site-settable real time interval, or
       38*   uses more than a site-settable amount of cpu time while it is suspended,
       39*   it will be destroyed.
       40*
       41*   Throughout this procedure, we ignore all nonzero return codes, because we
       42*have no way to report them.  If we're non-absentee, we most likely have no
       43*terminal to print output on, and an error message would either go into the
       44*bit bucket or cause a fatal I/O error in the process.  And whatever our
       45*process type, we have a limited quota of cpu time to use while suspended, and
       46*it would be unwise to waste it in calls to com_err_.
       47*
       48*   Written by T. Casey, February 1979.
       49*   Modified July 1979 by T. Casey for MR8.0 for suspension of interactive 
       50*     processes whose terminals have hung up.
       51*   Modified December 1980 by Benson I. Margulies to extend reconnection to 
       52*     other io modules.
       53*   Modified November 1981 by E. N. Kittlitz for terminal_reconnect.ec.
       54*   Modified December 1983 by Jon A. Rochlis to try the "reconnection" control
       55*     order on the -login_channel switch, and to put back the call to 
       56*     user_info_$outer_module, removing special casing for tty_ and netd_.
       57*
       58*   */
       59 
       60 /* DECLARATIONS */
       61 
       62 /* Internal static */
       63 
       64 	dcl     all_name		 (1) char (32) int static options (constant) init ("-all");
       65 						/* to turn on all ips's before signalling QUIT */
       66 	dcl     reconnect_ec_entry	 char (32) int static options (constant) init ("reconnect.ec");
       67 
       68 	dcl     trm_name		 (1) char (32) int static options (constant) init ("trm_");
       69 						/* to mask off everything but trm_ */
       70 	dcl     nosave_switch	 bit (1) aligned int static init (""b);
       71 
       72 	dcl     ec_reconnect_switch	 bit (1) aligned int static init (""b);
       73 
  1     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  1     2 
  1     3 /* Structure for find_condition_info_.
  1     4*
  1     5*   Written 1-Mar-79 by M. N. Davidoff.
  1     6**/
  1     7 
  1     8 /* automatic */
  1     9 
  1    10      declare condition_info_ptr     pointer;
  1    11 
  1    12 /* based */
  1    13 
  1    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  1    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  1    16 	     2 version	      fixed binary,		/* Must be 1 */
  1    17 	     2 condition_name     char (32) varying,	/* name of condition */
  1    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  1    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  1    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  1    21 	     2 flags	      unaligned,
  1    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  1    23 	       3 pad1	      bit (35),
  1    24 	     2 pad2	      bit (36),
  1    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  1    26 	     2 pad3	      (4) bit (36);
  1    27 
  1    28 /* internal static */
  1    29 
  1    30      declare condition_info_version_1
  1    31 			      fixed binary internal static options (constant) initial (1);
  1    32 
  1    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
       74 
  2     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  2     2 /* format: style2 */
  2     3 
  2     4      declare condition_info_header_ptr
  2     5 			      pointer;
  2     6      declare 1 condition_info_header
  2     7 			      aligned based (condition_info_header_ptr),
  2     8 	     2 length	      fixed bin,		/* length in words of this structure */
  2     9 	     2 version	      fixed bin,		/* version number of this structure */
  2    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  2    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  2    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  2    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  2    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  2    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  2    16 	       3 pad	      bit (32) unaligned,
  2    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  2    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  2    19 
  2    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
       75 
  3     1 /* BEGIN INCLUDE FILE ... quit_info.incl.pl1 ... */
  3     2 
  3     3 /* The include file condition_info_header must be used with this file. */
  3     4 
  3     5 declare quit_info_ptr pointer;
  3     6 declare 1 quit_info aligned based (quit_info_ptr),
  3     7         2 header aligned like condition_info_header,
  3     8         2 switches aligned,
  3     9 	3 reset_write bit (1) unaligned,
  3    10           3 ips_quit bit (1) unaligned,
  3    11           3 reconnection_quit bit (1) unaligned,
  3    12 	3 pad bit (33);
  3    13 
  3    14 /* END INCLUDE FILE ... quit_info.incl.pl1 ... */
       76 
       77 
       78 	dcl     1 quit_info_struc	 aligned like quit_info;
       79 
       80 	dcl     error_table_$unable_to_do_io
       81 				 ext static fixed bin (35);
       82 
       83 /* Automatic */
       84 
       85 	dcl     all_mask		 bit (36) aligned;
       86 	dcl     code		 fixed bin (35);
       87 	dcl     logout_channel	 fixed bin (71);
       88 	dcl     logout_pid		 bit (36);
       89 	dcl     old_mask		 bit (36) aligned;	/* to save old ips mask, to put back when we unsuspend */
       90 	dcl     process_type	 fixed bin (35);
       91 	dcl     reconnect_ec_dir	 char (168);
       92 	dcl     reconnect_command_line char (256);
       93 	dcl     trm_mask		 bit (36) aligned;
       94 
  4     1 /* BEGIN INCLUDE FILE ... event_wait_channel.incl.pl1 */
  4     2 
  4     3 /* ipc_$block wait list with one channel
  4     4*
  4     5*   Written 9-May-79 by M. N. Davidoff.
  4     6**/
  4     7 
  4     8      declare 1 event_wait_channel   aligned,
  4     9 	     2 n_channels	      fixed bin initial (1),	/* number of channels */
  4    10 	     2 pad	      bit (36),
  4    11 	     2 channel_id	      (1) fixed bin (71);	/* event channel to wait on */
  4    12 
  4    13 /* END INCLUDE FILE ... event_wait_channel.incl.pl1 */
       95 
  5     1 /* BEGIN INCLUDE FILE event_wait_info.incl.pl1 */
  5     2 
  5     3 /* T. Casey, May 1978 */
  5     4 
  5     5 dcl  event_wait_info_ptr ptr;
  5     6 
  5     7 dcl 1 event_wait_info aligned based (event_wait_info_ptr),	/* argument structure filled in on return from ipc_$block */
  5     8     2 channel_id fixed bin (71),			/* event channel on which wakeup occurred */
  5     9     2 message fixed bin (71),				/* 72 bits of information passed by sender of wakeup */
  5    10     2 sender bit (36),				/* process id of sender */
  5    11     2 origin,
  5    12       3 dev_signal bit (18) unaligned,			/* "1"b if device signal */
  5    13       3 ring fixed bin (17) unaligned,			/* ring from which sent */
  5    14     2 channel_index fixed bin;			/* index of this channel in the event wait list */
  5    15 
  5    16 /* END INCLUDE FILE event_wait_info.incl.pl1 */
       96 
       97 
       98 	dcl     1 auto_event_wait_info automatic aligned like event_wait_info;
       99 
      100 	dcl     ec_entry_type	 fixed bin (2);
      101 
      102 /* Ext Entries */
      103 
      104 	dcl     create_ips_mask_	 entry (ptr, fixed bin, bit (36) aligned);
      105 	dcl     cu_$cp		 entry (ptr, fixed bin (21), fixed bin (35));
      106 	dcl     default_error_handler_$wall_ignore_pi
      107 				 entry options (variable);
      108 	dcl     hcs_$reset_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      109 	dcl     hcs_$set_ips_mask	 entry (bit (36) aligned, bit (36) aligned);
      110 	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
      111 				 fixed bin (35));
      112 	dcl     hcs_$wakeup		 entry (bit (36), fixed bin (71), fixed bin (71), fixed bin (35));
      113 	dcl     ioa_$ioa_switch	 entry options (variable);
      114 	dcl     ipc_$block		 entry (ptr, ptr, fixed bin (35));
      115 	dcl     ipc_$create_ev_chn	 entry (fixed bin (71), fixed bin (35));
      116 	dcl     ipc_$delete_ev_chn	 entry (fixed bin (71), fixed bin (35));
      117 	dcl     ipc_$mask_ev_calls	 entry (fixed bin (35));
      118 	dcl     ipc_$unmask_ev_calls	 entry (fixed bin (35));
      119 
      120 	dcl     signal_		 entry () options (variable);
      121 	dcl     term_signal_handler_	 entry options(variable);
      122 	dcl     terminate_process_	 entry (char (*), ptr);
      123 	dcl     user_info_		 entry (char (*), char (*), char (*));
      124 	dcl     user_info_$homedir	 entry (char (*));
      125 	dcl     user_info_$logout_data entry (fixed bin (71), bit (36));
      126 	dcl     user_info_$process_type
      127 				 entry (fixed bin (35));
      128 	dcl     user_info_$outer_module
      129 				 entry (char (*));
      130 
      131 /* arg list is shortened to last interesting datum */
      132 
  6     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  6     2 
  6     3 /* Written 05/04/78 by C. D. Tavares */
  6     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  6     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  6     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  6     7 
  6     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  6     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  6    10      iox_$close entry (pointer, fixed bin (35)),
  6    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  6    12      iox_$delete_record entry (pointer, fixed bin (35)),
  6    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  6    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  6    15      iox_$err_not_attached entry options (variable),
  6    16      iox_$err_not_closed entry options (variable),
  6    17      iox_$err_no_operation entry options (variable),
  6    18      iox_$err_not_open entry options (variable),
  6    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  6    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  6    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  6    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  6    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  6    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  6    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  6    28      iox_$propagate entry (pointer),
  6    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  6    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  6    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  6    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  6    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  6    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  6    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  6    40 
  6    41 dcl (iox_$user_output,
  6    42      iox_$user_input,
  6    43      iox_$user_io,
  6    44      iox_$error_output) external static pointer;
  6    45 
  6    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      133 
  7     1 /* Begin include file ..... iox_modes.incl.pl1 */
  7     2 
  7     3 /* Written by C. D. Tavares, 03/17/75 */
  7     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  7     5 
  7     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  7     7     ("stream_input", "stream_output", "stream_input_output",
  7     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  7     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  7    10      "direct_input", "direct_output", "direct_update");
  7    11 
  7    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  7    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  7    14 
  7    15 dcl (Stream_input initial (1),
  7    16      Stream_output initial (2),
  7    17      Stream_input_output initial (3),
  7    18      Sequential_input initial (4),
  7    19      Sequential_output initial (5),
  7    20      Sequential_input_output initial (6),
  7    21      Sequential_update initial (7),
  7    22      Keyed_sequential_input initial (8),
  7    23      Keyed_sequential_output initial (9),
  7    24      Keyed_sequential_update initial (10),
  7    25      Direct_input initial (11),
  7    26      Direct_output initial (12),
  7    27      Direct_update initial (13)) fixed bin int static options (constant);
  7    28 
  7    29 /* End include file ..... iox_modes.incl.pl1 */
      134 
      135 
      136 /* Conditions */
      137 
      138 	dcl     any_other		 condition;
      139 
      140 /* Builtins */
      141 
      142 	dcl     (addr, codeptr, index, length, null, rtrim, size, string)
      143 				 builtin;
      144 
      145 /* PROCEDURE */
      146 
      147 /* If user changed his mind about -save, we'll log out when we get the sus_ signal. */
      148 
      149 	if nosave_switch
      150 	then call term_signal_handler_();
      151 
      152 /* Get our attach description for reattachment */
      153 
      154 /* Mask off all ips signals except trm_ (this allows a suspended process that gets bumped to signal finish). */
      155 
      156 	call create_ips_mask_ (addr (trm_name), (1), trm_mask);
      157 						/* this makes a mask that disables only trm_ */
      158 	trm_mask = ^trm_mask;			/* turn it into a mask that enables only trm_ */
      159 	call hcs_$set_ips_mask (trm_mask, old_mask);
      160 
      161 /* Mask off ipc event call wakeups */
      162 
      163 	call ipc_$mask_ev_calls (code);
      164 
      165 /* Create an event channel to block on */
      166 
      167 	call ipc_$create_ev_chn (event_wait_channel.channel_id (1), code);
      168 
      169 /* Tell answering service the channel id so it can wake us when it's ok to run again */
      170 
      171 	call user_info_$logout_data (logout_channel, logout_pid);
      172 						/* get channel and process id over which to signal a.s. */
      173 	call hcs_$wakeup (logout_pid, logout_channel, event_wait_channel.channel_id (1), code);
      174 						/* wakeup message is channel id */
      175 
      176 /* Now, go blocked on that channel until the answering service says we may run again */
      177 
      178 	auto_event_wait_info.sender = ""b;		/* so we can tell who sends the wakeup */
      179 	call ipc_$block (addr (event_wait_channel), addr (auto_event_wait_info), code);
      180 
      181 /* We returned from being blocked. We may run again. */
      182 
      183 	call ipc_$delete_ev_chn (event_wait_channel.channel_id (1), code);
      184 						/* clean up our ECT */
      185 
      186 	on any_other call REAL_FAILURE (error_table_$unable_to_do_io, "Fault or error reconnecting terminal.");
      187 
      188 /* What we do next depends on what kind of process we are. */
      189 
      190 	call user_info_$process_type (process_type);	/* find out */
      191 
      192 /* If we are absentee, we just return, to resume running. */
      193 
      194 	if process_type = 2
      195 	then do;
      196 		call unmask_all;			/* unmask ips signals and ipc event call wakeups */
      197 		return;
      198 	     end;
      199 
      200 /* Interactive or daemon */
      201 
      202 /* Can't be daemon because the MR8.0 answering service never sends sus_ to
      203*daemons.  So must be interactive.*/
      204 
      205 /* Simulate the user hitting QUIT. */
      206 
      207 /* We have a difficult problem here.  We would like to set a QUIT signal to
      208*be pending, then unmask everything, and let the QUIT and any other signals or
      209*wakeups go off in whatever order the system wants them to.  But if we unmask
      210*ips signals first, we are very likely to get one before we can signal QUIT.
      211*Or, if we signal QUIT with a signal statement first, we will probably get to
      212*command level with ips signals and ipc event call wakeups masked off, which
      213*is not a good environment in which to leave the user.  Since ipc wakeups will
      214*not happen until we go blocked, it is safe to unmask them just before
      215*signalling QUIT.  And, since the ips signals most likely to occur are cput
      216*and alrm, it is probably ok to let them happen before we signal QUIT.  So, we
      217*unmask and then immediately signal QUIT, and hope for the best.  But first,
      218*take care of a few details.  */
      219 
      220 
      221 	call reattach_user_channel;			/* redo iox_ attachments */
      222 
      223 /* Turn on the new terminal's QUIT button, while we still have control */
      224 
      225 	call iox_$control (iox_$user_io, "quit_enable", null (), code);
      226 
      227 	call ioa_$ioa_switch (iox_$user_io, "Wait for QUIT.");
      228 						/* tell user not to get impatient */
      229 	quit_info_struc.length = size (quit_info_struc);	/* set up QUIT info structure */
      230 	quit_info_struc.version = 1;
      231 	quit_info_struc.action_flags = ""b;		/* no special action */
      232 	quit_info_struc.info_string = "";
      233 	quit_info_struc.status_code = 0;
      234 	string (quit_info_struc.switches) = ""b;	/* ips_quit, reset_write = "0"b */
      235 	quit_info_struc.switches.reconnection_quit = "1"b;/* but this is... */
      236 
      237 /* Finally, we'll unmask and signal QUIT.
      238*   In case the hangup happened while a nonstandard mask was in effect, we'll mask everything on
      239*   before going to command level. This might cause problems in some rare cases, but it would be
      240*   a lot worse to put a user at command level with all ips signals masked off. If he
      241*   released in those circumstances, the ips signals would never get masked on again. */
      242 
      243 	call create_ips_mask_ (addr (all_name), (1), all_mask);
      244 						/* get mask that disables all ips signals */
      245 	all_mask = ^all_mask;			/* turn it into one that enables all ips signals */
      246 	call unmask_all;				/* for ipc and crit bit */
      247 	call hcs_$set_ips_mask (all_mask, (""b));
      248 
      249 	if ec_reconnect_switch
      250 	then do;
      251 		call user_info_$homedir (reconnect_ec_dir);
      252 		call hcs_$status_minf (reconnect_ec_dir, reconnect_ec_entry, 1, ec_entry_type, (0), code);
      253 		if code ^= 0 | ec_entry_type ^= 1
      254 		then do;
      255 			call user_info_ ((""), reconnect_ec_dir, (""));
      256 			reconnect_ec_dir = ">udd>" || rtrim (reconnect_ec_dir);
      257 			call hcs_$status_minf (reconnect_ec_dir, reconnect_ec_entry, 1, ec_entry_type, (0), code);
      258 			if code ^= 0 | ec_entry_type ^= 1
      259 			then do;
      260 				reconnect_ec_dir = ">system_control_dir";
      261 				call hcs_$status_minf (reconnect_ec_dir, reconnect_ec_entry, 1, ec_entry_type,
      262 				     (0), code);
      263 				if code ^= 0 | ec_entry_type ^= 1
      264 				then go to no_reconnect_ec;
      265 			     end;
      266 		     end;
      267 		on any_other call default_error_handler_$wall_ignore_pi;
      268 		reconnect_command_line = "exec_com " || rtrim (reconnect_ec_dir) || ">" || reconnect_ec_entry;
      269 		call cu_$cp (addr (reconnect_command_line), length (reconnect_command_line), code);
      270 		if code ^= 0
      271 		then call ioa_$ioa_switch (iox_$user_io, "sus_signal_handler_: Unable to invoke ^a.",
      272 			reconnect_ec_entry);
      273 	     end;
      274 
      275 no_reconnect_ec:
      276 	revert any_other;
      277 	call signal_ ("quit", null (), addr (quit_info_struc), null ());
      278 
      279 /* If the QUIT handler returns, the user probably said start. So we'll return to the procedure
      280*   that was interrupted by the sus_ signal. */
      281 
      282 
      283 	call iox_$control (iox_$user_io, "start", null (), code);
      284 						/* in case it hung up while we were in the tty_ dim */
      285 
      286 	call hcs_$reset_ips_mask (old_mask, (""b));	/* put back mask that was in effect at time of hangup */
      287 
      288 	return;
      289 
      290 
      291 unmask_all:
      292      proc;					/* to unmask ipc event calls and ips signals */
      293 
      294 	call ipc_$unmask_ev_calls (code);
      295 	call hcs_$reset_ips_mask (old_mask, (""b));	/* tell hardcore that we have stopped changing the mask */
      296 	return;
      297 
      298      end unmask_all;
      299 
      300 
      301 /* The following two entry points allow a user who specified -save at login time (or who gets -save by default)
      302*   to change his mind, repeatedly. Note that a user who doesn't log in with -save can not change his mind. */
      303 
      304 no_save_on_disconnect:
      305      entry;
      306 
      307 	nosave_switch = "1"b;
      308 	return;
      309 
      310 save_on_disconnect:
      311      entry;
      312 
      313 	nosave_switch = ""b;
      314 	return;
      315 
      316 
      317 /* The following four entry points are used to control the execution
      318*   of an exec_com following reconnection.  The process may disable/enable
      319*   the execution of the exec_com, and may establish the any_other handler
      320*   which will be used when the exec_com is being interpreted. */
      321 
      322 
      323 reconnect_ec_disable:
      324      entry;
      325 
      326 	ec_reconnect_switch = "0"b;
      327 	return;
      328 
      329 
      330 reconnect_ec_enable:
      331      entry;
      332 
      333 	ec_reconnect_switch = "1"b;
      334 	return;
      335 
      336 
      337 /* Brains of this act. This procedure reconnects switches attached
      338*   with -login_channel */
      339 
      340 reattach_user_channel:
      341      procedure;
      342 
  8     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  8     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  8     3*      version number to IOX2. */
  8     4 /* format: style2 */
  8     5 
  8     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  8     7 	     2 version	      character (4) aligned,	/* IOX2 */
  8     8 	     2 name	      char (32),		/* I/O name of this block. */
  8     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  8    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  8    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  8    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  8    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  8    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  8    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  8    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  8    17 						/* open(p,mode,not_used,s) */
  8    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  8    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  8    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  8    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  8    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  8    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  8    24 						/* put_chars(p,bufptr,buflen,s) */
  8    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  8    26 						/* modes(p,newmode,oldmode,s) */
  8    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  8    28 						/* position(p,u1,u2,s) */
  8    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  8    30 						/* control(p,order,infptr,s) */
  8    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  8    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  8    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  8    34 						/* write_record(p,bufptr,buflen,s) */
  8    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  8    36 						/* rewrite_record(p,bufptr,buflen,s) */
  8    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  8    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  8    39 						/* seek_key(p,key,len,s) */
  8    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  8    41 						/* read_key(p,key,len,s) */
  8    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  8    43 						/* read_length(p,len,s) */
  8    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  8    45 						/* open_file(p,mode,desc,not_used,s) */
  8    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  8    47 						/* close_file(p,desc,s) */
  8    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  8    49 						/* detach(p,desc,s) */
  8    50 
  8    51      declare iox_$iocb_version_sentinel
  8    52 			      character (4) aligned external static;
  8    53 
  8    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      343 
      344 	declare 1 IOCB		 aligned based (iocbp) like iocb;
      345 	declare iocbp		 pointer;
      346 	declare 1 atd		 aligned based (IOCB.attach_descrip_ptr),
      347 		2 len		 fixed bin (21),
      348 		2 attach_description char (0 refer (atd.len));
      349 	declare outer_module	 char (32);
      350 	declare ix		 fixed bin;
      351 	declare code		 fixed bin (35);
      352 	declare new_atd		 char (64);
      353 
      354 
      355 /* all attachments must be -login_channel to be noticed by this code */
      356 
      357 	outer_module = "";
      358 	call user_info_$outer_module (outer_module);
      359 
      360 	new_atd = rtrim (outer_module) || " -login_channel";
      361 
      362 	code = 0;
      363 
      364 	do ix = 1 repeat (1 + ix);			/* checkout all switches */
      365 	     code = 0;
      366 	     call iox_$find_iocb_n (ix, iocbp, code);
      367 	     if code ^= 0
      368 	     then goto NO_MORE_SWITCHES;
      369 	     if iocbp = IOCB.actual_iocb_ptr
      370 	     then if IOCB.attach_descrip_ptr ^= null ()
      371 		then do;
      372 			if index (attach_description, "-login_channel") > 0
      373 			then do;
      374 				call iox_$control (iocbp, "reconnection", null (), code);
      375 						/* for touchier io modules, ala window_io_/tc_io_ */
      376 				if code = 0
      377 				then goto RECONNECTED;
      378 				call iox_$close (iocbp, code);
      379 				if code ^= 0
      380 				then call REAL_FAILURE (code, "Closing switch " || IOCB.name);
      381 				call iox_$detach_iocb (iocbp, code);
      382 				if code ^= 0
      383 				then call REAL_FAILURE (code, "Detaching switch " || IOCB.name);
      384 				call iox_$attach_ptr (iocbp, rtrim (new_atd), codeptr (sus_signal_handler_), code)
      385 				     ;
      386 				if code ^= 0
      387 				then call REAL_FAILURE (code,
      388 					"Reattaching switch " || IOCB.name || " " || rtrim (new_atd));
      389 				call iox_$open (iocbp, Stream_input_output, ""b, code);
      390 				if code ^= 0
      391 				then call REAL_FAILURE (code, "Opening switch " || IOCB.name);
      392 				go to RECONNECTED;
      393 			     end;
      394 		     end;
      395 	end;
      396 
      397 NO_MORE_SWITCHES:					/* we hope for the best */
      398 RECONNECTED:
      399 	return;
      400      end reattach_user_channel;
      401 
      402 REAL_FAILURE:
      403      procedure (code, reason) options (non_quick);
      404 
      405 	dcl     code		 fixed bin (35);
      406 	dcl     reason		 char (*);
      407 	dcl     1 terminate_info	 aligned,
      408 		2 version		 fixed bin,
      409 		2 fatal_code	 fixed bin (35);
      410 
      411 	terminate_info.version = 0;
      412 	terminate_info.fatal_code = code;
      413 	call terminate_process_ ("fatal_error", addr (terminate_info));
      414      end REAL_FAILURE;
      415 
      416      end sus_signal_handler_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/29/88  0856.3  sus_signal_handler_.pl1           >spec>install>1093>sus_signal_handler_.pl1
74           1    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
75           2    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
76           3    02/09/82  1152.4  quit_info.incl.pl1                >ldd>include>quit_info.incl.pl1
95           4    06/29/79  1728.0  event_wait_channel.incl.pl1       >ldd>include>event_wait_channel.incl.pl1
96           5    06/29/79  1727.8  event_wait_info.incl.pl1          >ldd>include>event_wait_info.incl.pl1
133          6    05/23/83  0916.6  iox_entries.incl.pl1              >ldd>include>iox_dcls.incl.pl1
134          7    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
343          8    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
IOCB                                   based           structure                level 1 dcl 344
Stream_input_output             000000 constant        fixed bin(17,0)          initial dcl 7-15 set ref 389*
action_flags              2     000100 automatic       structure                level 3 dcl 78 set ref 231*
actual_iocb_ptr          12            based           pointer                  level 2 dcl 344 ref 369
addr                                                   builtin function         dcl 142 ref 156 156 179 179 179 179 243 243 269 269
                                                                                  277 277 413 413
all_mask                        000207 automatic       bit(36)                  dcl 85 set ref 243* 245* 245 247*
all_name                        000021 constant        char(32)                 initial array packed unaligned dcl 64 set ref 243
                                                                                  243
any_other                       000406 stack reference condition                dcl 138 ref 186 267 275
atd                                    based           structure                level 1 dcl 346
attach_descrip_ptr       14            based           pointer                  level 2 dcl 344 ref 369 372
attach_description        1            based           char                     level 2 dcl 346 ref 372
auto_event_wait_info            000376 automatic       structure                level 1 dcl 98 set ref 179 179
channel_id                2     000372 automatic       fixed bin(71,0)          array level 2 dcl 4-8 set ref 167* 173* 183*
code                            000210 automatic       fixed bin(35,0)          dcl 86 in procedure "sus_signal_handler_" set ref
                                                                                  163* 167* 173* 179* 183* 225* 252* 253 257* 258
                                                                                  261* 263 269* 270 283* 294*
code                                   parameter       fixed bin(35,0)          dcl 405 in procedure "REAL_FAILURE" ref 402 412
code                            000443 automatic       fixed bin(35,0)          dcl 351 in procedure "reattach_user_channel" set ref
                                                                                  362* 365* 366* 367 374* 376 378* 379 379* 381* 382
                                                                                  382* 384* 386 386* 389* 390 390*
codeptr                                                builtin function         dcl 142 ref 384 384
condition_info_header                  based           structure                level 1 dcl 2-6
create_ips_mask_                000014 constant        entry                    external dcl 104 ref 156 243
cu_$cp                          000016 constant        entry                    external dcl 105 ref 269
default_error_handler_$wall_ignore_pi
                                000020 constant        entry                    external dcl 106 ref 267
ec_entry_type                   000405 automatic       fixed bin(2,0)           dcl 100 set ref 252* 253 257* 258 261* 263
ec_reconnect_switch             000011 internal static bit(1)                   initial dcl 72 set ref 249 326* 333*
error_table_$unable_to_do_io    000012 external static fixed bin(35,0)          dcl 80 set ref 186*
event_wait_channel              000372 automatic       structure                level 1 dcl 4-8 set ref 179 179
event_wait_info                        based           structure                level 1 dcl 5-7
fatal_code                1     000100 automatic       fixed bin(35,0)          level 2 dcl 407 set ref 412*
hcs_$reset_ips_mask             000022 constant        entry                    external dcl 108 ref 286 295
hcs_$set_ips_mask               000024 constant        entry                    external dcl 109 ref 159 247
hcs_$status_minf                000026 constant        entry                    external dcl 110 ref 252 257 261
hcs_$wakeup                     000030 constant        entry                    external dcl 112 ref 173
header                          000100 automatic       structure                level 2 dcl 78
index                                                  builtin function         dcl 142 ref 372
info_string               3     000100 automatic       varying char(256)        level 3 dcl 78 set ref 232*
ioa_$ioa_switch                 000032 constant        entry                    external dcl 113 ref 227 270
iocb                                   based           structure                level 1 dcl 8-6
iocbp                           000430 automatic       pointer                  dcl 345 set ref 366* 369 369 369 372 374* 378* 379
                                                                                  381* 382 384* 386 389* 390
iox_$attach_ptr                 000066 constant        entry                    external dcl 6-8 ref 384
iox_$close                      000070 constant        entry                    external dcl 6-8 ref 378
iox_$control                    000072 constant        entry                    external dcl 6-8 ref 225 283 374
iox_$detach_iocb                000074 constant        entry                    external dcl 6-8 ref 381
iox_$find_iocb_n                000076 constant        entry                    external dcl 6-8 ref 366
iox_$open                       000100 constant        entry                    external dcl 6-8 ref 389
iox_$user_io                    000102 external static pointer                  dcl 6-41 set ref 225* 227* 270* 283*
ipc_$block                      000034 constant        entry                    external dcl 114 ref 179
ipc_$create_ev_chn              000036 constant        entry                    external dcl 115 ref 167
ipc_$delete_ev_chn              000040 constant        entry                    external dcl 116 ref 183
ipc_$mask_ev_calls              000042 constant        entry                    external dcl 117 ref 163
ipc_$unmask_ev_calls            000044 constant        entry                    external dcl 118 ref 294
ix                              000442 automatic       fixed bin(17,0)          dcl 350 set ref 364* 366* 395*
len                                    based           fixed bin(21,0)          level 2 dcl 346 ref 372
length                          000100 automatic       fixed bin(17,0)          level 3 in structure "quit_info_struc" dcl 78
                                                                                  in procedure "sus_signal_handler_" set ref 229*
length                                                 builtin function         dcl 142 in procedure "sus_signal_handler_" ref 269
                                                                                  269
logout_channel                  000212 automatic       fixed bin(71,0)          dcl 87 set ref 171* 173*
logout_pid                      000214 automatic       bit(36)                  packed unaligned dcl 88 set ref 171* 173*
n_channels                      000372 automatic       fixed bin(17,0)          initial level 2 dcl 4-8 set ref 4-8*
name                      1            based           char(32)                 level 2 dcl 344 ref 379 382 386 390
new_atd                         000444 automatic       char(64)                 packed unaligned dcl 352 set ref 360* 384 384 386
nosave_switch                   000010 internal static bit(1)                   initial dcl 70 set ref 149 307* 313*
null                                                   builtin function         dcl 142 ref 225 225 277 277 277 277 283 283 369 374
                                                                                  374
old_mask                        000215 automatic       bit(36)                  dcl 89 set ref 159* 286* 295*
outer_module                    000432 automatic       char(32)                 packed unaligned dcl 349 set ref 357* 358* 360
process_type                    000216 automatic       fixed bin(35,0)          dcl 90 set ref 190* 194
quit_info                              based           structure                level 1 dcl 3-6
quit_info_struc                 000100 automatic       structure                level 1 dcl 78 set ref 229 277 277
reason                                 parameter       char                     packed unaligned dcl 406 ref 402
reconnect_command_line          000271 automatic       char(256)                packed unaligned dcl 92 set ref 268* 269 269 269 269
reconnect_ec_dir                000217 automatic       char(168)                packed unaligned dcl 91 set ref 251* 252* 255* 256*
                                                                                  256 257* 260* 261* 268
reconnect_ec_entry              000011 constant        char(32)                 initial packed unaligned dcl 66 set ref 252* 257*
                                                                                  261* 268 270*
reconnection_quit       105(02) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 78 set ref 235*
rtrim                                                  builtin function         dcl 142 ref 256 268 360 384 384 386
sender                    4     000376 automatic       bit(36)                  level 2 dcl 98 set ref 178*
signal_                         000046 constant        entry                    external dcl 120 ref 277
size                                                   builtin function         dcl 142 ref 229
status_code             104     000100 automatic       fixed bin(35,0)          level 3 dcl 78 set ref 233*
string                                                 builtin function         dcl 142 set ref 234*
switches                105     000100 automatic       structure                level 2 dcl 78 set ref 234*
term_signal_handler_            000050 constant        entry                    external dcl 121 ref 149
terminate_info                  000100 automatic       structure                level 1 dcl 407 set ref 413 413
terminate_process_              000052 constant        entry                    external dcl 122 ref 413
trm_mask                        000371 automatic       bit(36)                  dcl 93 set ref 156* 158* 158 159*
trm_name                        000001 constant        char(32)                 initial array packed unaligned dcl 68 set ref 156
                                                                                  156
user_info_                      000054 constant        entry                    external dcl 123 ref 255
user_info_$homedir              000056 constant        entry                    external dcl 124 ref 251
user_info_$logout_data          000060 constant        entry                    external dcl 125 ref 171
user_info_$outer_module         000064 constant        entry                    external dcl 128 ref 358
user_info_$process_type         000062 constant        entry                    external dcl 126 ref 190
version                   1     000100 automatic       fixed bin(17,0)          level 3 in structure "quit_info_struc" dcl 78
                                                                                  in procedure "sus_signal_handler_" set ref 230*
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "terminate_info" dcl 407
                                                                                  in procedure "REAL_FAILURE" set ref 411*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 7-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 7-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 7-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 7-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 7-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 7-15
condition_info                         based           structure                level 1 dcl 1-14
condition_info_header_ptr              automatic       pointer                  dcl 2-4
condition_info_ptr                     automatic       pointer                  dcl 1-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 1-30
event_wait_info_ptr                    automatic       pointer                  dcl 5-5
iox_$attach_loud                000000 constant        entry                    external dcl 6-8
iox_$attach_name                000000 constant        entry                    external dcl 6-8
iox_$close_file                 000000 constant        entry                    external dcl 6-8
iox_$delete_record              000000 constant        entry                    external dcl 6-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 6-8
iox_$detach                     000000 constant        entry                    external dcl 6-8
iox_$err_no_operation           000000 constant        entry                    external dcl 6-8
iox_$err_not_attached           000000 constant        entry                    external dcl 6-8
iox_$err_not_closed             000000 constant        entry                    external dcl 6-8
iox_$err_not_open               000000 constant        entry                    external dcl 6-8
iox_$error_output                      external static pointer                  dcl 6-41
iox_$find_iocb                  000000 constant        entry                    external dcl 6-8
iox_$get_chars                  000000 constant        entry                    external dcl 6-8
iox_$get_line                   000000 constant        entry                    external dcl 6-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 8-51
iox_$look_iocb                  000000 constant        entry                    external dcl 6-8
iox_$modes                      000000 constant        entry                    external dcl 6-8
iox_$move_attach                000000 constant        entry                    external dcl 6-8
iox_$open_file                  000000 constant        entry                    external dcl 6-8
iox_$position                   000000 constant        entry                    external dcl 6-8
iox_$propagate                  000000 constant        entry                    external dcl 6-8
iox_$put_chars                  000000 constant        entry                    external dcl 6-8
iox_$read_key                   000000 constant        entry                    external dcl 6-8
iox_$read_length                000000 constant        entry                    external dcl 6-8
iox_$read_record                000000 constant        entry                    external dcl 6-8
iox_$rewrite_record             000000 constant        entry                    external dcl 6-8
iox_$seek_key                   000000 constant        entry                    external dcl 6-8
iox_$user_input                        external static pointer                  dcl 6-41
iox_$user_output                       external static pointer                  dcl 6-41
iox_$write_record               000000 constant        entry                    external dcl 6-8
iox_modes                              internal static char(24)                 initial array dcl 7-6
quit_info_ptr                          automatic       pointer                  dcl 3-5
short_iox_modes                        internal static char(4)                  initial array dcl 7-12

NAMES DECLARED BY EXPLICIT CONTEXT.
NO_MORE_SWITCHES                002007 constant        label                    dcl 397 ref 367
REAL_FAILURE                    002011 constant        entry                    internal dcl 402 ref 186 379 382 386 390
RECONNECTED                     002007 constant        label                    dcl 397 ref 376 392
no_reconnect_ec                 001165 constant        label                    dcl 275 ref 263
no_save_on_disconnect           001265 constant        entry                    external dcl 304
reattach_user_channel           001362 constant        entry                    internal dcl 340 ref 221
reconnect_ec_disable            001312 constant        entry                    external dcl 323
reconnect_ec_enable             001324 constant        entry                    external dcl 330
save_on_disconnect              001300 constant        entry                    external dcl 310
sus_signal_handler_             000201 constant        entry                    external dcl 32 ref 384 384
unmask_all                      001336 constant        entry                    internal dcl 291 ref 196 246

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2504        2610    2061        2514
Length      3224    2061       104         377     423           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
sus_signal_handler_                 443 external procedure  is an external procedure.  
on unit on line 186                  86 on unit               
on unit on line 267                  64 on unit               
unmask_all                              internal procedure  shares stack frame of external procedure sus_signal_handler_.  
reattach_user_channel                   internal procedure  shares stack frame of external procedure sus_signal_handler_.  
REAL_FAILURE                         84 internal procedure  is called during a stack extension, and   
                                                            is declared options(non_quick).  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 nosave_switch               sus_signal_handler_
000011 ec_reconnect_switch         sus_signal_handler_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
REAL_FAILURE             000100 terminate_info              REAL_FAILURE
sus_signal_handler_      000100 quit_info_struc             sus_signal_handler_
                         000207 all_mask                    sus_signal_handler_
                         000210 code                        sus_signal_handler_
                         000212 logout_channel              sus_signal_handler_
                         000214 logout_pid                  sus_signal_handler_
                         000215 old_mask                    sus_signal_handler_
                         000216 process_type                sus_signal_handler_
                         000217 reconnect_ec_dir            sus_signal_handler_
                         000271 reconnect_command_line      sus_signal_handler_
                         000371 trm_mask                    sus_signal_handler_
                         000372 event_wait_channel          sus_signal_handler_
                         000376 auto_event_wait_info        sus_signal_handler_
                         000405 ec_entry_type               sus_signal_handler_
                         000430 iocbp                       reattach_user_channel
                         000432 outer_module                reattach_user_channel
                         000442 ix                          reattach_user_channel
                         000443 code                        reattach_user_channel
                         000444 new_atd                     reattach_user_channel

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
return_mac          enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc
set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
create_ips_mask_              cu_$cp                        default_error_handler_$wall_ignore_pi
hcs_$reset_ips_mask           hcs_$set_ips_mask             hcs_$status_minf              hcs_$wakeup
ioa_$ioa_switch               iox_$attach_ptr               iox_$close                    iox_$control
iox_$detach_iocb              iox_$find_iocb_n              iox_$open                     ipc_$block
ipc_$create_ev_chn            ipc_$delete_ev_chn            ipc_$mask_ev_calls            ipc_$unmask_ev_calls
signal_                       term_signal_handler_          terminate_process_            user_info_
user_info_$homedir            user_info_$logout_data        user_info_$outer_module       user_info_$process_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unable_to_do_io  iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 4    8 000174        32 000200       149 000207       156 000216       158 000235       159 000240       163 000251
    167 000260       171 000271       173 000302       178 000317       179 000320       183 000337       186 000350
    190 000405       194 000414       196 000417       197 000420       221 000421       225 000422       227 000455
    229 000500       230 000502       231 000504       232 000516       233 000517       234 000520       235 000523
    243 000525       245 000544       246 000547       247 000550       249 000563       251 000566       252 000576
    253 000636       255 000643       256 000663       257 000711       258 000752       260 000757       261 000762
    263 001022       267 001027       268 001050       269 001117       270 001137       275 001165       277 001166
    283 001220       286 001250       288 001263       304 001264       307 001273       308 001276       310 001277
    313 001306       314 001310       323 001311       326 001320       327 001322       330 001323       333 001332
    334 001335       291 001336       294 001337       295 001346       296 001361       340 001362       357 001363
    358 001366       360 001377       362 001425       364 001427       365 001432       366 001433       367 001446
    369 001450       372 001461       374 001471       376 001524       378 001526       379 001537       381 001564
    382 001575       384 001622       386 001670       389 001737       390 001757       392 002004       395 002005
    397 002007       402 002010       411 002024       412 002025       413 002030       414 002052


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
