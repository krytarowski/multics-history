	COMPILATION LISTING OF SEGMENT mu_db_xref
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1338.7 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
        8 
        9 /*DESCRIPTION
       10*  This set of routines manages a temporary keyed vfile. This file contains the
       11*  database crossreference (ie., which domains are used by which attributes or
       12*  which attributes are used by which relations). The $build entry point is used
       13*  to create and initialize the file, the $reference, $dereference and $delete
       14*  are used to modify it, and the $find is used to query it.
       15**/
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       19*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       20*     written
       21*                                                   END HISTORY COMMENTS */
       22 
       23 mu_db_xref:
       24      proc;
       25 
       26 	return;
       27 
       28 /************************* EP build *************************/
       29 
       30 /*DESCRIPTION
       31*  This procedure creates a keyed_sequential vfile_ and goes through
       32*  each relation in the db_model adding the attribute and domain names to the
       33*  vfile as keys and a crossreference as the record data.  No duplicate
       34*  attributes or domains are stored so when complete it contains a list of all
       35*  the unique objects in the database.
       36**/
       37 
       38 mu_db_xref$xref_build:
       39      entry (Itemp_dir_path, Idb_path, Idbm_ptr, Ofile_name, Oiocb_ptr, Oerror_message, Ocode);
       40 
       41 /* Initialization */
       42 
       43 	temp_dir_path = Itemp_dir_path;
       44 	db_path = Idb_path;
       45 	dbm_ptr = Idbm_ptr;
       46 
       47 /* Create the attach description, attach and open the file */
       48 
       49 	temp_file_attach_name = unique_chars_ ("0"b) || ".rmdb.xref";
       50 	temp_file_attach_desc = "vfile_  " || rtrim (temp_dir_path) || ">" || temp_file_attach_name || " -share";
       51 
       52 	temp_file_iocb_ptr, temp_seg_ptr, fm_ptr = null;
       53 	close_temp_file = TRUE;
       54 	on cleanup
       55 	     begin;
       56 		if fm_ptr ^= null
       57 		then call terminate_file_ (fm_ptr, (0), TERM_FILE_TERM, (0));
       58 		call cleaner;
       59 	     end;
       60 
       61 	call iox_$attach_name (temp_file_attach_name, temp_file_iocb_ptr, temp_file_attach_desc, null, code);
       62 	if code = 0
       63 	then call iox_$open (temp_file_iocb_ptr, Keyed_sequential_update, "0"b, code);
       64 	if code ^= 0
       65 	then call error (code, temp_file_attach_desc);
       66 
       67 	call mu_temp_segments$get_temp_segment_path (temp_dir_path, myname, temp_seg_ptr, code);
       68 	if code ^= 0
       69 	then call error (code, "Unable to get a temporary segment.");
       70 	crossref_info_record_ptr = temp_seg_ptr;
       71 
       72 	max_seg_size = sys_info$max_seg_size * 4;
       73 
       74 /* Look at all the relations */
       75 
       76 	do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
       77 	     while (rel (fi_ptr) ^= NULL_OFFSET);
       78 
       79 	     file_model_name = rtrim (file_info.file_name) || ".m";
       80 	     call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
       81 	     if fm_ptr = null
       82 	     then call error (code, rtrim (db_path) || file_model_name);
       83 
       84 /* Add this relation to the xref. */
       85 	     call find_record (RELATION_KEY_HEAD, (file_info.file_name), crossref_info_record_ptr, max_seg_size);
       86 	     if code = 0
       87 	     then call error (code, (file_info.file_name));
       88 	     else if code ^= error_table_$no_record
       89 		then call error (code, error_message);
       90 
       91 	     call add_name ("", rel (fi_ptr), "0"b);
       92 
       93 /* Get a pointer to the relation_info structure in the file_model. */
       94 	     ri_ptr = ptr (fm_ptr, file_model.rel_ptr);	/* Relation info ptr */
       95 
       96 /* Loop through all attributes */
       97 
       98 	     do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) repeat ptr (fm_ptr, attr_info.fwd_thread)
       99 		while (rel (ai_ptr) ^= NULL_OFFSET);
      100 
      101 		call find_record (ATTRIBUTE_KEY_HEAD, (attr_info.name), crossref_info_record_ptr, max_seg_size);
      102 		if code = 0
      103 		then do;				/* it is there, so update the reference count */
      104 		     call add_name ((file_info.file_name), "0"b, "1"b);
      105 		     if code ^= 0
      106 		     then call error (code, "Rewriting list record: " || key);
      107 		     end;
      108 		else if code = error_table_$no_record
      109 		     then do;			/*  attribute name is not in list so add it */
      110 			call add_name ((file_info.file_name), attr_info.domain_ptr, "0"b);
      111 			if code ^= 0
      112 			then call error (code, "Storing list record: " || key);
      113 			end;
      114 		     else call error (code, "Seek key: " || key);
      115 
      116 /* Now update the domain crossreference record for this attribute */
      117 
      118 		di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      119 		call find_record (DOMAIN_KEY_HEAD, (domain_info.name), crossref_info_record_ptr, max_seg_size);
      120 		if code = 0
      121 		then do;				/* key is already there */
      122 		     call add_name ((attr_info.name), "0"b, "1"b);
      123 		     if code ^= 0
      124 		     then call error (code, "Storing list record: " || key);
      125 		     end;
      126 		else if code = error_table_$no_record
      127 		     then do;			/* key is not there, so add it */
      128 			call add_name ((domain_info.name), attr_info.domain_ptr, "0"b); 
      129 			                              /* entry for generated attr */
      130 			if code ^= 0
      131 			then call error (code, "Storing list record: " || key);
      132 			call add_name ((attr_info.name), "0"b, "1"b);
      133 			if code ^= 0
      134 			then call error (code, "Storing list record: " || key);
      135 			end;
      136 		     else call error (code, "Seeking list record: " || key);
      137 
      138 		end;				/* END of all attributes */
      139 
      140 /* Done with this file_model segment */
      141 	     call terminate_file_ (fm_ptr, (0), TERM_FILE_TERM, code);
      142 	     if code ^= 0
      143 	     then call error (code, "Terminating " || file_model_name);
      144 
      145 	     end;					/* END of all files (relations) */
      146 
      147 /* Now go thru the list of domains adding the domain name as an attribute name
      148*   to take care of the case where a domain might not have an attribute defined
      149*   for it */
      150 
      151 	do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) repeat ptr (dbm_ptr, domain_info.fwd_thread)
      152 	     while (rel (di_ptr) ^= NULL_OFFSET);
      153 
      154 	     call find_record (ATTRIBUTE_KEY_HEAD, (domain_info.name), crossref_info_record_ptr, max_seg_size);
      155 	     if code = error_table_$no_record
      156 	     then do;				/*  Attr name is not in list so add it */
      157 		call add_name ("", rel (di_ptr), "0"b);
      158 		if code ^= 0
      159 		then call error (code, "Storing list record: " || key);
      160 		end;
      161 	     else if code ^= 0
      162 		then call error (code, "Seeking list record: " || key);
      163 
      164 /* Add in the unreferenced domains */
      165 	     call find_record (DOMAIN_KEY_HEAD, (domain_info.name), crossref_info_record_ptr, max_seg_size);
      166 	     if code = error_table_$no_record
      167 	     then do;
      168 		call add_name ((domain_info.name), rel (di_ptr), "0"b);
      169 		if code ^= 0
      170 		then call error (code, "Storing list record: " || key);
      171 		end;
      172 	     else if code ^= 0
      173 		then call error (code, "Seeking list record: " || key);
      174 
      175 	     end;					/* END loop thru all domains */
      176 
      177 /* Finally, do all the unreferenced attributes. The unreferenced domains were
      178*   caught in the previous loop, when all the defined domains were added. */
      179 
      180 	do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      181 	     repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET);
      182 
      183 	     call find_record (ATTRIBUTE_KEY_HEAD, (unreferenced_attribute.name), crossref_info_record_ptr,
      184 		max_seg_size);
      185 	     if code = 0
      186 	     then call error (mrds_error_$internal_error, "Encountered a seek key for unreferenced attribute: " || key);
      187 	     else if code = error_table_$no_record
      188 		then do;
      189 		     call add_name ("", unreferenced_attribute.domain_ptr, "0"b);
      190 		     if code ^= 0
      191 		     then call error (code, "Storing list record: " || key);
      192 		     end;
      193 		else call error (code, "Seeking key: " || key);
      194 
      195 /* Now update the domain crossreference record for this attribute */
      196 	     di_ptr = ptr (dbm_ptr, unreferenced_attribute.domain_ptr);
      197 	     call find_record (DOMAIN_KEY_HEAD, (domain_info.name), crossref_info_record_ptr, max_seg_size);
      198 	     if code = 0
      199 	     then do;				/* key is already there */
      200 		call add_name ((unreferenced_attribute.name), "0"b, "1"b);
      201 		if code ^= 0
      202 		then call error (code, "Storing list record: " || key);
      203 		end;
      204 	     else if code = error_table_$no_record
      205 		then call error (mrds_error_$internal_error,
      206 			"Did not encounter a seek domain key for an unreferenced attribute: " || key);
      207 		else call error (code, "Seeking list record: " || key);
      208 
      209 	     end;					/* do ai_ptr */
      210 
      211 /* vfile_ now contains all unique attribute names as keys with domain offset and reference count as data.  */
      212 
      213 	Ofile_name = temp_file_attach_name;
      214 	Oiocb_ptr = temp_file_iocb_ptr;
      215 	close_temp_file = FALSE;
      216 
      217 	call error (0, "");
      218 
      219 /************************* EP destroy ***************************/
      220 
      221 /*DESCRIPTION
      222*  This entry point deletes the crossreference file.
      223**/
      224 
      225 mu_db_xref$xref_destroy:
      226      entry (IOfile_iocb_ptr, Itemp_dir_path, IOfile_name, Oerror_message, Ocode);
      227 
      228 	temp_file_iocb_ptr = IOfile_iocb_ptr;
      229 	temp_dir_path = Itemp_dir_path;
      230 	temp_file_attach_name = IOfile_name;
      231 
      232 	temp_seg_ptr = null;
      233 	if temp_file_iocb_ptr ^= null
      234 	then close_temp_file = TRUE;			/* so cleaner proc will delete it */
      235 
      236 	IOfile_iocb_ptr = null;
      237 	IOfile_name = "";
      238 	call error (0, "");
      239 
      240 /************************* EP reference *************************/
      241 
      242 /*DESCRIPTION
      243*  This entry point adds a given attribute or domain to the specified type of
      244*  record. An error is returned if the record doesn't already exist.
      245**/
      246 
      247 mu_db_xref$xref_reference:
      248      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Iobject_name, Irecord_ptr, Irecord_length, Oerror_message, Ocode);
      249 
      250 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      251 	temp_seg_ptr = null;
      252 	close_temp_file = FALSE;
      253 	call get_temp_dir_path;
      254 
      255 	on cleanup call cleaner;
      256 	call mu_temp_segments$get_temp_segment_path (temp_dir_path, myname, temp_seg_ptr, code);
      257 	if code ^= 0
      258 	then call error (code, "Cannot get temp segment.");
      259 
      260 	crossref_info_record_ptr = temp_seg_ptr;
      261 	max_seg_size = sys_info$max_seg_size * 4;
      262 	call find_record (Ikey_head, Irecord_name, crossref_info_record_ptr, max_seg_size);
      263 	if code ^= 0
      264 	then call error (code, "Seeking list record: " || key);
      265 
      266 	call add_name (Iobject_name, "0"b, "1"b);
      267 	if code = 0
      268 	then do;
      269 	     if Irecord_ptr ^= null
      270 	     then do;				/* give the caller something for his trouble */
      271 		max_seg_size = min (currentsize (crossref_info_record) * 4, Irecord_length);
      272 		call mlr_ (crossref_info_record_ptr, max_seg_size, Irecord_ptr, max_seg_size);
      273 		end;
      274 	     call error (0, "");
      275 	     end;
      276 	else call error (code, "Rewriting list record: " || key);
      277 
      278 /************************* INTERNAL add_name *************************/
      279 
      280 /* This internal subroutine adds a single name to a crossref record and writes
      281*   it back out to the temp file. It maintains the list of unique names in
      282*   sorted ascending order. */
      283 
      284 add_name:
      285      proc (name, offset, record_exists);
      286 
      287 dcl  idx fixed bin;
      288 dcl  name char (*) parameter;
      289 dcl  offset bit (18) unaligned parameter;
      290 dcl  position fixed bin;
      291 dcl  record_exists bit (1) aligned parameter;
      292 
      293 	if record_exists
      294 	then do;
      295 	     if ^search (name, idx)
      296 	     then do;
      297 		position, crossref_info_record.count = crossref_info_record.count + 1;
      298 		crossref_info_record.object_head (position) = OBJECT_HEAD;
      299 		crossref_info_record.object (position) = name;
      300 		end;				/* end insert somewhere */
      301 	     call iox_$rewrite_record (temp_file_iocb_ptr, crossref_info_record_ptr,
      302 		currentsize (crossref_info_record) * 4, code);
      303 	     end;					/* end record exists */
      304 	else do;					/* build a new record */
      305 	     crossref_info_record.offset = offset;
      306 	     if name ^= ""
      307 	     then do;
      308 		crossref_info_record.count = 1;
      309 		crossref_info_record.object_head = OBJECT_HEAD;
      310 		crossref_info_record.object (1) = name;
      311 		end;
      312 	     else crossref_info_record.count = 0;
      313 
      314 	     call iox_$write_record (temp_file_iocb_ptr, crossref_info_record_ptr,
      315 		currentsize (crossref_info_record) * 4, code);
      316 	     end;					/* end build a new record */
      317 
      318 	return;
      319      end add_name;
      320 
      321 /************************* EP create *************************/
      322 
      323 /*DESCRIPTION
      324*  This entry point creates a new crossreference record of the type specified.
      325**/
      326 mu_db_xref$xref_create_record:
      327      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Ioffset, Oerror_message, Ocode);
      328 
      329 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      330 	crossref_info_record_ptr = addr (local_buffer);
      331 	temp_seg_ptr = null;
      332 	close_temp_file = FALSE;
      333 
      334 /* Look for the record, it had better not be there or we can't create it */
      335 	call find_record (Ikey_head, Irecord_name, null, 0);
      336 	if code = 0
      337 	then if Ikey_head = DOMAIN_KEY_HEAD		/* it was there */
      338 	     then call error (mrds_error_$domain_already_defined, Irecord_name);
      339 	     else call error (mrds_error_$attr_already_exists, Irecord_name);
      340 	else if code ^= error_table_$no_record
      341 	     then call error (code, error_message);
      342 
      343 /* It wasn't there, go ahead, create it and write it out to the file */
      344 	call add_name ("", Ioffset, "0"b);
      345 	call error (code, error_message);
      346 
      347 /************************* EP delete *************************/
      348 
      349 /*DESCRIPTION
      350*  This entry deletes a single record from the crossreference file. Note that
      351*  if other records reference this one, they are not modified. The caller should
      352*  call $dereference on all other referenced records before using $delete.
      353**/
      354 
      355 mu_db_xref$xref_delete_record:
      356      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Oerror_message, Ocode);
      357 
      358 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      359 	temp_seg_ptr = null;
      360 	close_temp_file = FALSE;
      361 
      362 	call find_record (Ikey_head, Irecord_name, null, 0);
      363 	if code ^= 0
      364 	then if code = error_table_$no_record
      365 	     then call error (0, "");
      366 	     else call error (code, error_message);
      367 
      368 	call iox_$delete_record (temp_file_iocb_ptr, code);
      369 	call error (code, "Unable to delete record for key list: " || key);
      370 
      371 /************************* EP dereference *************************/
      372 
      373 /*DESCRIPTION
      374*  This entry point deletes a specific name from a specified crossreference
      375*  record.
      376**/
      377 
      378 mu_db_xref$xref_dereference:
      379      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Iobject_name, Oreference_count, Oerror_message, Ocode);
      380 
      381 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      382 	temp_seg_ptr = null;
      383 	close_temp_file = FALSE;
      384 	call get_temp_dir_path;
      385 
      386 	on cleanup call cleaner;
      387 	call mu_temp_segments$get_temp_segment_path (temp_dir_path, myname, temp_seg_ptr, code);
      388 	if code ^= 0
      389 	then call error (code, "Cannot get temp segment.");
      390 
      391 	crossref_info_record_ptr = temp_seg_ptr;
      392 	max_seg_size = sys_info$max_seg_size * 4;
      393 	call find_record (Ikey_head, Irecord_name, crossref_info_record_ptr, max_seg_size);
      394 	if code ^= 0
      395 	then call error (code, "Seeking list record: " || key);
      396 
      397 	if ^search (Iobject_name, place)
      398 	then call error (mrds_error_$internal_error,
      399 		"Unable to find name " || rtrim (Iobject_name) || " in list record: " || key);
      400 
      401 	call delete (place);
      402 
      403 	call iox_$rewrite_record (temp_file_iocb_ptr, crossref_info_record_ptr, currentsize (crossref_info_record) * 4,
      404 	     code);
      405 	if code ^= 0
      406 	then call error (code, "Rewriting list record: " || key);
      407 
      408 	Oreference_count = crossref_info_record.count;
      409 
      410 	call error (0, "");
      411 
      412 /************************* EP modify_record_name *************************/
      413 
      414 /*DESCRIPTION
      415*  This entry point changes the key for a specified crossreference record.
      416*  This must be done be deleting the old record (with it's key), and re-entering
      417*  it. The contents of the record may or may not be specified. If not, the record
      418*  is read first. The current record is then deleted, and the same record is
      419*  then stored.
      420**/
      421 
      422 mu_db_xref$xref_modify_record_name:
      423      entry (Ifile_iocb_ptr, Ikey_head, Ifrom_name, Ito_name, Irecord_ptr, Oerror_message, Ocode);
      424 
      425 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      426 	temp_seg_ptr = null;
      427 	close_temp_file = FALSE;
      428 
      429 	if Irecord_ptr = null
      430 	then do;
      431 	     call get_temp_dir_path;
      432 	     on cleanup call cleaner;
      433 
      434 	     call mu_temp_segments$get_temp_segment_path (temp_dir_path, myname, temp_seg_ptr, code);
      435 	     if code ^= 0
      436 	     then call error (code, "Cannot get a temp segment.");
      437 
      438 	     max_seg_size = sys_info$max_seg_size * 4;
      439 	     crossref_info_record_ptr = temp_seg_ptr;
      440 
      441 	     call find_record (Ikey_head, Ifrom_name, crossref_info_record_ptr, max_seg_size);
      442 	     if code ^= 0
      443 	     then call error (code, error_message);
      444 	     end;
      445 	else do;
      446 	     crossref_info_record_ptr = Irecord_ptr;
      447 	     temp_seg_ptr = null;
      448 
      449 	     call find_record (Ikey_head, Ifrom_name, null, (0));
      450 	     if code ^= 0
      451 	     then call error (code, error_message);
      452 	     end;
      453 
      454 	call iox_$delete_record (temp_file_iocb_ptr, code);
      455 	if code ^= 0
      456 	then call error (code, "Deleting list record: " || key);
      457 
      458 	call find_record (Ikey_head, Ito_name, null, (0));
      459 	if code ^= error_table_$no_record
      460 	then call error (mrds_error_$internal_error, "Found list record but shouldn't have:" || key);
      461 
      462 	call iox_$write_record (temp_file_iocb_ptr, crossref_info_record_ptr, currentsize (crossref_info_record) * 4,
      463 	     code);
      464 	if code ^= 0
      465 	then call error (code, "Writing list record: " || key);
      466 
      467 	call error (0, "");
      468 
      469 /************************* EP modify_reference_name *************************/
      470 
      471 /*DESCRIPTION
      472*  This entry point reads the specified record from the crossreference file,
      473*  searches for the specified name. It should be there. It then deletes the
      474*  old name, and adds the new name. This effectively does a rename operation.
      475*  Note that in the initial implementation it moves all the names twice in the
      476*  worst case. It should be modified to check whether the insertion point is also
      477*  the deletion point.
      478**/
      479 
      480 mu_db_xref$xref_modify_reference_name:
      481      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Ifrom_name, Ito_name, Oerror_message, Ocode);
      482 
      483 	temp_seg_ptr = null;
      484 	close_temp_file = FALSE;
      485 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      486 	call get_temp_dir_path;
      487 
      488 	on cleanup call cleaner;
      489 
      490 	call mu_temp_segments$get_temp_segment_path (temp_dir_path, myname, temp_seg_ptr, code);
      491 	if code ^= 0
      492 	then call error (code, "Unable to get a temp segment.");
      493 
      494 	crossref_info_record_ptr = temp_seg_ptr;
      495 	max_seg_size = sys_info$max_seg_size * 4;
      496 
      497 /* Retrieve the specified record */
      498 	call find_record (Ikey_head, Irecord_name, crossref_info_record_ptr, max_seg_size);
      499 	if code ^= 0
      500 	then call error (code, error_message);
      501 
      502 /* Find the specified from name */
      503 	if ^search (Ifrom_name, place)
      504 	then call error (mrds_error_$internal_error,
      505 		"Unable to find name " || rtrim (Ifrom_name) || " in list record: " || key);
      506 
      507 	call delete (place);
      508 	call add_name (Ito_name, "0"b, "1"b);
      509 
      510 	call error (0, "");
      511 
      512 /************************* INTERNAL delete *************************/
      513 
      514 /*DESCRIPTION
      515*  This internal subroutine deletes a single name from the current
      516*  crossref_info_record. */
      517 
      518 delete:
      519      proc (idx);
      520 
      521 dcl  from_ptr ptr;
      522 dcl  idx fixed bin parameter;
      523 dcl  move_length fixed bin (21);
      524 dcl  to_ptr ptr;
      525 
      526 	if idx ^= crossref_info_record.count
      527 	then do;					/* if not last entry, must move data */
      528 	     from_ptr = addr (crossref_info_record.entry (idx + 1));
      529 	     to_ptr = addr (crossref_info_record.entry (idx));
      530 	     move_length = (crossref_info_record.count - idx) * 33;
      531 
      532 	     call mlr_ (from_ptr, move_length, to_ptr, move_length);
      533 	     end;
      534 
      535 	crossref_info_record.count = crossref_info_record.count - 1;
      536 	return;
      537      end delete;
      538 
      539 /************************* INTERNAL search *************************/
      540 
      541 /*DESCRIPTION
      542*  This internal subroutine looks for the specified name inthe current
      543*  crossreference_info_record. If found, it returns the position. If not found,
      544*  0 is returned; as the point for new entries is always at the end of the
      545*  list. */
      546 
      547 search:
      548      proc (name, idx) returns (bit (1) aligned);
      549 
      550 dcl  idx fixed bin parameter;
      551 dcl  name char (*) parameter;
      552 dcl  position fixed bin (21);
      553 dcl  search_name char (33);
      554 
      555 	search_name = OBJECT_HEAD || name;
      556 	position = index (crossref_info_record_objects, search_name);
      557 	if position = 0
      558 	then idx = 0;
      559 	else idx = divide (position, 33, 17, 0) + 1;
      560 	return (idx > 0);
      561 
      562      end search;
      563 
      564 /************************* EP find *************************/
      565 
      566 /*DESCRIPTION
      567*  This routine searches the temp file for the specified record, returning as
      568*  much of the record as was requested.
      569**/
      570 
      571 mu_db_xref$xref_find_record:
      572      entry (Ifile_iocb_ptr, Ikey_head, Irecord_name, Irecord_ptr, Irecord_length, Oerror_message, Ocode);
      573 
      574 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      575 	temp_seg_ptr = null;
      576 	close_temp_file = FALSE;
      577 
      578 	call find_record (Ikey_head, Irecord_name, Irecord_ptr, Irecord_length);
      579 	call error (code, error_message);
      580 
      581 /************************* INTERNAL find_record *************************/
      582 
      583 find_record:
      584      proc (key_head, record_name, record_ptr, record_length);
      585 
      586 dcl  chars_read fixed bin (21);
      587 dcl  key_head char (*) parameter;
      588 dcl  record_length fixed bin (21) parameter;
      589 dcl  record_name char (*) parameter;
      590 dcl  record_ptr ptr parameter;
      591 
      592 	key = key_head || rtrim (record_name);
      593 	call iox_$seek_key (temp_file_iocb_ptr, key, (0), code);
      594 	if code ^= 0
      595 	then do;
      596 	     error_message = "Seeking record key: " || key;
      597 	     return;
      598 	     end;
      599 
      600 	if record_ptr ^= null
      601 	then do;
      602 	     call iox_$read_record (temp_file_iocb_ptr, record_ptr, record_length, chars_read, code);
      603 	     if code ^= error_table_$long_record
      604 	     then error_message = "Reading list record: " || key;
      605 	     else do;
      606 		code = 0;
      607 		error_message = "";
      608 		end;
      609 	     end;
      610 	return;
      611      end find_record;
      612 
      613 /************************* EP statistics *************************/
      614 
      615 /*DESCRIPTION
      616*  This entry point returns the number of records of each type that exist in
      617*  the database crossreference file.
      618**/
      619 
      620 mu_db_xref$xref_statistics:
      621      entry (Ifile_iocb_ptr, Odomain_count, Oattribute_count, Orelation_count, Oerror_message, Ocode);
      622 
      623 /* Initialize */
      624 	temp_file_iocb_ptr = Ifile_iocb_ptr;
      625 	Odomain_count, Oattribute_count, Orelation_count = 0;
      626 	close_temp_file = FALSE;
      627 	
      628 /* Position to beginning of file */
      629 	call iox_$position (temp_file_iocb_ptr, -1, 0, code);
      630 	if code ^= 0
      631 	then call error (code, "Positioning to beginning of crossreference file.");
      632 
      633 /* Loop through all the records in the file */
      634 	call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      635 	do while (code = 0);
      636 	     if /* case */ substr (key, 1, min (length (key), length (ATTRIBUTE_KEY_HEAD))) = ATTRIBUTE_KEY_HEAD
      637 	     then Oattribute_count = Oattribute_count + 1;
      638 	     else if substr (key, 1, length (DOMAIN_KEY_HEAD)) = DOMAIN_KEY_HEAD
      639 	     then Odomain_count = Odomain_count + 1;
      640 	     else Orelation_count = Orelation_count + 1;
      641 	     call iox_$position (temp_file_iocb_ptr, 0, 1, code);
      642 						/* goto next record */
      643 	     if code = 0
      644 	     then call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      645 	     end;					/* do while */
      646 
      647 	if code = error_table_$end_of_info
      648 	then call error (0, "");
      649 	else call error (code, "Reading crossreference file.");
      650 
      651 RETURN_TO_CALLER:
      652 	return;
      653 
      654 /************************* INTERNAL error *************************/
      655 
      656 error:
      657      proc (code, msg);
      658 
      659 dcl  code fixed bin (35) parameter;
      660 dcl  msg char (*) parameter;
      661 
      662 	Ocode = code;
      663 	if code = 0
      664 	then Oerror_message = "";
      665 	else Oerror_message = msg;
      666 	call cleaner;
      667 
      668 	goto RETURN_TO_CALLER;
      669      end error;
      670 
      671 /************************* INTERNAL cleaner *************************/
      672 
      673 cleaner:
      674      proc;
      675 
      676 	if temp_seg_ptr ^= null
      677 	then call mu_temp_segments$free_temp_segment (myname, temp_seg_ptr, (0));
      678 	if (temp_file_iocb_ptr ^= null & close_temp_file)
      679 	then call close_and_delete_temp_file;
      680 
      681 	return;
      682      end cleaner;
      683 
      684 /************** INTERNAL close_and_delete_file ***********************/
      685 
      686 close_and_delete_temp_file:
      687      proc;
      688 
      689 	call iox_$close (temp_file_iocb_ptr, (0));
      690 	call iox_$detach_iocb (temp_file_iocb_ptr, (0));
      691 	call iox_$destroy_iocb (temp_file_iocb_ptr, (0));
      692 	temp_file_iocb_ptr = null;
      693 
      694 	call delete_$path (temp_dir_path, temp_file_attach_name, "101111"b, myname, (0));
      695 
      696 	return;
      697      end close_and_delete_temp_file;
      698 
      699 /************************* INTERNAL get_temp_dir_path *************************/
      700 
      701 /*DESCRIPTION
      702*  Find the directory the crossreference file is created in. This is the temp
      703*  directory specified for this rmdb invocation. */
      704 
      705 get_temp_dir_path:
      706      proc;
      707 
      708 	attach_block_ptr = temp_file_iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;
      709 	temp_dir_path = substr (attach_block.attach_descrip_string, 8, attach_block.dname_len);
      710 
      711 	return;
      712      end get_temp_dir_path;
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      713 
  2     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  2     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  2     3*      version number to IOX2. */
  2     4 /* format: style2 */
  2     5 
  2     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  2     7 	     2 version	      character (4) aligned,	/* IOX2 */
  2     8 	     2 name	      char (32),		/* I/O name of this block. */
  2     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    17 						/* open(p,mode,not_used,s) */
  2    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    24 						/* put_chars(p,bufptr,buflen,s) */
  2    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    26 						/* modes(p,newmode,oldmode,s) */
  2    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    28 						/* position(p,u1,u2,s) */
  2    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    30 						/* control(p,order,infptr,s) */
  2    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    34 						/* write_record(p,bufptr,buflen,s) */
  2    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    36 						/* rewrite_record(p,bufptr,buflen,s) */
  2    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    39 						/* seek_key(p,key,len,s) */
  2    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    41 						/* read_key(p,key,len,s) */
  2    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  2    43 						/* read_length(p,len,s) */
  2    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  2    45 						/* open_file(p,mode,desc,not_used,s) */
  2    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  2    47 						/* close_file(p,desc,s) */
  2    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  2    49 						/* detach(p,desc,s) */
  2    50 
  2    51      declare iox_$iocb_version_sentinel
  2    52 			      character (4) aligned external static;
  2    53 
  2    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      714 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
      715 
  4     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  4     6*     modified to save space occupied by model
  4     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  4     8*     to add mdbm_secured bit in db_model
  4     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  4    10*     collapsed the following into an unused_offset array:
  4    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  4    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  4    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  4    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  4    15*       unused_1
  4    16*     Also changed the name of unused_2 to restructuring_history_offset
  4    17*     and changed the comment on the changer structure to indicate
  4    18*     that it will contain on database creation information.
  4    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  4    20*     used one of the unused_offsets to point to a message which indicates
  4    21*     why the db is inconsistent. The offset will be null when the db is created
  4    22*     and set the first time the message is used. this is so it will be
  4    23*     consistent with existing data bases. Also added the message structure.
  4    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  4    25*     added the undo_request element to the message structure
  4    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  4    27*     changed unused_offset (12) to last_restructruring_history_offset and
  4    28*     changed restructuring_history_offset to first_restructuring_history_offset
  4    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  4    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  4    31*     1 => vfile database and 2 => page_file database. Up to this point all
  4    32*     database types were equal to 1.
  4    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  4    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  4    35*     flags. This will allow information about transactions and dm_file
  4    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  4    37*     change is compatable with all datamodels created by the released version
  4    38*     of mrds.
  4    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  4    40*     added the rollback_on flag to the db_type_flags since it appears that you
  4    41*     can have a dmfile database that requires transactions but does not have any
  4    42*     journalizing. Also switched the order of the transactions_needed and
  4    43*     concurrency_on flags - this makes the change compatable with existing
  4    44*     dmfile databases except when displaying the model since concurrency_on and
  4    45*     rollback_on will be off in the model even though the dmfile relations had
  4    46*     them on during creation.
  4    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  4    48*      Removed ctl_file_path_ptr.
  4    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  4    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  4    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  4    53*      in the flag word for rmdb copying.
  4    54*                                                   END HISTORY COMMENTS */
  4    55 
  4    56 
  4    57 /* this include file contains the structures that go into the make up
  4    58*   of the "db_model" segment in the model for the database.
  4    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  4    60*
  4    61*   the db_model structure goes at the base of the segment, and contains items unique to
  4    62*   the whole databse. in addition, it has an area of size to fill the
  4    63*   rest of a segment, that holds the lists of files and domains in the database.
  4    64*   these lists are singly forward linked lists. all "pointers" in the database model
  4    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  4    66*   since actual pointers are process dependent on segment number.
  4    67*   the remaining structures are first a path_entry one to save pathnames in,
  4    68*   and the stack_item and constent structures, used to save a boolean
  4    69*   expression in polish form, with the stack represented by a linked list.
  4    70*   the final structure is one for identifying the status of version information */
  4    71 
  4    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  4    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  4    74 	     2 db_type_flags      unal,
  4    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  4    76 	       3 unused	      (13) bit (1) unal,
  4    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  4    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  4    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  4    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  4    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  4    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  4    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  4    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  4    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  4    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  4    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  4    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  4    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  4    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  4    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  4    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  4    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  4    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  4    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  4    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  4    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  4    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  4    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  4   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  4   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  4   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  4   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  4   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  4   105 
  4   106      dcl	   dbm_ptr	      ptr;
  4   107 
  4   108 /* the files in the database each have a file_info containing
  4   109*   their name, the file_model for each file is found by initiating the
  4   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  4   111*   the file_info list is a singly linked list in definition order */
  4   112 
  4   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  4   114 	     2 file_name	      char (30),		/* name of file */
  4   115 	     2 file_id	      bit (36),		/* id number of file */
  4   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  4   117 	     2 unused	      unal bit (18);	/* for future expansion */
  4   118 
  4   119      dcl	   fi_ptr		      ptr;
  4   120 
  4   121 /* each domain used in the database will have a domain info saved in the db_model
  4   122*   segment. it describes the domain of the given name, and it's options.
  4   123*   the domain_info's form a singly linked list in definition order */
  4   124 
  4   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  4   126 	     2 name	      char (32),		/* name of domain */
  4   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  4   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  4   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  4   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  4   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  4   132 	     2 reserved	      bit (31) unal,
  4   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  4   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  4   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  4   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  4   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  4   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  4   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  4   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  4   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  4   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  4   143 	     2 str_err_path_ptr   unal bit (18),
  4   144 	     2 str_after_path_ptr unal bit (18),
  4   145 	     2 get_before_path_ptr unal bit (18),
  4   146 	     2 get_err_path_ptr   unal bit (18),
  4   147 	     2 get_after_path_ptr unal bit (18),
  4   148 	     2 mod_before_path_ptr unal bit (18),
  4   149 	     2 mod_err_path_ptr   unal bit (18),
  4   150 	     2 mod_after_path_ptr unal bit (18),
  4   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  4   152 	     2 unused_2	      unal bit (18),
  4   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  4   154 
  4   155      dcl	   di_ptr		      ptr;
  4   156 
  4   157 /* information necessary for attributes that are not used in any relation */
  4   158 
  4   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  4   160 	     2 name char (32),			/* name of attribute */
  4   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  4   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  4   163 	     2 unused (2) bit (18) unal;
  4   164 
  4   165      dcl     ua_ptr ptr;
  4   166 
  4   167 
  4   168 /* space saving pathname$entryname structure, to be allocated
  4   169*   only when a path$entry has to be saved, else only a bit(18)
  4   170*   offset takes up space in the main model structure */
  4   171 
  4   172      declare 1 path_entry	      based (path_entry_ptr),
  4   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  4   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  4   175 	     2 reserved	      unal bit (36);	/* for future use */
  4   176 
  4   177      declare path_entry_ptr	      ptr;
  4   178 
  4   179 
  4   180 
  4   181 
  4   182 
  4   183 /* declarations for model of postfix stack holding the check option boolean expression
  4   184*   the following encoding values indicate the corresponding type of stack element
  4   185*
  4   186*   1  =
  4   187*   2  ^=
  4   188*   3  >
  4   189*   4  <
  4   190*   5  >=
  4   191*   6  <=
  4   192*
  4   193*   10  and
  4   194*   20  or
  4   195*   30  not
  4   196*
  4   197*   40  - (minus)
  4   198*
  4   199*   50  domain variable(same name as domain)
  4   200*
  4   201*   60  constant(number, bit string, or character string)
  4   202*
  4   203**/
  4   204 
  4   205 
  4   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  4   207 	     2 next	      bit (18),		/* link to next in list */
  4   208 	     2 type	      fixed binary,		/* code for this element type */
  4   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  4   210*						   if this is a constant element type */
  4   211 
  4   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  4   213 
  4   214 
  4   215 
  4   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  4   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  4   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  4   219 
  4   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  4   221 
  4   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  4   223 
  4   224 /* version structure, giving status of source for CMDB/RMDB,
  4   225*   status of model, and status of resultant */
  4   226 
  4   227 /* version number is in form MM.N.Y
  4   228*   where MM is the major version number, N is the minor version alteration,
  4   229*   and Y is the lastest modification to that alteration,
  4   230*   where M and N represent numbers 0-9, and Y is a letter */
  4   231 
  4   232      declare 1 version_status	      unal based (version_status_ptr),
  4   233 	     2 cmdb_rmdb,
  4   234 	       3 major	      fixed bin,
  4   235 	       3 minor	      fixed bin,
  4   236 	       3 modification     char (4),
  4   237 	     2 model,
  4   238 	       3 major	      fixed bin,
  4   239 	       3 minor	      fixed bin,
  4   240 	       3 modification     char (4),
  4   241 	     2 resultant,
  4   242 	       3 major	      fixed bin,
  4   243 	       3 minor	      fixed bin,
  4   244 	       3 modification     char (4);
  4   245 
  4   246      declare version_status_ptr     ptr;
  4   247 
  4   248 
  4   249 /* maintains information only about the db creation */
  4   250 
  4   251      declare 1 changer	      unal based (changer_ptr),
  4   252 	     2 id		      char (32),
  4   253 	     2 time	      fixed bin (71),
  4   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  4   255 
  4   256      declare changer_ptr	      ptr;
  4   257 
  4   258 
  4   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  4   260 	     02 len	      fixed bin,		/* length of the message */
  4   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  4   262 	     02 name	      char (32),		/* name of thing that set the message */
  4   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  4   264*                                                               that caused the database to become inconsistent */
  4   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  4   266 
  4   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  4   268 
  4   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  4   270 
  4   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  4   272 
  4   273 
      716 
  5     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  5     6*     modified to save space occupied by model
  5     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  5     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  5     9*     the number of secondary indices in the relation - it was always zero.
  5    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  5    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  5    12*     DMS conversion.
  5    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  5    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  5    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  5    16*     for relation manager changes.
  5    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  5    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  5    20*     <rel> files are good (for rmdb)
  5    21*                                                   END HISTORY COMMENTS */
  5    22 
  5    23 
  5    24 /* each file in the database will have a model segment with the name
  5    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  5    26*   the file_model structure is allocated at the base of the segment for a given file.
  5    27*   it contains an area with which all other structures in this include file are allocated.
  5    28*   these structures contain the information about which relations, foreign keys,
  5    29*   and attributes are members of this file. all lists are singly linked lists in
  5    30*   definition order. pointers to these structures are obtained by using the "pointer"
  5    31*   builtin function with arguments of the segment base pointer, and the
  5    32*   offset (bit (18)) relative to that pointer that is actually stored in
  5    33*   the file model itself. this is because pointer segment numbers are
  5    34*   per process dependent. the major lists pointed to by the file_model structure
  5    35*   are the list of relations in this file(each with a contained attribute list),
  5    36*   and the list of foreign keys whose parent relation resides in this file
  5    37*   (along with a participating attribute sublist, and the child relation list,
  5    38*   if they are also in this file) */
  5    39 
  5    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  5    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  5    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  5    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  5    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  5    45     2 reserved bit (32) unal,				/* reserved for future flags */
  5    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  5    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  5    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  5    49     2 pad_1 fixed bin (35),				/* for future use */
  5    50     2 pad_2 fixed bin (35),
  5    51     2 ratd_len fixed bin (21),			/* length of above */
  5    52     2 mratd_len fixed bin (21),			/* length of above */
  5    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  5    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  5    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  5    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  5    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  5    58     2 block_size unal fixed bin,			/* no. pages in block */
  5    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  5    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  5    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  5    62     2 num_rels unal fixed bin,			/* number of relations in file */
  5    63     2 num_links unal fixed bin,			/* number of links in file */
  5    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  5    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  5    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  5    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  5    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  5    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  5    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  5    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  5    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  5    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  5    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  5    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  5    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  5    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  5    78     2 open_eu_err_path_ptr unal bit (18),
  5    79     2 open_eu_after_path_ptr unal bit (18),
  5    80     2 open_er_before_path_ptr unal bit (18),
  5    81     2 open_er_err_path_ptr unal bit (18),
  5    82     2 open_er_after_path_ptr unal bit (18),
  5    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  5    84     2 open_neu_err_path_ptr unal bit (18),
  5    85     2 open_neu_after_path_ptr unal bit (18),
  5    86     2 open_ner_before_path_ptr unal bit (18),
  5    87     2 open_ner_err_path_ptr unal bit (18),
  5    88     2 open_ner_after_path_ptr unal bit (18),
  5    89     2 open_pu_before_path_ptr unal bit (18),
  5    90     2 open_pu_err_path_ptr unal bit (18),
  5    91     2 open_pu_after_path_ptr unal bit (18),
  5    92     2 open_pr_before_path_ptr unal bit (18),
  5    93     2 open_pr_err_path_ptr unal bit (18),
  5    94     2 open_pr_after_path_ptr unal bit (18),
  5    95     2 open_cu_before_path_ptr unal bit (18),
  5    96     2 open_cu_err_path_ptr unal bit (18),
  5    97     2 open_cu_after_path_ptr unal bit (18),
  5    98     2 open_cr_before_path_ptr unal bit (18),
  5    99     2 open_cr_err_path_ptr unal bit (18),
  5   100     2 open_cr_after_path_ptr unal bit (18),
  5   101     2 close_before_path_ptr unal bit (18),
  5   102     2 close_err_path_ptr unal bit (18),
  5   103     2 close_after_path_ptr unal bit (18),
  5   104     2 unused_1 unal bit (18),				/* for future expansion */
  5   105     2 unused_2 unal bit (18),
  5   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  5   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  5   108 dcl  fm_ptr ptr;
  5   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  5   110 dcl  atd_ptr ptr;
  5   111 dcl  atd_len fixed bin;
  5   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  5   113     2 ncomponents fixed bin,
  5   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  5   115 dcl  cna_ptr ptr;
  5   116 dcl  ncomp_init fixed bin;
  5   117 
  5   118 /* a rel_info structure contains information describing a relation.
  5   119*   a relation may only occur in one file, thus there is one rel_info
  5   120*   per relation per database, each stored in the file_model area for
  5   121*   the file that contains it. the list of rel_info's in this file
  5   122*   form a singly linked list in definition order.
  5   123*   the rel_info itself points to a list of the attributes it contains,
  5   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  5   125 
  5   126 dcl 1 rel_info aligned based (ri_ptr),
  5   127     2 name char (32),				/* relation name */
  5   128     2 id  bit (36) aligned,				/* relation id number */
  5   129     2 hashed bit (1) unal,				/* on if hashed */
  5   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  5   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  5   132     2 system bit (1) unal,				/* on if dont care how stored */
  5   133     2 indexed bit (1) unal,				/* on if secondary index */
  5   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  5   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  5   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  5   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  5   138     2 reserved bit (27) unal,				/* for future flags */
  5   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  5   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  5   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  5   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  5   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  5   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  5   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  5   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  5   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  5   148     2 unused_3 unal fixed bin,			/* element that was never used */
  5   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  5   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  5   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  5   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  5   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  5   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  5   155     2 attr_ptr unal bit (18),				/* to attr. info */
  5   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  5   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  5   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  5   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  5   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  5   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  5   162     2 link_err_path_ptr unal bit (18),
  5   163     2 link_after_path_ptr unal bit (18),
  5   164     2 unlk_before_path_ptr unal bit (18),
  5   165     2 unlk_err_path_ptr unal bit (18),
  5   166     2 unlk_after_path_ptr unal bit (18),
  5   167     2 str_before_path_ptr unal bit (18),
  5   168     2 str_err_path_ptr unal bit (18),
  5   169     2 str_after_path_ptr unal bit (18),
  5   170     2 del_before_path_ptr unal bit (18),
  5   171     2 del_err_path_ptr unal bit (18),
  5   172     2 del_after_path_ptr unal bit (18),
  5   173     2 mod_before_path_ptr unal bit (18),
  5   174     2 mod_err_path_ptr unal bit (18),
  5   175     2 mod_after_path_ptr unal bit (18),
  5   176     2 find_before_path_ptr unal bit (18),
  5   177     2 find_err_path_ptr unal bit (18),
  5   178     2 find_after_path_ptr unal bit (18),
  5   179     2 retr_before_path_ptr unal bit (18),
  5   180     2 retr_err_path_ptr unal bit (18),
  5   181     2 retr_after_path_ptr unal bit (18),
  5   182     2 unused_1 unal bit (18),				/* for future expansion */
  5   183     2 unused_2 unal bit (18),
  5   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  5   185 dcl  ri_ptr ptr;
  5   186 
  5   187 /* a attr_info structure contains information about an attribute in a given relation.
  5   188*   since attributes may appear in more than one relation, each occurence of an attribute
  5   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  5   190*   the list is singly linked in definition order. the attr_info describes
  5   191*   the data it represents, and how that data is used during a database search. */
  5   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  5   193     2 name char (32),				/* name of attribute */
  5   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  5   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  5   196     2 link_attr bit (1) unal,				/* on if participates in link */
  5   197     2 reserved bit (33) unal,
  5   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  5   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  5   200     2 key_order unal fixed bin,			/* relative posit. in key */
  5   201     2 bit_offset fixed bin (35),			/* position in tuple */
  5   202     2 bit_length fixed bin (35),			/* length if fixed */
  5   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  5   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  5   205     2 domain_ptr unal bit (18),			/* to domain info */
  5   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  5   207     2 fwd_thread unal bit (18),			/* to next in list */
  5   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  5   209 dcl  ai_ptr ptr;
  5   210 
  5   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  5   212*   each time a foreign key definition indicates a relation as it's parent,
  5   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  5   214*   a relation can be parent and/or child in any number of foreign keys.
  5   215*   the parent_link_info structure describes the foreign key, and also points
  5   216*   to a list of the attributes that participate in this foreign key.
  5   217*   (this could be from 1 up to all attributes in the relation)
  5   218*   the attr_list structures are in a singly linked list in definition order
  5   219*   for this purpose. also pointed to is a list of child_link_info's
  5   220*   that describe the child relations in this foreign key. since foreign keys
  5   221*   may span files, not all related child_link_info's have to be in this file's
  5   222*   model area. */
  5   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  5   224     2 name char (32),				/* name of link */
  5   225     2 singular bit (1) unal,				/* on if system owned link */
  5   226     2 temp bit (1) unal,				/* on if temp. order */
  5   227     2 first bit (1) unal,				/* insertion indicators */
  5   228     2 last bit (1) unal,
  5   229     2 next bit (1) unal,
  5   230     2 prior bit (1) unal,
  5   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  5   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  5   233     2 dup_first bit (1) unal,				/* duplicates first */
  5   234     2 dup_last bit (1) unal,				/* duplicates last */
  5   235     2 indexed bit (1) unal,				/* locate parent via index */
  5   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  5   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  5   238     2 thread_27 bit (1) unal,
  5   239     2 thread_18 bit (1) unal,
  5   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  5   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  5   242     2 reserved bit (19) unal,				/* reserved for future flags */
  5   243     2 index_id aligned bit (8),			/* id of index if indexed */
  5   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  5   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  5   246     2 n_children unal fixed bin,			/* no. children in link */
  5   247     2 child_fn char (30),				/* file name for first child in list */
  5   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  5   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  5   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  5   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  5   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  5   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  5   254     2 sort_err_path_ptr unal bit (18),
  5   255     2 sort_after_path_ptr unal bit (18),
  5   256     2 srch_before_path_ptr unal bit (18),
  5   257     2 srch_err_path_ptr unal bit (18),
  5   258     2 srch_after_path_ptr unal bit (18),
  5   259     2 link_before_path_ptr unal bit (18),
  5   260     2 link_err_path_ptr unal bit (18),
  5   261     2 link_after_path_ptr unal bit (18),
  5   262     2 unlk_before_path_ptr unal bit (18),
  5   263     2 unlk_err_path_ptr unal bit (18),
  5   264     2 unlk_after_path_ptr unal bit (18),
  5   265     2 unused_1 unal bit (18),				/* for future expansion */
  5   266     2 unused_2 unal bit (18),
  5   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  5   268 dcl  pli_ptr ptr;
  5   269 
  5   270 /* a child_link_info structure is the counter part of a parent_link_info
  5   271*   for foreign key child relations. each time a relation is defined to be
  5   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  5   273*   this list is singly linked in foreign key definition order.
  5   274*   the child_link_info points to a list of participating attributes from the
  5   275*   child relation by means of a singly linked list of attr_list structures
  5   276*   in definition order. the number of attributes in the parent attr_list
  5   277*   and the child attr_list lists are the same with corresponding attr_list
  5   278*   attributes having the same domain. all child_link_infos in this file
  5   279*   are on a seperately linked list. this may not include all
  5   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  5   281*   since foreign keys may span files, and the child_link_info will
  5   282*   reside in the file containing it's associated relation_info. */
  5   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  5   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  5   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  5   286     2 fixed bit (1) unal,				/* on if membership fixed */
  5   287     2 optional bit (1) unal,				/* on if membership optional */
  5   288     2 auto bit (1) unal,				/* on if insertion automatic */
  5   289     2 manual bit (1) unal,				/* on if insertion manual */
  5   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  5   291     2 range_sel bit (1) unal,				/* on if range type selection */
  5   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  5   293     2 key_dup_last bit (1) unal,
  5   294     2 key_null bit (1) unal,				/* on if null allowed */
  5   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  5   296     2 sel_current bit (1) unal,
  5   297     2 sel_key bit (1) unal,
  5   298     2 sel_proc bit (1) unal,
  5   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  5   300     2 reserved bit (21) unal,
  5   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  5   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  5   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  5   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  5   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  5   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  5   307     2 parent_fn char (30),				/* file name for parent info */
  5   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  5   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  5   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  5   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  5   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  5   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  5   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  5   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  5   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  5   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  5   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  5   319     2 link_err_path_ptr unal bit (18),
  5   320     2 link_after_path_ptr unal bit (18),
  5   321     2 unlk_before_path_ptr unal bit (18),
  5   322     2 unlk_err_path_ptr unal bit (18),
  5   323     2 unlk_after_path_ptr unal bit (18),
  5   324     2 srch_before_path_ptr unal bit (18),
  5   325     2 srch_err_path_ptr unal bit (18),
  5   326     2 srch_after_path_ptr unal bit (18),
  5   327     2 unused_1 unal bit (18),				/* for future expansion */
  5   328     2 unused_2 unal bit (18) ;
  5   329 dcl  cli_ptr ptr;
  5   330 
  5   331 /* the attr_list structure is associated with the parent_link_info
  5   332*   and child_link_info structures to represent by means of a singly linked list
  5   333*   the participating attributes from relations in a foreign key.
  5   334*   the parent_link_info has a list for the parent relation,
  5   335*   and the child_link_info has a list for the child relation.
  5   336*   the participating attributes are a subset(not necessary proper) of
  5   337*   those attributes contained in a relation definition.
  5   338*   there are equal numbers of attr_list structures in the parent and
  5   339*   child lists of the same foreign key. the corresponding attributes in these
  5   340*   lists must have the same domain. */
  5   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  5   342     2 attr_fn char (30),				/* file name for attr. */
  5   343     2 attr_ptr unal bit (18),				/* to attr info block */
  5   344     2 fwd_thread unal bit (18);			/* to next in list */
  5   345 dcl  al_ptr ptr;
  5   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  5   347     2 ascend bit (1) unal,				/* ascending order */
  5   348     2 descend bit (1) unal,				/* descending order */
  5   349     2 reserved bit (34) unal,
  5   350     2 attr_ptr unal bit (18),				/* to attr info */
  5   351     2 fwd_thread unal bit (18);			/* to next in list */
  5   352 dcl  sk_ptr ptr;
  5   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  5   354     2 attr_ptr unal bit (18),				/* to attr info */
  5   355     2 fwd_thread unal bit (18);			/* to next in list */
  5   356 dcl  dp_ptr ptr;
  5   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  5   358     2 link_fn char (30),				/* file name for thru link */
  5   359     2 link_ptr unal bit (18),				/* to parent link info */
  5   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  5   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  5   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  5   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  5   364     2 fwd_thread unal bit (18);			/* to next in chain */
  5   365 dcl  sc_ptr ptr;
  5   366 
  5   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  5   368 
  5   369 
      717 
  6     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  6     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6     6*     written.
  6     7*                                                   END HISTORY COMMENTS */
  6     8 
  6     9 /*DESCRIPTION
  6    10*  The following structures are the definition of the records with the keyed
  6    11*  vfile that is built during restructuring. This file serves as a crossreference
  6    12*  of unique attributes and domains used within the specified MRDS database. Each
  6    13*  object is a char (33); the first byte is set to an unprintable character so we
  6    14*  can use the index builtin to find a specific object.
  6    15**/
  6    16 
  6    17 dcl crossref_info_record_ptr ptr;
  6    18 dcl crossref_info_record_count fixed bin (21);
  6    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  6    20      2 offset bit (18) unal,
  6    21      2 pad bit (18) unal,
  6    22      2 count fixed bin (21),
  6    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  6    24       3 object_head char (1),
  6    25       3 object char (32);
  6    26 
  6    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  6    28 			   based (addr (crossref_info_record.entry(1)));
  6    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  6    30 
  6    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  6    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  6    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  6    34 
  6    35 /*DESCRIPTION
  6    36*  The following structures are used to contain sufficient crossreference
  6    37*  information for the delete_attribute and delete_domain requests. These
  6    38*  requests require a more complete view of a crossreference tree, associating
  6    39*  domains, attributes and relations in 2 directions.
  6    40**/
  6    41 
  6    42 dcl domain_list_ptr ptr;
  6    43 dcl domain_list_count fixed bin;
  6    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  6    45 dcl 1 domain_list based (domain_list_ptr),
  6    46      2 count fixed bin,				/* number of domains in the list */
  6    47      2 name (domain_list_count refer (domain_list.count))
  6    48 	  char (33) unaligned,			/* name of this domain */
  6    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  6    50 		      ptr;			/* -> attribute_list structure */
  6    51 
  6    52 dcl attribute_list_ptr ptr;
  6    53 dcl attribute_list_count fixed bin;
  6    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  6    55 dcl 1 attribute_list based (attribute_list_ptr),
  6    56      2 count fixed bin,				/* number of attributes in the list */
  6    57      2 name (attribute_list_count refer (attribute_list.count))
  6    58 	  char (33) unaligned,			/* name of this attribute */
  6    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  6    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  6    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  6    62 		 ptr;				/* -> attribute structure */
  6    63 
  6    64 dcl relation_list_ptr ptr;
  6    65 dcl relation_list_count fixed bin;
  6    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  6    67 dcl 1 relation_list based (relation_list_ptr),
  6    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  6    69      2 name (relation_list_count refer (relation_list.count))
  6    70 	  char (33) unaligned,			/* name of this relation */
  6    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  6    72 		ptr;				/* -> relation structure */
  6    73 
  6    74 dcl relation_ptr ptr;
  6    75 dcl relation_attribute_count fixed bin;
  6    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  6    77 dcl 1 relation based (relation_ptr),
  6    78      2 name char (32),				/* name of the relation */
  6    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  6    80      2 copy_file_model_ptr ptr,
  6    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  6    82      2 mbz fixed bin (35),
  6    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  6    84       3 flags aligned,
  6    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  6    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  6    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  6    88         4 to_be_deleted bit (1) unaligned,
  6    89         4 pad bit (32) unaligned,
  6    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  6    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  6    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  6    93 						/*   it must be of the correct data type as specified by the domain */
  6    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  6    95 		   char (33) unaligned;
  6    96 
  6    97 dcl attribute_ptr ptr;
  6    98 dcl attribute_count fixed bin;
  6    99 dcl 1 attribute based (attribute_ptr),
  6   100      2 count fixed bin,				/* number of relations this attribute is used in */
  6   101      2 relation_idx (attribute_count refer (attribute.count))
  6   102 		fixed bin;			/* index into list of relation names */
  6   103 
  6   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      718 
  7     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      719 
  8     1 /* BEGIN INCLUDE FILE - vfile_attach_block.incl.pl1 */
  8     2 
  8     3 /* Written 06/18/81 by Lindsey Spratt.
  8     4**/
  8     5 
  8     6 /* format: style2 */
  8     7      dcl	   1 attach_block	      based (attach_block_ptr),
  8     8 						/* the following are set by attach_file */
  8     9 	     2 flags	      aligned,
  8    10 	       3 (extend_attach, appending, no_trunc, old, ssf, header_present, blocked, shared, was_msf, is_msf,
  8    11 		  inv_lock_reset, dup_ok_sw, trans_sw, noend_sw, exclu_sw, stat_sw, checkpoint_sw)
  8    12 			      bit (1) unal,
  8    13 	       3 pad	      bit (19) unal,
  8    14 	     2 wait_time	      fixed (35),
  8    15 	     2 interp	      fixed,
  8    16 	     2 max_rec_len	      fixed (35),
  8    17 	     2 header_id	      fixed (35),
  8    18 	     2 attach_descrip,
  8    19 	       3 attach_descrip_len
  8    20 			      fixed bin (35),	/* < = 256 */
  8    21 	       3 attach_descrip_string
  8    22 			      char (256),		/* "vfile_ " (7 chars), the directory
  8    23*						   pathname (dname_len chars), ">", the entry
  8    24*						   name (ename_len chars), " -extend" (optional 8 chars),
  8    25*						   and " -raw" or " -extend"(optional 8 chars) */
  8    26 	     2 dname_len	      fixed bin,		/* < = l68 */
  8    27 	     2 ename_len	      fixed bin,		/* < = 32 */
  8    28 						/* The following are set by open_file */
  8    29 	     2 open_descrip,
  8    30 	       3 open_descrip_len fixed bin (35),	/* < = 31 */
  8    31 	       3 open_descrip_string
  8    32 			      char (32),		/* The string
  8    33*						   contains the opening mode, e.g., "stream output",
  8    34*						   (< = 23 chars) and " -extend" (8chars optional) */
  8    35 	     2 mode	      fixed bin,		/* opening mode 1 <= 13 */
  8    36 	     2 file_type	      fixed bin,		/* 0 = uns, 1 = seq, 2 = indx, 3 = blk */
  8    37 	     2 fcb_ptr	      ptr,		/* pointer to msf_manager control block */
  8    38 	     2 first_seg_ptr      ptr,		/* pointer to first component
  8    39*						   of the file.  Thie pointer is valid throughout the
  8    40*						   file opening */
  8    41 	     2 close_x	      entry (ptr),		/* routine to perform operations required
  8    42*						   for closing specific type of file obtained from open_x see
  8    43*						   open_file */
  8    44 	     2 last_comp	      fixed,		/* msf component number at open */
  8    45 	     2 tcf_iocbp	      ptr;		/* iocb ptr for transaction control switch */
  8    46 
  8    47      dcl	   attach_block_ptr	      ptr;
  8    48 
  8    49 /* END INCLUDE FILE - vfile_attach_block.incl.pl1 */
      720 
      721 
      722 dcl  addr builtin;
      723 dcl  cleanup condition;
      724 dcl  close_temp_file bit (1) aligned;
      725 dcl  code fixed bin (35);
      726 dcl  currentsize builtin;
      727 dcl  db_path char (168);
      728 dcl  delete_$path entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      729 dcl  divide builtin;
      730 dcl  error_message char (500);
      731 dcl  error_table_$end_of_info fixed bin (35) ext static;
      732 dcl  error_table_$long_record fixed bin (35) ext static;
      733 dcl  error_table_$no_record fixed bin (35) ext static;
      734 dcl  FALSE bit (1) aligned int static options (constant) init ("0"b);
      735 dcl  file_model_name char (32);
      736 dcl  fixed builtin;
      737 dcl  Idb_path char (*) parameter;
      738 dcl  Idbm_ptr ptr parameter;
      739 dcl  Ifile_iocb_ptr ptr parameter;
      740 dcl  Ifrom_name char (*) parameter;
      741 dcl  Ikey_head char (*) parameter;
      742 dcl  index builtin;
      743 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      744 dcl  Iobject_name char (*) parameter;
      745 dcl  Ioffset bit (18) unaligned parameter;
      746 dcl  IOfile_iocb_ptr ptr parameter;
      747 dcl  IOfile_name char (*) parameter;
      748 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      749 dcl  iox_$close entry (ptr, fixed bin (35));
      750 dcl  iox_$delete_record entry (ptr, fixed bin (35));
      751 dcl  iox_$destroy_iocb entry (ptr, fixed bin (35));
      752 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      753 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      754 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      755 dcl  iox_$read_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      756 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      757 dcl  iox_$rewrite_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      758 dcl  iox_$seek_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      759 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      760 dcl  Irecord_length fixed bin (21) parameter;
      761 dcl  Irecord_name char (*) parameter;
      762 dcl  Irecord_ptr ptr parameter;
      763 dcl  Itemp_dir_path char (*) parameter;
      764 dcl  Ito_name char (*) parameter;
      765 dcl  key char (256) varying;
      766 dcl  length builtin;
      767 dcl  local_buffer (10) fixed bin (35);
      768 dcl  max_seg_size fixed bin (21);
      769 dcl  mu_temp_segments$free_temp_segment entry (char (*), ptr, fixed bin (35));
      770 dcl  mu_temp_segments$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
      771 dcl  min builtin;
      772 dcl  mlr_ entry (ptr, fixed bin (21), ptr, fixed bin (21));
      773 dcl  mrds_error_$attr_already_exists fixed bin (35) ext static;
      774 dcl  mrds_error_$domain_already_defined fixed bin (35) ext static;
      775 dcl  mrds_error_$internal_error fixed bin (35) ext static;
      776 dcl  myname char (32) int static options (constant) init ("mu_db_xref");
      777 dcl  null builtin;
      778 dcl  NULL_OFFSET bit (18) unal int static options (constant) init ((18)"1"b);
      779 dcl  Oattribute_count fixed bin parameter;
      780 dcl  Ocode fixed bin (35) parameter;
      781 dcl  Odomain_count fixed bin parameter;
      782 dcl  Oerror_message char (*) parameter;
      783 dcl  Ofile_name char (*) parameter;
      784 dcl  Oiocb_ptr ptr parameter;
      785 dcl  Oreference_count fixed bin (21) parameter;
      786 dcl  Orelation_count fixed bin parameter;
      787 dcl  place fixed bin;
      788 dcl  ptr builtin;
      789 dcl  rel builtin;
      790 dcl  rtrim builtin;
      791 dcl  substr builtin;
      792 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      793 dcl  temp_dir_path char (168);
      794 dcl  temp_file_attach_desc char (256);
      795 dcl  temp_file_attach_name char (32);
      796 dcl  temp_file_iocb_ptr ptr;
      797 dcl  temp_seg_ptr ptr;
      798 dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      799 dcl  TRUE bit (1) aligned int static options (constant) init ("1"b);
      800 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      801 
      802      end mu_db_xref;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1142.8  mu_db_xref.pl1                    >special_ldd>install>MR12.0-1187>mu_db_xref.pl1
713          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
714          2    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
715          3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
716          4    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
717          5    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
718          6    10/16/86  1140.3  rmdb_crossref_info.incl.pl1       >special_ldd>install>MR12.0-1187>rmdb_crossref_info.incl.pl1
719          7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
720          8    07/31/81  1818.2  vfile_attach_block.incl.pl1       >ldd>include>vfile_attach_block.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000016 constant        char(10)                 initial unaligned dcl 6-31 set ref 101* 154* 183*
                                                                                  636 636
DOMAIN_KEY_HEAD                 000014 constant        char(7)                  initial unaligned dcl 6-32 set ref 119* 165* 197*
                                                                                  336 638 638
FALSE                                  constant        bit(1)                   initial dcl 734 ref 215 252 332 360 383 427 484 576
                                                                                  626
IOfile_iocb_ptr                        parameter       pointer                  dcl 746 set ref 225 228 236*
IOfile_name                            parameter       char                     unaligned dcl 747 set ref 225 230 237*
Idb_path                               parameter       char                     unaligned dcl 737 ref 38 44
Idbm_ptr                               parameter       pointer                  dcl 738 ref 38 45
Ifile_iocb_ptr                         parameter       pointer                  dcl 739 ref 247 250 326 329 355 358 378 381 422 425
                                                                                  480 485 571 574 620 624
Ifrom_name                             parameter       char                     unaligned dcl 740 set ref 422 441* 449* 480 503* 503
Ikey_head                              parameter       char                     unaligned dcl 741 set ref 247 262* 326 335* 336 355
                                                                                  362* 378 393* 422 441* 449* 458* 480 498* 571 578*
Iobject_name                           parameter       char                     unaligned dcl 744 set ref 247 266* 378 397* 397
Ioffset                                parameter       bit(18)                  unaligned dcl 745 set ref 326 344*
Irecord_length                         parameter       fixed bin(21,0)          dcl 760 set ref 247 271 571 578*
Irecord_name                           parameter       char                     unaligned dcl 761 set ref 247 262* 326 335* 336*
                                                                                  339* 355 362* 378 393* 480 498* 571 578*
Irecord_ptr                            parameter       pointer                  dcl 762 set ref 247 269 272* 422 429 446 571 578*
Itemp_dir_path                         parameter       char                     unaligned dcl 763 ref 38 43 225 229
Ito_name                               parameter       char                     unaligned dcl 764 set ref 422 458* 480 508*
Keyed_sequential_update         000031 constant        fixed bin(17,0)          initial dcl 3-15 set ref 62*
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 778 ref 76 98 151 180
OBJECT_HEAD                     007370 constant        char(1)                  initial unaligned dcl 6-29 ref 298 309 555
Oattribute_count                       parameter       fixed bin(17,0)          dcl 779 set ref 620 625* 636* 636
Ocode                                  parameter       fixed bin(35,0)          dcl 780 set ref 38 225 247 326 355 378 422 480 571
                                                                                  620 662*
Odomain_count                          parameter       fixed bin(17,0)          dcl 781 set ref 620 625* 638* 638
Oerror_message                         parameter       char                     unaligned dcl 782 set ref 38 225 247 326 355 378 422
                                                                                  480 571 620 663* 665*
Ofile_name                             parameter       char                     unaligned dcl 783 set ref 38 213*
Oiocb_ptr                              parameter       pointer                  dcl 784 set ref 38 214*
Oreference_count                       parameter       fixed bin(21,0)          dcl 785 set ref 378 408*
Orelation_count                        parameter       fixed bin(17,0)          dcl 786 set ref 620 625* 640* 640
RELATION_KEY_HEAD               000011 constant        char(9)                  initial unaligned dcl 6-33 set ref 85*
R_ACCESS                        000032 constant        bit(3)                   initial unaligned dcl 1-11 set ref 80*
TERM_FILE_TERM                  000010 constant        bit(3)                   initial unaligned dcl 7-14 set ref 56* 141*
TRUE                                   constant        bit(1)                   initial dcl 799 ref 53 233
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-6 ref 708
addr                                                   builtin function         dcl 722 ref 330 528 529 556
ai_ptr                          000114 automatic       pointer                  dcl 5-209 set ref 98* 98* 101 110 118 122 128 132*
                                                                                  138
attach_block                           based           structure                level 1 unaligned dcl 8-7
attach_block_ptr                000120 automatic       pointer                  dcl 8-47 set ref 708* 709 709
attach_data_ptr          16            based           pointer                  level 2 dcl 2-6 ref 708
attach_descrip            5            based           structure                level 2 unaligned dcl 8-7
attach_descrip_string
                          6            based           char(256)                level 3 packed unaligned dcl 8-7 ref 709
attr_info                              based           structure                level 1 dcl 5-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 5-126 ref 98
chars_read                      001016 automatic       fixed bin(21,0)          dcl 586 set ref 602*
cleanup                         000122 stack reference condition                dcl 723 ref 54 255 386 432 488
close_temp_file                 000130 automatic       bit(1)                   dcl 724 set ref 53* 215* 233* 252* 332* 360* 383*
                                                                                  427* 484* 576* 626* 678
code                            000131 automatic       fixed bin(35,0)          dcl 725 in procedure "mu_db_xref" set ref 61* 62 62*
                                                                                  64 64* 67* 68 68* 80* 81* 86 86* 88 88* 102 105
                                                                                  105* 108 111 111* 114* 120 123 123* 126 130 130*
                                                                                  133 133* 136* 141* 142 142* 155 158 158* 161 161*
                                                                                  166 169 169* 172 172* 185 187 190 190* 193* 198
                                                                                  201 201* 204 207* 256* 257 257* 263 263* 267 276*
                                                                                  301* 314* 336 340 340* 345* 363 363 366* 368* 369*
                                                                                  387* 388 388* 394 394* 403* 405 405* 434* 435 435*
                                                                                  442 442* 450 450* 454* 455 455* 459 462* 464 464*
                                                                                  490* 491 491* 499 499* 579* 593* 594 602* 603 606*
                                                                                  629* 630 630* 634* 635 641* 643 643* 647 649*
code                                   parameter       fixed bin(35,0)          dcl 659 in procedure "error" ref 656 662 663
count                     1            based           fixed bin(21,0)          level 2 dcl 6-19 set ref 271 297 297* 301 308* 309
                                                                                  312* 314 403 408 462 526 530 535* 535 556
crossref_info_record                   based           structure                level 1 unaligned dcl 6-19 set ref 271 301 314 403
                                                                                  462
crossref_info_record_objects           based           char                     unaligned dcl 6-27 ref 556
crossref_info_record_ptr        000116 automatic       pointer                  dcl 6-17 set ref 70* 85* 101* 119* 154* 165* 183*
                                                                                  197* 260* 262* 271 272* 297 297 298 299 301* 301
                                                                                  305 308 309 310 312 314* 314 330* 391* 393* 403*
                                                                                  403 408 439* 441* 446* 462* 462 494* 498* 526 528
                                                                                  529 530 535 535 556 556
currentsize                                            builtin function         dcl 726 ref 271 301 314 403 462
db_model                               based           structure                level 1 dcl 4-72
db_path                         000132 automatic       char(168)                unaligned dcl 727 set ref 44* 80* 81
dbm_ptr                         000100 automatic       pointer                  dcl 4-106 set ref 45* 76 76 118 145 151 151 175 180
                                                                                  180 196 209
delete_$path                    000010 constant        entry                    external dcl 728 ref 694
di_ptr                          000104 automatic       pointer                  dcl 4-155 set ref 118* 119 128 151* 151* 154 157 157
                                                                                  165 168 168 168* 175 196* 197
divide                                                 builtin function         dcl 729 ref 559
dname_len               106            based           fixed bin(17,0)          level 2 dcl 8-7 ref 709
domain_info                            based           structure                level 1 dcl 4-125
domain_ptr               17            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 5-192 in procedure "mu_db_xref" set ref 110*
                                                                                  118 128*
domain_ptr               10            based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 4-159 in procedure "mu_db_xref" set
                                                                                  ref 189* 196
domain_ptr               22(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 4-72 in procedure "mu_db_xref" ref 151
entry                     2            based           structure                array level 2 packed unaligned dcl 6-19 set ref 528
                                                                                  529 556
error_message                   000204 automatic       char(500)                unaligned dcl 730 set ref 88* 340* 345* 366* 442*
                                                                                  450* 499* 579* 596* 603* 607*
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 731 ref 647
error_table_$long_record        000014 external static fixed bin(35,0)          dcl 732 ref 603
error_table_$no_record          000016 external static fixed bin(35,0)          dcl 733 ref 88 108 126 155 166 187 204 340 363 459
fi_ptr                          000102 automatic       pointer                  dcl 4-119 set ref 76* 76* 79 85 86 91 91 104 110*
                                                                                  145
file_info                              based           structure                level 1 dcl 4-113
file_model                             based           structure                level 1 dcl 5-40
file_model_name                 000401 automatic       char(32)                 unaligned dcl 735 set ref 79* 80* 81 142
file_name                              based           char(30)                 level 2 dcl 4-113 ref 79 85 86 104 110
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 4-72 ref 76
fm_ptr                          000110 automatic       pointer                  dcl 5-108 set ref 52* 56 56* 80* 81 94 94 98 138
                                                                                  141*
from_ptr                        000762 automatic       pointer                  dcl 521 set ref 528* 532*
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 4-113 ref 145
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  unaligned dcl 4-159 in procedure "mu_db_xref" ref
                                                                                  209
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed unaligned
                                                                                  dcl 5-192 in procedure "mu_db_xref" ref 138
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed unaligned
                                                                                  dcl 4-125 in procedure "mu_db_xref" ref 175
idx                                    parameter       fixed bin(17,0)          dcl 522 in procedure "delete" ref 518 526 528 529
                                                                                  530
idx                             000750 automatic       fixed bin(17,0)          dcl 287 in procedure "add_name" set ref 295*
idx                                    parameter       fixed bin(17,0)          dcl 550 in procedure "search" set ref 547 557* 559*
                                                                                  560
index                                                  builtin function         dcl 742 ref 556
initiate_file_                  000020 constant        entry                    external dcl 743 ref 80
iocb                                   based           structure                level 1 dcl 2-6
iox_$attach_name                000022 constant        entry                    external dcl 748 ref 61
iox_$close                      000024 constant        entry                    external dcl 749 ref 689
iox_$delete_record              000026 constant        entry                    external dcl 750 ref 368 454
iox_$destroy_iocb               000030 constant        entry                    external dcl 751 ref 691
iox_$detach_iocb                000032 constant        entry                    external dcl 752 ref 690
iox_$open                       000034 constant        entry                    external dcl 753 ref 62
iox_$position                   000036 constant        entry                    external dcl 754 ref 629 641
iox_$read_key                   000040 constant        entry                    external dcl 755 ref 634 643
iox_$read_record                000042 constant        entry                    external dcl 756 ref 602
iox_$rewrite_record             000044 constant        entry                    external dcl 757 ref 301 403
iox_$seek_key                   000046 constant        entry                    external dcl 758 ref 593
iox_$write_record               000050 constant        entry                    external dcl 759 ref 314 462
key                             000411 automatic       varying char(256)        dcl 765 set ref 105 111 114 123 130 133 136 158 161
                                                                                  169 172 185 190 193 201 204 207 263 276 369 394
                                                                                  397 405 455 459 464 503 592* 593* 596 603 634* 636
                                                                                  636 638 643*
key_head                               parameter       char                     unaligned dcl 587 ref 583 592
length                                                 builtin function         dcl 766 ref 636 636 638
local_buffer                    000512 automatic       fixed bin(35,0)          array dcl 767 set ref 330
max_seg_size                    000524 automatic       fixed bin(21,0)          dcl 768 set ref 72* 85* 101* 119* 154* 165* 183*
                                                                                  197* 261* 262* 271* 272* 272* 392* 393* 438* 441*
                                                                                  495* 498*
min                                                    builtin function         dcl 771 ref 271 636
mlr_                            000056 constant        entry                    external dcl 772 ref 272 532
move_length                     000764 automatic       fixed bin(21,0)          dcl 523 set ref 530* 532* 532*
mrds_error_$attr_already_exists 000060 external static fixed bin(35,0)          dcl 773 set ref 339*
mrds_error_$domain_already_defined
                                000062 external static fixed bin(35,0)          dcl 774 set ref 336*
mrds_error_$internal_error      000064 external static fixed bin(35,0)          dcl 775 set ref 185* 204* 397* 459* 503*
msg                                    parameter       char                     unaligned dcl 660 ref 656 665
mu_temp_segments$free_temp_segment
                                000052 constant        entry                    external dcl 769 ref 676
mu_temp_segments$get_temp_segment_path
                                000054 constant        entry                    external dcl 770 ref 67 256 387 434 490
myname                          000000 constant        char(32)                 initial unaligned dcl 776 set ref 67* 256* 387* 434*
                                                                                  490* 676* 694*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 5-192
                                                                                  in procedure "mu_db_xref" ref 101 122 132
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 4-125
                                                                                  in procedure "mu_db_xref" ref 119 128 154 165 168
                                                                                  197
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 4-159 in procedure "mu_db_xref" ref 183 200
name                                   parameter       char                     unaligned dcl 288 in procedure "add_name" set ref
                                                                                  284 295* 299 306 310
name                                   parameter       char                     unaligned dcl 551 in procedure "search" ref 547 555
null                                                   builtin function         dcl 777 ref 52 56 61 61 81 232 233 236 251 269 331
                                                                                  335 335 359 362 362 382 426 429 447 449 449 458
                                                                                  458 483 575 600 676 678 692
object                    2(09)        based           char(32)                 array level 3 packed unaligned dcl 6-19 set ref 299*
                                                                                  310*
object_head               2            based           char(1)                  array level 3 packed unaligned dcl 6-19 set ref 298*
                                                                                  309*
offset                                 parameter       bit(18)                  unaligned dcl 289 in procedure "add_name" ref 284
                                                                                  305
offset                                 based           bit(18)                  level 2 in structure "crossref_info_record" packed
                                                                                  unaligned dcl 6-19 in procedure "mu_db_xref" set
                                                                                  ref 305*
place                           000525 automatic       fixed bin(17,0)          dcl 787 set ref 397* 401* 503* 507*
position                        000751 automatic       fixed bin(17,0)          dcl 290 in procedure "add_name" set ref 297* 298 299
position                        000776 automatic       fixed bin(21,0)          dcl 552 in procedure "search" set ref 556* 557 559
ptr                                                    builtin function         dcl 788 ref 76 94 98 118 138 145 151 175 180 196 209
record_exists                          parameter       bit(1)                   dcl 291 ref 284 293
record_length                          parameter       fixed bin(21,0)          dcl 588 set ref 583 602*
record_name                            parameter       char                     unaligned dcl 589 ref 583 592
record_ptr                             parameter       pointer                  dcl 590 set ref 583 600 602*
rel                                                    builtin function         dcl 789 ref 76 91 91 98 151 157 157 168 168 180
rel_info                               based           structure                level 1 dcl 5-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 5-40 ref 94
ri_ptr                          000112 automatic       pointer                  dcl 5-185 set ref 94* 98
rtrim                                                  builtin function         dcl 790 ref 50 79 81 397 503 592
search_name                     000777 automatic       char(33)                 unaligned dcl 553 set ref 555* 556
substr                                                 builtin function         dcl 791 ref 636 638 709
sys_info$max_seg_size           000066 external static fixed bin(35,0)          dcl 792 ref 72 261 392 438 495
temp_dir_path                   000526 automatic       char(168)                unaligned dcl 793 set ref 43* 50 67* 229* 256* 387*
                                                                                  434* 490* 694* 709*
temp_file_attach_desc           000600 automatic       char(256)                unaligned dcl 794 set ref 50* 61* 64*
temp_file_attach_name           000700 automatic       char(32)                 unaligned dcl 795 set ref 49* 50 61* 213 230* 694*
temp_file_iocb_ptr              000710 automatic       pointer                  dcl 796 set ref 52* 61* 62* 214 228* 233 250* 301*
                                                                                  314* 329* 358* 368* 381* 403* 425* 454* 462* 485*
                                                                                  574* 593* 602* 624* 629* 634* 641* 643* 678 689*
                                                                                  690* 691* 692* 708
temp_seg_ptr                    000712 automatic       pointer                  dcl 797 set ref 52* 67* 70 232* 251* 256* 260 331*
                                                                                  359* 382* 387* 391 426* 434* 439 447* 483* 490*
                                                                                  494 575* 676 676*
terminate_file_                 000070 constant        entry                    external dcl 798 ref 56 141
to_ptr                          000766 automatic       pointer                  dcl 524 set ref 529* 532*
ua_ptr                          000106 automatic       pointer                  dcl 4-165 set ref 180* 180* 183 189 196 200* 209
unique_chars_                   000072 constant        entry                    external dcl 800 ref 49
unreferenced_attribute                 based           structure                level 1 dcl 4-159
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed unaligned dcl 4-72 ref 180

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 3-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 3-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 3-15
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 3-15
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 3-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 3-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 3-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 3-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 3-15
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 7-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
al_ptr                                 automatic       pointer                  dcl 5-345
alloc_length                           internal static fixed bin(35,0)          dcl 4-222
atd                                    based           char                     unaligned dcl 5-109
atd_len                                automatic       fixed bin(17,0)          dcl 5-111
atd_ptr                                automatic       pointer                  dcl 5-110
attr_list                              based           structure                level 1 dcl 5-341
attribute                              based           structure                level 1 unaligned dcl 6-99
attribute_count                        automatic       fixed bin(17,0)          dcl 6-98
attribute_list                         based           structure                level 1 unaligned dcl 6-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 6-53
attribute_list_names                   based           char                     unaligned dcl 6-54
attribute_list_ptr                     automatic       pointer                  dcl 6-52
attribute_ptr                          automatic       pointer                  dcl 6-97
changer                                based           structure                level 1 packed unaligned dcl 4-251
changer_ptr                            automatic       pointer                  dcl 4-256
child_link_info                        based           structure                level 1 dcl 5-283
cli_ptr                                automatic       pointer                  dcl 5-329
cna_ptr                                automatic       pointer                  dcl 5-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 5-112
constant                               based           structure                level 1 unaligned dcl 4-216
constant_ptr                           automatic       pointer                  dcl 4-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 6-18
domain_list                            based           structure                level 1 unaligned dcl 6-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 6-43
domain_list_names                      based           char                     unaligned dcl 6-44
domain_list_ptr                        automatic       pointer                  dcl 6-42
dp_ptr                                 automatic       pointer                  dcl 5-356
dup_prev                               based           structure                level 1 dcl 5-353
fixed                                                  builtin function         dcl 736
iox_$iocb_version_sentinel             external static char(4)                  dcl 2-51
iox_modes                              internal static char(24)                 initial array dcl 3-6
message_str                            based           structure                level 1 packed unaligned dcl 4-259
message_str_len                        automatic       fixed bin(17,0)          dcl 4-269
message_str_ptr                        automatic       pointer                  dcl 4-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 5-116
parent_link_info                       based           structure                level 1 dcl 5-223
path_entry                             based           structure                level 1 packed unaligned dcl 4-172
path_entry_ptr                         automatic       pointer                  dcl 4-177
pli_ptr                                automatic       pointer                  dcl 5-268
relation                               based           structure                level 1 unaligned dcl 6-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 6-75
relation_attribute_names               based           char                     unaligned dcl 6-76
relation_list                          based           structure                level 1 unaligned dcl 6-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 6-65
relation_list_names                    based           char                     unaligned dcl 6-66
relation_list_ptr                      automatic       pointer                  dcl 6-64
relation_ptr                           automatic       pointer                  dcl 6-74
sc_ptr                                 automatic       pointer                  dcl 5-365
select_chain                           based           structure                level 1 dcl 5-357
short_iox_modes                        internal static char(4)                  initial array dcl 3-12
sk_ptr                                 automatic       pointer                  dcl 5-352
sort_key                               based           structure                level 1 dcl 5-346
stack_item                             based           structure                level 1 unaligned dcl 4-206
stack_item_ptr                         automatic       pointer                  dcl 4-212
terminate_file_switches                based           structure                level 1 packed unaligned dcl 7-4
version_status                         based           structure                level 1 packed unaligned dcl 4-232
version_status_ptr                     automatic       pointer                  dcl 4-246

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLER                006201 constant        label                    dcl 651 ref 668
add_name                        006202 constant        entry                    internal dcl 284 ref 91 104 110 122 128 132 157 168
                                                                                  189 200 266 344 508
cleaner                         006772 constant        entry                    internal dcl 673 ref 58 255 386 432 488 666
close_and_delete_temp_file      007036 constant        entry                    internal dcl 686 ref 678
delete                          006400 constant        entry                    internal dcl 518 ref 401 507
error                           006715 constant        entry                    internal dcl 656 ref 64 68 81 86 88 105 111 114 123
                                                                                  130 133 136 142 158 161 169 172 185 190 193 201
                                                                                  204 207 217 238 257 263 274 276 336 339 340 345
                                                                                  363 366 369 388 394 397 405 410 435 442 450 455
                                                                                  459 464 467 491 499 503 510 579 630 647 649
find_record                     006522 constant        entry                    internal dcl 583 ref 85 101 119 154 165 183 197 262
                                                                                  335 362 393 441 449 458 498 578
get_temp_dir_path               007137 constant        entry                    internal dcl 705 ref 253 384 431 486
mu_db_xref                      000334 constant        entry                    external dcl 23
mu_db_xref$xref_build           000350 constant        entry                    external dcl 38
mu_db_xref$xref_create_record   003406 constant        entry                    external dcl 326
mu_db_xref$xref_delete_record   003626 constant        entry                    external dcl 355
mu_db_xref$xref_dereference     004025 constant        entry                    external dcl 378
mu_db_xref$xref_destroy         002676 constant        entry                    external dcl 225
mu_db_xref$xref_find_record     005632 constant        entry                    external dcl 571
mu_db_xref$xref_modify_record_name
                                004504 constant        entry                    external dcl 422
mu_db_xref$xref_modify_reference_name
                                005231 constant        entry                    external dcl 480
mu_db_xref$xref_reference       003007 constant        entry                    external dcl 247
mu_db_xref$xref_statistics      005745 constant        entry                    external dcl 620
search                          006447 constant        entry                    internal dcl 547 ref 295 397 503

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10254       10350    7373       10264
Length     11062    7373        74         476     661           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_db_xref                          664 external procedure  is an external procedure.  
on unit on line 54                   84 on unit               
on unit on line 255                  64 on unit               
add_name                                internal procedure  shares stack frame of external procedure mu_db_xref.  
on unit on line 386                  64 on unit               
on unit on line 432                  64 on unit               
on unit on line 488                  64 on unit               
delete                                  internal procedure  shares stack frame of external procedure mu_db_xref.  
search                                  internal procedure  shares stack frame of external procedure mu_db_xref.  
find_record                             internal procedure  shares stack frame of external procedure mu_db_xref.  
error                                65 internal procedure  is called during a stack extension.  
cleaner                             116 internal procedure  is called by several nonquick procedures.  
close_and_delete_temp_file              internal procedure  shares stack frame of internal procedure cleaner.  
get_temp_dir_path                       internal procedure  shares stack frame of external procedure mu_db_xref.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_db_xref               000100 dbm_ptr                     mu_db_xref
                         000102 fi_ptr                      mu_db_xref
                         000104 di_ptr                      mu_db_xref
                         000106 ua_ptr                      mu_db_xref
                         000110 fm_ptr                      mu_db_xref
                         000112 ri_ptr                      mu_db_xref
                         000114 ai_ptr                      mu_db_xref
                         000116 crossref_info_record_ptr    mu_db_xref
                         000120 attach_block_ptr            mu_db_xref
                         000130 close_temp_file             mu_db_xref
                         000131 code                        mu_db_xref
                         000132 db_path                     mu_db_xref
                         000204 error_message               mu_db_xref
                         000401 file_model_name             mu_db_xref
                         000411 key                         mu_db_xref
                         000512 local_buffer                mu_db_xref
                         000524 max_seg_size                mu_db_xref
                         000525 place                       mu_db_xref
                         000526 temp_dir_path               mu_db_xref
                         000600 temp_file_attach_desc       mu_db_xref
                         000700 temp_file_attach_name       mu_db_xref
                         000710 temp_file_iocb_ptr          mu_db_xref
                         000712 temp_seg_ptr                mu_db_xref
                         000750 idx                         add_name
                         000751 position                    add_name
                         000762 from_ptr                    delete
                         000764 move_length                 delete
                         000766 to_ptr                      delete
                         000776 position                    search
                         000777 search_name                 search
                         001016 chars_read                  find_record

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
delete_$path                  initiate_file_                iox_$attach_name              iox_$close
iox_$delete_record            iox_$destroy_iocb             iox_$detach_iocb              iox_$open
iox_$position                 iox_$read_key                 iox_$read_record              iox_$rewrite_record
iox_$seek_key                 iox_$write_record             mlr_
mu_temp_segments$free_temp_segment                          mu_temp_segments$get_temp_segment_path
terminate_file_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record      error_table_$no_record
mrds_error_$attr_already_exists                             mrds_error_$domain_already_defined
mrds_error_$internal_error    sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000333        26 000341        38 000342        43 000403        44 000413        45 000421        49 000424
     50 000456        52 000536        53 000543        54 000545        56 000561        58 000614        59 000621
     61 000622        62 000654        64 000675        67 000713        68 000740        70 000761        72 000763
     76 000767        79 001001        80 001030        81 001067        85 001135        86 001145        88 001170
     91 001207        94 001216        98 001226       101 001237       102 001246       104 001250       105 001263
    107 001316       108 001320       110 001323       111 001352       113 001405       114 001407       118 001440
    119 001447       120 001455       122 001457       123 001472       125 001525       126 001527       128 001532
    130 001561       132 001614       133 001630       135 001663       136 001665       138 001716       141 001726
    142 001754       145 002000       151 002007       154 002021       155 002030       157 002034       158 002043
    160 002076       161 002100       165 002133       166 002143       168 002147       169 002162       171 002215
    172 002217       175 002252       180 002262       183 002273       185 002302       187 002337       189 002343
    190 002366       192 002421       193 002423       196 002454       197 002463       198 002471       200 002473
    201 002506       203 002541       204 002543       207 002600       209 002632       213 002642       214 002650
    215 002652       217 002653       225 002670       228 002724       229 002730       230 002740       232 002745
    233 002747       236 002754       237 002756       238 002762       247 002777       250 003050       251 003054
    252 003056       253 003057       255 003060       256 003102       257 003127       260 003153       261 003155
    262 003161       263 003207       266 003242       267 003271       269 003273       271 003277       272 003312
    274 003327       275 003344       276 003345       326 003376       329 003435       330 003441       331 003443
    332 003445       335 003446       336 003476       339 003526       340 003545       344 003564       345 003607
    355 003623       358 003655       359 003661       360 003663       362 003664       363 003714       366 003737
    368 003753       369 003764       378 004015       381 004061       382 004065       383 004067       384 004070
    386 004071       387 004113       388 004140       391 004164       392 004166       393 004172       394 004220
    397 004253       401 004370       403 004373       405 004420       408 004453       410 004460       422 004475
    425 004541       426 004545       427 004547       429 004550       431 004553       432 004554       434 004576
    435 004623       438 004644       439 004650       441 004652       442 004700       444 004716       446 004717
    449 004722       450 004752       454 004770       455 005001       458 005034       459 005066       462 005123
    464 005151       467 005204       480 005222       483 005270       484 005272       485 005273       486 005277
    488 005300       490 005322       491 005347       494 005370       495 005372       498 005376       499 005424
    503 005442       507 005557       508 005562       510 005606       571 005623       574 005666       575 005672
    576 005674       578 005675       579 005722       620 005736       624 005762       625 005766       626 005771
    629 005772       630 006012       634 006033       635 006051       636 006054       638 006067       640 006076
    641 006100       643 006120       645 006140       647 006141       649 006162       651 006201       284 006202
    293 006213       295 006217       297 006243       298 006250       299 006254       301 006262       303 006307
    305 006310       306 006315       308 006322       309 006324       310 006342       311 006350       312 006351
    314 006352       318 006377       518 006400       526 006402       528 006406       529 006412       530 006422
    532 006426       535 006443       536 006446       547 006447       555 006460       556 006476       557 006510
    559 006513       560 006516       583 006522       592 006540       593 006600       594 006617       596 006621
    597 006636       600 006640       602 006645       603 006664       605 006706       606 006707       607 006710
    610 006713       656 006714       662 006730       663 006734       665 006747       666 006761       668 006766
    673 006771       676 006777       678 007025       681 007035       686 007036       689 007037       690 007052
    691 007065       692 007100       694 007103       696 007136       705 007137       708 007140       709 007144
    711 007150


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
