	COMPILATION LISTING OF SEGMENT collmgr_display
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0918.4 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2,ind3 */
        7 collmgr_display:
        8 cmds:
        9    proc ();
       10 
       11 /*
       12*DESCRIPTION:
       13*
       14*     This command displays the collection_manager_ file_header, and the
       15*collection_headers for each of the collections in a DM file.
       16**/
       17 
       18 /*
       19*HISTORY:
       20*
       21*Written by Lindsey L. Spratt, 12/01/82.
       22*Modified:
       23*12/17/82 by Lindsey Spratt:  Added element displays and finer control over
       24*	  what is displayed.
       25*01/12/83 by Lindsey Spratt:  Fixed to initialize display_flag to "0"b.  Also
       26*	  fixed messages for displaying elements.
       27*03/08/83 by Lindsey Spratt:  Added special interpretation for a collection_idx
       28*	  of 0.  This identifies the header collection.  Added the ability
       29*	  to display an element formatted by an arbitrary structure (using
       30*	  the display_structure technology).  Changed the -element control
       31*	  option to only accept one element per option.
       32*12/05/84 by Lindsey L. Spratt:  Fixed to declare the undeclared builtins.
       33**/
       34 /* START OF DECLARATIONS */
       35 /* Parameter */
       36 /* Automatic */
       37 
       38       dcl	    file_dir	       char (168) init ("");
       39       dcl	    file_entry	       char (32) init ("");
       40       dcl	    (file_opening_id, current_collection_id)
       41 			       bit (36) aligned init ("0"b);
       42       dcl	    work_area_ptr	       ptr init (null);
       43       dcl	    1 local_print_data_info
       44 			       like print_data_info;
       45       dcl	    temp_string_ptr	       ptr init (null);
       46       dcl	    collection_idx	       fixed bin;
       47       dcl	    display_idx	       fixed bin init (0);
       48       dcl	    first_collection_idx   fixed bin init (0);
       49       dcl	    number_of_collections  fixed bin init (0);
       50       dcl	    1 automatic_cm_file_header
       51 			       like cm_file_header;
       52       dcl	    collection_id_table_length_in_bits
       53 			       fixed bin (35);
       54       dcl	    element_ptr	       ptr init (null);
       55       dcl	    element_length	       fixed bin (35) init (0);
       56       dcl	    (root_element_spec_ptr, element_spec_ptr, old_spec_ptr, next_ptr)
       57 			       ptr init (null);
       58 
       59       dcl	    display_flag	       (7) bit (1) aligned;
       60 
       61       dcl	    display_info	       bit (1) aligned defined display_flag (1);
       62       dcl	    display_header	       bit (1) aligned defined display_flag (2);
       63       dcl	    display_file_header    bit (1) aligned defined display_flag (3);
       64       dcl	    display_collection_id_table
       65 			       bit (1) aligned defined display_flag (4);
       66       dcl	    display_element	       bit (1) aligned defined display_flag (5);
       67       dcl	    display_element_in_characters
       68 			       bit (1) aligned defined display_flag (6);
       69       dcl	    display_header_collection
       70 			       bit (1) aligned defined display_flag (7);
       71 
       72       dcl	    true_arg	       char (32) varying init ("");
       73 
       74 /* Based */
       75 
       76       dcl	    work_area	       area (sys_info$max_seg_size) based (work_area_ptr);
       77       dcl	    temp_string	       based (temp_string_ptr) char (sys_info$max_seg_size * 4) varying;
       78 
       79       dcl	    1 element_spec	       based (element_spec_ptr),
       80 	      2 next	       ptr init (null),
       81 	      2 structure_name     char (32) varying init (""),
       82 	      2 collection_idx     fixed bin init (0),
       83 	      2 position	       fixed bin (17),
       84 	      2 id	       like element_id;
       85 
       86       dcl	    element	       based (element_ptr) bit (element_length);
       87       dcl	    character_element      based (element_ptr) char (divide (element_length, 9, 35, 0));
       88 
       89 /* Builtin */
       90 
       91       dcl	    (addr, bin, char, divide, hbound, index, length, null, rtrim, substr, unspec)
       92 			       builtin;
       93 
       94 /* Constant */
       95 
       96       dcl	    BITS_PER_BYTE	       init (9) fixed bin (35) internal static options (constant);
       97 
       98       dcl	    DISPLAY_KEYWORD	       (7, 2) char (32) varying
       99 			       init ("info", "i", "header", "h", "file_header", "fh", "collection_id_table", "cit",
      100 			       "element", "e", "element_in_characters", "eic", "header_collection", "hc")
      101 			       internal static options (constant);
      102 
      103       dcl	    myname	       init ("collmgr_display") char (32) varying internal static options (constant);
      104       dcl	    argument_type	       (9) internal static options (constant) char (64) varying
      105 			       init ("DM file pathname", "index into the collection_id_table",
      106 			       "index into the collection_id_table", "number of collections",
      107 			       "number of collections", "keyword", "keyword", "element_id", "element_id");
      108       dcl	    control_argument       (9) internal static options (constant) char (64) varying
      109 			       init ("-file", "-first_collection", "-ftc", "-number_of_collections", "-noc",
      110 			       "-display", "-ds", "-element", "-el");
      111 
      112 /* Entry */
      113 
      114       dcl	    ioa_		       entry () options (variable);
      115       dcl	    ioa_$nnl	       entry () options (variable);
      116       dcl	    file_manager_$open     entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      117       dcl	    cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      118       dcl	    cm_get_element	       entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
      119 			       fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
      120       dcl	    expand_pathname_       entry (char (*), char (*), char (*), fixed bin (35));
      121       dcl	    get_system_free_area_  entry () returns (ptr);
      122       dcl	    get_temp_segment_      entry (char (*), ptr, fixed bin (35));
      123       dcl	    release_temp_segment_  entry (char (*), ptr, fixed bin (35));
      124       dcl	    print_data_	       entry (char (*) var, ptr, fixed bin (35));
      125 
      126 /* External */
      127 
      128       dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
      129       dcl	    dm_error_$file_already_open
      130 			       fixed bin (35) ext static;
      131 
      132 /* END OF DECLARATIONS */
      133 
      134       display_flag = "0"b;
      135       display_file_header, display_info, display_header = "1"b;
      136       work_area_ptr = get_system_free_area_ ();
      137 
      138 /* Process arguments. */
      139 
      140       call cu_$af_return_arg (nargs, return_arg_ptr, return_arg_len, code);
      141       if code = 0
      142       then is_active_function = "1"b;
      143       else if code = error_table_$not_act_fnc
      144       then is_active_function = "0"b;
      145       else
      146          do;
      147 	  call com_err_ (code, myname);
      148 	  return;
      149          end;
      150 
      151       if is_active_function
      152       then complain = active_fnc_err_;
      153       else complain = com_err_;
      154 
      155       if nargs = 0
      156       then
      157          do;
      158 	  call complain (error_table_$noarg, myname, "^/Usage: ^a  {-control_args}", myname);
      159 	  return;
      160          end;
      161       accept_control_argument = "1"b;
      162       control_argument_idx = 1;
      163 
      164 ARG_PROCESSING_LOOP:
      165       do arg_idx = 1 to nargs;
      166          call cu_$arg_ptr (arg_idx, arg_ptr, arg_len, code);
      167          if char (arg, 1) ^= "-"
      168          then
      169 PROCESS_ARG:
      170 	  do;
      171 	     goto ARG (control_argument_idx);
      172 
      173 
      174 ARG (-1):						/* unexpected argument */
      175 	     call complain (error_table_$badopt, myname, "Argument is out of place: ^a.", arg);
      176 	     return;
      177 
      178 ARG (1):						/* -file */
      179 	     call expand_pathname_ (arg, file_dir, file_entry, code);
      180 	     if code ^= 0
      181 	     then
      182 	        do;
      183 		 call complain (code, myname, "^/Unable to expand the pathname ""^a"".", arg);
      184 		 return;
      185 	        end;
      186 
      187 	     control_argument_idx = -1;
      188 	     accept_control_argument = "1"b;
      189 	     goto NEXT_1;
      190 ARG (2):						/* -first_collection */
      191 ARG (3):						/* -ftc */
      192 	     first_collection_idx = bin (arg);
      193 
      194 	     control_argument_idx = -1;
      195 	     accept_control_argument = "1"b;
      196 	     goto NEXT_1;
      197 ARG (4):						/* -number_of_collections */
      198 ARG (5):						/* -noc */
      199 	     number_of_collections = bin (arg);
      200 
      201 	     control_argument_idx = -1;
      202 	     accept_control_argument = "1"b;
      203 	     goto NEXT_1;
      204 ARG (6):						/* -display */
      205 ARG (7):						/* -ds */
      206 	     if char (arg, 1) = "^"
      207 	     then true_arg = substr (arg, 2);
      208 	     else true_arg = arg;
      209 	     do display_idx = 1 to hbound (DISPLAY_KEYWORD, 1)
      210 		while (DISPLAY_KEYWORD (display_idx, 1) ^= true_arg & DISPLAY_KEYWORD (display_idx, 2) ^= true_arg);
      211 	     end;
      212 	     if display_idx > hbound (DISPLAY_KEYWORD, 1)
      213 	     then
      214 	        do;
      215 		 call complain (error_table_$badopt, myname,
      216 		      "^/Invalid display keyword ""^a"".  Valid display keywords are:
      217 ^v(^a (^a), ^)and ^a (^a).", arg, hbound (DISPLAY_KEYWORD, 1) - 1, DISPLAY_KEYWORD);
      218 		 call FINISH;
      219 		 return;
      220 	        end;
      221 	     display_flag (display_idx) = (arg = true_arg);
      222 
      223 	     accept_control_argument = "1"b;
      224 	     goto NEXT_1;
      225 
      226 ARG (8):						/* -element */
      227 ARG (9):						/* -el */
      228 	     old_spec_ptr = element_spec_ptr;
      229 	     alloc element_spec in (work_area);
      230 	     if root_element_spec_ptr = null
      231 	     then root_element_spec_ptr = element_spec_ptr;
      232 	     else old_spec_ptr -> element_spec.next = element_spec_ptr;
      233 	     element_spec.next = null;
      234 	     element_spec.position = 0;
      235 	     unspec (element_spec.id) = "0"b;
      236 	     element_spec.collection_idx = bin (arg);
      237 	     control_argument_idx = -2;
      238 	     accept_control_argument = "0"b;
      239 	     goto NEXT_1;
      240 
      241 ARG (-2):
      242 	     element_spec.id.control_interval_id = bin (arg);
      243 	     control_argument_idx = -3;
      244 	     accept_control_argument = "0"b;
      245 	     goto NEXT_1;
      246 
      247 ARG (-3):
      248 	     element_spec.id.index = bin (arg);
      249 	     control_argument_idx = -4;
      250 	     accept_control_argument = "1"b;
      251 	     goto NEXT_1;
      252 
      253 ARG (-4):
      254 	     element_spec.structure_name = arg;
      255 	     control_argument_idx = -1;
      256 
      257 	     accept_control_argument = "1"b;
      258 	     goto NEXT_1;
      259 NEXT_1:
      260 	  end PROCESS_ARG;
      261          else if control_argument_idx ^= -1 & ^accept_control_argument
      262          then
      263 	  do;
      264 	     if control_argument_idx = -2 | control_argument_idx = -3
      265 	     then control_argument_idx = 8;
      266 	     call complain (error_table_$noarg, myname, "^a must be followed by a^[n^] ^a.",
      267 		control_argument (control_argument_idx),
      268 		(index ("aeiouh", substr (argument_type (control_argument_idx), 1, 1)) > 0),
      269 		argument_type (control_argument_idx));
      270 	     return;
      271 	  end;
      272          else
      273 PROCESS_CONTROL_ARG:
      274 	  do;
      275 	     do control_argument_idx = 1 to hbound (control_argument, 1)
      276 		while (control_argument (control_argument_idx) ^= arg);
      277 	     end;
      278 	     if control_argument_idx > hbound (control_argument, 1)
      279 	     then
      280 	        do;
      281 		 call complain (error_table_$badopt, myname, "^a", arg);
      282 		 return;
      283 	        end;
      284 
      285 	     goto CONTROL_ARG (control_argument_idx);
      286 
      287 CONTROL_ARG (0):
      288 	     ;
      289 CONTROL_ARG (1):					/* -file */
      290 	     accept_control_argument = "0"b;
      291 	     goto NEXT_ARG;
      292 
      293 CONTROL_ARG (2):					/* -first_collection */
      294 CONTROL_ARG (3):					/* -ftc */
      295 	     accept_control_argument = "0"b;
      296 	     goto NEXT_ARG;
      297 
      298 CONTROL_ARG (4):					/* -number_of_collections */
      299 CONTROL_ARG (5):					/* -noc */
      300 	     accept_control_argument = "0"b;
      301 	     goto NEXT_ARG;
      302 
      303 CONTROL_ARG (6):					/* -display */
      304 CONTROL_ARG (7):					/* -ds */
      305 	     display_file_header, display_info, display_header = "1"b;
      306 	     display_collection_id_table, display_element, display_element_in_characters = "0"b;
      307 
      308 	     goto NEXT_ARG;
      309 
      310 CONTROL_ARG (8):					/* -element */
      311 CONTROL_ARG (9):					/* -el */
      312 	     display_element = "1"b;
      313 
      314 	     accept_control_argument = "0"b;
      315 	     goto NEXT_ARG;
      316 
      317 NEXT_ARG:
      318 	     ;
      319 	  end PROCESS_CONTROL_ARG;
      320       end ARG_PROCESSING_LOOP;
      321       if control_argument_idx ^= -1 & ^accept_control_argument
      322       then
      323          do;
      324 	  if control_argument_idx = -2 | control_argument_idx = -3
      325 	  then control_argument_idx = 8;
      326 	  call complain (error_table_$noarg, myname, "^a must be followed by a^[n^] ^a.",
      327 	       control_argument (control_argument_idx),
      328 	       (index ("aeiouh", substr (argument_type (control_argument_idx), 1, 1)) > 0),
      329 	       argument_type (control_argument_idx));
      330 	  return;
      331          end;
      332 
      333       call get_temp_segment_ ((myname), temp_string_ptr, code);
      334       if code ^= 0
      335       then
      336          do;
      337 	  call complain (code, myname, "^/Unable to get a temp_segment.");
      338 	  call FINISH;
      339 	  return;
      340          end;
      341 
      342       if file_dir = ""
      343       then
      344          do;
      345 	  call complain (error_table_$noarg, myname, "^/A DM file pathname must be specified.");
      346 	  call FINISH;
      347 	  return;
      348          end;
      349 
      350       call file_manager_$open (file_dir, file_entry, file_opening_id, code);
      351       if code ^= 0 & code ^= dm_error_$file_already_open
      352       then
      353          do;
      354 	  call complain (code, myname, "^/Unable to open the file ""^a^[>^]^a"".", file_dir, file_dir ^= ">",
      355 	       file_entry);
      356 	  call FINISH;
      357 	  return;
      358          end;
      359 
      360       call cm_opening_info$get (file_opening_id, HEADER_COLLECTION_ID, cm_info_ptr, code);
      361       if code ^= 0
      362       then
      363          do;
      364 	  call complain (code, myname, "^/Unable to get the opening info for the header collection (id ^o), for
      365 file ""^a^[>^]^a"".", HEADER_COLLECTION_ID, file_dir, file_dir ^= ">", file_entry);
      366 	  call FINISH;
      367 	  return;
      368          end;
      369 
      370       call cm_get_element (cm_info.file_oid, cm_info.collection_id, CM_FILE_HEADER_ELEMENT_ID, 0,
      371 	 addr (automatic_cm_file_header), length (unspec (automatic_cm_file_header)), null, ("0"b), cm_file_header_ptr,
      372 	 (0), code);
      373       if code ^= 0
      374       then
      375          do;
      376 	  call complain (code, myname, "^/Unable to get the file_header.");
      377 	  call FINISH ();
      378 	  return;
      379          end;
      380 
      381 
      382       if cm_file_header.number_of_collections = 0
      383       then
      384          do;
      385 	  call complain (0, myname, "^/The file ""^a^[>^]^a"" contains no collections.", file_dir, file_dir ^= ">",
      386 	       file_entry);
      387 	  call FINISH;
      388 	  return;
      389          end;
      390 
      391       print_data_info_ptr = addr (local_print_data_info);
      392 
      393       call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID, cm_file_header.collection_id_table_element_id, 0, null,
      394 	 (0), work_area_ptr, "1"b, collection_id_table_ptr, collection_id_table_length_in_bits, code);
      395       if code ^= 0
      396       then
      397          do;
      398 	  call complain (code, myname, "^/Unable to get the collection_id_table.");
      399 	  call FINISH ();
      400 	  return;
      401          end;
      402       cit_number_of_collections = cm_file_header.number_of_collections;
      403 
      404       print_data_info.version = print_data_info_version_1;
      405       print_data_info.indentation = 2;
      406       print_data_info.value_column = 30;
      407       print_data_info.output_switch = null;
      408       print_data_info.flags.octal = "1"b;
      409       print_data_info.intervals = "";
      410 
      411       if display_file_header
      412       then
      413          do;
      414 	  put string (temp_string) data (cm_file_header);
      415 	  call print_data_ (temp_string, print_data_info_ptr, code);
      416 	  if code ^= 0
      417 	  then
      418 	     do;
      419 	        call complain (code, myname, "^/Unable to display the cm_file_header structure.");
      420 	        call FINISH;
      421 	        return;
      422 	     end;
      423 
      424          end;
      425       if display_collection_id_table
      426       then
      427          do;
      428 	  put string (temp_string) data (collection_id_table);
      429 	  call print_data_ (temp_string, print_data_info_ptr, code);
      430 	  if code ^= 0
      431 	  then
      432 	     do;
      433 	        call complain (code, myname, "^/Unable to display the collection_id_table structure.");
      434 	        call FINISH;
      435 	        return;
      436 	     end;
      437          end;
      438 
      439       if display_header_collection
      440       then
      441          do;
      442 	  call ioa_ ("^/The header collection, id ^o:", HEADER_COLLECTION_ID);
      443 	  if display_info
      444 	  then
      445 	     do;
      446 	        put string (temp_string) data (cm_info);
      447 	        call print_data_ (temp_string, print_data_info_ptr, code);
      448 	     end;
      449 	  if display_header
      450 	  then
      451 	     do;
      452 	        put string (temp_string) data (cm_info.header_ptr -> collection_header);
      453 	        call print_data_ (temp_string, print_data_info_ptr, code);
      454 	     end;
      455          end;
      456 
      457       if first_collection_idx = 0
      458       then first_collection_idx = 1;
      459       if number_of_collections = 0
      460       then number_of_collections = cit_number_of_collections - first_collection_idx + 1;
      461 
      462       if ^display_element
      463       then
      464 COLLECTION_LOOP:
      465          do collection_idx = first_collection_idx to first_collection_idx + number_of_collections - 1;
      466 
      467 	  call ioa_ ("^/Collection ^d - id ^o:", collection_idx, collection_id_table (collection_idx));
      468 
      469 	  call cm_opening_info$get (file_opening_id, collection_id_table (collection_idx), cm_info_ptr, code);
      470 	  if code ^= 0
      471 	  then
      472 	     do;
      473 	        call complain (code, myname, "^/Unable to get the opening info for the header collection (id ^o), for
      474 file ""^a^[>^]^a"".", collection_id_table (collection_idx), file_dir, file_dir ^= ">", file_entry);
      475 	        call FINISH;
      476 	        return;
      477 	     end;
      478 
      479 	  if display_info
      480 	  then
      481 	     do;
      482 	        put string (temp_string) data (cm_info);
      483 	        call print_data_ (temp_string, print_data_info_ptr, code);
      484 	        if code ^= 0
      485 	        then
      486 		 do;
      487 		    call complain (code, myname,
      488 		         "^/Unable to display the cm_info structure for collection ^d, with id ^o.", collection_idx,
      489 		         collection_id_table (collection_idx));
      490 		    call FINISH;
      491 		    return;
      492 		 end;
      493 	     end;
      494 	  if display_header
      495 	  then
      496 	     do;
      497 	        put string (temp_string) data (cm_info.header_ptr -> collection_header);
      498 	        call print_data_ (temp_string, print_data_info_ptr, code);
      499 	        if code ^= 0
      500 	        then
      501 		 do;
      502 		    call complain (code, myname, "^/Unable to display the collection_header structure.");
      503 		    call FINISH;
      504 		    return;
      505 		 end;
      506 	     end;
      507 
      508          end COLLECTION_LOOP;
      509       else
      510 ELEMENT_DISPLAY:
      511          do;
      512 	  do element_spec_ptr = root_element_spec_ptr repeat (element_spec.next) while (element_spec_ptr ^= null);
      513 	     if element_spec.collection_idx > 0
      514 	     then current_collection_id = collection_id_table (element_spec.collection_idx);
      515 	     else current_collection_id = HEADER_COLLECTION_ID;
      516 	     call cm_get_element (file_opening_id, current_collection_id, unspec (element_spec.id),
      517 		element_spec.position, null, (0), work_area_ptr, ("0"b), element_ptr, element_length, code);
      518 	     if code ^= 0
      519 	     then
      520 	        do;
      521 		 call complain (code, myname, "^/Unable to get element in slot ^d of control interval ^d 
      522 (in collection number ^d with id ^o).", element_spec.id.index, element_spec.id.control_interval_id,
      523 		      element_spec.collection_idx, current_collection_id);
      524 		 call FINISH;
      525 		 return;
      526 	        end;
      527 
      528 	     call ioa_ ("Element for slot ^d of control interval ^d (collection ^o,  number ^d):",
      529 		element_spec.id.index, element_spec.id.control_interval_id, current_collection_id,
      530 		element_spec.collection_idx);
      531 
      532 	     if element_spec.structure_name ^= ""
      533 	     then call DISPLAY_ELEMENT_BY_STRUCTURE (addr (element), (element_spec.structure_name), code);
      534 	     else if display_element_in_characters
      535 	     then call ioa_ ("^a", character_element);
      536 	     else call ioa_ ("^.3b", element);
      537 
      538 	     free element in (work_area);
      539 
      540 	  end;
      541          end ELEMENT_DISPLAY;
      542 
      543       call FINISH;
      544       return;
      545 
      546 FINISH:
      547    proc;
      548       if temp_string_ptr ^= null
      549       then call release_temp_segment_ ((myname), temp_string_ptr, code);
      550    end FINISH;
      551 
      552 DISPLAY_ELEMENT_BY_STRUCTURE:
      553    proc (p_structure_ptr, p_structure_name, p_code);
      554       dcl	    cu_$arg_list_ptr       entry (ptr);
      555       dcl	    cu_$generate_call      entry (entry, ptr);
      556       dcl	    hcs_$make_entry	       entry (ptr, char (*), char (*), entry, fixed bin (35));
      557       dcl	    p_structure_ptr	       ptr parameter;
      558       dcl	    p_structure_name       char (*) parameter;
      559       dcl	    p_code	       fixed bin (35);
      560       dcl	    arg_list_ptr	       ptr;
      561       dcl	    structure_entry	       entry variable;
      562       dcl	    procedure_name	       char (32);
      563 
      564       procedure_name = "display_" || rtrim (p_structure_name) || "_";
      565 
      566       call hcs_$make_entry (null, procedure_name, procedure_name, structure_entry, p_code);
      567       if p_code ^= 0
      568       then return;
      569 
      570       call MAKE_STRUCTURE_CALL (p_structure_ptr, temp_string);
      571 
      572       call print_data_ (temp_string, print_data_info_ptr, p_code);
      573 
      574       return;
      575 
      576 MAKE_STRUCTURE_CALL:
      577    proc () options (variable);
      578 
      579       call cu_$arg_list_ptr (arg_list_ptr);
      580       call cu_$generate_call (structure_entry, arg_list_ptr);
      581    end MAKE_STRUCTURE_CALL;
      582    end DISPLAY_ELEMENT_BY_STRUCTURE;
      583 
      584 /* BEGIN INCLUDE FILE control_argument_dcls.incl.pl1 */
      585 
      586 /* This file contains all of the commonly used declarations for commands 
      587*concerning control argument processing.
      588*
      589*Written  by  Lindsey Spratt, 08/28/79
      590**/
      591       dcl	    cu_$arg_count	       entry returns (fixed bin);
      592       dcl	    cu_$arg_ptr	       entry (fixed bin, ptr, fixed bin, fixed bin (35));
      593       dcl	    cu_$af_return_arg      entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      594       dcl	    com_err_	       entry options (variable);
      595       dcl	    active_fnc_err_	       entry () options (variable);
      596       dcl	    complain	       entry () variable options (variable);
      597       dcl	    return_arg	       char (return_arg_len) based (return_arg_ptr) varying;
      598       dcl	    return_arg_len	       fixed bin (21);
      599       dcl	    return_arg_ptr	       ptr;
      600       dcl	    arg		       based (arg_ptr) char (arg_len);
      601       dcl	    arg_ptr	       ptr;
      602       dcl	    arg_len	       fixed bin;
      603       dcl	    arg_idx	       fixed bin;
      604       dcl	    nargs		       fixed bin;
      605 
      606       dcl	    control_argument_idx   fixed bin;
      607       dcl	    accept_control_argument
      608 			       bit (1);
      609       dcl	    is_active_function     bit (1);
      610       dcl	    code		       fixed bin (35);
      611 
      612       dcl	    error_table_$noarg     fixed bin (35) ext;
      613       dcl	    error_table_$badopt    fixed bin (35) ext;
      614       dcl	    error_table_$bad_arg   fixed bin (35) ext;
      615       dcl	    error_table_$not_act_fnc
      616 			       fixed bin (35) ext;	/*dcl error_table_$active_function fixed bin(35) ext; */
      617 
      618 /* END INCLUDE FILE control_argument_dcls.incl.pl1 */
      619 
      620 
  1     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*   Contains element identifiers of some elements in the Header Collection.
  1     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  1     7*   which the collection_header for the Header Collection is stored (see
  1     8*   dm_cm_collection_header.incl.pl1).
  1     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  1    10*   caller's file header is stored.
  1    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  1    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  1    13**/
  1    14 
  1    15 /* HISTORY:
  1    16*Written by Matthew Pierret, 09/24/84.
  1    17*Modified:
  1    18**/
  1    19 
  1    20 /* format: style2,ind3,ll79 */
  1    21      dcl	   (
  1    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  1    23 			      init ("000000000001"b3),
  1    24 	   CM_FILE_HEADER_ELEMENT_ID
  1    25 			      init ("000000000002"b3),
  1    26 	   CALLER_HEADER_ELEMENT_ID
  1    27 			      init ("000000000003"b3)
  1    28 	   )		      bit (36) aligned int static
  1    29 			      options (constant);
  1    30 
  1    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      621 
      622 
  2     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        Contains the identifier of the Header Collection for a file
  2     6*   managed by the collection_manager_.  This is used by callers of 
  2     7*   collection_manager who wish to maintain their own file header or who wish
  2     8*   to maintain their own collection header information beyond the caller
  2     9*   collection header provided by colleciton_manager_$(get put)_header.
  2    10**/
  2    11 
  2    12 /* HISTORY:
  2    13*Written by Matthew Pierret, 09/24/84.
  2    14*Modified:
  2    15**/
  2    16 
  2    17 /* format: style2,ind3,ll79 */
  2    18 
  2    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  2    20 			      aligned internal static options (constant);
  2    21 
  2    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      623 
      624 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The cm_info structure is used to hold per-process opening information
  3     5*   about a collection.  It is generally allocated in the process' DM free
  3     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  3     7*   is used to provide access the cm_info structure, keeping it in a hash
  3     8*   table keyed on file opening id and collection id combined.
  3     9*        Currently cm_info is never freed until the process terminates.  Each
  3    10*   time a new transaction is started, detected when the current transaction
  3    11*   id of a process differs from cm_info.current_transaction_id, the information
  3    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  3    13*   demand, as most modules do not need the information in the storage record.
  3    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  3    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  3    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  3    17*   requested, it is placed at the location pointed to by
  3    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 10/27/82. 
  3    23*Modified:
  3    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  3    25*            storage_record_buffer_ptr. This points to the storage_record.
  3    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  3    27*            but storage_record_buffer_ptr continues to point at where the
  3    28*            storage_record was. When the storge_record is again requested,
  3    29*            it is put back in the same place rather than allocating a new
  3    30*            storage_record.
  3    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  3    32*            init clause from the version component.
  3    33**/
  3    34 
  3    35 /* format: style2,ind3,ll79 */
  3    36 
  3    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  3    38 	     2 version	      char (8),
  3    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  3    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  3    41 	     2 collection_id      bit (36) aligned init ("0"b),
  3    42 	     2 header_ptr	      ptr init (null),
  3    43 	     2 storage_record_ptr ptr init (null),
  3    44 	     2 storage_record_buffer_ptr
  3    45 			      ptr init (null);
  3    46 
  3    47      dcl	   cm_info_ptr	      ptr init (null);
  3    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  3    49 			      internal static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      625 
      626 
  4     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*       Associated with each collection is the following collection_header
  4     5*   structure stored as an element in the Header Collection of the file.
  4     6*   The identifier of this element is also the idenfifier of the collection.
  4     7*   Even the Header Collection has a collection_header stored in the Header
  4     8*   Collection itself in the element identified by the constant
  4     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  4    10*   The information in collection_header is expected to be stable information.
  4    11*   The structure elements are described as follows:
  4    12*   
  4    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  4    14*   
  4    15*   flags.fixed_size_elements indicates, if on that all elements in the
  4    16*   collection are of a fixed length.
  4    17*   
  4    18*   flags.thread_elements indicates that elements in a collection are to be
  4    19*   threaded in a linked list.  This is currrently unupported.
  4    20*   
  4    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  4    22*   a collection are to be threaded in a linked list.  This is only useful if
  4    23*   the control interval storage method is blocked.
  4    24*   
  4    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  4    26*   
  4    27*   control_interval_storage_method is the method of storage management of
  4    28*   control intervals for this collection, either
  4    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  4    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  4    31*   dm_cism_info.incl.pl1.
  4    32*   
  4    33*   element_storage_method is the method of storage management of elements in
  4    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  4    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  4    36*   
  4    37*   maximum_element_size is the maximum size of an element in bits in this
  4    38*   collection.
  4    39*   
  4    40*   header_record_element_id is the identifier of an element containing a
  4    41*   caller-defined header for this collection.  If equal to "0"b, no
  4    42*   caller-defined header yet exists.  The put_header collection_manager_
  4    43*   operation stores such a header.
  4    44*   
  4    45*   storage_record_element_id is the identifier of the element containing the
  4    46*   storage_record for this collection.  The storage_record contains
  4    47*   information expected to be dynamic, such as the identifier of the last
  4    48*   control interval of the collection.  Its format is also dependent upon the
  4    49*   storage methods in effect for this collection.  storage_record structures
  4    50*   are declared in dm_cm_storage_record.incl.pl1.
  4    51*
  4    52**/
  4    53 
  4    54 /* HISTORY:
  4    55*Written by Matthew Pierret, 04/01/82.
  4    56*Modified:
  4    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  4    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  4    59*            storage_record_area out, leaving storage_record_element_id behind.
  4    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  4    61**/
  4    62 
  4    63 /* format: style2,ind3,ll79 */
  4    64 
  4    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  4    66 	     2 version	      char (8),
  4    67 	     2 flags	      unaligned,
  4    68 	       3 fixed_size_elements
  4    69 			      bit (1),
  4    70 	       3 thread_elements  bit (1),
  4    71 	       3 thread_control_intervals
  4    72 			      bit (1),
  4    73 	       3 must_be_zero1    bit (15),
  4    74 	     2 control_interval_storage_method
  4    75 			      fixed bin (17) unal,
  4    76 	     2 element_storage_method
  4    77 			      fixed bin (17),
  4    78 	     2 maximum_element_size
  4    79 			      fixed bin (35),
  4    80 	     2 header_record_element_id
  4    81 			      bit (36) aligned,
  4    82 	     2 storage_record_element_id
  4    83 			      bit (36) aligned;
  4    84 
  4    85      dcl	   collection_header_ptr  ptr;
  4    86      dcl	   COLLECTION_HEADER_VERSION_2
  4    87 			      init ("col_hdr2") char (8) aligned
  4    88 			      int static options (constant);
  4    89 
  4    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      627 
      628 
  5     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        A storage record is an extension to the collection_header structure.
  5     6*   It is expected to be more volatile than collection_header and has a 
  5     7*   different format depending on the control interval storage method in use
  5     8*   for the collection.  A storage record is stored as an element in the 
  5     9*   file's Header Collection with the element identifier 
  5    10*   collection_header.storage_record_element_id.
  5    11*   
  5    12*        The unblocked_storage_record contains the control interval numbers
  5    13*   of the first and last control intervals of a collection.  Unblocked
  5    14*   control intervals are chained together, so all control intervals can be 
  5    15*   found by starting at one end and following the chain forward or backward.
  5    16*   
  5    17*        The blocked_storage_record is not yet used, as the Blocked Control
  5    18*   Interval Storage Method is not yet implemented.
  5    19**/
  5    20 
  5    21 /* HISTORY:
  5    22*Written by Matthew Pierret, 09/24/84.
  5    23*Modified:
  5    24**/
  5    25 
  5    26 /* format: style2,ind3,ll79 */
  5    27 
  5    28      dcl	   1 unblocked_storage_record
  5    29 			      aligned
  5    30 			      based (unblocked_storage_record_ptr),
  5    31 	     2 first_control_interval
  5    32 			      fixed bin (24) uns,
  5    33 	     2 last_control_interval
  5    34 			      fixed bin (24) uns;
  5    35 
  5    36      dcl	   1 blocked_storage_record
  5    37 			      aligned based (blocked_storage_record_ptr),
  5    38 	     2 last_control_interval
  5    39 			      fixed bin (24) uns,
  5    40 	     2 number_of_blocks   fixed bin (17) unal,
  5    41 	     2 number_of_control_intervals_per_block
  5    42 			      fixed bin (17) unal,
  5    43 	     2 allocation_map_element_id
  5    44 			      bit (36) aligned;
  5    45 
  5    46      dcl	   unblocked_storage_record_ptr
  5    47 			      ptr init (null ());
  5    48      dcl	   blocked_storage_record_ptr
  5    49 			      ptr init (null ());
  5    50 
  5    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      629 
      630 
  6     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        Contains the declaration of an element identifier.  Element
  6     6*   identifiers consist of two parts, the id (number) of the control interval
  6     7*   in which the element resides, and the index into the slot table of
  6     8*   the element in the control interval.  The declaration of the element_id 
  6     9*   structure reflects this division of the element identifier.  The structure 
  6    10*   is based on the automatic bit string element_id_string because programs
  6    11*   generally pass bit strings (element_id_string) to each other, then 
  6    12*   interpret the bit string by overlaying the element_id structure ony if
  6    13*   it is necessary to access the parts of the id.  Basing element_id on
  6    14*   addr(element_id_string) instead of on a pointer removes the necessity
  6    15*   for always setting that pointer explicitly and guarantees that changes
  6    16*   made to the string or structure do not get inconsistent.
  6    17*
  6    18*   Changes made to element_id must also be made to datum_id, declared in 
  6    19*   dm_cm_datum.incl.pl1.
  6    20**/
  6    21 
  6    22 /* HISTORY:
  6    23*Written by Matthew Pierret, 04/01/82.
  6    24*Modified:
  6    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  6    26**/
  6    27 
  6    28 /* format: style2,ind3,ll79 */
  6    29 
  6    30      dcl	   element_id_string      bit (36) aligned;
  6    31 
  6    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  6    33 	     2 control_interval_id
  6    34 			      fixed bin (24) unal unsigned,
  6    35 	     2 index	      fixed bin (12) unal unsigned;
  6    36 
  6    37 
  6    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      631 
      632 
  7     1 /* BEGIN INCLUDE FILE -- print_data_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*          This structure is used by print_data to set various parameters
  7     5*     controlling the format of the output it produces.
  7     6*
  7     7*/* HISTORY:
  7     8*
  7     9*Written by Lindsey L. Spratt, 06/05/79.
  7    10*Modified:
  7    11*02/08/85 by Lindsey L. Spratt:  Fixed the HISTORY and DESCRIPTION sections.
  7    12**/
  7    13 
  7    14 /* format: style3,idind30,indcomtxt */
  7    15 dcl	print_data_info_version_1	fixed bin options (constant) init (1) internal static;
  7    16 
  7    17 dcl	print_data_info_ptr		ptr;
  7    18 dcl	1 print_data_info		based (print_data_info_ptr),
  7    19 	  2 version		fixed bin,
  7    20 	  2 indentation		fixed bin,	/* This sets the number of spaces by which structure level names are indented. */
  7    21 	  2 value_column		fixed bin,	/* This is the column in which the printing of values begins. */
  7    22 	  2 output_switch		ptr,		/* If null, user_output is used. */
  7    23 	  2 flags,
  7    24 	    3 octal		bit (1) unal,	/* Convert bit strings to octal. */
  7    25 	    3 hex			bit (1) unal,	/* hex, ditto */
  7    26 	    3 pad			bit (34) unaligned,
  7    27 	  2 intervals		char (256) varying;
  7    28 
  7    29 /* End include file print_data_info.incl.pl1 */
      633 
      634 
  8     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*        This include file contains the cm_file_header and collection_id_table 
  8     6*   structure.  These structures are stored as elements in the Header Collection
  8     7*   of a file and contain per-file, as opposed to per-collection, information.
  8     8*   
  8     9*        The cm_file_header structure is always stored in the element whose
  8    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  8    11*   dm_cm_hdr_col_ids.incl.pl1.  
  8    12*   
  8    13*        The collection_id_table is an array of identifiers of each collection 
  8    14*   in the file, excepting the Header Collection.  The identifier of a 
  8    15*   collection is the same as the identifier of the element which holds that
  8    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  8    17*   The identifier of the element in which the collection_id_table is
  8    18*   stored is cm_file_header.collection_id_table_element_id.
  8    19*   
  8    20*      A file also has a reservation map for determining which controls 
  8    21*   intervals have been reserved by a collection.  It is divided into
  8    22*   several blocks, or fragments.  The file_reservation_map is actually an
  8    23*   array of element identifiers of the fragments of the map.  The 
  8    24*   file_reservation_map is stored in the element whose identifier is 
  8    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  8    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  8    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  8    28*   bits long, representing equally as many control intervals.  The
  8    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  8    30*   cm_file_header.highest_numbered_ci is the number of the control
  8    31*   interval in the file with the highest control interval number.  It is not 
  8    32*   yet used or maintained.
  8    33*
  8    34**/
  8    35 
  8    36 /* HISTORY:
  8    37*Written by Matthew Pierret, 03/23/82.
  8    38*Modified:
  8    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  8    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  8    41*            ids referring to collection_header's. Reduced buffer length to 120,
  8    42*            enough bytes to hold the collmgr_header with 25 collection header
  8    43*            element ids.
  8    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  8    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  8    46*            made fixed length, split off array of collection_ids (also known as
  8    47*            element_ids of collection_headers).
  8    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  8    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  8    50*            dm_cm_hdr_col_ids.incl.pl1.  
  8    51**/
  8    52 
  8    53 /* format: style2,ind3,ll79 */
  8    54 
  8    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  8    56 	     2 version	      char (8),
  8    57 	     2 highest_numbered_ci
  8    58 			      fixed bin (24) uns,
  8    59 	     2 number_of_collections
  8    60 			      fixed bin (17) unal,
  8    61 	     2 number_of_blocks   fixed bin (17) unal,
  8    62 	     2 number_of_control_intervals_per_block
  8    63 			      fixed bin (17),
  8    64 	     2 allocation_map_element_id
  8    65 			      bit (36) aligned,
  8    66 	     2 collection_id_table_element_id
  8    67 			      bit (36) aligned;
  8    68 
  8    69      dcl	   cm_file_header_ptr     ptr;
  8    70      dcl	   CM_FILE_HEADER_VERSION_1
  8    71 			      char (8) aligned init ("cm_fhdr1")
  8    72 			      int static options (constant);
  8    73 
  8    74 
  8    75      dcl	   collection_id_table    (cit_number_of_collections)
  8    76 			      bit (36) aligned
  8    77 			      based (collection_id_table_ptr);
  8    78 
  8    79      dcl	   collection_id_table_ptr
  8    80 			      ptr;
  8    81      dcl	   cit_number_of_collections
  8    82 			      fixed bin (17);
  8    83 
  8    84 
  8    85 
  8    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  8    87 
      635 
      636    end collmgr_display;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/05/85  0835.6  collmgr_display.pl1               >spec>on>7138.pbf>collmgr_display.pl1
621          1    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
623          2    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
625          3    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
627          4    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
629          5    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
631          6    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
633          7    03/05/85  0800.2  print_data_info.incl.pl1          >spec>on>7138.pbf>print_data_info.incl.pl1
635          8    01/07/85  0858.3  dm_cm_file_header.incl.pl1        >ldd>include>dm_cm_file_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CM_FILE_HEADER_ELEMENT_ID       000761 constant        bit(36)                  initial dcl 1-21 set ref 370*
DISPLAY_KEYWORD                 000523 constant        varying char(32)         initial array dcl 98 set ref 209 209 209 212 215
                                                                                  215*
HEADER_COLLECTION_ID            000774 constant        bit(36)                  initial dcl 2-19 set ref 360* 364* 393* 442* 515
accept_control_argument         000366 automatic       bit(1)                   unaligned dcl 607 set ref 161* 188* 195* 202* 223*
                                                                                  238* 244* 250* 257* 261 289* 293* 298* 314* 321
active_fnc_err_                 000046 constant        entry                    external dcl 595 ref 151
addr                                                   builtin function         dcl 91 ref 370 370 391 532 532
arg                                    based           char                     unaligned dcl 600 set ref 167 174* 178* 183* 190 197
                                                                                  204 204 208 215* 221 236 241 247 253 275 281*
arg_idx                         000363 automatic       fixed bin(17,0)          dcl 603 set ref 164* 166*
arg_len                         000362 automatic       fixed bin(17,0)          dcl 602 set ref 166* 167 174 174 178 178 183 183 190
                                                                                  197 204 204 208 215 215 221 236 241 247 253 275
                                                                                  281 281
arg_list_ptr                    000100 automatic       pointer                  dcl 560 set ref 579* 580*
arg_ptr                         000360 automatic       pointer                  dcl 601 set ref 166* 167 174 178 183 190 197 204 204
                                                                                  208 215 221 236 241 247 253 275 281
argument_type                   000261 constant        varying char(64)         initial array dcl 104 set ref 266 266* 326 326*
automatic_cm_file_header        000304 automatic       structure                level 1 unaligned dcl 50 set ref 370 370 370 370
bin                                                    builtin function         dcl 91 ref 190 197 236 241 247
blocked_storage_record_ptr      000400 automatic       pointer                  initial dcl 5-48 set ref 5-48*
char                                                   builtin function         dcl 91 ref 167 204
character_element                      based           char                     unaligned dcl 87 set ref 534*
cit_number_of_collections       000412 automatic       fixed bin(17,0)          dcl 8-81 set ref 402* 428 459 8-75
cm_file_header                         based           structure                level 1 dcl 8-55 set ref 414
cm_file_header_ptr              000406 automatic       pointer                  dcl 8-69 set ref 370* 382 393 402 414 8-55 8-55 8-55
                                                                                  8-55 8-55 8-55 8-55 8-55
cm_get_element                  000020 constant        entry                    external dcl 118 ref 370 393 516
cm_info                                based           structure                level 1 dcl 3-37 set ref 446 482
cm_info_ptr                     000372 automatic       pointer                  initial dcl 3-47 set ref 360* 370 370 393 446 452
                                                                                  469* 482 497 3-37 3-37 3-37 3-37 3-37 3-37 3-37
                                                                                  3-37 3-47*
cm_opening_info$get             000016 constant        entry                    external dcl 117 ref 360 469
code                            000370 automatic       fixed bin(35,0)          dcl 610 set ref 140* 141 143 147* 166* 178* 180 183*
                                                                                  333* 334 337* 350* 351 351 354* 360* 361 364* 370*
                                                                                  373 376* 393* 395 398* 415* 416 419* 429* 430 433*
                                                                                  447* 453* 469* 470 473* 483* 484 487* 498* 499
                                                                                  502* 516* 518 521* 532* 548*
collection_header                      based           structure                level 1 dcl 4-65 ref 452 497
collection_header_ptr           000374 automatic       pointer                  dcl 4-85 ref 4-65 4-65 4-65 4-65 4-65 4-65 4-65 4-65
                                                                                  4-65 4-65 4-65 4-65
collection_id             4            based           bit(36)                  initial level 2 dcl 3-37 set ref 370*
collection_id_table                    based           bit(36)                  array dcl 8-75 set ref 428 467* 469* 473* 487* 513
collection_id_table_element_id
                          6            based           bit(36)                  level 2 dcl 8-55 set ref 393*
collection_id_table_length_in_bits
                                000313 automatic       fixed bin(35,0)          dcl 52 set ref 393*
collection_id_table_ptr         000410 automatic       pointer                  dcl 8-79 set ref 393* 428 467 469 473 487 513 8-75
collection_idx                  000300 automatic       fixed bin(17,0)          dcl 46 in procedure "cmds" set ref 462* 467* 467 469
                                                                                  473 487* 487*
collection_idx           13            based           fixed bin(17,0)          initial level 2 in structure "element_spec" dcl 79
                                                                                  in procedure "cmds" set ref 229* 236* 513 513 521*
                                                                                  528*
com_err_                        000044 constant        entry                    external dcl 594 ref 147 153
complain                        000350 automatic       entry variable           dcl 596 set ref 151* 153* 158 174 183 215 266 281
                                                                                  326 337 345 354 364 376 385 398 419 433 473 487
                                                                                  502 521
control_argument                000030 constant        varying char(64)         initial array dcl 108 set ref 266* 275 275 278 326*
control_argument_idx            000365 automatic       fixed bin(17,0)          dcl 606 set ref 162* 171 187* 194* 201* 237* 243*
                                                                                  249* 255* 261 264 264 264* 266 266 266 275* 275*
                                                                                  278 285 321 324 324 324* 326 326 326
control_interval_id      15            based           fixed bin(24,0)          level 3 packed unsigned unaligned dcl 79 set ref
                                                                                  241* 521* 528*
cu_$af_return_arg               000042 constant        entry                    external dcl 593 ref 140
cu_$arg_list_ptr                000060 constant        entry                    external dcl 554 ref 579
cu_$arg_ptr                     000040 constant        entry                    external dcl 592 ref 166
cu_$generate_call               000062 constant        entry                    external dcl 555 ref 580
current_collection_id           000163 automatic       bit(36)                  initial dcl 40 set ref 40* 513* 515* 516* 521* 528*
display_collection_id_table            defined         bit(1)                   dcl 64 set ref 306* 425
display_element                        defined         bit(1)                   dcl 66 set ref 306* 310* 462
display_element_in_characters          defined         bit(1)                   dcl 67 set ref 306* 534
display_file_header                    defined         bit(1)                   dcl 63 set ref 135* 303* 411
display_flag                    000330 automatic       bit(1)                   array dcl 59 set ref 134* 135* 135 135* 135 135* 135
                                                                                  221* 303* 303 303* 303 303* 303 306* 306 306* 306
                                                                                  306* 306 310* 310 411 411 425 425 439 439 443 443
                                                                                  449 449 462 462 479 479 494 494 534 534
display_header                         defined         bit(1)                   dcl 62 set ref 135* 303* 449 494
display_header_collection              defined         bit(1)                   dcl 69 ref 439
display_idx                     000301 automatic       fixed bin(17,0)          initial dcl 47 set ref 47* 209* 209 209* 212 221
display_info                           defined         bit(1)                   dcl 61 set ref 135* 303* 443 479
divide                                                 builtin function         dcl 91 ref 534 534
dm_error_$file_already_open     000036 external static fixed bin(35,0)          dcl 129 ref 351
element                                based           bit                      unaligned dcl 86 set ref 532 532 536* 538
element_id                             based           structure                level 1 dcl 6-32
element_length                  000316 automatic       fixed bin(35,0)          initial dcl 55 set ref 55* 516* 532 532 534 534 536
                                                                                  536 538 538
element_ptr                     000314 automatic       pointer                  initial dcl 54 set ref 54* 516* 532 532 534 536 538
element_spec                           based           structure                level 1 unaligned dcl 79 set ref 229
element_spec_ptr                000322 automatic       pointer                  initial dcl 56 set ref 56* 226 229* 230 232 233 234
                                                                                  235 236 241 247 253 512* 512* 513 513 516 516 516
                                                                                  521 521 521 528 528 528 532 532* 540
error_table_$badopt             000052 external static fixed bin(35,0)          dcl 613 set ref 174* 215* 281*
error_table_$noarg              000050 external static fixed bin(35,0)          dcl 612 set ref 158* 266* 326* 345*
error_table_$not_act_fnc        000056 external static fixed bin(35,0)          dcl 615 ref 143
expand_pathname_                000022 constant        entry                    external dcl 120 ref 178
file_dir                        000100 automatic       char(168)                initial unaligned dcl 38 set ref 38* 178* 342 350*
                                                                                  354* 354 364* 364 385* 385 473* 473
file_entry                      000152 automatic       char(32)                 initial unaligned dcl 39 set ref 39* 178* 350* 354*
                                                                                  364* 385* 473*
file_manager_$open              000014 constant        entry                    external dcl 116 ref 350
file_oid                  3            based           bit(36)                  initial level 2 dcl 3-37 set ref 370* 393*
file_opening_id                 000162 automatic       bit(36)                  initial dcl 40 set ref 40* 350* 360* 469* 516*
first_collection_idx            000302 automatic       fixed bin(17,0)          initial dcl 48 set ref 48* 190* 457 457* 459 462 462
flags                     6            based           structure                level 2 packed unaligned dcl 7-18
get_system_free_area_           000024 constant        entry                    external dcl 121 ref 136
get_temp_segment_               000026 constant        entry                    external dcl 122 ref 333
hbound                                                 builtin function         dcl 91 ref 209 212 215 275 278
hcs_$make_entry                 000064 constant        entry                    external dcl 556 ref 566
header_ptr                6            based           pointer                  initial level 2 dcl 3-37 ref 452 497
id                       15            based           structure                level 2 packed unaligned dcl 79 set ref 235* 516 516
indentation               1            based           fixed bin(17,0)          level 2 dcl 7-18 set ref 405*
index                                                  builtin function         dcl 91 in procedure "cmds" ref 266 326
index                    15(24)        based           fixed bin(12,0)          level 3 in structure "element_spec" packed unsigned
                                                                                  unaligned dcl 79 in procedure "cmds" set ref 247*
                                                                                  521* 528*
intervals                 7            based           varying char(256)        level 2 dcl 7-18 set ref 409*
ioa_                            000012 constant        entry                    external dcl 114 ref 442 467 528 534 536
is_active_function              000367 automatic       bit(1)                   unaligned dcl 609 set ref 141* 143* 151
length                                                 builtin function         dcl 91 ref 370 370
local_print_data_info           000166 automatic       structure                level 1 unaligned dcl 43 set ref 391
myname                          000512 constant        varying char(32)         initial dcl 103 set ref 147* 158* 158* 174* 183*
                                                                                  215* 266* 281* 326* 333 337* 345* 354* 364* 376*
                                                                                  385* 398* 419* 433* 473* 487* 502* 521* 548
nargs                           000364 automatic       fixed bin(17,0)          dcl 604 set ref 140* 155 164
next                                   based           pointer                  initial level 2 dcl 79 set ref 229* 232* 233* 540
next_ptr                        000326 automatic       pointer                  initial dcl 56 set ref 56*
null                                                   builtin function         dcl 91 ref 42 45 54 56 56 56 56 229 230 233 370 370
                                                                                  393 393 407 512 516 516 3-47 5-46 5-48 548 566 566
number_of_collections           000303 automatic       fixed bin(17,0)          initial dcl 49 in procedure "cmds" set ref 49* 197*
                                                                                  459 459* 462
number_of_collections
                          3            based           fixed bin(17,0)          level 2 in structure "cm_file_header" packed
                                                                                  unaligned dcl 8-55 in procedure "cmds" ref 382 402
octal                     6            based           bit(1)                   level 3 packed unaligned dcl 7-18 set ref 408*
old_spec_ptr                    000324 automatic       pointer                  initial dcl 56 set ref 56* 226* 232
output_switch             4            based           pointer                  level 2 dcl 7-18 set ref 407*
p_code                                 parameter       fixed bin(35,0)          dcl 559 set ref 552 566* 567 572*
p_structure_name                       parameter       char                     unaligned dcl 558 ref 552 564
p_structure_ptr                        parameter       pointer                  dcl 557 set ref 552 570*
position                 14            based           fixed bin(17,0)          level 2 dcl 79 set ref 234* 516*
print_data_                     000032 constant        entry                    external dcl 124 ref 415 429 447 453 483 498 572
print_data_info                        based           structure                level 1 unaligned dcl 7-18
print_data_info_ptr             000404 automatic       pointer                  dcl 7-17 set ref 391* 404 405 406 407 408 409 415*
                                                                                  429* 447* 453* 483* 498* 572*
print_data_info_version_1       000774 constant        fixed bin(17,0)          initial dcl 7-15 ref 404
procedure_name                  000106 automatic       char(32)                 unaligned dcl 562 set ref 564* 566* 566*
release_temp_segment_           000030 constant        entry                    external dcl 123 ref 548
return_arg_len                  000354 automatic       fixed bin(21,0)          dcl 598 set ref 140*
return_arg_ptr                  000356 automatic       pointer                  dcl 599 set ref 140*
root_element_spec_ptr           000320 automatic       pointer                  initial dcl 56 set ref 56* 230 230* 512
rtrim                                                  builtin function         dcl 91 ref 564
structure_entry                 000102 automatic       entry variable           dcl 561 set ref 566* 580*
structure_name            2            based           varying char(32)         initial level 2 dcl 79 set ref 229* 253* 532 532
substr                                                 builtin function         dcl 91 ref 204 266 326
sys_info$max_seg_size           000034 external static fixed bin(35,0)          dcl 128 ref 414 415 428 429 446 447 452 453 482 483
                                                                                  497 498 570 572
temp_string                            based           varying char             dcl 77 set ref 414* 415* 428* 429* 446* 447* 452*
                                                                                  453* 482* 483* 497* 498* 570* 572*
temp_string_ptr                 000276 automatic       pointer                  initial dcl 45 set ref 45* 333* 414 415 428 429 446
                                                                                  447 452 453 482 483 497 498 548 548* 570 572
true_arg                        000337 automatic       varying char(32)         initial dcl 72 set ref 72* 204* 208* 209 209 221
unblocked_storage_record_ptr    000376 automatic       pointer                  initial dcl 5-46 set ref 5-46*
unspec                                                 builtin function         dcl 91 set ref 235* 370 370 516 516
value_column              2            based           fixed bin(17,0)          level 2 dcl 7-18 set ref 406*
version                                based           fixed bin(17,0)          level 2 dcl 7-18 set ref 404*
work_area                              based           area                     dcl 76 ref 229 538
work_area_ptr                   000164 automatic       pointer                  initial dcl 42 set ref 42* 136* 229 393* 516* 538

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_BYTE                          constant        fixed bin(35,0)          initial dcl 96
CALLER_HEADER_ELEMENT_ID               constant        bit(36)                  initial dcl 1-21
CM_FILE_HEADER_VERSION_1               constant        char(8)                  initial dcl 8-70
CM_INFO_VERSION_2                      constant        char(8)                  initial dcl 3-48
COLLECTION_HEADER_VERSION_2            constant        char(8)                  initial dcl 4-86
HEADER_COLLECTION_HEADER_ELEMENT_ID    constant        bit(36)                  initial dcl 1-21
blocked_storage_record                 based           structure                level 1 dcl 5-36
cu_$arg_count                   000000 constant        entry                    external dcl 591
element_id_string               000402 automatic       bit(36)                  dcl 6-30
error_table_$bad_arg            000054 external static fixed bin(35,0)          dcl 614
ioa_$nnl                        000000 constant        entry                    external dcl 115
return_arg                             based           varying char             dcl 597
unblocked_storage_record               based           structure                level 1 dcl 5-28

NAMES DECLARED BY EXPLICIT CONTEXT.
ARG                             000000 constant        label                    array(-4:9) dcl 174 ref 171
ARG_PROCESSING_LOOP             001633 constant        label                    dcl 164
COLLECTION_LOOP                 004215 constant        label                    dcl 462
CONTROL_ARG                     000016 constant        label                    array(0:9) dcl 287 ref 285
DISPLAY_ELEMENT_BY_STRUCTURE    005320 constant        entry                    internal dcl 552 ref 532
ELEMENT_DISPLAY                 004737 constant        label                    dcl 509
FINISH                          005260 constant        entry                    internal dcl 546 ref 218 338 346 356 366 377 387 399
                                                                                  420 434 475 490 503 524 543
MAKE_STRUCTURE_CALL             005505 constant        entry                    internal dcl 576 ref 570
NEXT_1                          002341 constant        label                    dcl 259 ref 189 196 203 224 239 245 251 258
NEXT_ARG                        002534 constant        label                    dcl 317 ref 291 296 301 308 315
PROCESS_ARG                     001671 constant        label                    dcl 167
PROCESS_CONTROL_ARG             002431 constant        label                    dcl 272
cmds                            001454 constant        entry                    external dcl 7
collmgr_display                 001464 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6066        6154    5543        6076
Length      7534    5543        66        1343     323           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cmds                                652 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure cmds.  
DISPLAY_ELEMENT_BY_STRUCTURE        106 internal procedure  is called during a stack extension.  
MAKE_STRUCTURE_CALL                  74 internal procedure  is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
DISPLAY_ELEMENT_BY_STRUCTURE
                         000100 arg_list_ptr                DISPLAY_ELEMENT_BY_STRUCTURE
                         000102 structure_entry             DISPLAY_ELEMENT_BY_STRUCTURE
                         000106 procedure_name              DISPLAY_ELEMENT_BY_STRUCTURE
cmds                     000100 file_dir                    cmds
                         000152 file_entry                  cmds
                         000162 file_opening_id             cmds
                         000163 current_collection_id       cmds
                         000164 work_area_ptr               cmds
                         000166 local_print_data_info       cmds
                         000276 temp_string_ptr             cmds
                         000300 collection_idx              cmds
                         000301 display_idx                 cmds
                         000302 first_collection_idx        cmds
                         000303 number_of_collections       cmds
                         000304 automatic_cm_file_header    cmds
                         000313 collection_id_table_length_in_bits
                                                            cmds
                         000314 element_ptr                 cmds
                         000316 element_length              cmds
                         000320 root_element_spec_ptr       cmds
                         000322 element_spec_ptr            cmds
                         000324 old_spec_ptr                cmds
                         000326 next_ptr                    cmds
                         000330 display_flag                cmds
                         000337 true_arg                    cmds
                         000350 complain                    cmds
                         000354 return_arg_len              cmds
                         000356 return_arg_ptr              cmds
                         000360 arg_ptr                     cmds
                         000362 arg_len                     cmds
                         000363 arg_idx                     cmds
                         000364 nargs                       cmds
                         000365 control_argument_idx        cmds
                         000366 accept_control_argument     cmds
                         000367 is_active_function          cmds
                         000370 code                        cmds
                         000372 cm_info_ptr                 cmds
                         000374 collection_header_ptr       cmds
                         000376 unblocked_storage_record_ptr
                                                            cmds
                         000400 blocked_storage_record_ptr  cmds
                         000402 element_id_string           cmds
                         000404 print_data_info_ptr         cmds
                         000406 cm_file_header_ptr          cmds
                         000410 collection_id_table_ptr     cmds
                         000412 cit_number_of_collections   cmds

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_cs            cat_realloc_cs      call_var_desc
call_ext_out_desc   call_ext_out        call_int_this_desc  return              shorten_stack       ext_entry
int_entry           int_entry_desc      put_end             stream_io           put_data_eis        any_to_any_tr
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               cm_get_element                cm_opening_info$get           com_err_
cu_$af_return_arg             cu_$arg_list_ptr              cu_$arg_ptr                   cu_$generate_call
expand_pathname_              file_manager_$open            get_system_free_area_         get_temp_segment_
hcs_$make_entry               ioa_                          print_data_                   release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$file_already_open   error_table_$bad_arg          error_table_$badopt           error_table_$noarg
error_table_$not_act_fnc      sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 001421        39 001424        40 001427        42 001431        45 001433        47 001434        48 001435
     49 001436        54 001437        55 001440        56 001441        72 001445    3   47 001446    5   46 001447
 5   48 001450         7 001453       134 001472       135 001502       136 001506       140 001515       141 001532
    143 001537       147 001544       148 001560       151 001561       153 001571       155 001576       158 001600
    159 001626       161 001627       162 001631       164 001633       166 001643       167 001660       171 001671
    174 001673       176 001726       178 001727       180 001757       183 001761       184 002013       187 002014
    188 002016       189 002020       190 002021       194 002033       195 002035       196 002037       197 002040
    201 002052       202 002054       203 002056       204 002057       208 002073       209 002103       211 002130
    212 002132       215 002135       218 002202       219 002203       221 002204       223 002214       224 002216
    226 002217       229 002221       230 002232       232 002237       233 002240       234 002242       235 002243
    236 002244       237 002257       238 002261       239 002262       241 002263       243 002277       244 002301
    245 002302       247 002303       249 002316       250 002320       251 002322       253 002323       255 002334
    257 002336       258 002340       261 002341       264 002346       266 002354       270 002430       275 002431
    277 002450       278 002452       281 002455       282 002507       285 002510       287 002511       289 002512
    291 002513       293 002514       296 002515       298 002516       301 002517       303 002520       306 002524
    308 002527       310 002530       314 002532       315 002533       317 002534       320 002535       321 002537
    324 002544       326 002552       330 002627       333 002630       334 002660       337 002663       338 002706
    339 002707       342 002710       345 002714       346 002740       347 002741       350 002742       351 002767
    354 002774       356 003040       357 003041       360 003042       361 003057       364 003061       366 003131
    367 003132       370 003133       373 003201       376 003203       377 003226       378 003227       382 003230
    385 003234       387 003301       388 003302       391 003303       393 003305       395 003347       398 003351
    399 003374       400 003375       402 003376       404 003402       405 003404       406 003407       407 003411
    408 003413       409 003415       411 003416       414 003420       415 003503       416 003531       419 003533
    420 003556       421 003557       425 003560       428 003562       429 003617       430 003645       433 003647
    434 003672       435 003673       439 003674       442 003676       443 003716       446 003720       447 004001
    449 004027       452 004031       453 004153       457 004201       459 004205       462 004213       467 004225
    469 004260       470 004277       473 004301       475 004355       476 004356       479 004357       482 004361
    483 004442       484 004470       487 004472       490 004531       491 004532       494 004533       497 004535
    498 004657       499 004705       502 004707       503 004732       504 004733       508 004734       512 004737
    513 004746       515 004755       516 004757       518 005021       521 005023       524 005071       525 005072
    528 005073       532 005132       534 005173       536 005223       538 005245       540 005252       543 005256
    544 005257       546 005260       548 005261       550 005315       552 005317       564 005333       566 005374
    567 005425       570 005430       572 005453       574 005503       576 005504       579 005512       580 005521
    581 005533


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
