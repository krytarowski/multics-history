	COMPILATION LISTING OF SEGMENT state_man
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1153.31_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-02-27,Huen), approve(87-02-27,MCR7625), audit(87-02-27,RWaters),
       17*     install(87-05-21,MR12.1-1033):
       18*     Fix High priority
       19*     bug2106 ::  When a PL/1 stack frame is larger than 2 ** 14 words, bad code
       20*     is generated for the put_edit statement.
       21*  2) change(89-07-28,JRGray), approve(89-07-28,MCR8123), audit(89-09-12,Vu),
       22*     install(89-09-22,MR12.3-1073):
       23*     Added the state_man_$save_regs ep to save temp values (pl1 2091 2177).
       24*                                                   END HISTORY COMMENTS */
       25 /* Procedure to manage the machine state nodes
       26*
       27*   Initial Version: 27 April 1971 by BLW
       28*	Modified:  4 November 1972 by BLW 	
       29*	Modified:  15 February 1973 by RAB
       30*	Modified:	11 June 1973 by RAB for EIS
       31*	Modified:	29 May 1974 by RAB to save the string aq
       32*	Modified:	16 November 1974 by RAB to fix bug 1223
       33*	Modified:	18 November 1974 by RAB to fix 1258
       34*	Modified:	5 June 1975 by RAB for separate_static
       35*	Modified:	13 October 1975 by RAB to remember comparisons
       36*	Modified:	1 November 1975 by RAB to check save_temps bit
       37*	Modified:	24 November 1975 by RAB to check aggregate bit in save_temp
       38*	Modified:	8 January 1976 by RAB to fix bug 1452 in merge_ms
       39*	Modified:	29 April 1976 by RAB to fix bug 1494
       40*	Modified:	23 June 1976 by RAB to centralize use of cg_stat$last_call	
       41*	Modified:	25 March 1977 by RAB to fix 1599	
       42*	Modified: April 1977 by RHS to change allocation scheme of xeq_tree_area
       43*	Modified:	1 May 1977 by RAB to fix 1612
       44*	Modified:	1 September 1977 by RAB to add state_man$flush_sym in order to fix 1664
       45*	Modified 780717 by PG to count machine_state nodes allocated
       46*	Modified:	7 August 1978 by RAB to fix 1751 by allowing save_temp to save complex_flt_bin_1 temps
       47*          Modified: 30 January 1987 by SH&RW fixed bug 2106
       48**/
       49 
       50 state_man$create_ms: proc (pt);
       51 
       52 	dcl     pt		 ptr;		/* points at machine state node */
       53 
       54 	dcl     (p, q)		 ptr,
       55 	        sym		 ptr auto unal,
       56 	        (erase, b19)	 bit (19) aligned,
       57 	        (prev_state, found)	 bit (1) aligned,
       58 	        text_pos		 fixed bin (18),
       59 	        (i, j, n)		 fixed bin;
       60 
       61 	dcl     (cg_stat$ms_list, cg_stat$m_s_p) ptr ext,
       62 	        (cg_stat$text_pos, cg_stat$last_call) fixed bin (18) ext,
       63 	        pl1_stat_$node_uses	 (18) fixed bin external static;
       64 
       65 	dcl     c_a		 entry (fixed bin (18), fixed bin) returns (ptr),
       66 	        expmac		 entry (fixed bin (15), ptr),
       67 	        expmac$one		 entry (fixed bin (15), ptr, fixed bin (15)),
       68 	        expmac$one_eis	 entry (fixed bin (15), ptr),
       69 	        stack_temp$assign_block entry (ptr, fixed bin);
       70 
       71 	dcl     (abs, bin, bit, fixed, index, min, mod, null, string, substr) builtin;
       72 
  1     1 /* BEGIN INCLUDE FILE ... pl1_tree_areas.incl.pl1 */
  1     2 
  1     3 /* format: style3 */
  1     4 dcl	tree_area		area based (pl1_stat_$tree_area_ptr);
  1     5 dcl	xeq_tree_area	area based (pl1_stat_$xeq_tree_area_ptr);
  1     6 
  1     7 dcl	pl1_stat_$tree_area_ptr
  1     8 			ptr ext static,
  1     9 	pl1_stat_$xeq_tree_area_ptr
  1    10 			ptr ext static;
  1    11 
  1    12 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       73 
  2     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  2     2 
  2     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  2     4 
  2     5 dcl (	bits_per_char		init(9),
  2     6 	bits_per_half		init(18),
  2     7 	bits_per_word		init(36),
  2     8 	bits_per_two_words		init(72),
  2     9 	bits_per_four_words		init(144),
  2    10 	bits_per_words(2)		init(36,72),
  2    11 	packed_digits_per_char	init(2),
  2    12 	chars_per_word		init(4),
  2    13 	packed_digits_per_word	init(8),
  2    14 
  2    15 	break_even_bits		init(216),
  2    16 	break_even_words		init(6),
  2    17 
  2    18 	label_size		init(4),
  2    19 
  2    20 	convert_size(13:14)		init(9,1),
  2    21 	max_offset(13:14)		init(27,35),
  2    22 	max_short_size(13:14)	init(8,72),
  2    23 
  2    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  2    25 
  2    26 	max_dec_scale		init(32),
  2    27 	min_dec_scale		init(-31),
  2    28 	max_p_xreg		init(18),
  2    29 	max_p_fix_bin_1		init(35),
  2    30 	max_p_flt_bin_1		init(27),
  2    31 	max_p_fix_dec		init(59),
  2    32 	max_length_p		init(24),
  2    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  2    34 
  2    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  2    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  2    37 
  2    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  2    39 
  2    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  2    41 
       74 
  3     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  3     2 
  3     3 dcl	cg_static_$m_s_p ptr ext static,
  3     4 	m_s_p ptr init(cg_static_$m_s_p);
  3     5 
  3     6 dcl	1 machine_state	aligned based(m_s_p),
  3     7 	2 node_type	bit(9),
  3     8 	2 indicators	fixed bin,
  3     9 	2 next		ptr unal,
  3    10 	2 a_reg,
  3    11 	  3 variable(10)	ptr unal,
  3    12 	  3 number	fixed bin(17),
  3    13 	  3 size		fixed bin(8),
  3    14 	  3 length	fixed bin(8),
  3    15 	  3 offset	fixed bin(8),
  3    16 	  3 constant	fixed bin(24),
  3    17 	  3 changed	fixed bin(18),
  3    18 	  3 instruction	bit(36),
  3    19 	  3 locked	bit(1) aligned,
  3    20 	  3 number_h_o	fixed bin,
  3    21 	  3 has_offset(3)	ptr unal,
  3    22 	2 q_reg,
  3    23 	  3 variable(10)	ptr unal,
  3    24 	  3 number	fixed bin(17),
  3    25 	  3 size		fixed bin(8),
  3    26 	  3 length	fixed bin(8),
  3    27 	  3 offset	fixed bin(8),
  3    28 	  3 constant	fixed bin(24),
  3    29 	  3 changed	fixed bin(18),
  3    30 	  3 instruction	bit(36),
  3    31 	  3 locked	bit(1) aligned,
  3    32 	  3 number_h_o	fixed bin,
  3    33 	  3 has_offset(3)	ptr unal,
  3    34 	2 string_reg,
  3    35 	  3 variable	ptr unal,
  3    36 	  3 size		fixed bin(8),
  3    37 	  3 offset	fixed bin(8),
  3    38 	2 complex_reg,
  3    39 	  3 variable	ptr unal,
  3    40 	  3 size		fixed bin(8),
  3    41 	  3 scale		fixed bin(8),
  3    42 	2 decimal_reg,
  3    43 	  3 variable	ptr unal,
  3    44 	  3 size		fixed bin(8),
  3    45 	  3 scale		fixed bin(8),
  3    46 	2 index_regs(0:7),
  3    47 	  3 variable	ptr unal,
  3    48 	  3 constant	fixed bin,
  3    49 	  3 type		fixed bin(8),
  3    50 	  3 used		fixed bin(18),
  3    51 	  3 changed	fixed bin(18),
  3    52 	  3 instruction	bit(36),
  3    53 	  3 filler	fixed bin,
  3    54 	2 base_regs(0:7),
  3    55 	  3 variable	ptr unal,
  3    56 	  3 constant	fixed bin,
  3    57 	  3 type		fixed bin(8),
  3    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  3    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  3    60 	  3 used		fixed bin(18),
  3    61 	  3 changed	fixed bin(18),
  3    62 	  3 instruction	bit(36),
  3    63 	  3 locked	fixed bin(2),
  3    64 	2 indicators_ref(2:3) ptr unal;
  3    65 
  3    66 /* Permissible values for machine_state.indicators. */
  3    67 
  3    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  3    69 	ind_invalid	init (-1),
  3    70 	ind_string_aq	init (0),			/* logical value in storage */
  3    71 	ind_logical	init (1),			/* logical value in A or AQ */
  3    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  3    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  3    74 	ind_decimal_reg	init (14)
  3    75 	) fixed bin internal static options (constant);
  3    76 
  3    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       75 
  4     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  4     2 
  4     3 dcl	1 reference		based aligned,
  4     4 	2 node_type		bit(9) unaligned,
  4     5 	2 array_ref		bit(1) unaligned,
  4     6 	2 varying_ref		bit(1) unaligned,
  4     7 	2 shared			bit(1) unaligned,
  4     8 	2 put_data_sw		bit(1) unaligned,
  4     9 	2 processed		bit(1) unaligned,
  4    10 	2 units			fixed(3) unaligned,
  4    11 	2 ref_count		fixed(17) unaligned,
  4    12 	2 c_offset		fixed(24),
  4    13 	2 c_length		fixed(24),
  4    14 	2 symbol			ptr unaligned,
  4    15 	2 qualifier		ptr unaligned,
  4    16 	2 offset			ptr unaligned,
  4    17 	2 length			ptr unaligned,
  4    18 	2 subscript_list		ptr unaligned,
  4    19 						/* these fields are used by the 645 code generator */
  4    20 	2 address			structure unaligned,
  4    21 	  3 base			bit(3),
  4    22 	  3 offset		bit(15),
  4    23 	  3 op			bit(9),
  4    24 	  3 no_address		bit(1),
  4    25 	  3 inhibit		bit(1),
  4    26 	  3 ext_base		bit(1),
  4    27 	  3 tag			bit(6),
  4    28 	2 info			structure unaligned,
  4    29 	  3 address_in		structure,
  4    30 	    4 b			dimension(0:7) bit(1),
  4    31 	    4 storage		bit(1),
  4    32 	  3 value_in		structure,
  4    33 	    4 a			bit(1),
  4    34 	    4 q			bit(1),
  4    35 	    4 aq			bit(1),
  4    36 	    4 string_aq		bit(1),
  4    37 	    4 complex_aq		bit(1),
  4    38 	    4 decimal_aq		bit(1),
  4    39 	    4 b			dimension(0:7) bit(1),
  4    40 	    4 storage		bit(1),
  4    41 	    4 indicators		bit(1),
  4    42 	    4 x			dimension(0:7) bit(1),
  4    43 	  3 other			structure,
  4    44 	    4 big_offset		bit(1),
  4    45 	    4 big_length		bit(1),
  4    46 	    4 modword_in_offset	bit(1),
  4    47 	2 data_type		fixed(5) unaligned,
  4    48 	2 bits			structure unaligned,
  4    49 	  3 padded_ref		bit(1),
  4    50 	  3 aligned_ref		bit(1),
  4    51 	  3 long_ref		bit(1),
  4    52 	  3 forward_ref		bit(1),
  4    53 	  3 ic_ref		bit(1),
  4    54 	  3 temp_ref		bit(1),
  4    55 	  3 defined_ref		bit(1),
  4    56 	  3 evaluated		bit(1),
  4    57 	  3 allocate		bit(1),
  4    58 	  3 allocated		bit(1),
  4    59 	  3 aliasable		bit(1),
  4    60 	  3 even			bit(1),
  4    61 	  3 perm_address		bit(1),
  4    62 	  3 aggregate		bit(1),
  4    63 	  3 hit_zero		bit(1),
  4    64 	  3 dont_save		bit(1),
  4    65 	  3 fo_in_qual		bit(1),
  4    66 	  3 hard_to_load		bit(1),
  4    67 	2 relocation		bit(12) unaligned,
  4    68 	2 more_bits		structure unaligned,
  4    69 	  3 substr		bit(1),
  4    70 	  3 padded_for_store_ref	bit(1),
  4    71 	  3 aligned_for_store_ref	bit(1),
  4    72 	  3 mbz			bit(15),
  4    73 	2 store_ins		bit(18) unaligned;
  4    74 
  4    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       76 
  5     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  5     2 
  5     3 dcl	1 symbol			based aligned,
  5     4 	2 node_type		bit(9) unal,
  5     5 	2 source_id		structure unal,
  5     6 	  3 file_number		bit(8),
  5     7 	  3 line_number		bit(14),
  5     8 	  3 statement_number	bit(5),
  5     9 	2 location		fixed(18) unal unsigned,
  5    10 	2 allocated		bit(1) unal,
  5    11 	2 dcl_type		bit(3) unal,
  5    12 	2 reserved		bit(6) unal,
  5    13 	2 pix			unal,
  5    14 	  3 pic_fixed		bit(1) unal,
  5    15 	  3 pic_float		bit(1) unal,
  5    16 	  3 pic_char		bit(1) unal,
  5    17 	  3 pic_scale		fixed(7) unal,
  5    18 	  3 pic_size		fixed(7) unal,
  5    19 	2 level			fixed(8) unal,
  5    20 	2 boundary		fixed(3) unal,
  5    21 	2 size_units		fixed(3) unal,
  5    22 	2 scale			fixed(7) unal,
  5    23 	2 runtime			bit(18) unal,
  5    24 	2 runtime_offset		bit(18) unal,
  5    25 	2 block_node		ptr unal,
  5    26 	2 token			ptr unal,
  5    27 	2 next			ptr unal,
  5    28 	2 multi_use		ptr unal,
  5    29 	2 cross_references		ptr unal,
  5    30 	2 initial			ptr unal,
  5    31 	2 array			ptr unal,
  5    32 	2 descriptor		ptr unal,
  5    33 	2 equivalence		ptr unal,
  5    34 	2 reference		ptr unal,
  5    35 	2 general			ptr unal,
  5    36 	2 father			ptr unal,
  5    37 	2 brother			ptr unal,
  5    38 	2 son			ptr unal,
  5    39 	2 word_size		ptr unal,
  5    40 	2 bit_size		ptr unal,
  5    41 	2 dcl_size		ptr unal,
  5    42 	2 symtab_size		ptr unal,
  5    43 	2 c_word_size		fixed(24),
  5    44 	2 c_bit_size		fixed(24),
  5    45 	2 c_dcl_size		fixed(24),
  5    46 
  5    47 	2 attributes		structure aligned,
  5    48 	  3 data_type		structure unal,
  5    49 	    4 structure		bit(1) ,
  5    50 	    4 fixed		bit(1),
  5    51 	    4 float		bit(1),
  5    52 	    4 bit			bit(1),
  5    53 	    4 char		bit(1),
  5    54 	    4 ptr			bit(1),
  5    55 	    4 offset		bit(1),
  5    56 	    4 area		bit(1),
  5    57 	    4 label		bit(1),
  5    58 	    4 entry		bit(1),
  5    59 	    4 file		bit(1),
  5    60 	    4 arg_descriptor	bit(1),
  5    61 	    4 storage_block		bit(1),
  5    62 	    4 explicit_packed	bit(1), /* options(packed) */
  5    63 	    4 condition		bit(1),
  5    64 	    4 format		bit(1),
  5    65 	    4 builtin		bit(1),
  5    66 	    4 generic		bit(1),
  5    67 	    4 picture		bit(1),
  5    68 
  5    69 	  3 misc_attributes		structure unal,
  5    70 	    4 dimensioned		bit(1),
  5    71 	    4 initialed		bit(1),
  5    72 	    4 aligned		bit(1),
  5    73 	    4 unaligned		bit(1),
  5    74 	    4 signed		bit(1),
  5    75 	    4 unsigned		bit(1),
  5    76 	    4 precision		bit(1),
  5    77 	    4 varying		bit(1),
  5    78 	    4 local		bit(1),
  5    79 	    4 decimal		bit(1),
  5    80 	    4 binary		bit(1),
  5    81 	    4 real		bit(1),
  5    82 	    4 complex		bit(1),
  5    83 	    4 variable		bit(1),
  5    84 	    4 reducible		bit(1),
  5    85 	    4 irreducible		bit(1),
  5    86 	    4 returns		bit(1),
  5    87 	    4 position		bit(1),
  5    88 	    4 internal		bit(1),
  5    89 	    4 external		bit(1),
  5    90 	    4 like		bit(1),
  5    91 	    4 member		bit(1),
  5    92 	    4 non_varying		bit(1),
  5    93 	    4 options		bit(1),
  5    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  5    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  5    96 
  5    97 	  3 storage_class		structure unal,
  5    98 	    4 auto		bit(1),
  5    99 	    4 based		bit(1),
  5   100 	    4 static		bit(1),
  5   101 	    4 controlled		bit(1),
  5   102 	    4 defined		bit(1),
  5   103 	    4 parameter		bit(1),
  5   104 	    4 param_desc		bit(1),
  5   105 	    4 constant		bit(1),
  5   106 	    4 temporary		bit(1),
  5   107 	    4 return_value		bit(1),
  5   108 
  5   109 	  3 file_attributes		structure unal,
  5   110 	    4 print		bit(1),
  5   111 	    4 input		bit(1),
  5   112 	    4 output		bit(1),
  5   113 	    4 update		bit(1),
  5   114 	    4 stream		bit(1),
  5   115 	    4 reserved_1		bit(1),
  5   116 	    4 record		bit(1),
  5   117 	    4 sequential		bit(1),
  5   118 	    4 direct		bit(1),
  5   119 	    4 interactive		bit(1),		/* env(interactive) */
  5   120 	    4 reserved_2		bit(1),
  5   121 	    4 reserved_3		bit(1),
  5   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  5   123 	    4 keyed		bit(1),
  5   124 	    4 reserved_4		bit(1),
  5   125 	    4 environment		bit(1),
  5   126 
  5   127 	  3 compiler_developed	structure unal,
  5   128 	    4 aliasable		bit(1),
  5   129 	    4 packed		bit(1),
  5   130 	    4 passed_as_arg		bit(1),
  5   131 	    4 allocate		bit(1),
  5   132 	    4 set			bit(1),
  5   133 	    4 exp_extents		bit(1),
  5   134 	    4 refer_extents		bit(1),
  5   135 	    4 star_extents		bit(1),
  5   136 	    4 isub		bit(1),
  5   137 	    4 put_in_symtab		bit(1),
  5   138 	    4 contiguous		bit(1),
  5   139 	    4 put_data		bit(1),
  5   140 	    4 overlayed		bit(1),
  5   141 	    4 error		bit(1),
  5   142 	    4 symtab_processed	bit(1),
  5   143 	    4 overlayed_by_builtin	bit(1),
  5   144 	    4 defaulted		bit(1),
  5   145 	    4 connected		bit(1);
  5   146 
  5   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       77 
  6     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  6     2 
  6     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  6     4 
  6     5 /* format: style3 */
  6     6 dcl	1 operator	based aligned,
  6     7 	  2 node_type	bit (9) unaligned,
  6     8 	  2 op_code	bit (9) unaligned,
  6     9 	  2 shared	bit (1) unaligned,
  6    10 	  2 processed	bit (1) unaligned,
  6    11 	  2 optimized	bit (1) unaligned,
  6    12 	  2 number	fixed (14) unaligned,
  6    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  6    14 
  6    15 dcl	max_number_of_operands
  6    16 			fixed bin (15) int static options (constant) initial (32767);
  6    17 
  6    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       78 
  7     1 /* BEGIN INCLUDE FILE ... list.incl.pl1 */
  7     2 
  7     3 /* Modified 26 June 81 by EBush to add max_list_elements */
  7     4 
  7     5 
  7     6 dcl	1 list		based aligned,
  7     7 	2 node_type	bit(9) unaligned,
  7     8 	2 reserved	bit(12) unaligned,
  7     9 	2 number		fixed(14) unaligned,
  7    10 	2 element		dimension(n refer(list.number)) ptr unaligned;
  7    11 
  7    12 dcl       max_list_elements   fixed bin(17) internal static options (constant)
  7    13 	                    init(16383);
  7    14 
  7    15 /* END INCLUDE FILE ... list.incl.pl1 */
       79 
  8     1 /* ***********************************************************
  8     2*   *                                                         *
  8     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  8     4*   *                                                         *
  8     5*   *********************************************************** */
  8     6 /* BEGIN INCLUDE FILE ... statement.incl.pl1 */
  8     7 /* Internal interface of the PL/I compiler */
  8     8 
  8     9 dcl	1 statement		based aligned,
  8    10 	2 node_type		bit(9) unaligned,
  8    11 	2 source_id		structure unaligned,
  8    12 	  3 file_number		bit(8),
  8    13 	  3 line_number		bit(14),
  8    14 	  3 statement_number	bit(5),
  8    15 	2 next			ptr unaligned,
  8    16 	2 back			ptr unaligned,
  8    17 	2 root			ptr unaligned,
  8    18 	2 labels			ptr unaligned,
  8    19 	2 reference_list		ptr unaligned,
  8    20 	2 state_list		ptr unaligned,
  8    21 	2 reference_count		fixed(17) unaligned,
  8    22 	2 ref_count_copy		fixed(17) unaligned,
  8    23 	2 object			structure unaligned,
  8    24 	  3 start			fixed(17),
  8    25 	  3 finish		fixed(17),
  8    26 	2 source			structure unaligned,
  8    27 	  3 segment		fixed(11),
  8    28 	  3 start			fixed(23),
  8    29 	  3 length		fixed(11),
  8    30 	2 prefix			bit(12) unaligned,
  8    31 	2 optimized		bit(1) unaligned,
  8    32 	2 free_temps		bit(1) unaligned,
  8    33 	2 LHS_in_RHS		bit(1) unaligned,
  8    34 	2 statement_type		bit(9) unaligned,
  8    35 	2 bits			structure unaligned,
  8    36 	  3 processed		bit(1) unaligned,
  8    37 	  3 put_in_profile		bit(1) unaligned,
  8    38 	  3 generated		bit(1) unaligned,
  8    39 	  3 snap			bit(1) unaligned,
  8    40 	  3 system		bit(1) unaligned,
  8    41 	  3 irreducible		bit(1) unaligned,
  8    42 	  3 checked		bit(1) unaligned,
  8    43 	  3 save_temps		bit(1) unaligned,
  8    44 	  3 suppress_warnings	bit(1) unaligned,
  8    45 	  3 force_nonquick		bit(1) unaligned,
  8    46 	  3 expanded_by_name	bit(1) unaligned,
  8    47 	  3 begins_loop		bit(1) unaligned,
  8    48 	  3 pad			bit(24) unaligned;
  8    49 
  8    50 /* END INCLUDE FILE ... statement.incl.pl1 */
       80 
  9     1 /* BEGIN INCLUDE FILE ... block.incl.pl1 */
  9     2 /* Modified 22 Ocober 1980 by M. N. Davidoff to increase max block.number to 511 */
  9     3 /* format: style3,idind30 */
  9     4 
  9     5 declare	1 block			aligned based,
  9     6 	  2 node_type		bit (9) unaligned,
  9     7 	  2 source_id		structure unaligned,
  9     8 	    3 file_number		bit (8),
  9     9 	    3 line_number		bit (14),
  9    10 	    3 statement_number	bit (5),
  9    11 	  2 father		ptr unaligned,
  9    12 	  2 brother		ptr unaligned,
  9    13 	  2 son			ptr unaligned,
  9    14 	  2 declaration		ptr unaligned,
  9    15 	  2 end_declaration		ptr unaligned,
  9    16 	  2 default		ptr unaligned,
  9    17 	  2 end_default		ptr unaligned,
  9    18 	  2 context		ptr unaligned,
  9    19 	  2 prologue		ptr unaligned,
  9    20 	  2 end_prologue		ptr unaligned,
  9    21 	  2 main			ptr unaligned,
  9    22 	  2 end_main		ptr unaligned,
  9    23 	  2 return_values		ptr unaligned,
  9    24 	  2 return_count		ptr unaligned,
  9    25 	  2 plio_ps		ptr unaligned,
  9    26 	  2 plio_fa		ptr unaligned,
  9    27 	  2 plio_ffsb		ptr unaligned,
  9    28 	  2 plio_ssl		ptr unaligned,
  9    29 	  2 plio_fab2		ptr unaligned,
  9    30 	  2 block_type		bit (9) unaligned,
  9    31 	  2 prefix		bit (12) unaligned,
  9    32 	  2 like_attribute		bit (1) unaligned,
  9    33 	  2 no_stack		bit (1) unaligned,
  9    34 	  2 get_data		bit (1) unaligned,
  9    35 	  2 flush_at_call		bit (1) unaligned,
  9    36 	  2 processed		bit (1) unaligned,
  9    37 	  2 text_displayed		bit (1) unaligned,
  9    38 	  2 number		fixed bin (9) unsigned unaligned,
  9    39 	  2 free_temps		dimension (3) ptr,	/* these fields are used by the code generator */
  9    40 	  2 temp_list		ptr,
  9    41 	  2 entry_list		ptr,
  9    42 	  2 o_and_s		ptr,
  9    43 	  2 why_nonquick		aligned,
  9    44 	    3 auto_adjustable_storage bit (1) unaligned,
  9    45 	    3 returns_star_extents	bit (1) unaligned,
  9    46 	    3 stack_extended_by_args	bit (1) unaligned,
  9    47 	    3 invoked_by_format	bit (1) unaligned,
  9    48 	    3 format_statement	bit (1) unaligned,
  9    49 	    3 io_statements		bit (1) unaligned,
  9    50 	    3 assigned_to_entry_var	bit (1) unaligned,
  9    51 	    3 condition_statements	bit (1) unaligned,
  9    52 	    3 no_owner		bit (1) unaligned,
  9    53 	    3 recursive_call	bit (1) unaligned,
  9    54 	    3 options_non_quick	bit (1) unaligned,
  9    55 	    3 options_variable	bit (1) unaligned,
  9    56 	    3 never_referenced	bit (1) unaligned,
  9    57 	    3 pad_nonquick		bit (5) unaligned,
  9    58 	  2 prologue_flag		bit (1) unaligned,
  9    59 	  2 options_main		bit (1) unaligned,
  9    60 	  2 pad			bit (16) unaligned,
  9    61 	  2 number_of_entries	fixed bin (17),
  9    62 	  2 level			fixed bin (17),
  9    63 	  2 last_auto_loc		fixed bin (17),
  9    64 	  2 symbol_block		fixed bin (17),
  9    65 	  2 entry_info		fixed bin (18),
  9    66 	  2 enter			structure unaligned,
  9    67 	    3 start		fixed bin (17),
  9    68 	    3 end			fixed bin (17),
  9    69 	  2 leave			structure unaligned,
  9    70 	    3 start		fixed bin (17),
  9    71 	    3 end			fixed bin (17),
  9    72 	  2 owner			ptr;
  9    73 
  9    74 declare	max_block_number		fixed bin internal static options (constant) initial (511);
  9    75 
  9    76 /* END INCLUDE FILE ... block.incl.pl1 */
       81 
 10     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
 10     2 
 10     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
 10     4 
 10     5 dcl (	block_node		initial("000000001"b),
 10     6 	statement_node		initial("000000010"b),
 10     7 	operator_node		initial("000000011"b),
 10     8 	reference_node		initial("000000100"b),
 10     9 	token_node		initial("000000101"b),
 10    10 	symbol_node		initial("000000110"b),
 10    11 	context_node		initial("000000111"b),
 10    12 	array_node		initial("000001000"b),
 10    13 	bound_node		initial("000001001"b),
 10    14 	format_value_node		initial("000001010"b),
 10    15 	list_node			initial("000001011"b),
 10    16 	default_node		initial("000001100"b),
 10    17 	machine_state_node		initial("000001101"b),
 10    18 	source_node		initial("000001110"b),
 10    19 	label_node		initial("000001111"b),
 10    20 	cross_reference_node	initial("000010000"b),
 10    21 	sf_par_node		initial("000010001"b),
 10    22 	temporary_node		initial("000010010"b),
 10    23 	label_array_element_node	initial("000010011"b),
 10    24 	by_name_agg_node		initial("000010100"b))
 10    25 				bit(9) internal static aligned options(constant);
 10    26 
 10    27 dcl	1 node			based aligned,
 10    28 	2 type			unal bit(9),
 10    29 	2 source_id		unal structure,
 10    30 	  3 file_number		bit(8),
 10    31 	  3 line_number		bit(14),
 10    32 	  3 statement_number	bit(5);
 10    33 
 10    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
       82 
 11     1 dcl (	real_fix_bin_1		init(1),
 11     2 	real_fix_bin_2		init(2),
 11     3 	real_flt_bin_1		init(3),
 11     4 	real_flt_bin_2		init(4),
 11     5 	complex_fix_bin_1		init(5),
 11     6 	complex_fix_bin_2		init(6),
 11     7 	complex_flt_bin_1		init(7),
 11     8 	complex_flt_bin_2		init(8),
 11     9 	real_fix_dec		init(9),
 11    10 	real_flt_dec		init(10),
 11    11 	complex_fix_dec		init(11),
 11    12 	complex_flt_dec		init(12),
 11    13 	char_string		init(13),
 11    14 	bit_string		init(14),
 11    15 	label_constant		init(15),
 11    16 	local_label_variable	init(16),
 11    17 	label_variable		init(17),
 11    18 	entry_variable		init(18),
 11    19 	ext_entry_in		init(19),
 11    20 	ext_entry_out		init(20),
 11    21 	int_entry			init(21),
 11    22 	int_entry_other		init(22),
 11    23 	unpacked_ptr		init(23),
 11    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
       83 
 12     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
 12     2 
 12     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
 12     4 
 12     5 dcl (	bit_		init(1),
 12     6 	digit_		init(2),
 12     7 	character_	init(3),
 12     8 	half_		init(4),
 12     9 	word_		init(5),
 12    10 	mod2_		init(6),
 12    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
 12    12 
 12    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       84 
 13     1 /* BEGIN INCLUDE FILE ... temporary.incl.pl1 */
 13     2 
 13     3 dcl	1 temporary	based,
 13     4 	2 node_type	bit(9),	/* type is "000001010"b */
 13     5 	2 size		fixed bin(18),
 13     6 	2 next		ptr,
 13     7 	2 location	fixed bin(18),
 13     8 	2 ref_count	fixed bin,
 13     9 	2 symbol		ptr unal,
 13    10 	2 last_freed	fixed bin(18);
 13    11 
 13    12 /* END INCLUDE FILE ... temporary.incl.pl1 */
       85 
       86 
       87 	call get_ms;
       88 	pt = m_s_p;
       89 
       90 init:	machine_state.next,
       91 	     string_reg.variable,
       92 	     complex_reg.variable,
       93 	     decimal_reg.variable = null;
       94 
       95 	do i = 0 to 7;
       96 	     index_regs (i).type = 0;
       97 	     base_regs (i).type = 0;
       98 	     base_regs (i).locked = 0;
       99 	end;
      100 
      101 init1:	machine_state.indicators,
      102 	     a_reg.constant,
      103 	     q_reg.constant,
      104 	     a_reg.number_h_o,
      105 	     q_reg.number_h_o,
      106 	     a_reg.number,
      107 	     q_reg.number,
      108 	     a_reg.changed,
      109 	     q_reg.changed = 0;
      110 
      111 	a_reg.locked,
      112 	     q_reg.locked,
      113 	     a_reg.instruction,
      114 	     q_reg.instruction = "0"b;
      115 
      116 	cg_stat$last_call = cg_stat$text_pos;
      117 
      118 	return;
      119 
      120 state_man$save_ms: entry (pt, cond);
      121 
      122 /* this entry is called to append a copy of the current machine
      123*	   state to the list of states on a specified statement node */
      124 
      125 	dcl     cond		 bit (1) aligned;	/* "1"b if transfer is conditional */
      126 
      127 	dcl     (conditional, optimize) bit (1) aligned;
      128 
      129 	p = pt;
      130 	optimize = ^p -> statement.save_temps;
      131 
      132 	conditional = cond;
      133 
      134 	if conditional
      135 	then do;
      136 		call get_ms;
      137 		m_s_p -> machine_state = cg_stat$m_s_p -> machine_state;
      138 	     end;
      139 
      140 	machine_state.next = p -> statement.state_list;
      141 	p -> statement.state_list = m_s_p;
      142 	p -> statement.reference_count = p -> statement.reference_count - 1;
      143 
      144 	q = p -> statement.reference_list;
      145 
      146 /* see if any of the expressions in the active registers have to be
      147*	   saved because they will be needed at the statement being transfered 
      148*	   to.  Also, turn off bit saying reference is in a register if this
      149*	   is forward unconditional transfer */
      150 
      151 	do i = 1 to a_reg.number;
      152 	     p = a_reg.variable (i);
      153 	     if need_ref () then call save_temp (1);
      154 	     if ^conditional then p -> reference.value_in.a = "0"b;
      155 	end;
      156 
      157 	do i = 1 to q_reg.number;
      158 	     p = q_reg.variable (i);
      159 	     if need_ref () then call save_temp (2);
      160 	     if ^conditional then p -> reference.value_in.q = "0"b;
      161 	end;
      162 
      163 	do i = 0 to 7;
      164 	     if index_regs (i).type >= 2
      165 	     then do;
      166 		     p = index_regs (i).variable;
      167 		     if p ^= null
      168 		     then do;
      169 			     if need_ref () then call save_temp (0);
      170 			     if ^conditional then p -> reference.value_in.x (i) = "0"b;
      171 			end;
      172 		end;
      173 	end;
      174 
      175 	do i = 1 to 6;
      176 	     p = base_regs (i).variable;
      177 	     n = base_regs (i).type;
      178 	     if p = null then n = 0;
      179 	     if n = 1
      180 	     then do;
      181 		     if need_ref () then call save_temp (-i);
      182 		     if ^conditional then p -> reference.value_in.b (i) = "0"b;
      183 		end;
      184 	     else if n = 2
      185 	     then if ^conditional then p -> reference.address_in.b (i) = "0"b;
      186 	end;
      187 
      188 	if ^conditional
      189 	then do;
      190 
      191 		p = complex_reg.variable;
      192 		if p ^= null then p -> reference.value_in.complex_aq = "0"b;
      193 
      194 		p = string_reg.variable;
      195 		if p ^= null then p -> reference.value_in.string_aq = "0"b;
      196 
      197 		p = decimal_reg.variable;
      198 		if p ^= null then p -> reference.value_in.decimal_aq = "0"b;
      199 
      200 		cg_stat$m_s_p = null;
      201 	     end;
      202 
      203 	cg_stat$last_call = cg_stat$text_pos;
      204 
      205 	return;
      206 
      207 state_man$save_regs: entry (pt);
      208 
      209 /* This entrypoint will see if any of the expressions in the active
      210*   registers have to be saved because they will be needed at the statement
      211*   being transfered to.  This is part of the job that state_man$save_ms does
      212*   but is done here so that register saving will not clobber the indicators.
      213*   This occurs when another register (usually an X register) is loaded in
      214*   order to get a big enough offset to store a useful register. (PL1 2091) */
      215 
      216 	p = pt;
      217 	optimize = ^p -> statement.save_temps;	/* used by need_ref */
      218 	q = p -> statement.reference_list;	/* used by need_ref */
      219 
      220 	do i = 1 to a_reg.number;
      221 	     p = a_reg.variable (i);
      222 	     if need_ref () then call save_temp (1);
      223 	end;
      224 
      225 	do i = 1 to q_reg.number;
      226 	     p = q_reg.variable (i);
      227 	     if need_ref () then call save_temp (2);
      228 	end;
      229 
      230 	do i = 0 to 7;
      231 	     if index_regs (i).type >= 2
      232 	     then do;
      233 		     p = index_regs (i).variable;
      234 		     if p ^= null then if need_ref () then call save_temp (0);
      235 		end;
      236 	end;
      237 
      238 	do i = 1 to 6;
      239 	     p = base_regs (i).variable;
      240 	     if p ^= null then
      241 		if base_regs (i).type = 1 then
      242 		     if need_ref () then call save_temp (-i);
      243 	end;
      244 
      245 	return;	/* end of save_regs */
      246 
      247 state_man$merge_ms: entry (pt);
      248 
      249 /* this entry is called to merge the machine states
      250*	   attached to a statement node */
      251 
      252 	if pt -> statement.reference_count = 0
      253 	then erase = "0"b;
      254 	else erase = (19)"1"b;
      255 
      256 	p = pt -> statement.state_list;
      257 
      258 	if m_s_p = null
      259 	then do;
      260 
      261 /* previous statement was unconditional transfer */
      262 
      263 		if p = null
      264 		then do;
      265 			call get_ms;
      266 			cg_stat$m_s_p = m_s_p;
      267 			goto init;
      268 		     end;
      269 
      270 		m_s_p, cg_stat$m_s_p = p;
      271 		p = machine_state.next;
      272 		prev_state = "0"b;
      273 	     end;
      274 
      275 	else prev_state = "1"b;
      276 
      277 	if erase
      278 	then machine_state.indicators = 0;
      279 
      280 	do while (p ^= null);
      281 
      282 	     if machine_state.indicators ^= p -> machine_state.indicators
      283 	     then machine_state.indicators = 0;
      284 	     else if machine_state.indicators = -2
      285 	     then if indicators_ref (2) ^= p -> indicators_ref (2)
      286 		then machine_state.indicators = 0;
      287 		else if indicators_ref (3) ^= p -> indicators_ref (3)
      288 		then machine_state.indicators = 0;
      289 
      290 	     if substr (erase, 1, 1) then goto scrub_a;
      291 
      292 	     if a_reg.size ^= p -> a_reg.size
      293 	     then do;
      294 erase_a:		     substr (erase, 1, 1) = "1"b;
      295 
      296 scrub_a:		     do j = 1 to p -> a_reg.number;
      297 			q = p -> a_reg.variable (j);
      298 			if q ^= null then q -> reference.value_in.a = "0"b;
      299 		     end;
      300 
      301 
      302 		     goto chk_q;
      303 		end;
      304 
      305 	     if a_reg.length ^= p -> a_reg.length then goto erase_a;
      306 	     if a_reg.offset ^= p -> a_reg.offset then goto erase_a;
      307 	     if a_reg.constant ^= p -> a_reg.constant then goto erase_a;
      308 
      309 	     n = a_reg.number;
      310 	     do i = 1 by 1 while (i <= n);
      311 
      312 scan_a:		q = a_reg.variable (i);
      313 
      314 		do j = 1 to p -> a_reg.number;
      315 		     if q = p -> a_reg.variable (j)
      316 		     then do;
      317 			     p -> a_reg.variable (j) = null;
      318 			     goto ok_a;
      319 			end;
      320 		end;
      321 
      322 		q -> reference.value_in.a = "0"b;
      323 
      324 		n = n - 1;
      325 		if n = 0 then goto erase_a;
      326 		if n < i then goto end_a;
      327 
      328 		do j = i to n;
      329 		     a_reg.variable (j) = a_reg.variable (j + 1);
      330 		end;
      331 
      332 		goto scan_a;
      333 
      334 ok_a:	     end;
      335 
      336 end_a:	     a_reg.number = n;
      337 
      338 chk_q:	     if substr (erase, 2, 1) then goto scrub_q;
      339 
      340 	     if q_reg.size ^= p -> q_reg.size
      341 	     then do;
      342 erase_q:		     substr (erase, 2, 1) = "1"b;
      343 
      344 scrub_q:		     do j = 1 to p -> q_reg.number;
      345 			q = p -> q_reg.variable (j);
      346 			if q ^= null then q -> reference.value_in.q = "0"b;
      347 		     end;
      348 		     goto chk_sr;
      349 		end;
      350 
      351 	     if q_reg.length ^= p -> q_reg.length then goto erase_q;
      352 	     if q_reg.offset ^= p -> q_reg.offset then goto erase_q;
      353 	     if q_reg.constant ^= p -> q_reg.constant then goto erase_q;
      354 
      355 	     n = q_reg.number;
      356 	     do i = 1 by 1 while (i <= n);
      357 
      358 scan_q:		q = q_reg.variable (i);
      359 
      360 		do j = 1 to p -> q_reg.number;
      361 		     if q = p -> q_reg.variable (j)
      362 		     then do;
      363 			     p -> q_reg.variable (j) = null;
      364 			     goto ok_q;
      365 			end;
      366 		end;
      367 
      368 		q -> reference.value_in.q = "0"b;
      369 
      370 		n = n - 1;
      371 		if n = 0 then goto erase_q;
      372 		if n < i then goto end_q;
      373 
      374 		do j = i to n;
      375 		     q_reg.variable (j) = q_reg.variable (j + 1);
      376 		end;
      377 
      378 		goto scan_q;
      379 
      380 ok_q:	     end;
      381 
      382 end_q:	     q_reg.number = n;
      383 
      384 chk_sr:	     if substr (erase, 3, 1) then goto scrub_sr;
      385 
      386 	     if string_reg.size ^= p -> string_reg.size
      387 	     then do;
      388 erase_sr:		     substr (erase, 3, 1) = "1"b;
      389 
      390 scrub_sr:		     q = p -> string_reg.variable;
      391 		     if q ^= null then q -> reference.value_in.string_aq = "0"b;
      392 		     goto chk_cx;
      393 		end;
      394 
      395 	     if string_reg.variable ^= p -> string_reg.variable then goto erase_sr;
      396 
      397 chk_cx:	     if substr (erase, 4, 1) then goto scrub_cx;
      398 
      399 	     if complex_reg.size ^= p -> complex_reg.size
      400 	     then do;
      401 erase_cx:		     substr (erase, 4, 1) = "1"b;
      402 
      403 scrub_cx:		     q = p -> complex_reg.variable;
      404 		     if q ^= null then q -> reference.value_in.complex_aq = "0"b;
      405 		     goto chk_d;
      406 		end;
      407 
      408 	     if complex_reg.scale ^= p -> complex_reg.scale then goto erase_cx;
      409 	     if complex_reg.variable ^= p -> complex_reg.variable then goto erase_cx;
      410 
      411 chk_d:	     if substr (erase, 5, 1) then goto scrub_d;
      412 
      413 	     if decimal_reg.size ^= p -> decimal_reg.size
      414 	     then do;
      415 erase_d:		     substr (erase, 5, 1) = "1"b;
      416 
      417 scrub_d:		     q = p -> decimal_reg.variable;
      418 		     if q ^= null then q -> reference.value_in.decimal_aq = "0"b;
      419 		     goto chk_xr;
      420 		end;
      421 
      422 	     if decimal_reg.scale ^= p -> decimal_reg.scale then goto erase_d;
      423 	     if decimal_reg.variable ^= p -> decimal_reg.variable then goto erase_d;
      424 
      425 chk_xr:	     do i = 0 to 7;
      426 
      427 		if substr (erase, i + 6, 1) then goto scrub_xr;
      428 
      429 		n = index_regs (i).type;
      430 		if n ^= p -> index_regs (i).type
      431 		then do;
      432 erase_xr:			substr (erase, i + 6, 1) = "1"b;
      433 
      434 scrub_xr:			if p -> index_regs (i).type >= 2
      435 			then do;
      436 				q = p -> index_regs (i).variable;
      437 				if q ^= null then q -> reference.value_in.x (i) = "0"b;
      438 			     end;
      439 
      440 			goto end_xr;
      441 		     end;
      442 
      443 		if n >= 2
      444 		then if index_regs (i).variable ^= p -> index_regs (i).variable
      445 		     then goto erase_xr;
      446 
      447 		if index_regs (i).constant ^= p -> index_regs (i).constant then goto erase_xr;
      448 
      449 end_xr:	     end;
      450 
      451 chk_base:	     do i = 1 to 6;
      452 
      453 		if substr (erase, i + 13, 1) then goto scrub_base;
      454 
      455 		n = base_regs (i).type;
      456 		if n ^= p -> base_regs (i).type
      457 		then do;
      458 erase_base:		substr (erase, i + 13, 1) = "1"b;
      459 
      460 scrub_base:		q = p -> base_regs (i).variable;
      461 
      462 			n = p -> base_regs (i).type;
      463 			if q = null then n = 0;
      464 			if n = 1 then q -> reference.value_in.b (i) = "0"b;
      465 			else if n = 2 then q -> reference.address_in.b (i) = "0"b;
      466 
      467 			goto end_base;
      468 		     end;
      469 
      470 		if n = 0 then goto end_base;
      471 
      472 		if substr ("11000110110000"b, n, 1)
      473 		then if base_regs (i).variable ^= p -> base_regs (i).variable
      474 		     then goto erase_base;
      475 
      476 		if substr ("00110001111101"b, n, 1)
      477 		then if base_regs (i).constant ^= p -> base_regs (i).constant
      478 		     then goto erase_base;
      479 
      480 end_base:	     end;
      481 
      482 	     q = p;
      483 	     p = p -> machine_state.next;
      484 
      485 	     q -> machine_state.next = cg_stat$ms_list;
      486 	     cg_stat$ms_list = q;
      487 	end;
      488 
      489 	if erase
      490 	then call wipe;
      491 
      492 	if prev_state | (^erase = "0"b) then return;
      493 
      494 	if a_reg.constant = 0
      495 	then do i = 1 to a_reg.number;
      496 		a_reg (i).variable -> reference.value_in.a = "1"b;
      497 	     end;
      498 
      499 	if q_reg.constant = 0
      500 	then do i = 1 to q_reg.number;
      501 		q_reg (i).variable -> reference.value_in.q = "1"b;
      502 	     end;
      503 
      504 	q = string_reg.variable;
      505 	if q ^= null then q -> reference.value_in.string_aq = "1"b;
      506 
      507 	q = complex_reg.variable;
      508 	if q ^= null then q -> reference.value_in.complex_aq = "1"b;
      509 
      510 	q = decimal_reg.variable;
      511 	if q ^= null then q -> reference.value_in.decimal_aq = "1"b;
      512 
      513 	do i = 0 to 7;
      514 	     if index_regs (i).type >= 2
      515 	     then if index_regs (i).constant = 0
      516 		then do;
      517 			q = index_regs (i).variable;
      518 			if q ^= null then q -> reference.value_in.x (i) = "1"b;
      519 		     end;
      520 	end;
      521 
      522 	do i = 1 to 6;
      523 	     q = base_regs (i).variable;
      524 	     n = base_regs (i).type;
      525 	     if q = null then n = 0;
      526 	     if n = 1 then q -> reference.value_in.b (i) = "1"b;
      527 	     else if n = 2 then q -> reference.address_in.b (i) = "1"b;
      528 	end;
      529 
      530 	return;
      531 
      532 state_man$discard_ms: entry;
      533 
      534 /* this entry is called to discard the current machine state after
      535*	   an unconditional transfer back to a previously defined label */
      536 
      537 	machine_state.next = cg_stat$ms_list;
      538 	cg_stat$ms_list = m_s_p;
      539 	cg_stat$m_s_p = null;
      540 
      541 /* now flush state */
      542 
      543 state_man$flush: entry;
      544 
      545 /* this entry is called to completely flush the machine state */
      546 
      547 	machine_state.indicators = 0;
      548 
      549 /* save the index registers used by the operator */
      550 
      551 	erase = ("1111100000000111111"b);
      552 	call wipe;
      553 
      554 /* free all registers */
      555 
      556 	erase = (19)"1"b;
      557 	call wipe;
      558 
      559 	cg_stat$last_call = cg_stat$text_pos;
      560 	return;
      561 
      562 state_man$flush_ref: entry (pt);
      563 
      564 /* this entry is called to flush a particular reference from
      565*	   the machine state */
      566 
      567 	p = pt;
      568 
      569 	if machine_state.indicators = -2
      570 	then if p = indicators_ref (2)
      571 	     then machine_state.indicators = 0;
      572 	     else if p = indicators_ref (3)
      573 	     then machine_state.indicators = 0;
      574 
      575 /* can't test reference.value_in because ref could
      576*	   be in reg with a constant added */
      577 
      578 	n = a_reg.number;
      579 	do i = 1 to n;
      580 	     if a_reg.variable (i) = p
      581 	     then do;
      582 		     a_reg.number = n - 1;
      583 
      584 		     do i = i + 1 to n;
      585 			a_reg.variable (i - 1) = a_reg.variable (i);
      586 		     end;
      587 
      588 		     goto frq;
      589 		end;
      590 	end;
      591 
      592 frq:	n = q_reg.number;
      593 	do i = 1 to n;
      594 	     if q_reg.variable (i) = p
      595 	     then do;
      596 		     q_reg.number = n - 1;
      597 
      598 		     do i = i + 1 to n;
      599 			q_reg.variable (i - 1) = q_reg.variable (i);
      600 		     end;
      601 
      602 		     goto frsr;
      603 		end;
      604 	end;
      605 
      606 frsr:	if string_reg.variable = p then string_reg.variable = null;
      607 
      608 	if complex_reg.variable = p then complex_reg.variable = null;
      609 
      610 	if decimal_reg.variable = p then decimal_reg.variable = null;
      611 
      612 	do i = 0 to 7;
      613 	     n = index_regs (i).type;
      614 	     if abs (n) >= 2
      615 	     then if index_regs (i).variable = p
      616 		then do;
      617 			index_regs (i).type = min (0, n);
      618 			index_regs (i).variable = null;
      619 		     end;
      620 	end;
      621 
      622 	do i = 1 to 6;
      623 	     if base_regs (i).type = 1
      624 	     then if base_regs (i).variable = p
      625 		then base_regs (i).type = 0;
      626 	end;
      627 
      628 	string (p -> reference.value_in) = "0"b;
      629 	return;
      630 
      631 state_man$flush_address: entry (pt);
      632 
      633 /* this entry is called to remove the address of a reference
      634*	   from the machine state  */
      635 
      636 	p = pt;
      637 
      638 	do i = 1 to 6;
      639 	     if base_regs (i).type = 2
      640 	     then if base_regs (i).variable = p
      641 		then base_regs (i).type = 0;
      642 	end;
      643 
      644 	string (p -> reference.address_in.b) = "0"b;
      645 	return;
      646 
      647 state_man$flush_sym: entry (pt);
      648 
      649 /* this entry is called to flush all references to a particular
      650*	   symbol from the machine state.  it should be called whenever
      651*	   a short string is set by an EIS instruction (which does not
      652*	   alter a register). */
      653 
      654 	sym = pt;
      655 
      656 	if machine_state.indicators = -2
      657 	then if sym = indicators_ref (2) -> reference.symbol
      658 	     then machine_state.indicators = 0;
      659 	     else if sym = indicators_ref (3) -> reference.symbol
      660 	     then machine_state.indicators = 0;
      661 
      662 	i = 1;
      663 	do while (i <= a_reg.number);
      664 	     if sym = a_reg.variable (i) -> reference.symbol
      665 	     then do;
      666 		     a_reg.variable (i) -> reference.value_in.a = "0"b;
      667 		     a_reg.number = a_reg.number - 1;
      668 		     do j = i to a_reg.number;
      669 			a_reg.variable (j) = a_reg.variable (j + 1);
      670 		     end;
      671 		end;
      672 	     else i = i + 1;
      673 	end;
      674 
      675 	i = 1;
      676 	do while (i <= q_reg.number);
      677 	     if sym = q_reg.variable (i) -> reference.symbol
      678 	     then do;
      679 		     q_reg.variable (i) -> reference.value_in.q = "0"b;
      680 		     q_reg.number = q_reg.number - 1;
      681 		     do j = i to q_reg.number;
      682 			q_reg.variable (j) = q_reg.variable (j + 1);
      683 		     end;
      684 		end;
      685 	     else i = i + 1;
      686 	end;
      687 
      688 	if string_reg.variable ^= null
      689 	then if sym = string_reg.variable -> reference.symbol
      690 	     then do;
      691 		     string_reg.variable -> reference.value_in.string_aq = "0"b;
      692 		     string_reg.variable = null;
      693 		end;
      694 
      695 	if complex_reg.variable ^= null
      696 	then if sym = complex_reg.variable -> reference.symbol
      697 	     then do;
      698 		     complex_reg.variable -> reference.value_in.complex_aq = "0"b;
      699 		     complex_reg.variable = null;
      700 		end;
      701 
      702 	if decimal_reg.variable ^= null
      703 	then if sym = decimal_reg.variable -> reference.symbol
      704 	     then do;
      705 		     decimal_reg.variable -> reference.value_in.decimal_aq = "0"b;
      706 		     decimal_reg.variable = null;
      707 		end;
      708 
      709 	do i = 0 to 7;
      710 	     if abs (index_regs (i).type) >= 2
      711 	     then do;
      712 		     q = index_regs (i).variable;
      713 		     if sym = q -> reference.symbol
      714 		     then do;
      715 			     q -> reference.value_in.x (i) = "0"b;
      716 			     index_regs (i).type = 0;
      717 			end;
      718 		end;
      719 	end;
      720 
      721 	do i = 1 to 6;
      722 	     if base_regs (i).type = 1
      723 	     then do;
      724 		     q = base_regs (i).variable;
      725 		     if sym = q -> reference.symbol
      726 		     then do;
      727 			     q -> reference.value_in.b (i) = "0"b;
      728 			     base_regs (i).type = 0;
      729 			end;
      730 		end;
      731 	end;
      732 
      733 	return;
      734 
      735 state_man$update_ref: entry (pt);
      736 
      737 /* this entry is called to add a reference to machine state */
      738 
      739 	p = pt;
      740 	if p -> reference.data_type <= real_flt_bin_2 then goto up_q;
      741 
      742 	if p -> reference.data_type <= complex_flt_bin_2
      743 	then do;
      744 
      745 /* update complex register */
      746 
      747 		q = complex_reg.variable;
      748 		if q ^= null then q -> reference.value_in.complex_aq = "0"b;
      749 
      750 		complex_reg.variable = p;
      751 		p -> reference.value_in.complex_aq = "1"b;
      752 
      753 		return;
      754 	     end;
      755 
      756 	if p -> reference.long_ref
      757 	then do;
      758 
      759 /* update string register */
      760 
      761 		q = string_reg.variable;
      762 		if q ^= null then q -> reference.value_in.string_aq = "0"b;
      763 
      764 		string_reg.variable = p;
      765 		string_reg.size = p -> reference.c_length;
      766 		p -> reference.value_in.string_aq = "1"b;
      767 
      768 		p -> reference.address_in.storage = "1"b;
      769 
      770 		return;
      771 	     end;
      772 
      773 /* update a register */
      774 
      775 up_a:	do i = 1 to a_reg.number;
      776 	     a_reg.variable (i) -> reference.value_in.a = "0"b;
      777 	end;
      778 
      779 	n = p -> reference.data_type;
      780 	if n = bit_string | n = char_string
      781 	then do;
      782 		a_reg.size = p -> reference.c_length * convert_size (n);
      783 		a_reg.offset = mod (convert_offset (p -> reference.units) * p -> reference.c_offset, bits_per_two_words);
      784 		if a_reg.offset + a_reg.size > bits_per_word then a_reg.length = bits_per_two_words;
      785 		else a_reg.length = bits_per_word;
      786 	     end;
      787 	else a_reg.size, a_reg.offset = 0;
      788 
      789 	a_reg.number = 1;
      790 	a_reg.variable (1) = p;
      791 	p -> reference.value_in.a = "1"b;
      792 
      793 	return;
      794 
      795 /* update q register */
      796 
      797 up_q:	do i = 1 to q_reg.number;
      798 	     q_reg.variable (i) -> reference.value_in.q = "0"b;
      799 	end;
      800 
      801 	q_reg.number = 1;
      802 	q_reg.variable (1) = p;
      803 	p -> reference.value_in.q = "1"b;
      804 
      805 	return;
      806 
      807 state_man$update_reg: entry (pt, which);
      808 
      809 	dcl     (which, update)	 bit (19) aligned;
      810 
      811 	p = pt;
      812 	update = which;
      813 
      814 	if substr (update, 1, 1) then goto up_a;
      815 	if substr (update, 2, 1) then goto up_q;
      816 
      817 	return;
      818 
      819 state_man$erase_reg: entry (what);
      820 
      821 /* this entry is called to erase the contents of some register(s) */
      822 
      823 	dcl     what		 bit (19) aligned;	/* what to erase */
      824 
      825 	erase = what;
      826 
      827 	if substr (erase, 1, 1)
      828 	then do;
      829 
      830 /* if we are erasing a register, we have to check for
      831*	        double fixed, floating point, or unpacked ptr
      832*	        values left in "q" register */
      833 
      834 		if q_reg.number > 0
      835 		then do;
      836 
      837 			p = q_reg (1).variable;
      838 			n = p -> reference.data_type;
      839 
      840 			if n = real_fix_bin_2
      841 			     | n = real_flt_bin_1
      842 			     | n = real_flt_bin_2
      843 			     | n = unpacked_ptr
      844 			then
      845 
      846 /* have to erase q as well as a */
      847 
      848 			     substr (erase, 2, 1) = "1"b;
      849 		     end;
      850 
      851 		call wipe;
      852 		return;
      853 	     end;
      854 
      855 	if substr (erase, 2, 1)
      856 	then do;
      857 
      858 /* if we are erasing q register, we have to check for
      859*	        a string value that may have gotten shifted into q
      860*	        register from a */
      861 
      862 		if a_reg.number ^= 0
      863 		then if a_reg.size + a_reg.offset > bits_per_word
      864 		     then substr (erase, 1, 1) = "1"b;
      865 		     else a_reg.length = min (a_reg.length, bits_per_word);
      866 
      867 	     end;
      868 
      869 	call wipe;
      870 	return;
      871 
      872 state_man$erase_temps: entry;
      873 
      874 /* This entry is called to save in storage any fixed binary temporary
      875*	   values with precision such that they could be loaded into index registers
      876*	   via eax instructions.  It is used to prevent sequence like
      877*		ldq	j
      878*		cmq	k
      879*		eax5	0,al
      880*		tsx0	ap|r_e_as
      881*	   from being generated		*/
      882 
      883 	erase = "0"b;
      884 
      885 	b19 = "1"b;
      886 	do i = 1 to a_reg.number;
      887 	     p = a_reg (i).variable;
      888 	     if p -> reference.temp_ref then call check_temp;
      889 	end;
      890 
      891 	found = "0"b;
      892 	do i = 1 to q_reg.number while (^found);
      893 	     p = q_reg (i).variable;
      894 	     n = p -> reference.data_type;
      895 
      896 	     if n = real_fix_bin_2 | n = real_flt_bin_2
      897 		| n = real_flt_bin_1 | n = unpacked_ptr
      898 	     then found = "1"b;
      899 	end;
      900 
      901 	if found
      902 	then do;
      903 		b19 = "01"b;
      904 		do i = 1 to q_reg.number;
      905 		     p = q_reg (i).variable;
      906 		     if p -> reference.temp_ref then call check_temp;
      907 		end;
      908 	     end;
      909 
      910 	if erase
      911 	then do;
      912 		call wipe;
      913 		cg_stat$last_call = cg_stat$text_pos;	/* prevent xr_man from changing to eax	*/
      914 	     end;
      915 
      916 	return;
      917 
      918 state_man$unlock: entry;
      919 
      920 /* Unlocks all registers and updates used fields when necessary (for EIS) */
      921 
      922 	a_reg.locked, q_reg.locked = "0"b;
      923 	a_reg.number_h_o, q_reg.number_h_o = 0;
      924 
      925 	text_pos = cg_stat$text_pos;
      926 
      927 	do i = 0 to 7;
      928 	     if index_regs (i).type < 0
      929 	     then do;
      930 		     if index_regs (i).variable ^= null
      931 		     then index_regs (i).type = abs (index_regs (i).type);
      932 		     else index_regs (i).type = 0;
      933 		     index_regs (i).used = text_pos;
      934 		end;
      935 	end;
      936 
      937 	do i = 1 to 6;
      938 	     if base_regs (i).locked ^= 0
      939 	     then do;
      940 		     base_regs (i).locked = 0;
      941 		     base_regs (i).used = text_pos;
      942 		end;
      943 	end;
      944 
      945 	return;
      946 
      947 state_man$set_aliasables: entry (pt);
      948 
      949 /* When an aliasable variable (one that may have an alias) is set, all potential aliases must
      950*   be removed from the machine state.  We only search for shared aliases because the optimizer
      951*   and semantic_translator have automatically handled unshared aliases by the reference count
      952*   scheme. */
      953 
      954 	dcl     all		 bit (1) aligned;	/* "1"b if _a_l_l aliasables are to be flushed */
      955 
      956 	p = pt;
      957 	all = p = null;
      958 
      959 	if machine_state.indicators = -2
      960 	then do;
      961 		q = indicators_ref (2);
      962 		if compare_aliasables ()
      963 		then machine_state.indicators = 0;
      964 		else do;
      965 			q = indicators_ref (3);
      966 			if compare_aliasables ()
      967 			then machine_state.indicators = 0;
      968 		     end;
      969 	     end;
      970 
      971 	n = a_reg.number;
      972 	i = 1;
      973 	do while (i <= n);
      974 	     q = a_reg.variable (i);
      975 	     if compare_aliasables ()
      976 	     then do;
      977 		     q -> reference.value_in.a = "0"b;
      978 		     n = n - 1;
      979 		     do j = i to n;
      980 			a_reg.variable (j) = a_reg.variable (j + 1);
      981 		     end;
      982 		end;
      983 	     else i = i + 1;
      984 	end;
      985 	a_reg.number = n;
      986 
      987 	n = q_reg.number;
      988 	i = 1;
      989 	do while (i <= n);
      990 	     q = q_reg.variable (i);
      991 	     if compare_aliasables ()
      992 	     then do;
      993 		     q -> reference.value_in.q = "0"b;
      994 		     n = n - 1;
      995 		     do j = i to n;
      996 			q_reg.variable (j) = q_reg.variable (j + 1);
      997 		     end;
      998 		end;
      999 	     else i = i + 1;
     1000 	end;
     1001 	q_reg.number = n;
     1002 
     1003 	q = string_reg.variable;
     1004 	if q ^= null
     1005 	then if compare_aliasables ()
     1006 	     then do;
     1007 		     q -> reference.value_in.string_aq = "0"b;
     1008 		     string_reg.variable = null;
     1009 		end;
     1010 
     1011 	q = complex_reg.variable;
     1012 	if q ^= null
     1013 	then if compare_aliasables ()
     1014 	     then do;
     1015 		     q -> reference.value_in.complex_aq = "0"b;
     1016 		     complex_reg.variable = null;
     1017 		end;
     1018 
     1019 	q = decimal_reg.variable;
     1020 	if q ^= null
     1021 	then if compare_aliasables ()
     1022 	     then do;
     1023 		     q -> reference.value_in.decimal_aq = "0"b;
     1024 		     decimal_reg.variable = null;
     1025 		end;
     1026 
     1027 	do i = 0 to 7;
     1028 	     if index_regs (i).type >= 2
     1029 	     then do;
     1030 		     q = index_regs (i).variable;
     1031 		     if compare_aliasables ()
     1032 		     then do;
     1033 			     q -> reference.value_in.x (i) = "0"b;
     1034 			     index_regs (i).type = 0;
     1035 			end;
     1036 		end;
     1037 	end;
     1038 
     1039 	do i = 1 to 6;
     1040 	     if base_regs (i).type = 1
     1041 	     then do;
     1042 		     q = base_regs (i).variable;
     1043 		     if compare_aliasables ()
     1044 		     then do;
     1045 			     q -> reference.value_in.b (i) = "0"b;
     1046 			     base_regs (i).type = 0;
     1047 			end;
     1048 		end;
     1049 	end;
     1050 
     1051 	return;
     1052 
     1053 
     1054 check_temp: proc;
     1055 
     1056 	if p -> reference.data_type ^= real_fix_bin_1 then goto back;
     1057 	if p -> reference.value_in.storage then goto back;
     1058 	if p -> reference.ref_count < 1 then goto back;
     1059 	if p -> reference.symbol -> symbol.c_dcl_size < bits_per_half
     1060 	then erase = erase | b19;
     1061 
     1062 back: end;
     1063 
     1064 get_ms: proc;
     1065 
     1066 	m_s_p = cg_stat$ms_list;
     1067 	if m_s_p ^= null then cg_stat$ms_list = machine_state.next;
     1068 	else do;
     1069 		allocate machine_state in (xeq_tree_area) set (m_s_p);
     1070 		m_s_p -> node.type = machine_state_node;
     1071 		pl1_stat_$node_uses (bin (machine_state_node, 9)) = pl1_stat_$node_uses (bin (machine_state_node, 9)) + 1;
     1072 	     end;
     1073 
     1074      end;
     1075 
     1076 compare_aliasables: proc () returns (bit aligned);
     1077 
     1078 	if p ^= q
     1079 	then if q -> reference.shared
     1080 	     then if all
     1081 		then if q -> reference.aliasable
     1082 		     then return ("1"b);
     1083 		     else if q -> reference.symbol -> symbol.block_node ^= null
     1084 		     then return (q -> reference.symbol -> symbol.block_node -> block.flush_at_call);
     1085 		     else ;
     1086 		else if q -> reference.aliasable
     1087 		then return (compare_alias ((p -> reference.symbol), (q -> reference.symbol)));
     1088 
     1089 	return ("0"b);
     1090      end;
     1091 
 14     1 /* BEGIN INCLUDE FILE ... compare_alias.incl.pl1 */
 14     2 
 14     3 /* This subroutine is an include file and is included in the optimizer and in the
 14     4*   code generator.  It determines whether or not two potentially aliased variables are capable of
 14     5*   occupying the same generation of storage.  Its input is a pair of pointers each pointing
 14     6*   to a symbol node.  */
 14     7 
 14     8 compare_alias: proc(pa,pb) reducible returns(aligned bit);
 14     9 
 14    10 dcl	(a,b,pa,pb) ptr;
 15     1 /* BEGIN INCLUDE FILE ... picture_image.incl.pl1
 15     2*
 15     3*   James R. Davis  12 Mar 79
 15     4**/
 15     5 
 15     6      dcl	   1 picture_image	      aligned based,
 15     7 	     2 type	      fixed bin (8) unal,
 15     8 	     2 prec	      fixed bin (8) unal,	/* precision or length of associated value */
 15     9 	     2 scale	      fixed bin (8) unal,	/* for both fixed and float pictures,
 15    10*							=ndigits after "v" - scale_factor */
 15    11 	     2 piclength	      fixed bin (8) unal,	/* length of picture_constant.chars, <64
 15    12*							=length of normalized-picture-string */
 15    13 	     2 varlength	      fixed bin (8) unal,	/* length of pictured variable in chars, <64
 15    14*							=length of normalized_picture_string - "k" and "v" */
 15    15 	     2 scalefactor	      fixed bin (8) unal,	/* value of pict-sc-f, -256<=x<256  */
 15    16 	     2 explength	      fixed bin (8) unal,	/* length of exp field for float */
 15    17 	     2 drift_character    char (1) unal,
 15    18 	     2 chars	      char (0 refer (picture_image.piclength)) aligned;
 15    19 
 15    20      dcl	   (
 15    21 	   picture_char_type      init (24),
 15    22 	   picture_realfix_type   init (25),
 15    23 	   picture_complexfix_type
 15    24 			      init (26),
 15    25 	   picture_realflo_type   init (27),
 15    26 	   picture_complexflo_type
 15    27 			      init (28)
 15    28 	   )		      fixed bin (8) unal static internal options (constant);
 15    29 
 15    30 /* END INCLUDE FILE  ... picture_image.incl.pl1  */
 14    11 
 14    12 
 14    13 	a = pa;
 14    14 	b = pb;
 14    15 	if equal_types(a,b)|(bit_overlay(a)&bit_overlay(b))|(char_overlay(a)&char_overlay(b))
 14    16 	     then return("1"b);		/* coded this way for efficiency */
 14    17 	     else return("0"b);
 14    18 
 14    19 equal_types: proc(a,b) reducible returns(aligned bit);
 14    20 
 14    21 dcl	(a,b) ptr;
 14    22 
 14    23 
 14    24 	if string(a->symbol.data_type)=string(b->symbol.data_type)
 14    25 	   then if a->symbol.aligned=b->symbol.aligned
 14    26 	   then if a -> symbol.unsigned = b -> symbol.unsigned
 14    27 	   then if a->symbol.varying=b->symbol.varying
 14    28 	   then if a->symbol.binary=b->symbol.binary
 14    29 	   then if a->symbol.real=b->symbol.real
 14    30 	   then if(a->symbol.c_dcl_size=b->symbol.c_dcl_size|^(a->symbol.fixed|a->symbol.float))
 14    31 	   then if a->symbol.scale=b->symbol.scale
 14    32 	   then if a->symbol.picture
 14    33 		then return(a->symbol.general->reference.symbol->symbol.initial->picture_image.chars =
 14    34 				b->symbol.general->reference.symbol->symbol.initial->picture_image.chars);
 14    35 		else return("1"b);
 14    36 	return("0"b);
 14    37 	end; /* equal_types */
 14    38 
 14    39 bit_overlay: proc(a) reducible returns(aligned bit);
 14    40 
 14    41 dcl	(a,p) ptr;
 14    42 
 14    43 	p = a;
 14    44 	do while(p->symbol.structure);
 14    45 	p = p->symbol.son;
 14    46 	end;
 14    47 	return(a->symbol.packed&p->symbol.bit);
 14    48 	end; /* bit_overlay */
 14    49 
 14    50 char_overlay: proc(a) reducible returns(aligned bit);
 14    51 
 14    52 dcl	(a,p) ptr;
 14    53 
 14    54 	p = a;
 14    55 	do while(p->symbol.structure);
 14    56 	p = p->symbol.son;
 14    57 	end;
 14    58 	return(a->symbol.packed&(p->symbol.char|p->symbol.picture));
 14    59 	end; /* char_overlay */
 14    60 
 14    61 	end; /* compare_alias */
 14    62 
 14    63 /* END INCLUDE FILE ... compare_alias.incl.pl1 */
     1092 
     1093 
     1094 
     1095 wipe: proc;
     1096 
     1097 	if substr (erase, 1, 1)
     1098 	then do;
     1099 
     1100 		do i = 1 to a_reg.number;
     1101 		     p = a_reg.variable (i);
     1102 		     call save_temp (1);
     1103 		     p -> reference.value_in.a = "0"b;
     1104 		end;
     1105 
     1106 		a_reg.constant,
     1107 		     a_reg.number = 0;
     1108 	     end;
     1109 
     1110 	if substr (erase, 2, 1)
     1111 	then do;
     1112 
     1113 		do i = 1 to q_reg.number;
     1114 		     p = q_reg.variable (i);
     1115 		     call save_temp (2);
     1116 		     p -> reference.value_in.q = "0"b;
     1117 		end;
     1118 
     1119 		q_reg.constant,
     1120 		     q_reg.number = 0;
     1121 	     end;
     1122 
     1123 	if substr (erase, 3, 1)
     1124 	then do;
     1125 		p = string_reg.variable;
     1126 		if p ^= null
     1127 		then do;
     1128 			call save_temp (3);
     1129 			p -> reference.value_in.string_aq = "0"b;
     1130 			string_reg.variable = null;
     1131 		     end;
     1132 	     end;
     1133 
     1134 	if substr (erase, 4, 1)
     1135 	then do;
     1136 		q = complex_reg.variable;
     1137 		if q ^= null
     1138 		then do;
     1139 			q -> reference.value_in.complex_aq = "0"b;
     1140 			complex_reg.variable = null;
     1141 		     end;
     1142 	     end;
     1143 
     1144 	if substr (erase, 5, 1)
     1145 	then do;
     1146 		q = decimal_reg.variable;
     1147 		if q ^= null
     1148 		then do;
     1149 			q -> reference.value_in.decimal_aq = "0"b;
     1150 			decimal_reg.variable = null;
     1151 		     end;
     1152 	     end;
     1153 
     1154 	do i = 0 to 7;
     1155 	     if substr (erase, i + 6, 1)
     1156 	     then do;
     1157 		     if index_regs (i).type >= 2
     1158 		     then do;
     1159 			     p = index_regs (i).variable;
     1160 			     if p ^= null
     1161 			     then do;
     1162 				     call save_temp (0);
     1163 				     p -> reference.value_in.x (i) = "0"b;
     1164 				end;
     1165 			end;
     1166 
     1167 		     index_regs (i).type = 0;
     1168 		end;
     1169 	end;
     1170 
     1171 	do i = 1 to 6;
     1172 	     if substr (erase, i + 13, 1)
     1173 	     then do;
     1174 		     p = base_regs (i).variable;
     1175 		     n = base_regs (i).type;
     1176 		     if p = null then n = 0;
     1177 
     1178 		     if n = 1
     1179 		     then do;
     1180 			     p -> reference.value_in.b (i) = "0"b;
     1181 			     call save_temp (-i);
     1182 			end;
     1183 		     else if n = 2
     1184 		     then p -> reference.address_in.b (i) = "0"b;
     1185 
     1186 		     base_regs (i).type = 0;
     1187 		end;
     1188 	end;
     1189 
     1190 
     1191      end;
     1192 
     1193 
     1194 save_temp: proc (reg);
     1195 
     1196 	dcl     reg		 fixed bin;
     1197 
     1198 	dcl     ca		 ptr;
     1199 
     1200 	dcl     (macro, t, k)	 fixed bin (15);
     1201 
     1202 	dcl     (stfx1		 init (15),
     1203 	        stfx2		 init (16),
     1204 	        save_string_aq	 init (229),
     1205 	        sxl0		 init (345),
     1206 	        stx0		 init (714),
     1207 	        zero_mac		 init (308),
     1208 	        store_base		 (23:24, 6) init (61, 409, 622, 623, 624, 625, /* unpacked */
     1209 				 630, 631, 632, 633, 634, 635), /* packed */
     1210 	        sta		 init (4)) fixed bin (15) int static;
     1211 
     1212 	if cg_stat$m_s_p = null then return;
     1213 
     1214 	if ^p -> reference.temp_ref then goto exit;
     1215 
     1216 	if p -> reference.ref_count <= 0 then goto exit;
     1217 
     1218 	if p -> reference.value_in.storage then goto exit;
     1219 
     1220 	if p -> reference.symbol = null then goto exit;
     1221 
     1222 	if p -> reference.dont_save then go to exit;
     1223 
     1224 	if p -> reference.aggregate then go to exit;
     1225 
     1226 	t = p -> reference.data_type;
     1227 
     1228 	if reg = 2
     1229 	then do;
     1230 		if t = unpacked_ptr
     1231 		then if string (p -> reference.value_in.b)
     1232 		     then goto exit; else goto save;
     1233 
     1234 		if t = real_fix_bin_1
     1235 		then if p -> reference.symbol -> symbol.c_dcl_size < bits_per_half
     1236 		     then if string (p -> reference.value_in.x)
     1237 			then goto exit;
     1238 	     end;
     1239 
     1240 save:	p -> reference.store_ins = bit (cg_stat$text_pos, 18);
     1241 	p -> reference.ref_count = p -> reference.ref_count + 1;
     1242 
     1243 	if reg < 0
     1244 	then do;
     1245 		macro = store_base (t, abs (reg));
     1246 		goto gen;
     1247 	     end;
     1248 
     1249 	if reg = 3
     1250 	then do;
     1251 		if p -> reference.allocated then go to exit;
     1252 		if ^p -> reference.address_in.storage then go to exit;
     1253 
     1254 		call stack_temp$assign_block (p, 2);
     1255 
     1256 /* we must ensure that saving the string aq does
     1257*		   not alter any registers */
     1258 
     1259 		if string (p -> reference.address_in.b)
     1260 		then do;
     1261 			k = index (string (p -> reference.address_in.b), "1"b) - 1;
     1262 			p -> reference.address_in.storage = "0"b;
     1263 			call expmac ((store_base (23, k)), p);
     1264 			p -> reference.address_in.storage = "1"b;
     1265 		     end;
     1266 		else do;
     1267 			ca = c_a (p -> reference.qualifier -> temporary.location, 4);
     1268 			call expmac$one_eis ((save_string_aq), ca);
     1269 			p -> reference.ref_count = p -> reference.ref_count - 1;
     1270 		     end;
     1271 
     1272 		go to exit;
     1273 	     end;
     1274 
     1275 	if reg = 1
     1276 	then do;
     1277 		if t < char_string then k = 0;
     1278 		else k = fixed (p -> reference.c_length * convert_size (t) > bits_per_word, 1);
     1279 		call expmac$one ((sta), p, k);
     1280 
     1281 		if a_reg.offset ^= 0
     1282 		then do;
     1283 			p -> reference.aligned_ref = "0"b;
     1284 			p -> reference.c_offset = a_reg.offset;
     1285 			p -> reference.units = bit_;
     1286 		     end;
     1287 	     end;
     1288 	else do;
     1289 		if reg = 0
     1290 		then do;
     1291 			if p -> reference.symbol -> symbol.c_dcl_size < bits_per_half
     1292 			then do;
     1293 				macro = stx0 + i;
     1294 
     1295 /* convert the value in index register to "packed"
     1296*			   integer in storage */
     1297 
     1298 				p -> reference.aligned_ref = "0"b;
     1299 				p -> reference.c_offset = 0;
     1300 				p -> reference.c_length = bits_per_half;
     1301 				p -> reference.units = word_;
     1302 
     1303 /* We set reference.dont_save as a
     1304*			   kludge to fix bug 1599.  This
     1305*			   prevents save_value from converting
     1306*			   this back to an aligned temp,
     1307*			   which could cause problems after
     1308*			   an if statement. */
     1309 
     1310 				p -> reference.dont_save = "1"b;
     1311 			     end;
     1312 
     1313 			else do;
     1314 				macro = sxl0 + i;
     1315 				p -> reference.ref_count = p -> reference.ref_count + 1;
     1316 				call expmac ((zero_mac), p);
     1317 			     end;
     1318 		     end;
     1319 		else if t = unpacked_ptr | t = complex_flt_bin_1 then macro = stfx2;
     1320 		else if t = packed_ptr | t = bit_string then macro = stfx1;
     1321 		else macro = stfx1 - 1 + t;
     1322 
     1323 gen:		call expmac (macro, p);
     1324 	     end;
     1325 
     1326 	p -> reference.value_in.storage = "1"b;
     1327 
     1328 exit: end;
     1329 
     1330 need_ref: proc returns (bit (1) aligned);
     1331 
     1332 	dcl     (p1, p2)		 ptr;
     1333 
     1334 	if ^optimize
     1335 	then return ("1"b);
     1336 
     1337 	if p -> reference.temp_ref
     1338 	then do p1 = q repeat (p1 -> element (4)) while (p1 ^= null);
     1339 		p2 = p1 -> element (1);
     1340 
     1341 		if p2 -> node.type = operator_node
     1342 		then do;
     1343 			if substr (p2 -> operator.op_code, 1, 5) = "00111"b /* mod_bit class */
     1344 			then if p2 -> operand (2) = p
     1345 			     then return ("1"b);
     1346 
     1347 			p2 = p2 -> operand (1);
     1348 		     end;
     1349 
     1350 		if p = p2 then return ("1"b);
     1351 	     end;
     1352 
     1353 	return ("0"b);
     1354      end;
     1355 
     1356      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1153.3  state_man.pl1                     >udd>sm>ds>w>ml>state_man.pl1
73           1    07/21/80  1646.3  pl1_tree_areas.incl.pl1           >ldd>incl>pl1_tree_areas.incl.pl1
74           2    10/25/79  1745.8  cgsystem.incl.pl1                 >ldd>incl>cgsystem.incl.pl1
75           3    11/13/79  1115.8  machine_state.incl.pl1            >ldd>incl>machine_state.incl.pl1
76           4    07/21/80  1646.3  reference.incl.pl1                >ldd>incl>reference.incl.pl1
77           5    12/07/83  1801.7  symbol.incl.pl1                   >ldd>incl>symbol.incl.pl1
78           6    07/21/80  1646.3  operator.incl.pl1                 >ldd>incl>operator.incl.pl1
79           7    08/13/81  2311.5  list.incl.pl1                     >ldd>incl>list.incl.pl1
80           8    04/07/83  1735.0  statement.incl.pl1                >ldd>incl>statement.incl.pl1
81           9    08/13/81  2143.5  block.incl.pl1                    >ldd>incl>block.incl.pl1
82          10    07/21/80  1646.3  nodes.incl.pl1                    >ldd>incl>nodes.incl.pl1
83          11    05/03/76  1420.4  data_types.incl.pl1               >ldd>incl>data_types.incl.pl1
84          12    10/25/79  1745.8  boundary.incl.pl1                 >ldd>incl>boundary.incl.pl1
85          13    11/30/78  1327.4  temporary.incl.pl1                >ldd>incl>temporary.incl.pl1
1092        14    11/30/78  1327.5  compare_alias.incl.pl1            >ldd>incl>compare_alias.incl.pl1
14-11       15    06/28/79  1304.8  picture_image.incl.pl1            >ldd>incl>picture_image.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                                      parameter       pointer                  dcl 14-21 in procedure "equal_types" ref 14-19 14-24
                                                                                  14-24 14-24 14-24 14-24 14-24 14-24 14-24 14-24
                                                                                  14-24 14-24 14-24
a                                      parameter       pointer                  dcl 14-52 in procedure "char_overlay" ref 14-50
                                                                                  14-54 14-58
a                        11(09)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 154* 298* 322* 496*
                                                                                  666* 776* 791* 977* 1103*
a                                      parameter       pointer                  dcl 14-41 in procedure "bit_overlay" ref 14-39 14-43
                                                                                  14-47
a                               000206 automatic       pointer                  dcl 14-10 in procedure "compare_alias" set ref
                                                                                  14-13* 14-15* 14-15* 14-15*
a_reg                     3            based           structure                level 2 dcl 3-6
abs                                                    builtin function         dcl 71 ref 614 710 930 1245
address_in               11            based           structure                level 3 packed packed unaligned dcl 4-3
aggregate                12(19)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 1224
aliasable                12(16)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 1078
                                                                                  1086
aligned                  31(21)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
aligned_ref              12(07)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 set ref
                                                                                  1283* 1298*
all                             000123 automatic       bit(1)                   dcl 954 set ref 957* 1078
allocated                12(15)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 1251
attributes               31            based           structure                level 2 dcl 5-3
b                        11            based           bit(1)                   array level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 184* 465* 527* 644*
                                                                                  1183* 1259 1261
b                                      parameter       pointer                  dcl 14-21 in procedure "equal_types" ref 14-19 14-24
                                                                                  14-24 14-24 14-24 14-24 14-24 14-24 14-24 14-24
b                               000210 automatic       pointer                  dcl 14-10 in procedure "compare_alias" set ref
                                                                                  14-14* 14-15* 14-15* 14-15*
b                        11(15)        based           bit(1)                   array level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 182* 464* 526* 727*
                                                                                  1045* 1180* 1230
b19                             000106 automatic       bit(19)                  dcl 54 set ref 885* 903* 1059
base_regs               160            based           structure                array level 2 dcl 3-6
bin                                                    builtin function         dcl 71 ref 1071 1071
binary                   31(29)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
bit                                                    builtin function         dcl 71 in procedure "state_man$create_ms" ref 1240
bit                      31(03)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "state_man$create_ms" ref 14-47
bit_                                   constant        fixed bin(3,0)           initial dcl 12-5 ref 1285
bit_string                             constant        fixed bin(15,0)          initial dcl 11-1 ref 780 1320
bits                     12(06)        based           structure                level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms"
bits                     13            based           structure                level 2 in structure "statement" packed packed
                                                                                  unaligned dcl 8-9 in procedure
                                                                                  "state_man$create_ms"
bits_per_half                          constant        fixed bin(8,0)           initial dcl 2-5 ref 1059 1234 1291 1300
bits_per_two_words              005502 constant        fixed bin(8,0)           initial dcl 2-5 ref 783 784
bits_per_word                          constant        fixed bin(8,0)           initial dcl 2-5 ref 784 785 862 865 1278
block                                  based           structure                level 1 dcl 9-5
block_node                4            based           pointer                  level 2 packed packed unaligned dcl 5-3 ref 1083
                                                                                  1083
c_a                             000022 constant        entry                    external dcl 65 ref 1267
c_dcl_size               30            based           fixed bin(24,0)          level 2 dcl 5-3 ref 1059 14-24 14-24 1234 1291
c_length                  2            based           fixed bin(24,0)          level 2 dcl 4-3 set ref 765 782 1278 1300*
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 4-3 set ref 783 1284* 1299*
ca                              000256 automatic       pointer                  dcl 1198 set ref 1267* 1268*
cg_stat$last_call               000016 external static fixed bin(18,0)          dcl 61 set ref 116* 203* 559* 913*
cg_stat$m_s_p                   000012 external static pointer                  dcl 61 set ref 137 200* 266* 270* 539* 1212
cg_stat$ms_list                 000010 external static pointer                  dcl 61 set ref 485 486* 537 538* 1066 1067*
cg_stat$text_pos                000014 external static fixed bin(18,0)          dcl 61 ref 116 203 559 913 925 1240
cg_static_$m_s_p                000036 external static pointer                  dcl 3-3 ref 3-3
changed                  50            based           fixed bin(18,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
changed                  22            based           fixed bin(18,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
char                     31(04)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-58
char_string                            constant        fixed bin(15,0)          initial dcl 11-1 ref 780 1277
chars                     2            based           char                     level 2 dcl 15-6 ref 14-24 14-24
compiler_developed       32(35)        based           structure                level 3 packed packed unaligned dcl 5-3
complex_aq               11(13)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 set ref 192*
                                                                                  404* 508* 698* 748* 751* 1015* 1139*
complex_flt_bin_1                      constant        fixed bin(15,0)          initial dcl 11-1 ref 1319
complex_flt_bin_2                      constant        fixed bin(15,0)          initial dcl 11-1 ref 742
complex_reg              62            based           structure                level 2 dcl 3-6
cond                                   parameter       bit(1)                   dcl 125 ref 120 132
conditional                     000120 automatic       bit(1)                   dcl 127 set ref 132* 134 154 160 170 182 184 188
constant                 47            based           fixed bin(24,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  353 353 499 1119*
constant                 71            based           fixed bin(17,0)          array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 447 447
                                                                                  514
constant                161            based           fixed bin(17,0)          array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 476 476
constant                 21            based           fixed bin(24,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  307 307 494 1106*
convert_offset                  000014 constant        fixed bin(8,1)           initial array dcl 2-35 ref 783
convert_size                    000022 constant        fixed bin(8,0)           initial array dcl 2-5 ref 782 1278
data_type                31            based           structure                level 3 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "state_man$create_ms" ref 14-24 14-24
data_type                12            based           fixed bin(5,0)           level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" ref 740 742 779 838 894 1056
                                                                                  1226
decimal_aq               11(14)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 set ref 198*
                                                                                  418* 511* 705* 1023* 1149*
decimal_reg              65            based           structure                level 2 dcl 3-6
dont_save                12(21)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 set ref 1222
                                                                                  1310*
element                   1            based           pointer                  array level 2 packed packed unaligned dcl 7-6 ref
                                                                                  1339 1351
erase                           000105 automatic       bit(19)                  dcl 54 set ref 252* 254* 277 290 294* 338 342* 384
                                                                                  388* 397 401* 411 415* 427 432* 453 458* 489 492
                                                                                  551* 556* 825* 827 840* 855 862* 883* 910 1059*
                                                                                  1059 1097 1110 1123 1134 1144 1155 1172
expmac                          000024 constant        entry                    external dcl 65 ref 1263 1316 1323
expmac$one                      000026 constant        entry                    external dcl 65 ref 1279
expmac$one_eis                  000030 constant        entry                    external dcl 65 ref 1268
fixed                                                  builtin function         dcl 71 in procedure "state_man$create_ms" ref 1278
fixed                    31(01)        based           bit(1)                   level 4 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "state_man$create_ms" ref 14-24
float                    31(02)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
flush_at_call            24(24)        based           bit(1)                   level 2 packed packed unaligned dcl 9-5 ref 1083
found                           000110 automatic       bit(1)                   dcl 54 set ref 891* 892 896* 901
general                  16            based           pointer                  level 2 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
i                               000112 automatic       fixed bin(17,0)          dcl 54 set ref 95* 96 97 98* 151* 152* 157* 158*
                                                                                  163* 164 166 170* 175* 176 177 181 182 184* 220*
                                                                                  221* 225* 226* 230* 231 233* 238* 239 240 240*
                                                                                  310* 310* 312 326 328* 356* 356* 358 372 374* 425*
                                                                                  427 429 430 432 434 436 437 443 443 447 447* 451*
                                                                                  453 455 456 458 460 462 464 465 472 472 476 476*
                                                                                  494* 496* 499* 501* 513* 514 514 517 518* 522* 523
                                                                                  524 526 527* 579* 580 584* 584* 585 585* 593* 594
                                                                                  598* 598* 599 599* 612* 613 614 617 618* 622* 623
                                                                                  623 623* 638* 639 639 639* 662* 663 664 666 668
                                                                                  672* 672 675* 676 677 679 681 685* 685 709* 710
                                                                                  712 715 716* 721* 722 724 727 728* 775* 776* 797*
                                                                                  798* 886* 887* 892* 893* 904* 905* 927* 928 930
                                                                                  930 930 932 933* 937* 938 940 941* 972* 973 974
                                                                                  979 983* 983 988* 989 990 995 999* 999 1027* 1028
                                                                                  1030 1033 1034* 1039* 1040 1042 1045 1046* 1100*
                                                                                  1101* 1113* 1114* 1154* 1155 1157 1159 1163 1167*
                                                                                  1171* 1172 1174 1175 1180 1181 1183 1186* 1293
                                                                                  1314
index                                                  builtin function         dcl 71 ref 1261
index_regs               70            based           structure                array level 2 dcl 3-6
indicators                1            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 101* 277* 282 282 282* 284
                                                                                  284* 287* 547* 569 569* 572* 656 656* 659* 959
                                                                                  962* 966*
indicators_ref          420            based           pointer                  array level 2 packed packed unaligned dcl 3-6 set
                                                                                  ref 284 284 287 287 569 572 656 659 961 965
info                     11            based           structure                level 2 packed packed unaligned dcl 4-3
initial                  11            based           pointer                  level 2 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
instruction              23            based           bit(36)                  level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 111*
instruction              51            based           bit(36)                  level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 111*
j                               000113 automatic       fixed bin(17,0)          dcl 54 set ref 296* 297* 314* 315 317* 328* 329 329*
                                                                                  344* 345* 360* 361 363* 374* 375 375* 668* 669
                                                                                  669* 681* 682 682* 979* 980 980* 995* 996 996*
k                               000262 automatic       fixed bin(15,0)          dcl 1200 set ref 1261* 1263 1277* 1278* 1279*
length                   17            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 305 305
                                                                                  784* 785* 865* 865
length                   45            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 351 351
list                                   based           structure                level 1 dcl 7-6
location                  4            based           fixed bin(18,0)          level 2 dcl 13-3 set ref 1267*
locked                   24            based           bit(1)                   level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 111*
                                                                                  922*
locked                  203            based           fixed bin(2,0)           array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 98* 938
                                                                                  940*
locked                   52            based           bit(1)                   level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 111*
                                                                                  922*
long_ref                 12(08)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 756
m_s_p                           000116 automatic       pointer                  initial dcl 3-3 set ref 88 90 90 90 90 96 97 98 101
                                                                                  101 101 101 101 101 101 101 101 111 111 111 111
                                                                                  137 140 141 151 152 157 158 164 166 176 177 191
                                                                                  194 197 220 221 225 226 231 233 239 240 258 266
                                                                                  270* 271 277 282 282 284 284 284 287 287 292 305
                                                                                  306 307 309 312 329 329 336 340 351 352 353 355
                                                                                  358 375 375 382 386 395 399 408 409 413 422 423
                                                                                  429 443 447 455 472 476 494 494 496 499 499 501
                                                                                  504 507 510 514 514 517 523 524 537 538 547 569
                                                                                  569 569 572 572 578 580 582 585 585 592 594 596
                                                                                  599 599 606 606 608 608 610 610 613 614 617 618
                                                                                  623 623 623 639 639 639 656 656 656 659 659 663
                                                                                  664 666 667 667 668 669 669 676 677 679 680 680
                                                                                  681 682 682 688 688 691 692 695 695 698 699 702
                                                                                  702 705 706 710 712 716 722 724 728 747 750 761
                                                                                  764 765 775 776 782 783 784 784 784 785 787 787
                                                                                  789 790 797 798 801 802 834 837 862 862 862 865
                                                                                  865 886 887 892 893 904 905 922 922 923 923 928
                                                                                  930 930 930 932 933 938 940 941 959 961 962 965
                                                                                  966 971 974 980 980 985 987 990 996 996 1001 1003
                                                                                  1008 1011 1016 1019 1024 1028 1030 1034 1040 1042
                                                                                  1046 3-3* 1066* 1067 1067 1069* 1070 1100 1101
                                                                                  1106 1106 1113 1114 1119 1119 1125 1130 1136 1140
                                                                                  1146 1150 1157 1159 1167 1174 1175 1186 1281 1284
machine_state                          based           structure                level 1 dcl 3-6 set ref 137* 137 1069
machine_state_node                     constant        bit(9)                   initial dcl 10-5 ref 1070 1071 1071
macro                           000260 automatic       fixed bin(15,0)          dcl 1200 set ref 1245* 1293* 1314* 1319* 1320* 1321*
                                                                                  1323*
min                                                    builtin function         dcl 71 ref 617 865
misc_attributes          31(19)        based           structure                level 3 packed packed unaligned dcl 5-3
mod                                                    builtin function         dcl 71 ref 783
n                               000114 automatic       fixed bin(17,0)          dcl 54 set ref 177* 178* 179 184 309* 310 324* 324
                                                                                  325 326 328 336 355* 356 370* 370 371 372 374 382
                                                                                  429* 430 443 455* 456 462* 463* 464 465 470 472
                                                                                  476 524* 525* 526 527 578* 579 582 584 592* 593
                                                                                  596 598 613* 614 617 779* 780 780 782 838* 840 840
                                                                                  840 840 894* 896 896 896 896 971* 973 978* 978 979
                                                                                  985 987* 989 994* 994 995 1001 1175* 1176* 1178
                                                                                  1183
next                      2            based           pointer                  level 2 packed packed unaligned dcl 3-6 set ref 90*
                                                                                  140* 271 483 485* 537* 1067
node                                   based           structure                level 1 dcl 10-27
null                                                   builtin function         dcl 71 ref 90 167 178 192 195 198 200 234 240 258
                                                                                  263 280 298 317 346 363 391 404 418 437 463 505
                                                                                  508 511 518 525 539 606 608 610 618 688 692 695
                                                                                  699 702 706 748 762 930 957 1004 1008 1012 1016
                                                                                  1020 1024 1067 1083 1126 1130 1137 1140 1147 1150
                                                                                  1160 1176 1212 1220 1337
number                   43            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  157 225 344 355 360 382* 499 592 596* 676 680* 680
                                                                                  681 797 801* 834 892 904 987 1001* 1113 1119*
number                   15            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  151 220 296 309 314 336* 494 578 582* 663 667* 667
                                                                                  668 775 789* 862 886 971 985* 1100 1106*
number_h_o               53            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  923*
number_h_o               25            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 101*
                                                                                  923*
offset                   20            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 306 306
                                                                                  783* 784 787* 862 1281 1284
offset                   46            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 352 352
op_code                   0(09)        based           bit(9)                   level 2 packed packed unaligned dcl 6-6 ref 1343
operand                   1            based           pointer                  array level 2 packed packed unaligned dcl 6-6 ref
                                                                                  1343 1347
operator                               based           structure                level 1 dcl 6-6
operator_node                          constant        bit(9)                   initial dcl 10-5 ref 1341
optimize                        000121 automatic       bit(1)                   dcl 127 set ref 130* 217* 1334
p                               000100 automatic       pointer                  dcl 54 in procedure "state_man$create_ms" set ref
                                                                                  129* 130 140 141 142 142 144 152* 154 158* 160
                                                                                  166* 167 170 176* 178 182 184 191* 192 192 194*
                                                                                  195 195 197* 198 198 216* 217 218 221* 226* 233*
                                                                                  234 239* 240 256* 263 270 271* 280 282 284 287 292
                                                                                  296 297 305 306 307 314 315 317 340 344 345 351
                                                                                  352 353 360 361 363 386 390 395 399 403 408 409
                                                                                  413 417 422 423 430 434 436 443 447 456 460 462
                                                                                  472 476 482 483* 483 567* 569 572 580 594 606 608
                                                                                  610 614 623 628 636* 639 644 739* 740 742 750 751
                                                                                  756 764 765 766 768 779 782 783 783 790 791 802
                                                                                  803 811* 837* 838 887* 888 893* 894 905* 906 956*
                                                                                  957 1056 1057 1058 1059 1078 1086 1101* 1103 1114*
                                                                                  1116 1125* 1126 1129 1159* 1160 1163 1174* 1176
                                                                                  1180 1183 1214 1216 1218 1220 1222 1224 1226 1230
                                                                                  1234 1234 1240 1241 1241 1251 1252 1254* 1259 1261
                                                                                  1262 1263* 1264 1267 1269 1269 1278 1279* 1283
                                                                                  1284 1285 1291 1298 1299 1300 1301 1310 1315 1315
                                                                                  1316* 1323* 1326 1337 1343 1350
p                               000236 automatic       pointer                  dcl 14-52 in procedure "char_overlay" set ref 14-54*
                                                                                  14-55 14-56* 14-56 14-58 14-58
p                               000226 automatic       pointer                  dcl 14-41 in procedure "bit_overlay" set ref 14-43*
                                                                                  14-44 14-45* 14-45 14-47
p1                              000272 automatic       pointer                  dcl 1332 set ref 1337* 1337* 1339* 1351
p2                              000274 automatic       pointer                  dcl 1332 set ref 1339* 1341 1343 1343 1347* 1347
                                                                                  1350
pa                                     parameter       pointer                  dcl 14-10 ref 14-8 14-13
packed                   33            based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-47
                                                                                  14-58
packed_ptr                             constant        fixed bin(15,0)          initial dcl 11-1 ref 1320
pb                                     parameter       pointer                  dcl 14-10 ref 14-8 14-14
piclength                 0(27)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 15-6 ref 14-24
                                                                                  14-24
picture                  31(18)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-58
picture_image                          based           structure                level 1 dcl 15-6
pl1_stat_$node_uses             000020 external static fixed bin(17,0)          array dcl 61 set ref 1071* 1071
pl1_stat_$xeq_tree_area_ptr     000034 external static pointer                  dcl 1-7 ref 1069
prev_state                      000107 automatic       bit(1)                   dcl 54 set ref 272* 275* 492
pt                                     parameter       pointer                  dcl 52 set ref 50 88* 120 129 207 216 247 252 256
                                                                                  562 567 631 636 647 654 735 739 807 811 947 956
q                               000102 automatic       pointer                  dcl 54 in procedure "state_man$create_ms" set ref
                                                                                  144* 218* 297* 298 298 312* 315 322 345* 346 346
                                                                                  358* 361 368 390* 391 391 403* 404 404 417* 418
                                                                                  418 436* 437 437 460* 463 464 465 482* 485 486
                                                                                  504* 505 505 507* 508 508 510* 511 511 517* 518
                                                                                  518 523* 525 526 527 712* 713 715 724* 725 727
                                                                                  747* 748 748 761* 762 762 961* 965* 974* 977 990*
                                                                                  993 1003* 1004 1007 1011* 1012 1015 1019* 1020
                                                                                  1023 1030* 1033 1042* 1045 1078 1078 1078 1083
                                                                                  1083 1086 1086 1136* 1137 1139 1146* 1147 1149
                                                                                  1337
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 160* 346* 368* 501*
                                                                                  679* 798* 803* 993* 1116*
q_reg                    31            based           structure                level 2 dcl 3-6
qualifier                 4            based           pointer                  level 2 packed packed unaligned dcl 4-3 ref 1267
real                     31(30)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
real_fix_bin_1                         constant        fixed bin(15,0)          initial dcl 11-1 ref 1056 1234
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 11-1 ref 840 896
real_flt_bin_1                         constant        fixed bin(15,0)          initial dcl 11-1 ref 840 896
real_flt_bin_2                         constant        fixed bin(15,0)          initial dcl 11-1 ref 740 840 896
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-3 set ref 1058
                                                                                  1216 1241* 1241 1269* 1269 1315* 1315
reference                              based           structure                level 1 dcl 4-3
reference_count           7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 8-9 set ref 142*
                                                                                  142 252
reference_list            5            based           pointer                  level 2 packed packed unaligned dcl 8-9 ref 144 218
reg                                    parameter       fixed bin(17,0)          dcl 1196 ref 1194 1228 1243 1245 1249 1275 1289
save_string_aq                         constant        fixed bin(15,0)          initial dcl 1202 ref 1268
save_temps               13(07)        based           bit(1)                   level 3 packed packed unaligned dcl 8-9 ref 130 217
scale                    64            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 408 408
scale                    67            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 422 422
scale                     2(28)        based           fixed bin(7,0)           level 2 in structure "symbol" packed packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "state_man$create_ms" ref 14-24 14-24
shared                    0(11)        based           bit(1)                   level 2 packed packed unaligned dcl 4-3 ref 1078
size                     63            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 399 399
size                     66            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 413 413
size                     16            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 292 292
                                                                                  782* 784 787* 862
size                     44            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 340 340
size                     60            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 386 386
                                                                                  765*
son                      21            based           pointer                  level 2 packed packed unaligned dcl 5-3 ref 14-45
                                                                                  14-56
sta                                    constant        fixed bin(15,0)          initial dcl 1202 ref 1279
stack_temp$assign_block         000032 constant        entry                    external dcl 65 ref 1254
state_list                6            based           pointer                  level 2 packed packed unaligned dcl 8-9 set ref 140
                                                                                  141* 256
statement                              based           structure                level 1 dcl 8-9
stfx1                                  constant        fixed bin(15,0)          initial dcl 1202 ref 1320 1321
stfx2                                  constant        fixed bin(15,0)          initial dcl 1202 ref 1319
storage                  11(08)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 768* 1252 1262*
                                                                                  1264*
storage                  11(23)        based           bit(1)                   level 4 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" set ref 1057 1218 1326*
store_base                      000000 constant        fixed bin(15,0)          initial array dcl 1202 ref 1245 1263
store_ins                13(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-3 set ref
                                                                                  1240*
string                                                 builtin function         dcl 71 set ref 628* 644* 14-24 14-24 1230 1234 1259
                                                                                  1261
string_aq                11(12)        based           bit(1)                   level 4 packed packed unaligned dcl 4-3 set ref 195*
                                                                                  391* 505* 691* 762* 766* 1007* 1129*
string_reg               57            based           structure                level 2 dcl 3-6
structure                31            based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-44
                                                                                  14-55
stx0                                   constant        fixed bin(15,0)          initial dcl 1202 ref 1293
substr                                                 builtin function         dcl 71 set ref 290 294* 338 342* 384 388* 397 401*
                                                                                  411 415* 427 432* 453 458* 472 476 814 815 827
                                                                                  840* 855 862* 1097 1110 1123 1134 1144 1155 1172
                                                                                  1343
sxl0                                   constant        fixed bin(15,0)          initial dcl 1202 ref 1314
sym                             000104 automatic       pointer                  packed unaligned dcl 54 set ref 654* 656 659 664 677
                                                                                  688 695 702 713 725
symbol                    3            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "state_man$create_ms" ref 656 659 664 677 688 695
                                                                                  702 713 725 1059 1083 1083 1086 1086 14-24 14-24
                                                                                  1220 1234 1291
symbol                                 based           structure                level 1 dcl 5-3 in procedure "state_man$create_ms"
t                               000261 automatic       fixed bin(15,0)          dcl 1200 set ref 1226* 1230 1234 1245 1277 1278 1319
                                                                                  1319 1320 1320 1321
temp_ref                 12(11)        based           bit(1)                   level 3 packed packed unaligned dcl 4-3 ref 888 906
                                                                                  1214 1337
temporary                              based           structure                level 1 unaligned dcl 13-3
text_pos                        000111 automatic       fixed bin(18,0)          dcl 54 set ref 925* 933 941
type                                   based           bit(9)                   level 2 in structure "node" packed packed unaligned
                                                                                  dcl 10-27 in procedure "state_man$create_ms" set
                                                                                  ref 1070* 1341
type                     72            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 96* 164
                                                                                  231 429 430 434 514 613 617* 710 716* 928 930* 930
                                                                                  932* 1028 1034* 1157 1167*
type                    162            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 97* 177
                                                                                  240 455 456 462 524 623 623* 639 639* 722 728*
                                                                                  1040 1046* 1175 1186*
units                     0(14)        based           fixed bin(3,0)           level 2 packed packed unaligned dcl 4-3 set ref 783
                                                                                  1285* 1301*
unpacked_ptr                           constant        fixed bin(15,0)          initial dcl 11-1 ref 840 896 1230 1319
unsigned                 31(24)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
update                          000122 automatic       bit(19)                  dcl 809 set ref 812* 814 815
used                     73            based           fixed bin(18,0)          array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 933*
used                    200            based           fixed bin(18,0)          array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "state_man$create_ms" set ref 941*
value_in                 11(09)        based           structure                level 3 packed packed unaligned dcl 4-3 set ref 628*
variable                160            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 176 239 460 472 472
                                                                                  523 623 639 724 1042 1174
variable                 31            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 158 226 345 358 361
                                                                                  363* 375* 375 501 594 599* 599 677 679 682* 682
                                                                                  798 802* 837 893 905 990 996* 996 1114
variable                  3            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 152 221 297 312 315
                                                                                  317* 329* 329 496 580 585* 585 664 666 669* 669
                                                                                  776 790* 887 974 980* 980 1101
variable                 70            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  packed unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 166 233 436 443 443
                                                                                  517 614 618* 712 930 1030 1159
variable                 65            based           pointer                  level 3 in structure "machine_state" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 90* 197 417 423 423
                                                                                  510 610 610* 702 702 705 706* 1019 1024* 1146
                                                                                  1150*
variable                 62            based           pointer                  level 3 in structure "machine_state" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 90* 191 403 409 409
                                                                                  507 608 608* 695 695 698 699* 747 750* 1011 1016*
                                                                                  1136 1140*
variable                 57            based           pointer                  level 3 in structure "machine_state" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "state_man$create_ms" set ref 90* 194 390 395 395
                                                                                  504 606 606* 688 688 691 692* 761 764* 1003 1008*
                                                                                  1125 1130*
varying                  31(26)        based           bit(1)                   level 4 packed packed unaligned dcl 5-3 ref 14-24
                                                                                  14-24
what                                   parameter       bit(19)                  dcl 823 ref 819 825
which                                  parameter       bit(19)                  dcl 809 ref 807 812
word_                                  constant        fixed bin(3,0)           initial dcl 12-5 ref 1301
x                        11(25)        based           bit(1)                   array level 4 packed packed unaligned dcl 4-3 set
                                                                                  ref 170* 437* 518* 715* 1033* 1163* 1234
xeq_tree_area                          based           area(1024)               dcl 1-5 ref 1069
zero_mac                               constant        fixed bin(15,0)          initial dcl 1202 ref 1316

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
array_node                             internal static bit(9)                   initial dcl 10-5
bits_per_char                          internal static fixed bin(8,0)           initial dcl 2-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 2-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 2-35
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 2-5
block_node                             internal static bit(9)                   initial dcl 10-5
bound_node                             internal static bit(9)                   initial dcl 10-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 2-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 2-5
by_name_agg_node                       internal static bit(9)                   initial dcl 10-5
character_                             internal static fixed bin(3,0)           initial dcl 12-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 2-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 11-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 11-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 11-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 11-1
context_node                           internal static bit(9)                   initial dcl 10-5
cross_reference_node                   internal static bit(9)                   initial dcl 10-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 2-5
default_node                           internal static bit(9)                   initial dcl 10-5
digit_                                 internal static fixed bin(3,0)           initial dcl 12-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 11-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 11-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 11-1
format_value_node                      internal static bit(9)                   initial dcl 10-5
half_                                  internal static fixed bin(3,0)           initial dcl 12-5
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 3-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 3-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 3-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 3-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 3-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 3-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 3-68
int_entry                              internal static fixed bin(15,0)          initial dcl 11-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 11-1
label_array_element_node               internal static bit(9)                   initial dcl 10-5
label_constant                         internal static fixed bin(15,0)          initial dcl 11-1
label_node                             internal static bit(9)                   initial dcl 10-5
label_size                             internal static fixed bin(8,0)           initial dcl 2-5
label_variable                         internal static fixed bin(15,0)          initial dcl 11-1
list_node                              internal static bit(9)                   initial dcl 10-5
local_label_variable                   internal static fixed bin(15,0)          initial dcl 11-1
max_block_number                       internal static fixed bin(17,0)          initial dcl 9-74
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 2-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 2-5
max_list_elements                      internal static fixed bin(17,0)          initial dcl 7-12
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 6-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 2-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 2-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 2-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 2-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 12-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 12-5
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 2-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 2-5
picture_char_type                      internal static fixed bin(8,0)           initial packed unaligned dcl 15-20
picture_complexfix_type                internal static fixed bin(8,0)           initial packed unaligned dcl 15-20
picture_complexflo_type                internal static fixed bin(8,0)           initial packed unaligned dcl 15-20
picture_realfix_type                   internal static fixed bin(8,0)           initial packed unaligned dcl 15-20
picture_realflo_type                   internal static fixed bin(8,0)           initial packed unaligned dcl 15-20
pl1_stat_$tree_area_ptr                external static pointer                  dcl 1-7
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 11-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 11-1
reference_node                         internal static bit(9)                   initial dcl 10-5
sf_par_node                            internal static bit(9)                   initial dcl 10-5
source_node                            internal static bit(9)                   initial dcl 10-5
statement_node                         internal static bit(9)                   initial dcl 10-5
symbol_node                            internal static bit(9)                   initial dcl 10-5
temporary_node                         internal static bit(9)                   initial dcl 10-5
token_node                             internal static bit(9)                   initial dcl 10-5
tree_area                              based           area(1024)               dcl 1-4
units_per_word                         internal static fixed bin(8,0)           initial array dcl 2-5

NAMES DECLARED BY EXPLICIT CONTEXT.
back                            004012 constant        label                    dcl 1062 ref 1056 1057 1058
bit_overlay                     004343 constant        entry                    internal dcl 14-39 ref 14-15 14-15
char_overlay                    004373 constant        entry                    internal dcl 14-50 ref 14-15 14-15
check_temp                      003765 constant        entry                    internal dcl 1054 ref 888 906
chk_base                        001460 constant        label                    dcl 451
chk_cx                          001306 constant        label                    dcl 397 ref 392
chk_d                           001340 constant        label                    dcl 411 ref 405
chk_q                           001117 constant        label                    dcl 338 ref 302
chk_sr                          001257 constant        label                    dcl 384 ref 348
chk_xr                          001372 constant        label                    dcl 425 ref 419
compare_alias                   004127 constant        entry                    internal dcl 14-8 ref 1086
compare_aliasables              004047 constant        entry                    internal dcl 1076 ref 962 966 975 991 1004 1012 1020
                                                                                  1031 1043
end_a                           001114 constant        label                    dcl 336 ref 326
end_base                        001570 constant        label                    dcl 480 ref 467 470
end_q                           001254 constant        label                    dcl 382 ref 372
end_xr                          001456 constant        label                    dcl 449 ref 440
equal_types                     004177 constant        entry                    internal dcl 14-19 ref 14-15
erase_a                         000766 constant        label                    dcl 294 ref 305 306 307 325
erase_base                      001504 constant        label                    dcl 458 ref 472 476
erase_cx                        001316 constant        label                    dcl 401 ref 408 409
erase_d                         001350 constant        label                    dcl 415 ref 422 423
erase_q                         001127 constant        label                    dcl 342 ref 351 352 353 371
erase_sr                        001267 constant        label                    dcl 388 ref 395
erase_xr                        001416 constant        label                    dcl 432 ref 443 447
exit                            005332 constant        label                    dcl 1328 ref 1214 1216 1218 1220 1222 1224 1230 1234
                                                                                  1251 1252 1272
frq                             002146 constant        label                    dcl 592 ref 588
frsr                            002210 constant        label                    dcl 606 ref 602
gen                             005316 constant        label                    dcl 1323 ref 1246
get_ms                          004013 constant        entry                    internal dcl 1064 ref 87 136 265
init                            000060 constant        label                    dcl 90 ref 267
init1                           000104 constant        label                    dcl 101
need_ref                        005333 constant        entry                    internal dcl 1330 ref 153 159 169 181 222 227 234
                                                                                  240
ok_a                            001112 constant        label                    dcl 334 ref 318
ok_q                            001252 constant        label                    dcl 380 ref 364
save                            005012 constant        label                    dcl 1240 ref 1232
save_temp                       004726 constant        entry                    internal dcl 1194 ref 153 159 169 181 222 227 234
                                                                                  240 1102 1115 1128 1162 1181
scan_a                          001035 constant        label                    dcl 312 ref 332
scan_q                          001175 constant        label                    dcl 358 ref 378
scrub_a                         000770 constant        label                    dcl 296 ref 290
scrub_base                      001511 constant        label                    dcl 460 ref 453
scrub_cx                        001320 constant        label                    dcl 403 ref 397
scrub_d                         001352 constant        label                    dcl 417 ref 411
scrub_q                         001131 constant        label                    dcl 344 ref 338
scrub_sr                        001271 constant        label                    dcl 390 ref 384
scrub_xr                        001423 constant        label                    dcl 434 ref 427
state_man$create_ms             000046 constant        entry                    external dcl 50
state_man$discard_ms            002007 constant        entry                    external dcl 532
state_man$erase_reg             003106 constant        entry                    external dcl 819
state_man$erase_temps           003174 constant        entry                    external dcl 872
state_man$flush                 002027 constant        entry                    external dcl 543
state_man$flush_address         002321 constant        entry                    external dcl 631
state_man$flush_ref             002053 constant        entry                    external dcl 562
state_man$flush_sym             002365 constant        entry                    external dcl 647
state_man$merge_ms              000653 constant        entry                    external dcl 247
state_man$save_ms               000132 constant        entry                    external dcl 120
state_man$save_regs             000461 constant        entry                    external dcl 207
state_man$set_aliasables        003413 constant        entry                    external dcl 947
state_man$unlock                003321 constant        entry                    external dcl 918
state_man$update_ref            002647 constant        entry                    external dcl 735
state_man$update_reg            003057 constant        entry                    external dcl 807
up_a                            002733 constant        label                    dcl 775 ref 814
up_q                            003025 constant        label                    dcl 797 ref 740 815
wipe                            004430 constant        entry                    internal dcl 1095 ref 489 552 557 851 869 912

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6172        6232    5507        6202
Length      6742    5507        40         474     463           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
state_man$create_ms                 228 external procedure  is an external procedure.  
check_temp                              internal procedure  shares stack frame of external procedure state_man$create_ms.  
get_ms                                  internal procedure  shares stack frame of external procedure state_man$create_ms.  
compare_aliasables                      internal procedure  shares stack frame of external procedure state_man$create_ms.  
compare_alias                           internal procedure  shares stack frame of external procedure state_man$create_ms.  
equal_types                             internal procedure  shares stack frame of external procedure state_man$create_ms.  
bit_overlay                             internal procedure  shares stack frame of external procedure state_man$create_ms.  
char_overlay                            internal procedure  shares stack frame of external procedure state_man$create_ms.  
wipe                                    internal procedure  shares stack frame of external procedure state_man$create_ms.  
save_temp                               internal procedure  shares stack frame of external procedure state_man$create_ms.  
need_ref                                internal procedure  shares stack frame of external procedure state_man$create_ms.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
state_man$create_ms      000100 p                           state_man$create_ms
                         000102 q                           state_man$create_ms
                         000104 sym                         state_man$create_ms
                         000105 erase                       state_man$create_ms
                         000106 b19                         state_man$create_ms
                         000107 prev_state                  state_man$create_ms
                         000110 found                       state_man$create_ms
                         000111 text_pos                    state_man$create_ms
                         000112 i                           state_man$create_ms
                         000113 j                           state_man$create_ms
                         000114 n                           state_man$create_ms
                         000116 m_s_p                       state_man$create_ms
                         000120 conditional                 state_man$create_ms
                         000121 optimize                    state_man$create_ms
                         000122 update                      state_man$create_ms
                         000123 all                         state_man$create_ms
                         000206 a                           compare_alias
                         000210 b                           compare_alias
                         000226 p                           bit_overlay
                         000236 p                           char_overlay
                         000256 ca                          save_temp
                         000260 macro                       save_temp
                         000261 t                           save_temp
                         000262 k                           save_temp
                         000272 p1                          need_ref
                         000274 p2                          need_ref

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              unpk_to_pk          call_ext_out        return_mac          ext_entry
trunc_fx1           index_bs_1_eis      scaled_mod_fx1      op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
c_a                           expmac                        expmac$one                    expmac$one_eis
stack_temp$assign_block

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$last_call             cg_stat$m_s_p                 cg_stat$ms_list               cg_stat$text_pos
cg_static_$m_s_p              pl1_stat_$node_uses           pl1_stat_$xeq_tree_area_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3    3 000035        50 000043        87 000054        88 000055        90 000060        95 000066        96 000073
     97 000076        98 000101        99 000102       101 000104       111 000116       116 000122       118 000125
    120 000126       129 000140       130 000144       132 000151       134 000154       136 000155       137 000156
    140 000165       141 000171       142 000172       144 000177       151 000201       152 000211       153 000214
    154 000225       155 000232       157 000234       158 000245       159 000250       160 000261       161 000266
    163 000270       164 000275       166 000303       167 000306       169 000312       170 000322       173 000331
    175 000333       176 000341       177 000345       178 000350       179 000355       181 000360       182 000371
    183 000400       184 000401       186 000411       188 000413       191 000415       192 000420       194 000426
    195 000431       197 000437       198 000442       200 000450       203 000453       205 000456       207 000457
    216 000467       217 000473       218 000500       220 000502       221 000513       222 000516       223 000527
    225 000531       226 000541       227 000544       228 000555       230 000557       231 000563       233 000571
    234 000574       236 000610       238 000612       239 000617       240 000623       243 000646       245 000650
    247 000651       252 000661       254 000671       256 000673       258 000675       263 000701       265 000705
    266 000706       267 000711       270 000712       271 000715       272 000720       273 000721       275 000722
    277 000724       280 000731       282 000736       284 000745       287 000754       290 000760       292 000763
    294 000766       296 000770       297 001001       298 001004       299 001012       302 001014       305 001015
    306 001020       307 001023       309 001026       310 001030       312 001035       314 001041       315 001051
    317 001057       318 001061       320 001062       322 001064       324 001067       325 001071       326 001073
    328 001075       329 001103       330 001107       332 001111       334 001112       336 001114       338 001117
    340 001122       342 001127       344 001131       345 001141       346 001144       347 001152       348 001154
    351 001155       352 001160       353 001163       355 001166       356 001170       358 001175       360 001201
    361 001211       363 001217       364 001221       366 001222       368 001224       370 001227       371 001231
    372 001233       374 001235       375 001243       376 001247       378 001251       380 001252       382 001254
    384 001257       386 001262       388 001267       390 001271       391 001274       392 001302       395 001303
    397 001306       399 001311       401 001316       403 001320       404 001323       405 001331       408 001332
    409 001335       411 001340       413 001343       415 001350       417 001352       418 001355       419 001363
    422 001364       423 001367       425 001372       427 001377       429 001404       430 001412       432 001416
    434 001423       436 001432       437 001435       440 001445       443 001446       447 001453       449 001456
    451 001460       453 001465       455 001472       456 001500       458 001504       460 001511       462 001516
    463 001521       464 001526       465 001536       467 001544       470 001545       472 001547       476 001557
    480 001570       482 001572       483 001574       485 001576       486 001603       487 001604       489 001605
    492 001611       494 001617       496 001631       497 001635       499 001637       501 001651       502 001655
    504 001657       505 001662       507 001670       508 001673       510 001701       511 001704       513 001712
    514 001717       517 001730       518 001732       520 001742       522 001744       523 001751       524 001755
    525 001760       526 001765       527 001775       528 002003       530 002005       532 002006       537 002015
    538 002022       539 002023       543 002025       547 002035       551 002037       552 002041       556 002042
    557 002044       559 002045       560 002050       562 002051       567 002061       569 002065       572 002077
    578 002104       579 002106       580 002115       582 002123       584 002126       585 002135       586 002141
    588 002143       590 002144       592 002146       593 002151       594 002157       596 002165       598 002170
    599 002177       600 002203       602 002205       604 002206       606 002210       608 002217       610 002225
    612 002233       613 002237       614 002244       617 002256       618 002263       620 002265       622 002267
    623 002275       626 002311       628 002313       629 002316       631 002317       636 002327       638 002333
    639 002341       642 002355       644 002357       645 002362       647 002363       654 002373       656 002377
    659 002412       662 002417       663 002421       664 002426       666 002433       667 002435       668 002437
    669 002447       670 002453       671 002455       672 002456       673 002457       675 002460       676 002462
    677 002466       679 002473       680 002475       681 002477       682 002507       683 002513       684 002515
    685 002516       686 002517       688 002520       691 002527       692 002531       695 002533       698 002542
    699 002544       702 002546       705 002555       706 002557       709 002561       710 002565       712 002576
    713 002601       715 002604       716 002610       719 002611       721 002613       722 002621       724 002627
    725 002632       727 002635       728 002641       731 002642       733 002644       735 002645       739 002655
    740 002661       742 002665       747 002670       748 002673       750 002701       751 002703       753 002705
    756 002706       761 002711       762 002714       764 002722       765 002724       766 002726       768 002730
    770 002732       775 002733       776 002743       777 002747       779 002751       780 002755       782 002761
    783 002766       784 003003       785 003011       786 003013       787 003014       789 003017       790 003021
    791 003022       793 003024       797 003025       798 003035       799 003041       801 003043       802 003046
    803 003050       805 003052       807 003053       811 003065       812 003071       814 003074       815 003077
    817 003102       819 003103       825 003114       827 003120       834 003123       837 003126       838 003130
    840 003133       851 003145       852 003146       855 003147       862 003152       865 003164       869 003171
    870 003172       872 003173       883 003202       885 003203       886 003205       887 003215       888 003220
    889 003224       891 003226       892 003227       893 003241       894 003244       896 003247       899 003261
    901 003263       903 003265       904 003267       905 003277       906 003302       907 003306       910 003310
    912 003313       913 003314       916 003317       918 003320       922 003327       923 003332       925 003334
    927 003337       928 003343       930 003350       932 003362       933 003363       935 003365       937 003367
    938 003375       940 003402       941 003404       943 003406       945 003410       947 003411       956 003421
    957 003425       959 003432       961 003436       962 003440       965 003450       966 003453       971 003462
    972 003465       973 003467       974 003473       975 003476       977 003503       978 003506       979 003510
    980 003517       981 003523       982 003525       983 003526       984 003527       985 003530       987 003533
    988 003535       989 003537       990 003543       991 003546       993 003553       994 003556       995 003560
    996 003567       997 003573       998 003575       999 003576      1000 003577      1001 003600      1003 003603
   1004 003605      1007 003616      1008 003621      1011 003624      1012 003627      1015 003640      1016 003643
   1019 003646      1020 003651      1023 003662      1024 003665      1027 003670      1028 003675      1030 003703
   1031 003706      1033 003713      1034 003720      1037 003724      1039 003726      1040 003733      1042 003741
   1043 003744      1045 003751      1046 003756      1049 003762      1051 003764      1054 003765      1056 003766
   1057 003773      1058 003776      1059 004003      1062 004012      1064 004013      1066 004014      1067 004020
   1069 004030      1070 004037      1071 004041      1074 004046      1076 004047      1078 004051      1083 004071
   1085 004103      1086 004104      1089 004124   14    8 004127   14   13 004131   14   14 004134   14   15 004137
14   17 004174   14   19 004177   14   24 004201   14   35 004336   14   36 004341   14   39 004343   14   43 004345
14   44 004350   14   45 004354   14   46 004356   14   47 004357   14   50 004373   14   54 004375   14   55 004400
14   56 004404   14   57 004406   14   58 004407      1095 004430      1097 004431      1100 004434      1101 004445
   1102 004450      1103 004454      1104 004457      1106 004461      1110 004464      1113 004467      1114 004477
   1115 004502      1116 004506      1117 004511      1119 004513      1123 004516      1125 004521      1126 004524
   1128 004530      1129 004534      1130 004537      1134 004542      1136 004545      1137 004550      1139 004554
   1140 004556      1144 004561      1146 004564      1147 004567      1149 004573      1150 004575      1154 004600
   1155 004605      1157 004612      1159 004621      1160 004624      1162 004630      1163 004633      1167 004640
   1169 004644      1171 004646      1172 004653      1174 004660      1175 004665      1176 004670      1178 004675
   1180 004700      1181 004704      1182 004710      1183 004711      1186 004717      1188 004723      1191 004725
   1194 004726      1212 004730      1214 004736      1216 004742      1218 004746      1220 004751      1222 004755
   1224 004760      1226 004763      1228 004766      1230 004771      1232 004777      1234 005000      1240 005012
   1241 005017      1243 005022      1245 005024      1246 005036      1249 005037      1251 005041      1252 005044
   1254 005047      1259 005061      1261 005066      1262 005074      1263 005076      1264 005111      1265 005114
   1267 005115      1268 005133      1269 005146      1272 005154      1275 005155      1277 005157      1278 005164
   1279 005173      1281 005207      1283 005212      1284 005215      1285 005216      1287 005222      1289 005223
   1291 005225      1293 005232      1298 005235      1299 005237      1300 005240      1301 005242      1310 005246
   1311 005250      1314 005251      1315 005254      1316 005261      1318 005273      1319 005274      1320 005304
   1321 005313      1323 005316      1326 005327      1328 005332      1330 005333      1334 005335      1337 005342
   1339 005354      1341 005357      1343 005363      1347 005400      1350 005402      1351 005412      1353 005416


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
