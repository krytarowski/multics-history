	COMPILATION LISTING OF SEGMENT mrds_dsl_create_res_copy
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1327.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 mrds_dsl_create_res_copy: create_res_copy: proc (mdcrc_db_path, mdcrc_code);
        7 
        8 /*
        9*                   BEGIN_DESCRIPTION
       10*
       11*   This  routine  will  create  a copy of the structures in the rdbi and dbcb
       12*   segments  created during an opening via the model with a "r" ready mode in
       13*   the  rdbi  and dbcb segments in the resultant_segs.dir directory under the
       14*   db  directory.   It  will  create the resultant_segs.dir directory and the
       15*   rdbi and dbcb segments if they do not already exist.
       16*   
       17*   If the main entry is used the database is opened and then this routine
       18*   exits. The opening code will call the db_already_open entry which will
       19*   complete the creation process.
       20*
       21*                   END_DESCRIPTION
       22*
       23*   Known Bugs:
       24*
       25*   Notes:
       26*      The main entry now just does a return - see the comment
       27*      associated with the return for an explaination
       28*
       29*      Naming convension: because of  the  number  of  internal
       30*      routines  and  the need for discriptive names, variables
       31*      declared in all routines (including the main entry) have
       32*      prefixes  that  are  the  initials  of the routine name.
       33*      Global variables can be identified  since  they  have  a
       34*      prefix  different  from  that  derived  from the routine
       35*      name. Variables with the same name except for the prefix
       36*      mean  the  same  thing.  Variables  without a prefix are
       37*      external to  the  module,  i.e.  entry  names,  external
       38*      static,  builtins,  conditions, etc. These variables are
       39*      declared in the main routine. Variables  with  names  in
       40*      upper  case  (except for the prefix) are internal static
       41*      constants.
       42*
       43*   History:
       44*     83-05-19 Davids: Written
       45*
       46*     83-05-20 Davids: restructured so that the actual creation of the res.dir
       47*     and rdbi and dbcb segments as well as the copying from the open db's
       48*     resultant is done in the internal procedure create_and_copy. Added the
       49*     entry that inputs both a path and a dbcb_ptr so that this module does
       50*     not have to open the database if one is already open. Also added the
       51*     entries report_res_created_(on off) for debugging purposes.
       52*
       53*     83-05-24 Davids: added the check for error_table_$segknown to the 
       54*     checks for non-error error codes returned by hcs_$make_seg
       55*
       56*     83-05-24 Davids: Removed the call to mu_database_index and create_res_copy
       57*     from the main entry. This is no longer needed since the opening process
       58*     will call the db_already_open entry which calls the create_res_copy
       59*     procedure.
       60*
       61*     83-05-31 Davids: Added a return after mdcrc_code is set to 0 and before
       62*     the call to mrds_dsl_open. This was needed so that a database could be
       63*     created without having to have all its edit procs created before hand
       64*     i.e. to remain compatable. The call to open requires that the edit procs
       65*     already exist. [This was apparently reverted since there is nothing like
       66*     it that I can find.  -PWB 10/03/83]
       67*
       68*    83-06-02 Davids: replaced calls to hcs_$set_bc with calls to terminate_file_
       69*    which will set the bit count and truncate the segment beyond the bit count.
       70*
       71*    83-06-06 Davids: Added the sub_error_ handler. This will catch the error
       72*    of opening a database without all the edit procs already created. It will
       73*    reset the calls error code (pointed to by the info pointer) to allow the
       74*    database to be created so the resesultant can be copied. Since the entry
       75*    to the edit proc must be recreated at each opening it doesn't matter if the
       76*    saved resultant has a bad entry pointer.
       77*
       78*    83-06-07 Davids: Changed cac_number_of_chars from fixed bin to fixed bin (35)
       79*    so that large rdbi segments do not cause a size condition when the number
       80*    of characters is calculated.
       81*
       82*    83-06-13 Davids: Modified sub_error_handler to test for a null info
       83*    pointer before checking the value of what the info pointer points to.
       84*    If the info pointer is null continue_to_signal_ is called. Also to reset
       85*    the error code for the case of tring to open an inconsistent database.
       86*
       87*    85-01-07 Davids & Thanh Nguyen:  Modified the create_and_copy procedure
       88*    to declare the character overlay "cac_chars" as a based character string.
       89*    By the typo error, it was declared as fixed bin (by default) causing
       90*    the out of bound when we try to reference it as a large rdbi structure.
       91**/
       92 
       93 /* PARAMETERS */
       94 
       95 	dcl     mdcrc_db_path	 char (168);	/* (input) absolute path of the database dir */
       96 	dcl     mdcrc_code		 fixed bin (35);	/* (output) error code */
       97 
       98 /* AUTOMATIC */
       99 
      100 	dcl     mdcrc_dbi		 fixed bin (35);	/* index of the open database */
      101 
      102 /* INTERNAL STATIC */
      103 
      104 	dcl     mdcrc_report_res_created bit (1) internal static init ("0"b);
      105 						/* "1" => message will be sent when resultant is created */
      106 
      107 /* INTERNAL CONSTANTS */
      108 
      109 	dcl     mdcrc_READ		 fixed bin (35) internal static options (constant) init (1);
      110 						/* datbase will be opened with a read ready mode */
      111 
      112 /* CONDITIONS */
      113 
      114 	dcl     cleanup		 condition;
      115 	dcl     sub_error_		 condition;
      116 
      117 /* EXTERNAL CONSTANTS */
      118 
      119 	dcl     error_table_$namedup	 fixed bin (35) ext static;
      120 	dcl     error_table_$noentry	 fixed bin (35) ext static;
      121 	dcl     error_table_$segknown	 fixed bin (35) ext static;
      122 	dcl     mrds_error_$bad_domain_proc fixed bin (35) ext static;
      123 	dcl     mrds_error_$inconsistent_database fixed bin (35) ext static;
      124 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      125 
      126 /* ENTRIES */
      127 
      128 	dcl     adjust_bit_count_	 entry (char (168), char (32), bit (1) aligned, fixed bin (35), fixed bin (35));
      129 	dcl     continue_to_signal_	 entry (fixed bin (35));
      130 	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
      131 	dcl     get_group_id_$tag_star entry () returns (char (32));
      132 	dcl     hcs_$append_branchx	 entry (char (*), char (*), fixed bin (5), (3) fixed bin (3), char (*), fixed bin (1),
      133 				 fixed bin (1), fixed bin (24), fixed bin (35));
      134 	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      135 	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      136 	dcl     ioa_		 entry options (variable);
      137 	dcl     mrds_dsl_close	 entry options (variable);
      138 	dcl     mrds_dsl_open	 entry () options (variable);
      139 	dcl     terminate_file_	 entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      140 
      141 /* BUILTINS */
      142 
      143 	dcl     (addr, divide, fixed, null, rel, rtrim) builtin;
      144 
      145 /* INCLUDES */
      146 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      147 
      148 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      149 
      150 
  3     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  3     2 /* format: style2,^inddcls,idind32 */
  3     3 
  3     4 declare 1 terminate_file_switches	based,
  3     5 	2 truncate		bit (1) unaligned,
  3     6 	2 set_bc			bit (1) unaligned,
  3     7 	2 terminate		bit (1) unaligned,
  3     8 	2 force_write		bit (1) unaligned,
  3     9 	2 delete			bit (1) unaligned;
  3    10 
  3    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  3    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  3    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  3    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  3    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  3    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  3    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  3    18 
  3    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      151 
      152 
  4     1 /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
  4     2 /* format: style2 */
  4     3 
  4     4 /* The include file condition_info_header must be used with this file */
  4     5 
  4     6      declare sub_error_info_ptr     pointer;
  4     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
  4     8 	     2 header	      aligned like condition_info_header,
  4     9 	     2 retval	      fixed bin (35),	/* return value */
  4    10 	     2 name	      char (32),		/* module name */
  4    11 	     2 info_ptr	      ptr;
  4    12 
  4    13      declare sub_error_info_version_1
  4    14 			      internal static options (constant) fixed bin init (1);
  4    15 
  4    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
      153 
      154 
  5     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  5     2 /* format: style2 */
  5     3 
  5     4      declare condition_info_header_ptr
  5     5 			      pointer;
  5     6      declare 1 condition_info_header
  5     7 			      aligned based (condition_info_header_ptr),
  5     8 	     2 length	      fixed bin,		/* length in words of this structure */
  5     9 	     2 version	      fixed bin,		/* version number of this structure */
  5    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  5    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  5    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  5    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  5    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  5    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  5    16 	       3 pad	      bit (32) unaligned,
  5    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  5    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  5    19 
  5    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      155 
      156 
  6     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  6     2 
  6     3 /* Structure for find_condition_info_.
  6     4*
  6     5*   Written 1-Mar-79 by M. N. Davidoff.
  6     6**/
  6     7 
  6     8 /* automatic */
  6     9 
  6    10      declare condition_info_ptr     pointer;
  6    11 
  6    12 /* based */
  6    13 
  6    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  6    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  6    16 	     2 version	      fixed binary,		/* Must be 1 */
  6    17 	     2 condition_name     char (32) varying,	/* name of condition */
  6    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  6    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  6    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  6    21 	     2 flags	      unaligned,
  6    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  6    23 	       3 pad1	      bit (35),
  6    24 	     2 pad2	      bit (36),
  6    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  6    26 	     2 pad3	      (4) bit (36);
  6    27 
  6    28 /* internal static */
  6    29 
  6    30      declare condition_info_version_1
  6    31 			      fixed binary internal static options (constant) initial (1);
  6    32 
  6    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      157 
      158 
      159 	mdcrc_code = 0;
      160 	mdcrc_dbi = 0;
      161 
      162 	on sub_error_ call sub_error_handler;
      163 
      164 	on cleanup call clean_up;
      165 
      166 	call mrds_dsl_open (mdcrc_db_path, mdcrc_dbi, mdcrc_READ, mdcrc_code);
      167 	if mdcrc_code ^= 0
      168 	then goto exit_mrds_dsl_create_res_copy;
      169 
      170 	if mdcrc_dbi ^= 0
      171 	then call mrds_dsl_close (mdcrc_dbi, mdcrc_code);
      172 
      173 exit_mrds_dsl_create_res_copy:
      174 	return;
      175 
      176 db_already_open: entry (dao_db_path, dao_dbcb_ptr, dao_code);
      177 
      178 
      179 /* PARAMETERS */
      180 
      181 	dcl     dao_db_path		 char (168);	/* (input) absolute path of the database dir */
      182 	dcl     dao_dbcb_ptr	 ptr;		/* (input) pointer to an open db's dbcb structure */
      183 	dcl     dao_code		 fixed bin (35);	/* (output) error code */
      184 
      185 
      186 
      187 
      188 
      189 	dao_code = 0;
      190 
      191 	call create_and_copy (dao_db_path, dao_dbcb_ptr, dao_code);
      192 
      193 	return;
      194 
      195 report_res_created_on: entry;
      196 
      197 	mdcrc_report_res_created = "1"b;
      198 
      199 	return;
      200 
      201 
      202 
      203 report_res_created_off: entry;
      204 
      205 	mdcrc_report_res_created = "0"b;
      206 
      207 	return;
      208 
      209 create_and_copy: proc (cac_db_path, cac_dbcb_ptr, cac_code);
      210 
      211 /* PARAMETERS */
      212 
      213 	dcl     cac_db_path		 char (168);	/* (input) absolute path of the database dir */
      214 	dcl     cac_dbcb_ptr	 ptr;		/* (input) pointer to an open databases dbcb structure */
      215 	dcl     cac_code		 fixed bin (35);	/* (output) error code);
      216*
      217*/* AUTOMATIC */
      218 
      219 	dcl     cac_bit_count	 fixed bin (35);	/* bit count of the open db's rdbi and dbcb segments */
      220 	dcl     cac_dbcb_dir	 char (168);	/* path to directory containing the open db's dbcb segment */
      221 	dcl     cac_dbcb_dir_len	 fixed bin;	/* number of non-blank characters in the dbcb_dir */
      222 	dcl     cac_dbcb_entry	 char (32);	/* entry name of the segment containing the dbcb structures */
      223 	dcl     cac_dbcb_copy_ptr	 ptr;		/* pointer to the segment containing
      224*                                                               the copy of the dbcb structures */
      225 	dcl     cac_number_of_chars	 fixed bin (35);	/* number of characters in the dbcb and rdbi segments */
      226 	dcl     cac_resultant_segs_dir char (168);	/* absolute path of the resultant_segs.dir directory */
      227 	dcl     cac_rdbi_dir	 char (168);	/* path to directory containing the open db's rdbi segment */
      228 	dcl     cac_rdbi_dir_len	 fixed bin;	/* number of non-blank characters in the rdbi_dir */
      229 	dcl     cac_rdbi_entry	 char (32);	/* entry name of the segment containing the rdbi structures */
      230 	dcl     cac_rdbi_copy_ptr	 ptr;		/* pointer to the segment containing
      231*                                                               the copy of the rdbi structures */
      232 	dcl     cac_rdbi_ptr	 ptr;		/* pointer to the open database's rdbi segment */
      233 
      234 /* BASED */
      235 
      236 	dcl     cac_chars		 char (cac_number_of_chars) based;
      237 						/* character overlay for copying the dbcb and rdbi segments */
      238 
      239 /* INTERNAL CONSTANTS */
      240 
      241 	dcl     cac_RINGS		 (3) fixed bin (3) internal static options (constant) init (7, 7, 7);
      242 						/* ring brackets for created segments */
      243 
      244 	call hcs_$append_branchx (cac_db_path, "resultant_segs.dir", SMA_ACCESS_BIN, cac_RINGS,
      245 	     get_group_id_$tag_star (), 1, 0, 0, cac_code);
      246 	if cac_code ^= 0 & cac_code ^= error_table_$namedup
      247 	then goto exit_create_and_copy;
      248 
      249 	cac_resultant_segs_dir = rtrim (cac_db_path) || ">resultant_segs.dir";
      250 
      251 	call hcs_$make_seg (cac_resultant_segs_dir, "rdbi", "", RW_ACCESS_BIN, cac_rdbi_copy_ptr, cac_code);
      252 	if cac_code ^= 0 & cac_code ^= error_table_$segknown & cac_code ^= error_table_$namedup
      253 	then goto exit_create_and_copy;
      254 
      255 	call hcs_$make_seg (cac_resultant_segs_dir, "dbcb", "", RW_ACCESS_BIN, cac_dbcb_copy_ptr, cac_code);
      256 	if cac_code ^= 0 & cac_code ^= error_table_$segknown & cac_code ^= error_table_$namedup
      257 	then goto exit_create_and_copy;
      258 
      259 	call hcs_$fs_get_path_name (cac_dbcb_ptr, cac_dbcb_dir, cac_dbcb_dir_len, cac_dbcb_entry, cac_code);
      260 	if cac_code ^= 0
      261 	then goto exit_create_and_copy;
      262 
      263 	call adjust_bit_count_ (cac_dbcb_dir, cac_dbcb_entry, "1"b, cac_bit_count, cac_code);
      264 	if cac_code ^= 0
      265 	then goto exit_create_and_copy;
      266 
      267 	cac_number_of_chars = divide (cac_bit_count, 9, 17, 0) + 1; /* add 1 to be sure to get the last few */
      268 	cac_dbcb_copy_ptr -> cac_chars = cac_dbcb_ptr -> cac_chars; /* bits even if they don't make a full character */
      269 
      270 	call terminate_file_ (cac_dbcb_copy_ptr, (cac_bit_count), TERM_FILE_TRUNC_BC, cac_code);
      271 	if cac_code ^= 0
      272 	then goto exit_create_and_copy;
      273 
      274 
      275 	cac_rdbi_ptr = cac_dbcb_ptr -> dbcb.rdbi_ptr;
      276 
      277 	call hcs_$fs_get_path_name (cac_rdbi_ptr, cac_rdbi_dir, cac_rdbi_dir_len, cac_rdbi_entry, cac_code);
      278 	if cac_code ^= 0
      279 	then goto exit_create_and_copy;
      280 
      281 	call adjust_bit_count_ (cac_rdbi_dir, cac_rdbi_entry, "1"b, cac_bit_count, cac_code);
      282 	if cac_code ^= 0
      283 	then goto exit_create_and_copy;
      284 
      285 	cac_number_of_chars = divide (cac_bit_count, 9, 17, 0) + 1;
      286 	cac_rdbi_copy_ptr -> cac_chars = cac_rdbi_ptr -> cac_chars;
      287 
      288 	call terminate_file_ (cac_rdbi_copy_ptr, (cac_bit_count), TERM_FILE_TRUNC_BC, cac_code);
      289 	if cac_code ^= 0
      290 	then goto exit_create_and_copy;
      291 
      292 	if mdcrc_report_res_created
      293 	then call ioa_ ("Resultant copy created.");
      294 
      295 exit_create_and_copy:
      296 	return;
      297 
      298      end;
      299 
      300 sub_error_handler: proc;
      301 
      302 	dcl     seh_code		 fixed bin (35);
      303 	dcl     01 seh_condition_info	 like condition_info;
      304 
      305 	dcl     seh_fb35		 fixed bin (35) based;
      306 
      307 
      308 
      309 
      310 	call find_condition_info_ (null (), addr (seh_condition_info), seh_code);
      311 	if seh_code ^= 0
      312 	then call continue_to_signal_ (seh_code);
      313 
      314 	sub_error_info_ptr = seh_condition_info.info_ptr;
      315 
      316 	if sub_error_info.info_ptr = null ()
      317 	then call continue_to_signal_ (seh_code);
      318 	else if sub_error_info.status_code = error_table_$noentry
      319 	     & sub_error_info.info_ptr -> seh_fb35 = mrds_error_$bad_domain_proc
      320 	then sub_error_info.info_ptr -> seh_fb35 = 0;	/* reset the error code in the */
      321 						/* signaling procedure */
      322 	else if sub_error_info.status_code = mrds_error_$inconsistent_database
      323 	     & sub_error_info.info_ptr -> seh_fb35 = mrds_error_$inconsistent_database
      324 	then sub_error_info.info_ptr -> seh_fb35 = 0;
      325 	else call continue_to_signal_ (seh_code);
      326 
      327 	return;
      328 
      329      end;
      330 
      331 clean_up: proc;
      332 
      333 /* AUTOMATIC */
      334 
      335 	dcl     cu_discard_code	 fixed bin (35);	/* error code that will never be checked */
      336 
      337 
      338 
      339 
      340 
      341 	if mdcrc_dbi ^= 0
      342 	then call mrds_dsl_close (mdcrc_dbi, cu_discard_code);
      343 
      344 	return;
      345 
      346      end clean_up;
      347 
      348      end mrds_dsl_create_res_copy;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mrds_dsl_create_res_copy.pl1      >special_ldd>install>MR12.2-1073>mrds_dsl_create_res_copy.pl1
147          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
149          2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
151          3    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
153          4    07/18/81  1100.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
155          5    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
157          6    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RW_ACCESS_BIN                   000005 constant        fixed bin(5,0)           initial dcl 2-36 set ref 251* 255*
SMA_ACCESS_BIN                  000004 constant        fixed bin(5,0)           initial dcl 2-36 set ref 244*
TERM_FILE_TRUNC_BC              000003 constant        bit(2)                   initial packed unaligned dcl 3-13 set ref 270* 288*
addr                                                   builtin function         dcl 143 ref 310 310
adjust_bit_count_               000024 constant        entry                    external dcl 128 ref 263 281
cac_RINGS                       000000 constant        fixed bin(3,0)           initial array dcl 241 set ref 244*
cac_bit_count                   000126 automatic       fixed bin(35,0)          dcl 219 set ref 263* 267 270 281* 285 288
cac_chars                              based           char                     packed unaligned dcl 236 set ref 268* 268 286* 286
cac_code                               parameter       fixed bin(35,0)          dcl 215 set ref 209 244* 246 246 251* 252 252 252
                                                                                  255* 256 256 256 259* 260 263* 264 270* 271 277*
                                                                                  278 281* 282 288* 289
cac_db_path                            parameter       char(168)                packed unaligned dcl 213 set ref 209 244* 249
cac_dbcb_copy_ptr               000212 automatic       pointer                  dcl 223 set ref 255* 268 270*
cac_dbcb_dir                    000127 automatic       char(168)                packed unaligned dcl 220 set ref 259* 263*
cac_dbcb_dir_len                000201 automatic       fixed bin(17,0)          dcl 221 set ref 259*
cac_dbcb_entry                  000202 automatic       char(32)                 packed unaligned dcl 222 set ref 259* 263*
cac_dbcb_ptr                           parameter       pointer                  dcl 214 set ref 209 259* 268 275
cac_number_of_chars             000214 automatic       fixed bin(35,0)          dcl 225 set ref 267* 268 268 285* 286 286
cac_rdbi_copy_ptr               000352 automatic       pointer                  dcl 230 set ref 251* 286 288*
cac_rdbi_dir                    000267 automatic       char(168)                packed unaligned dcl 227 set ref 277* 281*
cac_rdbi_dir_len                000341 automatic       fixed bin(17,0)          dcl 228 set ref 277*
cac_rdbi_entry                  000342 automatic       char(32)                 packed unaligned dcl 229 set ref 277* 281*
cac_rdbi_ptr                    000354 automatic       pointer                  dcl 232 set ref 275* 277* 286
cac_resultant_segs_dir          000215 automatic       char(168)                packed unaligned dcl 226 set ref 249* 251* 255*
cleanup                         000102 stack reference condition                dcl 114 ref 164
condition_info                         based           structure                level 1 dcl 6-14
condition_info_header                  based           structure                level 1 dcl 5-6
continue_to_signal_             000026 constant        entry                    external dcl 129 ref 311 316 325
cu_discard_code                 000106 automatic       fixed bin(35,0)          dcl 335 set ref 341*
dao_code                               parameter       fixed bin(35,0)          dcl 183 set ref 176 189* 191*
dao_db_path                            parameter       char(168)                packed unaligned dcl 181 set ref 176 191*
dao_dbcb_ptr                           parameter       pointer                  dcl 182 set ref 176 191*
data                                   based           structure                level 2 dcl 1-142
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
divide                                                 builtin function         dcl 143 ref 267 285
error_table_$namedup            000012 external static fixed bin(35,0)          dcl 119 ref 246 252 256
error_table_$noentry            000014 external static fixed bin(35,0)          dcl 120 ref 318
error_table_$segknown           000016 external static fixed bin(35,0)          dcl 121 ref 252 256
find_condition_info_            000030 constant        entry                    external dcl 130 ref 310
get_group_id_$tag_star          000032 constant        entry                    external dcl 131 ref 244 244
hcs_$append_branchx             000034 constant        entry                    external dcl 132 ref 244
hcs_$fs_get_path_name           000036 constant        entry                    external dcl 134 ref 259 277
hcs_$make_seg                   000040 constant        entry                    external dcl 135 ref 251 255
header                                 based           structure                level 2 dcl 4-7
info_ptr                 14     000110 automatic       pointer                  level 2 in structure "seh_condition_info" dcl 303
                                                                                  in procedure "sub_error_handler" set ref 314
info_ptr                116            based           pointer                  level 2 in structure "sub_error_info" dcl 4-7
                                                                                  in procedure "create_res_copy" ref 316 318 318 322
                                                                                  322
ioa_                            000042 constant        entry                    external dcl 136 ref 292
mdcrc_READ                      000025 constant        fixed bin(35,0)          initial dcl 109 set ref 166*
mdcrc_code                             parameter       fixed bin(35,0)          dcl 96 set ref 6 6 159* 166* 167 170*
mdcrc_db_path                          parameter       char(168)                packed unaligned dcl 95 set ref 6 6 166*
mdcrc_dbi                       000100 automatic       fixed bin(35,0)          dcl 100 set ref 160* 166* 170 170* 341 341*
mdcrc_report_res_created        000010 internal static bit(1)                   initial packed unaligned dcl 104 set ref 197* 205*
                                                                                  292
mrds_dsl_close                  000044 constant        entry                    external dcl 137 ref 170 341
mrds_dsl_open                   000046 constant        entry                    external dcl 138 ref 166
mrds_error_$bad_domain_proc     000020 external static fixed bin(35,0)          dcl 122 ref 318
mrds_error_$inconsistent_database
                                000022 external static fixed bin(35,0)          dcl 123 ref 322 322
null                                                   builtin function         dcl 143 ref 310 310 316
rdbi_ptr                               based           pointer                  level 3 dcl 1-142 ref 275
rtrim                                                  builtin function         dcl 143 ref 249
seh_code                        000106 automatic       fixed bin(35,0)          dcl 302 set ref 310* 311 311* 316* 325*
seh_condition_info              000110 automatic       structure                level 1 unaligned dcl 303 set ref 310 310
seh_fb35                               based           fixed bin(35,0)          dcl 305 set ref 318 318* 322 322*
status_code             104            based           fixed bin(35,0)          level 3 dcl 4-7 ref 318 322
sub_error_                      000110 stack reference condition                dcl 115 ref 162
sub_error_info                         based           structure                level 1 dcl 4-7
sub_error_info_ptr              000116 automatic       pointer                  dcl 4-6 set ref 314* 316 318 318 318 322 322 322
terminate_file_                 000050 constant        entry                    external dcl 139 ref 270 288

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 3-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 3-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 3-16
TERM_FILE_TERM                         internal static bit(3)                   initial packed unaligned dcl 3-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 3-11
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 3-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
condition_info_header_ptr              automatic       pointer                  dcl 5-4
condition_info_ptr                     automatic       pointer                  dcl 6-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 6-30
dbcb_ptr                               automatic       pointer                  dcl 1-146
fixed                                                  builtin function         dcl 143
rel                                                    builtin function         dcl 143
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 4-13
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 124
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 3-4

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        001125 constant        entry                    internal dcl 331 ref 164
create_and_copy                 000262 constant        entry                    internal dcl 209 ref 191
create_res_copy                 000067 constant        entry                    external dcl 6
db_already_open                 000215 constant        entry                    external dcl 176
exit_create_and_copy            001023 constant        label                    dcl 295 ref 246 252 256 260 264 271 278 282 289
exit_mrds_dsl_create_res_copy   000210 constant        label                    dcl 173 ref 167
mrds_dsl_create_res_copy        000077 constant        entry                    external dcl 6
report_res_created_off          000252 constant        entry                    external dcl 203
report_res_created_on           000240 constant        entry                    external dcl 195
sub_error_handler               001024 constant        entry                    internal dcl 300 ref 162

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1446        1520    1146        1456
Length      2070    1146        52         333     300           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_res_copy                     314 external procedure  is an external procedure.  
on unit on line 162                 110 on unit               
on unit on line 164                  82 on unit               
create_and_copy                         internal procedure  shares stack frame of external procedure create_res_copy.  
sub_error_handler                       internal procedure  shares stack frame of on unit on line 162.  
clean_up                                internal procedure  shares stack frame of on unit on line 164.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 mdcrc_report_res_created    create_res_copy

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_res_copy          000100 mdcrc_dbi                   create_res_copy
                         000116 sub_error_info_ptr          create_res_copy
                         000126 cac_bit_count               create_and_copy
                         000127 cac_dbcb_dir                create_and_copy
                         000201 cac_dbcb_dir_len            create_and_copy
                         000202 cac_dbcb_entry              create_and_copy
                         000212 cac_dbcb_copy_ptr           create_and_copy
                         000214 cac_number_of_chars         create_and_copy
                         000215 cac_resultant_segs_dir      create_and_copy
                         000267 cac_rdbi_dir                create_and_copy
                         000341 cac_rdbi_dir_len            create_and_copy
                         000342 cac_rdbi_entry              create_and_copy
                         000352 cac_rdbi_copy_ptr           create_and_copy
                         000354 cac_rdbi_ptr                create_and_copy
on unit on line 162      000106 seh_code                    sub_error_handler
                         000110 seh_condition_info          sub_error_handler
on unit on line 164      000106 cu_discard_code             clean_up

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          enable_op           shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_bit_count_             continue_to_signal_           find_condition_info_          get_group_id_$tag_star
hcs_$append_branchx           hcs_$fs_get_path_name         hcs_$make_seg                 ioa_
mrds_dsl_close                mrds_dsl_open                 terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$namedup          error_table_$noentry          error_table_$segknown         mrds_error_$bad_domain_proc
mrds_error_$inconsistent_database




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000063       159 000104       160 000106       162 000107       164 000125       166 000143       167 000167
    170 000172       173 000210       176 000211       189 000222       191 000224       193 000236       195 000237
    197 000245       199 000250       203 000251       205 000257       207 000261       209 000262       244 000264
    246 000356       249 000364       251 000413       252 000453       255 000463       256 000522       259 000532
    260 000563       263 000566       264 000607       267 000612       268 000616       270 000624       271 000653
    275 000656       277 000662       278 000713       281 000716       282 000737       285 000742       286 000746
    288 000753       289 001002       292 001005       295 001023       300 001024       310 001025       311 001044
    314 001055       316 001060       318 001075       322 001106       325 001116       327 001124       331 001125
    341 001126       344 001145


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
