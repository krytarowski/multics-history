	COMPILATION LISTING OF SEGMENT rw_set_format_options
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/16/84  1128.2 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: off */



        7 
        8 /*
        9*
       10*     This is the main level procedure called to implement the
       11*     report_writer_ set_format_options request.  Description and usage follows.
       12*
       13*     Description:
       14*
       15*     This request does one or more of the following actions.
       16*     
       17*     1) Sets INDIVIDUAL formatting option values to USER SPECIFIED
       18*     VALUES.
       19*
       20*     2) Sets INDIVIDUAL formatting option values to SYSTEM DEFAULTS.
       21*
       22*     3) Sets ALL of the formatting option values to SYSTEM DEFAULTS.
       23*     
       24*     Usage:
       25*
       26*     set_format_options {-format_option_args} {-control_args}
       27*
       28*
       29*     Both parameters are passed to this request by ssu_.
       30*
       31*
       32*     Known Bugs:
       33*
       34*     Other Problems:
       35*
       36*     History:
       37*
       38*     Written - Al Dupuis - August 1983
       39*     Changed - Al Dupuis - October 1984 Became report_writer_.
       40*
       41**/
       42 
       43 rw_set_format_options: proc (
       44 
       45 	sci_ptr_parm,   /* input: ptr to the subsystem control info structure */
       46 	report_cip_parm /* input: points to report_control_info */
       47 		        );



       48 
       49 dcl report_cip_parm ptr parm;
       50 dcl sci_ptr_parm ptr parm;



       51 
       52 /*
       53*          Mainline Processing Overview.
       54*
       55*     	(1) Go through the control args once setting the long and 
       56*              reset flags.
       57*
       58*          (2) Reset all values to system defaults if -reset is in effect.
       59*
       60*          (3) Process the format option args, prompting for value if
       61*              requested, then setting the value to user provided or
       62*              system default value.
       63**/
       64 



       65 
       66 	call initialize;

       67 
       68           if reset_flag
       69 	then do;
       70 	     call rw_options$set_all_to_system_defaults (report_cip, code);
       71 	     if code ^= 0 
       72 	     then call ssu_$abort_line (sci_ptr, code);
       73 	     if number_of_control_args = number_of_args_supplied
       74 	     then return;
       75 	end;

       76 
       77 	current_arg_number = 1;
       78           still_processing_format_option_args = ON;

       79 
       80 	do while (still_processing_format_option_args);
       81                call get_argument_set;
       82 	     call get_and_or_set_the_value;
       83 	end;

       84 
       85 	return;
       86 
       87 get_accumulated_input: proc;



       88 
       89 /*
       90*	Keep picking up pieces of the value concatenating each piece
       91*	to the one before with a blank separating each one. The value is
       92*	complete when we see the next format option name, which is 
       93*	recognizable by the leading hyphen. If the arg before the
       94*	next format option name was -string then conceal the special
       95*	meaning of "-". The value is also complete when we exhaust the
       96*	format option arguments.
       97**/

       98 
       99 	still_adding_chunks_of_the_value = ON;

      100 
      101 	do while (still_adding_chunks_of_the_value);

      102 
      103 	     call get_next_format_arg (code);
      104 	     if code = NO_MORE_FORMAT_ARGS_LEFT
      105 	     then return;

      106 
      107 	     if substr (arg, 1, 1) = "-" 
      108 	     & ^this_is_a_string_arg (save_arg_number_for_hyphen_string)
      109 	     then do;
      110 		still_adding_chunks_of_the_value = OFF;
      111 		current_arg_number = save_arg_number_for_hyphen_string + 1;
      112 		still_processing_format_option_args = ON;
      113 	     end;
      114 	     else option_value 
      115 		= option_value || " " || substr (arg, 1, arg_length);

      116 
      117 	end;

      118 
      119 	return;

      120 
      121      end get_accumulated_input;
      122 
      123 get_and_or_set_the_value: proc;



      124 
      125 /*
      126*	Pick up the rest of the value if necessary. If the
      127*	previous argument was -string then conceal the
      128*	special meaning of -prompt and -default. If the value contains
      129*	a trailing newline only then remove it. If the value contains
      130*	imedded newlines then make sure it ends with a newline.
      131**/

      132 
      133           if option_value = "-default" 
      134 	& ^this_is_a_string_arg (save_arg_number_for_hyphen_string)
      135 	then call rw_options$set_and_check (report_cip, long_option_name,
      136 	     option_identifier, option_value, SYSTEM_DEFAULT, code);
      137 	else do;
      138 	     if option_value = "-prompt"
      139 	     & ^this_is_a_string_arg (save_arg_number_for_hyphen_string)
      140 	     then call get_prompted_input;
      141 	     else call get_accumulated_input;
      142 	     if length (option_value) > 0
      143 	     then do;
      144 		if index (substr (option_value, 1, length (option_value) - 1), NEWLINE) ^= 0
      145 		then if substr (option_value, length (option_value)) ^= NEWLINE
      146 		     then option_value = option_value || NEWLINE;
      147 		     else;
      148 		else if substr (option_value, length (option_value)) = NEWLINE
      149 		     then option_value = substr (option_value, 1, length (option_value) - 1);
      150 		     else;
      151 	     end;
      152 	     call rw_options$set_and_check (report_cip, long_option_name, 
      153 		option_identifier, option_value, NOT_SYSTEM_DEFAULT, code);
      154 	end;

      155 
      156           /* Report various errors. */

      157 
      158 	if code ^= 0
      159           then if code = rw_error_$bad_option_value
      160 	     then if identifier_needed
      161 	          then call ssu_$abort_line (sci_ptr, code,
      162 	               "^/^a is not a valid value for ^a.",
      163 	               option_value, normalized_option_name);
      164 	          else call ssu_$abort_line (sci_ptr, code,
      165 		     "^/^a is not a valid value for ^a.", 
      166 		     option_value, long_option_name);
      167 	     else if code = error_table_$nomatch
      168 		then call ssu_$abort_line (sci_ptr, code,
      169 		     "^/The column identifier ^a did not match any column names.",
      170 		     option_identifier);
      171 	          else call ssu_$abort_line (sci_ptr, code);
      172 	else;

      173 
      174           return;

      175 
      176      end get_and_or_set_the_value;
      177 
      178 get_argument_set: proc;



      179 
      180 	/* Get the option name. */

      181 
      182 	call get_next_format_arg (code);
      183 	if code ^= 0
      184 	then call ssu_$abort_line (sci_ptr, 0,
      185 	     "Logic error while processing the request arguments.");

      186 
      187 	/* Translate the short or long name into a long name
      188*             and find out if a column identifier is needed. */

      189 
      190           option_name = arg;
      191           call rw_options$check_name (report_cip, option_name, 
      192 	     long_option_name, identifier_needed, code);
      193 	if code ^= 0
      194 	then if code = rw_error_$no_columns_defined
      195 	     then call ssu_$abort_line (sci_ptr, code,
      196 	          "^/There must be columns defined before the value of ^a can be set.",
      197 	          long_option_name);
      198 	     else if code = rw_error_$bad_option_name
      199 		then call ssu_$abort_line (sci_ptr, code,
      200 		     "^/^a is not a valid option name.", option_name);
      201 	          else call ssu_$abort_line (sci_ptr, code);
      202 	else;

      203 
      204 	/* Get the identifier if its required and check to make sure it's
      205*             valid so that we never prompt the user for the value when the 
      206*	   option identifier is invalid. */

      207 
      208 	if identifier_needed
      209 	then do;
      210 	     call get_next_format_arg (code);
      211 	     if code = NO_MORE_FORMAT_ARGS_LEFT
      212 	     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
      213 		"The option name ^a was not followed by an identifier.", 
      214 		long_option_name);
      215 	     else;
      216 	     option_identifier = arg;
      217 	     call rw_options$check_identifier (report_cip, long_option_name, 
      218 		option_identifier, normalized_option_name, code);
      219 	     if code ^= 0
      220 	     then if code = rw_error_$bad_option_identifier
      221 		then call ssu_$abort_line (sci_ptr, code,
      222 		     "^/^a is not a valid identifier for ^a.",
      223 		     option_identifier, long_option_name);
      224 	          else if code ^= error_table_$nostars
      225 		     then call ssu_$abort_line (sci_ptr, code);
      226 		     else;
      227 	     else;
      228 	end;
      229 	else;

      230 
      231 /* 
      232*	Get the first part of the option value which might be the complete
      233*	value, part of the value, or the control args -default or -prompt.
      234**/

      235 
      236 	call get_next_format_arg (code);
      237           if code = NO_MORE_FORMAT_ARGS_LEFT
      238 	then call ssu_$abort_line (sci_ptr, rw_error_$bad_option_value,
      239 	     "^/The format option ^a did not have a value supplied.", 
      240 	     long_option_name);

      241 
      242 	option_value = arg;

      243 
      244           return;

      245 
      246      end get_argument_set;
      247 
      248 get_next_format_arg: proc (code_parm);



      249 
      250 /*
      251*	Ignore control args and get straight to the format option arg.
      252*	Save the number of the arg preceding the format option arg so
      253*	-string processing can be done. Make sure that there is another
      254*	format option arg for the next pass through and set an indicator
      255*	if we've exhausted them.
      256**/

      257 
      258 dcl code_parm fixed bin (35) parm;

      259 
      260 	code_parm = 0;

      261 
      262 	/* Skip over the control args and get to the format args. */

      263 
      264 	do while (this_is_a_control_arg (current_arg_number));
      265 	     current_arg_number = current_arg_number + 1;
      266 	end;

      267 
      268 	if current_arg_number > number_of_args_supplied
      269 	then do;
      270 	     code = NO_MORE_FORMAT_ARGS_LEFT;
      271 	     still_processing_format_option_args = OFF;
      272 	     return;
      273 	end;
      274           call ssu_$arg_ptr (sci_ptr, current_arg_number,
      275 	     arg_ptr, arg_length);
      276 	save_arg_number_for_hyphen_string = current_arg_number - 1;
      277 	current_arg_number = current_arg_number + 1;

      278 
      279 	/* Make sure there is another format option arg. */

      280 
      281 	do while (this_is_a_control_arg (current_arg_number));
      282 	     current_arg_number = current_arg_number + 1;
      283 	end;

      284 
      285 	if current_arg_number > number_of_args_supplied
      286 	then still_processing_format_option_args = OFF;

      287 
      288 	return;

      289 
      290      end get_next_format_arg;
      291 
      292 get_prompted_input: proc;



      293 
      294 /*
      295*	Keep collecting lines from user_input until we hit a line which
      296*	consists of the single character ".". Don't prompt before collecting
      297*	if we are in brief mode. If the value is more than one line then
      298*	leave the newline character after each line. If the value is one
      299*	line then remove the newline from the end.
      300**/

      301 
      302 	input_buffer = "";
      303 	option_value = "";

      304 
      305 	if ^brief_flag
      306 	then if identifier_needed
      307 	     then call ioa_ ("Enter ^a.", normalized_option_name);
      308 	     else call ioa_ ("Enter ^a.", long_option_name);
      309 	else;

      310 
      311 	number_of_input_lines = 0;
      312 	more_input = ON;

      313 
      314 	do while (more_input);
      315 	     call iox_$get_line (iox_$user_input,
      316 		input_buffer_ptr, input_buffer_length, 
      317 		number_of_chars_read, code);
      318 	     if code ^= 0
      319 	     then call ssu_$abort_line (sci_ptr, code);
      320 	     else;
      321 	     number_of_input_lines = number_of_input_lines + 1;
      322 	     if number_of_chars_read = 2
      323 	     then if substr (input_buffer, 1, 1) = "."
      324 		then more_input = OFF;
      325 	          else;
      326 	     else;
      327 	     if more_input 
      328 	     then option_value = option_value
      329 		|| substr (input_buffer, 1, number_of_chars_read);
      330 	end;

      331 
      332 	if number_of_input_lines = 2
      333 	then option_value = substr (option_value, 1, 
      334 	     length (option_value) - 1);

      335 
      336 	return;

      337 
      338      end get_prompted_input;
      339 
      340 initialize: proc;



      341 
      342 	sci_ptr = sci_ptr_parm;
      343 	report_cip = report_cip_parm;

      344 
      345 	reset_flag = OFF;
      346 	brief_flag = OFF;

      347 
      348           /* If no args are given it is an error. */

      349 
      350 	call ssu_$arg_count (sci_ptr, number_of_args_supplied);
      351 	if number_of_args_supplied = 0
      352 	then call ssu_$abort_line (sci_ptr, error_table_$noarg,
      353 	     "^/Usage: set_format_options {-format_option_args} {-control_args}");

      354 
      355 /* 
      356*	Go through the control args once setting the flags and flagging
      357*	the control args we should ignore on our next pass through.
      358*	This is done with a map of bits for the control args
      359*	and another map of bits for the string args. 
      360**/

      361 
      362 	unspec (this_is_a_control_arg) = OFF;
      363 	unspec (this_is_a_string_arg) = OFF;
      364 	number_of_control_args = 0;
      365 	current_arg_number = 1;
      366 	still_processing_control_args = ON;

      367 
      368 	do while (still_processing_control_args);

      369 
      370 	     call ssu_$arg_ptr (sci_ptr, current_arg_number,
      371 		arg_ptr, arg_length);

      372 
      373 	     if arg = "-string" | arg = "-str"
      374 	     then do;
      375 		this_is_a_control_arg (current_arg_number) = ON;
      376 		this_is_a_string_arg (current_arg_number) = ON;
      377 		number_of_control_args = number_of_control_args + 1;
      378 		current_arg_number = current_arg_number + 1;
      379 		if current_arg_number > number_of_args_supplied
      380 		then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
      381 		     "^/-string must be followed by a format option value.");
      382 		else;
      383 	     end;
      384 	     else if arg = "-reset" | arg = "-rs" 
      385 		| arg = "-no_reset" | arg = "-nrs"
      386 		then do;
      387 		     this_is_a_control_arg (current_arg_number) = ON;
      388 		     number_of_control_args = number_of_control_args + 1;
      389 		     if arg = "-reset" | arg = "-rs"
      390 		     then reset_flag = ON;
      391 		     else reset_flag = OFF;
      392 		end;
      393 		else if arg = "-brief" | arg = "-bf"
      394 		     | arg = "-long" | arg = "-lg"
      395 		     then do;
      396 			this_is_a_control_arg (current_arg_number) = ON;
      397 			number_of_control_args = number_of_control_args + 1;
      398 			if arg = "-brief" | arg = "-bf"
      399 			then brief_flag = ON;
      400 			else brief_flag = OFF;
      401 		     end;
      402 		     else;

      403 
      404 	     current_arg_number = current_arg_number + 1;
      405 	     if current_arg_number > number_of_args_supplied
      406 	     then still_processing_control_args = OFF;

      407 
      408 	end;

      409 
      410 	/* If no format option args were given (only control args were
      411*             given), then -reset must be in effect or there's nothing to do. */

      412 
      413 	if number_of_control_args = number_of_args_supplied
      414 	then if ^reset_flag
      415 	     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
      416 	          "^/-reset was not specified and there are no format option values to set.");
      417 	     else;
      418 	else;

      419 
      420 	/* Used as the buffer to hold prompted input lines. */

      421 
      422 	input_buffer_ptr = addr (input_buffer);
      423 	input_buffer_length = MAXIMUM_OPTION_VALUE_LENGTH;
      424 	option_identifier = "";

      425 
      426           return;

      427 
      428      end initialize;
      429 
      430 dcl NEWLINE char (1) static int options (constant) init ("
      431 ");
      432 dcl NO_MORE_FORMAT_ARGS_LEFT fixed bin (35) static int options (constant) init (1);
      433 dcl NOT_SYSTEM_DEFAULT bit (1) aligned static int options (constant) init ("0"b);
      434 dcl OFF bit (1) aligned static int options (constant) init ("0"b);
      435 dcl ON bit (1) aligned static int options (constant) init ("1"b);
      436 dcl SYSTEM_DEFAULT bit (1) aligned static int options (constant) init ("1"b);

      437 
      438 dcl addr builtin;
      439 dcl arg char (arg_length) based (arg_ptr);
      440 dcl arg_length fixed bin (21);
      441 dcl arg_ptr ptr;

      442 
      443 dcl brief_flag bit (1) aligned;

      444 
      445 dcl code fixed bin (35);
      446 dcl current_arg_number fixed bin;

      447 
      448 dcl error_table_$inconsistent fixed bin(35) ext static;
      449 dcl error_table_$noarg fixed bin(35) ext static;
      450 dcl error_table_$nomatch fixed bin(35) ext static;
      451 dcl error_table_$nostars fixed bin(35) ext static;

      452 
      453 dcl identifier_needed bit (1) aligned;
      454 dcl index builtin;
      455 dcl input_buffer char (MAXIMUM_OPTION_VALUE_LENGTH);
      456 dcl input_buffer_length fixed bin (21);
      457 dcl input_buffer_ptr ptr;
      458 dcl ioa_ entry() options(variable);
      459 dcl iox_$get_line entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35));
      460 dcl iox_$user_input ptr ext static;

      461 
      462 dcl length builtin;
      463 dcl long_option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;

      464 
      465 dcl more_input bit (1) aligned;

      466 
      467 dcl number_of_chars_read fixed bin (21);
      468 dcl number_of_args_supplied fixed bin;
      469 dcl number_of_control_args fixed bin;
      470 dcl number_of_input_lines fixed bin;
      471 dcl normalized_option_name char (MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH) varying;

      472 
      473 dcl option_identifier char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
      474 dcl option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
      475 dcl option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;

      476 
      477 dcl report_cip ptr;
      478 dcl reset_flag bit (1) aligned;
      479 dcl rw_error_$bad_option_identifier fixed bin (35) ext static;
      480 dcl rw_error_$bad_option_name fixed bin(35) ext static;
      481 dcl rw_error_$bad_option_value fixed bin (35) static ext;
      482 dcl rw_error_$no_columns_defined fixed bin(35) ext static;
      483 dcl rw_options$check_name entry (ptr, char(*) var, char(*) var, bit(1) aligned, fixed bin(35));
      484 dcl rw_options$check_identifier entry (ptr, char(*) var, char(*) var, char(*) var, fixed bin(35));
      485 dcl rw_options$set_all_to_system_defaults entry (ptr, fixed bin(35));
      486 dcl rw_options$set_and_check entry (ptr, char(*) var, char(*) var, char(*) var, bit(1) aligned, fixed bin(35));

      487 
      488 dcl save_arg_number_for_hyphen_string fixed bin;
      489 dcl sci_ptr ptr;
      490 dcl ssu_$abort_line entry() options(variable);
      491 dcl ssu_$arg_count entry (ptr, fixed bin);
      492 dcl ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin(21));
      493 dcl still_adding_chunks_of_the_value bit (1) aligned;
      494 dcl still_processing_format_option_args bit (1) aligned;
      495 dcl still_processing_control_args bit (1) aligned;
      496 dcl substr builtin;

      497 
      498 dcl this_is_a_control_arg (360) bit (1) unaligned;
      499 dcl this_is_a_string_arg (360) bit (1) unaligned;

      500 
      501 dcl unspec builtin;
      502 
  1     1 /*	BEGIN INCLUDE FILE rw_options_extents.incl.pl1
  1     2*
  1     3*   Extents for the formatting options used for producing reports.
  1     4*   Kept as a separate include so that some programs may include this
  1     5*   file without including rw_format_options.incl.pl1
  1     6*
  1     7*    Al Dupuis - August 1983
  1     8*
  1     9**/
  1    10 /* format: off */

  1    11 
  1    12 /* The three types of format options that we have. */

  1    13 
  1    14 dcl GENERAL_REPORT_OPTION fixed bin static int options (constant) init (1);
  1    15 dcl GENERAL_COLUMN_OPTION fixed bin static int options (constant) init (2);
  1    16 dcl SPECIFIC_COLUMN_OPTION fixed bin static int options (constant) init (3);

  1    17 
  1    18 /* Used to determine how big the tables are without doing a hbound on it. */

  1    19 
  1    20 dcl NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (15);
  1    21 dcl NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE fixed bin static int options (constant) init (9);
  1    22 dcl NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (6);

  1    23 
  1    24 /* Used to determine how much space is needed to list them. */

  1    25 
  1    26 dcl LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (10); /* -alignment */
  1    27 dcl LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH fixed bin static int options (constant) init (25); /* -format_document_controls */
  1    28 dcl LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (21); /* -group_footer_trigger */

  1    29 
  1    30 /* MAXIMUM_OPTION_IDENTIFIER_LENGTH + MAXIMUM_OPTION_NAME_LENGTH */

  1    31 
  1    32 dcl MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH fixed bin static int options (constant) init (101);

  1    33 
  1    34 dcl MAXIMUM_OPTION_IDENTIFIER_LENGTH fixed bin static int options (constant) init (69);
  1    35 dcl MAXIMUM_OPTION_NAME_LENGTH fixed bin static int options (constant) init (32);
  1    36 dcl MAXIMUM_OPTION_VALUE_LENGTH fixed bin static int options (constant) init (4096);
  1    37 
  1    38 /* Used to index into the OPTIONS tables defined in rw_format_options.incl.pl1. */

  1    39 
  1    40 dcl INDEX_FOR_DELIMITER fixed bin static int options (constant) init (1);
  1    41 dcl INDEX_FOR_FORMAT_DOCUMENT_CONTROLS fixed bin static int options (constant) init (2);
  1    42 dcl INDEX_FOR_HYPHENATION fixed bin static int options (constant) init (3);
  1    43 dcl INDEX_FOR_PAGE_FOOTER_VALUE fixed bin static int options (constant) init (4);
  1    44 dcl INDEX_FOR_PAGE_HEADER_VALUE fixed bin static int options (constant) init (5);
  1    45 dcl INDEX_FOR_PAGE_LENGTH fixed bin static int options (constant) init (6);
  1    46 dcl INDEX_FOR_PAGE_WIDTH fixed bin static int options (constant) init (7);
  1    47 dcl INDEX_FOR_TITLE_LINE fixed bin static int options (constant) init (8);
  1    48 dcl INDEX_FOR_TRUNCATION fixed bin static int options (constant) init (9);

  1    49 
  1    50 dcl INDEX_FOR_COLUMN_ORDER fixed bin static int options (constant) init (1);
  1    51 dcl INDEX_FOR_COUNT  fixed bin static int options (constant) init (2);
  1    52 dcl INDEX_FOR_EXCLUDE fixed bin static int options (constant) init (3);
  1    53 dcl INDEX_FOR_GROUP fixed bin static int options (constant) init (4);
  1    54 dcl INDEX_FOR_GROUP_FOOTER_TRIGGER fixed bin static int options (constant) init (5);
  1    55 dcl INDEX_FOR_GROUP_FOOTER_VALUE fixed bin static int options (constant) init (6);
  1    56 dcl INDEX_FOR_GROUP_HEADER_TRIGGER fixed bin static int options (constant) init (7);
  1    57 dcl INDEX_FOR_GROUP_HEADER_VALUE fixed bin static int options (constant) init (8);
  1    58 dcl INDEX_FOR_OUTLINE fixed bin static int options (constant) init (9);
  1    59 dcl INDEX_FOR_PAGE_BREAK fixed bin static int options (constant) init (10);
  1    60 dcl INDEX_FOR_ROW_FOOTER_VALUE fixed bin static int options (constant) init (11);
  1    61 dcl INDEX_FOR_ROW_HEADER_VALUE fixed bin static int options (constant) init (12);
  1    62 dcl INDEX_FOR_SUBCOUNT fixed bin static int options (constant) init (13);
  1    63 dcl INDEX_FOR_SUBTOTAL fixed bin static int options (constant) init (14);
  1    64 dcl INDEX_FOR_TOTAL fixed bin static int options (constant) init (15);

  1    65 
  1    66 dcl INDEX_FOR_ALIGNMENT fixed bin static int options (constant) init (1);
  1    67 dcl INDEX_FOR_EDITING fixed bin static int options (constant) init (2);
  1    68 dcl INDEX_FOR_FOLDING fixed bin static int options (constant) init (3);
  1    69 dcl INDEX_FOR_SEPARATOR fixed bin static int options (constant) init (4);
  1    70 dcl INDEX_FOR_TITLE fixed bin static int options (constant) init (5);
  1    71 dcl INDEX_FOR_WIDTH fixed bin static int options (constant) init (6);

  1    72 
  1    73 /*    END INCLUDE FILE rw_options_extents */
      503 



      504 
      505      end rw_set_format_options;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/16/84  1107.3  rw_set_format_options.pl1         >special_ldd>online>7001-11/16/84>rw_set_format_options.pl1
503          1    11/16/84  1107.8  rw_options_extents.incl.pl1       >special_ldd>online>7001-11/16/84>rw_options_extents.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH  constant        fixed bin(17,0)          initial dcl 1-32 ref 471
MAXIMUM_OPTION_IDENTIFIER_LENGTH       constant        fixed bin(17,0)          initial dcl 1-34 ref 473
MAXIMUM_OPTION_NAME_LENGTH             constant        fixed bin(17,0)          initial dcl 1-35 ref 463 474
MAXIMUM_OPTION_VALUE_LENGTH            constant        fixed bin(17,0)          initial dcl 1-36 ref 423 455 475
NEWLINE                         002462 constant        char(1)                  initial unaligned dcl 430 ref 144 144 144 148
NOT_SYSTEM_DEFAULT              000024 constant        bit(1)                   initial dcl 433 set ref 152*
NO_MORE_FORMAT_ARGS_LEFT               constant        fixed bin(35,0)          initial dcl 432 ref 104 211 237 270
OFF                                    constant        bit(1)                   initial dcl 434 ref 110 271 285 322 345 346 362 363
                                                                                  391 400 405
ON                              000000 constant        bit(1)                   initial dcl 435 ref 78 99 112 312 366 375 376 387
                                                                                  389 396 398
SYSTEM_DEFAULT                  000000 constant        bit(1)                   initial dcl 436 set ref 133*
addr                                                   builtin function         dcl 438 ref 422
arg                                    based           char                     unaligned dcl 439 ref 107 114 190 216 242 373 373
                                                                                  384 384 384 384 389 389 393 393 393 393 398 398
arg_length                      000100 automatic       fixed bin(21,0)          dcl 440 set ref 107 114 114 190 216 242 274* 370*
                                                                                  373 373 384 384 384 384 389 389 393 393 393 393
                                                                                  398 398
arg_ptr                         000102 automatic       pointer                  dcl 441 set ref 107 114 190 216 242 274* 370* 373
                                                                                  373 384 384 384 384 389 389 393 393 393 393 398
                                                                                  398
brief_flag                      000104 automatic       bit(1)                   dcl 443 set ref 305 346* 398* 400*
code                            000105 automatic       fixed bin(35,0)          dcl 445 set ref 70* 71 71* 103* 104 133* 152* 158
                                                                                  158 158* 164* 167 167* 171* 182* 183 191* 193 193
                                                                                  193* 198 198* 201* 210* 211 217* 219 219 219* 224
                                                                                  224* 236* 237 270* 315* 318 318*
code_parm                              parameter       fixed bin(35,0)          dcl 258 set ref 248 260*
current_arg_number              000106 automatic       fixed bin(17,0)          dcl 446 set ref 77* 111* 264 265* 265 268 274* 276
                                                                                  277* 277 281 282* 282 285 365* 370* 375 376 378*
                                                                                  378 379 387 396 404* 404 405
error_table_$inconsistent       000010 external static fixed bin(35,0)          dcl 448 set ref 211* 379* 413*
error_table_$noarg              000012 external static fixed bin(35,0)          dcl 449 set ref 351*
error_table_$nomatch            000014 external static fixed bin(35,0)          dcl 450 ref 167
error_table_$nostars            000016 external static fixed bin(35,0)          dcl 451 ref 224
identifier_needed               000107 automatic       bit(1)                   dcl 453 set ref 158 191* 208 305
index                                                  builtin function         dcl 454 ref 144
input_buffer                    000110 automatic       char                     unaligned dcl 455 set ref 302* 322 327 422
input_buffer_length             000110 automatic       fixed bin(21,0)          dcl 456 set ref 315* 423*
input_buffer_ptr                000112 automatic       pointer                  dcl 457 set ref 315* 422*
ioa_                            000020 constant        entry                    external dcl 458 ref 305 308
iox_$get_line                   000022 constant        entry                    external dcl 459 ref 315
iox_$user_input                 000024 external static pointer                  dcl 460 set ref 315*
length                                                 builtin function         dcl 462 ref 142 144 144 148 148 332
long_option_name                000114 automatic       varying char             dcl 463 set ref 133* 152* 164* 191* 193* 211* 217*
                                                                                  219* 237* 308*
more_input                      000114 automatic       bit(1)                   dcl 465 set ref 312* 314 322* 327
normalized_option_name          000121 automatic       varying char             dcl 471 set ref 158* 217* 305*
number_of_args_supplied         000116 automatic       fixed bin(17,0)          dcl 468 set ref 73 268 285 350* 351 379 405 413
number_of_chars_read            000115 automatic       fixed bin(21,0)          dcl 467 set ref 315* 322 327
number_of_control_args          000117 automatic       fixed bin(17,0)          dcl 469 set ref 73 364* 377* 377 388* 388 397* 397
                                                                                  413
number_of_input_lines           000120 automatic       fixed bin(17,0)          dcl 470 set ref 311* 321* 321 332
option_identifier               000121 automatic       varying char             dcl 473 set ref 133* 152* 167* 216* 217* 219* 424*
option_name                     000121 automatic       varying char             dcl 474 set ref 190* 191* 198*
option_value                    000121 automatic       varying char             dcl 475 set ref 114* 114 133 133* 138 142 144 144
                                                                                  144 144 144* 144 148 148 148* 148 148 152* 158*
                                                                                  164* 242* 303* 327* 327 332* 332 332
report_cip                      000122 automatic       pointer                  dcl 477 set ref 70* 133* 152* 191* 217* 343*
report_cip_parm                        parameter       pointer                  dcl 49 ref 43 343
reset_flag                      000124 automatic       bit(1)                   dcl 478 set ref 68 345* 389* 391* 413
rw_error_$bad_option_identifier 000026 external static fixed bin(35,0)          dcl 479 ref 219
rw_error_$bad_option_name       000030 external static fixed bin(35,0)          dcl 480 ref 198
rw_error_$bad_option_value      000032 external static fixed bin(35,0)          dcl 481 set ref 158 237*
rw_error_$no_columns_defined    000034 external static fixed bin(35,0)          dcl 482 ref 193
rw_options$check_identifier     000040 constant        entry                    external dcl 484 ref 217
rw_options$check_name           000036 constant        entry                    external dcl 483 ref 191
rw_options$set_all_to_system_defaults
                                000042 constant        entry                    external dcl 485 ref 70
rw_options$set_and_check        000044 constant        entry                    external dcl 486 ref 133 152
save_arg_number_for_hyphen_string
                                000125 automatic       fixed bin(17,0)          dcl 488 set ref 107 111 133 138 276*
sci_ptr                         000126 automatic       pointer                  dcl 489 set ref 71* 158* 164* 167* 171* 183* 193*
                                                                                  198* 201* 211* 219* 224* 237* 274* 318* 342* 350*
                                                                                  351* 370* 379* 413*
sci_ptr_parm                           parameter       pointer                  dcl 50 ref 43 342
ssu_$abort_line                 000046 constant        entry                    external dcl 490 ref 71 158 164 167 171 183 193 198
                                                                                  201 211 219 224 237 318 351 379 413
ssu_$arg_count                  000050 constant        entry                    external dcl 491 ref 350
ssu_$arg_ptr                    000052 constant        entry                    external dcl 492 ref 274 370
still_adding_chunks_of_the_value
                                000130 automatic       bit(1)                   dcl 493 set ref 99* 101 110*
still_processing_control_args   000132 automatic       bit(1)                   dcl 495 set ref 366* 368 405*
still_processing_format_option_args
                                000131 automatic       bit(1)                   dcl 494 set ref 78* 80 112* 271* 285*
substr                                                 builtin function         dcl 496 ref 107 114 144 144 148 148 322 327 332
this_is_a_control_arg           000133 automatic       bit(1)                   array unaligned dcl 498 set ref 264 281 362* 375*
                                                                                  387* 396*
this_is_a_string_arg            000145 automatic       bit(1)                   array unaligned dcl 499 set ref 107 133 138 363*
                                                                                  376*
unspec                                                 builtin function         dcl 501 set ref 362* 363*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
GENERAL_COLUMN_OPTION                  internal static fixed bin(17,0)          initial dcl 1-15
GENERAL_REPORT_OPTION                  internal static fixed bin(17,0)          initial dcl 1-14
INDEX_FOR_ALIGNMENT                    internal static fixed bin(17,0)          initial dcl 1-66
INDEX_FOR_COLUMN_ORDER                 internal static fixed bin(17,0)          initial dcl 1-50
INDEX_FOR_COUNT                        internal static fixed bin(17,0)          initial dcl 1-51
INDEX_FOR_DELIMITER                    internal static fixed bin(17,0)          initial dcl 1-40
INDEX_FOR_EDITING                      internal static fixed bin(17,0)          initial dcl 1-67
INDEX_FOR_EXCLUDE                      internal static fixed bin(17,0)          initial dcl 1-52
INDEX_FOR_FOLDING                      internal static fixed bin(17,0)          initial dcl 1-68
INDEX_FOR_FORMAT_DOCUMENT_CONTROLS     internal static fixed bin(17,0)          initial dcl 1-41
INDEX_FOR_GROUP                        internal static fixed bin(17,0)          initial dcl 1-53
INDEX_FOR_GROUP_FOOTER_TRIGGER         internal static fixed bin(17,0)          initial dcl 1-54
INDEX_FOR_GROUP_FOOTER_VALUE           internal static fixed bin(17,0)          initial dcl 1-55
INDEX_FOR_GROUP_HEADER_TRIGGER         internal static fixed bin(17,0)          initial dcl 1-56
INDEX_FOR_GROUP_HEADER_VALUE           internal static fixed bin(17,0)          initial dcl 1-57
INDEX_FOR_HYPHENATION                  internal static fixed bin(17,0)          initial dcl 1-42
INDEX_FOR_OUTLINE                      internal static fixed bin(17,0)          initial dcl 1-58
INDEX_FOR_PAGE_BREAK                   internal static fixed bin(17,0)          initial dcl 1-59
INDEX_FOR_PAGE_FOOTER_VALUE            internal static fixed bin(17,0)          initial dcl 1-43
INDEX_FOR_PAGE_HEADER_VALUE            internal static fixed bin(17,0)          initial dcl 1-44
INDEX_FOR_PAGE_LENGTH                  internal static fixed bin(17,0)          initial dcl 1-45
INDEX_FOR_PAGE_WIDTH                   internal static fixed bin(17,0)          initial dcl 1-46
INDEX_FOR_ROW_FOOTER_VALUE             internal static fixed bin(17,0)          initial dcl 1-60
INDEX_FOR_ROW_HEADER_VALUE             internal static fixed bin(17,0)          initial dcl 1-61
INDEX_FOR_SEPARATOR                    internal static fixed bin(17,0)          initial dcl 1-69
INDEX_FOR_SUBCOUNT                     internal static fixed bin(17,0)          initial dcl 1-62
INDEX_FOR_SUBTOTAL                     internal static fixed bin(17,0)          initial dcl 1-63
INDEX_FOR_TITLE                        internal static fixed bin(17,0)          initial dcl 1-70
INDEX_FOR_TITLE_LINE                   internal static fixed bin(17,0)          initial dcl 1-47
INDEX_FOR_TOTAL                        internal static fixed bin(17,0)          initial dcl 1-64
INDEX_FOR_TRUNCATION                   internal static fixed bin(17,0)          initial dcl 1-48
INDEX_FOR_WIDTH                        internal static fixed bin(17,0)          initial dcl 1-71
LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 1-28
LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 1-27
LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 1-26
NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE
                                       internal static fixed bin(17,0)          initial dcl 1-20
NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE
                                       internal static fixed bin(17,0)          initial dcl 1-21
NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE
                                       internal static fixed bin(17,0)          initial dcl 1-22
SPECIFIC_COLUMN_OPTION                 internal static fixed bin(17,0)          initial dcl 1-16

NAMES DECLARED BY EXPLICIT CONTEXT.
get_accumulated_input           000544 constant        entry                    internal dcl 87 ref 141
get_and_or_set_the_value        000641 constant        entry                    internal dcl 123 ref 82
get_argument_set                001220 constant        entry                    internal dcl 178 ref 81
get_next_format_arg             001663 constant        entry                    internal dcl 248 ref 103 182 210 236
get_prompted_input              001742 constant        entry                    internal dcl 292 ref 138
initialize                      002132 constant        entry                    internal dcl 340 ref 66
rw_set_format_options           000300 constant        entry                    external dcl 43

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2722        2776    2465        2732
Length      3244    2465        54         231     234           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rw_set_format_options               426 external procedure  is an external procedure.  
get_accumulated_input                   internal procedure  shares stack frame of external procedure rw_set_format_options.  
get_and_or_set_the_value                internal procedure  shares stack frame of external procedure rw_set_format_options.  
get_argument_set                        internal procedure  shares stack frame of external procedure rw_set_format_options.  
get_next_format_arg                     internal procedure  shares stack frame of external procedure rw_set_format_options.  
get_prompted_input                      internal procedure  shares stack frame of external procedure rw_set_format_options.  
initialize                              internal procedure  shares stack frame of external procedure rw_set_format_options.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rw_set_format_options    000100 arg_length                  rw_set_format_options
                         000102 arg_ptr                     rw_set_format_options
                         000104 brief_flag                  rw_set_format_options
                         000105 code                        rw_set_format_options
                         000106 current_arg_number          rw_set_format_options
                         000107 identifier_needed           rw_set_format_options
                         000110 input_buffer                rw_set_format_options
                         000110 input_buffer_length         rw_set_format_options
                         000112 input_buffer_ptr            rw_set_format_options
                         000114 long_option_name            rw_set_format_options
                         000114 more_input                  rw_set_format_options
                         000115 number_of_chars_read        rw_set_format_options
                         000116 number_of_args_supplied     rw_set_format_options
                         000117 number_of_control_args      rw_set_format_options
                         000120 number_of_input_lines       rw_set_format_options
                         000121 normalized_option_name      rw_set_format_options
                         000121 option_identifier           rw_set_format_options
                         000121 option_name                 rw_set_format_options
                         000121 option_value                rw_set_format_options
                         000122 report_cip                  rw_set_format_options
                         000124 reset_flag                  rw_set_format_options
                         000125 save_arg_number_for_hyphen_string
                                                            rw_set_format_options
                         000126 sci_ptr                     rw_set_format_options
                         000130 still_adding_chunks_of_the_value
                                                            rw_set_format_options
                         000131 still_processing_format_option_args
                                                            rw_set_format_options
                         000132 still_processing_control_args
                                                            rw_set_format_options
                         000133 this_is_a_control_arg       rw_set_format_options
                         000145 this_is_a_string_arg        rw_set_format_options

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return
alloc_auto_adj      shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          iox_$get_line                 rw_options$check_identifier   rw_options$check_name
rw_options$set_all_to_system_defaults                       rw_options$set_and_check      ssu_$abort_line
ssu_$arg_count                ssu_$arg_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$inconsistent     error_table_$noarg            error_table_$nomatch          error_table_$nostars
iox_$user_input               rw_error_$bad_option_identifier                             rw_error_$bad_option_name
rw_error_$bad_option_value    rw_error_$no_columns_defined




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000274       455 000305       463 000314       471 000324       473 000334       474 000344       475 000354
    133 000364       152 000375       158 000406       164 000414       167 000422       191 000425       193 000433
    198 000436       211 000441       217 000444       219 000455       237 000463       305 000466       308 000471
     66 000474        68 000475        70 000477        71 000510        73 000527        77 000532        78 000534
     80 000536        81 000540        82 000541        83 000542        85 000543        87 000544        99 000545
    101 000547       103 000552       104 000554       107 000560       110 000572       111 000573       112 000576
    113 000600       114 000601       117 000636       119 000640       123 000641       133 000642       138 000720
    141 000732       142 000733       144 000735       147 000767       148 000770       152 001004       158 001044
    164 001112       167 001150       171 001203       174 001217       178 001220       182 001221       183 001223
    190 001252       191 001264       193 001316       198 001354       201 001407       208 001423       210 001426
    211 001430       216 001464       217 001476       219 001531       224 001574       236 001612       237 001614
    242 001650       244 001662       248 001663       260 001665       264 001666       265 001673       266 001674
    268 001675       270 001700       271 001702       272 001703       274 001704       276 001721       277 001724
    281 001725       282 001733       283 001734       285 001735       288 001741       292 001742       302 001743
    303 001750       305 001751       308 002002       311 002025       312 002026       314 002030       315 002032
    318 002051       321 002070       322 002071       327 002101       330 002117       332 002120       336 002131
    340 002132       342 002133       343 002137       345 002142       346 002143       350 002144       351 002155
    362 002203       363 002206       364 002211       365 002212       366 002214       368 002216       370 002220
    373 002235       375 002247       376 002253       377 002256       378 002257       379 002260       383 002307
    384 002310       387 002335       388 002341       389 002342       391 002347       392 002350       393 002351
    396 002375       397 002401       398 002402       400 002407       404 002410       405 002411       408 002415
    413 002416       422 002447       423 002451       424 002453       426 002454


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
