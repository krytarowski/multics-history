	COMPILATION LISTING OF SEGMENT adjust_mrds_db
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/23/86  1013.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 adjust_mrds_db: amdb: proc;
       19 
       20 /* DESCRIPTION:
       21*
       22*   This routine is the  command  interface  which  will  adjust  the
       23*   specified data base.
       24*
       25*   If the -reset option is specified, then the dbc is  examined.  If
       26*   any  active  users  are discovered, the requestor is asked if she
       27*   really wishes to reset the dbc. If so, then the  dbc  segment  is
       28*   truncated and reinitialized.
       29*
       30*   The  requestor  should realize that the -reset option will remove
       31*   ALL  users from the data base, so care should be taken to execute
       32*   this command only when the data base is not being used by anyone.
       33*   Amdb  will  check to see if there are active or open users of the
       34*   database and will warn the requestor if this is the case.
       35*
       36*   The -trouble_switch control arg can be used with both  -reset  or
       37*   -dpr,  or  alone.  The -trouble_switch off option will cause only
       38*   the trouble_switch and possibly the scope_lock (both of the  dbc)
       39*   to   be  reset.  The  -trouble_switch  on  option  will  set  the
       40*   trouble_switch to ON.
       41*
       42*   The -dead_processs option will allow for removal  of  all  'dead'
       43*   users  from  the  dbc  and  can be invoked while the data base is
       44*   being used by others.
       45*
       46*   If the database is marked as being inconsistent, The requestor is
       47*   warned  about  this  and  given the reason stored in the database
       48*   before the amdb request is completed.
       49*
       50**/
       51 
       52 /* HISTORY:
       53*
       54*   Originally written by Oris D. Friesen in August 1977
       55*
       56*   Modified by Al Kepner, March 12, 1979, to work with MR7.0 version
       57*   data bases.
       58*
       59*   Modified by M. Pierret, 5 December, 1979, to :  make  -reset  the
       60*   default  operation;  restructure the program; require the user to
       61*   have sma access on database directory.
       62*
       63*   Modified  by  M.  Pierret  April  1980  to:  add  -dead_procs   ,
       64*   -trouble_switch on/off options; change use of locks.
       65*
       66*   Modified by Jim Gray - - May 1980, to handle case of only -tsw on
       67*   being given as the control argument.
       68*
       69*   Modified by Jim Gray - - June 1980, to fix logic that makes  user
       70*   have sma on the database directory(not the db containing dir).
       71*
       72*   Modified by Jim Gray - - 21-June-80, to report no model,  not  no
       73*   model/submodel err mesg
       74*
       75*   80-12-09  Jim  Gray : took truncation task out of AMDB and put in
       76*   common module mu_concurrency_control$reset_control_segment.  Also
       77*   made  getting  of  the  dbc_ptr  able  to  find either a "dbc" or
       78*   "db.control"  named  segment  for  hanlding either version 4 or 5
       79*   dbcs.             This           was           done           via
       80*   mu_concurrency_control$get_control_segment.
       81*
       82*   80-12-12 Jim Gray : Updated usage message to include  -dead_procs
       83*   and -trouble_switch.
       84*
       85*   80-12-24 Jim Gray : improved error messages for  null  or  r-only
       86*   access on database control segment.
       87*
       88*   81-01-27 Jim Gray : added usage of dsl_$get_path_info to  correct
       89*   problems   with   dsl_$get_db_version,   and   added   usage   of
       90*   dmd_$get_authorization as part of dba proposal implementation.
       91*
       92*   81-04-27 Jim Gray : added -force and -no_force control  arguments
       93*   for  optionally  over-riding  the  query, when active users exist
       94*   These  controls  imply  -reset.  Changed   to   allow   duplicate
       95*   -reset/-force/-no_force  control  arguments  for  over-riding  in
       96*   ec's, and for force option to make sense.
       97*
       98*   82-04-30  Mike  Kubicar  : amdb now checks the consistency bit in
       99*   the db_model segment and prints a warning message if the database
      100*   is  inconsistent.   Included in the message is the message placed
      101*   in  the  database  describing  the  reason for the inconsistency.
      102*   After  the  warning message is printed, the command completes its
      103*   function normally.
      104*
      105*   82-05-10  Mike Kubicar : Also changed to check the user list on a
      106*   reset  to  determine  more  presicely  what type of users will be
      107*   affected.  A distinction is made between dead and living users.
      108*
      109*   82-07-01  Roger Lackey : Modified the calls to mu_db_inconsistent to use
      110*   mdbm_util_$inconsistent_* for binding.
      111*
      112*   83-06-21 Davids: Removed check for old version database and the call
      113*   to v1 code if it was an old version db (old version dbs can no longer
      114*   be opened)
      115*
      116*   84-09-05 Thanh Nguyen: Modified code not to restrict to the position
      117*   of path name. 
      118*
      119*   84-09-14 Paul Benjamin: Further modification to make sure that only one
      120*   pathname is accepted.
      121**/
      122 
      123 /* Check number of arguments. There must be from 1 to 5 arguments, like so:
      124*   *     amdb <db_path> [ -reset (,-rs) -trouble_switch (,-tsw) on/off
      125*   *                    | -dead_procs (,-dpr) -tsw on/off
      126*   *		 | -trouble_switch (,-tsw) on/off  | -force | -no_force */
      127 
      128 
      129 	call cu_$arg_count (n_args);
      130 	if n_args < 1				/* must be at least 2 args: db_path and a control arg */
      131 	then call error (0,
      132 		"Usage:  amdb db_path {{-dead_procs|-reset{-force}}{-trouble_switch on/off}}");
      133 
      134 	if n_args > 5
      135 	then call error (error_table_$too_many_args, "");
      136 
      137 	db_dir = copy (" ", 168);
      138 	code = 0;
      139 	path_name_sw = "0"b;
      140 	do idx = 1 to n_args while (code = 0);
      141 	     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      142 	     if code ^= 0 then call error (code, "control argument");
      143 	     if index (arg, "-") = 1 then do;
      144 		if arg = "-reset" | arg = "-rs"
      145 		then if dead_process_sw
      146 		     then call error (error_table_$inconsistent, arg);
      147 		     else reset_sw = ON;
      148 
      149 		else if arg = "-dead_procs" | arg = "-dpr"
      150 		     then if reset_sw
      151 			then call error (error_table_$inconsistent, arg);
      152 			else dead_process_sw = ON;
      153 
      154 
      155 		     else if arg = "-trouble_switch" | arg = "-tsw"
      156 			then do;
      157 			     if idx < n_args
      158 			     then idx = idx + 1;
      159 			     else call error (error_table_$badopt, "");
      160 
      161 			     call cu_$arg_ptr (idx, arg_ptr, arg_len, code);
      162 			     if code ^= 0
      163 			     then call error (code, "control argument");
      164 
      165 			     if arg = "on"
      166 			     then trouble_sw_on = ON;
      167 			     else if arg ^= "off"
      168 				then call error (error_table_$badopt, arg);
      169 			          else ;
      170 			end;
      171 
      172 /* BEGIN CHANGE 81-04-27 *************************************** */
      173 
      174 		     else if arg = "-force" | arg = "-fc" then do;
      175 			     reset_sw, force_option = ON;
      176 			     if dead_process_sw then
      177 				call error (error_table_$inconsistent, arg);
      178 			end;
      179 
      180 		     else if arg = "-no_force" | arg = "-nfc" then do;
      181 			     force_option = OFF;
      182 			     reset_sw = ON;
      183 			     if dead_process_sw then
      184 				call error (error_table_$inconsistent, arg);
      185 			end;
      186 
      187 /* END CHANGE 81-04-27 ********************************************** */
      188 
      189 		     else call error (error_table_$badopt, arg);
      190 
      191 	     end;
      192 	     else do;
      193 		if path_name_sw			/* pathname already given */
      194 		     then call error (error_table_$bad_arg, arg);
      195 		path_name_sw = "1"b;
      196 		dbp_ptr = arg_ptr;
      197 		dbp_len = arg_len;
      198 		in_path = dbp;
      199 
      200 		/* check mrds version and path type */
      201 		call mrds_dsl_get_version$get_path_info (in_path, addr (local_area),
      202 		     mrds_path_info_structure_version, mrds_path_info_ptr, code);
      203 		if mrds_path_info_ptr = null () then
      204 		     db_path = in_path;
      205 		else db_path = mrds_path_info.absolute_path;
      206 		if code ^= 0 then do;
      207 		     if code = mrds_error_$no_model_submodel then
      208 			code = mrds_error_$no_database;
      209 		     call error (code, db_path);
      210 		end;
      211 
      212 		if mrds_path_info.type.submodel then
      213 		     call error (error_table_$badcall,
      214 		     "Data submodels are not supported by this command.  " || db_path);
      215 
      216 /* END CHANGE 81-01-27 ************************************************ */
      217 
      218 		call expand_pathname_ (db_path, db_dir, db_ent, code);
      219 		if code ^= 0 then call error (code, db_path);	/* return to command level */
      220 		
      221 		if length (rtrim (db_path)) > 164		/* must allow path <db_path>>dbc totalling <= 168 chars */
      222 		     then call error (error_table_$pathlong, db_path);
      223 
      224 /* Get control arg, set appropriate switch for later use */
      225 
      226 		if n_args = 1
      227 		     then reset_sw = ON;
      228 	     end;
      229 
      230 	end;
      231 	if path_name_sw = "0"b then
      232 	     call error (0, "data base path name is missing."); /* exit with error message */
      233 
      234 /* BEGIN CHANGE 81-01-27 ********************************************* */
      235 /* make sure the user is a DBA */
      236 
      237 	call mrds_dm_authorization$get_user_class (rtrim (db_path),
      238 	     addr (local_area),
      239 	     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      240 	if code ^= 0 then
      241 	     call error (code, "Unable to get user class for database """ || rtrim (db_path) || """");
      242 
      243 	else if ^mrds_authorization.administrator then
      244 	     call error (error_table_$insufficient_access,
      245 		"User must be a database administrator to perform this operation on the database " || rtrim (db_path));
      246 
      247 /* END CHANGE 81-01-27 ************************************************ */
      248 
      249 
      250 
      251 /* Check to see if inconsistent bit is set */
      252 	call mrds_dm_open (rtrim (db_path), RETREIVE_MODE, dm_ptr, code);
      253 	if code ^= 0 then call error (code,
      254 		"Unable to get a pointer to database model segment");
      255 	call mdbm_util_$inconsistent_get_info (dm_ptr, inconsistent_value,
      256 	     inconsistent_name, inconsistent_message, inconsistent_undo);
      257 	if inconsistent_value then do;
      258 		if inconsistent_message = " "
      259 		then call ioa_ ("adjust_mrds_db: Warning, the database is inconsistent.  No reason was given.");
      260 		else do;
      261 			call ioa_ ("adjust_mrds_db: Warning, the database is inconsistent for the following reason:");
      262 			call ioa_ ("^a.", inconsistent_message);
      263 		     end;
      264 		call ioa_ ("^/Please refer to restructure_mrds_db to repair it.");
      265 	     end;
      266 
      267 
      268 /* Get dbc_ptr */
      269 	call mu_concurrency_control$get_control_segment (db_path, dbc_ptr, dbc_bit_count, code);
      270 	if code ^= 0 then
      271 	     call error (code, "Unable to get a pointer to the database control segment.");
      272 
      273 /* Attempt to lock dbc */
      274 
      275 	locked = OFF;
      276 	call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), code);
      277 	if code = error_table_$invalid_lock_reset |
      278 	     code = error_table_$locked_by_this_process
      279 	then code = 0;
      280 
      281 
      282 /* only set trouble switch or ... */
      283 
      284 	if trouble_sw_on & ^dead_process_sw & ^reset_sw then
      285 	     call set_trouble (code);
      286 
      287 /* Remove all dead procs or.... */
      288 
      289 	else if dead_process_sw
      290 	then call remove_dead_processes (code);
      291 
      292 
      293 /* ..Reset whole dbc */
      294 
      295 	else if reset_sw
      296 	then call reset_dbc (code);
      297 
      298 /* ..Reset trouble switch */
      299 
      300 	else if ^trouble_sw_on
      301 	then call reset_trouble (code);
      302 
      303 
      304 exit:
      305 	if locked
      306 	then call set_lock_$unlock (dbc.scope_lock, code);
      307 
      308 	return;
      309 
      310 
      311 reset_dbc: proc (icode);
      312 
      313 	dcl     icode		 fixed bin (35);
      314 
      315 	if icode ^= 0
      316 	then do;
      317 		clear_lock_sw = ON;
      318 		icode = 0;
      319 	     end;
      320 	else locked = ON;
      321 
      322 
      323 /* If the force option is not in effect, check to make sure there will be
      324*   no users affected by a reset.  Scan through the open and active user
      325*   lists to determine this.  Any dead users with no active scope can be
      326*   ignored.  If users that will be affected are found, tell the user so
      327*   and ask if he still wants to continue.  If both open and scope locks
      328*   cannot be set, assume that someone is in the process of becoming
      329*   active or open.  */
      330 
      331 	if ^force_option then do;
      332 		call set_lock_$lock (dbc.proper.open_lock,
      333 		     (mrds_data_$lock_wait_time), code);
      334 		open_lock_set = (code = 0) |
      335 		     (code = error_table_$invalid_lock_reset) |
      336 		     (code = error_table_$locked_by_this_process);
      337 		found_quiesced, found_active, found_open,
      338 		     found_dead_active = OFF;
      339 		if locked
      340 		then if dbc.proper.user_counts.active_users > 0
      341 		     then do;
      342 			     current_user_offset = dbc.proper.offsets.
      343 				active_users_ofs;
      344 			     do while ((current_user_offset ^= NULL_OFS) &
      345 				(^found_active | (found_active &
      346 				^found_dead_active)));
      347 				current_user_ptr = pointer (dbc_ptr,
      348 				     current_user_offset);
      349 				if current_user_ptr -> user_list.flags.
      350 				     dead_proc
      351 				then found_dead_active = ON;
      352 				else if process_dead (current_user_ptr
      353 					-> user_list.ids.db_lock_id)
      354 				then found_dead_active = ON;
      355 				else found_active = ON;
      356 				current_user_offset = current_user_ptr
      357 				     -> user_list.offsets.next_active_ofs;
      358 			     end;
      359 			end;
      360 		if open_lock_set & ^found_active
      361 		then if dbc.proper.user_counts.open_users > 0
      362 		     then do;
      363 			     current_user_offset = dbc.proper.offsets.
      364 				open_users_ofs;
      365 			     do while ((current_user_offset ^= NULL_OFS) &
      366 				^found_open);
      367 				current_user_ptr = pointer (dbc_ptr,
      368 				     current_user_offset);
      369 				if ^current_user_ptr -> user_list.
      370 				     flags.dead_proc then found_open
      371 					= ^process_dead (current_user_ptr
      372 					-> user_list.ids.db_lock_id);
      373 				current_user_offset
      374 				     = current_user_ptr
      375 				     -> user_list.offsets.next_open_ofs;
      376 			     end;
      377 			end;
      378 
      379 
      380 /* Now tell the user what we've found */
      381 
      382 		if found_active
      383 		then call ioa_ ("There are active users that may be affected if you reset the database.");
      384 		else if found_open
      385 		then call ioa_ ("There are open users that may be affected if you reset the database.");
      386 		if ^locked
      387 		then call ioa_ ("There may be active users of the database.");
      388 		else if ^open_lock_set & ^found_active
      389 		then call ioa_ ("There may be open users of the database.");
      390 		if found_dead_active
      391 		then call ioa_ ("There are dead processes with active scope set.");
      392 
      393 
      394 /* Check for quiescing too */
      395 
      396 		call set_lock_$lock (dbc.proper.quiesce_lock,
      397 		     DONT_WAIT, code);
      398 		if code = error_table_$lock_wait_time_exceeded then do;
      399 			found_quiesced = ON;
      400 			if dbc.proper.flags.quiesce_sw
      401 			then call ioa_ ("Another DBA has quiesced the database.");
      402 			else call ioa_ ("Another DBA is waiting to quiesce the database.");
      403 		     end;
      404 
      405 		if ^locked | ^open_lock_set | found_active | found_open
      406 		     | found_dead_active | found_quiesced then do;
      407 			call command_query_$yes_no (
      408 			     reset_db_response, 0,
      409 			     "adjust_mrds_db",
      410 			     "Any current users of ^a will be affected if you reset the database.  Continue?",
      411 			     "Do you still wish to reset ^a?", db_path);
      412 			if ^reset_db_response then do;
      413 				if open_lock_set then do;
      414 					call set_lock_$unlock (dbc.proper.
      415 					     open_lock, code);
      416 					if code ^= 0
      417 					then call error (code,
      418 						"unlocking database");
      419 				     end;
      420 				return;
      421 			     end;
      422 		     end;
      423 
      424 /* Note that the scope lock is unlocked by the calling procedure if the
      425*   the answer was no.  If yes, everything is unlocked by the reset. */
      426 
      427 	     end;
      428 
      429 
      430 /* Reset the data base
      431*   this causes the control segment to be truncated
      432*   and then re-initialized with the latest version of the dbc structures
      433*   the name of the control segment is also changed if necessary */
      434 
      435 
      436 	call mu_concurrency_control$reset_control_segment (db_path, dbc_ptr, dbc_bit_count, icode);
      437 
      438 	if icode ^= 0 then call error (icode, "Unable to re-initialize database control segment.");
      439 
      440 /* Set trouble switch if asked */
      441 
      442 	if trouble_sw_on
      443 	then dbc.trouble_switch = ON;
      444 
      445 
      446 
      447      end reset_dbc;
      448 
      449 remove_dead_processes: proc (icode);
      450 
      451 /*
      452*   This routine will go through the dbc lists, removing dead dead_processs
      453**/
      454 
      455 	dcl     dead_sw		 bit (1);
      456 	dcl     icode		 fixed bin (35);
      457 	dcl     saved_ul_ptr	 ptr;
      458 	dcl     ulo_ptr		 ptr;
      459 
      460 
      461 
      462 /* Test for success of locking */
      463 
      464 	if icode ^= 0
      465 	then call error (icode, "");
      466 	else locked = ON;
      467 
      468 
      469 /* Search through open users list, looking for dead procs and cleaning them up */
      470 
      471 	ulo_ptr = addr (dbc.open_users_ofs);
      472 	ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
      473 	do while (ul_ptr ^= null);
      474 	     if user_list.dead_proc			/* Find out if user is dead */
      475 	     then dead_sw = ON;
      476 	     else do;
      477 		     call set_lock_$lock ((user_list.db_lock_id), 0, icode);
      478 		     if icode = error_table_$invalid_lock_reset
      479 		     then dead_sw = ON;
      480 		     else dead_sw = OFF;
      481 		end;
      482 
      483 /*  If user is dead, get rid of her */
      484 
      485 	     if dead_sw
      486 	     then do;
      487 
      488 		     if user_list.event_signal_sw	/* Is waking up */
      489 		     then dbc.wakeup_waiters = dbc.wakeup_waiters - 1;
      490 
      491 /* Remove user from all lists, decrement totals, free structures */
      492 
      493 		     saved_ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      494 		     call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, icode);
      495 		     ul_ptr = saved_ul_ptr;
      496 		end;
      497 
      498 	     else do;
      499 		     ulo_ptr = addr (user_list.next_open_ofs);
      500 		     ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      501 		end;
      502 
      503 	end /* End search through open list */;
      504 
      505 
      506 /* Removal of all dead procs resolves any dead proc conflicts */
      507 
      508 	dbc.flags.dead_proc_flag = OFF;
      509 
      510 /* Set trouble switch if asked */
      511 
      512 	if trouble_sw_on
      513 	then dbc.trouble_switch = ON;
      514 
      515 
      516      end remove_dead_processes;
      517 
      518 set_trouble: procedure (icode);
      519 
      520 /* this routine sets the trouble switch, when that
      521*   is all that is to be done */
      522 
      523 	declare icode		 fixed bin (35);
      524 
      525 /* test for success of locking */
      526 
      527 	if icode ^= 0 then
      528 	     call error (icode, "locking");
      529 	else locked = ON;
      530 
      531 	dbc.trouble_switch = ON;
      532 
      533      end;
      534 
      535 reset_trouble: proc (icode);
      536 
      537 	dcl     icode		 fixed bin (35);
      538 
      539 
      540 /* Test for success of locking; failure means scope_lock must be reset */
      541 
      542 	if icode ^= 0
      543 	then dbc.scope_lock = CLEAR;
      544 	else locked = ON;
      545 
      546 /* Reset trouble switch */
      547 
      548 	if dbc.flags.trouble_switch
      549 	then dbc.flags.trouble_switch = OFF;
      550 
      551 /* Clear scope lock, if necessary */
      552 
      553 	if clear_lock_sw
      554 	then dbc.scope_lock = CLEAR;
      555 
      556      end reset_trouble;
      557 
      558 convert: proc (a_ptr, ofs) returns (ptr);
      559 
      560 /* this procedure function converts an offset from "0"b to null
      561*   or from the offset value to a pointer value within the segment denoted by a_ptr
      562**/
      563 
      564 	dcl     result		 ptr;		/* the reultant pointer value */
      565 	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
      566 	dcl     ofs		 bit (18) unal;	/* the bit offset */
      567 
      568 	dcl     (null, ptr)		 builtin;
      569 
      570 	if ofs ^= NULL_OFS
      571 	then result = ptr (a_ptr, ofs);
      572 	else result = null;
      573 
      574 	return (result);
      575 
      576      end convert;
      577 
      578 error: proc (icode, string);
      579 
      580 	dcl     icode		 fixed bin (35);
      581 	dcl     string		 char (*);
      582 
      583 	call com_err_ (icode, "adjust_mrds_db", "^/^a", string);
      584 
      585 	goto exit;				/* return */
      586 
      587      end error;
      588 
      589 process_dead:
      590      proc (lock_id) returns (bit (1));
      591 
      592 /* This procedure check to see the process whose lock id is "lock_id"
      593*   is a live process */
      594 
      595 	dcl     icode		 fixed bin (35);
      596 	dcl     lock_id		 bit (36) aligned;
      597 	dcl     temp_lock		 bit (36) aligned;
      598 
      599 	temp_lock = lock_id;
      600 	call set_lock_$lock (temp_lock, DONT_WAIT, icode);
      601 	return (icode = error_table_$invalid_lock_reset);
      602      end process_dead;
      603 
      604 	dcl     (n_args,				/* nbr arguments in command string */
      605 	        dbp_len,				/* length of data base path */
      606 	        arg_len)		 fixed bin;	/* len of arg in chars */
      607 
      608 
      609 	dcl     (dbp_ptr,				/* ptr to data base path */
      610 	        arg_ptr)		 ptr;		/* ptr to control argument */
      611 
      612 	dcl     code		 fixed bin (35);	/* Error code returned */
      613 	dcl     db_dir		 char (168);	/* containing directory pathname of the data base */
      614 	dcl     db_ent		 char (32);	/* entry name of the data base */
      615 	dcl     cont_dir_ent	 char (32) init (""); /* containing dir entry */
      616 	dcl     cont_dir_dir	 char (168) init (""); /* containing dir of the containing dir */
      617 
      618 	dcl     in_path		 char (168) init (""); /* db pathname argument, in form suitable for passing */
      619 	dcl     db_path		 char (168) init (""); /* absolute pathname of data base */
      620 	dcl     db_path_var		 char (202) varying init (""); /* data base pathname made up of concatenation of dir and entry name */
      621 
      622 	dcl     arg		 char (arg_len) based (arg_ptr);
      623 	dcl     dbp		 char (dbp_len) based (dbp_ptr);
      624 
      625 	dcl     idx		 fixed bin;
      626 
      627 	dcl     reset_sw		 bit (1) init ("0"b); /* -rs=>reset dbc */
      628 	dcl     trouble_sw_on	 bit (1) init ("0"b); /* -tsw=>trouble switch on/off */
      629 	dcl     dead_process_sw	 bit (1) init ("0"b); /* -dpr=>remove only dead processes  */
      630 	dcl     clear_lock_sw	 bit (1) init ("0"b); /* scope_lock is damaged */
      631 	dcl     locked		 bit (1) init ("0"b); /* scope_lock has been locked - must unlock on error */
      632 	dcl     dm_ptr		 ptr;		/* pointer to db_model segment */
      633 	dcl     inconsistent_value	 bit (1);		/* The value of the inconsistency bit in db_model */
      634 	dcl     inconsistent_name	 char (32);	/* The program which set the database inconsistent */
      635 	dcl     inconsistent_message	 char (500);	/* The text message explaining the inconsistency */
      636 	dcl     inconsistent_undo	 char (500);	/* The request to remove the inconsistency */
      637 	dcl     open_lock_set	 bit (1);		/* Did amdb lock the open_lock of the dbc */
      638 	dcl     current_user_ptr	 ptr;		/* Pointer to current node in user_list list */
      639 	dcl     current_user_offset	 bit (18);	/* The corresponding offset */
      640 	dcl     found_active	 bit (1);		/* Were any active database users found */
      641 	dcl     found_open		 bit (1);		/* Any open users */
      642 	dcl     found_dead_active	 bit (1);		/* Any dead users with active scope */
      643 	dcl     found_quiesced	 bit (1);		/* Anybody quiescing the database */
      644 	dcl     reset_db_response	 bit (1);		/* Response from continue query */
      645           dcl     path_name_sw           bit (1);           /* Path name missing or not */
      646                                                             /* Builtins */
      647 
      648 	dcl     (index, copy, null, addr, empty, rtrim, length, pointer) builtin;
      649 
      650 /* Constants */
      651 
      652 	dcl     OFF		 bit (1) init ("0"b) int static options (constant);
      653 	dcl     ON		 bit (1) init ("1"b) int static options (constant);
      654 	dcl     CLEAR		 bit (36) init ("000000000000000000000000000000000000"b)
      655 				 int static options (constant);
      656 	dcl     RETREIVE_MODE	 fixed bin init (2) int static options (constant); /* Opening mode for mrds_dm_open */
      657 	dcl     DONT_WAIT		 fixed bin init (0) int static options (constant); /* Don't wait on locking operations */
      658 
      659 	dcl     mrds_data_$lock_wait_time ext fixed bin (35);
      660 
      661 	dcl     sys_info$max_seg_size	 fixed bin ext;
      662 
      663           dcl     error_table_$bad_arg fixed bin(35) ext static;
      664 	dcl     error_table_$badopt	 ext fixed bin (35);
      665 	dcl     error_table_$inconsistent ext fixed bin (35);
      666 	dcl     error_table_$insufficient_access ext fixed bin (35);
      667 	dcl     error_table_$invalid_lock_reset ext fixed bin (35);
      668 	dcl     error_table_$locked_by_this_process ext fixed bin (35);
      669 	dcl     error_table_$lock_wait_time_exceeded fixed bin (35) ext static;
      670 	dcl     error_table_$pathlong	 ext fixed bin (35);
      671 	dcl     error_table_$too_many_args ext fixed bin (35);
      672 
      673 
      674 /* Entries */
      675 
      676 
      677 	dcl     command_query_$yes_no	 entry options (variable);
      678 	dcl     com_err_		 entry options (variable);
      679 	dcl     cu_$arg_count	 entry (fixed bin);
      680 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      681 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      682 	dcl     ioa_		 entry () options (variable);
      683 	dcl     mdbm_util_$inconsistent_get_info entry (ptr, bit (1), char (*), char (*), char (*));
      684 	dcl     mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35));
      685 	dcl     mu_de_queue_user	 entry (bit (1), bit (1), ptr, ptr, fixed bin (35));
      686 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      687 	dcl     set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
      688 	declare mrds_error_$no_model_submodel fixed bin (35) ext; /* model or submodel */
      689 	declare mrds_error_$no_database fixed bin (35) ext; /* model only */
      690 
      691 	declare (mu_concurrency_control$get_control_segment, mu_concurrency_control$reset_control_segment)
      692 				 entry (char (*), ptr, fixed bin (24), fixed bin (35)); /* gets dbc_ptr/ reset dbc structures */
      693 	declare dbc_bit_count	 fixed bin (24);	/* unused */
      694 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* tells if user DBA */
      695 	declare local_area		 area (1024);	/* space for various mrds structures */
      696 	declare mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin,
      697 				 ptr, fixed bin (35)); /* finds db version */
      698 	declare error_table_$badcall	 fixed bin (35) ext;/* improper call */
      699 	declare force_option	 bit (1) init ("0"b);  /* on => dont query user */
      700 
  1     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Modified by odf for new version data bases in August 1978
  1     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  1     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  1     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  1     9*
  1    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  1    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  1    12**/
  1    13 
  1    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  1    15     2 proper,
  1    16       3 version fixed bin,				/* version number of this structure */
  1    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  1    18       3 flags,
  1    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  1    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  1    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  1    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  1    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  1    24         4 pad bit (31) unal,				/* reserved for future use */
  1    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  1    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  1    27*						   received it */
  1    28       3 user_counts,
  1    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  1    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  1    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  1    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  1    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  1    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  1    35       3 pad2 bit (144),
  1    36       3 offsets,
  1    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  1    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  1    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  1    40         4 obsolete bit (36) unal,			/* obsolete */
  1    41       3 pad3 bit (144),
  1    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  1    43 
  1    44 dcl  dbc_ptr ptr init (null ());
  1    45 
  1    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  1    47 
  1    48 
  1    49 /* END mdbm_dcb.incl.pl1  */
  1    50 
  1    51 
      701 
      702 
  2     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  2     7*     install(86-10-23,MR12.0-1199):
  2     8*     Deleted the DEFAULT_WAIT variable.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* HISTORY:
  2    13*   Written by Oris Friesen August 10, 1978.
  2    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  2    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  2    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  2    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  2    18*   r-u-s-m-d scope codes, instead of just r-u.
  2    19*
  2    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  2    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  2    22*   and pad to mbz for consistency with MRDS access acl modes.
  2    23*
  2    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  2    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  2    26*   This is currently only used in mrds_dsl_set_fscope.
  2    27*
  2    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  2    29*   Put it at the end to make the new structure compatable with the old so
  2    30*   that testing could take place without having to recompile all the modules
  2    31*   that use the structure.
  2    32*
  2    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  2    34*   element. This was done because set_fscope must be able to open the
  2    35*   relation if its not yet opened.
  2    36*   ---------------------------------------------------------------------------
  2    37*   DESCRIPTION:
  2    38*
  2    39*   The dbc contains the following information in its static area.
  2    40*   One group of information is composed of structures (user_list)
  2    41*   threaded 3 ways to form 3 lists. They are the list of active
  2    42*   scope users, of open users, and of users waiting to set scope.
  2    43*   The beginning of each of these lists is pointed to by fields
  2    44*   in the dbc proper.  All of these lists share the user_list structures,
  2    45*   and are completely contained within these structures, i.e., there
  2    46*   is no extraneous information in some knook in Scottsdale.
  2    47*
  2    48*   Associated with each user_list structure is a linked list of
  2    49*   fil_list structures.  The list is of all of the files (relations)
  2    50*   included in the user's scope request.  Unlike the user_list
  2    51*   structures which were shared by several different lists, the structures
  2    52*   in a user's file list are exclusively hers.  The entries contain
  2    53*   information about the scope request and the file name, and have
  2    54*   no real connection with the actual files in the resultant model.
  2    55*   --------------------------------------------------------------------------- */
  2    56 
  2    57 dcl 1 user_list based (ul_ptr),
  2    58     2 ids,
  2    59       3 group_id char (32),				/* group identifier of this user */
  2    60       3 process_id bit (36),				/* process identifier of this user */
  2    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  2    62*						   used to identify dead processes */
  2    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  2    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  2    65*						   to allow concurrent openings by same process */
  2    66     2 flags,
  2    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  2    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  2    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  2    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  2    71       3 priority_high bit (1) unal,			/* obsolete */
  2    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  2    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  2    74       3 dead_proc_conflict
  2    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  2    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  2    77       3 pad bit (28),				/* reserved for future use */
  2    78     2 allowance_count fixed bin,			/* obsolete */
  2    79     2 bypass_count fixed bin,				/* obsolete */
  2    80     2 offsets,
  2    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  2    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  2    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  2    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  2    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  2    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  2    87 						/* names of files accessible by this user */
  2    88 
  2    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  2    90     2 name char (30),				/* data model name of the file specified in scope request */
  2    91     2 permits,					/* permit codes for scope setting or deleting */
  2    92       3 mbz1 bit (15) unal,
  2    93       3 modify_attr bit (1) unal,
  2    94       3 delete_tuple bit (1) unal,
  2    95       3 append_tuple bit (1) unal,
  2    96       3 update bit (1) unal,
  2    97       3 read_attr bit (1) unal,
  2    98     2 prevents,					/* prevent codes for scope setting or deleting */
  2    99       3 update bit (1) unal,
  2   100       3 read_attr bit (1) unal,
  2   101       3 append_tuple bit (1) unal,
  2   102       3 delete_tuple bit (1) unal,
  2   103       3 modify_attr bit (1) unal,
  2   104       3 mbz2 bit (29) unal,
  2   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  2   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  2   107                                                             /* needed so that the relation can be opened if need be */
  2   108 
  2   109 dcl  ul_ptr ptr init (null ());
  2   110 dcl  fl_ptr ptr init (null ());
  2   111 
  2   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  2   113 
  2   114 
  2   115 dcl  WAIT init (0) fixed bin int static options (constant);
  2   116 						/* the number of later user requests for which a user
  2   117*						   request will wait before it must be honored */
  2   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  2   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  2   120 						/* dequeue from open list */
  2   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  2   122 						/*  do not dequeue from open list */
  2   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  2   124 dcl  QUE_FREE fixed bin (71);
  2   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  2   126 						/* wakeup up signal for time-out */
  2   127 dcl  ALARM fixed bin (71);
  2   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  2   129 						/* this is the 1st time process will asleep */
  2   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  2   131 						/* being queued for the 2nd, 3rd ... time */
  2   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  2   133 						/* check to see which scopes can be set */
  2   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  2   135 						/* check to see which scopes can be deleted */
  2   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  2   137 						/* process is alive */
  2   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  2   139 						/* process is dead */
  2   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  2   141 						/* permit retrieve, update */
  2   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  2   143 						/* prevent retrieve, update */
  2   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  2   145 						/* permit retrieve, update */
  2   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  2   147 						/* prevent retrieve, update */
  2   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  2   149 						/* measure wait time in relative seconds */
  2   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  2   151 						/* free this user's file lists */
  2   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  2   153 						/* do not free this user's file lists */
  2   154 
  2   155 /* END mdbm_users.incl.pl1 */
  2   156 
      703 
      704 
  3     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  3     6*
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   this structure returns the callers user_class
  3    12*   either database administrator or normal user.
  3    13*   Note that these separate classes were used to allow
  3    14*   future expansion to the user classes, rather than
  3    15*   make them logical "not"'s of one another.
  3    16*   NOTE: a DBA is always also a normal user, thus if the caller
  3    17*   is a DBA, his normal_user bit will be on also.
  3    18*
  3    19**/
  3    20 
  3    21 
  3    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  3    23         2 version fixed bin,				/* version number of this structure */
  3    24         2 administrator bit (1) unal,			/* caller is a DBA */
  3    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  3    26         2 mbz bit (34) unal ;
  3    27 
  3    28 
  3    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  3    30 
  3    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  3    32 
  3    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      705 
      706 
  4     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  4     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  4     7*
  4     8**/
  4     9 
  4    10 /* DESCRIPTION:
  4    11*
  4    12*   This structure returns information about a relative pathname, given
  4    13*   to a pathname accepting mrds interface. The information returned
  4    14*   is the absolute pathname, plus in the case that
  4    15*   the relative path points to a mrds database or submodel
  4    16*   whether it is a model or a submodel, the mrds version of
  4    17*   the model or submodel, it's creator, and the time of creation.
  4    18*
  4    19**/
  4    20 
  4    21 
  4    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  4    23         2 version fixed bin,				/* version number for this structure */
  4    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  4    25         2 type,
  4    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  4    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  4    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  4    29 	3 mbz1 bit (33) unal,
  4    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  4    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  4    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  4    33         2 mbz2 bit (36) unal ;
  4    34 
  4    35 
  4    36 declare  mrds_path_info_ptr ptr ;
  4    37 
  4    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  4    39 
  4    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
      707 
      708 
      709 
      710      end adjust_mrds_db;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/23/86  1009.0  adjust_mrds_db.pl1                >spec>install>1199>adjust_mrds_db.pl1
701          1    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
703          2    10/23/86  1006.0  mdbm_users.incl.pl1               >spec>install>1199>mdbm_users.incl.pl1
705          3    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
707          4    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CLEAR                                  constant        bit(36)                  initial unaligned dcl 654 ref 542 553
DONT_WAIT                       000054 constant        fixed bin(17,0)          initial dcl 657 set ref 396* 600*
DQ_OPEN                         000040 constant        bit(1)                   initial unaligned dcl 2-119 set ref 494*
FREE_FIL_LIST                   000040 constant        bit(1)                   initial unaligned dcl 2-150 set ref 494*
NULL_OFS                               constant        bit(18)                  initial unaligned dcl 2-118 ref 344 365 570
OFF                                    constant        bit(1)                   initial unaligned dcl 652 ref 181 275 337 480 508
                                                                                  548
ON                                     constant        bit(1)                   initial unaligned dcl 653 ref 147 152 165 175 182
                                                                                  226 317 320 349 352 355 399 442 466 474 478 512
                                                                                  529 531 544
RETREIVE_MODE                   000004 constant        fixed bin(17,0)          initial dcl 656 set ref 252*
a_ptr                                  parameter       pointer                  dcl 565 ref 558 570
absolute_path             1            based           char(168)                level 2 dcl 4-22 ref 205
active_users             10            based           fixed bin(17,0)          level 4 dcl 1-14 ref 339
active_users_ofs         21(18)        based           bit(18)                  level 4 packed unaligned dcl 1-14 ref 342
addr                                                   builtin function         dcl 648 ref 201 201 237 237 471 499
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 3-22 ref 243
arg                                    based           char                     unaligned dcl 622 set ref 143 144 144 144* 149 149
                                                                                  149* 155 155 165 167 167* 174 174 176* 180 180
                                                                                  183* 189* 193*
arg_len                         000102 automatic       fixed bin(17,0)          dcl 604 set ref 141* 143 144 144 144 144 149 149 149
                                                                                  149 155 155 161* 165 167 167 167 174 174 176 176
                                                                                  180 180 183 183 189 189 193 193 197
arg_ptr                         000106 automatic       pointer                  dcl 609 set ref 141* 143 144 144 144 149 149 149 155
                                                                                  155 161* 165 167 167 174 174 176 180 180 183 189
                                                                                  193 196
clear_lock_sw                   000471 automatic       bit(1)                   initial unaligned dcl 630 set ref 317* 553 630*
code                            000110 automatic       fixed bin(35,0)          dcl 612 set ref 138* 140 141* 142 142* 161* 162 162*
                                                                                  201* 206 207 207* 209* 218* 219 219* 237* 240 240*
                                                                                  252* 253 253* 269* 270 270* 276* 277 277 277* 284*
                                                                                  289* 295* 300* 304* 332* 334 334 334 396* 398 414*
                                                                                  416 416*
com_err_                        000036 constant        entry                    external dcl 678 ref 583
command_query_$yes_no           000034 constant        entry                    external dcl 677 ref 407
cont_dir_dir                    000203 automatic       char(168)                initial unaligned dcl 616 set ref 616*
cont_dir_ent                    000173 automatic       char(32)                 initial unaligned dcl 615 set ref 615*
copy                                                   builtin function         dcl 648 ref 137
cu_$arg_count                   000040 constant        entry                    external dcl 679 ref 129
cu_$arg_ptr                     000042 constant        entry                    external dcl 680 ref 141 161
current_user_offset             001104 automatic       bit(18)                  unaligned dcl 639 set ref 342* 344 347 356* 363* 365
                                                                                  367 373*
current_user_ptr                001102 automatic       pointer                  dcl 638 set ref 347* 349 352 356 367* 369 369 373
db_dir                          000111 automatic       char(168)                unaligned dcl 613 set ref 137* 218*
db_ent                          000163 automatic       char(32)                 unaligned dcl 614 set ref 218*
db_lock_id               11            based           bit(36)                  level 3 dcl 2-57 set ref 352* 369* 477
db_path                         000327 automatic       char(168)                initial unaligned dcl 619 set ref 203* 205* 209* 212
                                                                                  218* 219* 221 221* 237 237 240 243 252 252 269*
                                                                                  407* 436* 619*
db_path_var                     000401 automatic       varying char(202)        initial dcl 620 set ref 620*
dbc                                    based           structure                level 1 unaligned dcl 1-14
dbc_bit_count                   001113 automatic       fixed bin(24,0)          dcl 693 set ref 269* 436*
dbc_ptr                         003116 automatic       pointer                  initial dcl 1-44 set ref 269* 276 304 1-44* 332 339
                                                                                  342 347 360 363 367 396 400 414 436* 442 471 472*
                                                                                  472 488 488 493* 494* 500* 508 512 531 542 548 548
                                                                                  553
dbp                                    based           char                     unaligned dcl 623 ref 198
dbp_len                         000101 automatic       fixed bin(17,0)          dcl 604 set ref 197* 198
dbp_ptr                         000104 automatic       pointer                  dcl 609 set ref 196* 198
dead_proc                16(23)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 349 369 474
dead_proc_flag            4(01)        based           bit(1)                   level 4 packed unaligned dcl 1-14 set ref 508*
dead_process_sw                 000470 automatic       bit(1)                   initial unaligned dcl 629 set ref 144 152* 176 183
                                                                                  284 289 629*
dead_sw                         003146 automatic       bit(1)                   unaligned dcl 455 set ref 474* 478* 480* 485
dm_ptr                          000474 automatic       pointer                  dcl 632 set ref 252* 255*
empty                                                  builtin function         dcl 648 ref 695
error_table_$bad_arg            000012 external static fixed bin(35,0)          dcl 663 set ref 193*
error_table_$badcall            000076 external static fixed bin(35,0)          dcl 698 set ref 212*
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 664 set ref 159* 167* 189*
error_table_$inconsistent       000016 external static fixed bin(35,0)          dcl 665 set ref 144* 149* 176* 183*
error_table_$insufficient_access
                                000020 external static fixed bin(35,0)          dcl 666 set ref 243*
error_table_$invalid_lock_reset 000022 external static fixed bin(35,0)          dcl 667 ref 277 334 478 601
error_table_$lock_wait_time_exceeded
                                000026 external static fixed bin(35,0)          dcl 669 ref 398
error_table_$locked_by_this_process
                                000024 external static fixed bin(35,0)          dcl 668 ref 277 334
error_table_$pathlong           000030 external static fixed bin(35,0)          dcl 670 set ref 221*
error_table_$too_many_args      000032 external static fixed bin(35,0)          dcl 671 set ref 134*
event_signal_sw          16(22)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 488
expand_pathname_                000044 constant        entry                    external dcl 681 ref 218
fl_ptr                          003122 automatic       pointer                  initial dcl 2-110 set ref 2-110*
flags                    16            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "amdb"
flags                     4            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "amdb"
force_option                    003114 automatic       bit(1)                   initial unaligned dcl 699 set ref 175* 181* 331 699*
found_active                    001105 automatic       bit(1)                   unaligned dcl 640 set ref 337* 344 344 355* 360 382
                                                                                  388 405
found_dead_active               001107 automatic       bit(1)                   unaligned dcl 642 set ref 337* 344 349* 352* 390 405
found_open                      001106 automatic       bit(1)                   unaligned dcl 641 set ref 337* 365 369* 384 405
found_quiesced                  001110 automatic       bit(1)                   unaligned dcl 643 set ref 337* 399* 405
icode                                  parameter       fixed bin(35,0)          dcl 537 in procedure "reset_trouble" ref 535 542
icode                                  parameter       fixed bin(35,0)          dcl 456 in procedure "remove_dead_processes" set ref
                                                                                  449 464 464* 477* 478 494*
icode                                  parameter       fixed bin(35,0)          dcl 313 in procedure "reset_dbc" set ref 311 315
                                                                                  318* 436* 438 438*
icode                                  parameter       fixed bin(35,0)          dcl 523 in procedure "set_trouble" set ref 518 527
                                                                                  527*
icode                                  parameter       fixed bin(35,0)          dcl 580 in procedure "error" set ref 578 583*
icode                           003206 automatic       fixed bin(35,0)          dcl 595 in procedure "process_dead" set ref 600* 601
ids                                    based           structure                level 2 unaligned dcl 2-57
idx                             000465 automatic       fixed bin(17,0)          dcl 625 set ref 140* 141* 157 157* 157 161*
in_path                         000255 automatic       char(168)                initial unaligned dcl 618 set ref 198* 201* 203 618*
inconsistent_message            000507 automatic       char(500)                unaligned dcl 635 set ref 255* 258 262*
inconsistent_name               000477 automatic       char(32)                 unaligned dcl 634 set ref 255*
inconsistent_undo               000704 automatic       char(500)                unaligned dcl 636 set ref 255*
inconsistent_value              000476 automatic       bit(1)                   unaligned dcl 633 set ref 255* 257
index                                                  builtin function         dcl 648 ref 143
ioa_                            000046 constant        entry                    external dcl 682 ref 258 261 262 264 382 384 386 388
                                                                                  390 400 402
length                                                 builtin function         dcl 648 ref 221
local_area                      001114 automatic       area(1024)               dcl 695 set ref 201 201 237 237 695*
lock_id                                parameter       bit(36)                  dcl 596 ref 589 599
locked                          000472 automatic       bit(1)                   initial unaligned dcl 631 set ref 275* 304 320* 339
                                                                                  386 405 466* 529* 544* 631*
mdbm_util_$inconsistent_get_info
                                000050 constant        entry                    external dcl 683 ref 255
mrds_authorization                     based           structure                level 1 dcl 3-22
mrds_authorization_ptr          003124 automatic       pointer                  dcl 3-29 set ref 237* 243
mrds_authorization_structure_version
                                000055 constant        fixed bin(17,0)          initial dcl 3-31 set ref 237*
mrds_data_$lock_wait_time       000010 external static fixed bin(35,0)          dcl 659 ref 276 332
mrds_dm_authorization$get_user_class
                                000072 constant        entry                    external dcl 694 ref 237
mrds_dm_open                    000052 constant        entry                    external dcl 684 ref 252
mrds_dsl_get_version$get_path_info
                                000074 constant        entry                    external dcl 696 ref 201
mrds_error_$no_database         000064 external static fixed bin(35,0)          dcl 689 ref 207
mrds_error_$no_model_submodel   000062 external static fixed bin(35,0)          dcl 688 ref 207
mrds_path_info                         based           structure                level 1 dcl 4-22
mrds_path_info_ptr              003126 automatic       pointer                  dcl 4-36 set ref 201* 203 205 212
mrds_path_info_structure_version
                                000055 constant        fixed bin(17,0)          initial dcl 4-38 set ref 201*
mu_concurrency_control$get_control_segment
                                000066 constant        entry                    external dcl 691 ref 269
mu_concurrency_control$reset_control_segment
                                000070 constant        entry                    external dcl 691 ref 436
mu_de_queue_user                000054 constant        entry                    external dcl 685 ref 494
n_args                          000100 automatic       fixed bin(17,0)          dcl 604 set ref 129* 130 134 140 157 226
next_active_ofs          22(18)        based           bit(18)                  level 3 packed unaligned dcl 2-57 ref 356
next_open_ofs            23(18)        based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 373 493*
                                                                                  499 500*
null                                                   builtin function         dcl 648 in procedure "amdb" ref 203 1-44 2-109 2-110
                                                                                  473
null                                                   builtin function         dcl 568 in procedure "convert" ref 572
offsets                  21            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "amdb"
offsets                  22            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "amdb"
ofs                                    parameter       bit(18)                  unaligned dcl 566 ref 558 570 570
open_lock                12            based           bit(36)                  level 3 dcl 1-14 set ref 332* 414*
open_lock_set                   001101 automatic       bit(1)                   unaligned dcl 637 set ref 334* 360 388 405 413
open_users                7            based           fixed bin(17,0)          level 4 dcl 1-14 ref 360
open_users_ofs           21            based           bit(18)                  level 4 packed unaligned dcl 1-14 set ref 363 471
                                                                                  472*
path_name_sw                    001112 automatic       bit(1)                   unaligned dcl 645 set ref 139* 193 195* 231
pointer                                                builtin function         dcl 648 ref 347 367
proper                                 based           structure                level 2 unaligned dcl 1-14
ptr                                                    builtin function         dcl 568 ref 570
quiesce_lock              5            based           bit(36)                  level 3 dcl 1-14 set ref 396*
quiesce_sw                4(02)        based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 400
reset_db_response               001111 automatic       bit(1)                   unaligned dcl 644 set ref 407* 412
reset_sw                        000466 automatic       bit(1)                   initial unaligned dcl 627 set ref 147* 149 175* 182*
                                                                                  226* 284 295 627*
result                          003176 automatic       pointer                  dcl 564 set ref 570* 572* 574
rtrim                                                  builtin function         dcl 648 ref 221 237 237 240 243 252 252
saved_ul_ptr                    003150 automatic       pointer                  dcl 457 set ref 493* 495
scope_lock               13            based           bit(36)                  level 3 dcl 1-14 set ref 276* 304* 542* 553*
set_lock_$lock                  000056 constant        entry                    external dcl 686 ref 276 332 396 477 600
set_lock_$unlock                000060 constant        entry                    external dcl 687 ref 304 414
string                                 parameter       char                     unaligned dcl 581 set ref 578 583*
submodel                 53(02)        based           bit(1)                   level 3 packed unaligned dcl 4-22 ref 212
temp_lock                       003207 automatic       bit(36)                  dcl 597 set ref 599* 600*
trouble_sw_on                   000467 automatic       bit(1)                   initial unaligned dcl 628 set ref 165* 284 300 442
                                                                                  512 628*
trouble_switch            4            based           bit(1)                   level 4 packed unaligned dcl 1-14 set ref 442* 512*
                                                                                  531* 548 548*
type                     53            based           structure                level 2 dcl 4-22
ul_ptr                          003120 automatic       pointer                  initial dcl 2-109 set ref 2-109* 472* 473 474 477
                                                                                  488 493 494* 495* 499 500* 500
ulo_ptr                         003152 automatic       pointer                  dcl 458 set ref 471* 499*
user_counts               7            based           structure                level 3 unaligned dcl 1-14
user_list                              based           structure                level 1 unaligned dcl 2-57
wakeup_waiters            6            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 488* 488

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 2-127
ALIVE                                  internal static bit(1)                   initial unaligned dcl 2-136
CHAR_ALARM                             internal static char(8)                  initial unaligned dcl 2-125
CHAR_Q_F                               internal static char(8)                  initial unaligned dcl 2-123
DEAD                                   internal static bit(1)                   initial unaligned dcl 2-138
DEL                                    internal static bit(1)                   initial unaligned dcl 2-134
FIRST_QUEUE                            internal static bit(1)                   initial unaligned dcl 2-128
NO_DQ_OPEN                             internal static bit(1)                   initial unaligned dcl 2-121
QUEUE_AGAIN                            internal static bit(1)                   initial unaligned dcl 2-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 2-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 2-140
Q_PRM_BITS                             internal static bit(2)                   initial unaligned dcl 2-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 2-142
Q_PRV_BITS                             internal static bit(2)                   initial unaligned dcl 2-146
REL_SEC                                internal static bit(2)                   initial unaligned dcl 2-148
SAVE_FIL_LIST                          internal static bit(1)                   initial unaligned dcl 2-152
SET                                    internal static bit(1)                   initial unaligned dcl 2-132
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 1-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 2-115
fil_list                               based           structure                level 1 unaligned dcl 2-89
num_filns                              automatic       fixed bin(17,0)          dcl 2-112
sys_info$max_seg_size                  external static fixed bin(17,0)          dcl 661

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_mrds_db                  000615 constant        entry                    external dcl 18
amdb                            000605 constant        entry                    external dcl 18
convert                         003426 constant        entry                    internal dcl 558 ref 472 493 500
error                           003452 constant        entry                    internal dcl 578 ref 130 134 142 144 149 159 162 167
                                                                                  176 183 189 193 209 212 219 221 231 240 243 253
                                                                                  270 416 438 464 527
exit                            002324 constant        label                    dcl 304 ref 585
process_dead                    003523 constant        entry                    internal dcl 589 ref 352 369
remove_dead_processes           003144 constant        entry                    internal dcl 449 ref 289
reset_dbc                       002341 constant        entry                    internal dcl 311 ref 295
reset_trouble                   003403 constant        entry                    internal dcl 535 ref 300
set_trouble                     003352 constant        entry                    internal dcl 518 ref 284

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4174        4274    3567        4204
Length      4620    3567       100         307     404           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amdb                               1906 external procedure  is an external procedure.  
reset_dbc                               internal procedure  shares stack frame of external procedure amdb.  
remove_dead_processes                   internal procedure  shares stack frame of external procedure amdb.  
set_trouble                             internal procedure  shares stack frame of external procedure amdb.  
reset_trouble                           internal procedure  shares stack frame of external procedure amdb.  
convert                                 internal procedure  shares stack frame of external procedure amdb.  
error                                88 internal procedure  is called during a stack extension.  
process_dead                            internal procedure  shares stack frame of external procedure amdb.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amdb                     000100 n_args                      amdb
                         000101 dbp_len                     amdb
                         000102 arg_len                     amdb
                         000104 dbp_ptr                     amdb
                         000106 arg_ptr                     amdb
                         000110 code                        amdb
                         000111 db_dir                      amdb
                         000163 db_ent                      amdb
                         000173 cont_dir_ent                amdb
                         000203 cont_dir_dir                amdb
                         000255 in_path                     amdb
                         000327 db_path                     amdb
                         000401 db_path_var                 amdb
                         000465 idx                         amdb
                         000466 reset_sw                    amdb
                         000467 trouble_sw_on               amdb
                         000470 dead_process_sw             amdb
                         000471 clear_lock_sw               amdb
                         000472 locked                      amdb
                         000474 dm_ptr                      amdb
                         000476 inconsistent_value          amdb
                         000477 inconsistent_name           amdb
                         000507 inconsistent_message        amdb
                         000704 inconsistent_undo           amdb
                         001101 open_lock_set               amdb
                         001102 current_user_ptr            amdb
                         001104 current_user_offset         amdb
                         001105 found_active                amdb
                         001106 found_open                  amdb
                         001107 found_dead_active           amdb
                         001110 found_quiesced              amdb
                         001111 reset_db_response           amdb
                         001112 path_name_sw                amdb
                         001113 dbc_bit_count               amdb
                         001114 local_area                  amdb
                         003114 force_option                amdb
                         003116 dbc_ptr                     amdb
                         003120 ul_ptr                      amdb
                         003122 fl_ptr                      amdb
                         003124 mrds_authorization_ptr      amdb
                         003126 mrds_path_info_ptr          amdb
                         003146 dead_sw                     remove_dead_processes
                         003150 saved_ul_ptr                remove_dead_processes
                         003152 ulo_ptr                     remove_dead_processes
                         003176 result                      convert
                         003206 icode                       process_dead
                         003207 temp_lock                   process_dead

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
return_mac          tra_ext_1           shorten_stack       ext_entry           int_entry_desc      op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_$yes_no         cu_$arg_count                 cu_$arg_ptr
expand_pathname_              ioa_                          mdbm_util_$inconsistent_get_info
mrds_dm_authorization$get_user_class                        mrds_dm_open
mrds_dsl_get_version$get_path_info                          mu_concurrency_control$get_control_segment
mu_concurrency_control$reset_control_segment                mu_de_queue_user              set_lock_$lock
set_lock_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badcall          error_table_$badopt           error_table_$inconsistent
error_table_$insufficient_access                            error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_this_process
error_table_$pathlong         error_table_$too_many_args    mrds_data_$lock_wait_time     mrds_error_$no_database
mrds_error_$no_model_submodel




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    615 000550       616 000553       618 000556       619 000561       620 000564       627 000565       628 000566
    629 000567       630 000570       631 000571       695 000572       699 000575    1   44 000576    2  109 000600
 2  110 000601        18 000604       129 000623       130 000632       134 000655       137 000675       138 000700
    139 000701       140 000702       141 000713       142 000730       143 000752       144 000766       147 001021
    149 001024       152 001057       155 001062       157 001072       159 001077       161 001114       162 001131
    165 001153       167 001164       170 001210       174 001211       175 001221       176 001224       178 001246
    180 001247       181 001257       182 001260       183 001262       185 001304       189 001305       191 001325
    193 001326       195 001350       196 001352       197 001354       198 001356       201 001362       203 001414
    205 001424       206 001430       207 001432       209 001437       212 001453       218 001502       219 001526
    221 001544       226 001574       230 001601       231 001603       237 001625       240 001677       243 001744
    252 002003       253 002035       255 002056       257 002106       258 002111       261 002132       262 002146
    264 002165       269 002201       270 002226       275 002247       276 002250       277 002266       284 002275
    289 002306       295 002313       300 002320       304 002324       308 002340       311 002341       315 002343
    317 002345       318 002347       319 002350       320 002351       331 002353       332 002355       334 002373
    337 002410       339 002415       342 002422       344 002425       347 002436       349 002442       352 002450
    355 002466       356 002470       358 002474       360 002475       363 002504       365 002507       367 002515
    369 002521       373 002540       376 002544       382 002545       384 002564       386 002602       388 002623
    390 002643       396 002661       398 002675       399 002701       400 002703       402 002723       405 002736
    407 002752       412 003022       413 003025       414 003027       416 003041       420 003065       436 003066
    438 003114       442 003136       447 003143       449 003144       464 003146       466 003165       471 003167
    472 003172       473 003205       474 003212       477 003221       478 003240       480 003250       485 003251
    488 003253       493 003262       494 003276       495 003316       496 003320       499 003321       500 003326
    503 003341       508 003342       512 003345       516 003351       518 003352       527 003354       529 003375
    531 003377       533 003402       535 003403       542 003405       544 003412       548 003414       553 003422
    556 003425       558 003426       570 003430       572 003444       574 003446       578 003451       583 003465
    585 003520       589 003523       599 003525       600 003527       601 003542


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
