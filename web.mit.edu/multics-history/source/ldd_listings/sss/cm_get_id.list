	COMPILATION LISTING OF SEGMENT cm_get_id
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0953.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          This module implements collection_manager_$get_id (cm_get_id$id)
       11*     cm_get_id$ptr is an internal interface.
       12*
       13*          This routine returns the identifier of an element relative to another
       14*     element. The desired element is p_position_change elements away from the
       15*     "start" element in a forward direction if positive, or if negative, is
       16*     abs (p_position_change) away in a backward direction.  The element from
       17*     which to start is determined as follows: (1) if p_is_absolute_position
       18*     is on, then (1a) if p_position_change is positive (position forward),
       19*     the start is the imaginary element which precedes the first element of the
       20*     collection; else (1b) if p_position_change is negative (position backward)
       21*     the start is the imaginary element which succeeds the last element of the
       22*     collection; else (1c) if p_position_change is equal to 0 the error
       23*     dm_error_$beginning_of_collection is returned; (2) if 
       24*     p_is_absolute_position is off, the start is the element specified by
       25*     p_input_element_id_string. 
       26*
       27*          There are two entries into this routine, id and ptr.
       28*     The id entry point inplements collection_manager_$get_id.
       29*     The id entry point works as described above.  In the course of looking
       30*     through control intervals, it gets a pointer to each control interval 
       31*     of interest.
       32*     The ptr entry point is an internal interface.
       33*     The ptr entry point works the same, but allows the caller to supply the 
       34*     pointer to the first control interval to be examined.  The caller expects
       35*     the pointer to the last control interval examined.  p_input_ci_ptr and
       36*     p_return_ci_ptr are sed for these purposes.  The supplied pointer and the
       37*     returned pointer, which may be the same, must not be terminated.  All 
       38*     other control interval pointers used must be terminated.     
       39*
       40**/
       41 
       42 /* HISTORY:
       43*
       44*Written by Matthew Pierret, 09/03/82.
       45*Modified:
       46*11/05/82 by Matthew Pierret:  Added $info_* entries.  Made to get opening
       47*            info (cm_info) by calling cm_opening_info$full_get ($full_get
       48*            gets the storage record)
       49*11/22/82 by Lindsey Spratt:  Fixed the $element entry to do a
       50*	  cm_opening_info$full_get.  Fixed $info_element entry to set
       51*	  cm_info_ptr from p_cm_info_ptr.
       52*01/20/83 by Lindsey Spratt:  Fixed to check for the fetch of the first ci to
       53*	  return ci 0 when not looking in the header collection (always the
       54*	  owner of ci 0) as an indication of the current collection being
       55*	  empty.
       56*01/27/83 by Matthew Pierret: Changed to use cm_opening_info$get_storage_record.
       57*            Updraded to CM_INFO_VERSION_2. Added check to see if control
       58*            interval thread is consistent.
       59*02/07/83 by Matthew Pierret: Changed to accept p_bci_header_ptr and
       60*            p_slot_table_ptr so that this routine can be used by cm_ modules
       61*            that have already gotten the two structures. This will help
       62*            centralize all positioning in cm_.
       63*05/04/83 by Matthew Pierret:  Changed to use dm_error_$programming_error
       64*            instead of $col_is_inconsistent.
       65*10/13/83 by Lindsey L. Spratt:  Renamed the header and header_return_slot
       66*            entries to be info_header and info_header_return_slot.  Added new
       67*            header and header_return_slot entries which expect file_opening_id
       68*            and collection_id instead of a cm_info_ptr, then do a
       69*            cm_opening_info$get themselves.  Changed handling of error codes
       70*            to use the "call ERROR_RETURN (code);" technique.  Changed naming
       71*            of variables in internal procedures to use a prefix unique to that
       72*            internal procedure.
       73*02/06/84 by Matthew Pierret:  Removed all entries except $id and added $ptr.
       74*            All collection_manager_ modules which use cm_get_id now use the
       75*            $ptr entry.  This entry can receive as input and return as output
       76*            a pointer to a control interval, as returned by
       77*            file_manager_$get_ci_ptr.  Use of this pointer allows direct
       78*            access to look at file control intervals.  This module was
       79*            substantially rewritten to get ci_ptr's to access control
       80*            intervals.
       81*02/10/84 by Matthew Pierret:  Changed to initialize its return element id
       82*            string and to check for infinite looping.
       83*03/16/84 by Matthew Pierret:  Changed to special-case the error code
       84*            dm_error_$ci_not_allocated when returned from fm_$get_ci_ptr.
       85*05/21/84 by Matthew Pierret:  Renamed include fle dm_cm_cism_info to
       86*            dm_cism_info.
       87*07/17/84 by Matthew Pierret:  Changed to return dm_error_$ci_not_in_collection
       88*            instead of calling sub_err_ if there is a mismatch on the first
       89*            control interval seen.
       90*10/02/84 by Matthew Pierret:  Changed CHECK_CI_LAYOUT to return 
       91*            dm_error_$unimplemented_ci_version.  Modified DESCRIPTION to
       92*            correctly reflect the workings of this module.
       93*            Moved include files from internal procedures to main procedure,
       94*            making refernces to the structures in those procedures by
       95*            explicit pointer reference.
       96**/
       97 
       98 /* format: style2,ind3,ll80,^indprocbody */
       99 
      100 cm_get_id$id:
      101    procedure (p_file_opening_id, p_collection_id, p_input_element_id_string,
      102         p_position_change, p_is_absolute_position, p_return_element_id_string,
      103         p_code);
      104 
      105 
      106 
      107 /* START OF DECLARATIONS */
      108 /* Parameter */
      109 
      110    dcl	 p_file_opening_id	    bit (36) aligned parameter;
      111    dcl	 p_collection_id	    bit (36) aligned parameter;
      112    dcl	 p_input_element_id_string
      113 			    bit (36) aligned parameter;
      114    dcl	 p_return_element_id_string
      115 			    bit (36) aligned parameter;
      116    dcl	 p_position_change	    fixed bin (17) parameter;
      117    dcl	 p_is_absolute_position bit (1) aligned parameter;
      118    dcl	 p_input_ci_ptr	    ptr parameter;
      119    dcl	 p_return_ci_ptr	    ptr parameter;
      120    dcl	 p_code		    fixed bin (35) parameter;
      121 
      122 /* Automatic */
      123 
      124    dcl	 (ci_idx, current_slot_index, position_change)
      125 			    fixed bin (17);
      126    dcl	 (current_ci_id, most_recent_ci_id)
      127 			    fixed bin (24) uns init (0);
      128 
      129    dcl	 (file_opening_id, collection_id, input_element_id_string,
      130 	 return_element_id_string)
      131 			    bit (36) aligned init ("0"b);
      132 
      133    dcl	 (is_absolute_position, terminate_last_ci_ptr)
      134 			    bit (1) aligned init ("0"b);
      135 
      136    dcl	 (ci_ptr, input_ci_ptr) ptr init (null);
      137 
      138 /* Based */
      139 
      140    dcl	 1 input_element_id	    aligned
      141 			    based (addr (input_element_id_string))
      142 			    like element_id;
      143 
      144 /* Builtin */
      145 
      146    dcl	 (addr, max, min, null) builtin;
      147 
      148 /* Constant */
      149 
      150    dcl	 myname		    init ("cm_get_id") char (32) varying
      151 			    internal static options (constant);
      152    dcl	 LIMIT_TO_STOP_INFINITE_LOOPING
      153 			    init (1e6) fixed bin (35) internal
      154 			    static options (constant);
      155    dcl	 (
      156 	 LOWEST_SLOT_INDEX	    init (0),
      157 	 HIGHEST_SLOT_INDEX	    init (1e4)
      158 	 )		    fixed bin (17) internal static
      159 			    options (constant);
      160    dcl	 (
      161 	 IS_FIRST		    init ("1"b),
      162 	 NOT_FIRST	    init ("0"b)
      163 	 )		    bit (1) aligned internal static
      164 			    options (constant);
      165 
      166 /* Entry */
      167 
      168    dcl	 sub_err_		    entry () options (variable);
      169 
      170 /* External */
      171 
      172    dcl	 (
      173 	 dm_error_$beginning_of_collection,
      174 	 dm_error_$ci_not_allocated,
      175 	 dm_error_$ci_not_in_collection,
      176 	 dm_error_$end_of_collection,
      177 	 dm_error_$no_element,
      178 	 dm_error_$programming_error,
      179 	 dm_error_$unimplemented_cism,
      180 	 dm_error_$unimplemented_ci_version
      181 	 )		    fixed bin (35) ext static;
      182    dcl	 error_table_$unimplemented_version
      183 			    ext fixed bin (35);
      184 
      185 /* END OF DECLARATIONS */
      186 
      187 /*
      188*id:
      189*   entry (p_file_opening_id, p_collection_id, p_input_element_id_string,
      190*        p_position_change, p_is_absolute_position, p_return_element_id_string,
      191*        p_code);
      192**/
      193 
      194    input_ci_ptr = null;
      195    terminate_last_ci_ptr = "1"b;
      196 
      197    goto JOIN;
      198 
      199 ptr:
      200    entry (p_file_opening_id, p_collection_id, p_input_element_id_string,
      201         p_position_change, p_is_absolute_position, p_input_ci_ptr,
      202         p_return_ci_ptr, p_return_element_id_string, p_code);
      203 
      204    p_return_ci_ptr = null;
      205    terminate_last_ci_ptr = "0"b;
      206    input_ci_ptr = p_input_ci_ptr;
      207 
      208    goto JOIN;
      209 
      210 /* format: equalind25 */
      211 JOIN:
      212    p_code		        = 0;
      213    p_return_element_id_string
      214 		        = "0"b;
      215    file_opening_id	        = p_file_opening_id;
      216    collection_id	        = p_collection_id;
      217    is_absolute_position     = p_is_absolute_position;
      218    input_element_id_string  = p_input_element_id_string;
      219    position_change	        = p_position_change;		/* format: equalind0 */
      220 
      221    if is_absolute_position
      222    then call SET_DEFAULT_POSITION (file_opening_id, collection_id,
      223 	   position_change, current_ci_id, current_slot_index);
      224    else
      225       do;
      226          current_ci_id = input_element_id.control_interval_id;
      227          current_slot_index = input_element_id.index;
      228       end;
      229 
      230 LOOP_THROUGH_CONTROL_INTERVALS:
      231    do ci_idx = 1 to LIMIT_TO_STOP_INFINITE_LOOPING while (position_change ^= 0);
      232 
      233       call GET_CI_PTR (file_opening_id, collection_id, current_ci_id,
      234 	 input_ci_ptr, ci_ptr);
      235 
      236       if most_recent_ci_id ^= 0
      237       then if position_change > 0
      238 	      & ci_ptr -> bci_header.previous_control_interval
      239 	      ^= most_recent_ci_id
      240 	 then call sub_err_ (dm_error_$programming_error, myname,
      241 		 ACTION_CANT_RESTART, null, 0,
      242 		 "^/^a ^d ^a ^d;^/^a ^d ^a ^d.", "Control interval",
      243 		 most_recent_ci_id, "has a next control interval of",
      244 		 current_ci_id, "control interval", current_ci_id,
      245 		 "has a previous control interval of",
      246 		 ci_ptr -> bci_header.previous_control_interval);
      247 	 else if position_change < 0
      248 		 & ci_ptr -> bci_header.next_control_interval
      249 		 ^= most_recent_ci_id
      250 	 then call sub_err_ (dm_error_$programming_error, myname,
      251 		 ACTION_CANT_RESTART, null, 0,
      252 		 "^/^a ^d ^a ^d;^/^a ^d ^a ^d.", "Control interval",
      253 		 most_recent_ci_id, current_ci_id,
      254 		 "has a previous control interval of", "control interval",
      255 		 current_ci_id, "has a next control interval of",
      256 		 ci_ptr -> bci_header.next_control_interval);
      257 
      258       call POSITION_THROUGH_CI (ci_ptr, position_change, current_slot_index);
      259 
      260       if position_change ^= 0
      261       then
      262          do;
      263 	  most_recent_ci_id = current_ci_id;
      264 
      265 	  if position_change > 0
      266 	  then if ci_ptr -> bci_header.next_control_interval = 0
      267 	       then call ERROR_RETURN (dm_error_$end_of_collection);
      268 	       else
      269 		do;
      270 		   current_ci_id =
      271 		        ci_ptr -> bci_header.next_control_interval;
      272 		   current_slot_index = LOWEST_SLOT_INDEX;
      273 		end;				/* position_change is necessarily < 0 */
      274 	  else if ci_ptr -> bci_header.previous_control_interval = 0
      275 	  then call ERROR_RETURN (dm_error_$beginning_of_collection);
      276 	  else
      277 	     do;
      278 	        current_ci_id =
      279 		   ci_ptr -> bci_header.previous_control_interval;
      280 	        current_slot_index = HIGHEST_SLOT_INDEX;
      281 	     end;
      282 
      283          end;
      284 
      285 
      286    end LOOP_THROUGH_CONTROL_INTERVALS;
      287 
      288    if position_change ^= 0
      289    then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART,
      290 	   null, 0, "^/^a^/ ^d elements to^/position past.",
      291 	   "This module was looping without bound loop while attempting to",
      292 	   "position among the elements.  There are still", position_change);
      293 
      294    element_id.control_interval_id = current_ci_id;
      295    element_id.index = current_slot_index;
      296 
      297    p_return_element_id_string = element_id_string;
      298    p_code = 0;
      299    if terminate_last_ci_ptr
      300    then call TERMINATE_CI_PTR (ci_ptr);
      301    else p_return_ci_ptr = ci_ptr;
      302 
      303 MAIN_RETURN:
      304    return;
      305 
      306 CHECK_VERSION:
      307    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      308    dcl	 cv_p_received_version  char (8) aligned;
      309    dcl	 cv_p_expected_version  char (8) aligned;
      310    dcl	 cv_p_structure_name    char (*);
      311 
      312    if cv_p_received_version ^= cv_p_expected_version
      313    then call sub_err_ (error_table_$unimplemented_version, myname,
      314 	   ACTION_CANT_RESTART, null, 0,
      315 	   "^/Expected version ^a of the ^a structure.
      316 Received version ^a instead.", cv_p_expected_version, cv_p_structure_name,
      317 	   cv_p_received_version);
      318 
      319    end CHECK_VERSION;
      320 
      321 
      322 
      323 CHECK_CI_LAYOUT:
      324    proc (ccl_p_ci_layout);
      325    dcl	 ccl_p_ci_layout	    char (4) aligned;
      326 
      327    if ccl_p_ci_layout ^= BASIC_CI_LAYOUT_1
      328    then call sub_err_ (dm_error_$unimplemented_ci_version, myname,
      329 	   ACTION_CANT_RESTART, null, 0,
      330 	   "^/Expected a version ^a control interval. Received version ^a instead."
      331 	   , BASIC_CI_LAYOUT_1, ccl_p_ci_layout);
      332 
      333    end CHECK_CI_LAYOUT;
      334 
      335 
      336 
      337 FINISH:
      338    proc ();
      339 
      340    if ci_ptr ^= input_ci_ptr
      341    then call TERMINATE_CI_PTR (ci_ptr);
      342 
      343    end FINISH;
      344 
      345 ERROR_RETURN:
      346    proc (er_p_code);
      347    dcl	 er_p_code	    fixed bin (35) parameter;
      348 
      349    call FINISH;
      350    p_code = er_p_code;
      351    go to MAIN_RETURN;
      352 
      353    end ERROR_RETURN;
      354 
      355 
      356 POSITION_THROUGH_CI:
      357    proc (ptc_p_ci_ptr, ptc_p_position_change, ptc_p_current_slot_index);
      358 
      359    dcl	 ptc_p_ci_ptr	    ptr;
      360    dcl	 (ptc_p_position_change, ptc_p_current_slot_index)
      361 			    fixed bin (17);
      362    dcl	 ptc_slot_idx	    fixed bin (17);
      363 
      364    if ptc_p_position_change > 0
      365    then
      366 LOOP_FORWARD_THROUGH_SLOTS:
      367       do ptc_slot_idx = max (1, ptc_p_current_slot_index + 1)
      368 	 to ptc_p_ci_ptr -> basic_control_interval.header.number_of_datums
      369 	 while (ptc_p_position_change > 0);
      370          if ^(ptc_p_ci_ptr
      371 	    -> basic_control_interval.datum_position_table (ptc_slot_idx)
      372 	    .flags.is_continuation
      373 	    | ptc_p_ci_ptr
      374 	    -> basic_control_interval.datum_position_table (ptc_slot_idx)
      375 	    .offset_in_bytes = FREE_SLOT)
      376          then ptc_p_position_change = ptc_p_position_change - 1;
      377 
      378          ptc_p_current_slot_index = ptc_slot_idx;
      379       end LOOP_FORWARD_THROUGH_SLOTS;
      380    else
      381 LOOP_BACKWARD_THROUGH_SLOTS:
      382       do ptc_slot_idx =
      383 	 min (ptc_p_current_slot_index - 1,
      384 	 ptc_p_ci_ptr -> basic_control_interval.header.number_of_datums)
      385 	 to 1 by -1 while (ptc_p_position_change < 0);
      386          if ^(ptc_p_ci_ptr
      387 	    -> basic_control_interval.datum_position_table (ptc_slot_idx)
      388 	    .flags.is_continuation
      389 	    | ptc_p_ci_ptr
      390 	    -> basic_control_interval.datum_position_table (ptc_slot_idx)
      391 	    .offset_in_bytes = FREE_SLOT)
      392          then ptc_p_position_change = ptc_p_position_change + 1;
      393 
      394          ptc_p_current_slot_index = ptc_slot_idx;
      395       end LOOP_BACKWARD_THROUGH_SLOTS;
      396 
      397    return;
      398 
      399    end POSITION_THROUGH_CI;
      400 
      401 GET_CI_PTR:
      402    proc (gcp_p_file_opening_id, gcp_p_collection_id, gcp_p_ci_id,
      403         gcp_p_input_ci_ptr, gcp_p_ci_ptr);
      404 
      405    dcl	 gcp_p_file_opening_id  bit (36) aligned;
      406    dcl	 gcp_p_collection_id    bit (36) aligned;
      407    dcl	 gcp_p_ci_id	    fixed bin (24) unsigned;
      408    dcl	 gcp_p_input_ci_ptr	    ptr;
      409    dcl	 gcp_p_ci_ptr	    ptr;
      410    dcl	 gcp_this_is_first_look_at_ci
      411 			    bit (1) aligned;
      412    dcl	 gcp_code		    fixed bin (35);
      413 
      414 
      415    if gcp_p_ci_ptr = null
      416    then
      417       do;
      418          gcp_this_is_first_look_at_ci = IS_FIRST;
      419          if gcp_p_input_ci_ptr ^= null
      420          then
      421 	  do;
      422 	     gcp_p_ci_ptr = gcp_p_input_ci_ptr;
      423 	  end;
      424          else
      425 	  do;
      426 	     call REALLY_GET_CI_PTR (IS_FIRST);
      427 	  end;
      428       end;
      429    else
      430       do;
      431          gcp_this_is_first_look_at_ci = NOT_FIRST;
      432          if gcp_p_input_ci_ptr ^= gcp_p_ci_ptr
      433          then
      434 	  do;
      435 	     call TERMINATE_CI_PTR (gcp_p_ci_ptr);
      436 	  end;
      437          call REALLY_GET_CI_PTR (NOT_FIRST);
      438       end;
      439 
      440    call CHECK_CI_LAYOUT (gcp_p_ci_ptr -> bci_header.layout_type);
      441 
      442    if gcp_p_ci_ptr -> bci_header.collection_id ^= gcp_p_collection_id
      443    then
      444       do;
      445          if gcp_this_is_first_look_at_ci
      446          then
      447 	  do;
      448 	     call ERROR_RETURN (dm_error_$ci_not_in_collection);
      449 	  end;
      450          else
      451 	  do;
      452 	     call sub_err_ (dm_error_$programming_error, myname,
      453 		ACTION_CANT_RESTART, null, 0,
      454 		"^/Control interval ^d is in collection ^3bo but was expected to^/be in collection ^3bo."
      455 		, gcp_p_ci_id, gcp_p_ci_ptr -> bci_header.collection_id,
      456 		gcp_p_collection_id);
      457 	  end;
      458       end;
      459 
      460    return;
      461 
      462 REALLY_GET_CI_PTR:
      463    proc (rgcp_p_is_first);
      464 
      465    dcl	 rgcp_p_is_first	    bit (1) aligned;
      466    dcl	 file_manager_$get_ci_ptr
      467 			    entry (bit (36) aligned, fixed bin (27), ptr,
      468 			    fixed bin (35));
      469 
      470    call file_manager_$get_ci_ptr (gcp_p_file_opening_id, (gcp_p_ci_id),
      471         gcp_p_ci_ptr, gcp_code);
      472    if gcp_code ^= 0
      473    then if gcp_code ^= dm_error_$ci_not_allocated
      474         then call ERROR_RETURN (gcp_code);
      475         else if rgcp_p_is_first
      476         then call ERROR_RETURN (dm_error_$no_element);
      477         else call sub_err_ (gcp_code, myname, ACTION_CANT_RESTART, null, 0,
      478 	        "^/Control interval ^d was expected to be ^[next^;previous^] from^/control interval ^d."
      479 	        , gcp_p_ci_id, (position_change > 0), most_recent_ci_id);
      480 
      481    end REALLY_GET_CI_PTR;
      482 
      483    end GET_CI_PTR;
      484 
      485 TERMINATE_CI_PTR:
      486    proc (tcp_p_ci_ptr);
      487 
      488    dcl	 tcp_p_ci_ptr	    ptr;
      489 
      490    return;
      491 
      492    end TERMINATE_CI_PTR;
      493 
      494 SET_DEFAULT_POSITION:
      495    proc (sdp_p_file_opening_id, sdp_p_collection_id, sdp_p_position_change,
      496         sdp_p_ci_id, sdp_p_slot_index);
      497 
      498    dcl	 (sdp_p_file_opening_id, sdp_p_collection_id)
      499 			    bit (36) aligned;
      500    dcl	 sdp_p_position_change  fixed bin (17);
      501    dcl	 sdp_p_ci_id	    fixed bin (24) unsigned;
      502    dcl	 sdp_p_slot_index	    fixed bin (17);
      503    dcl	 sdp_code		    fixed bin (35);
      504    dcl	 sdp_cm_info_ptr	    ptr;
      505 
      506    call cm_opening_info$full_get (sdp_p_file_opening_id, sdp_p_collection_id,
      507         sdp_cm_info_ptr, sdp_code);
      508    if sdp_code ^= 0
      509    then call ERROR_RETURN (sdp_code);
      510 
      511    call CHECK_VERSION (sdp_cm_info_ptr -> cm_info.version, CM_INFO_VERSION_2,
      512         "cm_info");
      513 
      514    call CHECK_VERSION (sdp_cm_info_ptr -> cm_info.header_ptr
      515         -> collection_header.version, COLLECTION_HEADER_VERSION_2,
      516         "collection_header");
      517 
      518    if sdp_cm_info_ptr -> cm_info.header_ptr
      519         -> collection_header.control_interval_storage_method
      520         ^= UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      521    then call sub_err_ (dm_error_$unimplemented_cism, myname,
      522 	   ACTION_CANT_RESTART, null, 0,
      523 	   "^/Expected control interval storage method ^d; received ^d.",
      524 	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD,
      525 	   sdp_cm_info_ptr -> cm_info.header_ptr
      526 	   -> collection_header.control_interval_storage_method);
      527 
      528 
      529    if sdp_p_position_change > 0
      530    then
      531       do;
      532          sdp_p_slot_index = LOWEST_SLOT_INDEX;
      533          sdp_p_ci_id = GET_FIRST_CI ();
      534          if sdp_p_ci_id = 0 & sdp_p_collection_id ^= HEADER_COLLECTION_ID
      535          then call ERROR_RETURN (dm_error_$no_element);
      536       end;
      537    else if sdp_p_position_change < 0
      538    then
      539       do;
      540          sdp_p_slot_index = HIGHEST_SLOT_INDEX;
      541          sdp_p_ci_id = GET_LAST_CI ();
      542          if sdp_p_ci_id = 0 & sdp_p_collection_id ^= HEADER_COLLECTION_ID
      543          then call ERROR_RETURN (dm_error_$no_element);
      544       end;
      545    else call ERROR_RETURN (dm_error_$beginning_of_collection);
      546 
      547    return;
      548 
      549 
      550 GET_FIRST_CI:
      551    proc () returns (fixed bin (24) unsigned);
      552 
      553    return (sdp_cm_info_ptr -> cm_info.storage_record_ptr
      554         -> unblocked_storage_record.first_control_interval);
      555 
      556    end GET_FIRST_CI;
      557 
      558 
      559 GET_LAST_CI:
      560    proc () returns (fixed bin (24) unsigned);
      561 
      562    return (sdp_cm_info_ptr -> cm_info.storage_record_ptr
      563         -> unblocked_storage_record.last_control_interval);
      564 
      565    end GET_LAST_CI;
      566 
      567    end SET_DEFAULT_POSITION;
      568 
  1     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the declaration of an element identifier.  Element
  1     6*   identifiers consist of two parts, the id (number) of the control interval
  1     7*   in which the element resides, and the index into the slot table of
  1     8*   the element in the control interval.  The declaration of the element_id 
  1     9*   structure reflects this division of the element identifier.  The structure 
  1    10*   is based on the automatic bit string element_id_string because programs
  1    11*   generally pass bit strings (element_id_string) to each other, then 
  1    12*   interpret the bit string by overlaying the element_id structure ony if
  1    13*   it is necessary to access the parts of the id.  Basing element_id on
  1    14*   addr(element_id_string) instead of on a pointer removes the necessity
  1    15*   for always setting that pointer explicitly and guarantees that changes
  1    16*   made to the string or structure do not get inconsistent.
  1    17*
  1    18*   Changes made to element_id must also be made to datum_id, declared in 
  1    19*   dm_cm_datum.incl.pl1.
  1    20**/
  1    21 
  1    22 /* HISTORY:
  1    23*Written by Matthew Pierret, 04/01/82.
  1    24*Modified:
  1    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3,ll79 */
  1    29 
  1    30      dcl	   element_id_string      bit (36) aligned;
  1    31 
  1    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  1    33 	     2 control_interval_id
  1    34 			      fixed bin (24) unal unsigned,
  1    35 	     2 index	      fixed bin (12) unal unsigned;
  1    36 
  1    37 
  1    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      569 
      570 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        The collection_manager_ manages the structure of the addressable
  2     6*   portion of a control interval.  The addressable portion is that portion of
  2     7*   a control interval which the file_manager_ will allow the
  2     8*   collection_manager_ to address.  In this description control interval will
  2     9*   be used to mean the addressable portion of a control interval.
  2    10*   
  2    11*        A control interval is divided into four parts: the header, the datum
  2    12*   position table (also known as the slot table or slots), un-used space and
  2    13*   used space.  The beginning of the header is at offset 0, and the end of the
  2    14*   used space is at the end of the control interval (curently offset 4072).
  2    15*   Pictoriarly, a control interval is structured as follows:
  2    16*   
  2    17*   ----------------------------------------------------------------------
  2    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  2    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  2    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  2    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  2    22*   ----------------------------------------------------------------------
  2    23*                                           ^ ^    ^      ^    ^  ^   ^
  2    24*                                           | |    |      |    |  |   |
  2    25*                                           | |...........|.......|...|
  2    26*                        start of used space|      |           |      |
  2    27*                                                  |           |  each|
  2    28*                                          scattered free space|  is a used
  2    29*                                                                 datum
  2    30*   
  2    31*      The basic_control_interval structure describes the header
  2    32*   (basic_control_interval.header, bci_header) and the slots
  2    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  2    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  2    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  2    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  2    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  2    38**/
  2    39 
  2    40 /* HISTORY:
  2    41*Written by Matthew Pierret, 02/07/82.
  2    42*Modified:
  2    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  2    44*            and its sub-structures.
  2    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  2    46*            basic_ci_header to bci_header. Added previous_control_interval.
  2    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  2    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  2    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  2    50*            is not used.
  2    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  2    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  2    53**/
  2    54 
  2    55 /* format: style2 */
  2    56      dcl	   1 basic_control_interval
  2    57 			      aligned based (basic_control_interval_ptr),
  2    58 	     2 header	      like bci_header,
  2    59 	     2 datum_position_table
  2    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  2    61 
  2    62 
  2    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  2    64 	     2 layout_type	      char (4) aligned,
  2    65 	     2 collection_id      bit (36) aligned,
  2    66 	     2 next_control_interval
  2    67 			      fixed bin (24) uns unal,
  2    68 	     2 previous_control_interval
  2    69 			      fixed bin (24) uns unal,
  2    70 	     2 flags	      unal,
  2    71 	       3 continuation_datum_is_present
  2    72 			      bit (1) unal,
  2    73 	       3 free_slot_is_present
  2    74 			      bit (1) unal,
  2    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  2    76 	     2 scattered_free_space
  2    77 			      fixed bin (17) unal,
  2    78 	     2 start_of_used_space
  2    79 			      fixed bin (17) unal,
  2    80 	     2 number_of_datums   fixed bin (17) unal;
  2    81 
  2    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  2    83 	     2 flags	      unal,
  2    84 	       3 special_format_datum
  2    85 			      bit (1) unal,		/* reserved */
  2    86 	       3 is_continued     bit (1) unal,
  2    87 	       3 is_continuation  bit (1) unal,
  2    88 	       3 mbz	      bit (1) unal,		/* reserved */
  2    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  2    90 	     2 length_in_bits     fixed bin (17) uns unal;
  2    91 
  2    92      dcl	   basic_control_interval_ptr
  2    93 			      ptr;
  2    94      dcl	   bci_header_ptr	      ptr;
  2    95      dcl	   datum_slot_ptr	      ptr;
  2    96 
  2    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  2    98 
  2    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      571 
      572 
  3     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*   Contains constants useful in describing parts of a basic control interval.
  3     6**/
  3     7 
  3     8 /* HISTORY:
  3     9*Written by Matthew Pierret, 09/20/84.
  3    10*Modified:
  3    11**/
  3    12 
  3    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  3    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  3    15 			      init (20) fixed bin internal static options (constant);
  3    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  3    17 			      init (20) fixed bin internal static options (constant);
  3    18 
  3    19 
  3    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      573 
      574 
  4     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        A storage record is an extension to the collection_header structure.
  4     6*   It is expected to be more volatile than collection_header and has a 
  4     7*   different format depending on the control interval storage method in use
  4     8*   for the collection.  A storage record is stored as an element in the 
  4     9*   file's Header Collection with the element identifier 
  4    10*   collection_header.storage_record_element_id.
  4    11*   
  4    12*        The unblocked_storage_record contains the control interval numbers
  4    13*   of the first and last control intervals of a collection.  Unblocked
  4    14*   control intervals are chained together, so all control intervals can be 
  4    15*   found by starting at one end and following the chain forward or backward.
  4    16*   
  4    17*        The blocked_storage_record is not yet used, as the Blocked Control
  4    18*   Interval Storage Method is not yet implemented.
  4    19**/
  4    20 
  4    21 /* HISTORY:
  4    22*Written by Matthew Pierret, 09/24/84.
  4    23*Modified:
  4    24**/
  4    25 
  4    26 /* format: style2,ind3,ll79 */
  4    27 
  4    28      dcl	   1 unblocked_storage_record
  4    29 			      aligned
  4    30 			      based (unblocked_storage_record_ptr),
  4    31 	     2 first_control_interval
  4    32 			      fixed bin (24) uns,
  4    33 	     2 last_control_interval
  4    34 			      fixed bin (24) uns;
  4    35 
  4    36      dcl	   1 blocked_storage_record
  4    37 			      aligned based (blocked_storage_record_ptr),
  4    38 	     2 last_control_interval
  4    39 			      fixed bin (24) uns,
  4    40 	     2 number_of_blocks   fixed bin (17) unal,
  4    41 	     2 number_of_control_intervals_per_block
  4    42 			      fixed bin (17) unal,
  4    43 	     2 allocation_map_element_id
  4    44 			      bit (36) aligned;
  4    45 
  4    46      dcl	   unblocked_storage_record_ptr
  4    47 			      ptr init (null ());
  4    48      dcl	   blocked_storage_record_ptr
  4    49 			      ptr init (null ());
  4    50 
  4    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      575 
      576 
  5     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*        The cm_info structure is used to hold per-process opening information
  5     5*   about a collection.  It is generally allocated in the process' DM free
  5     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  5     7*   is used to provide access the cm_info structure, keeping it in a hash
  5     8*   table keyed on file opening id and collection id combined.
  5     9*        Currently cm_info is never freed until the process terminates.  Each
  5    10*   time a new transaction is started, detected when the current transaction
  5    11*   id of a process differs from cm_info.current_transaction_id, the information
  5    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  5    13*   demand, as most modules do not need the information in the storage record.
  5    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  5    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  5    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  5    17*   requested, it is placed at the location pointed to by
  5    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  5    19**/
  5    20 
  5    21 /* HISTORY:
  5    22*Written by Matthew Pierret, 10/27/82. 
  5    23*Modified:
  5    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  5    25*            storage_record_buffer_ptr. This points to the storage_record.
  5    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  5    27*            but storage_record_buffer_ptr continues to point at where the
  5    28*            storage_record was. When the storge_record is again requested,
  5    29*            it is put back in the same place rather than allocating a new
  5    30*            storage_record.
  5    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  5    32*            init clause from the version component.
  5    33**/
  5    34 
  5    35 /* format: style2,ind3,ll79 */
  5    36 
  5    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  5    38 	     2 version	      char (8),
  5    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  5    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  5    41 	     2 collection_id      bit (36) aligned init ("0"b),
  5    42 	     2 header_ptr	      ptr init (null),
  5    43 	     2 storage_record_ptr ptr init (null),
  5    44 	     2 storage_record_buffer_ptr
  5    45 			      ptr init (null);
  5    46 
  5    47      dcl	   cm_info_ptr	      ptr init (null);
  5    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  5    49 			      internal static options (constant);
  5    50 
  5    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      577 
      578 
  6     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*       Associated with each collection is the following collection_header
  6     5*   structure stored as an element in the Header Collection of the file.
  6     6*   The identifier of this element is also the idenfifier of the collection.
  6     7*   Even the Header Collection has a collection_header stored in the Header
  6     8*   Collection itself in the element identified by the constant
  6     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  6    10*   The information in collection_header is expected to be stable information.
  6    11*   The structure elements are described as follows:
  6    12*   
  6    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  6    14*   
  6    15*   flags.fixed_size_elements indicates, if on that all elements in the
  6    16*   collection are of a fixed length.
  6    17*   
  6    18*   flags.thread_elements indicates that elements in a collection are to be
  6    19*   threaded in a linked list.  This is currrently unupported.
  6    20*   
  6    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  6    22*   a collection are to be threaded in a linked list.  This is only useful if
  6    23*   the control interval storage method is blocked.
  6    24*   
  6    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  6    26*   
  6    27*   control_interval_storage_method is the method of storage management of
  6    28*   control intervals for this collection, either
  6    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  6    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  6    31*   dm_cism_info.incl.pl1.
  6    32*   
  6    33*   element_storage_method is the method of storage management of elements in
  6    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  6    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  6    36*   
  6    37*   maximum_element_size is the maximum size of an element in bits in this
  6    38*   collection.
  6    39*   
  6    40*   header_record_element_id is the identifier of an element containing a
  6    41*   caller-defined header for this collection.  If equal to "0"b, no
  6    42*   caller-defined header yet exists.  The put_header collection_manager_
  6    43*   operation stores such a header.
  6    44*   
  6    45*   storage_record_element_id is the identifier of the element containing the
  6    46*   storage_record for this collection.  The storage_record contains
  6    47*   information expected to be dynamic, such as the identifier of the last
  6    48*   control interval of the collection.  Its format is also dependent upon the
  6    49*   storage methods in effect for this collection.  storage_record structures
  6    50*   are declared in dm_cm_storage_record.incl.pl1.
  6    51*
  6    52**/
  6    53 
  6    54 /* HISTORY:
  6    55*Written by Matthew Pierret, 04/01/82.
  6    56*Modified:
  6    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  6    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  6    59*            storage_record_area out, leaving storage_record_element_id behind.
  6    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  6    61**/
  6    62 
  6    63 /* format: style2,ind3,ll79 */
  6    64 
  6    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  6    66 	     2 version	      char (8),
  6    67 	     2 flags	      unaligned,
  6    68 	       3 fixed_size_elements
  6    69 			      bit (1),
  6    70 	       3 thread_elements  bit (1),
  6    71 	       3 thread_control_intervals
  6    72 			      bit (1),
  6    73 	       3 must_be_zero1    bit (15),
  6    74 	     2 control_interval_storage_method
  6    75 			      fixed bin (17) unal,
  6    76 	     2 element_storage_method
  6    77 			      fixed bin (17),
  6    78 	     2 maximum_element_size
  6    79 			      fixed bin (35),
  6    80 	     2 header_record_element_id
  6    81 			      bit (36) aligned,
  6    82 	     2 storage_record_element_id
  6    83 			      bit (36) aligned;
  6    84 
  6    85      dcl	   collection_header_ptr  ptr;
  6    86      dcl	   COLLECTION_HEADER_VERSION_2
  6    87 			      init ("col_hdr2") char (8) aligned
  6    88 			      int static options (constant);
  6    89 
  6    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      579 
      580 
  7     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  7     6*     structures, as well as constants relevant to control interval storage
  7     7*     management.  These structures and constants are used by several managers.
  7     8*     The structures each describe a method of control interval storage 
  7     9*     management.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*
  7    14*Written 02/07/82 by Matthew Pierret.
  7    15*Modified:
  7    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  7    17*            a version string.
  7    18**/
  7    19 
  7    20 /* format: style2 */
  7    21 
  7    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  7    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    25 	     2 number_of_control_intervals_per_block
  7    26 			      fixed bin (17);
  7    27 
  7    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  7    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    31 	     2 must_be_zero	      fixed bin (17);
  7    32 
  7    33      dcl	   blocked_cism_info_ptr  ptr;
  7    34      dcl	   unblocked_cism_info_ptr
  7    35 			      ptr;
  7    36 
  7    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  7    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    39 			      fixed bin init (1) internal static options (constant);
  7    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    41 			      fixed bin init (2) internal static options (constant);
  7    42 
  7    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      581 
      582 
  8     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*   Contains entry declarations of internally available collection_manager_
  8     6*   entries.  Entries which are only available via the collection_manager_
  8     7*   transfer vector are not included here, but are declared instead in 
  8     8*   dm_collmgr_entry_dcls.incl.pl1.
  8     9**/
  8    10 
  8    11 /* HISTORY:
  8    12*Written by Mathew Pierret, 04/01/82.
  8    13*Modified:
  8    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  8    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  8    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  8    17*            Added cm_get_element$info*, $header*.  The former is used when
  8    18*            the caller has a cm_info structure already; the latter is used to
  8    19*            get collection headers.
  8    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  8    21*            Added cm_allocate_element$info.
  8    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  8    23*            calling sequence for returning free space.
  8    24*            Added cm_free_cn_datum("" $header).
  8    25*01/07/83 by Matthew Pierret:  Added:
  8    26*            cm_allocate_element$buffered("" _info);
  8    27*            cm_put_element$buffered("" _info);
  8    28*            cm_put_datum_in_place$buffered("" _continued);
  8    29*            cm_put_datum_in_pool$buffered("" _continued);
  8    30*            cm_compact$buffered.
  8    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  8    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  8    33*            Added cm_opening_info$get_storage_record.
  8    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  8    35*            id of the previous datum.
  8    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  8    37*            which is for the number of slots after allocation.
  8    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  8    39*            header header_return_slot).
  8    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  8    41*            Added cm_get_element$bypass_info.
  8    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  8    43*            cm_free_opening_info.
  8    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  8    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  8    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  8    47*            return flags indicating if a datum fits in the ci and the pool.
  8    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  8    49*            returned the new value of bci_header.free_slot_is_present.
  8    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  8    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  8    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  8    53*            calling sequence as other cm_get_element entries.
  8    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  8    55*            and cm_allocate_element to cm_put.
  8    56*            Switched the element_length/element_ptr parameter pair to be
  8    57*            element_ptr/element_length in cm_modify and cm_put.
  8    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  8    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  8    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  8    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  8    62*            Removed cm_find_free_space. Commented out un-used entries.
  8    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  8    64*            Re-named free element and free datum entries to use delete instead
  8    65*            of free, and cm_recursive_put to cm_recursive_modify.
  8    66*            Removed cm_get_element$bypass_info.
  8    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  8    68*            that cm_modify$buffered uses it.
  8    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  8    70**/
  8    71 
  8    72 /* format: style2,ind3 */
  8    73 
  8    74 
  8    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  8    77      dcl	   cm_allocate_ci$info_header
  8    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  8    79 
  8    80 
  8    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    84      dcl	   cm_compact$buffered_replacement
  8    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    86 
  8    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    88 
  8    89      dcl	   cm_delete_cn_datum$header
  8    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    91 
  8    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    93 			      fixed bin (35));
  8    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  8    95 
  8    96      dcl	   cm_determine_free_space$all
  8    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  8    98      dcl	   cm_determine_free_space$effective
  8    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   cm_determine_free_space$does_new_datum_fit
  8   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  8   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  8   104 
  8   105 /**** Not yet used *********************************************************
  8   106*     dcl	   cm_determine_free_space$does_replacement_fit
  8   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  8   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  8   109*************************************************************************** */
  8   110 
  8   111      dcl	   cm_find_ci_to_alloc_datum
  8   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  8   113 			      fixed bin (24) uns, fixed bin (35));
  8   114 
  8   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  8   116 			      bit (1) aligned, fixed bin (35));
  8   117 
  8   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  8   119      dcl	   cm_free_ci$raw_return_prev_next
  8   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  8   121 			      fixed bin (24) uns, fixed bin (35));
  8   122      dcl	   cm_free_ci$trace_thread_modifications_on
  8   123 			      entry ();
  8   124      dcl	   cm_free_ci$trace_thread_modifications_off
  8   125 			      entry ();
  8   126 
  8   127 
  8   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   129 
  8   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   131      dcl	   cm_get_bci_header$exclusive
  8   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   134 
  8   135 /**** Not yet used ********************************************************
  8   136*     dcl	   cm_get_bci_header$slot_exclusive
  8   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   138*************************************************************************** */
  8   139 
  8   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   142      dcl	   cm_get_element$exclusive
  8   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   145 
  8   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   148 			      fixed bin (35), fixed bin (35));
  8   149 
  8   150 /**** Not yet used ********************************************************
  8   151*     dcl	   cm_get_element_portion$exclusive
  8   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   154*			      fixed bin (35), fixed bin (35));
  8   155*************************************************************************** */
  8   156 
  8   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   161 
  8   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   163 			      fixed bin (35), fixed bin (35));
  8   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   165 			      fixed bin (35), fixed bin (35));
  8   166 
  8   167 /******* Not yet used *****************************************************
  8   168*     dcl	   cm_modify$buffered_info
  8   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   170*			      fixed bin (35));
  8   171*****************************************************************************/
  8   172 
  8   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   174      dcl	   cm_modify$unprotected_info
  8   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   176 
  8   177 
  8   178 /******* Not yet used *****************************************************
  8   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  8   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  8   181*****************************************************************************/
  8   182 
  8   183 
  8   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   185      dcl	   cm_opening_info$get_storage_record
  8   186 			      entry (ptr, fixed bin (35));
  8   187      dcl	   cm_opening_info$full_get
  8   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   189      dcl	   cm_opening_info$opening_table_ptr
  8   190 			      entry () returns (ptr);
  8   191 
  8   192      dcl	   cm_postcommit_increment
  8   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   194 
  8   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   196 			      fixed bin (35), fixed bin (35));
  8   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   198 			      fixed bin (35), fixed bin (35));
  8   199 
  8   200 /******* Not yet used *****************************************************
  8   201*     dcl	   cm_put$buffered_info
  8   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   203*			      fixed bin (35));
  8   204*****************************************************************************/
  8   205 
  8   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   207 
  8   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   209 			      fixed bin (35));
  8   210 
  8   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   212 
  8   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   214 			      fixed bin (35));
  8   215      dcl	   cm_put_datum_in_place$buffered
  8   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   217      dcl	   cm_put_datum_in_place$buffered_continued
  8   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   219 			      fixed bin (35));
  8   220      dcl	   cm_put_datum_in_place$continued
  8   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   223 
  8   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   225 			      fixed bin (35));
  8   226      dcl	   cm_put_datum_in_pool$buffered
  8   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   228      dcl	   cm_put_datum_in_pool$buffered_continued
  8   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   230 			      fixed bin (35));
  8   231      dcl	   cm_put_datum_in_pool$continued
  8   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   234 
  8   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   236 			      fixed bin (35));
  8   237      dcl	   cm_put_ordered_element$buffered
  8   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   239 			      fixed bin (35));
  8   240 
  8   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  8   242 
  8   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  8   244 			      fixed bin (35));
  8   245 
  8   246 
  8   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  8   248 			      entry ();
  8   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  8   250 			      entry ();
  8   251 
  8   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      583 
      584 
  9     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  9     2 /* format: style3 */
  9     3 
  9     4 /* These constants are to be used for the flags argument of sub_err_ */
  9     5 /* They are just "string (condition_info_header.action_flags)" */
  9     6 
  9     7 declare	(
  9     8 	ACTION_CAN_RESTART	init (""b),
  9     9 	ACTION_CANT_RESTART init ("1"b),
  9    10 	ACTION_DEFAULT_RESTART
  9    11 			init ("01"b),
  9    12 	ACTION_QUIET_RESTART
  9    13 			init ("001"b),
  9    14 	ACTION_SUPPORT_SIGNAL
  9    15 			init ("0001"b)
  9    16 	)		bit (36) aligned internal static options (constant);
  9    17 
  9    18 /* End include file */
      585 
      586 
 10     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*        Contains the identifier of the Header Collection for a file
 10     6*   managed by the collection_manager_.  This is used by callers of 
 10     7*   collection_manager who wish to maintain their own file header or who wish
 10     8*   to maintain their own collection header information beyond the caller
 10     9*   collection header provided by colleciton_manager_$(get put)_header.
 10    10**/
 10    11 
 10    12 /* HISTORY:
 10    13*Written by Matthew Pierret, 09/24/84.
 10    14*Modified:
 10    15**/
 10    16 
 10    17 /* format: style2,ind3,ll79 */
 10    18 
 10    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
 10    20 			      aligned internal static options (constant);
 10    21 
 10    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      587 
      588    end cm_get_id$id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.7  cm_get_id.pl1                     >spec>on>7192.pbf-04/04/85>cm_get_id.pl1
569          1    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
571          2    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
573          3    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
575          4    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
577          5    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
579          6    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
581          7    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
583          8    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
585          9    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
587         10    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000046 constant        bit(36)                  initial dcl 9-7 set ref 236* 247* 288* 312* 327*
                                                                                  452* 477* 518*
BASIC_CI_LAYOUT_1               000004 constant        char(4)                  initial dcl 2-97 set ref 327 327*
CM_INFO_VERSION_2               000002 constant        char(8)                  initial dcl 5-48 set ref 511*
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 6-86 set ref 514*
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 3-13 ref 370 386
HEADER_COLLECTION_ID                   constant        bit(36)                  initial dcl 10-19 ref 534 542
HIGHEST_SLOT_INDEX                     constant        fixed bin(17,0)          initial dcl 155 ref 280 540
IS_FIRST                               constant        bit(1)                   initial dcl 160 set ref 418 426*
LIMIT_TO_STOP_INFINITE_LOOPING  000005 constant        fixed bin(35,0)          initial dcl 152 ref 230
LOWEST_SLOT_INDEX                      constant        fixed bin(17,0)          initial dcl 155 ref 272 532
NOT_FIRST                              constant        bit(1)                   initial dcl 160 set ref 431 437*
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                000053 constant        fixed bin(17,0)          initial dcl 7-40 set ref 518 518*
addr                                                   builtin function         dcl 146 ref 226 227 294 295
basic_control_interval                 based           structure                level 1 dcl 2-56
bci_header                             based           structure                level 1 dcl 2-63
blocked_storage_record_ptr      000124 automatic       pointer                  initial dcl 4-48 set ref 4-48*
ccl_p_ci_layout                        parameter       char(4)                  dcl 325 set ref 323 327 327*
ci_idx                          000100 automatic       fixed bin(17,0)          dcl 124 set ref 230*
ci_ptr                          000114 automatic       pointer                  initial dcl 136 set ref 136* 233* 236 236 247 247
                                                                                  258* 265 270 274 278 299* 301 340 340*
cm_info                                based           structure                level 1 dcl 5-37
cm_info_ptr                     000126 automatic       pointer                  initial dcl 5-47 set ref 5-47*
cm_opening_info$full_get        000034 constant        entry                    external dcl 8-187 ref 506
collection_header                      based           structure                level 1 dcl 6-65
collection_id                   000106 automatic       bit(36)                  initial dcl 129 in procedure "cm_get_id$id" set ref
                                                                                  129* 216* 221* 233*
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 2-63
                                                                                  in procedure "cm_get_id$id" set ref 442 452*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "input_element_id" packed
                                                                                  unsigned unaligned dcl 140 in procedure
                                                                                  "cm_get_id$id" ref 226
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 1-32 in procedure "cm_get_id$id" set
                                                                                  ref 294*
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-65 set ref 518 518*
current_ci_id                   000103 automatic       fixed bin(24,0)          initial unsigned dcl 126 set ref 126* 221* 226* 233*
                                                                                  236* 236* 247* 247* 263 270* 278* 294
current_slot_index              000101 automatic       fixed bin(17,0)          dcl 124 set ref 221* 227* 258* 272* 280* 295
cv_p_expected_version                  parameter       char(8)                  dcl 309 set ref 306 312 312*
cv_p_received_version                  parameter       char(8)                  dcl 308 set ref 306 312 312*
cv_p_structure_name                    parameter       char                     unaligned dcl 310 set ref 306 312*
datum_position_table      5            based           structure                array level 2 dcl 2-56
datum_slot                             based           structure                level 1 dcl 2-82
dm_error_$beginning_of_collection
                                000012 external static fixed bin(35,0)          dcl 172 set ref 274* 545*
dm_error_$ci_not_allocated      000014 external static fixed bin(35,0)          dcl 172 ref 472
dm_error_$ci_not_in_collection  000016 external static fixed bin(35,0)          dcl 172 set ref 448*
dm_error_$end_of_collection     000020 external static fixed bin(35,0)          dcl 172 set ref 265*
dm_error_$no_element            000022 external static fixed bin(35,0)          dcl 172 set ref 475* 534* 542*
dm_error_$programming_error     000024 external static fixed bin(35,0)          dcl 172 set ref 236* 247* 288* 452*
dm_error_$unimplemented_ci_version
                                000030 external static fixed bin(35,0)          dcl 172 set ref 327*
dm_error_$unimplemented_cism    000026 external static fixed bin(35,0)          dcl 172 set ref 518*
element_id                             based           structure                level 1 dcl 1-32
element_id_string               000120 automatic       bit(36)                  dcl 1-30 set ref 294 295 297
er_p_code                              parameter       fixed bin(35,0)          dcl 347 ref 345 350
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 182 set ref 312*
file_manager_$get_ci_ptr        000036 constant        entry                    external dcl 466 ref 470
file_opening_id                 000105 automatic       bit(36)                  initial dcl 129 set ref 129* 215* 221* 233*
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 4-28 ref 553
flags                     5            based           structure                array level 3 packed unaligned dcl 2-56
gcp_code                        000227 automatic       fixed bin(35,0)          dcl 412 set ref 470* 472 472 472* 477*
gcp_p_ci_id                            parameter       fixed bin(24,0)          unsigned dcl 407 set ref 401 452* 470 477*
gcp_p_ci_ptr                           parameter       pointer                  dcl 409 set ref 401 415 422* 432 435* 440 442 452
                                                                                  470*
gcp_p_collection_id                    parameter       bit(36)                  dcl 406 set ref 401 442 452*
gcp_p_file_opening_id                  parameter       bit(36)                  dcl 405 set ref 401 470*
gcp_p_input_ci_ptr                     parameter       pointer                  dcl 408 ref 401 419 422 432
gcp_this_is_first_look_at_ci    000226 automatic       bit(1)                   dcl 410 set ref 418* 431* 445
header                                 based           structure                level 2 dcl 2-56
header_ptr                6            based           pointer                  initial level 2 dcl 5-37 ref 514 518 518
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 1-32 in procedure "cm_get_id$id" set
                                                                                  ref 295*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "input_element_id" packed
                                                                                  unsigned unaligned dcl 140 in procedure
                                                                                  "cm_get_id$id" ref 227
input_ci_ptr                    000116 automatic       pointer                  initial dcl 136 set ref 136* 194* 206* 233* 340
input_element_id                       based           structure                level 1 dcl 140
input_element_id_string         000107 automatic       bit(36)                  initial dcl 129 set ref 129* 218* 226 227
is_absolute_position            000111 automatic       bit(1)                   initial dcl 133 set ref 133* 217* 221
is_continuation           5(02)        based           bit(1)                   array level 4 packed unaligned dcl 2-56 ref 370 386
last_control_interval
                          1            based           fixed bin(24,0)          level 2 unsigned dcl 4-28 ref 562
layout_type                            based           char(4)                  level 2 dcl 2-63 set ref 440*
max                                                    builtin function         dcl 146 ref 364
min                                                    builtin function         dcl 146 ref 380
most_recent_ci_id               000104 automatic       fixed bin(24,0)          initial unsigned dcl 126 set ref 126* 236 236 236*
                                                                                  247 247* 263* 477*
myname                          000006 constant        varying char(32)         initial dcl 150 set ref 236* 247* 288* 312* 327*
                                                                                  452* 477* 518*
next_control_interval
                          2            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-63 set ref
                                                                                  247 247* 265 270
null                                                   builtin function         dcl 146 ref 136 136 194 204 236 236 247 247 288 288
                                                                                  4-46 4-48 5-47 312 312 327 327 415 419 452 452 477
                                                                                  477 518 518
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 2-56 ref 364 380
offset_in_bytes           5(04)        based           fixed bin(15,0)          array level 3 packed unsigned unaligned dcl 2-56 ref
                                                                                  370 386
p_code                                 parameter       fixed bin(35,0)          dcl 120 set ref 100 199 211* 298* 350*
p_collection_id                        parameter       bit(36)                  dcl 111 ref 100 199 216
p_file_opening_id                      parameter       bit(36)                  dcl 110 ref 100 199 215
p_input_ci_ptr                         parameter       pointer                  dcl 118 ref 199 206
p_input_element_id_string              parameter       bit(36)                  dcl 112 ref 100 199 218
p_is_absolute_position                 parameter       bit(1)                   dcl 117 ref 100 199 217
p_position_change                      parameter       fixed bin(17,0)          dcl 116 ref 100 199 219
p_return_ci_ptr                        parameter       pointer                  dcl 119 set ref 199 204* 301*
p_return_element_id_string             parameter       bit(36)                  dcl 114 set ref 100 199 213* 297*
position_change                 000102 automatic       fixed bin(17,0)          dcl 124 set ref 219* 221* 230 236 247 258* 260 265
                                                                                  288 288* 477
previous_control_interval
                          2(24)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-63 set ref
                                                                                  236 236* 274 278
ptc_p_ci_ptr                           parameter       pointer                  dcl 359 ref 356 364 370 370 380 386 386
ptc_p_current_slot_index               parameter       fixed bin(17,0)          dcl 360 set ref 356 364 378* 380 394*
ptc_p_position_change                  parameter       fixed bin(17,0)          dcl 360 set ref 356 364 364 370* 370 380 386* 386
ptc_slot_idx                    000174 automatic       fixed bin(17,0)          dcl 362 set ref 364* 370 370 378* 380* 386 386 394*
return_element_id_string        000110 automatic       bit(36)                  initial dcl 129 set ref 129*
rgcp_p_is_first                        parameter       bit(1)                   dcl 465 ref 462 475
sdp_cm_info_ptr                 000254 automatic       pointer                  dcl 504 set ref 506* 511 514 518 518 553 562
sdp_code                        000252 automatic       fixed bin(35,0)          dcl 503 set ref 506* 508 508*
sdp_p_ci_id                            parameter       fixed bin(24,0)          unsigned dcl 501 set ref 494 533* 534 541* 542
sdp_p_collection_id                    parameter       bit(36)                  dcl 498 set ref 494 506* 534 542
sdp_p_file_opening_id                  parameter       bit(36)                  dcl 498 set ref 494 506*
sdp_p_position_change                  parameter       fixed bin(17,0)          dcl 500 ref 494 529 537
sdp_p_slot_index                       parameter       fixed bin(17,0)          dcl 502 set ref 494 532* 540*
storage_record_ptr       10            based           pointer                  initial level 2 dcl 5-37 ref 553 562
sub_err_                        000010 constant        entry                    external dcl 168 ref 236 247 288 312 327 452 477 518
tcp_p_ci_ptr                           parameter       pointer                  dcl 488 ref 485
terminate_last_ci_ptr           000112 automatic       bit(1)                   initial dcl 133 set ref 133* 195* 205* 299
unblocked_storage_record               based           structure                level 1 dcl 4-28
unblocked_storage_record_ptr    000122 automatic       pointer                  initial dcl 4-46 set ref 4-46*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 6-65
                                                                                  in procedure "cm_get_id$id" set ref 514*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 5-37 in procedure
                                                                                  "cm_get_id$id" set ref 511*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 9-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 9-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 9-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 9-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 3-14
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 7-38
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 7-37
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 3-16
basic_control_interval_ptr             automatic       pointer                  dcl 2-92
bci_header_ptr                         automatic       pointer                  dcl 2-94
blocked_cism_info                      based           structure                level 1 dcl 7-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 7-33
blocked_storage_record                 based           structure                level 1 dcl 4-36
cm_allocate_ci                  000000 constant        entry                    external dcl 8-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 8-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 8-77
cm_compact                      000000 constant        entry                    external dcl 8-81
cm_compact$buffered             000000 constant        entry                    external dcl 8-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 8-84
cm_compact$replacement          000000 constant        entry                    external dcl 8-83
cm_delete                       000000 constant        entry                    external dcl 8-92
cm_delete$info                  000000 constant        entry                    external dcl 8-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 8-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 8-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 8-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 8-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 8-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 8-111
cm_find_free_slot               000000 constant        entry                    external dcl 8-115
cm_free_ci$info                 000000 constant        entry                    external dcl 8-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 8-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 8-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 8-122
cm_free_opening_info            000000 constant        entry                    external dcl 8-128
cm_get_bci_header               000000 constant        entry                    external dcl 8-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 8-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 8-133
cm_get_element                  000000 constant        entry                    external dcl 8-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 8-142
cm_get_element_portion          000000 constant        entry                    external dcl 8-146
cm_get_id$id                    000000 constant        entry                    external dcl 8-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 8-159
cm_modify                       000000 constant        entry                    external dcl 8-162
cm_modify$buffered              000000 constant        entry                    external dcl 8-164
cm_modify$info                  000000 constant        entry                    external dcl 8-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 8-174
cm_opening_info$get             000000 constant        entry                    external dcl 8-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 8-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 8-189
cm_postcommit_increment         000000 constant        entry                    external dcl 8-192
cm_put                          000000 constant        entry                    external dcl 8-195
cm_put$buffered                 000000 constant        entry                    external dcl 8-197
cm_put$info                     000000 constant        entry                    external dcl 8-206
cm_put_basic_element            000000 constant        entry                    external dcl 8-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 8-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 8-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 8-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 8-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 8-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 8-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 8-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 8-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 8-231
cm_put_ordered_element          000000 constant        entry                    external dcl 8-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 8-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 8-241
cm_recursive_modify             000000 constant        entry                    external dcl 8-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 8-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 8-247
collection_header_ptr                  automatic       pointer                  dcl 6-85
datum_slot_ptr                         automatic       pointer                  dcl 2-95
unblocked_cism_info                    based           structure                level 1 dcl 7-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 7-34

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_LAYOUT                 001247 constant        entry                    internal dcl 323 ref 440
CHECK_VERSION                   001145 constant        entry                    internal dcl 306 ref 511 514
ERROR_RETURN                    001340 constant        entry                    internal dcl 345 ref 265 274 448 472 475 508 534 542
                                                                                  545
FINISH                          001330 constant        entry                    internal dcl 337 ref 349
GET_CI_PTR                      001463 constant        entry                    internal dcl 401 ref 233
GET_FIRST_CI                    002232 constant        entry                    internal dcl 550 ref 533
GET_LAST_CI                     002240 constant        entry                    internal dcl 559 ref 541
JOIN                            000433 constant        label                    dcl 211 ref 197 208
LOOP_BACKWARD_THROUGH_SLOTS     001417 constant        label                    dcl 380
LOOP_FORWARD_THROUGH_SLOTS      001353 constant        label                    dcl 364
LOOP_THROUGH_CONTROL_INTERVALS  000464 constant        label                    dcl 230
MAIN_RETURN                     001144 constant        label                    dcl 303 ref 351
POSITION_THROUGH_CI             001347 constant        entry                    internal dcl 356 ref 258
REALLY_GET_CI_PTR               001631 constant        entry                    internal dcl 462 ref 426 437
SET_DEFAULT_POSITION            001763 constant        entry                    internal dcl 494 ref 221
TERMINATE_CI_PTR                001760 constant        entry                    internal dcl 485 ref 299 340 435
cm_get_id$id                    000363 constant        entry                    external dcl 100
ptr                             000410 constant        entry                    external dcl 199

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2550        2610    2334        2560
Length      3230    2334        40         403     214           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_get_id$id                        672 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_get_id$id.  
CHECK_CI_LAYOUT                         internal procedure  shares stack frame of external procedure cm_get_id$id.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_get_id$id.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_get_id$id.  
POSITION_THROUGH_CI                     internal procedure  shares stack frame of external procedure cm_get_id$id.  
GET_CI_PTR                              internal procedure  shares stack frame of external procedure cm_get_id$id.  
REALLY_GET_CI_PTR                       internal procedure  shares stack frame of external procedure cm_get_id$id.  
TERMINATE_CI_PTR                        internal procedure  shares stack frame of external procedure cm_get_id$id.  
SET_DEFAULT_POSITION                    internal procedure  shares stack frame of external procedure cm_get_id$id.  
GET_FIRST_CI                            internal procedure  shares stack frame of external procedure cm_get_id$id.  
GET_LAST_CI                             internal procedure  shares stack frame of external procedure cm_get_id$id.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_get_id$id             000100 ci_idx                      cm_get_id$id
                         000101 current_slot_index          cm_get_id$id
                         000102 position_change             cm_get_id$id
                         000103 current_ci_id               cm_get_id$id
                         000104 most_recent_ci_id           cm_get_id$id
                         000105 file_opening_id             cm_get_id$id
                         000106 collection_id               cm_get_id$id
                         000107 input_element_id_string     cm_get_id$id
                         000110 return_element_id_string    cm_get_id$id
                         000111 is_absolute_position        cm_get_id$id
                         000112 terminate_last_ci_ptr       cm_get_id$id
                         000114 ci_ptr                      cm_get_id$id
                         000116 input_ci_ptr                cm_get_id$id
                         000120 element_id_string           cm_get_id$id
                         000122 unblocked_storage_record_ptr
                                                            cm_get_id$id
                         000124 blocked_storage_record_ptr  cm_get_id$id
                         000126 cm_info_ptr                 cm_get_id$id
                         000174 ptc_slot_idx                POSITION_THROUGH_CI
                         000226 gcp_this_is_first_look_at_ci
                                                            GET_CI_PTR
                         000227 gcp_code                    GET_CI_PTR
                         000252 sdp_code                    SET_DEFAULT_POSITION
                         000254 sdp_cm_info_ptr             SET_DEFAULT_POSITION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_opening_info$full_get      file_manager_$get_ci_ptr      sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$beginning_of_collection                           dm_error_$ci_not_allocated
dm_error_$ci_not_in_collection                              dm_error_$end_of_collection   dm_error_$no_element
dm_error_$programming_error   dm_error_$unimplemented_ci_version                          dm_error_$unimplemented_cism
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    126 000335       129 000337       133 000343       136 000345    4   46 000350    4   48 000351    5   47 000352
    100 000355       195 000376       197 000400       199 000401       204 000423       205 000426       206 000427
    208 000432       211 000433       213 000434       215 000435       216 000440       217 000442       218 000445
    219 000447       221 000451       226 000456       227 000461       230 000464       233 000475       236 000477
    247 000633       258 000760       260 000762       263 000764       265 000766       270 001005       272 001006
    273 001010       274 001011       278 001030       280 001031       286 001033       288 001035       294 001124
    295 001127       297 001131       298 001133       299 001134       301 001141       303 001144       306 001145
    312 001156       319 001246       323 001247       327 001251       333 001327       337 001330       340 001331
    343 001337       345 001340       349 001342       350 001343       351 001346       356 001347       364 001351
    370 001376       378 001412       379 001414       380 001417       386 001442       394 001455       395 001457
    397 001462       401 001463       415 001465       418 001471       419 001473       422 001477       423 001502
    426 001503       428 001505       431 001506       432 001507       435 001513       437 001521       440 001523
    442 001533       445 001541       448 001543       449 001552       452 001553       460 001630       462 001631
    470 001633       472 001653       475 001663       477 001676       481 001757       485 001760       490 001762
    494 001763       506 001765       508 002003       511 002007       514 002030       518 002056       529 002142
    532 002145       533 002147       534 002155       536 002172       537 002173       540 002174       541 002176
    542 002204       544 002221       545 002222       547 002231       550 002232       553 002234       559 002240
    562 002242


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
