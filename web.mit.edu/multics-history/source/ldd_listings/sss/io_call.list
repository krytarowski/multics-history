	COMPILATION LISTING OF SEGMENT io_call
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/27/84  1336.5 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Command interface to iox_ for performing operations on I/O switches. */
       12 
       13 /* Completely rewritten in June 1975 by Larry Johnson */
       14 /* Modified September 1975 by Larry Johnson to check for non-fatal input errors */
       15 /* Modified December 1975 by Larry Johnson to extend position operation types */
       16 /* Modified April 1976 by Larry Johnson to use io_call order in control operations */
       17 /* Modified July 1976 by Larry Johnson to allow entry point names in attach module name. */
       18 /* Modified June 1977 by Larry Johnson for io active function. Command was also split into several modules */
       19 /* Modified: 12 November 1980 by G. Palter to increase possible size of the mode string to 512 */
       20 /* Modified 1/83 by S. Krupp to add handling for new iox_ entry points:
       21*   open_file, close_file, and detach.  Modified attach to call
       22*   iox_$attach_loud rather than attaching switches differently from everyone
       23*   else.  Moved the code that handles entry point names in attach
       24*   module names to attach_name.pl1 which is common code used by all
       25*   iox_$attach entries. */
       26 /* Modified 08/02/83 by Jim Lippard to allow find_iocb as an AF and to print
       27*   the name of the control order in error messages about the control order
       28*   (rather than nonsensically using the name of the I/O switch) */
       29 /* Modified 12/19/83 by Jim Lippard to make open_desc allow -no_quote */
       30 
       31 io_call: io: proc;
       32 
       33 /* Automatic storage */
       34 
       35 dcl  code fixed bin (35);				/* System status code */
       36 dcl  arg_list_ptr ptr;				/* Pointer to argument list */
       37 dcl  arg_ptr ptr;					/* Pointer to current argument */
       38 dcl  arg_len fixed bin;				/* Length of current argument */
       39 dcl  arg2_len fixed bin;				/* Length of a second arg */
       40 dcl  arg2_ptr ptr;					/* Pointer to a second arg */
       41 dcl  n_args fixed bin;				/* Number of arguments on command line */
       42 dcl  next_arg fixed bin;				/* Used in counting args */
       43 dcl  dir char (168);				/* To hold directory names */
       44 dcl  desc_len fixed bin;				/* The length of a description. */
       45 dcl  ename char (32);				/* To hold entry names */
       46 dcl  seg_ptr ptr;					/* Pointer to dir>ename */
       47 dcl  arg_name char (32) var;				/* Name of current arg for error msg */
       48 dcl  attach_entry char (32);				/* For building name of attach entry point */
       49 dcl  iocb_ptr ptr;					/* Pointer to IOCB being processed */
       50 dcl  iocb2_ptr ptr;					/* Pointer to target IOCB during move_attach */
       51 dcl (i, j) fixed bin;				/* A binary number */
       52 dcl  mode fixed bin;				/* Mode for open operation */
       53 dcl  cv_dec_err fixed bin;				/* Error code from cv_dec_check_ */
       54 dcl  data_ptr ptr;					/* Pointer to data if i/o from a segment */
       55 dcl  data_len fixed bin (21);				/* Length of data if io from segment */
       56 dcl  key char (256) var;				/* A key for seek type operations */
       57 dcl  print_sw bit (1);				/* On if results of modes should be printed */
       58 dcl  new_mode_sw bit (1);				/* On if modes command specified a new mode */
       59 dcl  negate_sw bit (1);				/* For calculating position */
       60 dcl  dummy_char char (1);				/* Used when null character string needed */
       61 dcl  n_low fixed bin;				/* Lower bound of param array description */
       62 dcl  n_high fixed bin;				/* Number of entries in param array */
       63 dcl  max_l fixed bin;				/* Max length of an entry in param array */
       64 dcl  msg_ptr ptr;					/* Will point to io_call_msg_$ if needed */
       65 dcl  order char (32);				/* The order on a control operation */
       66 dcl  error entry variable options (variable);		/* Will be com_err_ of active_fnc_err_ */
       67 dcl  af_sw bit (1);					/* Set if invoked as active function */
       68 dcl  af_retp ptr;					/* Pointer to active function return string */
       69 dcl  af_retl fixed bin;				/* Length of active function return string */
       70 dcl  no_quote_sw bit (1);				/* Set by -no_quote */
       71 dcl  ev entry variable;				/* For valid_op operation */
       72 dcl  valid_mode_sw bit (1);				/* To distinguish between valid and test mode ops */
       73 
       74 /* Constants */
       75 
       76 dcl  cmd_name char (7) int static options (constant) init ("io_call"); /* Name of this thing */
       77 
       78 /* This array contains the names of 16 of the possible operations performed by this command. This
       79*   array must agree with the names and positions of the entry variables in the IOCB */
       80 
       81 dcl  opt_name (19) char (14) int static options (constant) init
       82     ("detach_iocb",					/* 1 */
       83      "open",					/* 2 */
       84      "close",					/* 3 */
       85      "get_line",					/* 4 */
       86      "get_chars",					/* 5 */
       87      "put_chars",					/* 6 */
       88      "modes",					/* 7 */
       89      "position",					/* 8 */
       90      "control",					/* 9 */
       91      "read_record",					/* 10 */
       92      "write_record",				/* 11 */
       93      "rewrite_record",				/* 12 */
       94      "delete_record",				/* 13 */
       95      "seek_key",					/* 14 */
       96      "read_key",					/* 15 */
       97      "read_length", 				/* 16 */
       98      "open_file",					/* 17 */
       99      "close_file",					/* 18 */
      100      "detach");					/* 19 */
      101 
      102 /* The remaining operations performed by this command are numbered starting with 20, as follows:
      103*
      104*   20 - attach		21 - find_iocb		22 - look_iocb
      105*   23 - destroy_iocb	24 - move_attach		25 - print_iocb
      106*   26 - attached		27 - opened		28 - closed
      107*   29 - detached		30 - open_desc		31 - attach_desc
      108*   32 - io_module		33 - valid_op		34 - test_mode
      109*   35 - valid_mode
      110**/
      111 
      112 /* This array contains the names of the rest of the operations performed by the command,
      113*   including some abbreviations for things in the first array of operations */
      114 
      115 dcl  opt_name2 (27) char (12) int static options (constant) init
      116     ("attach",					/* 1 -> 20 */
      117      "find_iocb",					/* 2 -> 21 */
      118      "find",					/* 3 -> 21 */
      119      "look_iocb",					/* 4 -> 22 */
      120      "look",					/* 5 -> 22 */
      121      "destroy_iocb",				/* 6 -> 23 */
      122      "destroy",					/* 7 -> 23 */
      123      "write",					/* 8 -> 11 */
      124      "rewrite",					/* 9 -> 12 */
      125      "delete",					/* 10 -> 13 */
      126      "seek",					/* 11 -> 14 */
      127      "move_attach",					/* 12 -> 24 */
      128      "move",					/* 13 -> 24 */
      129      "print_iocb",					/* 14 -> 25 */
      130      "piocb",					/* 15 -> 25 */
      131      "print",					/* 16 -> 25 */
      132      "read",					/* 17 -> 10 */
      133      "attached",					/* 18 -> 26 */
      134      "opened",					/* 19 -> 27 */
      135      "closed",					/* 20 -> 28 */
      136      "detached",					/* 21 -> 29 */
      137      "open_desc",					/* 22 -> 30 */
      138      "attach_desc",					/* 23 -> 31 */
      139      "io_module",					/* 24 -> 32 */
      140      "valid_op",					/* 25 -> 33 */
      141      "test_mode",					/* 26 -> 34 */
      142      "valid_mode");					/* 27 -> 35 */
      143 
      144 /* This array defines the correspondence between operations in opt_name2 and
      145*   the labels that perform the operations. (See the comments in opt_name2) */
      146 
      147 dcl  op_match (27) fixed bin int static options (constant) init
      148     (20, 21, 21, 22, 22, 23, 23, 11, 12, 13, 14, 24, 24, 25, 25, 25, 10, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35);
      149 
      150 /* The following array defines what operations are valid through the active function */
      151 
      152 dcl  valid_af (35) bit (1) unal int static options (constant) init (
      153      "0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b,
      154      "0"b, "0"b, "0"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b,
      155      "1"b, "1"b, "0"b, "0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "1"b,
      156      "1"b, "1"b, "1"b, "1"b, "1"b);
      157 
      158 /* The following array defines what tests must be performed in
      159*   order to determine if an operation is valid (for the valid_op operation ).
      160*   The tests are:
      161*   1 - check IOCB entry variable
      162*   2 - valid if detached
      163*   3 - valid if IOCB exists
      164*   4 - always valid
      165*   5 - valid if open
      166*   6 - valid if attached */
      167 
      168 dcl  valid_op (35) fixed bin int static options (constant) init (
      169      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
      170      4, 4, 2, 6, 3, 4, 4, 4, 4, 5, 6, 6, 4, 6, 6);
      171 
      172 /* Full names of all open modes */
      173 
      174 dcl  open_type (13) char (24) int static init
      175     ("stream_input",				/* 1 */
      176      "stream_output",				/* 2 */
      177      "stream_input_output",				/* 3 */
      178      "sequential_input",				/* 4 */
      179      "sequential_output",				/* 5 */
      180      "sequential_input_output",			/* 6 */
      181      "sequential_update",				/* 7 */
      182      "keyed_sequential_input",			/* 8 */
      183      "keyed_sequential_output",			/* 9 */
      184      "keyed_sequential_update",			/* 10 */
      185      "direct_input",				/* 11 */
      186      "direct_output",				/* 12 */
      187      "direct_update");				/* 13 */
      188 
      189 /* Abbreviations for open types */
      190 
      191 dcl  open_abbrev (13) char (4) int static init
      192     ("si",					/* 1 */
      193      "so",					/* 2 */
      194      "sio",					/* 3 */
      195      "sqi",					/* 4 */
      196      "sqo",					/* 5 */
      197      "sqio",					/* 6 */
      198      "squ",					/* 7 */
      199      "ksqi",					/* 8 */
      200      "ksqo",					/* 9 */
      201      "ksqu",					/* 10 */
      202      "di",					/* 11 */
      203      "do",					/* 12 */
      204      "du");					/* 13 */
      205 
      206 /* Static storage */
      207 
      208 dcl  req char (32) static init (".");			/* Current operation, remembered for next call */
      209 dcl  ioname char (32) static init (".");		/* Current io switch, remembered for next call */
      210 dcl  WHITESPACE char(2) init(" 	") int static options(constant);
      211 
      212 /* Based storage */
      213 
      214 dcl  arg char (arg_len) based (arg_ptr);		/* Some arbitrary argument */
      215 dcl  arg2 char (arg2_len) based (arg2_ptr);		/* A second argument */
      216 dcl  af_ret char (af_retl) based (af_retp) var;		/* To return active function value */
      217 dcl  ev_array (16) entry based;			/* Array of entry variables in iocb */
      218 
      219 dcl 1 word aligned based (data_ptr),			/* Used for help messages */
      220     2 upper bit (18) unal,
      221     2 lower bit (18) unal;
      222 
      223 
      224 dcl 1 descrip aligned based,				/* An attach or open description */
      225     2 msg_len fixed bin,
      226     2 msg char (0 refer (descrip.msg_len)) unal;
      227 
      228 
      229 /* External variables */
      230 
      231 dcl  error_table_$bad_mode ext fixed bin (35);
      232 dcl  error_table_$badopt ext fixed bin (35);
      233 dcl  error_table_$end_of_info ext fixed bin (35);
      234 dcl  error_table_$key_order ext fixed bin (35);
      235 dcl  error_table_$no_ext_sym ext fixed bin (35);
      236 dcl  error_table_$no_operation ext fixed bin (35);
      237 dcl  error_table_$no_record ext fixed bin (35);
      238 dcl  error_table_$noarg ext fixed bin (35);
      239 dcl  error_table_$not_attached ext fixed bin (35);
      240 dcl  error_table_$not_detached ext fixed bin (35);
      241 dcl  error_table_$not_open ext fixed bin (35);
      242 dcl  error_table_$request_not_recognized ext fixed bin (35);
      243 dcl  error_table_$seg_not_found ext fixed bin (35);
      244 dcl  error_table_$too_many_args ext fixed bin (35);
      245 dcl  error_table_$undefined_order_request ext fixed bin (35);
      246 
      247 dcl  io_call_msg_$ ext;				/* External error message stuff */
      248 
      249 /* Builtin functions */
      250 
      251 dcl (addr, addrel, bin, hbound, index, length, max, min, null, reverse, rtrim, search, substr) builtin;
      252 
      253 
      254 /* Entry variables */
      255 
      256 dcl  active_fnc_err_ entry options (variable);
      257 dcl  com_err_ entry options (variable);
      258 
      259 dcl  cu_$arg_count entry (fixed bin);
      260 dcl  cu_$arg_list_ptr entry (ptr);
      261 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      262 dcl  cu_$ptr_call entry options (variable);
      263 dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
      264 dcl  cu_$af_arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      265 dcl  cu_$decode_entry_value entry (entry, ptr, ptr);
      266 
      267 dcl  cv_dec_check_ entry (char (*), fixed bin) returns (fixed bin (35));
      268 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
      269 
      270 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      271 dcl  hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35));
      272 
      273 dcl  ioa_ entry options (variable);
      274 dcl  ioa_$rsnnl entry options (variable);
      275 
      276 dcl  io_call_print_iocb_ entry (ptr);
      277 dcl  io_call_read_write_$put_chars entry (ptr, ptr);
      278 dcl  io_call_read_write_$get_chars entry (ptr, ptr);
      279 dcl  io_call_read_write_$get_line entry (ptr, ptr);
      280 dcl  io_call_read_write_$read_record entry (ptr, ptr);
      281 dcl  io_call_read_write_$write_record entry (ptr, ptr);
      282 dcl  io_call_read_write_$rewrite_record entry (ptr, ptr);
      283 
      284 dcl  iox_$attach_loud entry (ptr, char(*), ptr, fixed bin(35));
      285 dcl  iox_$close entry (ptr, fixed bin (35));
      286 dcl  iox_$close_file entry(ptr, char(*), fixed bin (35));
      287 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      288 dcl  iox_$delete_record entry (ptr, fixed bin (35));
      289 dcl  iox_$destroy_iocb entry (ptr, fixed bin (35));
      290 dcl  iox_$detach entry(ptr, char(*), fixed bin (35));
      291 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      292 dcl  iox_$find_iocb entry (char (*), ptr, fixed bin (35));
      293 dcl  iox_$look_iocb entry (char (*), ptr, fixed bin (35));
      294 dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
      295 dcl  iox_$move_attach entry (ptr, ptr, fixed bin (35));
      296 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      297 dcl  iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35));
      298 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      299 dcl  iox_$read_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      300 dcl  iox_$read_length entry (ptr, fixed bin (21), fixed bin (35));
      301 dcl  iox_$seek_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      302 dcl  iox_$err_no_operation entry;
      303 dcl  iox_$err_not_attached entry;
      304 dcl  iox_$err_not_closed entry;
      305 dcl  iox_$err_not_open entry;
      306 
      307 dcl  requote_string_ entry (char (*)) returns (char (*));
      308 dcl  term_$single_refname entry (char (*) aligned, fixed bin (35));
      309 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  1     3*      version number to IOX2. */
  1     4 /* format: style2 */
  1     5 
  1     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     7 	     2 version	      character (4) aligned,	/* IOX2 */
  1     8 	     2 name	      char (32),		/* I/O name of this block. */
  1     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    17 						/* open(p,mode,not_used,s) */
  1    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    24 						/* put_chars(p,bufptr,buflen,s) */
  1    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    26 						/* modes(p,newmode,oldmode,s) */
  1    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    28 						/* position(p,u1,u2,s) */
  1    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    30 						/* control(p,order,infptr,s) */
  1    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* write_record(p,bufptr,buflen,s) */
  1    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    36 						/* rewrite_record(p,bufptr,buflen,s) */
  1    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* seek_key(p,key,len,s) */
  1    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    41 						/* read_key(p,key,len,s) */
  1    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  1    43 						/* read_length(p,len,s) */
  1    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  1    45 						/* open_file(p,mode,desc,not_used,s) */
  1    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  1    47 						/* close_file(p,desc,s) */
  1    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  1    49 						/* detach(p,desc,s) */
  1    50 
  1    51      declare iox_$iocb_version_sentinel
  1    52 			      character (4) aligned external static;
  1    53 
  1    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      310 
      311 
      312 /* Check first to see if command or active function */
      313 
      314 	call cu_$af_return_arg (n_args, af_retp, af_retl, code); /* This guy knows */
      315 	if code = 0 then do;
      316 	     af_sw = "1"b;				/* We are an active function */
      317 	     error = active_fnc_err_;			/* For reporting errors */
      318 	end;
      319 	else do;					/* Plain old command */
      320 	     af_sw = "0"b;
      321 	     error = com_err_;
      322 	     call cu_$arg_count (n_args);		/* Get command arg count */
      323 	end;
      324 	call cu_$arg_list_ptr (arg_list_ptr);		/* Need this in any case */
      325 
      326 /* Get operation to be performed (the first argument) */
      327 
      328 	if n_args = 0 then do;			/* If no args, setup help message */
      329 	     i = 0;
      330 	     arg_name = "opname";
      331 	     go to help;
      332 	end;
      333 	next_arg = 1;
      334 	call get_arg ("operation");
      335 	if arg ^= "." then req = arg;			/* "." means same req as last time */
      336 	if req = "." then do;			/* There was no last time */
      337 	     code = error_table_$noarg;
      338 	     arg_name = "operation";
      339 	     go to err_1;
      340 	end;
      341 
      342 /* Determine if the operation specified is valid. */
      343 
      344 	i = get_op_number (req);			/* Look up opertion */
      345 
      346 	if i = 0 then do;
      347 bad_req:	     code = error_table_$request_not_recognized;	/* Unknown request */
      348 	     arg_name = req;
      349 	     go to err_1;
      350 	end;
      351 
      352 	if af_sw then if ^valid_af (i) then go to bad_req; /* Only valid in command */
      353 	if n_args > 1 then go to get_sw;		/* If a switch name also specified */
      354 
      355 /* Command specification is incomplete so print a help message */
      356 
      357 	arg_name = req;				/* Type of help being given */
      358 help:	msg_ptr = addr (io_call_msg_$);		/* Get pointer to segment with help messages */
      359 	data_ptr = addrel (msg_ptr, i);		/* Pointer to header word for command */
      360 	j = bin (word.lower);			/* Number of messages */
      361 	data_ptr = addrel (msg_ptr, word.upper);	/* Pointer to first message pointer */
      362 	if ^af_sw then call ioa_ ("^a: Usage is: io_call ^a switchname ^A",
      363 	     cmd_name, arg_name, addrel (msg_ptr, word.upper));
      364 	else call error (0, cmd_name, "Usage is: [io_call ^a switchname ^A]",
      365 	     arg_name, addrel (msg_ptr, word.upper));
      366 
      367 	do i = 2 to j;				/* Print rest of message */
      368 	     data_ptr = addrel (data_ptr, 1);
      369 	     call ioa_ ("^A", addrel (msg_ptr, word.upper));
      370 	end;
      371 	return;
      372 
      373 /* Get I/O switch name (the second argument) */
      374 
      375 get_sw:	call get_arg ("switchname");
      376 	if arg ^= "." then ioname = arg;		/* "." means same switch again */
      377 	if ioname = "." then do;			/* There was no last time */
      378 	     code = error_table_$noarg;
      379 	     arg_name = "switchname";
      380 	     go to err_1;
      381 	end;
      382 
      383 
      384 
      385 	go to op (i);				/* Dispatch to appropriate routine */
      386 
      387 /* This is the exit from the command */
      388 
      389 
      390 finish:	if code ^= 0 then go to err_2;		/* Most operations finish here to check last error code */
      391           return;
      392 
      393 finish_attach:
      394           if code = error_table_$seg_not_found		/* Cannot locate I/O module. */
      395 	then go to err_4;
      396 	else if code ^= 0
      397 	then go to err_2;
      398 	return;
      399 
      400 exit:	return;
      401 
      402 
      403 /* True/false type active function entries exit here */
      404 
      405 true:	call report ("true");
      406 	go to exit;
      407 
      408 false:	call report ("false");
      409 	go to exit;
      410 
      411 /* DETACH_IOCB operation */
      412 
      413 /* Note:  the DETACH operation transfers control to here ONLY when there
      414*   is no detach description specified on the command line. */
      415 
      416 op (1):	call look_iocb;				/* Get IOCB pointer */
      417 	call check_eol;
      418 	call iox_$detach_iocb (iocb_ptr, code);		/* Do the real detach */
      419 	go to finish;
      420 
      421 /* OPEN operation */
      422 
      423 op (2):   call open_common();				/* Gets iocb_ptr and open mode. */
      424 	call check_eol;
      425 
      426 	call iox_$open (iocb_ptr, mode, "0"b, code);	/* Open the switch */
      427 	go to finish;
      428 
      429 /* CLOSE operation */
      430 
      431 op (3):	call look_iocb;				/* Get IOCB pointer */
      432 	call check_eol;
      433 	call iox_$close (iocb_ptr, code);
      434 	go to finish;
      435 
      436 /* GET_LINE operation */
      437 
      438 op (4):	call look_iocb;
      439 	call io_call_read_write_$get_line (iocb_ptr, arg_list_ptr);
      440 	go to exit;
      441 
      442 /* GET_CHARS operation */
      443 
      444 op (5):	call look_iocb;				/* Locate the IOCB */
      445 	call io_call_read_write_$get_chars (iocb_ptr, arg_list_ptr);
      446 	go to exit;
      447 
      448 /* PUT_CHARS operation */
      449 
      450 op (6):	call look_iocb;
      451 	call io_call_read_write_$put_chars (iocb_ptr, arg_list_ptr);
      452 	go to exit;
      453 
      454 /* MODES operation */
      455 
      456 op (7):	call look_iocb;
      457 	arg_name = "new modes.";			/* Looking for new modes */
      458 	print_sw = "1"b;				/* Assume for now old modes will be printed */
      459 	new_mode_sw = "0"b;				/* Mode not found yet */
      460 	do while (next_arg <= n_args);
      461 	     call get_arg ("");
      462 	     if arg = "-brief" | arg = "-bf" then print_sw = "0"b; /* This means don't print old modes */
      463 	     else if new_mode_sw then do;
      464 		code = error_table_$badopt;
      465 		go to err_3;
      466 	     end;
      467 	     else do;
      468 		arg2_len = arg_len;			/* Remember this arg */
      469 		arg2_ptr = arg_ptr;
      470 		new_mode_sw = "1"b;
      471 	     end;
      472 	end;
      473 	if ^new_mode_sw then do;			/* If a new mode was not given */
      474 	     arg2_ptr = addr (dummy_char);		/* Set up a dummy one */
      475 	     arg2_len = 1;
      476 	     dummy_char = " ";
      477 	end;
      478 
      479 	begin;
      480 
      481 dcl  old_modes char (512);				/* Allow for long modes string */
      482 
      483 	     old_modes = "";
      484 	     call iox_$modes (iocb_ptr, arg2, old_modes, code); /* Do modes operation */
      485 	     if code ^= 0 then go to err_2;
      486 	     else if af_sw then af_ret = requote_string_ (rtrim (old_modes));
      487 	     else if print_sw & old_modes ^= "" then	/* If printing wanted, and something returned */
      488 		call ioa_ ("^a: ^a", cmd_name, old_modes);
      489 	end;
      490 	go to exit;
      491 
      492 /* POSITION operation */
      493 
      494 op (8):	call look_iocb;
      495 	call get_arg ("position type");
      496 	negate_sw = "0"b;				/* Initialize switch */
      497 	i = cv_dec ();				/* Should be decimal number */
      498 	if cv_dec_err ^= 0 then do;			/* Check for some keywords */
      499 	     if arg = "bof" | arg = "b" then i = -1;	/* Beginning of file */
      500 	     else if arg = "eof" | arg = "e" then i = 1;	/* End of file */
      501 	     else if arg = "forward" | arg = "foward" | arg = "fwd" | arg = "f" then do; /* Move forward */
      502 		i = 0;
      503 	     end;
      504 	     else if arg = "reverse" | arg = "rev" | arg = "r" then do; /* If reverse move */
      505 		i = 0;
      506 		negate_sw = "1"b;			/* The number will have to be inverted */
      507 	     end;
      508 	     else do;
      509 		call error (0, cmd_name, "Invalid position specification. ^a", arg);
      510 		go to exit;
      511 	     end;
      512 	end;
      513 
      514 /* Another argument is required if i = 0, is illegal for i = 1 and i = -1,
      515*   and is optional for other values of i */
      516 
      517 	if i = 0 | ((i ^= 1) & (i ^= -1) & (next_arg <= n_args)) then do;
      518 	     call get_arg ("position value");
      519 	     data_len = cv_dec ();			/* Which also is decimal */
      520 	     if cv_dec_err ^= 0 then do;
      521 		call error (0, cmd_name, "Invalid decimal number. ^a", arg);
      522 		go to exit;
      523 	     end;
      524 	     if negate_sw then data_len = -data_len;	/* If reverse position */
      525 	end;
      526 	else data_len = 0;				/* Don't care */
      527 	call check_eol;
      528 	call iox_$position (iocb_ptr, i, data_len, code); /* Do operation */
      529 	if af_sw then do;
      530 	     if code = 0 then go to true;
      531 	     if code = error_table_$end_of_info then go to false;
      532 	end;
      533 	go to finish;
      534 
      535 /* CONTROL operation */
      536 
      537 op (9):	call look_iocb;				/* First, locate the IOCB */
      538 	call get_arg ("order");
      539 	order = arg;				/* Save order name */
      540 	if order = "io_call" | order = "io_call_af" then do;
      541 	     call error (0, cmd_name, "The ^a ^[active function^;command^] cannot perform an ^a order.",
      542 		cmd_name, af_sw, order);
      543 	     go to exit;
      544 	end;
      545 	call check_args;				/* Scan rest of argument list */
      546 
      547 	begin;					/* Begin block allocates param structure */
      548 
      549 dcl  io_call_order_name char (10);			/* Will be io_call or io_call_af */
      550 dcl 1 io_call_info aligned,				/* This structure must look like io_call_info.incl.pl1 */
      551     2 version fixed bin,
      552     2 caller_name char (32),
      553     2 order_name char (32),
      554     2 ioa_entry entry variable options (variable),
      555     2 com_err_entry entry variable options (variable),
      556     2 af_returnp ptr,				/* Pointer to active function return string */
      557     2 af_returnl fixed bin,				/* Its max length */
      558     2 fill (5) bit (36) aligned,
      559     2 nargs fixed bin,
      560     2 max_arglen fixed bin,
      561     2 args (n_high) char (max_l) varying;
      562 
      563 	     io_call_info.version = 1;
      564 	     io_call_info.caller_name = cmd_name;	/* Initialize param list */
      565 	     io_call_info.order_name = order;
      566 	     io_call_info.ioa_entry = ioa_;
      567 	     if af_sw then do;
      568 		io_call_info.af_returnp = af_retp;
      569 		io_call_info.af_returnl = af_retl;
      570 		io_call_order_name = "io_call_af";
      571 	     end;
      572 	     else do;
      573 		io_call_info.af_returnp = null;
      574 		io_call_info.af_returnl = 0;
      575 		io_call_order_name = "io_call";
      576 	     end;
      577 	     io_call_info.com_err_entry = error;
      578 	     io_call_info.fill = "0"b;
      579 	     io_call_info.nargs = n_high;
      580 	     io_call_info.max_arglen = max_l;
      581 	     i = 1;
      582 	     do while (next_arg <= n_args);
      583 		call get_arg ("");
      584 		io_call_info.args (i) = arg;
      585 		i = i + 1;
      586 	     end;
      587 
      588 /* First try to perform the control operation with the "io_call" order */
      589 
      590 	     call iox_$control (iocb_ptr, io_call_order_name, addr (io_call_info), code);
      591 
      592 	end;
      593 
      594 	if code = 0 then go to exit;			/* Io module did the order. */
      595 	if af_sw then go to err_2;
      596 	if code = error_table_$no_operation | code = error_table_$undefined_order_request then do;
      597 						/* Module does not seem to like io_call order */
      598 	     call iox_$control (iocb_ptr, rtrim (order), null, code); /* Retry original order */
      599 	     if code ^= 0 then do;
      600 		call error (code, cmd_name, "Order ^a on switch ^a.", order, ioname);
      601 		go to exit;
      602 	     end;
      603 	     end;
      604 	go to finish;
      605 
      606 /* READ_RECORD operation */
      607 
      608 op (10):	call look_iocb;				/* Locate IOCB */
      609 	call io_call_read_write_$read_record (iocb_ptr, arg_list_ptr);
      610 	go to exit;
      611 
      612 /* WRITE_RECORD operation */
      613 
      614 op (11):	call look_iocb;
      615 	call io_call_read_write_$write_record (iocb_ptr, arg_list_ptr);
      616 	go to exit;
      617 
      618 /* REWRITE_RECORD operation */
      619 
      620 op (12):	call look_iocb;
      621 	call io_call_read_write_$rewrite_record (iocb_ptr, arg_list_ptr);
      622 	go to exit;
      623 
      624 /* DELETE_RECORD operation */
      625 
      626 op (13):	call look_iocb;
      627 	call check_eol;
      628 	call iox_$delete_record (iocb_ptr, code);
      629 	go to finish;
      630 
      631 /* SEEK_KEY operation */
      632 
      633 op (14):	call look_iocb;
      634 	call get_arg ("key");
      635 	call check_eol;
      636 	key = arg;				/* Copy key to varying string */
      637 	data_len = -1;
      638 	call iox_$seek_key (iocb_ptr, key, data_len, code);
      639 	if af_sw then do;				/* Active function */
      640 	     if code = 0 then go to true;
      641 	     if code = error_table_$no_record then go to false;
      642 	end;
      643 	if code ^= 0 then do;
      644 	     if data_len = -1 then do;		/* No record length returned */
      645 		if code = error_table_$no_record | code = error_table_$key_order then
      646 		     call error (code, cmd_name, "^a", key);
      647 		else go to err_2;
      648 	     end;
      649 	     else call error (code, cmd_name, "len=^d.", data_len);
      650 	end;
      651 	else call ioa_ ("^a: key=""^a"" len=^d.", cmd_name, key, data_len);
      652 	go to exit;
      653 
      654 
      655 /* READ_KEY operation */
      656 
      657 op (15):	call look_iocb;
      658 	call check_nq;				/* Look for -no_quote */
      659 	call check_eol;
      660 	data_len = -1;
      661 	key = "";
      662 	call iox_$read_key (iocb_ptr, key, data_len, code); /* Do the operation */
      663 	if code ^= 0 then do;
      664 	     if data_len = -1 then go to err_2;		/* Nothing returned */
      665 	     else call error (code, cmd_name, "key=""^a"" len=^d.", key, data_len);
      666 	end;
      667 	else if af_sw then do;
      668 	     if no_quote_sw then af_ret = key;
      669 	     else af_ret = requote_string_ ((key));
      670 	end;
      671 	else call ioa_ ("^a: key=""^a"" len=^d.", cmd_name, key, data_len);
      672 	go to exit;
      673 
      674 
      675 /* READ_LENGTH operation */
      676 
      677 op (16):	call look_iocb;
      678 	call check_eol;
      679 	data_len = -1;
      680 	call iox_$read_length (iocb_ptr, data_len, code); /* Get length */
      681 	if code ^= 0 then do;
      682 	     if data_len = -1 then go to err_2;
      683 	     call error (code, cmd_name, "len=^d.", data_len);
      684 	end;
      685 	else if af_sw then call ioa_$rsnnl ("^d", af_ret, (0), data_len);
      686 	else call ioa_ ("^a: len=^d.", cmd_name, data_len);
      687 	go to exit;
      688 
      689 /* OPEN_FILE operation */
      690 
      691 op (17):  call open_common();				/* Gets IOCB ptr and open mode. */
      692           call get_desc_len(desc_len);
      693 
      694 	begin;
      695 
      696 	     dcl description char(desc_len);
      697 
      698 	     call get_desc(description);
      699 	     call iox_$open_file(iocb_ptr, mode, description, "0"b, code);
      700 
      701 	end;
      702 
      703 	go to finish;
      704 
      705 /* CLOSE_FILE operation */
      706 
      707 op (18):  call look_iocb();				/* Get IOCB ptr. */
      708           call get_desc_len(desc_len);
      709 
      710 	begin;
      711 
      712 	     dcl description char(desc_len);
      713 
      714 	     call get_desc(description);
      715 	     call iox_$close_file(iocb_ptr, description, code);
      716 
      717 	end;
      718 
      719 	go to finish;
      720 
      721 /* DETACH operation */
      722 
      723 op (19):  call look_iocb();				/* Get IOCB ptr. */
      724 
      725           if at_eol()				/* No detach description specified. */
      726 	then go to op(1);				/* Transfer to DETACH_IOCB op. */
      727 
      728           call get_desc_len(desc_len);
      729 
      730 	begin;
      731 
      732 	     dcl description char(desc_len);
      733 
      734 	     call get_desc(description);
      735 	     call iox_$detach(iocb_ptr, description, code);
      736 
      737 	end;
      738 
      739 	go to finish;
      740 
      741 
      742 /* ATTACH operation */
      743 
      744 op (20):	call find_iocb();				/* Get IOCB pointer */
      745           call get_desc_len(desc_len);
      746 
      747 	begin;
      748 
      749 	     dcl description char(desc_len);
      750 
      751 	     call get_desc(description);
      752 	     call iox_$attach_loud(iocb_ptr, description, (null), code);
      753 	if code = error_table_$no_ext_sym then do;
      754 		call error (code, cmd_name, "Attaching ^a on switch ^a.", description, ioname);
      755 		code = 0;
      756 	end;
      757 
      758 	end;
      759 
      760 	go to finish_attach;
      761 
      762 
      763 /* FIND_IOCB operation */
      764 
      765 op (21):	call find_iocb;
      766 findx:	call check_eol;
      767 	if af_sw then call ioa_$rsnnl ("^p", af_ret, (0), iocb_ptr);
      768 	else call ioa_ ("^a: ^a at ^p", cmd_name, ioname, iocb_ptr);
      769 	go to exit;
      770 
      771 /* LOOK_IOCB operation */
      772 
      773 op (22):	call iox_$look_iocb (ioname, iocb_ptr, code);	/* Get IOCB pointer */
      774 	if af_sw then do;
      775 	     if code = 0 then go to true;
      776 	     else go to false;
      777 	end;
      778 	else if code ^= 0 then go to err_2;
      779 	else go to findx;
      780 
      781 
      782 /* DESTROY_IOCB operation */
      783 
      784 op (23):	call look_iocb;
      785 	call check_eol;
      786 	call iox_$destroy_iocb (iocb_ptr, code);
      787 	go to finish;
      788 
      789 
      790 /* MOVE_ATTACH operation */
      791 
      792 op (24):	call look_iocb;				/* Locate source IOCB */
      793 	call get_arg ("target iocb");
      794 	call check_eol;
      795 	call iox_$find_iocb (arg, iocb2_ptr, code);	/* Get pointer to target IOCB */
      796 	if code ^= 0 then go to err_3;		/* If this failed */
      797 	call iox_$move_attach (iocb_ptr, iocb2_ptr, code);
      798 	if code ^= 0 then do;
      799 	     if code = error_table_$not_detached then go to err_3; /* Error applies to target IOCB */
      800 	     else go to err_2;			/* Error applies to source IOCB */
      801 	end;
      802 	go to exit;
      803 
      804 /* PRINT_IOCB operation */
      805 
      806 op (25):	call look_iocb;				/* Find IOCB */
      807 	call check_eol;
      808 	call io_call_print_iocb_ (iocb_ptr);
      809 	go to exit;
      810 
      811 /* ATTACHED operation */
      812 
      813 op (26):	call check_eol;
      814 	call iox_$look_iocb (ioname, iocb_ptr, code);
      815 	if code ^= 0 then go to false;
      816 	if iocb_ptr -> iocb.attach_descrip_ptr = null then go to false;
      817 	else go to true;
      818 
      819 /* OPENED operation */
      820 
      821 op (27):	call check_eol;
      822 	call iox_$look_iocb (ioname, iocb_ptr, code);
      823 	if code ^= 0 then go to false;
      824 	if iocb_ptr -> iocb.open_descrip_ptr = null then go to false;
      825 	else go to true;
      826 
      827 /* CLOSED operation */
      828 
      829 op (28):	call check_eol;
      830 	call iox_$look_iocb (ioname, iocb_ptr, code);
      831 	if code ^= 0 then go to true;
      832 	if iocb_ptr -> iocb.open_descrip_ptr = null then go to true;
      833 	else go to false;
      834 
      835 /* DETACHED operation */
      836 
      837 op (29):	call check_eol;
      838 	call iox_$look_iocb (ioname, iocb_ptr, code);
      839 	if code ^= 0 then go to true;
      840 	if iocb_ptr -> iocb.attach_descrip_ptr = null then go to true;
      841 	else go to false;
      842 
      843 /* OPEN_DESC operation */
      844 
      845 op (30):	call check_eol;
      846 	call look_iocb;
      847 	call check_nq;
      848 	if iocb_ptr -> iocb.open_descrip_ptr = null then do;
      849 	     code = error_table_$not_open;
      850 	     go to err_2;
      851 	end;
      852           if no_quote_sw then call report (iocb_ptr -> iocb.open_descrip_ptr -> descrip.msg);
      853 	else call report (requote_string_ (iocb_ptr -> iocb.open_descrip_ptr -> descrip.msg));
      854 	go to exit;
      855 
      856 /* ATTACH_DESC operation */
      857 
      858 op (31):	call look_iocb;
      859 	call check_nq;
      860 	call check_eol;
      861 	if iocb_ptr -> iocb.attach_descrip_ptr = null then do;
      862 	     code = error_table_$not_attached;
      863 	     go to err_2;
      864 	end;
      865 	if no_quote_sw then call report (iocb_ptr -> iocb.attach_descrip_ptr -> descrip.msg);
      866 	else call report (requote_string_ (iocb_ptr -> iocb.attach_descrip_ptr -> descrip.msg));
      867 	go to exit;
      868 
      869 /* IO_MODULE operation */
      870 
      871 op (32):	call check_eol;
      872 	call look_iocb;
      873 	if iocb_ptr -> iocb.attach_descrip_ptr = null then do; /* No attachment */
      874 	     code = error_table_$not_attached;
      875 	     go to err_2;
      876 	end;
      877 	i = index (iocb_ptr -> iocb.attach_descrip_ptr -> descrip.msg, " ");
      878 	if i = 0 then i = length (iocb_ptr -> iocb.attach_descrip_ptr -> descrip.msg);
      879 	else i = i - 1;
      880 	call report (substr (iocb_ptr -> iocb.attach_descrip_ptr -> descrip.msg, 1, i));
      881 	go to exit;
      882 
      883 /* VALID_OP operation */
      884 
      885 op (33):	call get_arg ("operation");
      886 	i = get_op_number (arg);			/* Look it up */
      887 	if i = 0 then do;
      888 	     code = error_table_$badopt;
      889 	     go to err_3;
      890 	end;
      891 	call check_eol;
      892 	go to valid_op_test (valid_op (i));		/* Go check if valid */
      893 valid_op_test (1):					/* Valid if no error entry in IOCB */
      894 	call iox_$look_iocb (ioname, iocb_ptr, code);
      895 	if code ^= 0 then go to false;
      896 	ev = addr (iocb_ptr -> iocb.detach_iocb) -> ev_array (i);
      897 	if equal_ev (ev, iox_$err_no_operation) then go to false;
      898 	if equal_ev (ev, iox_$err_not_attached) then go to false;
      899 	if equal_ev (ev, iox_$err_not_closed) then go to false;
      900 	if equal_ev (ev, iox_$err_not_open) then go to false;
      901 	go to true;
      902 valid_op_test (2):					/* Valid if detached */
      903 	call iox_$look_iocb (ioname, iocb_ptr, code);
      904 	if code ^= 0 then go to true;
      905 	if iocb_ptr -> iocb.attach_descrip_ptr = null then go to true;
      906 	else go to false;
      907 valid_op_test (3):					/* Valid if iocb exists */
      908 	call iox_$look_iocb (ioname, iocb_ptr, code);
      909 	if code = 0 then go to true;
      910 	else go to false;
      911 valid_op_test (4):					/* Always valid */
      912 	go to true;
      913 valid_op_test (5):					/* True if open */
      914 	call iox_$look_iocb (ioname, iocb_ptr, code);
      915 	if code ^= 0 then go to false;
      916 	if iocb_ptr -> iocb.open_descrip_ptr = null then go to false;
      917 	else go to true;
      918 valid_op_test (6):					/* Valid if attached */
      919 	call iox_$look_iocb (ioname, iocb_ptr, code);
      920 	if code ^= 0 then go to false;
      921 	if iocb_ptr -> iocb.attach_descrip_ptr = null then go to false;
      922 	else go to true;
      923 
      924 /* TEST_MODE operation */
      925 
      926 op (34):	valid_mode_sw = "0"b;			/* Not a valid_mode operation */
      927 test_mode_join:
      928 	call look_iocb;
      929 	call get_arg ("mode");
      930 	call check_eol;
      931 
      932 	begin;
      933 
      934 dcl  not_sw bit (1);				/* Set if ^mode asked for */
      935 dcl  test_mode char (32) var;
      936 dcl  mode_str char (512);
      937 dcl  modes char (512) var;
      938 
      939 	     not_sw = (substr (arg, 1, 1) = "^");
      940 	     if not_sw then test_mode = substr (arg, 2);
      941 	     else test_mode = arg;
      942 	     call iox_$modes (iocb_ptr, "", mode_str, code);
      943 	     if code ^= 0 then go to err_2;
      944 	     modes = rtrim (mode_str, " .");		/* Trim spaces and trailing period */
      945 	     do while (modes ^= "");			/* Loop till string gone */
      946 		i = index (modes, ",");		/* Find end of next mode */
      947 		if i = 0 then i = length (modes);
      948 		else i = i - 1;
      949 		if substr (modes, 1, 1) = "^" then
      950 		     if substr (modes, 2, i-1) = test_mode then
      951 			if valid_mode_sw then go to true;
      952 			else if not_sw then go to true;
      953 			else go to false;
      954 		     else;
      955 		else if substr (modes, 1, i) = test_mode then
      956 		     if valid_mode_sw then go to true;
      957 		     else if not_sw then go to false;
      958 		     else go to true;
      959 		if i+1 >= length (modes) then modes = ""; /* Done */
      960 		else modes = substr (modes, i+2);	/* Strip off mode */
      961 	     end;
      962 
      963 	     if valid_mode_sw then go to false;
      964 	     code = error_table_$bad_mode;
      965 	     go to err_3;
      966 
      967 	end;
      968 
      969 /* VALID_MODE operation */
      970 
      971 op (35):	valid_mode_sw = "1"b;
      972 	go to test_mode_join;
      973 
      974 /* Get next argument and print error if not found */
      975 
      976 get_arg:	proc (s);
      977 
      978 dcl  s char (*);					/* Comment for error message */
      979 
      980 	     call get_arg_ptr;
      981 	     if code = 0 then return;
      982 	     call error (code, cmd_name, "^a", s);
      983 	     go to exit;
      984 
      985 	end get_arg;
      986 
      987 /* Internal procedure to call cu_$arg_ptr_rel so that this argument list is only built once */
      988 
      989 get_arg_ptr: proc;
      990 
      991 	     if af_sw then call cu_$af_arg_ptr_rel (next_arg, arg_ptr, arg_len, code, arg_list_ptr);
      992 	     else call cu_$arg_ptr_rel (next_arg, arg_ptr, arg_len, code, arg_list_ptr);
      993 	     next_arg = next_arg + 1;
      994 
      995 	end get_arg_ptr;
      996 
      997 
      998 /* Internal procedure to check next argument for a decimal value */
      999 
     1000 cv_dec:	proc returns (fixed bin (35));
     1001 
     1002 	     return (cv_dec_check_ (arg, cv_dec_err));
     1003 
     1004 	end cv_dec;
     1005 
     1006 
     1007 /* Entry to print or return a result */
     1008 
     1009 report:	proc (answer);
     1010 
     1011 dcl  answer char (*);
     1012 
     1013 	     if af_sw then af_ret = answer;		/* If active function */
     1014 	     else call ioa_ ("^a", answer);		/* If command */
     1015 	     return;
     1016 
     1017 	end report;
     1018 
     1019 /* Each operation starts with a call to one of the following internal procedures: The call
     1020*   is to look_iocb if the IOCB must exist prior to the command being issued:  the call is to
     1021*   find_iocb if this is not required. */
     1022 
     1023 look_iocb: proc;
     1024 
     1025 	     call iox_$look_iocb (ioname, iocb_ptr, code);
     1026 	     if code ^= 0 then go to err_2;
     1027 	     return;
     1028 
     1029 	end look_iocb;
     1030 
     1031 
     1032 find_iocb: proc;
     1033 
     1034 	     call iox_$find_iocb (ioname, iocb_ptr, code);
     1035 	     if code ^= 0 then go to err_2;
     1036 	     return;
     1037 
     1038 	end find_iocb;
     1039 
     1040 
     1041 /* This procedure scan the rest of the argument list to determine how much space must be allocated
     1042*   to hold it. This is used by control operations. */
     1043 
     1044 check_args: proc;
     1045 
     1046 dcl  save_next_arg fixed bin;				/* Arg to start with */
     1047 
     1048 	     save_next_arg = next_arg;
     1049 	     max_l = 1;				/* Length of longest arg */
     1050 	     do while (next_arg <= n_args);
     1051 		call get_arg ("");
     1052 		max_l = max (max_l, arg_len);
     1053 	     end;
     1054 
     1055 	     next_arg = save_next_arg;
     1056 	     n_high = n_args - next_arg + 1;		/* Number of elements in array */
     1057 	     n_low = min (1, n_high);			/* Bounds are 1:n_high or 0:0 */
     1058 	     return;
     1059 
     1060 	end check_args;
     1061 
     1062 /* Check for too many arguments */
     1063 
     1064 check_eol: proc;
     1065 
     1066 	     if next_arg > n_args then return;		/* Ok */
     1067 	     call get_arg_ptr;
     1068 	     call error (error_table_$too_many_args, cmd_name, "^a", arg);
     1069 	     go to exit;
     1070 
     1071 	end check_eol;
     1072 
     1073 /* Check the next argument for -no_quote */
     1074 
     1075 check_nq:	proc;
     1076 
     1077 
     1078 	     no_quote_sw = "0"b;
     1079 	     if next_arg > n_args then return;
     1080 	     call get_arg ("");
     1081 	     if arg = "-no_quote" | arg = "-nq" then do;
     1082 		no_quote_sw = "1"b;
     1083 		return;
     1084 	     end;
     1085 
     1086 	     code = error_table_$badopt;
     1087 	     go to err_3;
     1088 
     1089 	end check_nq;
     1090 
     1091 /* This function looks up an operation and returns its index */
     1092 
     1093 get_op_number: proc (op) returns (fixed bin);
     1094 
     1095 dcl  op char (*);
     1096 dcl  i fixed bin;
     1097 
     1098 	     do i = 1 to hbound (opt_name, 1);
     1099 		if op = opt_name (i) then return (i);
     1100 	     end;
     1101 	     do i = 1 to hbound (opt_name2, 1);
     1102 		if op = opt_name2 (i) then return (op_match (i));
     1103 	     end;
     1104 	     return (0);
     1105 
     1106 	end get_op_number;
     1107 
     1108 /* This procedure scans the rest of the argument list to determine the
     1109*   maximum length of the description.  It is used by attach, open_file,
     1110*   close_file and detach. */
     1111 
     1112 get_desc_len:  proc(desc_len);
     1113 
     1114           dcl desc_len fixed bin;
     1115 	dcl save_next_arg fixed bin;
     1116 
     1117 	save_next_arg = next_arg;
     1118 	desc_len = 0;
     1119 
     1120 	do while(next_arg <= n_args);
     1121 	     call get_arg("");
     1122 	     if search(arg, WHITESPACE) ^= 0
     1123 	     then desc_len = desc_len + (2 * arg_len + 2);     /* (2 * arg_len + 2) from requote_string_. */
     1124 	     else desc_len = desc_len + arg_len;
     1125 	     if next_arg <= n_args
     1126 	     then desc_len = desc_len + 1;		/* +1 for space between args. */
     1127 	end;
     1128 
     1129 	next_arg = save_next_arg;
     1130 
     1131      end get_desc_len;
     1132 
     1133 /* Concatenates the rest of the argument list forming the description. */
     1134 
     1135 get_desc: proc(description);
     1136 
     1137           dcl description char(*);
     1138 	dcl var_description char(length(description)) var;
     1139 
     1140 	description = "";
     1141 	var_description = "";
     1142 
     1143 	do while(next_arg <= n_args);
     1144 	     call get_arg("");
     1145 	     if search(arg, WHITESPACE) ^= 0
     1146 	     then var_description = var_description || requote_string_(arg);
     1147 	     else var_description = var_description || arg;
     1148 	     if next_arg <= n_args
     1149 	     then var_description = var_description || " ";
     1150 
     1151 	end;
     1152 
     1153 	description = var_description;
     1154 
     1155      end get_desc;
     1156 
     1157 /* This function compares two entry variables and returns true if they have the same procedure pointer */
     1158 
     1159 equal_ev:	proc (e1, e2) returns (bit (1));
     1160 
     1161 dcl (e1, e2) entry;
     1162 dcl (p1, p2, p3) ptr;
     1163 
     1164 	     call cu_$decode_entry_value (e1, p1, p3);
     1165 	     call cu_$decode_entry_value (e2, p2, p3);
     1166 	     return (p1 = p2);
     1167 
     1168 	end equal_ev;
     1169 
     1170 open_common: proc();
     1171 
     1172           call look_iocb;				/* Get IOCB pointer */
     1173 	call get_arg ("open mode");
     1174 	mode = cv_dec ();				/* First test for numeric mode */
     1175 	if cv_dec_err = 0 then do;			/* If it is numeric.. */
     1176 	     if mode < 1 | mode > hbound (open_type, 1) then do; /* If out of range */
     1177 		code = error_table_$badopt;
     1178 		go to err_3;
     1179 	     end;
     1180 	     return;				/* Found type */
     1181 	end;
     1182 
     1183 	do mode = 1 to hbound (open_type, 1);		/* Scan array of possible modes */
     1184 	     if arg = open_type (mode) | arg = open_abbrev (mode)
     1185 	     then return;				/* Found match */
     1186 	end;
     1187 
     1188 	code = error_table_$badopt;
     1189 	go to err_3;
     1190 
     1191      end open_common;
     1192 
     1193 /* Says whether or not we have already gotten the last argument on the
     1194*   command line. */
     1195 
     1196 at_eol: proc() returns(bit(1) aligned);
     1197 
     1198                return(next_arg > n_args);
     1199 
     1200           end at_eol;
     1201 
     1202 
     1203 /* Come here for various kinds of error messages */
     1204 
     1205 err_1:	call error (code, cmd_name, "^a", arg_name);
     1206 	go to exit;
     1207 
     1208 err_2:	arg_name = ioname;
     1209 	go to err_1;
     1210 
     1211 err_3:	call error (code, cmd_name, "^a", arg);
     1212 	go to exit;
     1213 
     1214 err_4:    call error (code, cmd_name, "Cannot locate I/O module to attach ^a.", ioname);
     1215 
     1216      end io_call;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/27/84  1336.5  io_call.pl1                       >spec>on>6660>io_call.pl1
310          1    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
WHITESPACE                             constant        char(2)                  initial unaligned dcl 210 ref 1122 1145
active_fnc_err_                 000070 constant        entry                    external dcl 256 ref 317
addr                                                   builtin function         dcl 251 ref 358 474 590 590 896
addrel                                                 builtin function         dcl 251 ref 359 361 362 362 364 364 368 369 369
af_ret                                 based           varying char             dcl 216 set ref 486* 668* 669* 685* 767* 1013*
af_retl                         000274 automatic       fixed bin(17,0)          dcl 69 set ref 314* 486 569 668 669 685 767 1013
af_retp                         000272 automatic       pointer                  dcl 68 set ref 314* 486 568 668 669 685 767 1013
af_returnl               34     000104 automatic       fixed bin(17,0)          level 2 dcl 550 set ref 569* 574*
af_returnp               32     000104 automatic       pointer                  level 2 dcl 550 set ref 568* 573*
af_sw                           000270 automatic       bit(1)                   unaligned dcl 67 set ref 316* 320* 352 362 486 529
                                                                                  541* 567 595 639 667 685 767 774 991 1013
answer                                 parameter       char                     unaligned dcl 1011 set ref 1009 1013 1014*
arg                                    based           char                     unaligned dcl 214 set ref 335 335 376 376 462 462
                                                                                  499 499 500 500 501 501 501 501 504 504 504 509*
                                                                                  521* 539 584 636 795* 886* 939 940 941 1002* 1068*
                                                                                  1081 1081 1122 1145 1145* 1147 1184 1184 1211*
arg2                                   based           char                     unaligned dcl 215 set ref 484*
arg2_len                        000107 automatic       fixed bin(17,0)          dcl 39 set ref 468* 475* 484 484
arg2_ptr                        000110 automatic       pointer                  dcl 40 set ref 469* 474* 484
arg_len                         000106 automatic       fixed bin(17,0)          dcl 38 set ref 335 335 376 376 462 462 468 499 499
                                                                                  500 500 501 501 501 501 504 504 504 509 509 521
                                                                                  521 539 584 636 795 795 886 886 939 940 941 991*
                                                                                  992* 1002 1002 1052 1068 1068 1081 1081 1122 1122
                                                                                  1124 1145 1145 1145 1147 1184 1184 1211 1211
arg_list_ptr                    000102 automatic       pointer                  dcl 36 set ref 324* 439* 445* 451* 609* 615* 621*
                                                                                  991* 992*
arg_name                        000115 automatic       varying char(32)         dcl 47 set ref 330* 338* 348* 357* 362* 364* 379*
                                                                                  457* 1205* 1208*
arg_ptr                         000104 automatic       pointer                  dcl 37 set ref 335 335 376 376 462 462 469 499 499
                                                                                  500 500 501 501 501 501 504 504 504 509 521 539
                                                                                  584 636 795 886 939 940 941 991* 992* 1002 1068
                                                                                  1081 1081 1122 1145 1145 1147 1184 1184 1211
args                     44     000104 automatic       varying char             array level 2 dcl 550 set ref 584*
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-6 ref 816 840 861 865 866 873 877 878
                                                                                  880 880 905 921
bin                                                    builtin function         dcl 251 ref 360
caller_name               1     000104 automatic       char(32)                 level 2 dcl 550 set ref 564*
cmd_name                        000530 constant        char(7)                  initial unaligned dcl 76 set ref 362* 364* 487* 509*
                                                                                  521* 541* 541* 564 600* 645* 649* 651* 665* 671*
                                                                                  683* 686* 754* 768* 982* 1068* 1205* 1211* 1214*
code                            000100 automatic       fixed bin(35,0)          dcl 35 set ref 314* 315 337* 347* 378* 390 393 396
                                                                                  418* 426* 433* 464* 484* 485 528* 530 531 590* 594
                                                                                  596 596 598* 599 600* 628* 638* 640 641 643 645
                                                                                  645 645* 649* 662* 663 665* 680* 681 683* 699*
                                                                                  715* 735* 752* 753 754* 755* 773* 775 778 786*
                                                                                  795* 796 797* 798 799 814* 815 822* 823 830* 831
                                                                                  838* 839 849* 862* 874* 888* 893* 895 902* 904
                                                                                  907* 909 913* 915 918* 920 942* 943 964* 981 982*
                                                                                  991* 992* 1025* 1026 1034* 1035 1086* 1177* 1188*
                                                                                  1205* 1211* 1214*
com_err_                        000072 constant        entry                    external dcl 257 ref 321
com_err_entry            26     000104 automatic       entry variable           level 2 dcl 550 set ref 577*
cu_$af_arg_ptr_rel              000104 constant        entry                    external dcl 264 ref 991
cu_$af_return_arg               000102 constant        entry                    external dcl 263 ref 314
cu_$arg_count                   000074 constant        entry                    external dcl 259 ref 322
cu_$arg_list_ptr                000076 constant        entry                    external dcl 260 ref 324
cu_$arg_ptr_rel                 000100 constant        entry                    external dcl 261 ref 992
cu_$decode_entry_value          000106 constant        entry                    external dcl 265 ref 1164 1165
cv_dec_check_                   000110 constant        entry                    external dcl 267 ref 1002
cv_dec_err                      000135 automatic       fixed bin(17,0)          dcl 53 set ref 498 520 1002* 1175
data_len                        000140 automatic       fixed bin(21,0)          dcl 55 set ref 519* 524* 524 526* 528* 637* 638* 644
                                                                                  649* 651* 660* 662* 664 665* 671* 679* 680* 682
                                                                                  683* 685* 686*
data_ptr                        000136 automatic       pointer                  dcl 54 set ref 359* 360 361* 361 362 362 364 364
                                                                                  368* 368 369 369
desc_len                               parameter       fixed bin(17,0)          dcl 1114 in procedure "get_desc_len" set ref 1112
                                                                                  1118* 1122* 1122 1124* 1124 1125* 1125
desc_len                        000114 automatic       fixed bin(17,0)          dcl 44 in procedure "io" set ref 692* 696 708* 712
                                                                                  728* 732 745* 749
descrip                                based           structure                level 1 dcl 224
description                     000100 automatic       char                     unaligned dcl 732 in begin block on line 730 set ref
                                                                                  734* 735*
description                     000100 automatic       char                     unaligned dcl 696 in begin block on line 694 set ref
                                                                                  698* 699*
description                     000100 automatic       char                     unaligned dcl 712 in begin block on line 710 set ref
                                                                                  714* 715*
description                     000100 automatic       char                     unaligned dcl 749 in begin block on line 747 set ref
                                                                                  751* 752* 754*
description                            parameter       char                     unaligned dcl 1137 in procedure "get_desc" set ref
                                                                                  1135 1138 1140* 1153*
detach_iocb              26            based           entry variable           level 2 dcl 1-6 set ref 896
dummy_char                      000245 automatic       char(1)                  unaligned dcl 60 set ref 474 476*
e1                                     parameter       entry variable           dcl 1161 set ref 1159 1164*
e2                                     parameter       entry variable           dcl 1161 set ref 1159 1165*
error                           000264 automatic       entry variable           dcl 66 set ref 317* 321* 364 509 521 541 577 600 645
                                                                                  649 665 683 754 982 1068 1205 1211 1214
error_table_$bad_mode           000030 external static fixed bin(35,0)          dcl 231 ref 964
error_table_$badopt             000032 external static fixed bin(35,0)          dcl 232 ref 464 888 1086 1177 1188
error_table_$end_of_info        000034 external static fixed bin(35,0)          dcl 233 ref 531
error_table_$key_order          000036 external static fixed bin(35,0)          dcl 234 ref 645
error_table_$no_ext_sym         000040 external static fixed bin(35,0)          dcl 235 ref 753
error_table_$no_operation       000042 external static fixed bin(35,0)          dcl 236 ref 596
error_table_$no_record          000044 external static fixed bin(35,0)          dcl 237 ref 641 645
error_table_$noarg              000046 external static fixed bin(35,0)          dcl 238 ref 337 378
error_table_$not_attached       000050 external static fixed bin(35,0)          dcl 239 ref 862 874
error_table_$not_detached       000052 external static fixed bin(35,0)          dcl 240 ref 799
error_table_$not_open           000054 external static fixed bin(35,0)          dcl 241 ref 849
error_table_$request_not_recognized
                                000056 external static fixed bin(35,0)          dcl 242 ref 347
error_table_$seg_not_found      000060 external static fixed bin(35,0)          dcl 243 ref 393
error_table_$too_many_args      000062 external static fixed bin(35,0)          dcl 244 set ref 1068*
error_table_$undefined_order_request
                                000064 external static fixed bin(35,0)          dcl 245 ref 596
ev                              000276 automatic       entry variable           dcl 71 set ref 896* 897* 898* 899* 900*
ev_array                               based           entry variable           array dcl 217 ref 896
fill                     35     000104 automatic       bit(36)                  array level 2 dcl 550 set ref 578*
hbound                                                 builtin function         dcl 251 ref 1098 1101 1176 1183
i                               001174 automatic       fixed bin(17,0)          dcl 1096 in procedure "get_op_number" set ref 1098*
                                                                                  1099 1099* 1101* 1102 1102*
i                               000132 automatic       fixed bin(17,0)          dcl 51 in procedure "io" set ref 329* 344* 346 352
                                                                                  359 367* 385 497* 499* 500* 502* 505* 517 517 517
                                                                                  528* 581* 584 585* 585 877* 878 878* 879* 879 880
                                                                                  880 886* 887 892 896 946* 947 947* 948* 948 949
                                                                                  955 959 960
index                                                  builtin function         dcl 251 ref 877 946
io_call_info                    000104 automatic       structure                level 1 dcl 550 set ref 590 590
io_call_msg_$                   000066 external static fixed bin(17,0)          dcl 247 set ref 358
io_call_order_name              000100 automatic       char(10)                 unaligned dcl 549 set ref 570* 575* 590*
io_call_print_iocb_             000116 constant        entry                    external dcl 276 ref 808
io_call_read_write_$get_chars   000122 constant        entry                    external dcl 278 ref 445
io_call_read_write_$get_line    000124 constant        entry                    external dcl 279 ref 439
io_call_read_write_$put_chars   000120 constant        entry                    external dcl 277 ref 451
io_call_read_write_$read_record 000126 constant        entry                    external dcl 280 ref 609
io_call_read_write_$rewrite_record
                                000132 constant        entry                    external dcl 282 ref 621
io_call_read_write_$write_record
                                000130 constant        entry                    external dcl 281 ref 615
ioa_                            000112 constant        entry                    external dcl 273 ref 362 369 487 566 651 671 686 768
                                                                                  1014
ioa_$rsnnl                      000114 constant        entry                    external dcl 274 ref 685 767
ioa_entry                22     000104 automatic       entry variable           level 2 dcl 550 set ref 566*
iocb                                   based           structure                level 1 dcl 1-6
iocb2_ptr                       000130 automatic       pointer                  dcl 50 set ref 795* 797*
iocb_ptr                        000126 automatic       pointer                  dcl 49 set ref 418* 426* 433* 439* 445* 451* 484*
                                                                                  528* 590* 598* 609* 615* 621* 628* 638* 662* 680*
                                                                                  699* 715* 735* 752* 767* 768* 773* 786* 797* 808*
                                                                                  814* 816 822* 824 830* 832 838* 840 848 852 853
                                                                                  861 865 866 873 877 878 880 880 893* 896 902* 905
                                                                                  907* 913* 916 918* 921 942* 1025* 1034*
ioname                          000020 internal static char(32)                 initial unaligned dcl 209 set ref 376* 377 600* 754*
                                                                                  768* 773* 814* 822* 830* 838* 893* 902* 907* 913*
                                                                                  918* 1025* 1034* 1208 1214*
iox_$attach_loud                000134 constant        entry                    external dcl 284 ref 752
iox_$close                      000136 constant        entry                    external dcl 285 ref 433
iox_$close_file                 000140 constant        entry                    external dcl 286 ref 715
iox_$control                    000142 constant        entry                    external dcl 287 ref 590 598
iox_$delete_record              000144 constant        entry                    external dcl 288 ref 628
iox_$destroy_iocb               000146 constant        entry                    external dcl 289 ref 786
iox_$detach                     000150 constant        entry                    external dcl 290 ref 735
iox_$detach_iocb                000152 constant        entry                    external dcl 291 ref 418
iox_$err_no_operation           000200 constant        entry                    external dcl 302 ref 897 897
iox_$err_not_attached           000202 constant        entry                    external dcl 303 ref 898 898
iox_$err_not_closed             000204 constant        entry                    external dcl 304 ref 899 899
iox_$err_not_open               000206 constant        entry                    external dcl 305 ref 900 900
iox_$find_iocb                  000154 constant        entry                    external dcl 292 ref 795 1034
iox_$look_iocb                  000156 constant        entry                    external dcl 293 ref 773 814 822 830 838 893 902 907
                                                                                  913 918 1025
iox_$modes                      000160 constant        entry                    external dcl 294 ref 484 942
iox_$move_attach                000162 constant        entry                    external dcl 295 ref 797
iox_$open                       000164 constant        entry                    external dcl 296 ref 426
iox_$open_file                  000166 constant        entry                    external dcl 297 ref 699
iox_$position                   000170 constant        entry                    external dcl 298 ref 528
iox_$read_key                   000172 constant        entry                    external dcl 299 ref 662
iox_$read_length                000174 constant        entry                    external dcl 300 ref 680
iox_$seek_key                   000176 constant        entry                    external dcl 301 ref 638
j                               000133 automatic       fixed bin(17,0)          dcl 51 set ref 360* 367
key                             000141 automatic       varying char(256)        dcl 56 set ref 636* 638* 645* 651* 661* 662* 665*
                                                                                  668 669 671*
length                                                 builtin function         dcl 251 ref 878 947 959 1138
lower                     0(18)        based           bit(18)                  level 2 packed unaligned dcl 219 ref 360
max                                                    builtin function         dcl 251 ref 1052
max_arglen               43     000104 automatic       fixed bin(17,0)          level 2 dcl 550 set ref 580*
max_l                           000250 automatic       fixed bin(17,0)          dcl 63 set ref 550 580 584 584 584 1049* 1052* 1052
min                                                    builtin function         dcl 251 ref 1057
mode                            000134 automatic       fixed bin(17,0)          dcl 52 set ref 426* 699* 1174* 1176 1176 1183* 1184
                                                                                  1184*
mode_str                        000516 automatic       char(512)                unaligned dcl 936 set ref 942* 944
modes                           000716 automatic       varying char(512)        dcl 937 set ref 944* 945 946 947 949 949 955 959
                                                                                  959* 960* 960
msg                       1            based           char                     level 2 packed unaligned dcl 224 set ref 852* 853*
                                                                                  865* 866* 877 878 880 880
msg_len                                based           fixed bin(17,0)          level 2 dcl 224 ref 852 852 853 853 865 865 866 866
                                                                                  877 878 880 880
msg_ptr                         000252 automatic       pointer                  dcl 64 set ref 358* 359 361 362 362 364 364 369 369
n_args                          000112 automatic       fixed bin(17,0)          dcl 41 set ref 314* 322* 328 353 460 517 582 1050
                                                                                  1056 1066 1079 1120 1125 1143 1148 1198
n_high                          000247 automatic       fixed bin(17,0)          dcl 62 set ref 550 579 1056* 1057
n_low                           000246 automatic       fixed bin(17,0)          dcl 61 set ref 1057*
nargs                    42     000104 automatic       fixed bin(17,0)          level 2 dcl 550 set ref 579*
negate_sw                       000244 automatic       bit(1)                   unaligned dcl 59 set ref 496* 506* 524
new_mode_sw                     000243 automatic       bit(1)                   unaligned dcl 58 set ref 459* 463 470* 473
next_arg                        000113 automatic       fixed bin(17,0)          dcl 42 set ref 333* 460 517 582 991* 992* 993* 993
                                                                                  1048 1050 1055* 1056 1066 1079 1117 1120 1125
                                                                                  1129* 1143 1148 1198
no_quote_sw                     000275 automatic       bit(1)                   unaligned dcl 70 set ref 668 852 865 1078* 1082*
not_sw                          000504 automatic       bit(1)                   unaligned dcl 934 set ref 939* 940 952 957
null                                                   builtin function         dcl 251 ref 573 598 598 752 816 824 832 840 848 861
                                                                                  873 905 916 921
old_modes                       000304 automatic       char(512)                unaligned dcl 481 set ref 483* 484* 486 486 487 487*
op                                     parameter       char                     unaligned dcl 1095 ref 1093 1099 1102
op_match                        000250 constant        fixed bin(17,0)          initial array dcl 147 ref 1102
open_abbrev                     000051 constant        char(4)                  initial array unaligned dcl 191 ref 1184
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-6 ref 824 832 848 852 853 916
open_type                       000066 constant        char(24)                 initial array unaligned dcl 174 ref 1176 1183 1184
opt_name                        000424 constant        char(14)                 initial array unaligned dcl 81 ref 1098 1099
opt_name2                       000303 constant        char(12)                 initial array unaligned dcl 115 ref 1101 1102
order                           000254 automatic       char(32)                 unaligned dcl 65 set ref 539* 540 540 541* 565 598
                                                                                  598 600*
order_name               11     000104 automatic       char(32)                 level 2 dcl 550 set ref 565*
p1                              001214 automatic       pointer                  dcl 1162 set ref 1164* 1166
p2                              001216 automatic       pointer                  dcl 1162 set ref 1165* 1166
p3                              001220 automatic       pointer                  dcl 1162 set ref 1164* 1165*
print_sw                        000242 automatic       bit(1)                   unaligned dcl 57 set ref 458* 462* 487
req                             000010 internal static char(32)                 initial unaligned dcl 208 set ref 335* 336 344* 348
                                                                                  357
requote_string_                 000210 constant        entry                    external dcl 307 ref 486 669 853 866 1145
rtrim                                                  builtin function         dcl 251 ref 486 486 598 598 944
s                                      parameter       char                     unaligned dcl 978 set ref 976 982*
save_next_arg                   001204 automatic       fixed bin(17,0)          dcl 1115 in procedure "get_desc_len" set ref 1117*
                                                                                  1129
save_next_arg                   001150 automatic       fixed bin(17,0)          dcl 1046 in procedure "check_args" set ref 1048*
                                                                                  1055
search                                                 builtin function         dcl 251 ref 1122 1145
substr                                                 builtin function         dcl 251 ref 880 880 939 940 949 949 955 960
test_mode                       000505 automatic       varying char(32)         dcl 935 set ref 940* 941* 949 955
upper                                  based           bit(18)                  level 2 packed unaligned dcl 219 ref 361 362 362 364
                                                                                  364 369 369
valid_af                        000247 constant        bit(1)                   initial array unaligned dcl 152 ref 352
valid_mode_sw                   000302 automatic       bit(1)                   unaligned dcl 72 set ref 926* 949 955 963 971*
valid_op                        000204 constant        fixed bin(17,0)          initial array dcl 168 ref 892
var_description                 000100 automatic       varying char             dcl 1138 set ref 1141* 1145* 1145 1147* 1147 1148*
                                                                                  1148 1153
version                         000104 automatic       fixed bin(17,0)          level 2 dcl 550 set ref 563*
word                                   based           structure                level 1 dcl 219

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
attach_entry                           automatic       char(32)                 unaligned dcl 48
cu_$ptr_call                    000000 constant        entry                    external dcl 262
dir                                    automatic       char(168)                unaligned dcl 43
ename                                  automatic       char(32)                 unaligned dcl 45
expand_path_                    000000 constant        entry                    external dcl 268
hcs_$initiate                   000000 constant        entry                    external dcl 270
hcs_$make_ptr                   000000 constant        entry                    external dcl 271
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-51
reverse                                                builtin function         dcl 251
seg_ptr                                automatic       pointer                  dcl 46
term_$single_refname            000000 constant        entry                    external dcl 308

NAMES DECLARED BY EXPLICIT CONTEXT.
at_eol                          007114 constant        entry                    internal dcl 1196 ref 725
bad_req                         001210 constant        label                    dcl 347 ref 352
check_args                      006260 constant        entry                    internal dcl 1044 ref 545
check_eol                       006322 constant        entry                    internal dcl 1064 ref 417 424 432 527 627 635 659
                                                                                  678 766 785 794 807 813 821 829 837 845 860 871
                                                                                  891 930
check_nq                        006366 constant        entry                    internal dcl 1075 ref 658 847 859
cv_dec                          006101 constant        entry                    internal dcl 1000 ref 497 519 1174
equal_ev                        006760 constant        entry                    internal dcl 1159 ref 897 898 899 900
err_1                           005630 constant        label                    dcl 1205 ref 339 349 380 1209
err_2                           005657 constant        label                    dcl 1208 set ref 390 396 485 595 645 664 682 778 800
                                                                                  850 863 875 943 1026 1035
err_3                           005666 constant        label                    dcl 1211 ref 465 796 799 889 965 1087 1178 1189
err_4                           005720 constant        label                    dcl 1214 ref 393
exit                            001503 constant        label                    dcl 400 ref 406 409 440 446 452 490 510 522 543 594
                                                                                  601 610 616 622 652 672 687 769 802 809 854 867
                                                                                  881 983 1069 1206 1212
false                           001517 constant        label                    dcl 408 ref 531 641 776 815 816 823 824 833 841 895
                                                                                  897 898 899 900 906 910 915 916 920 921 953 957
                                                                                  963
find_iocb                       006233 constant        entry                    internal dcl 1032 ref 744 765
findx                           004222 constant        label                    dcl 766 ref 779
finish                          001471 constant        label                    dcl 390 ref 419 427 434 533 604 629 703 719 739 787
finish_attach                   001474 constant        label                    dcl 393 ref 760
get_arg                         005751 constant        entry                    internal dcl 976 ref 334 375 461 495 518 538 583 634
                                                                                  793 885 929 1051 1080 1121 1144 1173
get_arg_ptr                     006030 constant        entry                    internal dcl 989 ref 980 1067
get_desc                        006565 constant        entry                    internal dcl 1135 ref 698 714 734 751
get_desc_len                    006507 constant        entry                    internal dcl 1112 ref 692 708 728 745
get_op_number                   006425 constant        entry                    internal dcl 1093 ref 344 886
get_sw                          001423 constant        label                    dcl 375 ref 353
help                            001241 constant        label                    dcl 358 ref 331
io                              001027 constant        entry                    external dcl 31
io_call                         001036 constant        entry                    external dcl 31
look_iocb                       006206 constant        entry                    internal dcl 1023 ref 416 431 438 444 450 456 494
                                                                                  537 608 614 620 626 633 657 677 707 723 784 792
                                                                                  806 846 858 872 927 1172
op                              000000 constant        label                    array(35) dcl 416 ref 385 725
open_common                     007024 constant        entry                    internal dcl 1170 ref 423 691
report                          006134 constant        entry                    internal dcl 1009 ref 405 408 852 853 865 866 880
test_mode_join                  005375 constant        label                    dcl 927 ref 972
true                            001504 constant        label                    dcl 405 ref 530 640 775 817 825 831 832 839 840 901
                                                                                  904 905 909 911 917 922 949 952 955 958
valid_op_test                   000043 constant        label                    array(6) dcl 893 ref 892

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10432       10644    7564       10442
Length     11216    7564       212         335     646          20

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
io                                  940 external procedure  is an external procedure.  
begin block on line 479                 begin block         shares stack frame of external procedure io.  
begin block on line 547             100 begin block         uses auto adjustable storage.  
begin block on line 694             102 begin block         uses auto adjustable storage.  
begin block on line 710              92 begin block         uses auto adjustable storage.  
begin block on line 730              92 begin block         uses auto adjustable storage.  
begin block on line 747             124 begin block         uses auto adjustable storage.  
begin block on line 932                 begin block         shares stack frame of external procedure io.  
get_arg                              86 internal procedure  is called by several nonquick procedures.  
get_arg_ptr                          76 internal procedure  is called by several nonquick procedures.  
cv_dec                                  internal procedure  shares stack frame of external procedure io.  
report                               76 internal procedure  is called during a stack extension.  
look_iocb                               internal procedure  shares stack frame of external procedure io.  
find_iocb                               internal procedure  shares stack frame of external procedure io.  
check_args                              internal procedure  shares stack frame of external procedure io.  
check_eol                               internal procedure  shares stack frame of external procedure io.  
check_nq                                internal procedure  shares stack frame of external procedure io.  
get_op_number                           internal procedure  shares stack frame of external procedure io.  
get_desc_len                            internal procedure  shares stack frame of external procedure io.  
get_desc                             92 internal procedure  uses auto adjustable storage.  
equal_ev                                internal procedure  shares stack frame of external procedure io.  
open_common                             internal procedure  shares stack frame of external procedure io.  
at_eol                                  internal procedure  shares stack frame of external procedure io.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 req                         io
000020 ioname                      io

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 547  000100 io_call_order_name          begin block on line 547
                         000104 io_call_info                begin block on line 547
begin block on line 694  000100 description                 begin block on line 694
begin block on line 710  000100 description                 begin block on line 710
begin block on line 730  000100 description                 begin block on line 730
begin block on line 747  000100 description                 begin block on line 747
get_desc                 000100 var_description             get_desc
io                       000100 code                        io
                         000102 arg_list_ptr                io
                         000104 arg_ptr                     io
                         000106 arg_len                     io
                         000107 arg2_len                    io
                         000110 arg2_ptr                    io
                         000112 n_args                      io
                         000113 next_arg                    io
                         000114 desc_len                    io
                         000115 arg_name                    io
                         000126 iocb_ptr                    io
                         000130 iocb2_ptr                   io
                         000132 i                           io
                         000133 j                           io
                         000134 mode                        io
                         000135 cv_dec_err                  io
                         000136 data_ptr                    io
                         000140 data_len                    io
                         000141 key                         io
                         000242 print_sw                    io
                         000243 new_mode_sw                 io
                         000244 negate_sw                   io
                         000245 dummy_char                  io
                         000246 n_low                       io
                         000247 n_high                      io
                         000250 max_l                       io
                         000252 msg_ptr                     io
                         000254 order                       io
                         000264 error                       io
                         000270 af_sw                       io
                         000272 af_retp                     io
                         000274 af_retl                     io
                         000275 no_quote_sw                 io
                         000276 ev                          io
                         000302 valid_mode_sw               io
                         000304 old_modes                   begin block on line 479
                         000504 not_sw                      begin block on line 932
                         000505 test_mode                   begin block on line 932
                         000516 mode_str                    begin block on line 932
                         000716 modes                       begin block on line 932
                         001150 save_next_arg               check_args
                         001174 i                           get_op_number
                         001204 save_next_arg               get_desc_len
                         001214 p1                          equal_ev
                         001216 p2                          equal_ev
                         001220 p3                          equal_ev

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_cs            enter_begin         leave_begin         call_var_desc
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return              tra_ext             alloc_auto_adj      shorten_stack       ext_entry           int_entry
int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_arg_ptr_rel            cu_$af_return_arg
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel               cu_$decode_entry_value
cv_dec_check_                 io_call_print_iocb_           io_call_read_write_$get_chars io_call_read_write_$get_line
io_call_read_write_$put_chars io_call_read_write_$read_record
io_call_read_write_$rewrite_record                          io_call_read_write_$write_record
ioa_                          ioa_$rsnnl                    iox_$attach_loud              iox_$close
iox_$close_file               iox_$control                  iox_$delete_record            iox_$destroy_iocb
iox_$detach                   iox_$detach_iocb              iox_$err_no_operation         iox_$err_not_attached
iox_$err_not_closed           iox_$err_not_open             iox_$find_iocb                iox_$look_iocb
iox_$modes                    iox_$move_attach              iox_$open                     iox_$open_file
iox_$position                 iox_$read_key                 iox_$read_length              iox_$seek_key
requote_string_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode         error_table_$badopt           error_table_$end_of_info      error_table_$key_order
error_table_$no_ext_sym       error_table_$no_operation     error_table_$no_record        error_table_$noarg
error_table_$not_attached     error_table_$not_detached     error_table_$not_open
error_table_$request_not_recognized                         error_table_$seg_not_found    error_table_$too_many_args
error_table_$undefined_order_request                        io_call_msg_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 001026       314 001043       315 001057       316 001061       317 001063       318 001070       320 001071
    321 001073       322 001100       324 001106       328 001115       329 001117       330 001120       331 001124
    333 001125       334 001127       335 001143       336 001155       337 001162       338 001164       339 001171
    344 001172       346 001206       347 001210       348 001213       349 001220       352 001221       353 001230
    357 001233       358 001241       359 001244       360 001250       361 001253       362 001260       364 001320
    367 001361       368 001371       369 001374       370 001420       371 001422       375 001423       376 001440
    377 001452       378 001457       379 001461       380 001466       385 001467       390 001471       391 001473
    393 001474       396 001500       398 001502       400 001503       405 001504       406 001516       408 001517
    409 001531       416 001532       417 001533       418 001534       419 001545       423 001546       424 001547
    426 001550       427 001567       431 001570       432 001571       433 001572       434 001603       438 001604
    439 001605       440 001616       444 001617       445 001620       446 001631       450 001632       451 001633
    452 001644       456 001645       457 001646       458 001653       459 001655       460 001656       461 001661
    462 001671       463 001705       464 001707       465 001712       468 001713       469 001715       470 001716
    472 001720       473 001721       474 001723       475 001725       476 001727       483 001731       484 001734
    485 001764       486 001766       487 002044       490 002076       494 002077       495 002100       496 002116
    497 002117       498 002123       499 002125       500 002142       501 002155       502 002175       503 002176
    504 002177       505 002213       506 002214       507 002216       509 002217       510 002252       517 002253
    518 002264       519 002302       520 002306       521 002310       522 002343       524 002344       525 002350
    526 002351       527 002352       528 002353       529 002370       530 002373       531 002375       533 002400
    537 002401       538 002402       539 002414       540 002421       541 002431       543 002470       545 002471
    547 002472       550 002475       563 002506       564 002510       565 002513       566 002516       567 002524
    568 002527       569 002531       570 002533       571 002540       573 002541       574 002543       575 002544
    577 002547       578 002553       579 002565       580 002570       581 002572       582 002574       583 002600
    584 002611       585 002636       586 002637       590 002640       592 002666       594 002667       595 002671
    596 002674       598 002701       599 002746       600 002751       601 003007       604 003010       608 003011
    609 003012       610 003023       614 003024       615 003025       616 003036       620 003037       621 003040
    622 003051       626 003052       627 003053       628 003054       629 003065       633 003066       634 003067
    635 003101       636 003102       637 003113       638 003115       639 003132       640 003135       641 003137
    643 003142       644 003144       645 003147       648 003203       649 003204       650 003232       651 003233
    652 003263       657 003264       658 003265       659 003266       660 003267       661 003271       662 003272
    663 003307       664 003311       665 003314       666 003352       667 003353       668 003356       669 003372
    670 003434       671 003436       672 003466       677 003467       678 003470       679 003471       680 003473
    681 003506       682 003510       683 003513       684 003541       685 003542       686 003602       687 003627
    691 003630       692 003631       694 003633       696 003636       698 003646       699 003651       698 003654
    699 003664       701 003720       703 003721       707 003722       708 003723       710 003725       712 003730
    714 003740       715 003743       714 003746       715 003756       717 004000       719 004001       723 004002
    725 004003       728 004010       730 004012       732 004015       734 004025       735 004030       734 004033
    735 004043       737 004065       739 004066       744 004067       745 004070       747 004072       749 004075
    751 004105       752 004110       754 004113       751 004116       752 004126       753 004155       754 004162
    755 004215       758 004217       760 004220       765 004221       766 004222       767 004223       768 004263
    769 004315       773 004316       774 004336       775 004341       776 004343       778 004344       779 004346
    784 004347       785 004350       786 004351       787 004362       792 004363       793 004364       794 004400
    795 004401       796 004425       797 004427       798 004442       799 004444       800 004447       802 004450
    806 004451       807 004452       808 004453       809 004462       813 004463       814 004464       815 004505
    816 004507       817 004514       821 004515       822 004516       823 004537       824 004541       825 004546
    829 004547       830 004550       831 004571       832 004573       833 004600       837 004601       838 004602
    839 004623       840 004625       841 004632       845 004633       846 004634       847 004635       848 004636
    849 004643       850 004646       852 004647       853 004666       854 004717       858 004721       859 004722
    860 004723       861 004724       862 004731       863 004734       865 004735       866 004754       867 005005
    871 005007       872 005010       873 005011       874 005016       875 005021       877 005022       878 005035
    879 005041       880 005043       881 005062       885 005064       886 005100       887 005117       888 005121
    889 005124       891 005125       892 005126       893 005131       895 005152       896 005154       897 005163
    898 005175       899 005207       900 005221       901 005233       902 005234       904 005255       905 005257
    906 005264       907 005265       909 005306       910 005310       911 005311       913 005312       915 005333
    916 005335       917 005342       918 005343       920 005364       921 005366       922 005373       926 005374
    927 005375       929 005376       930 005410       939 005411       940 005417       941 005432       942 005442
    943 005467       944 005471       945 005511       946 005517       947 005531       948 005535       949 005537
    952 005554       953 005556       954 005557       955 005560       957 005570       958 005572       959 005573
    960 005601       961 005616       963 005617       964 005621       965 005624       971 005625       972 005627
   1205 005630      1206 005656      1208 005657      1209 005665      1211 005666      1212 005717      1214 005720
   1216 005747       976 005750       980 005764       981 005771       982 005774       983 006024       989 006027
    991 006035       992 006060       993 006076       995 006100      1000 006101      1002 006103      1009 006133
   1013 006147      1014 006166      1015 006205      1023 006206      1025 006207      1026 006230      1027 006232
   1032 006233      1034 006234      1035 006255      1036 006257      1044 006260      1048 006261      1049 006263
   1050 006265      1051 006271      1052 006301      1053 006306      1055 006307      1056 006311      1057 006315
   1058 006321      1064 006322      1066 006323      1067 006327      1068 006333      1069 006365      1075 006366
   1078 006367      1079 006370      1080 006374      1081 006404      1082 006416      1083 006420      1086 006421
   1087 006424      1093 006425      1098 006436      1099 006443      1100 006456      1101 006460      1102 006465
   1103 006502      1104 006504      1112 006507      1117 006511      1118 006513      1120 006514      1121 006517
   1122 006527      1124 006551      1125 006554      1127 006560      1129 006561      1131 006563      1135 006564
   1138 006600      1140 006613      1141 006621      1143 006622      1144 006626      1145 006637      1147 006716
   1148 006732      1151 006746      1153 006747      1155 006757      1159 006760      1164 006762      1165 006775
   1166 007011      1170 007024      1172 007025      1173 007026      1174 007042      1175 007046      1176 007050
   1177 007055      1178 007060      1180 007061      1183 007062      1184 007067      1186 007106      1188 007110
   1189 007113      1196 007114      1198 007116


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
