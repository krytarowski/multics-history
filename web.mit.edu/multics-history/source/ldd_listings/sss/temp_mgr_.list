	COMPILATION LISTING OF SEGMENT temp_mgr_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/16/86  0854.7 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       13*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       14*     Improved documentation and readability, changed errname to use the
       15*     caller-supplied name instead of "binder_", changed make_object and
       16*     close_files entrypoints to use a process dir temporary until binding is
       17*     complete and then copy into the working dir.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* ******************************************************
       22*   *                                                    *
       23*   *                                                    *
       24*   * Copyright (c) 1978 by Massachusetts Institute of   *
       25*   * Technology and Honeywell Information Systems, Inc. *
       26*   *                                                    *
       27*   *                                                    *
       28*   ****************************************************** */
       29 
       30 
       31 
       32 /* procedure to do temporary database management for the binder.
       33*
       34*Designed and originally coded by Michael J. Spier, August 19, 1970  */
       35 /* Modified 9/78 by David Spector to use get_temp_segment_ and release_temp_segment_ */
       36 /*		Note: -debug no longer stores temp segs in wdir!	*/
       37 /* Modified 9/20/84 by M Sharpe to 1) use nd_handler_;
       38*	2) check for null pointers before using them;
       39**/
       40 
       41 /* format: style3,^indnoniterdo */
       42 
       43 temp_mgr_:
       44      procedure;
       45 
       46 
       47 /* DECLARATION OF EXTERNAL ENTRIES */
       48 
       49 declare	com_err_		external entry options (variable);
       50 declare	error_table_$segnamedup
       51 			external fixed bin (35);
       52 declare	error_table_$namedup
       53 			external fixed bin (35);
       54 declare	error_table_$rqover external fixed bin (35);
       55 declare	get_pdir_		external entry () returns (char (168));
       56 declare	get_wdir_		external entry () returns (char (168));
       57 declare	get_temp_segment_	external entry (char (*), ptr, fixed bin (35));
       58 declare	hcs_$chname_seg	ext entry (ptr, char (*) aligned, char (*) aligned, fixed bin (35));
       59 declare	initiate_file_$create
       60 			ext
       61 			entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
       62 declare	nd_handler_	ext entry (char (*), char (*), char (*), fixed bin (35));
       63 declare	release_temp_segment_
       64 			external entry (char (*), ptr, fixed bin (35));
       65 declare	sys_info$max_seg_size
       66 			external fixed bin (19);
       67 declare	terminate_file_	ext entry (ptr, fixed bin (24), bit (*), fixed bin (35));
       68 declare	tssi_$clean_up_segment
       69 			entry (ptr);
       70 declare	tssi_$get_segment	external entry (char (*) aligned, char (*) aligned, pointer, ptr, fixed bin (35));
       71 declare	tssi_$finish_segment
       72 			external entry (pointer, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
       73 
       74 /* DECLARATION OF INTERNAL STATIC VARIABLES */
       75 
       76 declare	pdir		char (168) internal static initial ("");
       77 declare	wdir		char (168) aligned internal static initial (" ");
       78 declare	limit		fixed bin (18) internal static;
       79 declare	mask		bit (36) aligned internal static initial ("000000000000000000111111111111111000"b);
       80 declare	errname		char (16) aligned internal static;
       81 
       82 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
       83 
       84 declare	bound_segl	fixed bin (21);
       85 declare	bound_segp	ptr;
       86 declare	created		bit (1) aligned;
       87 declare	offset		fixed bin (18);
       88 declare	i		fixed bin;
       89 declare	code		fixed bin (35);
       90 declare	(p, sp, ip)	pointer;
       91 declare	segname		char (32) aligned;
       92 
       93 
       94 /* DECLARATION OF BUILTIN FUNCTIONS */
       95 
       96 declare	(addr, divide, null, ptr, rel, rtrim, substr)
       97 			builtin;
       98 
       99 /* DECLARATION OF CONDITIONS */
      100 
      101 declare	cleanup		condition;
      102 declare	record_quota_overflow
      103 			condition;
      104 
      105 /* DECLARATION OF BASED STRUCTURES */
      106 
      107 declare	1 temp_seg	based aligned,		/* format of temp segments */
      108 	  2 next_temp_ptr	ptr,			/* ptr to next chained temp seg */
      109 	  2 storage	bit (0);			/* start of temp_mgr_ storage */
      110 
      111 declare	bound_seg		char (bound_segl) based;
      112 
      113 declare	1 offset_overlay	aligned based (addr (offset)),
      114 	  2 dum		bit (18) unaligned,
      115 	  2 relp		bit (18) unaligned;
      116 declare	offset_bits	bit (36) aligned based (addr (offset));
      117 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      118 
      119 
  2     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  2     2 /* format: style2,^inddcls,idind32 */
  2     3 
  2     4 declare 1 terminate_file_switches	based,
  2     5 	2 truncate		bit (1) unaligned,
  2     6 	2 set_bc			bit (1) unaligned,
  2     7 	2 terminate		bit (1) unaligned,
  2     8 	2 force_write		bit (1) unaligned,
  2     9 	2 delete			bit (1) unaligned;
  2    10 
  2    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  2    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  2    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  2    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  2    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  2    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  2    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  2    18 
  2    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      120 
      121 
      122 
      123 reserve:
      124      entry (last_used);
      125 
      126 /**********************************************************************/
      127 /*							*/
      128 /*	Name:	temp_mgr_$reserve				*/
      129 /*	Input:	last_used					*/
      130 /*	Function:	reserves a block of storage from the current	*/
      131 /*		address pointed to by bx_$freep to the address	*/
      132 /*		pointed to by last_used and realigns bx_$freep	*/
      133 /*		to a 0 mod 8 boundary.  If the new value for	*/
      134 /*		bx_$freep is past a preset limit, a new temp_seg	*/
      135 /*		is procured and chained in and bx_$freep set to	*/
      136 /*		point to the start of it's storage area.	*/
      137 /*		NB.  Since no guarantees can be made about the	*/
      138 /*		     amount of space remaining in the temp_seg	*/
      139 /*		     temp_mgr_$allocate should be called prior	*/
      140 /*		     to calling temp_mgr_$reserve to insure that	*/
      141 /*		     sufficient space is available.		*/
      142 /*	Output:	none					*/
      143 /*							*/
      144 /**********************************************************************/
      145 
      146 declare	last_used		pointer;
      147 
      148 	offset = 0;				/* preset to zero */
      149 	offset_overlay.relp = rel (last_used);		/* get offset of last-used location */
      150 	offset = offset + 7;			/* make new offset 0 mod 8 */
      151 	offset_bits = offset_bits & mask;		/* ... */
      152 	if offset <= limit
      153 	then /* segment not yet overflowing */
      154 	     do;					/* generate new free pointer */
      155 	     bx_$freep = ptr (last_used, offset_overlay.relp);
      156 	     return;
      157 	end;
      158 
      159 /* arrived here we have an overflowing temporary segment, and must create a new one */
      160 
      161 create_temp:					/* Initialize a new temp segment.  bx_$temp contains a pointer (initially null) to the
      162*   latest temp seg.  Each temp seg contains a pointer to the previous one in the list.
      163*   Exact format is described by declaration for "temp_seg". */
      164 	call get_temp_segment_ ("bind", p, code);
      165 	if code ^= 0
      166 	then do;
      167 	     call com_err_ (code, errname, "unable to create temporary segment.");
      168 	     bx_$fatal_error = 1;
      169 	     return;
      170 	end;
      171 
      172 /* Push new temp segment onto chained list of temp segs, for later releasing. */
      173 
      174 	p -> temp_seg.next_temp_ptr = bx_$temp;
      175 	bx_$temp = p;
      176 
      177 /* Initialize for storing into space following the fwd ptr. */
      178 
      179 	bx_$freep = addr (bx_$temp -> temp_seg.storage);
      180 
      181 	return;
      182 
      183 
      184 allocate:
      185      entry (area_size);
      186 
      187 declare	area_size		fixed bin;
      188 
      189 /**********************************************************************/
      190 /*							*/
      191 /*	Name:	temp_mgr_$allocate				*/
      192 /*	Input:	area_size					*/
      193 /*	Function:	checks to make sure that <area_size> words can be	*/
      194 /*		allocated within the current temp_seg, and gets a	*/
      195 /*		new one if not.				*/
      196 /*	Output:	none					*/
      197 /*							*/
      198 /**********************************************************************/
      199 
      200 	offset = 0;
      201 	offset_overlay.relp = rel (bx_$freep);		/* get current offset */
      202 	if offset + area_size <= limit
      203 	then return;				/* there is enough room for area */
      204 
      205 	goto create_temp;				/* go make another temporary */
      206 
      207 
      208 close_files:
      209      entry;
      210 
      211 /**********************************************************************/
      212 /*							*/
      213 /*	Name:	temp_mgr_$close_files			*/
      214 /*	Input:	none					*/
      215 /*	Function:	copies the process directory copy of the bound	*/
      216 /*		object segment into the working dir and adds the	*/
      217 /*		appropriate names to the new object segment.	*/
      218 /*		If an Addname statement occurred in the bindfile	*/
      219 /*		add the given names if any were given or add the	*/
      220 /*		names off all retained entrypoints if no names	*/
      221 /*		were specified.  The object segment bit count and	*/
      222 /*		acl are set and the temp_segs are released.	*/
      223 /*	Output:	none					*/
      224 /*							*/
      225 /**********************************************************************/
      226 
      227 
      228 	bx_$bseg_acinfop = null;
      229 	bound_segp = null;
      230 
      231 	if bx_$fatal_error ^= 0
      232 	then do;
      233 
      234 	     call close_file_cleanup ();
      235 
      236 	     return;				/* forget the rest */
      237 						/* save the bad version */
      238 	end;
      239 
      240 /* move the new bound object from the pdir temporary into the final	*/
      241 /* working dir copy.					*/
      242 
      243 	on cleanup
      244 	     begin;
      245 		call close_file_cleanup ();
      246 	     end;
      247 
      248 /* create the working dir copy of the bound object segment	*/
      249 
      250 	call tssi_$get_segment (wdir, bx_$bound_segname, bound_segp, bx_$bseg_acinfop, code);
      251 	if code ^= 0
      252 	then do;
      253 	     call com_err_ (code, errname, "^/Unable to create ^a, a copy exists in [pd]>^a", bx_$bound_segname,
      254 		bx_$bound_segname);
      255 	     bx_$fatal_error = 1;
      256 	     call close_file_cleanup ();
      257 	     return;
      258 	end;
      259 
      260 /* if a record quota overflow occurs while we are copying, print	*/
      261 /* a message indicating that an intact copy of the bound segment is	*/
      262 /* available in the process directory, and then abort.		*/
      263 
      264 	on record_quota_overflow
      265 	     begin;
      266 		call com_err_ (error_table_$rqover, errname, "^/Unable to complete ^a, a copy exists in [pd]>^a",
      267 		     bx_$bound_segname, bx_$bound_segname);
      268 		call close_file_cleanup;		/* clean up what would have been the final version */
      269 		goto close_file_return;
      270 	     end;
      271 
      272 /* calculate the length of the bound segment expressed in terms of	*/
      273 /* characters for the string overlay copy operation.		*/
      274 
      275 	bound_segl = divide (bx_$bseg_bitcount, 9, 21, 0);
      276 
      277 /* copy the new bound segment into the working dir copy		*/
      278 
      279 	bound_segp -> bound_seg = bx_$temp_bsegp -> bound_seg;
      280 
      281 	revert record_quota_overflow;
      282 	bx_$bsegp = bound_segp;			/* now operate on the real thing */
      283 
      284 /* now delete the copy of the bound object in the process dir	*/
      285 
      286 	call terminate_file_ (bx_$temp_bsegp, 0, TERM_FILE_DELETE, code);
      287 	bx_$temp_bsegp = null;			/* done with this */
      288 
      289 
      290 /* add the appropriate synonyms to the bound segment */
      291 
      292 	if bx_$addname = 1
      293 	then do;
      294 	     adnp = bx_$adnp;
      295 
      296 /* add all names explicitly asked for by Addname statement by	*/
      297 /* direct extraction from the addname table.			*/
      298 
      299 	     if an.n_an > 0
      300 	     then do i = 1 to an.n_an;
      301 		     segname = an.syn (i);
      302 		     call Addname;
      303 		end;
      304 
      305 /* add names specified by implicit addname (ie. "Addname;") by	*/
      306 /* scanning the segname table, and for each component, scanning the	*/
      307 /* definition list for retained definitions and adding the name of	*/
      308 /* the definition to the bound segment.			*/
      309 
      310 	     else do i = 1 to bx_$sntp -> snt.n_names;
      311 		     sp = addr (bx_$sntp -> snt.entry (i));
      312 		     ip = sp -> seg.comp -> comp.insymentp;
      313 		     if ip -> insym.retained = "1"b
      314 		     then do;
      315 			segname = substr (sp -> seg.name, 2, sp -> seg.lng - 1);
      316 			call Addname;
      317 		     end;
      318 		end;
      319 	end;					/* finished processing Addname */
      320 
      321 
      322 	do p = bx_$temp repeat bx_$temp while (p ^= null);
      323 	     bx_$temp = p -> temp_seg.next_temp_ptr;
      324 	     call release_temp_segment_ ("bind", p, code);
      325 	end;
      326 
      327 	if bx_$bseg_acinfop ^= null
      328 	then call tssi_$finish_segment (bx_$bsegp, bx_$bseg_bitcount, "1100"b, bx_$bseg_acinfop, code);
      329 
      330 close_file_return:
      331 	return;
      332 
      333 
      334 
      335 close_file_cleanup:
      336      proc ();
      337 
      338 	if bx_$bseg_acinfop ^= null
      339 	then call tssi_$clean_up_segment (bx_$bseg_acinfop);
      340 
      341 /* Return all temp segments to free pool. */
      342 
      343 	do p = bx_$temp repeat bx_$temp while (p ^= null);
      344 	     bx_$temp = p -> temp_seg.next_temp_ptr;
      345 	     call release_temp_segment_ ("bind", p, code);
      346 	end;
      347 
      348 	return;
      349      end close_file_cleanup;
      350 
      351 
      352 init:
      353      entry;
      354 
      355 /**********************************************************************/
      356 /*							*/
      357 /*	Name:	temp_mgr_$init				*/
      358 /*	Input:	none					*/
      359 /*	Function:	sets up the name for error messages and the limit	*/
      360 /*		on how full temp_segs will be allowed to grow.	*/
      361 /*		It then creates the first temp_seg.		*/
      362 /*	Output:	none					*/
      363 /*							*/
      364 /**********************************************************************/
      365 
      366 	if bx_$debug = 1
      367 	then errname = "temp_mgr_";
      368 	else errname = bx_$caller;
      369 	wdir = get_wdir_ ();			/* get name of working directory */
      370 	pdir = get_pdir_ ();			/* get name of process directory */
      371 	if sys_info$max_seg_size <= 65536
      372 	then limit = sys_info$max_seg_size - 8192;
      373 	else limit = sys_info$max_seg_size - 16384;	/* Slack in temporary will be 8K when 64K segments are maximum */
      374 						/* and will be 16K when 256K segments are maximum. */
      375 	bx_$temp = null;				/* Clear list of temp segments. */
      376 	goto create_temp;
      377 
      378 make_object:
      379      entry;
      380 
      381 /**********************************************************************/
      382 /*							*/
      383 /*	Name:	temp_mgr_$make_object			*/
      384 /*	Input:	none					*/
      385 /*	Function:	creates a working copy of the new object in the	*/
      386 /*		process directory with the name specified by	*/
      387 /*		bx_$bound_segname and saves the segment pointer	*/
      388 /*	Output:	none					*/
      389 /*							*/
      390 /**********************************************************************/
      391 
      392 	bx_$bseg_acinfop = null;
      393 
      394 	call initiate_file_$create (pdir, (bx_$bound_segname), RW_ACCESS, bx_$temp_bsegp, created, (0), code);
      395 	if code ^= 0
      396 	then do;
      397 	     call com_err_ (code, errname, "unable to create temporary copy of ^a", bx_$bound_segname);
      398 	     bx_$fatal_error = 1;
      399 	     return;
      400 	end;
      401 
      402 	if ^created
      403 	then do;
      404 	     call terminate_file_ (bx_$temp_bsegp, 0, TERM_FILE_TRUNC, code);
      405 	     if code ^= 0
      406 	     then do;
      407 		call com_err_ (code, errname, "unable to truncate temporary copy of ^a", bx_$bound_segname);
      408 		bx_$fatal_error = 1;
      409 		return;
      410 	     end;
      411 	end;
      412 
      413 	bx_$bsegp = bx_$temp_bsegp;			/* bind into the temp */
      414 
      415 	return;
      416 
      417 
      418 
      419 
      420 Addname:
      421      procedure;
      422 
      423 /**********************************************************************/
      424 /*							*/
      425 /*	Name:	Addname					*/
      426 /*	Input:	none					*/
      427 /*	Function:	adds the name specified by the global variable	*/
      428 /*		segname to the output object segment.  If the	*/
      429 /*		name is on another segment, the nd_handler_ is	*/
      430 /*		called to take care of things.		*/
      431 /*	Output:	none					*/
      432 /*							*/
      433 /**********************************************************************/
      434 
      435 TRY_ADDNAME:
      436 	call hcs_$chname_seg (bx_$bsegp, "", segname, code);
      437 						/* add name to the bound segment */
      438 	if code ^= 0
      439 	then do;					/* this is a name duplication */
      440 	     if code = error_table_$segnamedup
      441 	     then ;				/*   do nothing if seg already has the addname   */
      442 	     else if code = error_table_$namedup	/*   normal handling for name duplication   */
      443 	     then do;
      444 		call nd_handler_ ((bx_$caller), rtrim (wdir), (segname), code);
      445 		if code = 0
      446 		then go to TRY_ADDNAME;
      447 	     end;
      448 	end;
      449 
      450 
      451      end Addname;
      452 
      453 
      454 
  3     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  3     6*     audit(86-06-30,Weaver):
  3     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  3    11 
  3    12 /* include file bindext.incl.pl1 */
  3    13 
  3    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  3    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  3    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  3    17 
  3    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  3    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  3    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  3    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  3    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  3    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  3    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  3    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  3    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  3    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  3    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  3    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  3    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  3    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  3    32 declare  bx_$optp pointer external;			/* pointer to options table */
  3    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  3    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  3    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  3    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  3    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  3    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  3    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  3    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  3    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  3    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  3    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  3    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  3    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  3    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  3    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  3    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  3    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  3    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  3    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  3    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  3    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  3    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  3    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  3    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  3    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  3    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  3    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  3    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  3    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  3    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  3    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  3    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  3    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  3    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  3    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  3    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  3    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  3    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  3    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  3    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  3    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  3    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  3    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  3    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  3    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  3    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  3    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  3    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  3    81 
  3    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
      455 
      456 
  4     1 	/* Include file bndtbl.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  4     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  4     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  4     8*     to base structures on..
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 	/* DIVERSE BINDER TABLES */
  4    12 
  4    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  4    14 	/* Modified Dec 1978 by David Spector for making repatch table
  4    15*	   automatically extensible */
  4    16 	
  4    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  4    18 
  4    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  4    20 
  4    21 declare	1 snt aligned based(sntp),
  4    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  4    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  4    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  4    25 	2 entry(1000) like seg;
  4    26 
  4    27 	/* declaration of a SEGNAME entry */
  4    28 
  4    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  4    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  4    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  4    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  4    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  4    34 	  2 comp pointer,			/* pointer to associated component table */
  4    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  4    36 
  4    37 
  4    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  4    39 
  4    40 declare	1 an aligned based(adnp),
  4    41 	2 max_size fixed bin,		/* size limit of addname table */
  4    42 	2 n_an fixed bin,			/* number of names to add */
  4    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  4    44 
  4    45 
  4    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  4    47 
  4    48 declare	1 od aligned based(odnp),
  4    49 	2 max_size fixed bin,		/* max size of table */
  4    50 	2 n_odds fixed bin,			/* current size of table */
  4    51 	2 entry(1000),
  4    52 	  3 name char(289) aligned;
  4    53 
  4    54 
  4    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  4    56 
  4    57 declare	1 rpt aligned based(rptp),
  4    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  4    59 	2 npt fixed bin,
  4    60 	2 entry(1000) like rpte aligned;
  4    61 
  4    62 
  4    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  4    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  4    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  4    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  4    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  4    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  4    69 
  4    70 
  4    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  4    72 
  4    73 declare	1 strm aligned based(strmp),
  4    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  4    75 	2 max_size fixed bin,
  4    76 	2 nstr fixed bin,
  4    77 	2 entry(2048) unaligned,
  4    78 	  3 map bit(18),			/* rel pointer to string in def section */
  4    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  4    80 
  4    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  4    82 	/* have not been regenerated to insure generation of all links */
  4    83 	
  4    84 declare	1 lrt		aligned based (lrtp),
  4    85 	  2 count		fixed bin,
  4    86 	  2 start_offset	fixed bin (18) unsigned,
  4    87 	  2 regenerated (0 refer (lrt.count))
  4    88 			bit (18) unaligned;
  4    89 
  4    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  4    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
      457 
      458 
  5     1 	/* Include file comptbl.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  5     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  5     7*     added link_regeneration_table pointer (clrtp) to component structure.
  5     8*                                                   END HISTORY COMMENTS */
  5     9 
  5    10 declare	(ctp, ctep) pointer;
  5    11 
  5    12 declare	comp_tbl(1000) pointer based(ctp);
  5    13 
  5    14 
  5    15 
  5    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  5    17 	2 filename char(32) aligned,		/* object segment's file name */
  5    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  5    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  5    20 
  5    21 	2 ctxtp pointer,			/* pointer to base of text section */
  5    22 	2 cdefp pointer,			/* pointer to definitions */
  5    23 	2 cstatp pointer,			/* pointer to static section */
  5    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  5    25 	2 csymp pointer,			/* pointer to symbol table */
  5    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  5    27 	2 crltp pointer,			/* pointer to rel-text */
  5    28 	2 crllp pointer,			/* pointer to rel-link */
  5    29 	2 crlsp pointer,			/* pointer to rel-symb */
  5    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  5    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  5    32 	2 unused_1 pointer,			/* reserve */
  5    33 	2 unused_2 pointer,			/* reserve */
  5    34 	2 unused_3 fixed bin,		/* reserve */
  5    35 	2 cindex fixed bin,			/* this entry's index in table */
  5    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  5    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  5    38 	2 fn_lng fixed bin,			/* length of filename string */
  5    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  5    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  5    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  5    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  5    43          (2 defblockp,			/* rel pointer to component's definition block */
  5    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  5    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  5    46 	2 clngt fixed bin(18),		/* length of pure text section */
  5    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  5    48 	2 clngd fixed bin(18),		/* length of definition section */
  5    49 	2 clngi fixed bin,			/* length of internal static */
  5    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  5    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  5    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  5    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  5    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  5    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  5    56 
  5    57 	2 crelt fixed bin,			/* relocation value for text */
  5    58 	2 creli fixed bin,			/* relocation value for internal static */
  5    59 	2 crels fixed bin,			/* relocation value for symbol section */
  5    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  5    61  
  5    62 
  5    63 
      459 
      460 
  6     1 	/* Include file insym.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  6     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  6     7*     Changed to eliminate the use of "p" as a pointer to base the structures
  6     8*     on.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 declare	1 insym aligned based,		/* declaration of the INSYM structure */
  6    13 
  6    14 	2 thread pointer,			/* pointer to the next insym structure */
  6    15 	2 n_insyms fixed bin,		/* number of insym entries */
  6    16 	(2 retained,			/* def(s) have been retained for this component */
  6    17 	2 global_nolink) bit(1) unaligned,	/* don't prelink any reference to/from this object */
  6    18 	2 entry(1000) like is;
  6    19 
  6    20 declare	1 is aligned based,
  6    21          (2 next_ext_ptr bit(18),		/* thread to next def */
  6    22 	2 trap_ptr bit(18),			/* trap pointer */
  6    23 	2 value bit(18),			/* symbol's offset value */
  6    24 	2 class bit(18)) unaligned,		/* corresponding section of the object */
  6    25 	2 def_offset fixed bin(18),		/* offset of def in original def section */
  6    26 	2 symbol char(257) aligned,		/* the symbol in ACC string form */
  6    27 	2 lng fixed bin,			/* length in chars of ACC string (incl. ACC count) */
  6    28 	2 nargs fixed bin,			/* # of args expected by entry */
  6    29 	2 descr_ptr pointer,		/* ptr to descriptor ptr array */
  6    30          (2 null_entry,			/* 1->type 3 (seg|expr) entry, no insym symbol */
  6    31 	2 snapped,			/* 0->not referenced, 1->link snapped */
  6    32 	2 has_descr,			/* 1->entry has valid descriptors */
  6    33 	2 entrypoint,			/* 0->segdef, 1->entrypoint; meaningful only for standard */
  6    34 	2 retain_flag,			/* 1->turn on retain flag; was on in original */
  6    35 	2 delete,				/* 1->don't regenerate this def in any case */
  6    36 	2 ignore,				/* 1->regenerate but ignore */
  6    37 	2 regenerated,			/* this definition already regenerated */
  6    38 	2 retain,				/* 0->don't regenerate, 1->retain definition */
  6    39 	2 no_link,			/* don't prelink to this symbol */
  6    40 	2 duplicate) bit(1) unaligned,	/* this symbol name duplicated in another block */
  6    41 	2 defrel bit (18);			/* offset in defs of regenerated definition */
  6    42 
  6    43 
  6    44 
      461 
      462 
      463 
      464 
      465      end temp_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/16/86  0846.5  temp_mgr_.pl1                     >spec>install>1094>temp_mgr_.pl1
118          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
120          2    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
455          3    07/16/86  0841.5  bindext.incl.pl1                  >spec>install>1094>bindext.incl.pl1
457          4    07/16/86  0845.5  bndtbl.incl.pl1                   >spec>install>1094>bndtbl.incl.pl1
459          5    07/16/86  0845.6  comptbl.incl.pl1                  >spec>install>1094>comptbl.incl.pl1
461          6    07/16/86  0845.8  insym.incl.pl1                    >spec>install>1094>insym.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RW_ACCESS                       000001 constant        bit(3)                   initial unaligned dcl 1-11 set ref 394*
TERM_FILE_DELETE                000000 constant        bit(5)                   initial unaligned dcl 2-17 set ref 286*
TERM_FILE_TRUNC                 000011 constant        bit(1)                   initial unaligned dcl 2-11 set ref 404*
addr                                                   builtin function         dcl 96 ref 149 151 151 155 179 201 311
adnp                            000142 automatic       pointer                  dcl 4-17 set ref 294* 299 299 301
an                                     based           structure                level 1 dcl 4-40
area_size                              parameter       fixed bin(17,0)          dcl 187 ref 184 202
bound_seg                              based           char                     unaligned dcl 111 set ref 279* 279
bound_segl                      000100 automatic       fixed bin(21,0)          dcl 84 set ref 275* 279 279
bound_segp                      000102 automatic       pointer                  dcl 85 set ref 229* 250* 279 282
bx_$addname                     000224 external static fixed bin(17,0)          dcl 3-58 ref 292
bx_$adnp                        000210 external static pointer                  dcl 3-36 ref 294
bx_$bound_segname               000214 external static char(32)                 dcl 3-48 set ref 250* 253* 253* 266* 266* 394 397*
                                                                                  407*
bx_$bseg_acinfop                000220 external static pointer                  dcl 3-50 set ref 228* 250* 327 327* 338 338* 392*
bx_$bseg_bitcount               000222 external static fixed bin(24,0)          dcl 3-51 set ref 275 327*
bx_$bsegp                       000204 external static pointer                  dcl 3-30 set ref 282* 327* 413* 435*
bx_$caller                      000232 external static char(32)                 dcl 3-80 ref 368 444
bx_$debug                       000226 external static fixed bin(17,0)          dcl 3-59 ref 366
bx_$fatal_error                 000216 external static fixed bin(17,0)          dcl 3-49 set ref 168* 231 255* 398* 408*
bx_$freep                       000202 external static pointer                  dcl 3-27 set ref 155* 179* 201
bx_$sntp                        000212 external static pointer                  dcl 3-42 ref 310 311
bx_$temp                        000206 external static pointer                  dcl 3-31 set ref 174 175* 179 322 323* 325 343 344*
                                                                                  346 375*
bx_$temp_bsegp                  000230 external static pointer                  dcl 3-79 set ref 279 286* 287* 394* 404* 413
cleanup                         000126 stack reference condition                dcl 101 ref 243
code                            000107 automatic       fixed bin(35,0)          dcl 89 set ref 161* 165 167* 250* 251 253* 286* 324*
                                                                                  327* 345* 394* 395 397* 404* 405 407* 435* 438 440
                                                                                  442 444* 445
com_err_                        000142 constant        entry                    external dcl 49 ref 167 253 266 397 407
comp                     14            based           pointer                  level 2 in structure "seg" dcl 4-29 in procedure
                                                                                  "temp_mgr_" ref 312
comp                                   based           structure                level 1 dcl 5-16 in procedure "temp_mgr_"
created                         000104 automatic       bit(1)                   dcl 86 set ref 394* 402
divide                                                 builtin function         dcl 96 ref 275
entry                   326            based           structure                array level 2 dcl 4-21 set ref 311
errname                         000135 internal static char(16)                 dcl 80 set ref 167* 253* 266* 366* 368* 397* 407*
error_table_$namedup            000146 external static fixed bin(35,0)          dcl 52 ref 442
error_table_$rqover             000150 external static fixed bin(35,0)          dcl 54 set ref 266*
error_table_$segnamedup         000144 external static fixed bin(35,0)          dcl 50 ref 440
get_pdir_                       000152 constant        entry                    external dcl 55 ref 370
get_temp_segment_               000156 constant        entry                    external dcl 57 ref 161
get_wdir_                       000154 constant        entry                    external dcl 56 ref 369
hcs_$chname_seg                 000160 constant        entry                    external dcl 58 ref 435
i                               000106 automatic       fixed bin(17,0)          dcl 88 set ref 299* 301* 310* 311*
initiate_file_$create           000162 constant        entry                    external dcl 59 ref 394
insym                                  based           structure                level 1 dcl 6-12
insymentp                36            based           pointer                  level 2 dcl 5-16 ref 312
ip                              000114 automatic       pointer                  dcl 90 set ref 312* 313
is                                     based           structure                level 1 dcl 6-20
last_used                              parameter       pointer                  dcl 146 ref 123 149 155
limit                           000134 internal static fixed bin(18,0)          dcl 78 set ref 152 202 371* 373*
lng                      11            based           fixed bin(17,0)          level 2 dcl 4-29 ref 315
mask                                   constant        bit(36)                  initial dcl 79 ref 151
n_an                      1            based           fixed bin(17,0)          level 2 dcl 4-40 ref 299 299
n_names                 324            based           fixed bin(17,0)          level 2 dcl 4-21 ref 310
name                                   based           char(33)                 level 2 dcl 4-29 ref 315
nd_handler_                     000164 constant        entry                    external dcl 62 ref 444
next_temp_ptr                          based           pointer                  level 2 dcl 107 set ref 174* 323 344
null                                                   builtin function         dcl 96 ref 228 229 287 322 327 338 343 375 392
offset                          000105 automatic       fixed bin(18,0)          dcl 87 set ref 148* 149 150* 150 151 151 152 155
                                                                                  200* 201 202
offset_bits                            based           bit(36)                  dcl 116 set ref 151* 151
offset_overlay                         based           structure                level 1 dcl 113
p                               000110 automatic       pointer                  dcl 90 set ref 161* 174 175 322* 322* 323 324* 343*
                                                                                  343* 344 345*
pdir                            000010 internal static char(168)                initial unaligned dcl 76 set ref 370* 394*
ptr                                                    builtin function         dcl 96 ref 155
record_quota_overflow           000134 stack reference condition                dcl 102 ref 264 281
rel                                                    builtin function         dcl 96 ref 149 201
release_temp_segment_           000166 constant        entry                    external dcl 63 ref 324 345
relp                      0(18)        based           bit(18)                  level 2 packed unaligned dcl 113 set ref 149* 155
                                                                                  201*
retained                  3            based           bit(1)                   level 2 packed unaligned dcl 6-12 ref 313
rpte                                   based           structure                level 1 dcl 4-63
rtrim                                                  builtin function         dcl 96 ref 444 444
seg                                    based           structure                level 1 dcl 4-29
segname                         000116 automatic       char(32)                 dcl 91 set ref 301* 315* 435* 444
snt                                    based           structure                level 1 dcl 4-21
sp                              000112 automatic       pointer                  dcl 90 set ref 311* 312 315 315
storage                   2            based           bit                      level 2 dcl 107 set ref 179
substr                                                 builtin function         dcl 96 ref 315
syn                       2            based           char(32)                 array level 2 dcl 4-40 ref 301
sys_info$max_seg_size           000170 external static fixed bin(19,0)          dcl 65 ref 371 371 373
temp_seg                               based           structure                level 1 dcl 107
terminate_file_                 000172 constant        entry                    external dcl 67 ref 286 404
tssi_$clean_up_segment          000174 constant        entry                    external dcl 68 ref 338
tssi_$finish_segment            000200 constant        entry                    external dcl 71 ref 327
tssi_$get_segment               000176 constant        entry                    external dcl 70 ref 250
wdir                            000062 internal static char(168)                initial dcl 77 set ref 250* 369* 444 444

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 4-91
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 2-12
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 2-16
TERM_FILE_TERM                         internal static bit(3)                   initial unaligned dcl 2-14
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 2-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 2-15
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 4-90
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
bx_$addname_limit                      external static fixed bin(17,0)          dcl 3-24
bx_$area_begin                         external static fixed bin(18,0)          dcl 3-25
bx_$bdefp                              external static pointer                  dcl 3-38
bx_$bindmap_def                        external static pointer                  dcl 3-37
bx_$blnkp                              external static pointer                  dcl 3-40
bx_$bound_sep_stat                     external static fixed bin(17,0)          dcl 3-64
bx_$bproc                              external static fixed bin(17,0)          dcl 3-67
bx_$brief                              external static fixed bin(17,0)          dcl 3-60
bx_$bstatp                             external static pointer                  dcl 3-39
bx_$bsymp                              external static pointer                  dcl 3-41
bx_$ctp                                external static pointer                  dcl 3-26
bx_$curdeflng                          external static fixed bin(18,0)          dcl 3-69
bx_$d_lng                              external static fixed bin(18,0)          dcl 3-54
bx_$first_rptp                         external static pointer                  dcl 3-34
bx_$force_order                        external static fixed bin(17,0)          dcl 3-61
bx_$has_comb_stat                      external static fixed bin(17,0)          dcl 3-63
bx_$has_sep_stat                       external static fixed bin(17,0)          dcl 3-62
bx_$i_lng                              external static fixed bin(17,0)          dcl 3-55
bx_$inpp                               external static pointer                  dcl 3-29
bx_$isp                                external static pointer                  dcl 3-28
bx_$l_lng                              external static fixed bin(17,0)          dcl 3-56
bx_$last_rptp                          external static pointer                  dcl 3-35
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 3-72
bx_$maxlinklng                         external static fixed bin(17,0)          dcl 3-71
bx_$n_firstrefs                        external static fixed bin(17,0)          dcl 3-47
bx_$n_lng                              external static fixed bin(17,0)          dcl 3-76
bx_$ncomp                              external static fixed bin(17,0)          dcl 3-74
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 3-78
bx_$nsymdefs                           external static fixed bin(17,0)          dcl 3-77
bx_$o_lng                              external static fixed bin(19,0)          dcl 3-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 3-22
bx_$odnp                               external static pointer                  dcl 3-33
bx_$optp                               external static pointer                  dcl 3-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 3-65
bx_$s_lng                              external static fixed bin(18,0)          dcl 3-57
bx_$size                               external static fixed bin(17,0)          dcl 3-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 3-21
bx_$standard                           external static fixed bin(17,0)          dcl 3-66
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 3-23
bx_$strmp                              external static pointer                  dcl 3-46
bx_$t_lng                              external static fixed bin(18,0)          dcl 3-53
bx_$tdefp                              external static pointer                  dcl 3-43
bx_$textlng                            external static fixed bin(18,0)          dcl 3-68
bx_$tintlng                            external static fixed bin(17,0)          dcl 3-70
bx_$tintp                              external static pointer                  dcl 3-44
bx_$tlinklng                           external static fixed bin(17,0)          dcl 3-73
bx_$tlinkp                             external static pointer                  dcl 3-45
bx_$v_lng                              external static fixed bin(17,0)          dcl 3-75
bx_$vers_name                          external static char(168)                dcl 3-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 3-19
comp_tbl                               based           pointer                  array dcl 5-12
ctep                                   automatic       pointer                  dcl 5-10
ctp                                    automatic       pointer                  dcl 5-10
lrt                                    based           structure                level 1 dcl 4-84
lrtp                                   automatic       pointer                  dcl 4-17
od                                     based           structure                level 1 dcl 4-48
odnp                                   automatic       pointer                  dcl 4-17
rpt                                    based           structure                level 1 dcl 4-57
rptep                                  automatic       pointer                  dcl 4-17
rptp                                   automatic       pointer                  dcl 4-17
sntp                                   automatic       pointer                  dcl 4-17
strm                                   based           structure                level 1 dcl 4-73
strmp                                  automatic       pointer                  dcl 4-17
terminate_file_switches                based           structure                level 1 packed unaligned dcl 2-4

NAMES DECLARED BY EXPLICIT CONTEXT.
Addname                         001330 constant        entry                    internal dcl 420 ref 302 316
TRY_ADDNAME                     001331 constant        label                    dcl 435 ref 445
allocate                        000270 constant        entry                    external dcl 184
close_file_cleanup              001242 constant        entry                    internal dcl 335 ref 234 245 256 268
close_file_return               000752 constant        label                    dcl 330 ref 269
close_files                     000313 constant        entry                    external dcl 208
create_temp                     000175 constant        label                    dcl 161 ref 205 376
init                            000754 constant        entry                    external dcl 352
make_object                     001032 constant        entry                    external dcl 378
reserve                         000145 constant        entry                    external dcl 123
temp_mgr_                       000134 constant        entry                    external dcl 43

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2054        2310    1444        2064
Length      2702    1444       234         356     407         132

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
temp_mgr_                           250 external procedure  is an external procedure.  
on unit on line 243                  64 on unit               
on unit on line 264                 100 on unit               
close_file_cleanup                   84 internal procedure  is called by several nonquick procedures.  
Addname                                 internal procedure  shares stack frame of external procedure temp_mgr_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 pdir                        temp_mgr_
000062 wdir                        temp_mgr_
000134 limit                       temp_mgr_
000135 errname                     temp_mgr_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
temp_mgr_                000100 bound_segl                  temp_mgr_
                         000102 bound_segp                  temp_mgr_
                         000104 created                     temp_mgr_
                         000105 offset                      temp_mgr_
                         000106 i                           temp_mgr_
                         000107 code                        temp_mgr_
                         000110 p                           temp_mgr_
                         000112 sp                          temp_mgr_
                         000114 ip                          temp_mgr_
                         000116 segname                     temp_mgr_
                         000142 adnp                        temp_mgr_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      get_pdir_                     get_temp_segment_             get_wdir_
hcs_$chname_seg               initiate_file_$create         nd_handler_                   release_temp_segment_
terminate_file_               tssi_$clean_up_segment        tssi_$finish_segment          tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$addname                   bx_$adnp                      bx_$bound_segname             bx_$bseg_acinfop
bx_$bseg_bitcount             bx_$bsegp                     bx_$caller                    bx_$debug
bx_$fatal_error               bx_$freep                     bx_$sntp                      bx_$temp
bx_$temp_bsegp                error_table_$namedup          error_table_$rqover           error_table_$segnamedup
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000133       123 000141       148 000152       149 000153       150 000161       151 000163       152 000165
    155 000170       156 000174       161 000175       165 000220       167 000222       168 000246       169 000251
    174 000252       175 000256       179 000260       181 000264       184 000265       200 000275       201 000276
    202 000304       205 000311       208 000312       228 000320       229 000323       231 000324       234 000326
    236 000332       243 000333       245 000347       246 000354       250 000355       251 000405       253 000407
    255 000441       256 000444       257 000450       264 000451       266 000465       268 000516       269 000523
    275 000526       279 000532       281 000540       282 000541       286 000542       287 000567       292 000572
    294 000575       299 000600       301 000611       302 000617       303 000620       310 000623       311 000635
    312 000643       313 000646       315 000652       316 000657       318 000660       322 000662       323 000672
    324 000676       325 000720       327 000725       330 000752       352 000753       366 000761       368 000771
    369 000775       370 001007       371 001015       373 001024       375 001026       376 001030       378 001031
    392 001037       394 001042       395 001107       397 001111       398 001141       399 001144       402 001145
    404 001150       405 001176       407 001200       408 001230       409 001233       413 001234       415 001240
    335 001241       338 001247       343 001261       344 001273       345 001277       346 001321       348 001327
    420 001330       435 001331       438 001356       440 001360       442 001364       444 001366       445 001440
    451 001443


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
