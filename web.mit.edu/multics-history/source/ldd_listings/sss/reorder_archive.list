	COMPILATION LISTING OF SEGMENT reorder_archive
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/12/88  1246.2 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-10-07,TLNguyen), approve(87-10-07,MCR7773),
       17*     audit(87-12-03,GWMay), install(88-01-12,MR12.2-1012):
       18*     - Make reorder_archive.pl1 reference error_table_$rqover.
       19*     - Changed all calls to com_err_ that print the pathname of an
       20*       archive to call pathname_ to build the pathname.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 reorder_archive: ra: proc options (variable);
       25 
       26 /*
       27*   modified by E Stone Jan 1974 to call new version of update_handler_
       28*   Modified to call newer update_handler_ 03/29/79 by Steve Herbst
       29*   Bugs fixed 04/15/80 S. Herbst */
       30 /* Fixed usage message and bug in argument processing 10/29/82 S. Herbst */
       31 
       32 /*  declarations  */
       33 /* ---------------- */
       34 
       35 dcl  whoami char (15) static options (constant) init ("reorder_archive"); /*  for printing error messages  */
       36 
       37 /*  pointers  */
       38 
       39 dcl  arg_ptr ptr,					/*  pointer to current argument  */
       40      input_ptr ptr,					/*  pointer to archive to be reordered  */
       41      temp_ptr ptr,
       42      p1 ptr;					/*  sorting pointer  */
       43 
       44 /*  for argument fetching  */
       45 
       46 dcl  arg_len fixed bin (21),				/*  length of current argument  */
       47      arg char (arg_len)based (arg_ptr),			/*  argument  */
       48      arg_index fixed bin,				/*  argument fetch index  */
       49      arg_given bit (1),				/*  ON if good arg has been encountered  */
       50 
       51     (code, udh_code) fixed bin (35);			/*  error code  */
       52 
       53 /*  path and file names  */
       54 
       55 dcl  archive_dir char (168),				/*  directory of archive to be reordered  */
       56      archive_name char (32),				/*  file name of archive to be reordered  */
       57      comment char (35),				/* For fs_move comment */
       58      list_name char (32);				/*  file name of driving list  */
       59 
       60 /*  for examining driving list  */
       61 
       62 dcl  ioname1 char (32),
       63      iox_$user_input ptr external,
       64      attached_sw bit (1),				/* ON if driving file has been attached */
       65      file_input_sw bit (1),				/* ON to read from file */
       66      iocb_ptr ptr,					/* where to read component names */
       67      num_chars_read fixed bin (21),			/*  to read list  */
       68      next_new_line char (128) aligned,			/*  line with leading and trailing blanks  */
       69      new_line char (32),				/*  new line cleaned up  */
       70     (error_table_$badopt,				/* unrecognized option */
       71      error_table_$end_of_info,
       72      error_table_$moderr,
       73      error_table_$rqover) fixed bin (35) external;
       74 
       75 
       76 /*  for examining archive file  */
       77 
       78 dcl  total_words fixed bin (19),			/*  number of words in archive file  */
       79      sub_words fixed bin (18),			/*  bitcount of subfile converted  */
       80      bitcnt fixed bin (24),				/*  bitcount  */
       81 
       82      1 arc_head based (p1) aligned,			/*  archive header mask  */
       83      2 unused char (12),
       84      2 name char (32),
       85      2 unused2 char (40),
       86      2 bitcnt char (8),
       87      2 unused3 char(8);
       88 
       89 dcl  move (sub_words) fixed bin (35) based (p1);		/*  for moving subfiles  */
       90 
       91 /*  for error on attempting to copy temporary  */
       92 
       93 dcl  fatal_err_sw bit (1),				/*  warning flag  */
       94      temp_name char (32) init ("ra_temp_.archive");	/*  name of temporary in pdir  */
       95 
       96 /* for forcing access */
       97 
       98 dcl  access_switches bit (36),			/* returned by update_handler_
       99*						   BIT saying access was added,
      100*						   BIT saying there already was such an ACL term. */
      101      old_mode bit (36);				/* previous mode if any */
      102 
      103 /*  arrays  */
      104 
      105 dcl (ptr_array ptr,					/*  pointers to old archive subfiles  */
      106      lngth_array fixed bin (18),			/*  lengths of subfiles  */
      107      name_array char (32)aligned,			/*  names in old archive in order  */
      108      used_array fixed bin,				/*  flags, show whether subfile was used  */
      109 
      110      order_array fixed bin) (0:999);			/*  index into other arrays of new order  */
      111 
      112 /*  indices  */
      113 
      114 dcl (i, j, k, l) fixed bin (18),
      115      retry fixed bin;
      116 
      117 /*  external entry declarations  */
      118 /* ------------------------------- */
      119 
      120 dcl (com_err_, com_err_$suppress_name, ioa_) entry options (variable),
      121      cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      122      cv_dec_ entry (char (*) aligned) returns (fixed bin (35) aligned),
      123      expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35)),
      124      get_temp_segment_ entry (char (*), ptr, fixed bin (35)),
      125      hcs_$chname_seg entry (ptr, char (*), char (*), fixed bin (35)),
      126      hcs_$fs_move_seg entry (ptr, ptr, fixed bin, fixed bin (35)),
      127      hcs_$initiate_count entry (char (*), char (*), char (*),
      128      fixed bin (24), fixed bin (2), ptr, fixed bin (35)),
      129      hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
      130      hcs_$terminate_noname entry (ptr, fixed bin (35)),
      131      hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
      132      iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35)),
      133      iox_$close entry (ptr, fixed bin (35)),
      134      iox_$detach_iocb entry (ptr, fixed bin (35)),
      135      iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
      136      iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
      137      pathname_ entry (char (*), char (*)) returns (char (168)),
      138      release_temp_segment_ entry (char (*), ptr, fixed bin (35)),
      139      suffixed_name_$new_suffix entry (char (*), char (*), char (*), char (32), fixed bin (35)),
      140      update_handler_ entry (char (*), char (*), char (*), bit (36), bit (36), fixed bin (35)),
      141      update_handler_$reprotect entry (char (*), char (*), bit (36), bit (36), fixed bin (35));
      142 
      143 dcl  cleanup condition;
      144 
      145 dcl (addr, addrel, bin, divide, hbound, length, ltrim, null, rel, rtrim, size, substr) builtin;
      146 
      147 /* 
      148*   */
      149 
      150 	attached_sw = "0"b;
      151 	temp_ptr = null;
      152 
      153 	on cleanup call clean_up;
      154 
      155 	arg_given, fatal_err_sw, file_input_sw = "0"b;
      156 	arg_index = 0;
      157 
      158 /*  processing  */
      159 /* -------------- */
      160 
      161 /*  create a temporary segment in the process directory  */
      162 
      163 	call get_temp_segment_ (whoami, temp_ptr, code);
      164 	if code ^= 0 then do;
      165 	     call com_err_ (code, whoami, "Obtaining temp segment.");
      166 	     return;
      167 	end;
      168 
      169 /* Fetch arguments */
      170 
      171 FETCH_NEXT_ARG:					/*  get the next argument  */
      172 
      173 	arg_index = arg_index + 1;			/*  increment the arguments fetched index  */
      174 
      175 	call cu_$arg_ptr (arg_index, arg_ptr, arg_len, code); /*  fetch the next argument  */
      176 	if code ^= 0 then go to FINI;
      177 	if arg_len = 0 then go to FINI;
      178 
      179 	if substr (arg, 1, 1) = "-" then do;
      180 
      181 	     if arg = "-file_input" | arg = "-fi" then do;
      182 		arg_given = "0"b;
      183 		file_input_sw = "1"b;
      184 		ioname1 = "info";			/*  for calls to attach and read  */
      185 		go to FETCH_NEXT_ARG;
      186 	     end;
      187 
      188 	     else if arg = "-console_input" | arg = "-ci" then do;
      189 		arg_given = "1"b;
      190 		file_input_sw = "0"b;
      191 		go to FETCH_NEXT_ARG;
      192 	     end;
      193 
      194 	     else do;				/* invalid option specified  */
      195 		fatal_err_sw = "1"b;		/*  get out  */
      196 		call com_err_ (error_table_$badopt, whoami, arg);
      197 		go to DONE;
      198 	     end;
      199 	end;
      200 
      201 	arg_given = "1"b;				/*  good argument  */
      202 
      203 /*  expand the argument, create list and archive names  */
      204 
      205 	call expand_pathname_$add_suffix (arg, "archive", archive_dir, archive_name, code);
      206 	if code ^= 0 then do;
      207 	     call com_err_ (code, whoami, arg);
      208 	     go to FETCH_NEXT_ARG;
      209 	end;
      210 
      211 	call hcs_$initiate_count (archive_dir, archive_name, "", bitcnt, 0, input_ptr, code);
      212 	if input_ptr = null then do;
      213 	     call com_err_ (code, whoami, "^a", pathname_ (archive_dir, archive_name));
      214 	     go to FETCH_NEXT_ARG;
      215 	end;
      216 
      217 	if ^file_input_sw then iocb_ptr = iox_$user_input;
      218 	else do;
      219 
      220 	     call suffixed_name_$new_suffix (archive_name, "archive", "order", list_name, code);
      221 	     call iox_$attach_name (ioname1, iocb_ptr, "vfile_ " || list_name, null, code);
      222 	     if code ^= 0 then do;
      223 IO_ERROR:		call com_err_ (code, whoami, "^a", list_name);
      224 		go to terminate_archive;
      225 	     end;
      226 
      227 	     attached_sw = "1"b;
      228 
      229 	     call iox_$open (iocb_ptr, 1, "0"b, code);
      230 	     if code ^= 0 then go to IO_ERROR;
      231 	end;
      232 
      233 /* now iocb_ptr is set, regardless of input source (tty or file) */
      234 
      235 	total_words = divide (bitcnt+35, 36, 19, 0);	/*  number of words in archive file  */
      236 
      237 /*  examine the archive, fill name, pointer, and length arrays  */
      238 
      239 	used_array (*) = 0;
      240 	p1 = input_ptr;				/*  set scan ptr to beginning of archive  */
      241 
      242 	do i = 0 to hbound (order_array, 1) while (bin (rel (p1), 18) < total_words);
      243 	     ptr_array (i) = p1;			/*  put subfile pointer in slot  */
      244 	     sub_words = divide (cv_dec_ (p1 -> arc_head.bitcnt)+35, 36, 18, 0)+size (arc_head); /*  calculate subfile word count  */
      245 	     lngth_array (i) = sub_words;		/*  put word count in subfile slot  */
      246 	     name_array (i) = p1 -> arc_head.name;	/*  put name in subfile slot  */
      247 	     p1 = addrel (p1, sub_words);		/*  step the scan pointer  */
      248 	end;
      249 
      250 	if i > hbound (order_array, 1) then do;		/*  too many subfiles in archive  */
      251 	     call com_err_ (0, whoami, "Too many entries (> ^d) in archive ^a", hbound (order_array, 1) + 1,
      252 		pathname_ (archive_dir, archive_name));
      253 	     go to ERR3;
      254 	end;
      255 
      256 /* read new order */
      257 
      258 	if ^file_input_sw then call ioa_ ("Input for ^a:", archive_name);
      259 
      260 	j = -1;					/*  initialize the order array index  */
      261 
      262 READ_NEXT_NAME:					/*  get a name from the list  */
      263 
      264 	call iox_$get_line (iocb_ptr, addr (next_new_line), length (next_new_line), num_chars_read, code);
      265 	if code ^= 0 then
      266 	     if code = error_table_$end_of_info then go to MAKE_NEW_ARCHIVE;
      267 	     else do;
      268 		call com_err_ (code, whoami, list_name);
      269 		go to ERR3;
      270 	     end;
      271 
      272 /*  strip off any blanks  */
      273 
      274 	if num_chars_read <= 1 then go to READ_NEXT_NAME; /*  test for carriage return  */
      275 	new_line = rtrim (ltrim (substr (next_new_line, 1, num_chars_read - 1)));
      276 	if new_line = "" then go to READ_NEXT_NAME;
      277 	if new_line = "." then go to MAKE_NEW_ARCHIVE;	/*  test for end of console input  */
      278 	if ^file_input_sw then
      279 	     if new_line = ".*" then do;		/* user wants "finished" signal */
      280 		call ioa_ ("*");
      281 		go to READ_NEXT_NAME;
      282 	     end;
      283 	     else if new_line = ".q" then do;		/* user has decided not to reorder */
      284 		fatal_err_sw = "1"b;
      285 		go to ERR3;
      286 	     end;
      287 
      288 /*  fill in the order and "used" arrays  */
      289 
      290 	/* Note: j is initialized to -1 just before the beginning of this loop at READ_NEXT_NAME. */
      291 
      292 	do k = 0 to i - 1;
      293 	     if name_array (k) = new_line then do;	/*  find name in name array  */
      294 		if used_array (k) = 1 then do;	/*  name duplication; error  */
      295 		     call com_err_ (0, whoami, "^a duplicated in input for ^a",
      296 			new_line, pathname_ (archive_dir, archive_name));
      297 		     if ^file_input_sw then go to READ_NEXT_NAME;
      298 		     go to ERR3;
      299 		end;
      300 		j = j + 1;			/*  step the order array index  */
      301 		order_array (j) = k;		/*  put offset to name in slot  */
      302 		used_array (k) = 1;			/*  mark the name as used  */
      303 		go to READ_NEXT_NAME;		/*  read another name  */
      304 	     end;
      305 	end;
      306 
      307 	call com_err_ (0, whoami, "^a not found in ^a", new_line, pathname_ (archive_dir, archive_name));
      308 	if ^file_input_sw then go to READ_NEXT_NAME;
      309 	go to ERR3;
      310 
      311 /* All names have been read */
      312 
      313 MAKE_NEW_ARCHIVE:					/*  make the new archive  */
      314 
      315 /*  copy the specified subfiles  */
      316 
      317 	p1 = temp_ptr;				/*  set scan pointer to output segment  */
      318 	do k = 0 to j;				/*  for specified names  */
      319 	     l = order_array (k);			/*  get index to name, pointer, and length  */
      320 	     sub_words = lngth_array (l);		/*  get length of subfile  */
      321 	     p1 -> move = ptr_array (l) -> move;	/*  copy the subfile  */
      322 	     p1 = addrel (p1, sub_words);		/*  step the subfile pointer  */
      323 	end;
      324 
      325 /*  copy the unspecified subfiles  */
      326 
      327 	if j < i - 1 then do k = 0 to i - 1;
      328 	     if used_array (k) = 0 then do;
      329 		sub_words = lngth_array (k);		/*  get length of the subfile  */
      330 		p1 -> move = ptr_array (k) -> move;	/*  copy the subfile if not yet done  */
      331 		p1 = addrel (p1, sub_words);		/*  step the subfile pointer  */
      332 	     end;
      333 	end;
      334 
      335 /* Move the temporary back into the archive file. */
      336 
      337 	retry = 0;				/* Clear counter */
      338 
      339 try_move:
      340 	call hcs_$fs_move_seg (temp_ptr, input_ptr, 1b, code); /* Move the temporary after truncating the original */
      341 	if code ^= 0
      342 	then do;
      343 
      344 	     if code = error_table_$moderr		/* Couldn't move because of bad mode in target */
      345 	     then if retry = 0			/* Have we been here before? */
      346 		then do;				/* OK, try to change mode */
      347 
      348 		     call update_handler_ (archive_dir, archive_name, whoami, access_switches, old_mode, udh_code);
      349 
      350 		     if udh_code = 0		/* Successful? */
      351 		     then do;
      352 
      353 			retry = retry + 1;		/* Update counter */
      354 			go to try_move;		/* See if it works this time */
      355 
      356 		     end;
      357 
      358 		     else if udh_code = 1		/* He answered "no" */
      359 		     then code = 0;			/* Suppress part of diagnostic */
      360 		     else code = udh_code;		/* Something else, tell him */
      361 
      362 		end;
      363 
      364 		else comment = "";			/* fall out of access error */
      365 
      366 	     else if code = error_table_$rqover then comment = "";
      367 	     else comment = "Original may have been truncated.  ";
      368 
      369 	     call hcs_$set_bc_seg (temp_ptr, bitcnt, udh_code); /* Make temporary copiable */
      370 
      371 	     call hcs_$chname_seg (temp_ptr, temp_name, archive_name, udh_code);
      372 	     if udh_code = 0 then temp_name = archive_name;
      373 
      374 	     temp_ptr = null;			/* Re-call makeseg next time. */
      375 
      376 	     call com_err_ (code, whoami, "^a not updated.^/^a ^a^a", pathname_ (archive_dir, archive_name),
      377 		comment, "Reordered version temporarily preserved in [pd]>", temp_name);
      378 
      379 	     go to DONE;
      380 
      381 	end;
      382 
      383 /* Reset the bit-count on the branch (really shouldn't have changed) */
      384 
      385 	call hcs_$set_bc_seg (input_ptr, bitcnt, code);
      386 
      387 	if code ^= 0
      388 	then call com_err_ (code, whoami, "^a", pathname_ (archive_dir, archive_name));
      389 	code = 0;
      390 
      391 	if retry ^= 0
      392 	then call update_handler_$reprotect (archive_dir, archive_name, access_switches, old_mode, code);
      393 
      394 	if code ^= 0 then call com_err_ (code, whoami, "^a", pathname_ (archive_dir, archive_name));
      395 
      396 terminate_archive:
      397 	call hcs_$terminate_noname (input_ptr, code);	/*  terminate the old archive */
      398 	if code ^= 0 then do;
      399 	     call com_err_ (code, whoami, "Terminating ^a", pathname_ (archive_dir, archive_name));
      400 	     code = 0;
      401 	end;
      402 
      403 	if file_input_sw & attached_sw then do;		/* close input file */
      404 	     call iox_$close (iocb_ptr, code);
      405 	     call iox_$detach_iocb (iocb_ptr, code);
      406 	end;
      407 
      408 	if ^fatal_err_sw then call hcs_$truncate_seg (temp_ptr, 0, code); /*  truncate the temporary  */
      409 	if code ^= 0 then do;
      410 	     temp_ptr = null;			/*  so can't be used again  */
      411 	     call com_err_ (code, whoami, "Truncating [pd]>^a", temp_name);
      412 	     go to DONE;
      413 	end;
      414 	if ^fatal_err_sw then go to FETCH_NEXT_ARG;
      415 
      416 FINI:
      417 	if ^arg_given then call com_err_$suppress_name
      418 	     (0, whoami, "Usage:  reorder_archive {-control_arg} path1 {... {-control_arg} pathN}");
      419 
      420 DONE:	call clean_up;
      421 	return;
      422 
      423 
      424 ERR3:	call com_err_ (0, whoami, "^a not reordered.", pathname_ (archive_dir, archive_name));
      425 	go to terminate_archive;
      426 
      427 
      428 clean_up:	proc;
      429 
      430 dcl  code fixed bin (35);
      431 
      432 	     if temp_ptr ^= null then call release_temp_segment_ (whoami, temp_ptr, code);
      433 	     if attached_sw then do;
      434 		call iox_$close (iocb_ptr, code);
      435 		call iox_$detach_iocb (iocb_ptr, code);
      436 	     end;
      437 
      438 	end clean_up;
      439 
      440 
      441      end reorder_archive;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/12/88  1245.0  reorder_archive.pl1               >spec>install>1012>reorder_archive.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
access_switches                 000321 automatic       bit(36)                  unaligned dcl 98 set ref 348* 391*
addr                                                   builtin function         dcl 145 ref 262 262
addrel                                                 builtin function         dcl 145 ref 247 322 331
arc_head                               based           structure                level 1 dcl 78 set ref 244
archive_dir                     000115 automatic       char(168)                unaligned dcl 55 set ref 205* 211* 213* 213* 251*
                                                                                  251* 295* 295* 307* 307* 348* 376* 376* 387* 387*
                                                                                  391* 394* 394* 399* 399* 424* 424*
archive_name                    000167 automatic       char(32)                 unaligned dcl 55 set ref 205* 211* 213* 213* 220*
                                                                                  251* 251* 258* 295* 295* 307* 307* 348* 371* 372
                                                                                  376* 376* 387* 387* 391* 394* 394* 399* 399* 424*
                                                                                  424*
arg                                    based           char                     unaligned dcl 46 set ref 179 181 181 188 188 196*
                                                                                  205* 207*
arg_given                       000112 automatic       bit(1)                   unaligned dcl 46 set ref 155* 182* 189* 201* 416
arg_index                       000111 automatic       fixed bin(17,0)          dcl 46 set ref 156* 171* 171 175*
arg_len                         000110 automatic       fixed bin(21,0)          dcl 46 set ref 175* 177 179 181 181 188 188 196 196
                                                                                  205 205 207 207
arg_ptr                         000100 automatic       pointer                  dcl 39 set ref 175* 179 181 181 188 188 196 205 207
attached_sw                     000230 automatic       bit(1)                   unaligned dcl 62 set ref 150* 227* 403 433
bin                                                    builtin function         dcl 145 ref 242
bitcnt                   25            based           char(8)                  level 2 in structure "arc_head" dcl 78 in procedure
                                                                                  "ra" set ref 244*
bitcnt                          000307 automatic       fixed bin(24,0)          dcl 78 in procedure "ra" set ref 211* 235 369* 385*
cleanup                         031642 stack reference condition                dcl 143 ref 153
code                            000113 automatic       fixed bin(35,0)          dcl 46 in procedure "ra" set ref 163* 164 165* 175*
                                                                                  176 205* 206 207* 211* 213* 220* 221* 222 223*
                                                                                  229* 230 262* 265 265 268* 339* 341 344 358* 360*
                                                                                  366 376* 385* 387 387* 389* 391* 394 394* 396* 398
                                                                                  399* 400* 404* 405* 408* 409 411*
code                            000100 automatic       fixed bin(35,0)          dcl 430 in procedure "clean_up" set ref 432* 434*
                                                                                  435*
com_err_                        000022 constant        entry                    external dcl 120 ref 165 196 207 213 223 251 268 295
                                                                                  307 376 387 394 399 411 424
com_err_$suppress_name          000024 constant        entry                    external dcl 120 ref 416
comment                         000177 automatic       char(35)                 unaligned dcl 55 set ref 364* 366* 367* 376*
cu_$arg_ptr                     000030 constant        entry                    external dcl 120 ref 175
cv_dec_                         000032 constant        entry                    external dcl 120 ref 244
divide                                                 builtin function         dcl 145 ref 235 244
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 62 set ref 196*
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 62 ref 265
error_table_$moderr             000016 external static fixed bin(35,0)          dcl 62 ref 344
error_table_$rqover             000020 external static fixed bin(35,0)          dcl 62 ref 366
expand_pathname_$add_suffix     000034 constant        entry                    external dcl 120 ref 205
fatal_err_sw                    000310 automatic       bit(1)                   unaligned dcl 93 set ref 155* 195* 284* 408 414
file_input_sw                   000231 automatic       bit(1)                   unaligned dcl 62 set ref 155* 183* 190* 217 258 278
                                                                                  297 308 403
get_temp_segment_               000036 constant        entry                    external dcl 120 ref 163
hbound                                                 builtin function         dcl 145 ref 242 250 251
hcs_$chname_seg                 000040 constant        entry                    external dcl 120 ref 371
hcs_$fs_move_seg                000042 constant        entry                    external dcl 120 ref 339
hcs_$initiate_count             000044 constant        entry                    external dcl 120 ref 211
hcs_$set_bc_seg                 000046 constant        entry                    external dcl 120 ref 369 385
hcs_$terminate_noname           000050 constant        entry                    external dcl 120 ref 396
hcs_$truncate_seg               000052 constant        entry                    external dcl 120 ref 408
i                               031634 automatic       fixed bin(18,0)          dcl 114 set ref 242* 243 245 246* 250 292 327 327
input_ptr                       000102 automatic       pointer                  dcl 39 set ref 211* 212 240 339* 385* 396*
ioa_                            000026 constant        entry                    external dcl 120 ref 258 280
iocb_ptr                        000232 automatic       pointer                  dcl 62 set ref 217* 221* 229* 262* 404* 405* 434*
                                                                                  435*
ioname1                         000220 automatic       char(32)                 unaligned dcl 62 set ref 184* 221*
iox_$attach_name                000054 constant        entry                    external dcl 120 ref 221
iox_$close                      000056 constant        entry                    external dcl 120 ref 404 434
iox_$detach_iocb                000060 constant        entry                    external dcl 120 ref 405 435
iox_$get_line                   000062 constant        entry                    external dcl 120 ref 262
iox_$open                       000064 constant        entry                    external dcl 120 ref 229
iox_$user_input                 000010 external static pointer                  dcl 62 ref 217
j                               031635 automatic       fixed bin(18,0)          dcl 114 set ref 260* 300* 300 301 318 327
k                               031636 automatic       fixed bin(18,0)          dcl 114 set ref 292* 293 294 301 302* 318* 319* 327*
                                                                                  328 329 330*
l                               031637 automatic       fixed bin(18,0)          dcl 114 set ref 319* 320 321
length                                                 builtin function         dcl 145 ref 262 262
list_name                       000210 automatic       char(32)                 unaligned dcl 55 set ref 220* 221 223* 268*
lngth_array                     004244 automatic       fixed bin(18,0)          array dcl 105 set ref 245* 320 329
ltrim                                                  builtin function         dcl 145 ref 275
move                                   based           fixed bin(35,0)          array dcl 89 set ref 321* 321 330* 330
name                      3            based           char(32)                 level 2 dcl 78 ref 246
name_array                      006214 automatic       char(32)                 array dcl 105 set ref 246* 293
new_line                        000275 automatic       char(32)                 unaligned dcl 62 set ref 275* 276 277 278 283 293
                                                                                  295* 307*
next_new_line                   000235 automatic       char(128)                dcl 62 set ref 262 262 262 262 275
null                                                   builtin function         dcl 145 ref 151 212 221 221 374 410 432
num_chars_read                  000234 automatic       fixed bin(21,0)          dcl 62 set ref 262* 274 275
old_mode                        000322 automatic       bit(36)                  unaligned dcl 98 set ref 348* 391*
order_array                     027664 automatic       fixed bin(17,0)          array dcl 105 set ref 242 250 251 301* 319
p1                              000106 automatic       pointer                  dcl 39 set ref 240* 242 243 244 244 246 247* 247
                                                                                  313* 321 322* 322 330 331* 331
pathname_                       000066 constant        entry                    external dcl 120 ref 213 213 251 251 295 295 307 307
                                                                                  376 376 387 387 394 394 399 399 424 424
ptr_array                       000324 automatic       pointer                  array dcl 105 set ref 243* 321 330
rel                                                    builtin function         dcl 145 ref 242
release_temp_segment_           000070 constant        entry                    external dcl 120 ref 432
retry                           031640 automatic       fixed bin(17,0)          dcl 114 set ref 337* 344 353* 353 391
rtrim                                                  builtin function         dcl 145 ref 275
size                                                   builtin function         dcl 145 ref 244
sub_words                       000306 automatic       fixed bin(18,0)          dcl 78 set ref 244* 245 247 320* 321 322 329* 330
                                                                                  331
substr                                                 builtin function         dcl 145 ref 179 275
suffixed_name_$new_suffix       000072 constant        entry                    external dcl 120 ref 220
temp_name                       000311 automatic       char(32)                 initial unaligned dcl 93 set ref 93* 371* 372* 376*
                                                                                  411*
temp_ptr                        000104 automatic       pointer                  dcl 39 set ref 151* 163* 313 339* 369* 371* 374*
                                                                                  408* 410* 432 432*
total_words                     000305 automatic       fixed bin(19,0)          dcl 78 set ref 235* 242
udh_code                        000114 automatic       fixed bin(35,0)          dcl 46 set ref 348* 350 358 360 369* 371* 372
update_handler_                 000074 constant        entry                    external dcl 120 ref 348
update_handler_$reprotect       000076 constant        entry                    external dcl 120 ref 391
used_array                      025714 automatic       fixed bin(17,0)          array dcl 105 set ref 239* 294 302* 328
whoami                          000000 constant        char(15)                 initial unaligned dcl 35 set ref 163* 165* 196* 207*
                                                                                  213* 223* 251* 268* 295* 307* 348* 376* 387* 394*
                                                                                  399* 411* 416* 424* 432*

NAMES DECLARED BY EXPLICIT CONTEXT.
DONE                            002607 constant        label                    dcl 420 ref 197 379 412
ERR3                            002614 constant        label                    dcl 424 ref 253 269 285 298 309
FETCH_NEXT_ARG                  000360 constant        label                    dcl 171 ref 185 191 208 214 414
FINI                            002560 constant        label                    dcl 416 ref 176 177
IO_ERROR                        001001 constant        label                    dcl 223 ref 230
MAKE_NEW_ARCHIVE                001626 constant        label                    dcl 313 ref 265 277
READ_NEXT_NAME                  001266 constant        label                    dcl 262 ref 274 276 281 297 303 308
clean_up                        002667 constant        entry                    internal dcl 428 ref 153 420
ra                              000236 constant        entry                    external dcl 24
reorder_archive                 000246 constant        entry                    external dcl 24
terminate_archive               002363 constant        label                    dcl 396 ref 224 425
try_move                        001722 constant        label                    dcl 339 ref 354

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3320        3420    2755        3330
Length      3660    2755       100         223     342           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ra                                13358 external procedure  is an external procedure.  
on unit on line 153                  64 on unit               
clean_up                             80 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 code                        clean_up
ra                       000100 arg_ptr                     ra
                         000102 input_ptr                   ra
                         000104 temp_ptr                    ra
                         000106 p1                          ra
                         000110 arg_len                     ra
                         000111 arg_index                   ra
                         000112 arg_given                   ra
                         000113 code                        ra
                         000114 udh_code                    ra
                         000115 archive_dir                 ra
                         000167 archive_name                ra
                         000177 comment                     ra
                         000210 list_name                   ra
                         000220 ioname1                     ra
                         000230 attached_sw                 ra
                         000231 file_input_sw               ra
                         000232 iocb_ptr                    ra
                         000234 num_chars_read              ra
                         000235 next_new_line               ra
                         000275 new_line                    ra
                         000305 total_words                 ra
                         000306 sub_words                   ra
                         000307 bitcnt                      ra
                         000310 fatal_err_sw                ra
                         000311 temp_name                   ra
                         000321 access_switches             ra
                         000322 old_mode                    ra
                         000324 ptr_array                   ra
                         004244 lngth_array                 ra
                         006214 name_array                  ra
                         025714 used_array                  ra
                         027664 order_array                 ra
                         031634 i                           ra
                         031635 j                           ra
                         031636 k                           ra
                         031637 l                           ra
                         031640 retry                       ra

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        cu_$arg_ptr                   cv_dec_
expand_pathname_$add_suffix   get_temp_segment_             hcs_$chname_seg               hcs_$fs_move_seg
hcs_$initiate_count           hcs_$set_bc_seg               hcs_$terminate_noname         hcs_$truncate_seg
ioa_                          iox_$attach_name              iox_$close                    iox_$detach_iocb
iox_$get_line                 iox_$open                     pathname_                     release_temp_segment_
suffixed_name_$new_suffix     update_handler_               update_handler_$reprotect

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$end_of_info      error_table_$moderr           error_table_$rqover
iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     93 000230        24 000235       150 000254       151 000255       153 000257       155 000301       156 000304
    163 000305       164 000326       165 000330       166 000357       171 000360       175 000361       176 000376
    177 000400       179 000402       181 000407       182 000417       183 000420       184 000422       185 000425
    188 000426       189 000436       190 000440       191 000441       195 000442       196 000444       197 000467
    201 000470       205 000472       206 000527       207 000531       208 000555       211 000556       212 000620
    213 000624       214 000673       217 000674       220 000703       221 000737       222 000777       223 001001
    224 001030       227 001031       229 001033       230 001054       235 001056       239 001062       240 001072
    242 001074       243 001105       244 001111       245 001136       246 001140       247 001147       248 001152
    250 001154       251 001157       253 001236       258 001237       260 001264       262 001266       265 001311
    268 001316       269 001336       274 001337       275 001342       276 001373       277 001377       278 001403
    280 001411       281 001424       283 001425       284 001431       285 001433       292 001434       293 001443
    294 001451       295 001455       297 001532       298 001534       300 001535       301 001536       302 001541
    303 001543       305 001544       307 001546       308 001623       309 001625       313 001626       318 001630
    319 001637       320 001641       321 001643       322 001655       323 001660       327 001662       328 001675
    329 001677       330 001702       331 001714       333 001717       337 001721       339 001722       341 001741
    344 001743       348 001750       350 002003       353 002005       354 002006       358 002007       360 002013
    362 002014       364 002015       366 002021       367 002027       369 002032       371 002045       372 002071
    374 002076       376 002100       379 002172       385 002173       387 002206       389 002257       391 002260
    394 002312       396 002363       398 002374       399 002376       400 002451       403 002452       404 002456
    405 002467       408 002500       409 002516       410 002520       411 002522       412 002555       414 002556
    416 002560       420 002607       421 002613       424 002614       425 002665       428 002666       432 002674
    433 002721       434 002724       435 002735       438 002747


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
