	COMPILATION LISTING OF SEGMENT dl_handler_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/09/86  1226.4 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-08-05,Houck), approve(86-08-11,MCR7501), audit(86-08-15,Wong),
       12*     install(86-08-29,MR12.0-1140):
       13*     Fixed so that an error code is now checked which was previously ignored.
       14*  2) change(86-11-17,Dickson), approve(86-11-18,MECR0001),
       15*     audit(86-11-17,GDixon), install(86-11-18,MR12.0-1221):
       16*     Fix bug in which mailboxes/message_segments couldn't be deleted because
       17*     the "safety" switch was on, but the "copy" switch was unimplemented.
       18*  3) change(86-12-04,Dickson), approve(86-12-04,MCR7582),
       19*     audit(86-12-08,GDixon), install(86-12-09,MR12.0-1236):
       20*     Fixed the bug in which mailboxes/message_segments couldn't be delete
       21*     because the "safety" switch was on, but the "copy" switch was
       22*     unimplemented.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* format: style2,idind30,indcomtxt */
       27 
       28 dl_handler_:
       29      procedure (id, dname, ename, code);
       30 
       31 /* Initially coded 6/69 by V. Voydock */
       32 /* Modified 03/08/70 P. Karger */
       33 /* Modified 12/03/70 E. Donner */
       34 /* Modified 11/02/71 Dennis Capps */
       35 /* Modified 01/74 by E. Donner to reflect that the safety switch protects a branch. */
       36 /* Rewritten to work on mailboxes and queues 03/28/80 S. Herbst */
       37 /* Changed $dirdelete to say "empty" or "nonempty" if possible 12/15/82 S. Herbst */
       38 /* changed for object_type_, added switches entry 7/2/83 Jay Pattin */
       39 /* 830927 BIM object_type_ --> fs_util_ */
       40 /* Fixed to return et_$vtoc_io_error & try to ignore et_$vtoce_connection_fail 06/25/84 S. Herbst */
       41 
       42 
  1     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  1     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  1     3 /*	version number changed to 4, 08/10/78 WOS */
  1     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  1     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  1     6 
  1     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  1     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  1     9     2 switches aligned,                                     /* various bit switch values */
  1    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  1    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  1    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  1    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  1    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  1    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  1    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  1    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  1    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  1    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  1    20 
  1    21 /*  Limit of data defined for version 2 */
  1    22 
  1    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  1    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  1    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  1    26 						/* minimum of 30 seconds required for repeat */
  1    27 						/* otherwise, no repeat will occur */
  1    28 /* Limit of data defined for version 4 */
  1    29 
  1    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  1    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  1    32 
  1    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  1    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  1    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  1    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  1    37 
  1    38 /*	END INCLUDE FILE query_info.incl.pl1 */
       43 
  2     1 /* BEGIN INCLUDE FILE:  dl_handler_options.incl.pl1 */
  2     2 
  2     3 /* This is the switches argument to dl_handler_$switches
  2     4*
  2     5*   Jay Pattin 7/2/83 */
  2     6 
  2     7 declare   1 dl_handler_options,
  2     8           2 no_question                 bit (1) unaligned,  /* ON = reset switches without querying */
  2     9           2 library                     bit (1) unaligned,  /* ON = use installatio_tools_ */
  2    10           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ (library takes precedence) */
  2    11           2 mbz                         bit (33) unaligned;
  2    12 
  2    13 /* END INCLUDE FILE: dl_handler_options.incl.pl1 */
       44 
       45 
  3     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  3     2 /* format: style3,indcomtxt,idind30 */
  3     3 /**** Jay Pattin 2/13/83
  3     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  3     5*
  3     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  3     7*
  3     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  3     9 
  3    10 declare   suffix_info_ptr               ptr;
  3    11 
  3    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  3    13             2 version                   char (8),
  3    14             2 type                      char (32) unaligned,
  3    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  3    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  3    17             2 flags                     unaligned,
  3    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  3    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  3    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  3    21               3 mbz1                    bit (33) unaligned,
  3    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  3    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  3    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  3    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  3    26             2 info_pathname             char (168) unaligned;
  3    27                                                             /* pathname of info segment containing more info */
  3    28 
  3    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  3    30 
  3    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  3    32 
  3    33 declare   switch_list_ptr               ptr,
  3    34           alloc_switch_count            fixed bin,
  3    35           alloc_switch_name_count       fixed bin;
  3    36 
  3    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  3    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  3    39             2 switch_count              fixed bin,          /* total number of switches */
  3    40             2 switch_name_count         fixed bin,          /* total number of names */
  3    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  3    42               3 name_index              fixed bin,          /* index of first name for this switch */
  3    43               3 name_count              fixed bin,          /* number of names for this switch */
  3    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  3    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  3    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  3    47 
  3    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  3    49 
  3    50 declare   (
  3    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  3    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  3    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  3    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  3    55           FS_OBJECT_TYPE_LINK           init ("-link")
  3    56           )                             char (32) unaligned int static options (constant);
  3    57 
  3    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
       46 
  4     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  4     2 
  4     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  4     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  4     5*
  4     6*   Jay Pattin 6/23/83 */
  4     7 
  4     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  4     9           2 names                       bit (1) unaligned,
  4    10           2 acl                         bit (1) unaligned,
  4    11           2 ring_brackets               bit (1) unaligned,
  4    12           2 max_length                  bit (1) unaligned,
  4    13           2 copy_switch                 bit (1) unaligned,
  4    14           2 safety_switch               bit (1) unaligned,
  4    15           2 dumper_switches             bit (1) unaligned,
  4    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  4    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  4    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  4    19           2 mbz                         bit (26) unaligned;
  4    20 
  4    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
       47 
       48 
       49 	dcl     1 dir_acl		        aligned,	/* for hcs_$add_dir_acl_entries */
       50 		2 user_id		        char (32) aligned,
       51 		2 mode		        bit (36) aligned,
       52 		2 status		        fixed bin (35);
       53 
       54 
       55 	dcl     (id, dname, ename)	        char (*);
       56 	dcl     switches		        bit (36) aligned parameter;
       57 	dcl     (code, star_code)	        fixed bin (35);
       58 
       59 	dcl     fs_util_type	        char (32);
       60 	dcl     answer		        char (150) varying;
       61 	dcl     (empty_str, switch_type)      char (32);
       62 
       63 	dcl     fb_copy_switch	        fixed bin (1);
       64 	dcl     copy_switch		        bit (1) aligned;
       65 	dcl     safety_switch	        bit (1) aligned;
       66 
       67 	dcl     bit_count		        fixed bin (24);
       68 	dcl     entry_count		        fixed bin;
       69 	dcl     type		        fixed bin (2);
       70 
       71 	dcl     error_table_$action_not_performed
       72 				        fixed bin (35) ext;
       73 	dcl     error_table_$nomatch	        fixed bin (35) ext;
       74 	dcl     error_table_$safety_sw_on     fixed bin (35) ext;
       75 	dcl     error_table_$vtoce_connection_fail
       76 				        fixed bin (35) ext;
       77 
       78 	dcl     command_query_	        entry options (variable);
       79 	dcl     fs_util_$list_switches        entry (char (*), char (*), char (*), ptr, ptr, fixed bin (35));
       80 	dcl     get_group_id_	        entry returns (char (32));
       81 	dcl     get_system_free_area_	        entry returns (ptr);
       82 	dcl     hcs_$add_dir_acl_entries      entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       83 	dcl     hcs_$get_safety_sw	        entry (char (*), char (*), bit (1) aligned, fixed bin (35));
       84 	dcl     hcs_$get_copysw	        entry (char (*), char (*), fixed bin (1), fixed bin (35));
       85 	dcl     hcs_$set_copysw	        entry (char (*), char (*), fixed bin (1), fixed bin (35));
       86 	dcl     hcs_$set_safety_sw	        entry (char (*), char (*), bit (1) aligned, fixed bin (35));
       87 	dcl     hcs_$star_		        entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
       88 				        fixed bin (35));
       89 	dcl     hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
       90 				        fixed bin (35));
       91 	dcl     installation_tools_$set_safety_sw
       92 				        entry (char (*), char (*), bit (1) aligned, fixed bin (35));
       93 	dcl     fs_util_$get_switch	        entry (char (*), char (*), char (*), bit (1) aligned, fixed bin (35));
       94 	dcl     fs_util_$set_switch	        entry (char (*), char (*), char (*), bit (1) aligned, fixed bin (35));
       95 	dcl     fs_util_$get_type	        entry (character (*), character (*), character (*), fixed binary (35));
       96 	dcl     pathname_		        entry (char (*), char (*)) returns (char (168));
       97 
       98 	dcl     cleanup		        condition;
       99 
      100 	dcl     (addr, hbound, lbound, null, string, unspec)
      101 				        builtin;
      102 
      103 /* dl_handler_$dl_handler_ */
      104 
      105 	string (dl_handler_options) = ""b;
      106 	goto JOIN;
      107 
      108 dl_handler_$switches:
      109      entry (id, dname, ename, switches, code);
      110 
      111 	string (dl_handler_options) = switches;
      112 	if dl_handler_options.no_question
      113 	then goto RESET;
      114 
      115 JOIN:
      116 	call query_init;
      117 	query_info.status_code = error_table_$safety_sw_on;
      118 
      119 	if dl_handler_options.raw
      120 	then call hcs_$get_safety_sw (dname, ename, safety_switch, code);
      121 	else call fs_util_$get_switch (dname, ename, "safety", safety_switch, code);
      122 	if code ^= 0
      123 	then if code = error_table_$vtoce_connection_fail
      124 	     then go to GET_STATUS;			/* OK to delete anyway */
      125 	     else return;
      126 
      127 	if safety_switch
      128 	then switch_type = "safety switch";
      129 	else do;
      130 		if dl_handler_options.raw
      131 		then do;
      132 			call hcs_$get_copysw (dname, ename, fb_copy_switch, code);
      133 			copy_switch = (fb_copy_switch ^= 0);
      134 		     end;
      135 		else call fs_util_$get_switch (dname, ename, "copy", copy_switch, code);
      136 		if code ^= 0
      137 		then if code = error_table_$vtoce_connection_fail
      138 		     then go to GET_STATUS;		/* unlikely 2nd time */
      139 		     else return;
      140 
      141 		if copy_switch
      142 		then switch_type = "copy switch";
      143 		else go to GET_STATUS;		/* neither switch is on */
      144 	     end;
      145 
      146 	code = 0;
      147 
      148 	call command_query_ (addr (query_info), answer, id, "^a is protected by ^a. Do you want to delete it?  ",
      149 	     pathname_ (dname, ename), switch_type);
      150 
      151 	if answer = "no"
      152 	then do;
      153 NO:
      154 		code = error_table_$action_not_performed;
      155 		return;
      156 	     end;
      157 	goto RESET;
      158 
      159 noquestion:
      160      entry (id, dname, ename, code);			/* dl_handler_$noquestion: no need to query */
      161 
      162 	string (dl_handler_options) = ""b;		/* no need to set no_question */
      163 
      164 RESET:
      165 	if dl_handler_options.library
      166 	then call installation_tools_$set_safety_sw (dname, ename, "0"b, code);
      167 	else if dl_handler_options.raw
      168 	then do;
      169 		call hcs_$set_copysw (dname, ename, 0, code);
      170 		call hcs_$set_safety_sw (dname, ename, "0"b, code);
      171 	     end;
      172 	else do;
      173 		call fs_util_$set_switch (dname, ename, "copy", "0"b, code);
      174 		if code ^= 0
      175 		then if ^switch_implemented (dname, ename, "copy")
      176 		     then code = 0;
      177 		if code = 0
      178 		then do;
      179 			call fs_util_$set_switch (dname, ename, "safety", "0"b, code);
      180 			if code ^= 0
      181 			then if ^switch_implemented (dname, ename, "safety")
      182 			     then code = 0;
      183 		     end;
      184 	     end;
      185 	if code ^= 0
      186 	then return;
      187 
      188 /* Obtain storage system type */
      189 
      190 GET_STATUS:
      191 	call hcs_$status_minf (dname, ename, 0, type, bit_count, code);
      192 	if code ^= 0
      193 	then return;
      194 
      195 /* If entry is a directory, add current user onto ACL with sma access */
      196 
      197 	if type = 2 & bit_count = 0
      198 	then do;
      199 		if ^dl_handler_options.raw
      200 		then do;				/* is it really a dir? */
      201 			call fs_util_$get_type (dname, ename, fs_util_type, code);
      202 			if code = 0 & fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
      203 			then return;		/* its some sort of extended something */
      204 		     end;
      205 
      206 		dir_acl.user_id = get_group_id_ ();
      207 		dir_acl.mode = "111"b;
      208 		call hcs_$add_dir_acl_entries (dname, ename, addr (dir_acl), 1, code);
      209 	     end;
      210 
      211 	return;					/*						*/
      212 dblstar:
      213      entry (id, dname, ename, code);			/* "Do you want to delete '**'? */
      214 
      215 	call query_init;
      216 	query_info.suppress_name_sw = "1"b;
      217 
      218 	call command_query_ (addr (query_info), answer, id, "Do you want to '^a ^a' in ^a ?  ", id, ename, dname);
      219 
      220 	if answer = "no"
      221 	then go to NO;
      222 	else code = 0;
      223 
      224 	return;
      225 
      226 
      227 
      228 dirdelete:
      229      entry (id, dname, ename, code);			/* "Do you want to delete the directory...?" */
      230 
      231 	call query_init;
      232 
      233 	call hcs_$star_ (pathname_ (dname, ename), "**", 3 /* ALL ENTRIES */, null, entry_count, null, null, star_code);
      234 	if star_code = 0
      235 	then if entry_count = 0
      236 	     then empty_str = " empty";
      237 	     else empty_str = " nonempty";
      238 	else if star_code = error_table_$nomatch
      239 	then empty_str = " empty";
      240 	else empty_str = "";
      241 	call command_query_ (addr (query_info), answer, id, "Do you want to delete the^a directory ^a ? ", empty_str,
      242 	     pathname_ (dname, ename));
      243 	if answer = "no"
      244 	then go to NO;
      245 	else code = 0;
      246 
      247 	return;					/*						*/
      248 query_init:
      249      proc;
      250 
      251 	unspec (query_info) = "0"b;
      252 	query_info.version = query_info_version_4;
      253 	query_info.yes_or_no_sw = "1"b;
      254 	query_info.question_iocbp, query_info.answer_iocbp = null;
      255 
      256      end query_init;
      257 
      258 
      259 switch_implemented:
      260      procedure (dname, ename, switch) returns (bit (1) aligned);
      261 
      262 	dcl     switch		        char (32);
      263 	dcl     dname		        char (*);
      264 	dcl     ename		        char (*);
      265 
      266 	dcl     found		        bit(1);
      267 	dcl     indx		        fixed bin;
      268 	dcl     system_area_ptr	        ptr;
      269 	dcl     system_area		        area based(system_area_ptr);
      270 
      271 	switch_list_ptr = null ();
      272 	on cleanup call cleanup_switch_list;
      273 	system_area_ptr = get_system_free_area_();
      274 
      275 	call fs_util_$list_switches (dname, ename, SWITCH_LIST_VERSION_1,
      276 	     addr(system_area), switch_list_ptr, code);
      277 	if code ^= 0 then return ("0"b);
      278 
      279 	do indx = lbound (switch_list.names, 1)
      280 	       to hbound (switch_list.names, 1)
      281 	    while (switch_list.names(indx) ^= switch);
      282 	end;
      283 	found = indx > hbound(switch_list.names, 1);
      284 	free switch_list in (system_area);
      285 
      286 	return (found);
      287 
      288 cleanup_switch_list:
      289      procedure;
      290 
      291 	if switch_list_ptr ^= null ()
      292 	then free switch_list in (system_area);
      293 
      294      end cleanup_switch_list;
      295 
      296      end switch_implemented;
      297 
      298      end dl_handler_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/09/86  1226.4  dl_handler_.pl1                   >spec>install>1236>dl_handler_.pl1
43           1    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
44           2    10/14/83  1606.7  dl_handler_options.incl.pl1       >ldd>include>dl_handler_options.incl.pl1
46           3    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
47           4    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FS_OBJECT_TYPE_DIRECTORY        000000 constant        char(32)                 initial unaligned dcl 3-50 ref 202
SWITCH_LIST_VERSION_1           000010 constant        char(8)                  initial unaligned dcl 3-48 set ref 275*
addr                                                   builtin function         dcl 100 ref 148 148 208 208 218 218 241 241 275 275
answer                          000143 automatic       varying char(150)        dcl 60 set ref 148* 151 218* 220 241* 243
answer_iocbp              6     000100 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7* 254*
bit_count                       000235 automatic       fixed bin(24,0)          dcl 67 set ref 190* 197
cleanup                         000000 stack reference condition                dcl 98 ref 272
code                                   parameter       fixed bin(35,0)          dcl 57 set ref 28 108 119* 121* 122 122 132* 135*
                                                                                  136 136 146* 153* 159 164* 169* 170* 173* 174 174*
                                                                                  177 179* 180 180* 185 190* 192 201* 202 208* 212
                                                                                  222* 228 245* 275* 277
command_query_                  000020 constant        entry                    external dcl 78 ref 148 218 241
copy_flags                             based           structure                level 1 dcl 4-8
copy_switch                     000233 automatic       bit(1)                   dcl 64 set ref 133* 135* 141
cp_escape_control         1(02) 000100 automatic       bit(2)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7*
dir_acl                         000120 automatic       structure                level 1 dcl 49 set ref 208 208
dl_handler_options              000115 automatic       structure                level 1 packed unaligned dcl 2-7 set ref 105* 111*
                                                                                  162*
dname                                  parameter       char                     unaligned dcl 55 in procedure "dl_handler_" set ref
                                                                                  28 108 119* 121* 132* 135* 148* 148* 159 164* 169*
                                                                                  170* 173* 174* 179* 180* 190* 201* 208* 212 218*
                                                                                  228 233* 233* 241* 241*
dname                                  parameter       char                     unaligned dcl 263 in procedure "switch_implemented"
                                                                                  set ref 259 275*
empty_str                       000212 automatic       char(32)                 unaligned dcl 61 set ref 234* 237* 238* 240* 241*
ename                                  parameter       char                     unaligned dcl 264 in procedure "switch_implemented"
                                                                                  set ref 259 275*
ename                                  parameter       char                     unaligned dcl 55 in procedure "dl_handler_" set ref
                                                                                  28 108 119* 121* 132* 135* 148* 148* 159 164* 169*
                                                                                  170* 173* 174* 179* 180* 190* 201* 208* 212 218*
                                                                                  228 233* 233* 241* 241*
entry_count                     000236 automatic       fixed bin(17,0)          dcl 68 set ref 233* 234
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 71 ref 153
error_table_$nomatch            000012 external static fixed bin(35,0)          dcl 73 ref 238
error_table_$safety_sw_on       000014 external static fixed bin(35,0)          dcl 74 ref 117
error_table_$vtoce_connection_fail
                                000016 external static fixed bin(35,0)          dcl 75 ref 122 136
explanation_len          14     000100 automatic       fixed bin(21,0)          initial level 2 dcl 1-7 set ref 1-7*
explanation_ptr          12     000100 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7*
fb_copy_switch                  000232 automatic       fixed bin(1,0)           dcl 63 set ref 132* 133
found                           000100 automatic       bit(1)                   unaligned dcl 266 set ref 283* 286
fs_util_$get_switch             000050 constant        entry                    external dcl 93 ref 121 135
fs_util_$get_type               000054 constant        entry                    external dcl 95 ref 201
fs_util_$list_switches          000022 constant        entry                    external dcl 79 ref 275
fs_util_$set_switch             000052 constant        entry                    external dcl 94 ref 173 179
fs_util_type                    000133 automatic       char(32)                 unaligned dcl 59 set ref 201* 202
get_group_id_                   000024 constant        entry                    external dcl 80 ref 206
get_system_free_area_           000026 constant        entry                    external dcl 81 ref 273
hbound                                                 builtin function         dcl 100 ref 279 283
hcs_$add_dir_acl_entries        000030 constant        entry                    external dcl 82 ref 208
hcs_$get_copysw                 000034 constant        entry                    external dcl 84 ref 132
hcs_$get_safety_sw              000032 constant        entry                    external dcl 83 ref 119
hcs_$set_copysw                 000036 constant        entry                    external dcl 85 ref 169
hcs_$set_safety_sw              000040 constant        entry                    external dcl 86 ref 170
hcs_$star_                      000042 constant        entry                    external dcl 87 ref 233
hcs_$status_minf                000044 constant        entry                    external dcl 89 ref 190
id                                     parameter       char                     unaligned dcl 55 set ref 28 108 148* 159 212 218*
                                                                                  218* 228 241*
indx                            000101 automatic       fixed bin(17,0)          dcl 267 set ref 279* 279* 283
installation_tools_$set_safety_sw
                                000046 constant        entry                    external dcl 91 ref 164
lbound                                                 builtin function         dcl 100 ref 279
library                   0(01) 000115 automatic       bit(1)                   level 2 packed unaligned dcl 2-7 set ref 164
literal_sw                1(05) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7*
mode                     10     000120 automatic       bit(36)                  level 2 dcl 49 set ref 207*
names                                  based           char(32)                 array level 2 dcl 3-37 ref 279 279 279 283
no_question                     000115 automatic       bit(1)                   level 2 packed unaligned dcl 2-7 set ref 112
null                                                   builtin function         dcl 100 ref 233 233 233 233 233 233 1-7 1-7 1-7 254
                                                                                  271 291
padding                   1(07) 000100 automatic       bit(29)                  initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7*
pathname_                       000056 constant        entry                    external dcl 96 ref 148 148 233 233 241 241
prompt_after_explanation
                          1(06) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7*
query_code                3     000100 automatic       fixed bin(35,0)          initial level 2 dcl 1-7 set ref 1-7*
query_info                      000100 automatic       structure                level 1 dcl 1-7 set ref 148 148 218 218 241 241 251*
query_info_version_4                   constant        fixed bin(17,0)          initial dcl 1-34 ref 252
question_iocbp            4     000100 automatic       pointer                  initial level 2 dcl 1-7 set ref 1-7* 254*
raw                       0(02) 000115 automatic       bit(1)                   level 2 packed unaligned dcl 2-7 set ref 119 130 167
                                                                                  199
repeat_time              10     000100 automatic       fixed bin(71,0)          initial level 2 dcl 1-7 set ref 1-7*
safety_switch                   000234 automatic       bit(1)                   dcl 65 set ref 119* 121* 127
star_code                       000132 automatic       fixed bin(35,0)          dcl 57 set ref 233* 234 238
status_code               2     000100 automatic       fixed bin(35,0)          initial level 2 dcl 1-7 set ref 117* 1-7*
string                                                 builtin function         dcl 100 set ref 105* 111* 162*
suppress_name_sw          1(01) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  216* 1-7*
suppress_spacing          1(04) 000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7*
switch                                 parameter       char(32)                 unaligned dcl 262 ref 259 279
switch_count              2            based           fixed bin(17,0)          level 2 dcl 3-37 ref 279 279 279 283 284 291
switch_list                            based           structure                level 1 dcl 3-37 ref 284 291
switch_list_ptr                 000116 automatic       pointer                  dcl 3-33 set ref 271* 275* 279 279 279 283 284 291
                                                                                  291
switch_name_count         3            based           fixed bin(17,0)          level 2 dcl 3-37 ref 279 283 284 291
switch_type                     000222 automatic       char(32)                 unaligned dcl 61 set ref 127* 141* 148*
switches                  1     000100 automatic       structure                level 2 in structure "query_info" dcl 1-7
                                                                                  in procedure "dl_handler_"
switches                               parameter       bit(36)                  dcl 56 in procedure "dl_handler_" ref 108 111
system_area                            based           area(1024)               dcl 269 set ref 275 275 284 291
system_area_ptr                 000102 automatic       pointer                  dcl 268 set ref 273* 275 275 284 291
type                            000237 automatic       fixed bin(2,0)           dcl 69 set ref 190* 197
unspec                                                 builtin function         dcl 100 set ref 251*
user_id                         000120 automatic       char(32)                 level 2 dcl 49 set ref 206*
version                         000100 automatic       fixed bin(17,0)          level 2 dcl 1-7 set ref 252*
yes_or_no_sw              1     000100 automatic       bit(1)                   initial level 3 packed unaligned dcl 1-7 set ref
                                                                                  1-7* 253*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial unaligned dcl 3-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial unaligned dcl 3-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial unaligned dcl 3-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial unaligned dcl 3-50
SUFFIX_INFO_VERSION_1                  internal static char(8)                  initial unaligned dcl 3-29
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 3-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 3-33
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 1-33
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 1-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 1-36
suffix_info                            based           structure                level 1 dcl 3-12
suffix_info_ptr                        automatic       pointer                  dcl 3-10

NAMES DECLARED BY EXPLICIT CONTEXT.
GET_STATUS                      001161 constant        label                    dcl 190 ref 122 136 141
JOIN                            000263 constant        label                    dcl 115 ref 106
NO                              000576 constant        label                    dcl 153 ref 220 243
RESET                           000637 constant        label                    dcl 164 ref 112 157
cleanup_switch_list             002146 constant        entry                    internal dcl 288 ref 272
dblstar                         001346 constant        entry                    external dcl 212
dirdelete                       001463 constant        entry                    external dcl 228
dl_handler_                     000164 constant        entry                    external dcl 28
dl_handler_$switches            000224 constant        entry                    external dcl 108
noquestion                      000605 constant        entry                    external dcl 159
query_init                      001737 constant        entry                    internal dcl 248 ref 115 215 231
switch_implemented              001754 constant        entry                    internal dcl 259 ref 174 180

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2524        2604    2177        2534
Length      3106    2177        60         265     324           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dl_handler_                         324 external procedure  is an external procedure.  
query_init                              internal procedure  shares stack frame of external procedure dl_handler_.  
switch_implemented                  110 internal procedure  enables or reverts conditions.  
on unit on line 272                  71 on unit               
cleanup_switch_list                     internal procedure  shares stack frame of on unit on line 272.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dl_handler_              000100 query_info                  dl_handler_
                         000115 dl_handler_options          dl_handler_
                         000116 switch_list_ptr             dl_handler_
                         000120 dir_acl                     dl_handler_
                         000132 star_code                   dl_handler_
                         000133 fs_util_type                dl_handler_
                         000143 answer                      dl_handler_
                         000212 empty_str                   dl_handler_
                         000222 switch_type                 dl_handler_
                         000232 fb_copy_switch              dl_handler_
                         000233 copy_switch                 dl_handler_
                         000234 safety_switch               dl_handler_
                         000235 bit_count                   dl_handler_
                         000236 entry_count                 dl_handler_
                         000237 type                        dl_handler_
switch_implemented       000100 found                       switch_implemented
                         000101 indx                        switch_implemented
                         000102 system_area_ptr             switch_implemented

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_ne_as             call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
enable_op           ext_entry_desc      int_entry           int_entry_desc      op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                fs_util_$get_switch           fs_util_$get_type             fs_util_$list_switches
fs_util_$set_switch           get_group_id_                 get_system_free_area_         hcs_$add_dir_acl_entries
hcs_$get_copysw               hcs_$get_safety_sw            hcs_$set_copysw               hcs_$set_safety_sw
hcs_$star_                    hcs_$status_minf              installation_tools_$set_safety_sw
pathname_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$nomatch          error_table_$safety_sw_on
error_table_$vtoce_connection_fail




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 1    7 000125        28 000157       105 000215       106 000216       108 000217       111 000255       112 000260
    115 000263       117 000264       119 000267       121 000321       122 000355       125 000362       127 000363
    130 000372       132 000375       133 000424       134 000427       135 000430       136 000465       139 000472
    141 000473       146 000501       148 000502       151 000571       153 000576       155 000601       157 000602
    159 000603       162 000636       164 000637       167 000674       169 000677       170 000727       171 000760
    173 000761       174 001020       177 001057       179 001061       180 001120       185 001157       190 001161
    192 001221       197 001223       199 001230       201 001233       202 001262       206 001270       207 001302
    208 001304       211 001343       212 001344       215 001377       216 001400       218 001402       220 001452
    222 001457       224 001460       228 001461       231 001514       233 001515       234 001613       237 001623
    238 001627       240 001636       241 001641       243 001730       245 001735       247 001736       248 001737
    251 001740       252 001743       253 001745       254 001747       256 001752       259 001753       271 001774
    272 001777       273 002015       275 002024       277 002065       279 002073       282 002122       283 002124
    284 002132       286 002142       288 002146       291 002147       294 002167


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
