	COMPILATION LISTING OF SEGMENT probe_seg_mgr_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1235.6 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-05-27,JRGray), approve(87-06-24,MCR7711), audit(87-06-24,Huen),
       14*     install(87-07-15,MR12.1-1040):
       15*     Modifed to allow breakpoints in more than one component of a bound module
       16*     at a time (probe 111).
       17*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       18*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       19*     Added format control comment to make the source more readable.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       23 
       24 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       25 
       26 probe_seg_mgr_:
       27   proc;
       28 
       29 
       30   call probe_error_$malfunction ();
       31 
       32   /* Interface to the probe seg (also known as the break seg).  All permanent information is kept here
       33*   This consists of an entry for every procedure that probe has set a break in.
       34*
       35*   It may one day also hold modes, macros, and variables
       36*
       37*   ENTRIES HERE -
       38*
       39*   get_breakseg_ptr		- initialize breakseg, create if need be
       40*   first_procedure_ptr	- to find first procedure entry in chain
       41*   get_procedure_entry	- given ptr to seg_info, find the procedure entry for it
       42*   create_procedure_entry	- given ptr to seg info, find or create a procedure entry
       43*   delete_procedure_entry	- given ptr to procedure_entry delete it
       44*
       45*
       46*   Jim Davis Aug -  Sept 79 */
       47   /* Improved error message if can't get ptr to seg 08/31/81 S. Herbst */
       48   /* Changed $get_breakseg_ptr not to create, and added $create_breakseg 10/02/81 S. Herbst */
       49   /* Fixed bug that allows $first_procedure_ptr to take a null ptr fault 01/15/85 Steve Herbst */
       50   /* Fixed $first_procedure_ptr to test for null static_info_ptr too 01/23/85 Steve Herbst */
       51 
       52 
       53   dcl (
       54       P_probe_info_ptr	ptr,
       55       P_ent		ptr,
       56       P_bmp		ptr,
       57       P_seginfop		ptr,
       58       P_code		fixed bin (35)
       59       )			parameter;
       60 
       61   dcl (
       62       CREATE		init ("1"b),
       63       DONT_CREATE		init ("0"b)
       64       )			bit (1) aligned;
       65 
       66   dcl seginfop		ptr;	/* copy of P_seginfop */
       67 
       68   dcl (add, addrel, binary, bit, divide, fixed, mod, multiply, null, pointer,
       69       rel, rtrim, size, subtract)
       70 			builtin;
       71 
       72   dcl error_table_$action_not_performed
       73 			fixed bin (35) ext;
       74 
       75   dcl probe_error_$malfunction
       76 			entry options (variable);
       77 
       78   dcl com_err_		entry options (variable);
       79   dcl hcs_$set_bc_seg	entry (ptr, fixed bin (24), fixed bin (35));
       80 
       81 get_breakseg_ptr:
       82   entry (P_code) returns (ptr);
       83 
       84 
       85   P_code = 0;
       86   call initialize_breakseg (DONT_CREATE);
       87 				/* sets break_segp and P_code */
       88   return (break_segp);
       89 
       90 
       91 
       92 create_breakseg:
       93   entry (P_code) returns (ptr);
       94 
       95 
       96   P_code = 0;
       97   call initialize_breakseg (CREATE);
       98   return (break_segp);
       99 
      100 
      101 
      102 first_procedure_ptr:
      103   entry (P_probe_info_ptr, P_code) returns (ptr);
      104 
      105 
      106   P_code = 0;
      107   if P_probe_info_ptr = null
      108     then
      109          return (null);
      110 
      111   probe_info_ptr = P_probe_info_ptr;
      112 
      113   if probe_info.static_info_ptr = null
      114     then
      115          return (null);
      116 
      117   break_segp = probe_static_info.break_segment_ptr;
      118   if break_segp = null
      119     then
      120          return (null);
      121   if break_segment.first_procedure_entry = (18)"0"b
      122     then return (null ());
      123     else return (pointer (break_segp, break_segment.first_procedure_entry));
      124 
      125 
      126 
      127 get_procedure_entry:
      128   entry (P_probe_info_ptr, P_seginfop, P_ent, P_bmp, P_code);
      129 
      130 
      131   probe_info_ptr = P_probe_info_ptr;
      132   seginfop = P_seginfop;
      133   P_code = 0;
      134 
      135   break_segp = probe_static_info.break_segment_ptr;
      136 
      137   call search_for_proc_entry ();
      138   P_ent = ent;
      139   P_bmp = bmp;
      140   return;
      141 
      142 
      143 
      144 delete_procedure_entry:
      145   entry (P_probe_info_ptr, P_ent, P_code);
      146 
      147   probe_info_ptr = P_probe_info_ptr;
      148   P_code = 0;
      149 
      150   break_segp = probe_static_info.break_segment_ptr;
      151   call delete_proc ((P_ent));
      152   return;
      153 
      154 
      155 
      156 create_procedure_entry:
      157   entry (P_probe_info_ptr, P_seginfop, P_ent, P_bmp, P_code);
      158 
      159 
      160   probe_info_ptr = P_probe_info_ptr;
      161   seginfop = P_seginfop;
      162   P_code = 0;
      163 
      164   break_segp = probe_static_info.break_segment_ptr;
      165 
      166   call search_for_proc_entry ();
      167   P_ent = ent;
      168   P_bmp = bmp;
      169   if ent ^= null ()
      170     then
      171          return;			/* already had one */
      172   call create_proc ();
      173   P_ent = ent;			/* the entry just created */
      174   P_bmp = null ();			/* obviously, 'cause we just made it */
      175   return;
      176 
      177 
      178 initialize_breakseg:
      179   proc (P_create_sw);
      180 
      181   dcl P_create_sw		bit (1) aligned;
      182 
      183   dcl dirname		character (168);
      184 				/* directory portion of pathname of break seg */
      185   dcl entryname		character (32);
      186 				/* entry portion of name */
      187   dcl code		fixed bin (35);
      188 
      189   dcl user_info_		entry options (variable);
      190   dcl user_info_$homedir	entry (char (*));
      191   dcl hcs_$initiate		entry (char (*), char (*), char (*),
      192 			fixed bin (1), fixed bin (2), ptr,
      193 			fixed bin (35));
      194   dcl hcs_$make_seg		entry (char (*), char (*), char (*),
      195 			fixed bin (5), ptr, fixed bin (35));
      196 
      197   dcl probe_data_$break_segment_suffix
      198 			char (32) external static;
      199 
      200 
      201   call user_info_ (entryname);	/* get user's id and project */
      202   call user_info_$homedir (dirname);	/* get directory in which to place seg */
      203 
      204   entryname =
      205        rtrim (entryname) || "." || rtrim (probe_data_$break_segment_suffix);
      206 
      207   if P_create_sw then do;
      208       call hcs_$make_seg (dirname, entryname, "", 01010b, break_segp, code);
      209       if break_segp = null () then do;	/* something went wrong */
      210 	call com_err_ (code, "probe", "^a^[>^]^a", dirname, dirname ^= ">",
      211 	     entryname);
      212 	P_code = error_table_$action_not_performed;
      213 	return;
      214         end;
      215     end;
      216     else do;
      217       call hcs_$initiate (dirname, entryname, "", 0, 0, break_segp, code);
      218       code = 0;
      219       if break_segp = null
      220         then
      221 	   return;
      222     end;
      223 
      224   if break_segment.version = 1 then do; /* old style break segment, convert to new style */
      225       break_segment.upper_bound = /* builtins are so powerful..... */
      226 	 bit (
      227 	 subtract (
      228 	 multiply (divide (add (binary (break_segment.word_count, 18, 0),
      229 	 1023, 18, 0), 1024, 18, 0), 1024, 18, 0), 4, 18, 0));
      230       call hcs_$set_bc_seg (break_segp,
      231 	 multiply (binary (break_segment.upper_bound, 18, 0) + 4, 36, 24, 0)
      232 	 , (0));
      233     end;
      234 
      235   else if break_segment.version ^= 2 then do;
      236 				/* this segment has not been initialized */
      237       break_segment.version = 2;
      238       break_segment.name = "breakseg";
      239       break_segment.word_count =
      240 	 bit (
      241 	 binary (size (break_segment) + mod (size (break_segment), 2), 18,
      242 	 0));
      243       break_segment.upper_bound = bit (binary (1020, 18, 0));
      244 				/* know that header not more than a page */
      245       call hcs_$set_bc_seg (break_segp,
      246 	 multiply (binary (break_segment.upper_bound, 18, 0), 36, 24, 0),
      247 	 (0));
      248     end;
      249   return;
      250 
      251   end initialize_breakseg;
      252 
      253 search_for_proc_entry:
      254   proc ();
      255 
      256   /* GLOBAL! seginfop ent bmp */
      257 
      258 
      259   dcl goal_id		fixed bin (71) aligned;
      260   dcl next		ptr;
      261 
      262   goal_id = seginfop -> seg_info.bound_create_time;
      263 
      264   do ent = pointer (break_segp, break_segment.first_procedure_entry)
      265        repeat next while (rel (ent) ^= "0"b);
      266 
      267     next = pointer (break_segp, procedure_entry.chain);
      268 
      269     if procedure_entry.time_stamp = goal_id
      270       then
      271 	 /* confirm by checking against entry and seg names,
      272*		     necessary as bound object components share bound_create_times */
      273 	 if procedure_entry.entry = seginfop -> seg_info.entry_name &
      274 	      procedure_entry.segname = seginfop -> seg_info.segname
      275 	   then do;
      276 	     bmp = pointer (seginfop -> seg_info.symbol_header_ptr,
      277 				/* any ptr would be as good */
      278 		procedure_entry.break_map);
      279 	     if procedure_entry.time_stamp = break_map.identifier
      280 	       then
      281 		  return;
      282 	       else call delete_proc (ent);
      283 				/* its obsolete */
      284 	   end;
      285   end;				/* loop */
      286 
      287   ent, bmp = null ();		/* failed */
      288   end search_for_proc_entry;
      289 
      290 
      291 
      292 create_proc:
      293   proc;
      294 
      295   /* GLOBAL import seginfop ent
      296*
      297*   make a new procedure entry for the segment seginfop describes, put it in the
      298*   breakseg and initialize it
      299**/
      300   ent = allocate_in_breakseg (size (procedure_entry));
      301 				/* make room for it */
      302   procedure_entry.item_type = PROCEDURE_ITEM;
      303 				/* record that this is a segment entry */
      304   procedure_entry.directory = seginfop -> seg_info.directory_name;
      305 				/* fill in data */
      306 
      307   procedure_entry.entry = seginfop -> seg_info.entry_name;
      308   procedure_entry.segname = seginfop -> seg_info.segname;
      309   procedure_entry.pad = 0;
      310   procedure_entry.time_stamp = seginfop -> seg_info.bound_create_time;
      311 
      312   procedure_entry.first_statement = (18)"0"b;
      313   procedure_entry.first_symbol = (18)"0"b;
      314   procedure_entry.first_macro = (18)"0"b;
      315   procedure_entry.statement_map =
      316        rel (seginfop -> seg_info.statement_map_ptr);
      317   procedure_entry.statement_map_size =
      318        bit (fixed (seginfop -> seg_info.map_size, 18, 0));
      319   procedure_entry.source_map = rel (seginfop -> seg_info.original_source_ptr);
      320   procedure_entry.symbol_header =
      321        rel (seginfop -> seg_info.symbol_header_ptr);
      322   procedure_entry.bounds = seginfop -> seg_info.bounds;
      323   procedure_entry.language_type = seginfop -> seg_info.language_type;
      324   procedure_entry.break_map = "0"b;	/* none yet */
      325   procedure_entry.chain = break_segment.first_procedure_entry;
      326   break_segment.first_procedure_entry = rel (ent);
      327   end create_proc;
      328 
      329 
      330 
      331 
      332 delete_proc:
      333   proc (ent);
      334 
      335   dcl ent			pointer parameter;
      336   dcl lent		pointer;
      337 
      338   /* unchain item, by searching chain for the previous item */
      339 
      340 
      341   if break_segment.first_procedure_entry = rel (ent)
      342     then break_segment.first_procedure_entry = ent -> procedure_entry.chain;
      343     else do;
      344       do lent = pointer (break_segp, break_segment.first_procedure_entry)
      345 	 repeat pointer (lent, lent -> procedure_entry.chain)
      346 	 while (rel (ent) ^= lent -> procedure_entry.chain);
      347         if lent -> procedure_entry.chain = (18)"0"b
      348 	then call probe_error_$malfunction (probe_info_ptr);
      349       end;
      350       lent -> procedure_entry.chain = ent -> procedure_entry.chain;
      351     end;
      352   call release_in_breakseg (ent);	/* free it, it is no longer needed */
      353 
      354   return;
      355 
      356   end delete_proc;
      357 
      358   /* This routine is used to allocate space for an item in either the break segment.   It attempts
      359*   to find the first free item containing enough space to hold the item, failing that it is placed at
      360*   the end of the segment */
      361 
      362 allocate_in_breakseg:
      363   procedure (required) returns (pointer);
      364 
      365   dcl required		fixed bin parameter;
      366 				/* number of words needed */
      367 
      368   dcl needed		fixed bin;/* 0 mod 2 size */
      369   dcl fip			pointer;
      370   dcl lfip		pointer;
      371 
      372   needed = required + mod (required, 2);/* 0 mod 2 size */
      373   lfip = null ();
      374   do fip = pointer (break_segp, break_segment.first_free_item)
      375        repeat pointer (fip, fip -> free_item.chain)
      376        while (rel (fip) ^= (18)"0"b);
      377 
      378     /* search for a free item that can contain the allocation */
      379 
      380     if fip -> free_item.size >= needed then do;
      381 				/* this one will work */
      382         if fip -> free_item.size = needed then do;
      383 				/* occupies entire area */
      384 	  if lfip ^= null ()
      385 	    then
      386 	         lfip -> free_item.chain = fip -> free_item.chain;
      387 				/* skip this one */
      388 	    else break_segment.first_free_item = fip -> free_item.chain;
      389 	end;
      390 	else do;			/* only uses part, let rest remain free */
      391 	  fip -> free_item.size = fip -> free_item.size - needed;
      392 	  fip = addrel (fip, fip -> free_item.size);
      393 				/* use top part */
      394 	end;
      395         fip -> item.size = needed;	/* fill in for freeing */
      396         return (fip);
      397       end;
      398 
      399     lfip = fip;
      400   end;				/* of loop through chain */
      401 
      402   /* if we get here, weither there were no free areas, or there were none large enough, in
      403*   either case, allocate the space at the end of the segment */
      404 
      405   fip = pointer (break_segp, break_segment.word_count);
      406   fip -> item.size = needed;
      407   break_segment.word_count =
      408        bit (add (binary (break_segment.word_count, 18, 0), needed, 18, 0));
      409 
      410   /* must check if this allocation has overflowed the area, if so we will extend it */
      411 
      412   if break_segment.word_count > break_segment.upper_bound then do;
      413       break_segment.upper_bound =
      414 	 bit (
      415 	 subtract (
      416 	 multiply (divide (add (binary (break_segment.word_count, 18, 0),
      417 	 1023, 18, 0), 1024, 18, 0), 1024, 18, 0), 4, 18, 0));
      418 
      419       call hcs_$set_bc_seg (break_segp,
      420 	 multiply (binary (break_segment.upper_bound, 18, 0) + 4, 36, 24, 0)
      421 	 , (0));
      422 				/* an error here will only cause move problems */
      423     end;
      424   return (fip);
      425   end;				/* internal procedure allocate_in_breakseg */
      426 
      427 
      428 
      429 
      430 
      431   /* This routine is used to handle the freeing of items in the break segment.
      432*   When an item is frees it is chained together with other free items.
      433*   if two or three then turn out to be continguous, they are combined.
      434**/
      435 
      436 release_in_breakseg:
      437   procedure (item_pointer);
      438 
      439   dcl item_pointer		pointer,	/* pointer to the item itself */
      440       ip			pointer,	/* working copies of the above */
      441       i			fixed bin (35),
      442 				/* offset of item */
      443       (p, lp)		pointer;
      444   dcl copy_overlay		(copy_count) bit (36) based aligned;
      445   dcl copy_count		fixed bin;
      446 
      447 
      448   ip = item_pointer;		/* copy pointers */
      449   i = binary (rel (ip), 18, 0);
      450 
      451   /* first check if item is at the end of the segment */
      452 
      453   if i + ip -> item.size
      454        = binary (break_segment.word_count, 18, 0) /* it is at the end */
      455     then do;
      456       break_segment.word_count = rel (ip);
      457       copy_count = ip -> item.size;
      458       ip -> copy_overlay = "0"b;	/* zero out words at the end of a segment */
      459 
      460       lp = null ();
      461       do p = pointer (break_segp, break_segment.first_free_item)
      462 	 repeat pointer (p, p -> free_item.chain)
      463 	 while (rel (p) ^= (18)"0"b); /*  see if this leaves one at the end of the area */
      464 
      465         if addrel (p, p -> free_item.size) = ip then do;
      466 				/* this one is at the end, so remove it */
      467 	  break_segment.word_count = rel (p);
      468 				/* new length */
      469 	  if lp ^= null ()		/* remove form chain */
      470 	    then lp -> free_item.chain = (18)"0"b;
      471 				/* as items are order, this is the last */
      472 	    else break_segment.first_free_item = (18)"0"b;
      473 	  copy_count = p -> free_item.size;
      474 				/* zero it out */
      475 	  p -> copy_overlay = "0"b;
      476 	  return;
      477 	end;
      478       end;
      479       return;
      480     end;
      481 
      482   /* no, free it within the area */
      483 
      484   if break_segment.first_free_item then do;
      485 				/* if this is not the only one, we will have to
      486*						   check if it is contguous with the others */
      487       lp = null ();
      488       do p = pointer (break_segp, break_segment.first_free_item)
      489 	 repeat pointer (p, p -> free_item.chain);
      490 				/* termination condition checked below */
      491 
      492         if i < binary (rel (p), 18, 0) then do;
      493 				/* the item goes here */
      494 	  if lp ^= null /* if there is a previous item look at it */
      495 	    then do;
      496 	      if addrel (lp, lp -> free_item.size)
      497 		 = ip /* the last one and the new one touch */
      498 	        then do;
      499 		lp -> free_item.size =
      500 		     lp -> free_item.size + ip -> item.size;
      501 		ip = lp;		/* we are now interested in the combination */
      502 	        end;
      503 	        else do;
      504 		ip -> free_item.size = ip -> item.size;
      505 		lp -> free_item.chain = rel (ip);
      506 	        end;
      507 	    end;
      508 	    else do;
      509 	      ip -> free_item.size = ip -> item.size;
      510 	      break_segment.first_free_item = rel (ip);
      511 	    end;
      512 
      513 	  if addrel (ip, ip -> free_item.size)
      514 	       = p /* the new one and the next one touch */
      515 	    then do;
      516 	      ip -> free_item.size =
      517 		 ip -> free_item.size + p -> free_item.size;
      518 	      ip -> free_item.chain = p -> free_item.chain;
      519 	    end;
      520 	    else do;
      521 	      ip -> free_item.chain = rel (p);
      522 	    end;
      523 	  return;			/* all done */
      524 	end;
      525 
      526         if p -> free_item.chain
      527 	   = (18)"0"b /* if this is the end of the chain, put it here */
      528 	then do;
      529 	  if addrel (p, p -> free_item.size) = ip
      530 	    then p -> free_item.size =
      531 		    p -> free_item.size + ip -> item.size;
      532 	    else do;
      533 	      ip -> free_item.size = ip -> item.size;
      534 	      ip -> free_item.chain = (18)"0"b;
      535 	      p -> free_item.chain = rel (ip);
      536 	    end;
      537 	  return;
      538 	end;
      539 
      540       end;			/* of search through free chain */
      541 
      542     end;
      543 
      544   /* first free_item, start the chain */
      545 
      546   break_segment.first_free_item = rel (ip);
      547   ip -> free_item.chain = (18)"0"b;
      548   ip -> free_item.size = ip -> item.size;
      549   return;
      550 
      551   end release_in_breakseg;
      552 
      553 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      554 
      555 
      556   /* ;;;;;;; */
      557 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      558 
      559 
      560   /* ;;;;;;; */
      561 
      562 
  3     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  3     2*
  3     3*   25 June 79 JRDavis
  3     4*
  3     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  3     6*	correction per file.
  3     7**/
  3     8 
  3     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  3    10     2 language_type fixed bin,			/* language of source program */
  3    11     2 bits aligned,
  3    12       3 ignore_case bit (1) unal,
  3    13       3 bound_segment bit (1) unaligned,
  3    14       3 component bit (1) unaligned,
  3    15       3 pad bit (33) unal,
  3    16     2 names,					/* where to find it */
  3    17       3 directory_name character (168) unal,		/* what directory */
  3    18       3 entry_name character (32) unal,			/* what segment */
  3    19       3 segname character (32) unal,			/* procedure segname definition */
  3    20     2 identifier fixed bin (71),			/* time of object creation */
  3    21     2 pointers,					/* location of various parts of segment */
  3    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  3    23       3 original_source_ptr ptr unal,			/* to segment source map */
  3    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  3    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  3    26*						   bound ones, -> break_map !obsolete, I think! */
  3    27       3 chain ptr unal,				/* to entry for next component if bound */
  3    28       3 linkage_ptr ptr unal,				/* to linkage section */
  3    29     2 bounds aligned,				/* structure of bounds information */
  3    30       3 text_bounds,
  3    31         4 start fixed bin (35),
  3    32         4 end fixed bin (35),
  3    33       3 symbol_bounds,
  3    34         4 start fixed bin (35),
  3    35         4 end fixed bin (35),
  3    36     2 map_size fixed bin,				/* size of statement map */
  3    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  3    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  3    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  3    40     2 pad (1) fixed bin (35),
  3    41 
  3    42     2 nfiles fixed bin,
  3    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  3    44       3 file_pointers ptr unal,
  3    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  3    46 
  3    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  3    48 
  3    49 
  3    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      563 
      564 
      565   /* ;;;;;;; */
      566 
  4     1 /*	BEGIN INCLUDE FILE probe_break_info.incl.pl1
  4     2*   Removed from probe_break_mgr_, 05/18/79 WOS
  4     3*
  4     4*   Some of these things are found only in the probe segment (the break segment)
  4     5*   such as "break_segment", "procedure_entry".
  4     6*   If "macro_item" or   "symbol_item" were used, they'd go there, too.
  4     7*   If probe_modes were kept in   the probe seg, they'd go there too.
  4     8*   In the break_map of an object seg go "break_map", and "statement_item" and
  4     9*   "break_slot" (there are two flavors of break_slot, one for "before",
  4    10*   and one for "after".  The astute reader will notice that they are both the
  4    11*   same , except in how they arrange the eight words in "sequence".  For cases
  4    12*   where what is of interest is not in those eigth words, the more general "break_slot"
  4    13*   structure may be used.  It may come to pass in the future that before and after will
  4    14*   look different, of course.
  4    15*
  4    16*   James R. Davis 23 Sept 79
  4    17*
  4    18*   "symbol_item" removed, because probe variables are implemented differently
  4    19*   then JMB seemed to envision.  SYMBOL_ITEM is left for compatibility, but not used
  4    20**/
  4    21 
  4    22 dcl 1 break_segment based (break_segp) aligned,		/* declaration of header for break segment */
  4    23     2 version fixed bin initial (2),			/* version number */
  4    24     2 name character (8) initial ("breakseg"),
  4    25     2 upper_bound bit (18) unal,			/* as described above */
  4    26     2 word_count bit (18) unal,
  4    27     2 first_free_item bit (18) unal,
  4    28     2 first_procedure_entry bit (18) unal,		/* the break procedure only has procedure entries */
  4    29     2 first_symbol bit (18) unal,			/* can be deleted */
  4    30     2 first_macro bit (18) unal;
  4    31 
  4    32 dcl  break_segp pointer;
  4    33 
  4    34 dcl 1 break_map based (bmp) aligned,			/* declaration of header for break map */
  4    35     2 version fixed bin initial (2),			/* version number */
  4    36     2 name character (8) initial ("breakmap"),
  4    37     2 upper_bound bit (18) unal,
  4    38     2 word_count bit (18) unal,
  4    39     2 first_free_item bit (18) unal,			/* as above */
  4    40     2 symbol_header bit (18) unal,			/* to symbol section of entire object seg */
  4    41     2 initial_word_count fixed bin (35),		/* low water mark for allocations */
  4    42     2 identifier fixed bin (71),			/* unique id of entire segment */
  4    43     2 map_sequence pointer;				/* beginning of code to call break handler */
  4    44 						/* pointer to align on double word */
  4    45 
  4    46 dcl 1 item based aligned,				/* canonical declaration for all items */
  4    47     2 item_type fixed bin,				/* separates different types */
  4    48     2 unused bit (18) unaligned,
  4    49     2 chain bit (18) unaligned,			/* to next item of same type or (18)"0"b */
  4    50     2 size fixed bin;				/* number of words occupied by this item */
  4    51 
  4    52 dcl 1 free_item based aligned,			/* little bundle of free storage */
  4    53     2 size fixed bin,				/* number free words contained here */
  4    54     2 unused bit (18) unaligned,
  4    55     2 chain bit (18) unaligned,
  4    56     2 zeros bit (0);				/* area to zero out when freed */
  4    57 
  4    58 dcl 1 procedure_entry based (ent) aligned,		/* one entry for each procedure that has breaks */
  4    59     2 item_type fixed bin initial (PROCEDURE_ITEM),	/* as for all other items */
  4    60     2 unused bit (18) unaligned,
  4    61     2 chain bit (18) unaligned,
  4    62     2 size fixed bin,
  4    63     2 directory character (168) unal,			/* directory portion of segment pathname */
  4    64     2 entry character (32) unal,			/* entry portion of pathname */
  4    65     2 segname character (32) unal,			/* name of "main" entry */
  4    66     2 pad fixed bin (71),				/* formerly time of proc. creation */
  4    67     2 time_stamp fixed bin (71),			/* time of creation of containing seg. */
  4    68     2 first_statement bit (18) unal,			/* chain of statements with breaks */
  4    69     2 first_symbol bit (18) unal,			/* not used */
  4    70     2 first_macro bit (18) unal,
  4    71     2 first_debug_break bit (18) unal,			/* chain of debug style breaks (not used yet) */
  4    72     2 break_map bit (18) unal,			/* offset in object seg of break map */
  4    73     2 statement_map bit (18) unal,			/* offset in object seg of map for this proc */
  4    74     2 statement_map_size bit (18) unal,			/* number of entries in map */
  4    75     2 source_map bit (18) unal,			/* offset of source map for proc */
  4    76     2 symbol_header bit (18) unal,			/* offset of symbol section for this proc */
  4    77     2 bounds aligned,				/* structure of bounds information */
  4    78       3 text_bounds,
  4    79         4 start fixed bin (35),
  4    80         4 end fixed bin (35),
  4    81       3 symbol_bounds,
  4    82         4 start fixed bin (35),
  4    83         4 end fixed bin (35),
  4    84     2 language_type fixed bin;			/* code for language of source program */
  4    85 
  4    86 dcl 1 statement_item based (stp) aligned,		/* each statement with a break has a map entry */
  4    87     2 item_type fixed bin initial (STATEMENT_ITEM),
  4    88     2 unused bit (18) unaligned,
  4    89     2 chain bit (18) unaligned,
  4    90     2 size fixed bin,
  4    91     2 identifier fixed bin (71),			/* id of proc this stmt is in */
  4    92     2 proc_entry bit (18) unal,			/* offset of proc entry in break seg */
  4    93     2 number fixed bin,				/* statement number */
  4    94     2 slots (0:1) bit (18);				/* offset of break slots for insert and append */
  4    95 
  4    96 /* unused, here only as indication of what JMB (Amen!) may have had in mind 
  4    97*   for probe macros.  For the record, it looked like he was going to do
  4    98*   probe variables in a similar way, and they are not done the way he seemed
  4    99*  to envision.
  4   100**/
  4   101 
  4   102 dcl 1 macro_item based aligned,			/* definition of a probe macro */
  4   103     2 item_type fixed bin initial (MACRO_ITEM),
  4   104     2 unused bit (18) unaligned,
  4   105     2 chain bit (18) unaligned,
  4   106     2 size fixed bin,
  4   107     2 name character (32),				/* macro name */
  4   108     2 count fixed bin,				/* number of characters in command list */
  4   109     2 command_list character (0);			/* place to put command list */
  4   110 
  4   111 
  4   112 dcl 1 break_slot_before aligned based (before_slot_ptr),
  4   113     2 item_type fixed bin init (BREAK_ITEM),
  4   114     2 breakmap_header_offset bit (18) unal,
  4   115     2 statement_item_offset bit (18) unal,
  4   116     2 size fixed bin,
  4   117     2 sequence,					/* eight words */
  4   118       3 word0 bit (36) init (SPRI_wd),
  4   119       3 word1,
  4   120         4 map_seq_offset bit (18) unal,
  4   121         4 opcode bit (18) unal init (TSPLB_code),
  4   122       3 word2,
  4   123         4 slot_offset bit (18) unal,
  4   124         4 opcode bit (18) unal init (NOP_code),
  4   125       3 moved_instruction bit (36),			/* first instr. of line, executed after break has occured */
  4   126       3 moved_descs (3),				/* descriptors if needed */
  4   127         4 offset bit (18) unal init (0),
  4   128         4 opcode bit (18) unal init (NOP_code),		/* and harmless NOP if not */
  4   129       3 return,
  4   130         4 offset bit (18) unal,			/* patched to be place to return to after break */
  4   131         4 opcode bit (18) unal init (TRA_code),
  4   132     2 old_instruction bit (36),			/* former occupant, sans relocation */
  4   133     2 symbol_block_offset bit (18) unal,
  4   134     2 location bit (18) unal,
  4   135     2 type fixed bin init (BREAK_BEFORE),
  4   136     2 count fixed bin,
  4   137     2 command_list char (command_list_size refer (break_slot_before.count));
  4   138 
  4   139 dcl 1 break_slot_after aligned based (after_slot_ptr),
  4   140     2 item_type fixed bin init (BREAK_ITEM),
  4   141     2 breakmap_header_offset bit (18) unal,
  4   142     2 statement_item_offset bit (18) unal,
  4   143     2 size fixed bin,
  4   144     2 sequence,
  4   145       3 moved_instruction bit (36),			/* happens before the break occurs */
  4   146       3 moved_descs (3),
  4   147         4 offset bit (18) unal init ((3)0),
  4   148         4 opcode bit (18) unal init ((3) NOP_code),
  4   149       3 word4 bit (36) init (SPRI_wd),
  4   150       3 word5,
  4   151         4 map_seq_offset bit (18) unal,
  4   152         4 opcode bit (18) unal init (TSPLB_code),
  4   153       3 word6,
  4   154         4 slot_offset bit (18) unal,
  4   155         4 opcode bit (18) unal init (NOP_code),
  4   156       3 return,
  4   157         4 offset bit (18) unal,
  4   158         4 opcode bit (18) unal init (TRA_code),
  4   159     2 old_instruction bit (36),			/* former occupant, sans relocation */
  4   160     2 symbol_block_offset bit (18) unal,
  4   161     2 location bit (18) unal,
  4   162     2 type fixed bin init (BREAK_AFTER),
  4   163     2 count fixed bin,
  4   164     2 command_list char (command_list_size refer (break_slot_before.count));
  4   165 
  4   166 
  4   167 /* we need these next two because PL/I wont take size(break_slot_before.sequence) */
  4   168 dcl size_of_after_sequence fixed bin internal static init (8) options (constant);
  4   169 dcl size_of_before_sequence fixed bin internal static init (8)  options (constant);
  4   170 
  4   171 
  4   172 dcl (BREAK_ITEM init (0),
  4   173      STATEMENT_ITEM init (1),
  4   174      SYMBOL_ITEM init (2),				/* will never be used */
  4   175      MACRO_ITEM init (3),				/* not used now */
  4   176      PROCEDURE_ITEM init (4)) fixed bin internal static options (constant);
  4   177 
  4   178 dcl  command_list_size fixed bin (21);
  4   179 
  4   180 dcl (ent, bmp, stp, before_slot_ptr, after_slot_ptr) ptr;
  4   181 
  4   182 dcl  SPRI_wd bit (36) init ("600022254120"b3);		/* spri sp|stack_frame.next_sp,* */
  4   183 
  4   184 dcl (NOP_code init ("011003"b3),
  4   185      TSPLB_code init ("671000"b3),
  4   186      TRA_code init ("710000"b3)) internal static options (constant) bit (18) unal;
  4   187 
  4   188 
  4   189 /* END INCLUDE FILE  ... probe_break_info.incl.pl1 */
      567 
      568 
      569   end probe_seg_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1225.1  probe_seg_mgr_.pl1                >spec>install>MR12.2-1194>probe_seg_mgr_.pl1
554          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
558          2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
563          3    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
567          4    07/15/80  1728.8  probe_break_info.incl.pl1         >ldd>include>probe_break_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CREATE                          000100 automatic       bit(1)                   initial dcl 61 set ref 61* 97*
DONT_CREATE                     000101 automatic       bit(1)                   initial dcl 61 set ref 61* 86*
PROCEDURE_ITEM                         constant        fixed bin(17,0)          initial dcl 4-172 ref 302
P_bmp                                  parameter       pointer                  dcl 53 set ref 127 139* 156 168* 174*
P_code                                 parameter       fixed bin(35,0)          dcl 53 set ref 81 85* 92 96* 102 106* 127 133* 144
                                                                                  148* 156 162* 212*
P_create_sw                            parameter       bit(1)                   dcl 181 ref 178 207
P_ent                                  parameter       pointer                  dcl 53 set ref 127 138* 144 151 156 167* 173*
P_probe_info_ptr                       parameter       pointer                  dcl 53 ref 102 107 111 127 131 144 147 156 160
P_seginfop                             parameter       pointer                  dcl 53 ref 127 132 156 161
SPRI_wd                         000114 automatic       bit(36)                  initial packed unaligned dcl 4-182 set ref 4-182*
add                                                    builtin function         dcl 68 ref 225 407 413
addrel                                                 builtin function         dcl 68 ref 392 465 496 513 529
binary                                                 builtin function         dcl 68 ref 225 230 230 239 243 245 245 407 413 419
                                                                                  419 449 453 492
bit                                                    builtin function         dcl 68 ref 225 239 243 317 407 413
bmp                             000112 automatic       pointer                  dcl 4-180 set ref 139 168 276* 279 287*
bound_create_time       112            based           fixed bin(71,0)          level 2 dcl 3-9 ref 262 310
bounds                  107            based           structure                level 2 in structure "procedure_entry" dcl 4-58
                                                                                  in procedure "probe_seg_mgr_" set ref 322*
bounds                  104            based           structure                level 2 in structure "seg_info" dcl 3-9 in procedure
                                                                                  "probe_seg_mgr_" ref 322
break_map                              based           structure                level 1 dcl 4-34 in procedure "probe_seg_mgr_"
break_map               104            based           bit(18)                  level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 4-58 in procedure "probe_seg_mgr_"
                                                                                  set ref 276 324*
break_segment                          based           structure                level 1 dcl 4-22 set ref 239 239
break_segment_ptr        42            based           pointer                  level 2 dcl 2-8 ref 117 135 150 164
break_segp                      000106 automatic       pointer                  dcl 4-32 set ref 88 98 117* 118 121 123 123 135*
                                                                                  150* 164* 208* 209 217* 219 224 225 225 230* 230
                                                                                  230 235 237 238 239 239 239 243 245* 245 245 264
                                                                                  264 267 325 326 341 341 344 344 374 374 388 405
                                                                                  405 407 407 412 412 413 413 419* 419 419 453 456
                                                                                  461 461 467 472 484 488 488 510 546
chain                     1(18)        based           bit(18)                  level 2 in structure "free_item" packed packed
                                                                                  unaligned dcl 4-52 in procedure "probe_seg_mgr_"
                                                                                  set ref 384* 384 388 400 469* 478 505* 518* 518
                                                                                  521* 526 534* 535* 540 547*
chain                     1(18)        based           bit(18)                  level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 4-58 in procedure "probe_seg_mgr_"
                                                                                  set ref 267 325* 341 344 347 349 350* 350
code                            000214 automatic       fixed bin(35,0)          dcl 187 set ref 208* 210* 217* 218*
com_err_                        000014 constant        entry                    external dcl 78 ref 210
copy_count                      000300 automatic       fixed bin(17,0)          dcl 445 set ref 457* 458 473* 475
copy_overlay                           based           bit(36)                  array dcl 444 set ref 458* 475*
directory                 3            based           char(168)                level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  304*
directory_name            2            based           char(168)                level 3 packed packed unaligned dcl 3-9 ref 304
dirname                         000132 automatic       char(168)                packed unaligned dcl 183 set ref 202* 208* 210* 210
                                                                                  217*
divide                                                 builtin function         dcl 68 ref 225 413
ent                                    parameter       pointer                  dcl 335 in procedure "delete_proc" set ref 332 341
                                                                                  341 344 350 352*
ent                             000110 automatic       pointer                  dcl 4-180 in procedure "probe_seg_mgr_" set ref 138
                                                                                  167 169 173 264* 264* 267 269 269 269 276 279 282*
                                                                                  287* 300* 300 300 302 304 307 308 309 310 312 313
                                                                                  314 315 317 319 320 322 323 324 325 326
entry                    55            based           char(32)                 level 2 packed packed unaligned dcl 4-58 set ref 269
                                                                                  307*
entry_name               54            based           char(32)                 level 3 packed packed unaligned dcl 3-9 ref 269 307
entryname                       000204 automatic       char(32)                 packed unaligned dcl 185 set ref 201* 204* 204 208*
                                                                                  210* 217*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 72 ref 212
fip                             000256 automatic       pointer                  dcl 369 set ref 374* 374* 380 382 384 388 391 391
                                                                                  392* 392 392 395 396 399* 400 400 405* 406 424
first_free_item           4            based           bit(18)                  level 2 packed packed unaligned dcl 4-22 set ref 374
                                                                                  388* 461 472* 484 488 510* 546*
first_macro             103            based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  314*
first_procedure_entry
                          4(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-22 set ref 121
                                                                                  123 264 325 326* 341 341* 344
first_statement         102            based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  312*
first_symbol            102(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  313*
fixed                                                  builtin function         dcl 68 ref 317
free_item                              based           structure                level 1 dcl 4-52
goal_id                         000224 automatic       fixed bin(71,0)          dcl 259 set ref 262* 269
hcs_$initiate                   000024 constant        entry                    external dcl 191 ref 217
hcs_$make_seg                   000026 constant        entry                    external dcl 194 ref 208
hcs_$set_bc_seg                 000016 constant        entry                    external dcl 79 ref 230 245 419
i                               000272 automatic       fixed bin(35,0)          dcl 439 set ref 449* 453 492
identifier                6            based           fixed bin(71,0)          level 2 dcl 4-34 ref 279
ip                              000270 automatic       pointer                  dcl 439 set ref 448* 449 453 456 457 458 465 496 499
                                                                                  501* 504 504 505 509 509 510 513 513 516 516 518
                                                                                  521 529 529 533 533 534 535 546 547 548 548
item                                   based           structure                level 1 dcl 4-46
item_pointer                           parameter       pointer                  dcl 439 ref 436 448
item_type                              based           fixed bin(17,0)          initial level 2 dcl 4-58 set ref 302*
language_type                          based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 3-9 in procedure
                                                                                  "probe_seg_mgr_" ref 323
language_type           113            based           fixed bin(17,0)          level 2 in structure "procedure_entry" dcl 4-58
                                                                                  in procedure "probe_seg_mgr_" set ref 323*
lent                            000244 automatic       pointer                  dcl 336 set ref 344* 344* 347* 349 349 350
lfip                            000260 automatic       pointer                  dcl 370 set ref 373* 384 384 399*
lp                              000276 automatic       pointer                  dcl 439 set ref 460* 469 469 487* 494 496 496 499
                                                                                  499 501 505
map_size                110            based           fixed bin(17,0)          level 2 dcl 3-9 ref 317
mod                                                    builtin function         dcl 68 ref 239 372
multiply                                               builtin function         dcl 68 ref 225 230 230 245 245 413 419 419
name                      1            based           char(8)                  initial level 2 dcl 4-22 set ref 238*
names                     2            based           structure                level 2 dcl 3-9
needed                          000254 automatic       fixed bin(17,0)          dcl 368 set ref 372* 380 382 391 395 406 407
next                            000226 automatic       pointer                  dcl 260 set ref 267* 285
null                                                   builtin function         dcl 68 ref 107 107 113 113 118 118 121 169 174 209
                                                                                  219 287 373 384 460 469 487 494
original_source_ptr      77            based           pointer                  level 3 packed packed unaligned dcl 3-9 ref 319
p                               000274 automatic       pointer                  dcl 439 set ref 461* 461* 465 465 467 473 475* 478
                                                                                  478 488* 492 513 516 518 521 526 529 529 529 529
                                                                                  535* 540 540*
pad                      76            based           fixed bin(71,0)          level 2 dcl 4-58 set ref 309*
pointer                                                builtin function         dcl 68 ref 123 264 267 276 344 349 374 400 405 461
                                                                                  478 488 540
pointers                 76            based           structure                level 2 dcl 3-9
probe_data_$break_segment_suffix
                                000030 external static char(32)                 packed unaligned dcl 197 ref 204
probe_error_$malfunction        000012 constant        entry                    external dcl 75 ref 30 347
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000104 automatic       pointer                  dcl 1-86 set ref 111* 113 117 131* 135 147* 150 160*
                                                                                  164 347*
probe_static_info                      based           structure                level 1 dcl 2-8
procedure_entry                        based           structure                level 1 dcl 4-58 set ref 300 300
rel                                                    builtin function         dcl 68 ref 264 315 319 320 326 341 344 374 449 456
                                                                                  461 467 492 505 510 521 535 546
required                               parameter       fixed bin(17,0)          dcl 365 ref 362 372 372
rtrim                                                  builtin function         dcl 68 ref 204 204
seg_info                               based           structure                level 1 dcl 3-9
seginfop                        000102 automatic       pointer                  dcl 66 set ref 132* 161* 262 269 269 276 304 307 308
                                                                                  310 315 317 319 320 322 323
segname                  64            based           char(32)                 level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 3-9 in procedure "probe_seg_mgr_"
                                                                                  ref 269 308
segname                  65            based           char(32)                 level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 4-58 in procedure "probe_seg_mgr_"
                                                                                  set ref 269 308*
size                      2            based           fixed bin(17,0)          level 2 in structure "item" dcl 4-46 in procedure
                                                                                  "probe_seg_mgr_" set ref 395* 406* 453 457 499 504
                                                                                  509 529 533 548
size                                   based           fixed bin(17,0)          level 2 in structure "free_item" dcl 4-52
                                                                                  in procedure "probe_seg_mgr_" set ref 380 382 391*
                                                                                  391 392 465 473 496 499* 499 504* 509* 513 516*
                                                                                  516 516 529 529* 529 533* 548*
size                                                   builtin function         dcl 68 in procedure "probe_seg_mgr_" ref 239 239 300
                                                                                  300
source_map              105(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  319*
statement_map           104(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  315*
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 3-9 ref 315
statement_map_size      105            based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  317*
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 113 117
                                                                                  135 150 164
subtract                                               builtin function         dcl 68 ref 225 413
symbol_header           106            based           bit(18)                  level 2 packed packed unaligned dcl 4-58 set ref
                                                                                  320*
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 3-9 ref 276 320
time_stamp              100            based           fixed bin(71,0)          level 2 dcl 4-58 set ref 269 279 310*
upper_bound               3            based           bit(18)                  level 2 packed packed unaligned dcl 4-22 set ref
                                                                                  225* 230 230 243* 245 245 412 413* 419 419
user_info_                      000020 constant        entry                    external dcl 189 ref 201
user_info_$homedir              000022 constant        entry                    external dcl 190 ref 202
version                                based           fixed bin(17,0)          initial level 2 dcl 4-22 set ref 224 235 237*
word_count                3(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-22 set ref 225
                                                                                  239* 405 407* 407 412 413 453 456* 467*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BREAK_ITEM                             internal static fixed bin(17,0)          initial dcl 4-172
MACRO_ITEM                             internal static fixed bin(17,0)          initial dcl 4-172
NOP_code                               internal static bit(18)                  initial packed unaligned dcl 4-184
STATEMENT_ITEM                         internal static fixed bin(17,0)          initial dcl 4-172
SYMBOL_ITEM                            internal static fixed bin(17,0)          initial dcl 4-172
TRA_code                               internal static bit(18)                  initial packed unaligned dcl 4-184
TSPLB_code                             internal static bit(18)                  initial packed unaligned dcl 4-184
after_slot_ptr                         automatic       pointer                  dcl 4-180
before_slot_ptr                        automatic       pointer                  dcl 4-180
break_slot_after                       based           structure                level 1 dcl 4-139
break_slot_before                      based           structure                level 1 dcl 4-112
command_list_size                      automatic       fixed bin(21,0)          dcl 4-178
expression_area                        based           area(1024)               dcl 1-95
macro_item                             based           structure                level 1 dcl 4-102
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 3-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
size_of_after_sequence                 internal static fixed bin(17,0)          initial dcl 4-168
size_of_before_sequence                internal static fixed bin(17,0)          initial dcl 4-169
statement_item                         based           structure                level 1 dcl 4-86
stp                                    automatic       pointer                  dcl 4-180
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
allocate_in_breakseg            001357 constant        entry                    internal dcl 362 ref 300
create_breakseg                 000124 constant        entry                    external dcl 92
create_proc                     001200 constant        entry                    internal dcl 292 ref 172
create_procedure_entry          000423 constant        entry                    external dcl 156
delete_proc                     001270 constant        entry                    internal dcl 332 ref 151 282
delete_procedure_entry          000360 constant        entry                    external dcl 144
first_procedure_ptr             000160 constant        entry                    external dcl 102
get_breakseg_ptr                000072 constant        entry                    external dcl 81
get_procedure_entry             000307 constant        entry                    external dcl 127
initialize_breakseg             000511 constant        entry                    internal dcl 178 ref 86 97
probe_seg_mgr_                  000050 constant        entry                    external dcl 26
release_in_breakseg             001536 constant        entry                    internal dcl 436 ref 352
search_for_proc_entry           001115 constant        entry                    internal dcl 253 ref 137 166

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2306        2340    2067        2316
Length      2630    2067        32         253     216           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_seg_mgr_                      298 external procedure  is an external procedure.  
initialize_breakseg                     internal procedure  shares stack frame of external procedure probe_seg_mgr_.  
search_for_proc_entry                   internal procedure  shares stack frame of external procedure probe_seg_mgr_.  
create_proc                             internal procedure  shares stack frame of external procedure probe_seg_mgr_.  
delete_proc                             internal procedure  shares stack frame of external procedure probe_seg_mgr_.  
allocate_in_breakseg                    internal procedure  shares stack frame of external procedure probe_seg_mgr_.  
release_in_breakseg                     internal procedure  shares stack frame of external procedure probe_seg_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_seg_mgr_           000100 CREATE                      probe_seg_mgr_
                         000101 DONT_CREATE                 probe_seg_mgr_
                         000102 seginfop                    probe_seg_mgr_
                         000104 probe_info_ptr              probe_seg_mgr_
                         000106 break_segp                  probe_seg_mgr_
                         000110 ent                         probe_seg_mgr_
                         000112 bmp                         probe_seg_mgr_
                         000114 SPRI_wd                     probe_seg_mgr_
                         000132 dirname                     initialize_breakseg
                         000204 entryname                   initialize_breakseg
                         000214 code                        initialize_breakseg
                         000224 goal_id                     search_for_proc_entry
                         000226 next                        search_for_proc_entry
                         000244 lent                        delete_proc
                         000254 needed                      allocate_in_breakseg
                         000256 fip                         allocate_in_breakseg
                         000260 lfip                        allocate_in_breakseg
                         000270 ip                          release_in_breakseg
                         000272 i                           release_in_breakseg
                         000274 p                           release_in_breakseg
                         000276 lp                          release_in_breakseg
                         000300 copy_count                  release_in_breakseg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
mdfx1               signal_op           shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      hcs_$initiate                 hcs_$make_seg                 hcs_$set_bc_seg
probe_error_$malfunction      user_info_                    user_info_$homedir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           probe_data_$break_segment_suffix




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     61 000040    4  182 000043        26 000047        30 000060        81 000065        85 000106        86 000107
     88 000111        92 000122        96 000140        97 000141        98 000143       102 000154       106 000174
    107 000175       111 000213       113 000216       117 000232       118 000235       121 000252       123 000267
    127 000302       131 000324       132 000330       133 000333       135 000334       137 000337       138 000340
    139 000342       140 000345       144 000354       147 000375       148 000401       150 000402       151 000405
    152 000412       156 000421       160 000440       161 000444       162 000447       164 000450       166 000453
    167 000454       168 000456       169 000461       172 000474       173 000475       174 000477       175 000502
    178 000511       201 000513       202 000524       204 000535       207 000612       208 000617       209 000655
    210 000661       212 000731       213 000734       215 000735       217 000736       218 001000       219 001001
    224 001006       225 001011       230 001025       233 001045       235 001046       237 001050       238 001052
    239 001056       243 001070       245 001075       249 001114       253 001115       262 001116       264 001121
    267 001132       269 001140       276 001154       279 001162       282 001167       285 001171       287 001174
    288 001177       292 001200       300 001201       302 001205       304 001207       307 001214       308 001217
    309 001222       310 001224       312 001226       313 001230       314 001232       315 001234       317 001237
    319 001244       320 001247       322 001252       323 001255       324 001257       325 001261       326 001264
    327 001267       332 001270       341 001272       344 001306       347 001324       349 001337       350 001345
    352 001347       354 001356       362 001357       372 001361       373 001367       374 001371       380 001402
    382 001405       384 001406       388 001417       389 001424       391 001425       392 001427       395 001433
    396 001436       399 001441       400 001443       405 001450       406 001456       407 001460       412 001470
    413 001500       419 001512       424 001532       436 001536       448 001540       449 001543       453 001546
    456 001561       457 001564       458 001566       460 001577       461 001601       465 001612       467 001622
    469 001626       472 001636       473 001640       475 001642       476 001653       478 001654       479 001662
    484 001663       487 001667       488 001671       492 001676       494 001702       496 001706       499 001716
    501 001721       502 001723       504 001724       505 001727       507 001733       509 001734       510 001737
    513 001742       516 001752       518 001754       519 001760       521 001761       523 001765       526 001766
    529 001773       533 002007       534 002012       535 002014       537 002017       540 002020       546 002023
    547 002026       548 002031       549 002033


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
