	COMPILATION LISTING OF SEGMENT im_create_index
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1309.7 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-12-03,Dupuis), approve(86-12-03,PBF7311), audit(86-12-05,Blair),
       11*     install(86-12-09,MR12.0-1237):
       12*     Changed the created area to be a freeing area. im_set_cursor
       13*     expected this to be a freeing area and was getting an out-of-bounds
       14*     when it tried to free something.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* DESCRIPTION
       19*
       20*        Creates an empty index collection in the given file with the fields
       21*   specified in typed_vector_array.  An index collection identifier is
       22*   assigned for referencing this collection which is the element id of the
       23*   collection header in the header for this file.  The index collection header
       24*   (index_header) contains the element_id of the field table for this
       25*   collection.  If there are vectors in the typed_vector_array
       26*   (typed_vector_array.number_of_vectors > 0) the new index collection is
       27*   loaded with these vectors.
       28**/
       29 
       30 /* HISTORY:
       31*Written by Lindsey Spratt, 04/01/82.
       32*  (From the source for rcm_create_collection.)
       33*Modified:
       34*04/22/82 by Matthew Pierret: Changed to use data_mgmt_util_$cv_typed_array_to_table
       35*            instead of dmu_build_field_table.
       36*07/27/82 by Lindsey Spratt:  Added p_number_of_duplication_fields to the
       37*	  calling sequence.  Also, changed to using version 2 of the
       38*	  index_header structure.
       39*08/10/82 by Matthew Pierret:  Changed collection ids from "fixed bin (17)" to
       40*            "bit (36) aligned".
       41*08/19/82 by Lindsey Spratt:  Renamed to create_index, from create_collection
       42*	  (it now conforms with the specification).  Added ability to load
       43*	  the index if any vectors are in the typed_vector_array used to
       44*	  define the fields.
       45*11/01/82 by Lindsey Spratt:  Changed to use the version 3 index_header.  This
       46*	  has the key_count_array in it.
       47*03/23/83 by Lindsey Spratt:  Fixed to use version 2 of the field_table.
       48*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3, to use
       49*            local structures instead of allocated ones where possible, to use
       50*            "file_" instead of "pf_" and check the version in-line.
       51*            Changed to set index_header.number_of_duplication_fields to
       52*            field_table.number_of_fields+1 if the input value of
       53*            p_number_of_duplication_fields is 0.
       54*05/20/84 by Matthew Pierret:  Changed to use new versions of the 
       55*            ordered_esm_info and unblocked_cism_info structures, and to use
       56*            dm_(esm cism)_info.incl.pl1 instead of 
       57*            dm_cm_(esm cism)_info.incl.pl1.
       58*06/12/84 by Matthew Pierret:  Re-named cm_$allocate_element to cm_$put.
       59*10/28/84 by Lindsey L. Spratt:  Changed to use version 4 of the index_header,
       60*            and to separately allocate the new version 2 key_count_array.
       61*            Changed to use the ERROR_RETURN technology.  Changed DEFINE_AREA
       62*            to take an explicit parameter.
       63**/
       64 
       65 /* format: style2,ind3 */
       66 
       67 im_create_index:
       68    proc (p_file_opening_id, p_typed_vector_array_ptr, p_number_of_duplication_fields, p_index_collection_id, p_code);
       69 
       70 /* START OF DECLARATIONS */
       71 /* Parameter */
       72 
       73       dcl	    p_file_opening_id      bit (36) aligned;
       74       dcl	    p_typed_vector_array_ptr
       75 			       ptr;
       76       dcl	    p_number_of_duplication_fields
       77 			       fixed bin (17);
       78       dcl	    p_index_collection_id  bit (36) aligned;
       79       dcl	    p_code	       fixed bin (35);
       80 
       81 /* Automatic */
       82 
       83       dcl	    field_table_id_string  bit (36) aligned init ("0"b);
       84       dcl	    file_opening_id	       bit (36) aligned init ("0"b);
       85       dcl	    index_collection_id    bit (36) aligned init ("0"b);
       86       dcl	    key_count_array_id_string
       87 			       bit (36) aligned init ("0"b);
       88       dcl	    1 local_ordered_esm_info
       89 			       aligned like ordered_esm_info;
       90       dcl	    1 local_unblocked_cism_info
       91 			       aligned like unblocked_cism_info;
       92       dcl	    maximum_element_length fixed bin (35);
       93       dcl	    work_area_ptr	       ptr;
       94       dcl	    cursor_ptr	       ptr;
       95 
       96 /* Based */
       97 
       98       dcl	    work_area	       area (sys_info$max_seg_size) based (work_area_ptr);
       99 
      100 /* Builtin */
      101 
      102       dcl	    (addr, size, currentsize, null, string)
      103 			       builtin;
      104 
      105 /* Condition */
      106 
      107       dcl	    cleanup	       condition;
      108 
      109 /* Constant */
      110 
      111       dcl	    myname	       init ("im_create_index") char (32) varying int static options (constant);
      112       dcl	    HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36) aligned int static options (constant);
      113       dcl	    BITS_PER_WORD	       init (36) fixed bin int static options (constant);
      114 
      115 /* Entry */
      116 
      117       dcl	    data_format_util_$cv_typed_array_to_table
      118 			       entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
      119       dcl	    define_area_	       entry (ptr, fixed bin (35));
      120       dcl	    release_area_	       entry (ptr);
      121       dcl	    sub_err_	       entry () options (variable);
      122 
      123 /* External */
      124 
      125       dcl	    sys_info$max_seg_size  ext fixed bin (35);
      126       dcl	    error_table_$unimplemented_version
      127 			       ext fixed bin (35);
      128 
      129 /* END OF DECLARATIONS */
      130 
      131       p_code = 0;
      132       file_opening_id = p_file_opening_id;
      133       typed_vector_array_ptr = p_typed_vector_array_ptr;
      134 
      135       on cleanup call FINISH ();
      136 
      137       call DEFINE_AREA (work_area_ptr);
      138 
      139       ft_length_of_field_names, ft_number_of_fields = 0;	/* So compiler won't complain */
      140 
      141       call data_format_util_$cv_typed_array_to_table (typed_vector_array_ptr, work_area_ptr, field_table_ptr,
      142 	 maximum_element_length, p_code);
      143       if p_code ^= 0
      144       then call ERROR_RETURN (p_code);
      145 
      146       call CHECK_VERSION (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      147 
      148       local_unblocked_cism_info.version = CISM_INFO_VERSION_1;
      149       local_unblocked_cism_info.type = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD;
      150       local_unblocked_cism_info.must_be_zero = 0;
      151 
      152       local_ordered_esm_info.version = ESM_INFO_VERSION_1;
      153       local_ordered_esm_info.type = ORDERED_ELEMENT_STORAGE_METHOD;
      154       local_ordered_esm_info.flags.fixed_length = "0"b;
      155       local_ordered_esm_info.flags.pad = "0"b;
      156       local_ordered_esm_info.maximum_element_length = maximum_element_length;
      157 
      158       call collection_manager_$create_collection (file_opening_id, addr (local_unblocked_cism_info),
      159 	 addr (local_ordered_esm_info), index_collection_id, p_code);
      160       if p_code ^= 0
      161       then call ERROR_RETURN (p_code);
      162 
      163       call collection_manager_$put (file_opening_id, HEADER_COLLECTION_ID, field_table_ptr, length (unspec (field_table)),
      164 	 field_table_id_string, (0), p_code);
      165       if p_code ^= 0
      166       then call ERROR_RETURN (p_code);
      167 
      168       kca_number_of_counts = field_table.number_of_fields;
      169       alloc key_count_array in (work_area);
      170       key_count_array.version = KEY_COUNT_ARRAY_VERSION_2;
      171       key_count_array.count = 0;
      172 
      173       call collection_manager_$put (file_opening_id, HEADER_COLLECTION_ID, key_count_array_ptr,
      174 	 length (unspec (key_count_array)), key_count_array_id_string, (0), p_code);
      175       if p_code ^= 0
      176       then call ERROR_RETURN (p_code);
      177 
      178       alloc index_header in (work_area);
      179       index_header.version = INDEX_HEADER_VERSION_4;
      180       unspec (index_header.field_table_element_id) = field_table_id_string;
      181       if p_number_of_duplication_fields = 0
      182       then index_header.number_of_duplication_fields = field_table.number_of_fields + 1;
      183       else index_header.number_of_duplication_fields = p_number_of_duplication_fields;
      184       index_header.root_id = 0;
      185       unspec (index_header.key_count_array_element_id) = key_count_array_id_string;
      186       index_header.pad1 = "0"b;
      187       index_header.pad2 = "0"b;
      188 
      189       call collection_manager_$put_header (file_opening_id, index_collection_id, index_header_ptr,
      190 	 length (unspec (index_header)), p_code);
      191       if p_code ^= 0
      192       then call ERROR_RETURN (p_code);
      193 
      194       if typed_vector_array.number_of_vectors > 0
      195       then
      196          do;
      197 	  call index_manager_$create_cursor (file_opening_id, index_collection_id, work_area_ptr, cursor_ptr, p_code);
      198 	  if p_code ^= 0
      199 	  then call ERROR_RETURN (p_code);
      200 
      201 	  call index_manager_$put_key_array (typed_vector_array_ptr, cursor_ptr, p_code);
      202 	  if p_code ^= 0
      203 	  then call ERROR_RETURN (p_code);
      204          end;
      205 
      206       call FINISH;
      207 
      208       p_index_collection_id = index_collection_id;
      209 
      210 MAIN_RETURN:
      211       return;
      212 
      213 
      214 
      215 FINISH:
      216    proc;
      217       if work_area_ptr ^= null
      218       then call release_area_ (work_area_ptr);
      219 
      220    end FINISH;
      221 
      222 ERROR_RETURN:
      223    proc (er_p_code);
      224       dcl	    er_p_code	       fixed bin (35) parameter;
      225 
      226       call FINISH ();
      227       p_code = er_p_code;
      228       goto MAIN_RETURN;
      229 
      230    end ERROR_RETURN;
      231 
      232 CHECK_VERSION:
      233    proc (p_expected_version, p_received_version, p_structure_name);
      234       dcl	    (p_expected_version, p_received_version)
      235 			       char (8) aligned parameter;
      236       dcl	    p_structure_name       char (*) parameter;
      237 
      238       if p_expected_version ^= p_received_version
      239       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      240 	      "^/Expected version ^a of the ^a structure.  
      241 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      242    end CHECK_VERSION;
      243 
      244 DEFINE_AREA:
      245    proc (da_p_work_area_ptr);
      246       dcl	    da_p_work_area_ptr     ptr parameter;
      247 
      248       dcl	    1 da_area_info	       aligned like area_info;
      249       dcl	    da_code	       fixed bin (35) init (0);
      250 
      251       da_area_info.version = area_info_version_1;
      252       string (da_area_info.control) = "0"b;
      253       da_area_info.control.extend = "1"b;
      254       da_area_info.owner = myname;
      255       da_area_info.size = sys_info$max_seg_size;
      256       da_area_info.areap = null;
      257 
      258       call define_area_ (addr (da_area_info), da_code);
      259       if da_code ^= 0
      260       then call ERROR_RETURN (da_code);
      261 
      262       da_p_work_area_ptr = da_area_info.areap;
      263 
      264    end DEFINE_AREA;
      265 
  1     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  1     2 /* format: style3 */
  1     3 
  1     4 /* These constants are to be used for the flags argument of sub_err_ */
  1     5 /* They are just "string (condition_info_header.action_flags)" */
  1     6 
  1     7 declare	(
  1     8 	ACTION_CAN_RESTART	init (""b),
  1     9 	ACTION_CANT_RESTART init ("1"b),
  1    10 	ACTION_DEFAULT_RESTART
  1    11 			init ("01"b),
  1    12 	ACTION_QUIET_RESTART
  1    13 			init ("001"b),
  1    14 	ACTION_SUPPORT_SIGNAL
  1    15 			init ("0001"b)
  1    16 	)		bit (36) aligned internal static options (constant);
  1    17 
  1    18 /* End include file */
      266 
      267 
  2     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
  2     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
  2     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
  2     9*     beginning of the structure to the element key_count_array.count in
  2    10*     characters. Using this it is possible to calculate the key_count_array_ptr
  2    11*     given the "addr (key_count_array.count (0))".
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 
  2    15 /* DESCRIPTION:
  2    16*
  2    17*          The key_count_array holds counts of the number of unique key values
  2    18*     in an index.  These values are used by the search optimization done by
  2    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
  2    20*     number of keys in the index which have at least fields 1 through N
  2    21*     having the same value as another key in the index, i.e. count(N)
  2    22*     is the number of partial duplicates with number of partial
  2    23*     duplication fields equal to N.
  2    24*
  2    25**/
  2    26 
  2    27 /* HISTORY:
  2    28*
  2    29*Written by Lindsey Spratt, 11/09/82.
  2    30*Modified:
  2    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
  2    32*	  Added a description, fixed the history section.
  2    33**/
  2    34 
  2    35 /* format: style2,ind3 */
  2    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
  2    37 	     2 version	      char (8) aligned,
  2    38 	     2 number_of_counts   fixed bin (17) unal,
  2    39 	     2 pad	      bit (18) unal,
  2    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
  2    41 			      bin (35) aligned;
  2    42 
  2    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
  2    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
  2    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
  2    46 			      init (12) fixed bin internal static options (constant);
  2    47 
  2    48      dcl	   key_count_array_ptr    ptr init (null);
  2    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
  2    50 
  2    51 
  2    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      268 
      269 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  3     7 
  3     8 /* Written by Lindsey Spratt, 03/04/82.
  3     9*Modified:
  3    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  3    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  3    12*	  the print_vector value (char varying), ptr to the typed_vector
  3    13*	  value location, and a code. cv_to_print now takes ptr to the
  3    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  3    15*	  (char(*) varying), the maximum allowed length for the print_vector
  3    16*	  value, a temp_seg to put the value in if its to big to fit into
  3    17*	  the print_vector, and a code.
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  3    22 	     2 version	      fixed bin (35),
  3    23 	     2 number_of_dimensions
  3    24 			      fixed bin (17),
  3    25 	     2 number_of_vectors  fixed bin (17),
  3    26 	     2 number_of_vector_slots
  3    27 			      fixed bin (17),
  3    28 	     2 maximum_dimension_name_length
  3    29 			      fixed bin (17),
  3    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  3    31 	       3 name	      char (tva_maximum_dimension_name_length
  3    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  3    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  3    34 						/* temp_seg_ptr, max_length_for_print_value, */
  3    35 						/* print_value, code) */
  3    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  3    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  3    38 						/* print_value_ptr, typed_value_ptr, code) */
  3    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  3    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  3    41 			      pointer;
  3    42 
  3    43      dcl	   typed_vector_array_ptr ptr;
  3    44      dcl	   tva_number_of_vector_slots
  3    45 			      fixed bin;
  3    46      dcl	   tva_number_of_dimensions
  3    47 			      fixed bin;
  3    48      dcl	   tva_maximum_dimension_name_length
  3    49 			      fixed bin;
  3    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  3    51 			      fixed bin (35) int static options (constant) init (2);
  3    52 
  3    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      270 
      271 
  4     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          The index_header structure is stored in the header element of an
  4     6*     index collection and describes basic information about the index.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*
  4    11*Written by Lindsey Spratt, 04/02/82.
  4    12*Modified:
  4    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  4    14*	  count(0) is the number of keys in the index.  count(N) is the
  4    15*	  number of keys in the index which have at least fields 1 through N
  4    16*	  having the same value as another key in the index, i.e. count(N)
  4    17*	  is the number of partial duplicates with number of partial
  4    18*	  duplication fields equal to N.
  4    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  4    20*	  Replaced the key_count_array with a key_count_array_element_id.
  4    21*	  Changed the version field to char(8).  Aligned the structure.
  4    22**/
  4    23 
  4    24 /* format: style2,ind3 */
  4    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  4    26 	     2 version	      char (8) aligned,
  4    27 	     2 field_table_element_id
  4    28 			      like element_id,
  4    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  4    30 	     2 pad1	      bit (12) unaligned,
  4    31 	     2 number_of_duplication_fields
  4    32 			      fixed bin (17) unal,
  4    33 	     2 pad2	      bit (18) unal,
  4    34 	     2 key_count_array_element_id
  4    35 			      like element_id;
  4    36 
  4    37      dcl	   index_header_ptr	      ptr;
  4    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  4    39 
  4    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      272 
      273 
  5     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          The field_table describes the layout of a set of fields in a
  5     6*     formatted data string.  Such a string is the stored representation of a
  5     7*     record or a key.  Fields are placed side-by-side in the string in the
  5     8*     order they appear in the field_table.field array.  The string is divided
  5     9*     into the fixed portion and the varying portion.  In the fixed portion
  5    10*     appear fixed-length fields and fixed-size length-fields for
  5    11*     varying-length fields.  In the varying portion appear varying length
  5    12*     fields.  The length-field for a varying-length field contains the length
  5    13*     of the field values either in bits or in characters, depending on the
  5    14*     data type of the field.
  5    15**/
  5    16 
  5    17 /* HISTORY:
  5    18*Written by Matthew Pierret, 04/01/82.
  5    19*Modified:
  5    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  5    21*	  that if the field is varying, its length is expressed in
  5    22*	  bytes/characters.
  5    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  5    24*	  of 17, changed version to 2, changed version field to char(8) from
  5    25*	  fixed bin (17).
  5    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  5    27*            put field names in one string (field_names) at the end of the 
  5    28*            structure. Added field.location_of_name and field.length_of_name
  5    29*            for locating the field name in field_names. Aligned all "fixed bin"
  5    30*            structure elements.  Changed maximum_field_name_length to 
  5    31*            length_of_field_names.
  5    32**/
  5    33 
  5    34 /* format: style2 */
  5    35 
  5    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  5    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  5    38 	     2 number_of_fields   fixed bin (17),
  5    39 	     2 length_of_field_names
  5    40 			      fixed bin (17),	/* length of field_names in characters */
  5    41 	     2 location_of_first_varying_field
  5    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  5    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  5    44 	       3 flags	      aligned,
  5    45 	         4 descriptor_is_varying
  5    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  5    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  5    48 						/* containing the id of the element in which the descriptor is stored. */
  5    49 	         4 length_is_in_characters
  5    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  5    51 						/* in characters instead of in bits */
  5    52 	         4 must_be_zero   bit (34) unal,
  5    53 	       3 descriptor	      bit (36) aligned,
  5    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  5    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  5    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  5    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  5    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  5    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  5    60 	       3 varying_field_index
  5    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  5    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  5    63 
  5    64 
  5    65      dcl	   field_table_ptr	      ptr;
  5    66      dcl	   ft_length_of_field_names
  5    67 			      fixed bin;
  5    68      dcl	   ft_number_of_fields    fixed bin;
  5    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  5    70 
  5    71 dcl field_name char (field_name_length) based (field_name_ptr);
  5    72 
  5    73 dcl field_name_length fixed bin;
  5    74 dcl field_name_ptr ptr;
  5    75 
  5    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      274 
      275 
  6     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  6     6*     structures, as well as constants relevant to control interval storage
  6     7*     management.  These structures and constants are used by several managers.
  6     8*     The structures each describe a method of control interval storage 
  6     9*     management.
  6    10**/
  6    11 
  6    12 /* HISTORY:
  6    13*
  6    14*Written 02/07/82 by Matthew Pierret.
  6    15*Modified:
  6    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  6    17*            a version string.
  6    18**/
  6    19 
  6    20 /* format: style2 */
  6    21 
  6    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  6    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  6    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  6    25 	     2 number_of_control_intervals_per_block
  6    26 			      fixed bin (17);
  6    27 
  6    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  6    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  6    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  6    31 	     2 must_be_zero	      fixed bin (17);
  6    32 
  6    33      dcl	   blocked_cism_info_ptr  ptr;
  6    34      dcl	   unblocked_cism_info_ptr
  6    35 			      ptr;
  6    36 
  6    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  6    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  6    39 			      fixed bin init (1) internal static options (constant);
  6    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  6    41 			      fixed bin init (2) internal static options (constant);
  6    42 
  6    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      276 
      277 
  7     1 /* BEGIN INCLUDE FILE dm_esm_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the basic_esm_info and ordered_esm_info
  7     6*     structures, as well as constants used to distinguish element storage
  7     7*     methods.  They are used by several managers to describe the type of
  7     8*     element storage management to be used in a collection.
  7     9**/
  7    10 
  7    11 /* HISTORY:
  7    12*Written 02/07/82 by Matthew Pierret.
  7    13*Modified:
  7    14*05/17/84 by Matthew Pierret:  Changed name from dm_cm_esm_info (the cm_
  7    15*            dropped because the include file is used by multiple managers),
  7    16*            to align structure elements and to add a version string.
  7    17**/
  7    18 
  7    19 /* format: style2 */
  7    20 
  7    21      dcl	   1 basic_esm_info	      based (basic_esm_info_ptr) aligned,
  7    22 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  7    23 	     2 type	      fixed bin (17) init (BASIC_ELEMENT_STORAGE_METHOD),
  7    24 	     2 flags	      aligned,
  7    25 	       3 threaded	      bit (1) unal,
  7    26 	       3 fixed_length     bit (1) unal,
  7    27 	       3 pad	      bit (34) unal,
  7    28 	     2 maximum_element_length
  7    29 			      fixed bin (35);
  7    30 
  7    31      dcl	   1 ordered_esm_info     based (ordered_esm_info_ptr) aligned,
  7    32 	     2 version	      char (8) aligned init (ESM_INFO_VERSION_1),
  7    33 	     2 type	      fixed bin (17) init (ORDERED_ELEMENT_STORAGE_METHOD),
  7    34 	     2 flags	      aligned,
  7    35 	       3 fixed_length     bit (1) unal,
  7    36 	       3 pad	      bit (35) unal,
  7    37 	     2 maximum_element_length
  7    38 			      fixed bin (35);
  7    39 
  7    40      dcl	   basic_esm_info_ptr     ptr;
  7    41      dcl	   ordered_esm_info_ptr   ptr;
  7    42 
  7    43      dcl	   ESM_INFO_VERSION_1     init ("ESMinfo1") char (8) aligned internal static options (constant);
  7    44      dcl	   BASIC_ELEMENT_STORAGE_METHOD
  7    45 			      fixed bin init (1) internal static options (constant);
  7    46      dcl	   ORDERED_ELEMENT_STORAGE_METHOD
  7    47 			      fixed bin init (2) internal static options (constant);
  7    48 
  7    49 
  7    50 /* END INCLUDE FILE dm_esm_info.incl.pl1 */
      278 
      279 
  8     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*     This include file contains declarations of all collection_manager_ 
  8     5*     entrypoints.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret 
  8    10*Modified:
  8    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  8    12*	  allocate_control_interval operation to be unaligned, as well as
  8    13*	  unsigned.
  8    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  8    15*            removed the beginning_location parameter from the put_element
  8    16*            operation. Added the create_page_file_operation.
  8    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  8    18*            wherever collection_id was required.
  8    19*            Also changed the control_interval_id parameter of the 
  8    20*            allocate_control_interval operation back to be aligned. So there.
  8    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  8    22*            added the argument file_create_info_ptr to $create_file.
  8    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  8    24*	  include the zero_on_free bit.
  8    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  8    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  8    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  8    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  8    29*            cm_$put_unprotected_header.
  8    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  8    31*             $simple_get_buffered_element.
  8    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  8    33*            parameter for specifying absolute/relative nature of search.
  8    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  8    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  8    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  8    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  8    38*            delete_from_ci_buffer.
  8    39*            Re-named *_buffered_ci to =_ci_buffer.
  8    40*            get entries.
  8    41*            modify entries.
  8    42*            Changed calling sequence of modify entries to have a ptr/length
  8    43*            instead of length/ptr parameter pair.
  8    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  8    45**/
  8    46 
  8    47 /* This include file contains declarations of collection_manager_ entrypoints */
  8    48 
  8    49 /* format: style2,ind3 */
  8    50      dcl	   collection_manager_$allocate_control_interval
  8    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    52      dcl	   collection_manager_$compact_control_interval
  8    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  8    54      dcl	   collection_manager_$create_collection
  8    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8    56      dcl	   collection_manager_$create_file
  8    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  8    58      dcl	   collection_manager_$destroy_collection
  8    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8    60      dcl	   collection_manager_$free_control_interval
  8    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  8    62 			      fixed bin (35));
  8    63 
  8    64      dcl	   collection_manager_$delete
  8    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    66 			      fixed bin (35));
  8    67      dcl	   collection_manager_$delete_from_ci_buffer
  8    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    69 			      fixed bin (35));
  8    70 
  8    71      dcl	   collection_manager_$get
  8    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    74      dcl	   collection_manager_$get_control_interval_ptr
  8    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  8    76 			      fixed bin (35));
  8    77      dcl	   collection_manager_$get_from_ci_buffer
  8    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    80      dcl	   collection_manager_$get_by_ci_ptr
  8    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  8    83      dcl	   collection_manager_$get_header
  8    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  8    85 			      ptr, fixed bin (35), fixed bin (35));
  8    86      dcl	   collection_manager_$get_id
  8    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  8    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    89      dcl	   collection_manager_$get_portion
  8    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8    92 			      fixed bin (35), fixed bin (35));
  8    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  8    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8    96 			      fixed bin (35));
  8    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  8    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   collection_manager_$modify
  8   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   103 			      fixed bin (35), fixed bin (35));
  8   104      dcl	   collection_manager_$modify_unprotected
  8   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   106 			      fixed bin (35), fixed bin (35));
  8   107      dcl	   collection_manager_$modify_in_ci_buffer
  8   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   109 			      fixed bin (35), fixed bin (35));
  8   110      dcl	   collection_manager_$modify_portion
  8   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  8   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   113      dcl	   collection_manager_$postcommit_increments
  8   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   115      dcl	   collection_manager_$put
  8   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   117 			      fixed bin (35), fixed bin (35));
  8   118      dcl	   collection_manager_$put_in_ci_buffer
  8   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   120 			      fixed bin (35), fixed bin (35));
  8   121      dcl	   collection_manager_$put_header
  8   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   123      dcl	   collection_manager_$put_unprotected_header
  8   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   125 
  8   126      dcl	   collection_manager_$replace_ci_buffer
  8   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   128 			      fixed bin (35));
  8   129      dcl	   collection_manager_$setup_ci_buffer
  8   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   131 			      fixed bin (35));
  8   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  8   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   134 			      fixed bin (35));
  8   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  8   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   137 			      fixed bin (35));
  8   138 
  8   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      280 
      281 
  9     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  9     2 
  9     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  9     4 
  9     5 dcl  area_infop ptr;
  9     6 
  9     7 dcl 1 area_info aligned based (area_infop),
  9     8     2 version fixed bin,				/* version number for this structure is 1 */
  9     9     2 control aligned like area_control,		/* control bits for the area */
  9    10     2 owner char (32) unal,				/* creator of the area */
  9    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  9    12     2 size fixed bin (18),				/* size of the area in words */
  9    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  9    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  9    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  9    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  9    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  9    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  9    19 
  9    20 dcl 1 area_control aligned based,
  9    21     2 extend bit (1) unal,				/* says area is extensible */
  9    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  9    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  9    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  9    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  9    26     2 system bit (1) unal,				/* says area is managed by system */
  9    27     2 pad bit (30) unal;
  9    28 
  9    29 /* END INCLUDE FILE area_info.incl.pl1 */
      282 
      283 
 10     1 /* BEGIN INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*          This include file has all of the declarations for the index_manager_
 10     6*     external interface.  It is useful for programs which are making extensive
 10     7*     use of the index_manager_ to include this include file rather than
 10     8*     individually declaring each of the entries.
 10     9*     
 10    10**/
 10    11 
 10    12 /* HISTORY:
 10    13*
 10    14*Written by Lindsey Spratt, 06/25/82.
 10    15*Modified:
 10    16*07/28/82 by Lindsey Spratt: Extended the create_collection entry calling
 10    17*	  sequence to include the number_of_duplication_fields.
 10    18*08/10/82 by Matthew Pierret: Changed the create_collection entry calling 
 10    19*            sequence to return a "bit (36) aligned" collection id instead of
 10    20*            "fixed bin (17)".  Changed create_cursor calling sequence likewise.
 10    21*08/19/82 by Lindsey Spratt:  Renamed create_collection to create_index. Added
 10    22*	  the put_key_array entry.  Added the id_list_ptr to the get_key
 10    23*	  entry.  Added the create_subset_index entry.
 10    24*08/23/82 by Lindsey Spratt:  Added the position_cursor entry.
 10    25*09/27/82 by Lindsey Spratt:  Added the get_count and get_duplicate_key_count
 10    26*	  entries.
 10    27*11/09/82 by Lindsey Spratt:  Added ptr to get_key for the interval_list.
 10    28*	  Changed get_duplicate_key_count to get_key_count_array.
 10    29*05/31/83 by Matthew Pierret: Added $destroy_index and $destroy_cursor.
 10    30*05/02/84 by Lee Baldwin:  Renamed $get_count to $get_key_count_by_spec.
 10    31*10/23/84 by Lindsey L. Spratt:  Addressed auditing comments - alphabetized
 10    32*            entries, fixed $create_index to use "fixed bin (17)" instead of
 10    33*            just "fixed bin", added a description section.
 10    34**/
 10    35 
 10    36 /* format: style2,ind3 */
 10    37 
 10    38      dcl	   index_manager_$create_cursor entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 10    39      dcl	   index_manager_$create_index entry (bit (36) aligned, ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 10    40      dcl	   index_manager_$create_subset_index entry (ptr, bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10    41      dcl	   index_manager_$delete_key entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 10    42      dcl	   index_manager_$destroy_cursor entry (ptr, fixed bin (35));
 10    43      dcl	   index_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 10    44      dcl	   index_manager_$get_key entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 10    45      dcl	   index_manager_$get_key_count_array entry (ptr, ptr, ptr, fixed bin (35));
 10    46      dcl	   index_manager_$get_key_count_by_spec entry (ptr, ptr, fixed bin (35), fixed bin (35));
 10    47      dcl	   index_manager_$position_cursor entry (ptr, ptr, ptr, fixed bin (35));
 10    48      dcl	   index_manager_$put_key entry (ptr, ptr, fixed bin (35));
 10    49      dcl	   index_manager_$put_key_array entry (ptr, ptr, fixed bin (35));
 10    50 
 10    51 /* END INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
      284 
      285 
 11     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*
 11     5*        Contains the declaration of an element identifier.  Element
 11     6*   identifiers consist of two parts, the id (number) of the control interval
 11     7*   in which the element resides, and the index into the slot table of
 11     8*   the element in the control interval.  The declaration of the element_id 
 11     9*   structure reflects this division of the element identifier.  The structure 
 11    10*   is based on the automatic bit string element_id_string because programs
 11    11*   generally pass bit strings (element_id_string) to each other, then 
 11    12*   interpret the bit string by overlaying the element_id structure ony if
 11    13*   it is necessary to access the parts of the id.  Basing element_id on
 11    14*   addr(element_id_string) instead of on a pointer removes the necessity
 11    15*   for always setting that pointer explicitly and guarantees that changes
 11    16*   made to the string or structure do not get inconsistent.
 11    17*
 11    18*   Changes made to element_id must also be made to datum_id, declared in 
 11    19*   dm_cm_datum.incl.pl1.
 11    20**/
 11    21 
 11    22 /* HISTORY:
 11    23*Written by Matthew Pierret, 04/01/82.
 11    24*Modified:
 11    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
 11    26**/
 11    27 
 11    28 /* format: style2,ind3,ll79 */
 11    29 
 11    30      dcl	   element_id_string      bit (36) aligned;
 11    31 
 11    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
 11    33 	     2 control_interval_id
 11    34 			      fixed bin (24) unal unsigned,
 11    35 	     2 index	      fixed bin (12) unal unsigned;
 11    36 
 11    37 
 11    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      286 
      287    end im_create_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1304.8  im_create_index.pl1               >spec>install>MR12.1-1020>im_create_index.pl1
266          1    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
268          2    04/02/87  1300.6  dm_key_count_array.incl.pl1       >spec>install>MR12.1-1020>dm_key_count_array.incl.pl1
270          3    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
272          4    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
274          5    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
276          6    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
278          7    01/07/85  0858.5  dm_esm_info.incl.pl1              >ldd>include>dm_esm_info.incl.pl1
280          8    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
282          9    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
284         10    01/07/85  0858.8  dm_idxmgr_entry_dcls.incl.pl1     >ldd>include>dm_idxmgr_entry_dcls.incl.pl1
286         11    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000023 constant        bit(36)                  initial dcl 1-7 set ref 238*
CISM_INFO_VERSION_1             000002 constant        char(8)                  initial dcl 6-37 ref 90 148
ESM_INFO_VERSION_1              000000 constant        char(8)                  initial dcl 7-43 ref 88 152
FIELD_TABLE_VERSION_3           000004 constant        char(8)                  initial dcl 5-69 set ref 146*
HEADER_COLLECTION_ID            000035 constant        bit(36)                  initial dcl 112 set ref 163* 173*
INDEX_HEADER_VERSION_4          000006 constant        char(8)                  initial dcl 4-38 ref 179
KEY_COUNT_ARRAY_VERSION_2       000010 constant        char(8)                  initial dcl 2-43 ref 170
ORDERED_ELEMENT_STORAGE_METHOD         constant        fixed bin(17,0)          initial dcl 7-46 ref 88 153
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 6-40 ref 90 149
addr                                                   builtin function         dcl 102 ref 158 158 158 158 258 258
area_control                           based           structure                level 1 dcl 9-20
area_info                              based           structure                level 1 dcl 9-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 9-3 ref 251
areap                    16     000170 automatic       pointer                  level 2 dcl 248 set ref 256* 262
cleanup                         000122 stack reference condition                dcl 107 ref 135
collection_manager_$create_collection
                                000024 constant        entry                    external dcl 8-54 ref 158
collection_manager_$put         000026 constant        entry                    external dcl 8-115 ref 163 173
collection_manager_$put_header  000030 constant        entry                    external dcl 8-121 ref 189
control                   1     000170 automatic       structure                level 2 dcl 248 set ref 252*
count                     3            based           fixed bin(35,0)          array level 2 dcl 2-36 set ref 171*
cursor_ptr                      000120 automatic       pointer                  dcl 94 set ref 197* 201*
da_area_info                    000170 automatic       structure                level 1 dcl 248 set ref 258 258
da_code                         000214 automatic       fixed bin(35,0)          initial dcl 249 set ref 249* 258* 259 259*
da_p_work_area_ptr                     parameter       pointer                  dcl 246 set ref 244 262*
data_format_util_$cv_typed_array_to_table
                                000010 constant        entry                    external dcl 117 ref 141
define_area_                    000012 constant        entry                    external dcl 119 ref 258
element_id                             based           structure                level 1 dcl 11-32
er_p_code                              parameter       fixed bin(35,0)          dcl 224 ref 222 227
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 126 set ref 238*
extend                    1     000170 automatic       bit(1)                   level 3 packed unaligned dcl 248 set ref 253*
field_table                            based           structure                level 1 dcl 5-36 set ref 163 163
field_table_element_id
                          2            based           structure                level 2 dcl 4-25 set ref 180*
field_table_id_string           000100 automatic       bit(36)                  initial dcl 83 set ref 83* 163* 180
field_table_ptr                 000140 automatic       pointer                  dcl 5-65 set ref 141* 146 163* 163 163 168 181
file_opening_id                 000101 automatic       bit(36)                  initial dcl 84 set ref 84* 132* 158* 163* 173* 189*
                                                                                  197*
fixed_length              3     000104 automatic       bit(1)                   level 3 packed unaligned dcl 88 set ref 154*
flags                     3     000104 automatic       structure                level 2 dcl 88
ft_length_of_field_names        000142 automatic       fixed bin(17,0)          dcl 5-66 set ref 139*
ft_number_of_fields             000143 automatic       fixed bin(17,0)          dcl 5-68 set ref 139*
index_collection_id             000102 automatic       bit(36)                  initial dcl 85 set ref 85* 158* 189* 197* 208
index_header                           based           structure                level 1 dcl 4-25 set ref 178 189 189
index_header_ptr                000136 automatic       pointer                  dcl 4-37 set ref 178* 179 180 181 183 184 185 186
                                                                                  187 189* 189 189
index_manager_$create_cursor    000032 constant        entry                    external dcl 10-38 ref 197
index_manager_$put_key_array    000034 constant        entry                    external dcl 10-49 ref 201
kca_number_of_counts            000132 automatic       fixed bin(17,0)          initial dcl 2-49 set ref 168* 169 169 2-49*
key_count_array                        based           structure                level 1 dcl 2-36 set ref 169 173 173
key_count_array_element_id
                          5            based           structure                level 2 dcl 4-25 set ref 185*
key_count_array_id_string       000103 automatic       bit(36)                  initial dcl 86 set ref 86* 173* 185
key_count_array_ptr             000130 automatic       pointer                  initial dcl 2-48 set ref 169* 170 171 173* 173 173
                                                                                  2-48*
length_of_field_names
                          3            based           fixed bin(17,0)          level 2 dcl 5-36 ref 163 163
local_ordered_esm_info          000104 automatic       structure                level 1 dcl 88 set ref 158 158
local_unblocked_cism_info       000111 automatic       structure                level 1 dcl 90 set ref 158 158
maximum_element_length
                          4     000104 automatic       fixed bin(35,0)          level 2 in structure "local_ordered_esm_info" dcl 88
                                                                                  in procedure "im_create_index" set ref 156*
maximum_element_length          000115 automatic       fixed bin(35,0)          dcl 92 in procedure "im_create_index" set ref 141*
                                                                                  156
must_be_zero              3     000111 automatic       fixed bin(17,0)          level 2 dcl 90 set ref 150*
myname                          000012 constant        varying char(32)         initial dcl 111 set ref 238* 254
null                                                   builtin function         dcl 102 ref 2-48 217 238 238 256
number_of_counts          2            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-36 set ref 169* 171
                                                                                  173 173
number_of_duplication_fields
                          4            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-25 set ref 181* 183*
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 5-36 ref 163 163 163 163 168 181
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 3-21 ref 194
ordered_esm_info                       based           structure                level 1 dcl 7-31
owner                     2     000170 automatic       char(32)                 level 2 packed unaligned dcl 248 set ref 254*
p_code                                 parameter       fixed bin(35,0)          dcl 79 set ref 67 131* 141* 143 143* 158* 160 160*
                                                                                  163* 165 165* 173* 175 175* 189* 191 191* 197* 198
                                                                                  198* 201* 202 202* 227*
p_expected_version                     parameter       char(8)                  dcl 234 set ref 232 238 238*
p_file_opening_id                      parameter       bit(36)                  dcl 73 ref 67 132
p_index_collection_id                  parameter       bit(36)                  dcl 78 set ref 67 208*
p_number_of_duplication_fields         parameter       fixed bin(17,0)          dcl 76 ref 67 181 183
p_received_version                     parameter       char(8)                  dcl 234 set ref 232 238 238*
p_structure_name                       parameter       char                     unaligned dcl 236 set ref 232 238*
p_typed_vector_array_ptr               parameter       pointer                  dcl 74 ref 67 133
pad                       3(01) 000104 automatic       bit(35)                  level 3 packed unaligned dcl 88 set ref 155*
pad1                      3(24)        based           bit(12)                  level 2 packed unaligned dcl 4-25 set ref 186*
pad2                      4(18)        based           bit(18)                  level 2 packed unaligned dcl 4-25 set ref 187*
release_area_                   000014 constant        entry                    external dcl 120 ref 217
root_id                   3            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-25 set ref
                                                                                  184*
size                     13     000170 automatic       fixed bin(18,0)          level 2 dcl 248 set ref 255*
string                                                 builtin function         dcl 102 set ref 252*
sub_err_                        000016 constant        entry                    external dcl 121 ref 238
sys_info$max_seg_size           000020 external static fixed bin(35,0)          dcl 125 ref 255
type                      2     000104 automatic       fixed bin(17,0)          initial level 2 in structure
                                                                                  "local_ordered_esm_info" dcl 88 in procedure
                                                                                  "im_create_index" set ref 88* 153*
type                      2     000111 automatic       fixed bin(17,0)          initial level 2 in structure
                                                                                  "local_unblocked_cism_info" dcl 90 in procedure
                                                                                  "im_create_index" set ref 90* 149*
typed_vector_array                     based           structure                level 1 dcl 3-21
typed_vector_array_ptr          000134 automatic       pointer                  dcl 3-43 set ref 133* 141* 194 201*
unblocked_cism_info                    based           structure                level 1 dcl 6-28
version                                based           char(8)                  level 2 in structure "index_header" dcl 4-25
                                                                                  in procedure "im_create_index" set ref 179*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 5-36
                                                                                  in procedure "im_create_index" set ref 146*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 2-36
                                                                                  in procedure "im_create_index" set ref 170*
version                         000104 automatic       char(8)                  initial level 2 in structure
                                                                                  "local_ordered_esm_info" dcl 88 in procedure
                                                                                  "im_create_index" set ref 88* 152*
version                         000111 automatic       char(8)                  initial level 2 in structure
                                                                                  "local_unblocked_cism_info" dcl 90 in procedure
                                                                                  "im_create_index" set ref 90* 148*
version                         000170 automatic       fixed bin(17,0)          level 2 in structure "da_area_info" dcl 248
                                                                                  in procedure "DEFINE_AREA" set ref 251*
work_area                              based           area                     dcl 98 ref 169 178
work_area_ptr                   000116 automatic       pointer                  dcl 93 set ref 137* 141* 169 178 197* 217 217*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 1-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 1-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 1-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 1-7
BASIC_ELEMENT_STORAGE_METHOD           internal static fixed bin(17,0)          initial dcl 7-44
BITS_PER_WORD                          internal static fixed bin(17,0)          initial dcl 113
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 6-38
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 2-45
TYPED_VECTOR_ARRAY_VERSION_2           internal static fixed bin(35,0)          initial dcl 3-50
area_infop                             automatic       pointer                  dcl 9-5
basic_esm_info                         based           structure                level 1 dcl 7-21
basic_esm_info_ptr                     automatic       pointer                  dcl 7-40
blocked_cism_info                      based           structure                level 1 dcl 6-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 6-33
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 8-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 8-52
collection_manager_$create_file 000000 constant        entry                    external dcl 8-56
collection_manager_$delete      000000 constant        entry                    external dcl 8-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 8-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 8-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 8-60
collection_manager_$get         000000 constant        entry                    external dcl 8-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 8-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-77
collection_manager_$get_header  000000 constant        entry                    external dcl 8-83
collection_manager_$get_id      000000 constant        entry                    external dcl 8-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 8-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 8-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 8-93
collection_manager_$modify      000000 constant        entry                    external dcl 8-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 8-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 8-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 8-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 8-113
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 8-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 8-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 8-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 8-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-135
currentsize                                            builtin function         dcl 102
element_id_string                      automatic       bit(36)                  dcl 11-30
field_name                             based           char                     unaligned dcl 5-71
field_name_length                      automatic       fixed bin(17,0)          dcl 5-73
field_name_ptr                         automatic       pointer                  dcl 5-74
index_manager_$create_index     000000 constant        entry                    external dcl 10-39
index_manager_$create_subset_index
                                000000 constant        entry                    external dcl 10-40
index_manager_$delete_key       000000 constant        entry                    external dcl 10-41
index_manager_$destroy_cursor   000000 constant        entry                    external dcl 10-42
index_manager_$destroy_index    000000 constant        entry                    external dcl 10-43
index_manager_$get_key          000000 constant        entry                    external dcl 10-44
index_manager_$get_key_count_array
                                000000 constant        entry                    external dcl 10-45
index_manager_$get_key_count_by_spec
                                000000 constant        entry                    external dcl 10-46
index_manager_$position_cursor  000000 constant        entry                    external dcl 10-47
index_manager_$put_key          000000 constant        entry                    external dcl 10-48
ordered_esm_info_ptr                   automatic       pointer                  dcl 7-41
size                                                   builtin function         dcl 102
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 3-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 3-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 3-44
unblocked_cism_info_ptr                automatic       pointer                  dcl 6-34

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000702 constant        entry                    internal dcl 232 ref 146
DEFINE_AREA                     001004 constant        entry                    internal dcl 244 ref 137
ERROR_RETURN                    000667 constant        entry                    internal dcl 222 ref 143 160 165 175 191 198 202 259
FINISH                          000646 constant        entry                    internal dcl 215 ref 135 206 226
MAIN_RETURN                     000644 constant        label                    dcl 210 ref 228
im_create_index                 000077 constant        entry                    external dcl 67

NAMES DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 163 163 173 173 189 189
unspec                                                 builtin function         set ref 163 163 173 173 180* 185* 189 189

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1264        1322    1062        1274
Length      1744    1062        36         406     202           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_create_index                     246 external procedure  is an external procedure.  
on unit on line 135                  64 on unit               
FINISH                               68 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_create_index.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_create_index.  
DEFINE_AREA                             internal procedure  shares stack frame of external procedure im_create_index.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_create_index          000100 field_table_id_string       im_create_index
                         000101 file_opening_id             im_create_index
                         000102 index_collection_id         im_create_index
                         000103 key_count_array_id_string   im_create_index
                         000104 local_ordered_esm_info      im_create_index
                         000111 local_unblocked_cism_info   im_create_index
                         000115 maximum_element_length      im_create_index
                         000116 work_area_ptr               im_create_index
                         000120 cursor_ptr                  im_create_index
                         000130 key_count_array_ptr         im_create_index
                         000132 kca_number_of_counts        im_create_index
                         000134 typed_vector_array_ptr      im_create_index
                         000136 index_header_ptr            im_create_index
                         000140 field_table_ptr             im_create_index
                         000142 ft_length_of_field_names    im_create_index
                         000143 ft_number_of_fields         im_create_index
                         000170 da_area_info                DEFINE_AREA
                         000214 da_code                     DEFINE_AREA

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$create_collection                       collection_manager_$put
collection_manager_$put_header                              data_format_util_$cv_typed_array_to_table
define_area_                  index_manager_$create_cursor  index_manager_$put_key_array  release_area_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     67 000072        83 000104        84 000105        85 000106        86 000107        88 000110        90 000114
 2   48 000121    2   49 000123       131 000124       132 000126       133 000130       135 000133       137 000155
    139 000157       141 000161       143 000201       146 000212       148 000235       149 000240       150 000242
    152 000243       153 000245       154 000247       155 000251       156 000253       158 000255       160 000301
    163 000312       165 000356       168 000367       169 000372       170 000403       171 000406       173 000423
    175 000454       178 000465       179 000472       180 000475       181 000477       183 000510       184 000512
    185 000514       186 000516       187 000520       189 000522       191 000543       194 000554       197 000557
    198 000577       201 000610       202 000624       206 000635       208 000641       210 000644       215 000645
    217 000653       220 000666       222 000667       226 000671       227 000675       228 000701       232 000702
    238 000713       242 001003       244 001004       249 001006       251 001007       252 001011       253 001012
    254 001014       255 001020       256 001023       258 001025       259 001037       262 001043       264 001046


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
