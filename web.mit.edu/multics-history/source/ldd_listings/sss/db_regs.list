	COMPILATION LISTING OF SEGMENT db_regs
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1822.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 db_regs:	procedure;
       12 
       13 
       14 
       15 /*	This procedure is used to print, get, or assign the values of the  debug  or  user
       16**	defined data registers.  There is an entry provided for each of these three
       17**	functions.   The  debug data registers  are really data fields in the machine
       18**	conditions and are referenced via pre-defined names.
       19**
       20**	Rewritten  Nov 72  for the  6180  by  Bill Silver.
       21**/
       22 
       23 
       24 
       25 /*		PARAMETER  DATA		*/
       26 
       27 dcl	db_mc_ptr	ptr,		/* Pointer to the current machine conditions.  All debug keeps
       28*				*  is a pointer to the machine conditions which are in the stack.
       29*				*  If this pointer is null then we don't have any machine
       30*				*  registers to play with.  Note, the user defined registers
       31*				*  are always available.  	*/
       32 
       33 	name	char(4) aligned,	/* The name of the data item that is to be processed.  It is
       34*				*  either a predefined debug data name or the name of a
       35*				*  user defined register.  	*/
       36 
       37 	print_mode	fixed bin,	/* 0 => BRIEF,  1 => LONG.  */
       38 
       39 	value	bit(72) aligned;	/* Used to assign or get the value of one debug data item.
       40*				*  Its contents are always right justified.  	*/
       41 
       42 
       43 
       44 
       45 
       46 /*		AUTOMATIC  DATA		*/
       47 
       48 
       49 /*	These  data items are used as work variables.  */
       50 
       51 dcl	block_ptr		ptr,	/* Pointer to a block of 8 words to be printed. */
       52 
       53 
       54 	work_ptr		ptr;	/* Just a temporary pointer. */
       55 
       56 dcl	indp		ptr;	/* pointer to indicator reg. in scu */
       57 
       58 dcl	delim		char(2);	/* comma or blank for indicator list */
       59 
       60 dcl	namex	fixed bin,	/* The index of the db_data$names table. */
       61 
       62 	userx	fixed bin,	/* The index of both the user_reg_names and
       63*				*  user_reg_values  table. */
       64 
       65 	i	fixed bin;	/* Just a work varaible. */
       66 
       67 dcl	len	fixed bin;	/* Another work variable. */
       68 
       69 
       70 /*	This variable is used to obtain a printable string of information about
       71**	an instruction from the  print_text_$format procedure.
       72**/
       73 
       74 dcl	source_string	char (72)	varying;
       75 
       76 
       77 
       78 
       79 /*	These words are used to print data items in octal via calls to  "ioa_".   They
       80**	are needed to correctly print, for example, a 3 octal digit number since the
       81**	number must be right justified in a 36 bit word and all but the 3 digits to be
       82**	printed must be zero.
       83**/
       84 
       85 dcl	( print_word1, print_word2, print_word3, print_word4 )
       86 	bit(36)	init( "0"b );
       87 
       88 
       89 
       90 
       91 /*	This word is used in printing out the value of the eaq in floating format */
       92 
       93 dcl	float_val float bin(63);
       94 
       95 
       96 dcl	print_request bit (1) init ("0"b);	/* ON if entry by db_regs$print  */
       97 
       98 
       99 
      100 
      101 /*		BASED  DECLARATIONS		*/
      102 
      103 
      104 /*	Used to overlay floating value for eaq output */
      105 
      106 dcl	1 float_overlay	aligned based(addr(float_val)),
      107 	2 exponent	unal bit(8),
      108 	2 a_part		unal bit(36),
      109 	2 q_part		unal bit(27);
      110 
      111 
      112 /*	Used to print out a block of  8  words.  */
      113 
      114 dcl	block (0:7)  bit(36)  based;
      115 dcl	eight_words bit(288) based aligned;
      116 
      117 
      118 /*	Used to reference a pointer as a bit string.  */
      119 
      120 dcl	ptr_bit_string	bit(72)	based;
      121 
      122 dcl	based_ptr 	ptr   based;
      123 
      124 dcl	ind_bits		bit(14) based(indp);	/* indicators */
      125 
      126 
      127 
      128 /*		INTERNAL  STATIC  DATA	    */
      129 
      130 
      131 
      132 /*	The following two tables are used to convert an index of a debug data name into
      133**	an index of a label constant array.  Except for the first and the last entries
      134**	all of the entries of these two tables correspond to a debug data name as defined
      135**	in the  db_data$names array.  The first entry (-1) is used when there is no room
      136**	left for another user register.  The last entry is used for  user defined registers.
      137**	The value of each entry is an index into the label array which corresponds to each.
      138**	of these tables.  Note, the  get_ass_label_table  is used for both the
      139**	get_label array  and the  assign_label array.   The entries in the label arrays
      140**	are used to transfer the routine which can process this type of data.
      141**/
      142 
      143 
      144 
      145 dcl	print_label_table ( -1:33 )	fixed bin	  internal  static
      146 
      147 /*			    DATA NAME	PRINT ROUTINE	*/
      148 
      149 	init (	    0,	/*		return		*/
      150 		(8) 6,	/* pointer regs	print_pr		*/
      151 		(8) 7,	/* index regs	print_xreg	*/
      152 		    9,	/*   aq		print_aq		*/
      153 		    1,	/*   all		print_all		*/
      154 		    2,	/*   prs		print_prs		*/
      155 		    3,	/*   regs		print_regs	*/
      156 		    4,	/*   scu		print_scu		*/
      157 		    5,	/*   user		print_user_regs	*/
      158 		   10,	/*   a		print_a		*/
      159 		   11,	/*   q		print_q		*/
      160 		   12,	/*   exp		print_exp		*/
      161 		   13,	/*   tr		print_tr		*/
      162 		   14,	/*   ralr		print_ralr	*/
      163 		   15,	/*   ppr		print_ppr		*/
      164 		   16,	/*   tpr		print_tpr		*/
      165 		   17,	/*   even		print_even	*/
      166 		   18,	/*   odd		print_odd		*/
      167 		   19,	/*   ind		print_indicators	*/
      168 		   20,	/*   eaq		print_floating_eaq  */
      169 		    8);	/*   		print_user_reg	*/
      170 
      171 
      172 
      173 dcl	get_ass_label_table ( -1:33 )	fixed bin	  internal  static
      174 
      175 /*			    DATA NAME	GET/ASSIGN ROUTINE	*/
      176 
      177 	init (	    0,	/*		return		*/
      178 		(8) 2,	/* pointer regs	get/assign_pr	*/
      179 		(8) 3,	/* index regs	get/assign_xreg	*/
      180 		    5,	/*   aq		get/assign_aq	*/
      181 		    1,	/*   all		get/assign_illegal	*/
      182 		    1,	/*   prs		get/assign_illegal	*/
      183 		    1,	/*   regs		get/assign_illegal	*/
      184 		    1,	/*   scu		get/assign_illegal	*/
      185 		    1,	/*   user		get/assign_illegal	*/
      186 		    6,	/*   a		get/assign_a	*/
      187 		    7,	/*   q		get/assign_q	*/
      188 		    8,	/*   exp		get/assign_exp	*/
      189 		    9,	/*   tr		get/assign_tr	*/
      190 		   10,	/*   ralr		get/assign_ralr	*/
      191 		   11,	/*   ppr		get/assign_ppr	*/
      192 		   12,	/*   tpr		get/assign_tpr	*/
      193 		   13,	/*   even		get/assign_even	*/
      194 		   14,	/*   odd		get/assign_odd	*/
      195 		    1,	/*   ind		get/assign_illegal	*/
      196 		    1,	/*   eaq		get/assign_illegal	*/
      197 		    4);	/*   		get/assign_user_reg	*/
      198 
      199 
      200 /*	The following table contains the names to be associated with
      201**	each bit of the Indicators register.
      202**/
      203 
      204 dcl	ind_names (14) char(4)	int static initial
      205 	("zero",
      206 	 "neg ",
      207 	 "cary",
      208 	 "ovfl",
      209 	 "eovf",
      210 	 "eufl",
      211 	 "oflm",
      212 	 "tro ",
      213 	 "par ",
      214 	 "parm",
      215 	 "^bar",
      216 	 "tru ",
      217 	 "mif ",
      218 	 "abs ");
      219 
      220 
      221 
      222 
      223 /*	These tables contain the user defined registers.  The maximum number that may
      224**	be defined is  16.   The corresponding entries of the two tables define the
      225**	name and the value of each register.  Note, these registers are defied as
      226**	INTERNAL STATIC and thus will remain unchanged for recursive calls to  debug.
      227**	This is not true for the debug machine condition data.
      228**/
      229 
      230 /*	These variables contain the number of user defined registers which have actually
      231**	been defined  and the  maximum number which may be defined.
      232**/
      233 
      234 dcl      (num_user_regs	fixed bin    init(0),
      235 
      236 	max_num_user_regs	fixed bin	   init(16) )    internal static;
      237 
      238 
      239 dcl	user_reg_names(16)	char(4)	internal  static;
      240 
      241 dcl	user_reg_values(16)	bit(36)	internal static;
      242 
      243 
      244 
      245 
      246 
      247 /*		EXTERNAL  and  BUILTIN  DATA		*/
      248 
      249 
      250 /*	These are the external procedures called by  db_regs.  */
      251 
  1     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  1     2*   *
  1     3*   *	This include file is used to reference the common data  that is passed from the
  1     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  1     5*   *
  1     6*   *	modified 7/75 by S.E. Barr for the break instructions
  1     7**/
  1     8 
  1     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  1    10 
  1    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  1    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  1    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  1    14*						   it was entered via a fault.  It will go to debug in
  1    15*						   another frame.  */
  1    16 
  1    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  1    18*						   1 = input switch iocb ptr
  1    19*						   2 = output switch iocb ptr      */
  1    20     2 flags aligned,
  1    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  1    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  1    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  1    24*						   condition on;  1 = use the debug condition handler */
  1    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  1    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  1    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  1    28 
  1    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
      252 
      253 
      254 dcl	print_text_$format	ext    entry	( ptr, char(*) var ),
      255 
      256 	ioa_$ioa_stream	ext    entry	options(variable);
      257 
      258 dcl	ioa_$rsnnl	ext    entry	options(variable);
      259 
      260 
      261 
      262 dcl	( addr, substr )	builtin;
      263 /**/
  2     1 /*	BEGIN INCLUDE FILE ... db_data_map.incl.pl 1   Last modified Nov 72  for  6180  - WSS. */
  2     2 
  2     3 
  2     4 /*	Below are references to the tables found in  db_data.alm.   These are the
  2     5**	PL/I  definitions of these tables.
  2     6**/
  2     7 
  2     8 dcl	db_data$n_regs		fixed bin	external;
  2     9 
  2    10 dcl	db_data$names(0:31)		char (4)	aligned	external;
  2    11 
  2    12 dcl	db_data$tags(0:63)		char (4)	aligned	external;
  2    13 
  2    14 dcl	db_data$fault_names (0:31)	char (20)	aligned	external;
  2    15 
  2    16 dcl	db_data$acv_names (16)	char (24)	aligned	external;
  2    17 
  2    18 dcl	db_data$ipr_names (7)	char (24)	aligned	external;
  2    19 
  2    20 
  2    21 
  2    22 
  2    23 /*	END OF INCLUDE FILE ... db_data_map.incl.pl1   */
      264 
      265 /**/
  3     1 /* BEGIN INCLUDE FILE its.incl.pl1
  3     2*   modified 27 July 79 by JRDavis to add its_unsigned
  3     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  3     4 
  3     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  3     6     2 pad1 bit (3) unaligned,
  3     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  3     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  3     9     2 pad2 bit (9) unaligned,
  3    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  3    11 
  3    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  3    13     2 pad3 bit (3) unaligned,
  3    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  3    15     2 pad4 bit (3) unaligned,
  3    16     2 mod bit (6) unaligned;				/* further modification */
  3    17 
  3    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  3    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  3    20     2 pad1 bit (27) unaligned,
  3    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  3    22 
  3    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  3    24     2 pad2 bit (3) unaligned,
  3    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  3    26     2 pad3 bit (3) unaligned,
  3    27     2 mod bit (6) unaligned;				/* further modification */
  3    28 
  3    29 
  3    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  3    31     2 pad1 bit (3) unaligned,
  3    32     2 segno fixed bin (15) unsigned unaligned,
  3    33     2 ringno fixed bin (3) unsigned unaligned,
  3    34     2 pad2 bit (9) unaligned,
  3    35     2 its_mod bit (6) unaligned,
  3    36 
  3    37     2 offset fixed bin (18) unsigned unaligned,
  3    38     2 pad3 bit (3) unaligned,
  3    39     2 bit_offset fixed bin (6) unsigned unaligned,
  3    40     2 pad4 bit (3) unaligned,
  3    41     2 mod bit (6) unaligned;
  3    42 
  3    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  3    44     2 pr_no fixed bin (3) unsigned unaligned,
  3    45     2 pad1 bit (27) unaligned,
  3    46     2 itp_mod bit (6) unaligned,
  3    47 
  3    48     2 offset fixed bin (18) unsigned unaligned,
  3    49     2 pad2 bit (3) unaligned,
  3    50     2 bit_offset fixed bin (6) unsigned unaligned,
  3    51     2 pad3 bit (3) unaligned,
  3    52     2 mod bit (6) unaligned;
  3    53 
  3    54 
  3    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  3    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  3    57 
  3    58 /* END INCLUDE FILE   its.incl.pl1 */
      266 
  4     1 /*  */
  4     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  4     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  4     4 /* Modified 07/07/76 by Morris for fault register data */
  4     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  4     6 
  4     7 
  4     8 /* words 0-15 pointer registers */
  4     9 
  4    10 dcl  mcp ptr;
  4    11 
  4    12 dcl 1 mc based (mcp) aligned,
  4    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  4    14    (2 regs,					/* registers */
  4    15       3 x (0:7) bit (18),				/* index registers */
  4    16       3 a bit (36),					/* accumulator */
  4    17       3 q bit (36),					/* q-register */
  4    18       3 e bit (8),					/* exponent */
  4    19       3 pad1 bit (28),
  4    20       3 t bit (27),					/* timer register */
  4    21       3 pad2 bit (6),
  4    22       3 ralr bit (3),				/* ring alarm register */
  4    23 
  4    24     2 scu (0:7) bit (36),
  4    25 
  4    26     2 mask bit (72),				/* mem controller mask at time of fault */
  4    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  4    28     2 errcode fixed bin (35),				/* fault handler's error code */
  4    29     2 fim_temp,
  4    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  4    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  4    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  4    33     2 fault_reg bit (36),				/* fault register */
  4    34     2 pad2 bit (1),
  4    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  4    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  4    37     2 fault_time bit (54),				/* time of fault */
  4    38 
  4    39     2 eis_info (0:7) bit (36)) unaligned;
  4    40 
  4    41 
  4    42 dcl (apx fixed bin init (0),
  4    43      abx fixed bin init (1),
  4    44      bpx fixed bin init (2),
  4    45      bbx fixed bin init (3),
  4    46      lpx fixed bin init (4),
  4    47      lbx fixed bin init (5),
  4    48      spx fixed bin init (6),
  4    49      sbx fixed bin init (7)) internal static;
  4    50 
  4    51 
  4    52 
  4    53 
  4    54 dcl  scup ptr;
  4    55 
  4    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  4    57 
  4    58 
  4    59 /*	WORD (0)		*/
  4    60 
  4    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  4    62       3 prr bit (3),				/* procedure ring register */
  4    63       3 psr bit (15),				/* procedure segment register */
  4    64       3 p bit (1),					/* procedure privileged bit */
  4    65 
  4    66     2 apu,					/* APPENDING UNIT STATUS */
  4    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  4    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  4    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  4    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  4    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  4    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  4    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  4    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  4    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  4    76       3 ptw bit (1),				/* Fetch of PTW */
  4    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  4    78       3 fap bit (1),				/* Fetch of final address paged */
  4    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  4    80       3 fabs bit (1),				/* Fetch of final address absolute */
  4    81 
  4    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  4    83 
  4    84 
  4    85 /*	WORD (1)		*/
  4    86 
  4    87     2 fd,						/* FAULT  DATA */
  4    88       3 iro bit (1),				/* illegal ring order */
  4    89       3 oeb bit (1),				/* out of execute bracket */
  4    90       3 e_off bit (1),				/* no execute */
  4    91       3 orb bit (1),				/* out of read bracket */
  4    92       3 r_off bit (1),				/* no read */
  4    93       3 owb bit (1),				/* out of write bracket */
  4    94       3 w_off bit (1),				/* no write */
  4    95       3 no_ga bit (1),				/* not a gate */
  4    96       3 ocb bit (1),				/* out of call bracket */
  4    97       3 ocall bit (1),				/* outward call */
  4    98       3 boc bit (1),				/* bad outward call */
  4    99       3 inret bit (1),				/* inward return */
  4   100       3 crt bit (1),				/* cross ring transfer */
  4   101       3 ralr bit (1),				/* ring alarm register */
  4   102       3 am_er bit (1),				/* associative memory fault */
  4   103       3 oosb bit (1),				/* out of segment bounds */
  4   104       3 paru bit (1),				/* processor parity upper */
  4   105       3 parl bit (1),				/* processor parity lower */
  4   106       3 onc_1 bit (1),				/* op not complete type 1 */
  4   107       3 onc_2 bit (1),				/* op not complete type 2 */
  4   108 
  4   109     2 port_stat,					/* PORT  STATUS */
  4   110       3 ial bit (4),				/* illegal action lines */
  4   111       3 iac bit (3),				/* illegal action channel */
  4   112       3 con_chan bit (3),				/* connect channel */
  4   113 
  4   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  4   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  4   116 
  4   117 
  4   118 /*	WORD (2)		*/
  4   119 
  4   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  4   121       3 trr bit (3),				/* temporary ring register */
  4   122       3 tsr bit (15),				/* temporary segment register */
  4   123 
  4   124     2 pad2 bit (9),
  4   125 
  4   126     2 cpu_no bit (3),				/* CPU number */
  4   127 
  4   128     2 delta bit (6),				/* tally modification DELTA */
  4   129 
  4   130 
  4   131 /*	WORD (3)		*/
  4   132 
  4   133     2 word3 bit (18),
  4   134 
  4   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  4   136       3 tsna,					/* Word 1 status */
  4   137         4 prn bit (3),				/* Word 1  PR  number */
  4   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  4   139       3 tsnb,					/* Word 2  status */
  4   140         4 prn bit (3),				/* Word 2  PR  number */
  4   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  4   142       3 tsnc,					/* Word 3  status */
  4   143         4 prn bit (3),				/* Word 3  PR  number */
  4   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  4   145 
  4   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  4   147 
  4   148 
  4   149 /* 	WORD (4)		*/
  4   150 
  4   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  4   152 
  4   153     2 ir,						/* INDICATOR  REGISTERS */
  4   154       3 zero bit (1),				/* zero indicator */
  4   155       3 neg bit (1),				/* negative indicator */
  4   156       3 carry bit (1),				/* carryry indicator */
  4   157       3 ovfl bit (1),				/* overflow indicator */
  4   158       3 eovf bit (1),				/* eponent overflow */
  4   159       3 eufl bit (1),				/* exponent underflow */
  4   160       3 oflm bit (1),				/* overflow mask */
  4   161       3 tro bit (1),				/* tally runout */
  4   162       3 par bit (1),				/* parity error */
  4   163       3 parm bit (1),				/* parity mask */
  4   164       3 bm bit (1),					/* ^bar mode */
  4   165       3 tru bit (1),				/* truncation mode */
  4   166       3 mif bit (1),				/* multi-word instruction mode */
  4   167       3 abs bit (1),				/* absolute mode */
  4   168       3 pad bit (4),
  4   169 
  4   170 
  4   171 /*	WORD (5)		*/
  4   172 
  4   173     2 ca bit (18),					/* COMPUTED  ADDRESS */
  4   174 
  4   175     2 cu,						/* CONTROL UNIT STATUS */
  4   176       3 rf bit (1),					/* on first cycle of repeat instr */
  4   177       3 rpt bit (1),				/* repeat instruction */
  4   178       3 rd bit (1),					/* repeat double instruction */
  4   179       3 rl bit (1),					/* repeat link instruciton */
  4   180       3 pot bit (1),				/* IT  modification */
  4   181       3 pon bit (1),				/* return type instruction */
  4   182       3 xde bit (1),				/* XDE from Even location */
  4   183       3 xdo bit (1),				/* XDE from Odd  location */
  4   184       3 poa bit (1),				/* operation preparation */
  4   185       3 rfi bit (1),				/* tells CPU to refetch instruction */
  4   186       3 its bit (1),				/* ITS modification */
  4   187       3 if bit (1),					/* fault occured during instruction fetch */
  4   188 
  4   189     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  4   190 
  4   191 
  4   192 /*	WORDS (6,7)	*/
  4   193 
  4   194     2 even_inst bit (36),				/* even instruction of faulting pair */
  4   195 
  4   196     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  4   197 
  4   198 
  4   199 
  4   200 
  4   201 
  4   202 
  4   203 /*	ALTERNATE   SCU  DECLARATION		*/
  4   204 
  4   205 
  4   206 dcl 1 scux based (scup) aligned,
  4   207 
  4   208    (2 pad0 bit (36),
  4   209 
  4   210     2 fd,						/* GROUP II  FAULT DATA */
  4   211       3 isn bit (1),				/* illegal segment number */
  4   212       3 ioc bit (1),				/* illegal op  code  */
  4   213       3 ia_am bit (1),				/* illegal address - modifier */
  4   214       3 isp bit (1),				/* illegal slave  procedure */
  4   215       3 ipr bit (1),				/* illegal procedure */
  4   216       3 nea bit (1),				/* non existent address */
  4   217       3 oobb bit (1),				/* out of bounds */
  4   218       3 pad bit (29),
  4   219 
  4   220     2 pad2 bit (36),
  4   221 
  4   222     2 pad3a bit (18),
  4   223 
  4   224     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  4   225       3 prn bit (3),				/* PR  number */
  4   226       3 prv bit (1),				/* PR  valid bit */
  4   227 
  4   228     2 pad3b bit (6)) unaligned,
  4   229 
  4   230     2 pad45 (0:1) bit (36),
  4   231 
  4   232     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  4   233 
  4   234 
  4   235 
  4   236 /*  END INCLUDE FILE   mc.incl.pl1 */
      267 
      268 /**/
      269 
      270 
      271 print:	entry  ( db_mc_ptr, name, print_mode );
      272 
      273 	print_request = "1"b;		/* Set so we won't create if not found */
      274 
      275 	call	get_namex;		/* Get the index of this name. */
      276 
      277 
      278 /*	This index is used to reference the label table which then gives us the index
      279**	of the label constant that we want to  goto.
      280**/
      281 
      282 	goto	print_label( print_label_table(namex) );
      283 
      284 
      285 
      286 
      287 
      288 
      289 get:	entry  ( db_mc_ptr, name, value, print_mode );
      290 
      291 
      292 	call	get_namex;
      293 
      294 
      295 	value  =  "0"b;		/* Initially set the return value to zero.  */
      296 
      297 
      298 	goto	get_label( get_ass_label_table(namex) );
      299 
      300 
      301 
      302 
      303 
      304 
      305 assign:	entry  ( db_mc_ptr, name, value, print_mode );
      306 
      307 
      308 	call	get_namex;
      309 
      310 
      311 	print_word1  =  substr( value, 1,36);	/* Break up the input value into two words */
      312 	print_word2  =  substr( value,37,36);	/* so it can be more easily printed
      313*					*  via  ioa_.  */
      314 
      315 
      316 	goto	assign_label( get_ass_label_table(namex) );
      317 
      318 
      319 
      320 
      321 
      322 /*	We come here if  "namex"  =  -1  which implies that there was no room for another
      323**	user defined register.  We will simply return.
      324**/
      325 
      326 print_label(0):
      327 get_label(0):
      328 assign_label(0):
      329 
      330 	return;
      331 
      332 
      333 
      334 
      335 /*	This label is called from  get_namex  when the pointer to the machine conditions is
      336**	null.  Since there is no register data to work with we will just return.
      337**/
      338 
      339 no_mc_data:
      340 
      341 	if	print_mode  =  0			/* BRIEF  or  LONG  */
      342 
      343 		then	call    ioa_$ioa_stream (debug_output, "No  mc  data.");
      344 
      345 
      346 		else  do;				/* LONG. */
      347 		call    ioa_$ioa_stream (debug_output, "No fault frame found in stack trace.");
      348 		end;
      349 
      350 
      351 	return;
      352 /**/
      353 get_namex:	procedure;
      354 
      355 
      356 /*	This procedure is called to set  "namex"  to the number which corresponds to the data
      357**	name passed to  db_regs  in  "name".   If it is a standard pre-defined debug data
      358**	name then  "namex"  will be simply the index of the   db_data$names array entry
      359**	which contains this name.  Otherwise it will be a user defined register name and "namex"
      360**	will be equal to a number one greater than the highest valid index to  db_data$names.
      361**	The index of the user register is set in  "userx".   If there is no room to allocate
      362**	a new user register then  "namex"  will be set to  -1.
      363**/
      364 
      365 
      366 
      367 	mcp  =  db_mc_ptr;		/* Copy the parameter which points to the area where
      368*				*  debug's  copy of the machine conditions are saved.  */
      369 
      370 
      371 /*	See if this name is one of the standard debug data names.  If it is then  "namex"
      372**	is equal to the index of the db_data$names entry which contains this name.
      373**	If it is one of the standard register names then we will check the pointer to the
      374**	machine conditions that we were passed.  If it is  null  then we can't do anything
      375**	with this register since as far as we are conserned it doesn't exist.
      376**/
      377 
      378 	do    namex  =  0  to  db_data$n_regs;
      379 
      380 	if    name  =  db_data$names(namex)		/* Is it one of the standard machine
      381*						*  condition type register names? */
      382 
      383 		then    if    db_mc_ptr  =  null()	/* YES it is - do we have a pointer
      384*						*  to it?  */
      385 
      386 			then  goto  no_mc_data;	/* NO. */
      387 
      388 			else  do;			/* YES, return with namex. */
      389 			scup  =  addr( mcp -> mc.scu );
      390 			return;
      391 			end;
      392 
      393 	end;
      394 
      395 
      396 /*	This name is not one of the standard names.  It must be the name of a user defined
      397**	register.  "namex"  is set correctly.  It came out of the  do loop  one greater
      398**	than the number of standard names.  We will now see if this user name is allready
      399**	defined.  If it is we will just return with  "userx"  set correctly.
      400**/
      401 
      402 	do    userx  =  1  to  num_user_regs;
      403 
      404 	if    name   =  user_reg_names(userx)    then  return;
      405 
      406 	end;
      407 
      408 
      409 /*	This is a new user register name.  Do we have another slot in the user register
      410**	tables for it?  If not we will tell the user and  "namex"  will be set to -1.
      411**	The register will not be created for a print request.
      412**/
      413 
      414 
      415 	if print_request then do;
      416 	     call ioa_$ioa_stream (debug_output, "User register not defined.  ^a", name);
      417 	     namex = -1;
      418 	     return;
      419 	end;
      420 	if	userx  >  max_num_user_regs
      421 
      422 		then  do;
      423 		call  ioa_$ioa_stream (debug_output, "User register  ^a  not initialized - max number exceded",name);
      424 		namex  =  -1;
      425 		return;
      426 		end;
      427 
      428 
      429 /*	There is room for this new user register so lets initialize it.
      430**/
      431 
      432 	num_user_regs  =  userx;		/* Reset the count of active user registers
      433*					*  to reflect this new register.  */
      434 
      435 	user_reg_names(userx)   =  name;	/* Remember its name. */
      436 
      437 	user_reg_values(userx)  =  "0"b;	/* Initialize its value to zero. */
      438 
      439 /*	If we are in LONG mode then we will tell the user that he has just created
      440**	a new user register.  */
      441 
      442 	if	print_mode  ^=  0
      443 
      444 		then    call    ioa_$ioa_stream (debug_output, "Creating new user register  ^a", name );
      445 
      446 
      447 	end	get_namex;
      448 /**/
      449 /*	These are the routines called via the  print_label  array.   Each little piece
      450**	of code  PRINTS  some of the debug machine conditions data.
      451**/
      452 
      453 
      454 /*	Print all of the machine conditions data.  Also print the user defined
      455**	registers.
      456**/
      457 
      458 print_label(1):			/*	print_all 	*/
      459 
      460 	if	print_mode  ^=  0
      461 		then    call    ioa_$ioa_stream (debug_output, "All  ""machine conditions""  data.");
      462 
      463 	call	print_prs;
      464 
      465 	call	print_regs;
      466 
      467 	call	print_scu;
      468 
      469 	if	print_mode  ^=  0
      470 		then    call  ioa_$ioa_stream (debug_output, "^/The  8  words after the  SCU  data");
      471 	block_ptr  =  addr( mcp -> mc.mask );
      472 	call	print_block;
      473 
      474 	block_ptr  =  addr( mcp -> mc.eis_info );
      475 	if block_ptr -> eight_words ^= "0"b then do;
      476 		if	print_mode  ^=  0
      477 		then    call  ioa_$ioa_stream (debug_output, "^/EIS  info");
      478 		call	print_block;
      479 	end;
      480 
      481 	call	print_user_regs;
      482 
      483 	return;
      484 
      485 
      486 
      487 
      488 
      489 /* 	Print  all  of the  pointer registers.  */
      490 
      491 print_label(2):
      492 
      493 	call	print_prs;
      494 	return;
      495 
      496 
      497 print_prs:	procedure;
      498 
      499 	call	ioa_$ioa_stream (debug_output, "^/Pointer Registers");
      500 
      501 	do    i  =  0  to  7;
      502 	call	ioa_$ioa_stream (debug_output, "^a^-^p",db_data$names(i), mcp->mc.prs(i));
      503 	end;
      504 
      505 	end	print_prs;
      506 
      507 
      508 
      509 
      510 
      511 /*	Print all of the registers: index registers, A,Q,Exp,Timer Register and
      512**	Ring Alarm Register.
      513**/
      514 
      515 print_label(3):
      516 
      517 	call	print_regs;
      518 	return;
      519 
      520 
      521 print_regs:	procedure;
      522 
      523 	if	print_mode  ^=  0
      524 
      525 		then  do;
      526 
      527 		call  ioa_$ioa_stream (debug_output, "^/Index  and other  Registers");
      528 
      529 		do    i  =  0  to  7;
      530 		call	ioa_$ioa_stream (debug_output, "^a^-^.3b", db_data$names(i+8), mcp->mc.regs.x(i));
      531 		end;
      532 		end;
      533 
      534 
      535 		else  do;			/* BRIEF  mode.  */
      536 
      537 		call    ioa_$ioa_stream (debug_output, "^-^.3b  ^.3b  ^.3b  ^.3b",
      538 			mc.regs.x(0), mc.regs.x(1), mc.regs.x(2), mc.regs.x(3));
      539 		call    ioa_$ioa_stream (debug_output, "^-^.3b  ^.3b  ^.3b  ^.3b",
      540 			mc.regs.x(4), mc.regs.x(5), mc.regs.x(6), mc.regs.x(7));
      541 
      542 		end;
      543 	call	ioa_$ioa_stream (debug_output, "a^-^w^/q^-^w", mcp->mc.regs.a, mcp->mc.regs.q);
      544 
      545 	call	print_exp;
      546 	call	print_tr;
      547 	call	print_ralr;
      548 
      549 	end	print_regs;
      550 
      551 
      552 
      553 
      554 
      555 /*	Print the SCU data.  We will print out the  PPR, TPR and the EVEN and ODD
      556**	instructions.  Then we will print out the  SCU  data as a block.
      557**/
      558 
      559 print_label(4):
      560 
      561 	call	print_scu;
      562 	return;
      563 
      564 
      565 print_scu:	procedure;
      566 
      567 	if	print_mode  ^=  0
      568 
      569 		then  do;
      570 		call	ioa_$ioa_stream (debug_output, "^/SCU  data");
      571 		call	print_ppr;
      572 		call	print_tpr;
      573 		call	ioa_$ioa_stream (debug_output, "^/");
      574 		call	print_even;
      575 		call	print_odd;
      576 		call	print_ind;
      577 		call	ioa_$ioa_stream (debug_output, "The  SCU  data as a block");
      578 		end;
      579 
      580 	block_ptr  =  scup;
      581 	call	print_block;
      582 
      583 	end	print_scu;
      584 
      585 
      586 
      587 
      588 
      589 /*	Print out all of the user defined registers.  */
      590 
      591 print_label(5):
      592 
      593 	call	print_user_regs;
      594 	return;
      595 
      596 
      597 print_user_regs:	procedure;
      598 
      599 	if	num_user_regs  =  0
      600 
      601 		then  do;
      602 		if	print_mode  ^=  0
      603 			then    call  ioa_$ioa_stream (debug_output, "^/No user defined registers");
      604 		return;
      605 		end;
      606 
      607 	if	print_mode  ^=  0
      608 		then    call  ioa_$ioa_stream (debug_output, "^/User defined registers");
      609 
      610 	do    i  =  1  to  num_user_regs;
      611 	call	ioa_$ioa_stream (debug_output, "^a^-^w", user_reg_names(i), user_reg_values(i));
      612 	end;
      613 
      614 	end	print_user_regs;
      615 
      616 
      617 
      618 
      619 
      620 /*	Print out  one  pointer register.  */
      621 
      622 print_label(6):			/*	print_pr  	*/
      623 
      624 	call	ioa_$ioa_stream (debug_output, "^a^-^p",db_data$names(namex), mcp->mc.prs(namex));
      625 	return;
      626 
      627 
      628 
      629 
      630 
      631 /*	Print out  one  index register.  */
      632 
      633 print_label(7):			/*	print_xreg  	*/
      634 
      635 	call	ioa_$ioa_stream (debug_output, "^a^-^.3b", db_data$names(namex), mcp->mc.regs.x(namex-8) );
      636 	return;
      637 
      638 
      639 
      640 
      641 
      642 /*	Print out  one  user defined register.  */
      643 
      644 print_label(8):			/*	print_user_reg	*/
      645 
      646 	call	ioa_$ioa_stream (debug_output, "^a^-^w", user_reg_names(userx), user_reg_values(userx));
      647 	return;
      648 
      649 
      650 
      651 
      652 
      653 /*	Print the  AQ  as a combined register  or  print the  A  or  the  Q.  */
      654 
      655 print_label(9):			/*	print_aq  	*/
      656 
      657 	call	ioa_$ioa_stream (debug_output, "aq^-^w ^w", mcp -> mc.regs.a, mcp -> mc.regs.q);
      658 	return;
      659 
      660 
      661 print_label(10):			/*	print_a   	*/
      662 
      663 	call	ioa_$ioa_stream (debug_output, "a^-^w", mcp->mc.regs.a);
      664 	return;
      665 
      666 
      667 
      668 print_label(11):			/*	print_q   	*/
      669 
      670 	call	ioa_$ioa_stream (debug_output, "q^-^w", mcp->mc.regs.q);
      671 	return;
      672 
      673 
      674 
      675 
      676 
      677 /*	Print the  Exponent register.  */
      678 
      679 print_label(12):
      680 
      681 	call	print_exp;
      682 	return;
      683 
      684 print_exp:	procedure;
      685 
      686 	call	ioa_$ioa_stream (debug_output, "exp^-^.3b", "0"b || mc.regs.e);
      687 
      688 	end	print_exp;
      689 
      690 
      691 
      692 
      693 
      694 
      695 /*	Print the  Timer Register.  */
      696 
      697 print_label(13):
      698 
      699 	call	print_tr;
      700 	return;
      701 
      702 
      703 print_tr:		procedure;
      704 
      705 	call	ioa_$ioa_stream (debug_output, "tr^-^.3b", mcp->mc.regs.t);
      706 
      707 	end	print_tr;
      708 
      709 
      710 
      711 
      712 
      713 /*	Print the  Ring Alarm Register.  */
      714 
      715 print_label(14):
      716 
      717 	call	print_ralr;
      718 	return;
      719 
      720 
      721 print_ralr:	procedure;
      722 
      723 	call	ioa_$ioa_stream (debug_output, "ralr^-^.3b", mc.regs.ralr);
      724 
      725 	end	print_ralr;
      726 
      727 
      728 
      729 
      730 /*	Print the  PPR.  */
      731 
      732 print_label(15):
      733 
      734 	call	print_ppr;
      735 	return;
      736 
      737 
      738 print_ppr:	procedure;
      739 
      740 	if	print_mode  ^=  0
      741 		then    call  ioa_$ioa_stream (debug_output, "^/ppr:^-prr  psr   p    ic");
      742 
      743 	call	ioa_$ioa_stream (debug_output, "^- ^.3b  ^.3b  ^.1b  ^.3b", scu.ppr.prr,
      744 		     scu.ppr.psr, scu.ppr.p, scu.ilc);
      745 
      746 	end	print_ppr;
      747 
      748 
      749 
      750 
      751 
      752 /*	Print  the  TPR.  */
      753 
      754 print_label(16):
      755 
      756 	call	print_tpr;
      757 	return;
      758 
      759 
      760 print_tpr:	procedure;
      761 
      762 	if	print_mode  ^=  0
      763 		then    call  ioa_$ioa_stream (debug_output, "^/tpr:^-trr  tsr   tbr   ca");
      764 
      765 	call	ioa_$ioa_stream (debug_output, "^- ^.3b  ^.3b  ^.3b  ^.3b",  scu.tpr.trr,
      766 		     scu.tpr.tsr, scu.tpr_tbr, scu.ca);
      767 
      768 	end	print_tpr;
      769 
      770 
      771 
      772 
      773 
      774 /*	Print out the  EVEN  or  the  ODD  instruction.  */
      775 
      776 print_label(17):
      777 
      778 	call	print_even;
      779 	return;
      780 
      781 print_even:	procedure;
      782 
      783 	call	print_text_$format( addr( scup -> scu.even_inst), source_string);
      784 
      785 	call	ioa_$ioa_stream (debug_output, "even^-^a", source_string );
      786 
      787 	end	print_even;
      788 
      789 
      790 
      791 print_label(18):
      792 
      793 	call	print_odd;
      794 	return;
      795 
      796 
      797 print_odd:	procedure;
      798 
      799 	call	print_text_$format( addr( scup -> scu.odd_inst), source_string);
      800 
      801 	call	ioa_$ioa_stream (debug_output, "odd^-^a", source_string);
      802 
      803 	end	print_odd;
      804 
      805 
      806 
      807 print_label(19):
      808 
      809 	call	print_ind;
      810 	return;
      811 
      812 /*	Print out eaq in exponential format */
      813 
      814 print_label(20):
      815 
      816 	float_overlay.exponent = mc.e;
      817 	float_overlay.a_part = mc.a;
      818 	float_overlay.q_part = mc.q;
      819 
      820 	call ioa_$ioa_stream (debug_output, "eaq^-^e",float_val);
      821 	return;
      822 
      823 
      824 print_ind:	procedure;
      825 
      826 	indp = addr(scup -> scu.ir);	/* point to indicator bits */
      827 
      828 	delim = "";			/* initialize */
      829 	source_string = "";
      830 
      831 	if indp -> ind_bits = (14)"0"b
      832 	then source_string = "none";		/* no point if they're all off */
      833 
      834 	else
      835 	do i = 1 to 14;
      836 	     if substr (indp -> ind_bits, i, 1)
      837 	     then do;
      838 
      839 		call ioa_$rsnnl ("^a^a^a", source_string, len, source_string,
      840 			delim, ind_names(i) );
      841 		delim = ", ";		/* in case it was first one */
      842 	     end;
      843 	end;
      844 
      845 	call ioa_$ioa_stream (debug_output, "indicators: ^a", source_string);
      846 
      847 	end	print_ind;
      848 
      849 
      850 
      851 
      852 
      853 
      854 
      855 
      856 /*	This procedure prints out a block of  8  octal words.  It must be passed
      857**	a pointer to the block of wors to be printed.
      858**/
      859 
      860 print_block:	procedure;
      861 
      862 	call	ioa_$ioa_stream (debug_output, "^/^-^w  ^w  ^w  ^w",
      863 		block_ptr->block(0), block_ptr->block(1), block_ptr->block(2), block_ptr->block(3));
      864 
      865 	call	ioa_$ioa_stream (debug_output, "^-^w  ^w  ^w  ^w",
      866 		block_ptr->block(4), block_ptr->block(5), block_ptr->block(6), block_ptr->block(7));
      867 
      868 	end	print_block;
      869 /**/
      870 /*	These are the routines called via the  get_label  array.  note, the value returned
      871**	will always be  RIGHT  justified with leading zeros.
      872**/
      873 
      874 
      875 
      876 
      877 /*	The names used to print multiple data items cannot be used to retrieve data.
      878**	A zero will be returned.
      879**/
      880 
      881 get_label(1):			/*	get_illegal	*/
      882 
      883 	return;			/* value is allready zero.  */
      884 
      885 
      886 
      887 
      888 get_label(2):			/*	get_pr    	*/
      889 
      890 	value  =  addr( mcp -> mc.prs(namex)) -> ptr_bit_string;
      891 	return;
      892 
      893 
      894 
      895 
      896 get_label(3):			/*	get_xreg		*/
      897 
      898 	substr( value, 55, 18 )  =  mcp -> mc.regs.x(namex-8);
      899 	return;
      900 
      901 
      902 
      903 get_label(4):			/*	get_user_reg	*/
      904 
      905 	substr( value, 37, 36 )  =  user_reg_values(userx);
      906 	return;
      907 
      908 
      909 
      910 
      911 get_label(5):			/*	get_aq		*/
      912 
      913 	substr( value, 1, 36 )   =  mcp -> mc.regs.a;
      914 	substr( value, 37, 36 )  =  mcp -> mc.regs.q;
      915 	return;
      916 
      917 
      918 
      919 
      920 get_label(6):			/*	get_a		*/
      921 
      922 	substr( value, 37, 36 )  =  mcp -> mc.regs.a;
      923 	return;
      924 
      925 
      926 
      927 
      928 get_label(7):			/*	get_q		*/
      929 
      930 	substr( value, 37, 36 )  =  mcp -> regs.q;
      931 	return;
      932 
      933 
      934 
      935 
      936 get_label(8):			/*	get_exp		*/
      937 
      938 	substr( value, 65, 8 )  =  mcp -> mc.regs.e;
      939 	return;
      940 
      941 
      942 
      943 get_label(9):			/*	get_tr		*/
      944 
      945 	substr( value, 46, 27 )  =  mcp -> mc.regs.t;
      946 	return;
      947 
      948 
      949 
      950 
      951 get_label(10):			/*	get_ralr		*/
      952 
      953 	substr( value, 70, 3 )  =  mcp -> mc.regs.ralr;
      954 	return;
      955 
      956 
      957 
      958 
      959 get_label(11):			/*	get_ppr		*/
      960 
      961 	work_ptr  =  addr( value );
      962 	work_ptr -> its.segno  =  scup -> scu.ppr.psr;
      963 	work_ptr -> its.ringno =  scup -> scu.ppr.prr;
      964 	substr( value, 3, 1 )  =  scup -> scu.ppr.p;	/* Normal its pointers have no p bit. */
      965 	work_ptr -> its.offset =  scup -> scu.ilc;
      966 	return;
      967 
      968 
      969 
      970 
      971 get_label(12):			/*	get_tpr		*/
      972 
      973 	work_ptr  =  addr( value );
      974 	work_ptr -> its.segno  =  scup -> scu.tpr.tsr;
      975 	work_ptr -> its.ringno =  scup -> scu.tpr.trr;
      976 	work_ptr -> its.bit_offset  =  scup -> scu.tpr_tbr;
      977 	work_ptr -> its.offset =  scup -> scu.ca;
      978 	return;
      979 
      980 
      981 
      982 
      983 get_label(13):			/*	get_even		*/
      984 
      985 	substr( value, 37, 36 )  =  scup -> scu.even_inst;
      986 	return;
      987 
      988 
      989 
      990 
      991 get_label(14):			/*	get_odd		*/
      992 
      993 	substr( value, 37, 36 )  =  scup -> scu.odd_inst;
      994 	return;
      995 /**/
      996 /*	These routines are called via the assign_label array.  note, the value to be
      997**	assigned is always assumed to be a  RIGHT  justified  BIT  string.
      998**	Note, if the print mode is  LONG  we will print out the value of the data item
      999**	before it is changed and after the assignment.  If we are in  BRIEF  mode we will
     1000**	just make the assignment without telling the user anything.
     1001**/
     1002 
     1003 
     1004 
     1005 /*	The name used to print multiple data items cannot be used to assign values.
     1006**	Each assignment must be made to a specific register.
     1007**/
     1008 
     1009 assign_label(1):			/*	assign_illegal	*/
     1010 
     1011 	call	ioa_$ioa_stream (debug_output, "The  debug  name  ^a  cannot be used in an assignment command.",
     1012 		      db_data$names(namex));
     1013 	return;
     1014 
     1015 assign_label(2):			/*	assign_pr		*/
     1016 
     1017 	if	print_mode  =  1
     1018 
     1019 		then    	call	ioa_$ioa_stream (debug_output, "^a  changed from  ^p  to  ^p",
     1020 			          db_data$names(namex), mcp -> mc.prs(namex), addr(value) -> based_ptr);
     1021 
     1022 	addr( mcp -> mc.prs(namex)) -> ptr_bit_string  =  value;
     1023 
     1024 	return;
     1025 
     1026 assign_label(3):			/*	assign_xreg	*/
     1027 
     1028 	if	print_mode  =  1
     1029 		then  do;
     1030 		call	ioa_$ioa_stream (debug_output, "^a  changed from  ^.3b  to  ^.3b",
     1031 		          db_data$names(namex), mc.regs.x(namex-8), substr(print_word2, 19, 18));
     1032 		end;
     1033 
     1034 	mcp -> mc.regs.x(namex-8)  =  substr( print_word2, 19, 18 );
     1035 
     1036 	return;
     1037 
     1038 assign_label(4):			/*	assign_user_reg	*/
     1039 
     1040 	if	print_mode  =  1
     1041 
     1042 		then	call	ioa_$ioa_stream (debug_output, "^a  changed from  ^w  to  ^w",
     1043 			          user_reg_names(userx), user_reg_values(userx), print_word2);
     1044 
     1045 	user_reg_values(userx)  =  print_word2;
     1046 
     1047 	return;
     1048 
     1049 assign_label(5):			/*	assign_aq		*/
     1050 
     1051 	if	print_mode  =  1
     1052 
     1053 		then	call	ioa_$ioa_stream (debug_output, "aq    changed from  ^w^w  to  ^w^w",
     1054 		   	          mcp -> mc.regs.a, mcp -> mc.regs.q, print_word1, print_word2);
     1055 
     1056 	mcp -> mc.regs.a  =  print_word1;
     1057 	mcp -> mc.regs.q  =  print_word2;
     1058 
     1059 	return;
     1060 
     1061 assign_label(6):			/*	assign_a		*/
     1062 
     1063 	if	print_mode  =  1
     1064 
     1065 		then	call	ioa_$ioa_stream (debug_output, "a     changed from  ^w  to  ^w",
     1066 				mcp -> mc.regs.a, print_word2);
     1067 
     1068 	mcp -> mc.regs.a  =  print_word2;
     1069 
     1070 	return;
     1071 
     1072 assign_label(7):			/*	assign_q		*/
     1073 
     1074 	if print_mode = 1 then
     1075 	call	ioa_$ioa_stream (debug_output, "q     changed from  ^w  to  ^w",
     1076 			          mcp -> mc.regs.q, print_word2);
     1077 
     1078 	mcp -> mc.regs.q  =  print_word2;
     1079 
     1080 	return;
     1081 
     1082 assign_label(8):			/*	assign_exp	*/
     1083 
     1084 	if	print_mode  =  1
     1085 		then  do;
     1086 		call	ioa_$ioa_stream (debug_output, "exp   changed from  ^.3b  to  ^.3b",
     1087 			     "0"b || mc.regs.e, "0"b || substr(print_word2, 29, 8));
     1088 		end;
     1089 
     1090 	mcp -> mc.regs.e  =  substr( print_word2, 29, 8 );
     1091 
     1092 	return;
     1093 
     1094 assign_label(9):			/*	assign_tr		*/
     1095 
     1096 	if	print_mode  =  1
     1097 		then  do;
     1098 		call	ioa_$ioa_stream (debug_output, "tr    changed from  ^.3b  to  ^.3b",
     1099 			     mc.regs.t, substr(print_word2, 10, 27));
     1100 		end;
     1101 
     1102 	mcp -> mc.regs.t  =  substr( print_word2, 10, 27 );
     1103 
     1104 	return;
     1105 
     1106 assign_label(10):			/*	assign_ralr	*/
     1107 
     1108 	if	print_mode  =  1
     1109 		then  do;
     1110 		call	ioa_$ioa_stream (debug_output, "ralr  changed from  ^.3b  to  ^.3b",
     1111 			     mc.regs.ralr, substr(print_word2, 34, 3));
     1112 		end;
     1113 
     1114 	mcp -> mc.regs.ralr  =  substr( print_word2, 34, 3 );
     1115 
     1116 	return;
     1117 
     1118 assign_label(11):			/*	assign_ppr	*/
     1119 
     1120 	work_ptr  =  addr( value );
     1121 
     1122 	if	print_mode  =  1
     1123 
     1124 		then  do;
     1125 		call	ioa_$ioa_stream (debug_output, "Old  ppr");
     1126 		call	print_ppr;
     1127 		end;
     1128 
     1129 	scup -> scu.ppr.psr  =  work_ptr -> its.segno;
     1130 	scup -> scu.ppr.prr  =  work_ptr -> its.ringno;
     1131 	scup -> scu.ppr.p  =  substr( value, 3,1 );
     1132 	scup -> scu.ilc  =  work_ptr -> its.offset;
     1133 
     1134 	if	print_mode  =  1
     1135 
     1136 		then  do;
     1137 		call	ioa_$ioa_stream (debug_output, "New  ppr");
     1138 		call	print_ppr;
     1139 		end;
     1140 
     1141 	return;
     1142 
     1143 assign_label(12):			/*	assign_tpr	*/
     1144 
     1145 	work_ptr  =  addr( value );
     1146 
     1147 	if	print_mode  =  1
     1148 
     1149 		then  do;
     1150 		call	ioa_$ioa_stream (debug_output, "Old  tpr");
     1151 		call	print_tpr;
     1152 		end;
     1153 
     1154 	scup -> scu.tpr.tsr  =  work_ptr -> its.segno;
     1155 	scup -> scu.tpr.trr  =  work_ptr -> its.ringno;
     1156 	scup -> scu.tpr_tbr  =  work_ptr -> its.bit_offset;
     1157 	scup -> scu.ca  =  work_ptr -> its.offset;
     1158 
     1159 	if	print_mode  =  1
     1160 
     1161 		then  do;
     1162 		call	ioa_$ioa_stream (debug_output, "New  tpr");
     1163 		call	print_tpr;
     1164 		end;
     1165 
     1166 	return;
     1167 
     1168 assign_label(13):			/*	assign_even	*/
     1169 
     1170 	if	print_mode  =  1
     1171 
     1172 		then  do;
     1173 		call	print_text_$format( addr( scup -> scu.even_inst), source_string);
     1174 		call	ioa_$ioa_stream (debug_output, "Old  even instruction:  ^a", source_string);
     1175 		end;
     1176 
     1177 	scup -> scu.even_inst  =  print_word2;
     1178 
     1179 	if	print_mode  =  1
     1180 
     1181 		then  do;
     1182 		call	print_text_$format( addr( scup -> scu.even_inst), source_string);
     1183 		call	ioa_$ioa_stream (debug_output, "New  even instruction:  ^a", source_string);
     1184 		end;
     1185 
     1186 	return;
     1187 
     1188 assign_label(14):			/*	assign_odd	*/
     1189 
     1190 	if	print_mode  =  1
     1191 
     1192 		then  do;
     1193 		call	print_text_$format( addr( scup -> scu.odd_inst), source_string);
     1194 		call	ioa_$ioa_stream (debug_output, "Old  odd instruction:  ^a", source_string);
     1195 		end;
     1196 
     1197 	scup -> scu.odd_inst  =  print_word2;
     1198 
     1199 	if	print_mode  =  1
     1200 
     1201 		then  do;
     1202 		call	print_text_$format( addr( scup -> scu.odd_inst), source_string);
     1203 		call	ioa_$ioa_stream (debug_output, "New  odd instruction:  ^a", source_string);
     1204 		end;
     1205 
     1206 	return;
     1207 
     1208 	end	db_regs;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1628.8  db_regs.pl1                       >dumps>old>recomp>db_regs.pl1
252          1    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
264          2    11/22/74  1603.5  db_data_map.incl.pl1              >ldd>include>db_data_map.incl.pl1
266          3    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
267          4    08/12/81  2025.8  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        24            based           bit(36)                  level 3 packed unaligned dcl 4-12 set ref 543* 655*
                                                                                  661* 817 911 920 1049* 1056* 1061* 1068*
a_part                    0(08)        based           bit(36)                  level 2 packed unaligned dcl 106 set ref 817*
addr                                                   builtin function         dcl 262 ref 389 471 474 783 783 799 799 814 817 818
                                                                                  826 888 959 971 1015 1022 1118 1143 1173 1173 1182
                                                                                  1182 1193 1193 1202 1202
based_ptr                              based           pointer                  dcl 122 set ref 1015*
bit_offset                1(21)        based           bit(6)                   level 2 packed unaligned dcl 3-5 set ref 976* 1156
block                                  based           bit(36)                  array unaligned dcl 114 set ref 862* 862* 862* 862*
                                                                                  865* 865* 865* 865*
block_ptr                       000100 automatic       pointer                  dcl 51 set ref 471* 474* 475 580* 862 862 862 862
                                                                                  865 865 865 865
ca                        5            based           bit(18)                  level 2 packed unaligned dcl 4-56 set ref 765* 977
                                                                                  1157*
db_data$n_regs                  000100 external static fixed bin(17,0)          dcl 2-8 ref 378
db_data$names                   000102 external static char(4)                  array dcl 2-10 set ref 380 502* 530* 622* 633* 1009*
                                                                                  1015* 1030*
db_ext_stat_$db_ext_stat_       000070 external static structure                level 1 dcl 1-9
db_mc_ptr                              parameter       pointer                  dcl 27 ref 271 289 305 367 380
debug_output             10     000070 external static char(32)                 level 2 dcl 1-9 set ref 339* 347* 416* 423* 442*
                                                                                  458* 469* 476* 499* 502* 527* 530* 537* 539* 543*
                                                                                  570* 573* 577* 602* 607* 611* 622* 633* 644* 655*
                                                                                  661* 668* 686* 705* 723* 740* 743* 762* 765* 785*
                                                                                  801* 820* 845* 862* 865* 1009* 1015* 1030* 1038*
                                                                                  1049* 1061* 1072* 1086* 1098* 1110* 1125* 1137*
                                                                                  1150* 1162* 1174* 1183* 1194* 1203*
delim                           000106 automatic       char(2)                  unaligned dcl 58 set ref 828* 839* 841*
e                        26            based           bit(8)                   level 3 packed unaligned dcl 4-12 set ref 686 814
                                                                                  936 1086 1090*
eight_words                            based           bit(288)                 dcl 115 ref 475
eis_info                 50            based           bit(36)                  array level 2 packed unaligned dcl 4-12 set ref 474
even_inst                 6            based           bit(36)                  level 2 dcl 4-56 set ref 783 783 983 1173 1173 1177*
                                                                                  1182 1182
exponent                               based           bit(8)                   level 2 packed unaligned dcl 106 set ref 814*
float_overlay                          based           structure                level 1 dcl 106
float_val                       000142 automatic       float bin(63)            dcl 93 set ref 814 817 818 820*
get_ass_label_table             000063 constant        fixed bin(17,0)          initial array dcl 173 ref 298 316
i                               000111 automatic       fixed bin(17,0)          dcl 60 set ref 501* 502 502* 529* 530 530* 610* 611
                                                                                  611* 834* 836 839*
ilc                       4            based           bit(18)                  level 2 packed unaligned dcl 4-56 set ref 743* 965
                                                                                  1132*
ind_bits                               based           bit(14)                  unaligned dcl 124 ref 831 836
ind_names                       000010 internal static char(4)                  initial array unaligned dcl 204 set ref 839*
indp                            000104 automatic       pointer                  dcl 56 set ref 826* 831 836
ioa_$ioa_stream                 000074 constant        entry                    external dcl 254 ref 339 347 416 423 442 458 469 476
                                                                                  499 502 527 530 537 539 543 570 573 577 602 607
                                                                                  611 622 633 644 655 661 668 686 705 723 740 743
                                                                                  762 765 785 801 820 845 862 865 1009 1015 1030
                                                                                  1038 1049 1061 1072 1086 1098 1110 1125 1137 1150
                                                                                  1162 1174 1183 1194 1203
ioa_$rsnnl                      000076 constant        entry                    external dcl 258 ref 839
ir                        4(18)        based           structure                level 2 packed unaligned dcl 4-56 set ref 826
its                                    based           structure                level 1 dcl 3-5
len                             000112 automatic       fixed bin(17,0)          dcl 67 set ref 839*
mask                     40            based           bit(72)                  level 2 packed unaligned dcl 4-12 set ref 471
max_num_user_regs                      constant        fixed bin(17,0)          initial dcl 234 ref 420
mc                                     based           structure                level 1 dcl 4-12
mcp                             000146 automatic       pointer                  dcl 4-10 set ref 367* 389 471 474 502 530 537 537
                                                                                  537 537 539 539 539 539 543 543 622 633 655 655
                                                                                  661 668 686 705 723 814 817 818 888 896 911 914
                                                                                  920 928 936 943 951 1015 1022 1030 1034 1049 1049
                                                                                  1056 1057 1061 1068 1072 1078 1086 1090 1098 1102
                                                                                  1110 1114
name                                   parameter       char(4)                  dcl 27 set ref 271 289 305 380 404 416* 423* 435
                                                                                  442*
namex                           000107 automatic       fixed bin(17,0)          dcl 60 set ref 282 298 316 378* 380* 417* 424* 622
                                                                                  622 633 633 888 896 1009 1015 1015 1022 1030 1030
                                                                                  1034
num_user_regs                   000026 internal static fixed bin(17,0)          initial dcl 234 set ref 402 432* 599 610
odd_inst                  7            based           bit(36)                  level 2 dcl 4-56 set ref 799 799 991 1193 1193 1197*
                                                                                  1202 1202
offset                    1            based           bit(18)                  level 2 packed unaligned dcl 3-5 set ref 965* 977*
                                                                                  1132 1157
p                         0(18)        based           bit(1)                   level 3 packed unaligned dcl 4-56 set ref 743* 964
                                                                                  1131*
ppr                                    based           structure                level 2 packed unaligned dcl 4-56
print_label_table               000126 constant        fixed bin(17,0)          initial array dcl 145 ref 282
print_mode                             parameter       fixed bin(17,0)          dcl 27 ref 271 289 305 339 442 458 469 476 523 567
                                                                                  602 607 740 762 1015 1026 1038 1049 1061 1072 1082
                                                                                  1094 1106 1122 1134 1147 1159 1168 1179 1188 1199
print_request                   000144 automatic       bit(1)                   initial unaligned dcl 96 set ref 96* 273* 415
print_text_$format              000072 constant        entry                    external dcl 254 ref 783 799 1173 1182 1193 1202
print_word1                     000136 automatic       bit(36)                  initial unaligned dcl 85 set ref 85* 311* 1049* 1056
print_word2                     000137 automatic       bit(36)                  initial unaligned dcl 85 set ref 85* 312* 1030 1030
                                                                                  1034 1038* 1045 1049* 1057 1061* 1068 1072* 1078
                                                                                  1086 1090 1098 1098 1102 1110 1110 1114 1177 1197
print_word3                     000140 automatic       bit(36)                  initial unaligned dcl 85 set ref 85*
print_word4                     000141 automatic       bit(36)                  initial unaligned dcl 85 set ref 85*
prr                                    based           bit(3)                   level 3 packed unaligned dcl 4-56 set ref 743* 963
                                                                                  1130*
prs                                    based           pointer                  array level 2 dcl 4-12 set ref 502* 622* 888 1015*
                                                                                  1022
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 4-56 set ref 743* 962
                                                                                  1129*
ptr_bit_string                         based           bit(72)                  unaligned dcl 120 set ref 888 1022*
q                        25            based           bit(36)                  level 3 packed unaligned dcl 4-12 set ref 543* 655*
                                                                                  668* 818 914 928 1049* 1057* 1072* 1078*
q_part                    1(08)        based           bit(27)                  level 2 packed unaligned dcl 106 set ref 818*
ralr                     27(33)        based           bit(3)                   level 3 packed unaligned dcl 4-12 set ref 723* 951
                                                                                  1110* 1114*
regs                     20            based           structure                level 2 packed unaligned dcl 4-12
ringno                    0(18)        based           bit(3)                   level 2 packed unaligned dcl 3-5 set ref 963* 975*
                                                                                  1130 1155
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed unaligned
                                                                                  dcl 4-12 in procedure "db_regs" set ref 389
scu                                    based           structure                level 1 dcl 4-56 in procedure "db_regs"
scup                            000150 automatic       pointer                  dcl 4-54 set ref 389* 580 743 743 743 743 765 765
                                                                                  765 765 783 783 799 799 826 962 963 964 965 974
                                                                                  975 976 977 983 991 1129 1130 1131 1132 1154 1155
                                                                                  1156 1157 1173 1173 1177 1182 1182 1193 1193 1197
                                                                                  1202 1202
segno                     0(03)        based           bit(15)                  level 2 packed unaligned dcl 3-5 set ref 962* 974*
                                                                                  1129 1154
source_string                   000113 automatic       varying char(72)         dcl 74 set ref 783* 785* 799* 801* 829* 831* 839*
                                                                                  839* 845* 1173* 1174* 1182* 1183* 1193* 1194*
                                                                                  1202* 1203*
substr                                                 builtin function         dcl 262 set ref 311 312 836 896* 903* 911* 914* 920*
                                                                                  928* 936* 943* 951* 964* 983* 991* 1030 1030 1034
                                                                                  1086 1090 1098 1098 1102 1110 1110 1114 1131
t                        27            based           bit(27)                  level 3 packed unaligned dcl 4-12 set ref 705* 943
                                                                                  1098* 1102*
tpr                       2            based           structure                level 2 packed unaligned dcl 4-56
tpr_tbr                   3(30)        based           bit(6)                   level 2 packed unaligned dcl 4-56 set ref 765* 976
                                                                                  1156*
trr                       2            based           bit(3)                   level 3 packed unaligned dcl 4-56 set ref 765* 975
                                                                                  1155*
tsr                       2(03)        based           bit(15)                  level 3 packed unaligned dcl 4-56 set ref 765* 974
                                                                                  1154*
user_reg_names                  000027 internal static char(4)                  array unaligned dcl 239 set ref 404 435* 611* 644*
                                                                                  1038*
user_reg_values                 000047 internal static bit(36)                  array unaligned dcl 241 set ref 437* 611* 644* 903
                                                                                  1038* 1045*
userx                           000110 automatic       fixed bin(17,0)          dcl 60 set ref 402* 404* 420 432 435 437 644 644 903
                                                                                  1038 1038 1045
value                                  parameter       bit(72)                  dcl 27 set ref 289 295* 305 311 312 888* 896* 903*
                                                                                  911* 914* 920* 928* 936* 943* 951* 959 964* 971
                                                                                  983* 991* 1015 1022 1118 1131 1143
work_ptr                        000102 automatic       pointer                  dcl 51 set ref 959* 962 963 965 971* 974 975 976 977
                                                                                  1118* 1129 1130 1132 1143* 1154 1155 1156 1157
x                        20            based           bit(18)                  array level 3 packed unaligned dcl 4-12 set ref 530*
                                                                                  537* 537* 537* 537* 539* 539* 539* 539* 633* 896
                                                                                  1030* 1034*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-55
abx                                    internal static fixed bin(17,0)          initial dcl 4-42
apx                                    internal static fixed bin(17,0)          initial dcl 4-42
bbx                                    internal static fixed bin(17,0)          initial dcl 4-42
bpx                                    internal static fixed bin(17,0)          initial dcl 4-42
db_data$acv_names                      external static char(24)                 array dcl 2-16
db_data$fault_names                    external static char(20)                 array dcl 2-14
db_data$ipr_names                      external static char(24)                 array dcl 2-18
db_data$tags                           external static char(4)                  array dcl 2-12
db_ext_stat_$break_instructions        external static bit(36)                  array dcl 1-27
itp                                    based           structure                level 1 dcl 3-18
itp_unsigned                           based           structure                level 1 dcl 3-43
its_unsigned                           based           structure                level 1 dcl 3-30
lbx                                    internal static fixed bin(17,0)          initial dcl 4-42
lpx                                    internal static fixed bin(17,0)          initial dcl 4-42
sbx                                    internal static fixed bin(17,0)          initial dcl 4-42
scux                                   based           structure                level 1 dcl 4-206
spx                                    internal static fixed bin(17,0)          initial dcl 4-42

NAMES DECLARED BY EXPLICIT CONTEXT.
assign                          001030 constant        entry                    external dcl 305
assign_label                    000000 constant        label                    array(0:14) dcl 326 ref 316
db_regs                         000745 constant        entry                    external dcl 11
get                             001004 constant        entry                    external dcl 289
get_label                       000017 constant        label                    array(0:14) dcl 326 ref 298
get_namex                       003163 constant        entry                    internal dcl 353 ref 275 292 308
no_mc_data                      001054 constant        label                    dcl 339 ref 380
print                           000760 constant        entry                    external dcl 271
print_block                     004676 constant        entry                    internal dcl 860 ref 472 478 581
print_even                      004434 constant        entry                    internal dcl 781 ref 574 776
print_exp                       004126 constant        entry                    internal dcl 684 ref 545 679
print_ind                       004550 constant        entry                    internal dcl 824 ref 576 807
print_label                     000036 constant        label                    array(0:20) dcl 326 ref 282
print_odd                       004502 constant        entry                    internal dcl 797 ref 575 791
print_ppr                       004246 constant        entry                    internal dcl 738 ref 571 732 1126 1138
print_prs                       003361 constant        entry                    internal dcl 497 ref 463 491
print_ralr                      004213 constant        entry                    internal dcl 721 ref 547 715
print_regs                      003445 constant        entry                    internal dcl 521 ref 465 515
print_scu                       003707 constant        entry                    internal dcl 565 ref 467 559
print_tpr                       004341 constant        entry                    internal dcl 760 ref 572 754 1151 1163
print_tr                        004164 constant        entry                    internal dcl 703 ref 546 697
print_user_regs                 004006 constant        entry                    internal dcl 597 ref 481 591

NAME DECLARED BY CONTEXT OR IMPLICATION.
null                                                   builtin function         ref 380

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5120        5224    5006        5130
Length      5572    5006       104         332     111          60

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_regs                             770 external procedure  is an external procedure.  
get_namex                               internal procedure  shares stack frame of external procedure db_regs.  
print_prs                               internal procedure  shares stack frame of external procedure db_regs.  
print_regs                              internal procedure  shares stack frame of external procedure db_regs.  
print_scu                               internal procedure  shares stack frame of external procedure db_regs.  
print_user_regs                         internal procedure  shares stack frame of external procedure db_regs.  
print_exp                               internal procedure  shares stack frame of external procedure db_regs.  
print_tr                                internal procedure  shares stack frame of external procedure db_regs.  
print_ralr                              internal procedure  shares stack frame of external procedure db_regs.  
print_ppr                               internal procedure  shares stack frame of external procedure db_regs.  
print_tpr                               internal procedure  shares stack frame of external procedure db_regs.  
print_even                              internal procedure  shares stack frame of external procedure db_regs.  
print_odd                               internal procedure  shares stack frame of external procedure db_regs.  
print_ind                               internal procedure  shares stack frame of external procedure db_regs.  
print_block                             internal procedure  shares stack frame of external procedure db_regs.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ind_names                   db_regs
000026 num_user_regs               db_regs
000027 user_reg_names              db_regs
000047 user_reg_values             db_regs

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_regs                  000100 block_ptr                   db_regs
                         000102 work_ptr                    db_regs
                         000104 indp                        db_regs
                         000106 delim                       db_regs
                         000107 namex                       db_regs
                         000110 userx                       db_regs
                         000111 i                           db_regs
                         000112 len                         db_regs
                         000113 source_string               db_regs
                         000136 print_word1                 db_regs
                         000137 print_word2                 db_regs
                         000140 print_word3                 db_regs
                         000141 print_word4                 db_regs
                         000142 float_val                   db_regs
                         000144 print_request               db_regs
                         000146 mcp                         db_regs
                         000150 scup                        db_regs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$ioa_stream               ioa_$rsnnl                    print_text_$format

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_data$n_regs                db_data$names                 db_ext_stat_$db_ext_stat_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     85 000735        96 000741        11 000744       271 000753       273 000771       275 000773       282 000774
    289 000777       292 001015       295 001016       298 001023       305 001026       308 001041       311 001042
    312 001045       316 001050       326 001053       339 001054       347 001101       351 001122       458 001123
    463 001145       465 001146       467 001147       469 001150       471 001173       472 001176       474 001177
    475 001202       476 001206       478 001233       481 001234       483 001235       491 001236       494 001237
    515 001240       518 001241       559 001242       562 001243       591 001244       594 001245       622 001246
    625 001301       633 001302       636 001337       644 001340       647 001371       655 001372       658 001424
    661 001425       664 001452       668 001453       671 001500       679 001501       682 001502       697 001503
    700 001504       715 001505       718 001506       732 001507       735 001510       754 001511       757 001512
    776 001513       779 001514       791 001515       794 001516       807 001517       810 001520       814 001521
    817 001526       818 001534       820 001541       821 001565       881 001566       888 001567       891 001577
    896 001600       899 001606       903 001607       906 001613       911 001614       914 001617       915 001621
    920 001622       923 001625       928 001626       931 001631       936 001632       939 001640       943 001641
    946 001645       951 001646       954 001653       959 001654       962 001656       963 001662       964 001667
    965 001674       966 001677       971 001700       974 001702       975 001707       976 001714       977 001721
    978 001723       983 001724       986 001727       991 001730       994 001733      1009 001734      1013 001762
   1015 001763      1022 002025      1024 002037      1026 002040      1030 002043      1034 002107      1036 002115
   1038 002116      1045 002157      1047 002163      1049 002164      1056 002226      1057 002231      1059 002233
   1061 002234      1068 002270      1070 002273      1072 002274      1078 002330      1080 002333      1082 002334
   1086 002337      1090 002400      1092 002406      1094 002407      1098 002412      1102 002447      1104 002453
   1106 002454      1110 002457      1114 002516      1116 002523      1118 002524      1122 002526      1125 002531
   1126 002551      1129 002552      1130 002556      1131 002563      1132 002571      1134 002575      1137 002600
   1138 002620      1141 002621      1143 002622      1147 002624      1150 002627      1151 002647      1154 002650
   1155 002655      1156 002662      1157 002666      1159 002670      1162 002673      1163 002713      1166 002714
   1168 002715      1173 002720      1174 002740      1177 002765      1179 002770      1182 002773      1183 003012
   1186 003037      1188 003040      1193 003043      1194 003063      1197 003110      1199 003113      1202 003116
   1203 003135      1206 003162       353 003163       367 003164       378 003170       380 003177       389 003210
    390 003213       393 003214       402 003216       404 003226       406 003234       415 003236       416 003240
    417 003266       418 003270       420 003271       423 003273       424 003321       425 003323       432 003324
    435 003326       437 003331       442 003332       447 003360       497 003361       499 003362       501 003403
    502 003407       503 003442       505 003444       521 003445       523 003446       527 003450       529 003471
    530 003475       531 003533       532 003535       537 003536       539 003603       543 003650       545 003703
    546 003704       547 003705       549 003706       565 003707       567 003710       570 003712       571 003734
    572 003735       573 003736       574 003756       575 003757       576 003760       577 003761       580 004002
    581 004004       583 004005       597 004006       599 004007       602 004012       604 004034       607 004035
    610 004062       611 004072       612 004123       614 004125       684 004126       686 004127       688 004163
    703 004164       705 004165       707 004212       721 004213       723 004214       725 004245       738 004246
    740 004247       743 004272       746 004340       760 004341       762 004342       765 004365       768 004433
    781 004434       783 004435       785 004455       787 004501       797 004502       799 004503       801 004523
    803 004547       824 004550       826 004551       828 004556       829 004560       831 004561       834 004572
    836 004577       839 004604       841 004643       843 004645       845 004647       847 004675       860 004676
    862 004677       865 004741       868 005001


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
